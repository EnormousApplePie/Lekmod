; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod Files\Lekmod DLL versions\v29\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTacticalAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG219922 DB	'Type', 00H
$SG221574 DB	00H
	ORG $+2
$SG219924 DB	'Priority', 00H
	ORG $+3
$SG219925 DB	'OffenseFlavorWeight', 00H
$SG219926 DB	'DefenseFlavorWeight', 00H
$SG219927 DB	'OperationsCanRecruit', 00H
	ORG $+3
$SG219928 DB	'DominanceZoneMove', 00H
	ORG $+2
$SG220174 DB	'TACTICAL_UNASSIGNED', 00H
$SG220175 DB	'TACTICAL_POSTURE_SIT_AND_BOMBARD', 00H
	ORG $+3
$SG220176 DB	'TACTICAL_POSTURE_ATTRIT_FROM_RANGE', 00H
	ORG $+1
$SG220177 DB	'TACTICAL_POSTURE_EXPLOIT_FLANKS', 00H
$SG220178 DB	'TACTICAL_POSTURE_STEAMROLL', 00H
	ORG $+1
$SG220179 DB	'TACTICAL_POSTURE_SURGICAL_CITY_STRIKE', 00H
	ORG $+2
$SG220180 DB	'TACTICAL_POSTURE_COUNTERATTACK', 00H
	ORG $+1
$SG220181 DB	'TACTICAL_MOVE_NONCOMBATANTS_TO_SAFETY', 00H
	ORG $+2
$SG220182 DB	'TACTICAL_CAPTURE_CITY', 00H
	ORG $+2
$SG220183 DB	'TACTICAL_DAMAGE_CITY', 00H
	ORG $+3
$SG220184 DB	'TACTICAL_DESTROY_HIGH_UNIT', 00H
	ORG $+1
$SG220185 DB	'TACTICAL_DESTROY_MEDIUM_UNIT', 00H
	ORG $+3
$SG220186 DB	'TACTICAL_DESTROY_LOW_UNIT', 00H
	ORG $+2
$SG220187 DB	'TACTICAL_TO_SAFETY', 00H
	ORG $+1
$SG220188 DB	'TACTICAL_ATTRIT_HIGH_UNIT', 00H
	ORG $+2
$SG220189 DB	'TACTICAL_ATTRIT_MEDIUM_UNIT', 00H
$SG220190 DB	'TACTICAL_ATTRIT_LOW_UNIT', 00H
	ORG $+3
$SG220191 DB	'TACTICAL_REPOSITION', 00H
$SG220192 DB	'TACTICAL_BARBARIAN_CAMP', 00H
$SG220193 DB	'TACTICAL_PILLAGE', 00H
	ORG $+3
$SG220194 DB	'TACTICAL_ATTACK_VERY_HIGH_PRIORITY_CIVILIAN', 00H
$SG220195 DB	'TACTICAL_ATTACK_HIGH_PRIORITY_CIVILIAN', 00H
	ORG $+1
$SG220196 DB	'TACTICAL_ATTACK_MEDIUM_PRIORITY_CIVILIAN', 00H
	ORG $+3
$SG220197 DB	'TACTICAL_ATTACK_LOW_PRIORITY_CIVILIAN', 00H
	ORG $+2
$SG220198 DB	'TACTICAL_SAFE_BOMBARDS', 00H
	ORG $+1
$SG220199 DB	'TACTICAL_HEAL', 00H
	ORG $+2
$SG220200 DB	'TACTICAL_ANCIENT_RUINS', 00H
	ORG $+1
$SG220201 DB	'TACTICAL_GARRISON_TO_ALLOW_BOMBARD', 00H
	ORG $+1
$SG220202 DB	'TACTICAL_GARRISON_ALREADY_THERE', 00H
$SG220203 DB	'TACTICAL_BASTION_ALREADY_THERE', 00H
	ORG $+1
$SG220204 DB	'TACTICAL_GUARD_IMPROVEMENT_ALREADY_THERE', 00H
	ORG $+3
$SG220205 DB	'TACTICAL_GARRISON_1_TURN', 00H
	ORG $+3
$SG220206 DB	'TACTICAL_BASTION_1_TURN', 00H
$SG220207 DB	'TACTICAL_GUARD_IMPROVEMENT_1_TURN', 00H
	ORG $+2
$SG220208 DB	'TACTICAL_AIR_INTERCEPT', 00H
	ORG $+1
$SG220209 DB	'TACTICAL_AIR_SWEEP', 00H
	ORG $+1
$SG220210 DB	'TACTICAL_POSTURE_HEDGEHOG', 00H
	ORG $+2
$SG220211 DB	'TACTICAL_POSTURE_WITHDRAW', 00H
	ORG $+2
$SG220212 DB	'TACTICAL_POSTURE_SHORE_BOMBARDMENT', 00H
	ORG $+1
$SG220213 DB	'TACTICAL_CLOSE_ON_TARGET', 00H
	ORG $+3
$SG220214 DB	'TACTICAL_MOVE_OPERATIONS', 00H
	ORG $+3
$SG220215 DB	'TACTICAL_EMERGENCY_PURCHASES', 00H
	ORG $+3
$SG220216 DB	'TACTICAL_ESCORT_EMBARKED_UNIT', 00H
	ORG $+2
$SG220217 DB	'TACTICAL_PLUNDER_TRADE_UNIT', 00H
$SG220218 DB	'TACTICAL_PARK_ON_TRADE_ROUTE', 00H
	ORG $+3
$SG220219 DB	'TACTICAL_DEFENSIVE_AIRLIFT', 00H
	ORG $+1
$SG220220 DB	'TACTICAL_PILLAGE_CITADEL', 00H
	ORG $+3
$SG220221 DB	'TACTICAL_PILLAGE_RESOURCE', 00H
	ORG $+2
$SG220222 DB	'TACTICAL_PILLAGE_CITADEL_NEXT_TURN', 00H
	ORG $+1
$SG220223 DB	'TACTICAL_PILLAGE_RESOURCE_NEXT_TURN', 00H
$SG220224 DB	'TACTICAL_PILLAGE_NEXT_TURN', 00H
	ORG $+1
$SG220225 DB	'MUPOSITION_CIVILIAN_SUPPORT', 00H
$SG220226 DB	'MUPOSITION_NAVAL_ESCORT', 00H
$SG220227 DB	'MUPOSITION_BOMBARD', 00H
	ORG $+1
$SG220228 DB	'MUPOSITION_FRONT_LINE', 00H
	ORG $+6
$SG220395 DB	'Queued attack with %s, To X: %d, To Y: %d, From X: %d, F'
	DB	'rom Y: %d', 00H
	ORG $+6
$SG220421 DB	'Made initial ranged attack with %s, at X: %d, Y: %d, vs.'
	DB	' target at X: %d, Y: %d', 00H
$SG220423 DB	'Made follow-on ranged attack with %s, at X: %d, Y: %d, v'
	DB	's. target at X: %d, Y: %d', 00H
	ORG $+6
$SG220426 DB	'Made initial attack with %s, at X: %d, Y: %d, vs. target'
	DB	' at X: %d, Y: %d', 00H
	ORG $+7
$SG220428 DB	'Made follow-on attack with %s, at X: %d, Y: %d, vs. targ'
	DB	'et at X: %d, Y: %d', 00H
	ORG $+1
$SG220678 DB	'Zone ID: %d, ', 00H
	ORG $+2
$SG220684 DB	'Sit and Bombard', 00H
$SG220686 DB	'Attrit from Range', 00H
	ORG $+2
$SG220688 DB	'Exploit Flanks', 00H
	ORG $+1
$SG220690 DB	'Steamroll', 00H
	ORG $+2
$SG220692 DB	'Surgical City Strike', 00H
	ORG $+3
$SG220694 DB	'Hedgehog', 00H
	ORG $+3
$SG220696 DB	'Counterattack', 00H
	ORG $+2
$SG220698 DB	'Withdraw', 00H
	ORG $+3
$SG220700 DB	'Shore Bombardment', 00H
	ORG $+2
$SG220843 DB	'Tactical AI Move Priority', 00H
	ORG $+2
$SG220969 DB	'TACTICAL_CLOSE_ON_TARGET', 00H
	ORG $+3
$SG220972 DB	'TACTICAL_POSTURE_WITHDRAW', 00H
	ORG $+2
$SG220975 DB	'TACTICAL_POSTURE_HEDGEHOG', 00H
	ORG $+2
$SG220978 DB	'TACTICAL_POSTURE_SHORE_BOMBARDMENT', 00H
	ORG $+1
$SG220981 DB	'TACTICAL_EMERGENCY_PURCHASES', 00H
	ORG $+3
$SG220984 DB	'TACTICAL_DEFENSIVE_AIRLIFT', 00H
	ORG $+1
$SG220987 DB	'TACTICAL_OFFENSIVE_POSTURE_MOVES', 00H
	ORG $+3
$SG221220 DB	'Attacking city of ', 00H
	ORG $+1
$SG221221 DB	' to capture, X: %d, Y: %d,', 00H
	ORG $+1
$SG221246 DB	'Attacking city of ', 00H
	ORG $+1
$SG221247 DB	' to damage, X: %d, Y: %d,', 00H
	ORG $+2
$SG221261 DB	'Removing barbarian camp, X: %d, Y: %d', 00H
	ORG $+2
$SG221288 DB	'Unknown Unit Type', 00H
	ORG $+2
$SG221294 DB	'Looking at damaging high priority %s, X: %d, Y: %d,', 00H
$SG221296 DB	'Looking at damaging medium priority %s, X: %d, Y: %d,', 00H
	ORG $+2
$SG221298 DB	'Looking at damaging low priority %s, X: %d, Y: %d,', 00H
	ORG $+1
$SG221314 DB	'Looking at killing high priority %s, X: %d, Y: %d,', 00H
	ORG $+1
$SG221316 DB	'Looking at killing medium priority %s, X: %d, Y: %d,', 00H
	ORG $+3
$SG221318 DB	'Looking at killing low priority %s, X: %d, Y: %d,', 00H
	ORG $+2
$SG221533 DB	'Plundering trade unit, X: %d, Y: %d', 00H
$SG221577 DB	'Citadel', 00H
$SG221580 DB	'Improved Resource', 00H
	ORG $+2
$SG221582 DB	'Improvement', 00H
$SG221591 DB	'Paratrooping in to pillage %s, X: %d, Y: %d', 00H
$SG221596 DB	'Pillaging %s, X: %d, Y: %d', 00H
	ORG $+1
$SG221601 DB	'Moving toward %s for pillage, X: %d, Y: %d', 00H
	ORG $+1
$SG221648 DB	'Plundering trade unit, X: %d, Y: %d', 00H
$SG221660 DB	'Blockading naval resource(s) with move to, X: %d, Y: %d', 00H
$SG221678 DB	'Attacking very high priority civilian, X: %d, Y: %d', 00H
$SG221680 DB	'Attacking high priority civilian, X: %d, Y: %d', 00H
	ORG $+1
$SG221682 DB	'Attacking medium priority civilian, X: %d, Y: %d', 00H
	ORG $+3
$SG221684 DB	'Attacking low priority civilian, X: %d, Y: %d', 00H
	ORG $+2
$SG221728 DB	'Healing at, X: %d, Y: %d', 00H
	ORG $+3
$SG221741 DB	'Moving to protect camp, X: %d, Y: %d', 00H
	ORG $+3
$SG221758 DB	'Garrison, X: %d, Y: %d, Priority: %d, Turns Away: %d', 00H
	ORG $+3
$SG221760 DB	', Allows bombard', 00H
	ORG $+3
$SG221774 DB	'Bastion, X: %d, Y: %d, Priority: %d, Turns Away: %d', 00H
$SG221788 DB	'Guard Improvement, X: %d, Y: %d, Turns Away: %d', 00H
$SG221802 DB	'Moving to goody hut, X: %d, Y: %d, Turns Away: %d', 00H
	ORG $+2
$SG221831 DB	'Ready to intercept enemy air units at, X: %d, Y: %d', 00H
$SG221859 DB	'Ready to air sweep enemy air units at, X: %d, Y: %d', 00H
$SG221929 DB	'Airlifting %s to city of %s, Current X: %d, Current Y: %'
	DB	'd', 00H
	ORG $+2
$SG222154 DB	'Unassigned %s at, X: %d, Y: %d', 00H
	ORG $+1
$SG222181 DB	'Moving escorting %s to civilian for operation, Civilian '
	DB	'X: %d, Civilian Y: %d, X: %d, Y: %d', 00H
$SG222219 DB	'Moving %s without escort to target, X: %d, Y: %d', 00H
	ORG $+3
$SG222198 DB	'Moving escorting %s to open hex, Open hex X: %d, Open he'
	DB	'x Y: %d, X: %d, Y: %d', 00H
	ORG $+2
$SG222199 DB	'Moving %s to open hex, Open hex X: %d, Open hex Y: %d, X'
	DB	': %d, Y: %d', 00H
$SG222228 DB	'Moving %s to target, X: %d, Y: %d', 00H
	ORG $+2
$SG222203 DB	'Retargeting civilian escort operation. No empty tile adj'
	DB	'acent to civilian to meet.', 00H
	ORG $+5
$SG222212 DB	'Retargeting civilian escort operation (path lost to targ'
	DB	'et), X: %d, Y: %d', 00H
	ORG $+2
$SG222229 DB	'Moving escorting %s to target, X: %d, Y: %d', 00H
$SG222239 DB	'Retargeting civilian escort operation (path lost to targ'
	DB	'et), X: %d, Y: %d', 00H
	ORG $+2
$SG222248 DB	'Moving escorting %s to target, X: %d, Y: %d', 00H
$SG222249 DB	'Moving %s to target, X: %d, Y: %d', 00H
	ORG $+6
$SG222253 DB	'Retargeting civilian escort operation. Too many blocking'
	DB	' units.', 00H
$SG222262 DB	'Moving escorting %s to target, X: %d, Y: %d', 00H
$SG222263 DB	'Moving %s to target, X: %d, Y: %d', 00H
	ORG $+2
$SG222267 DB	'Retargeting civilian escort operation. Could not move bl'
	DB	'ocking unit.', 00H
	ORG $+3
$SG222390 DB	'City founded, At X=%d, At Y=%d', 00H
	ORG $+1
$SG222400 DB	'Moving %s to target, X: %d, Y: %d', 00H
	ORG $+2
$SG222406 DB	'Moving %s to target, X: %d, Y: %d', 00H
	ORG $+2
$SG222419 DB	'Moving %s near target, Now at X: %d, Y: %d', 00H
	ORG $+5
$SG222446 DB	'Retargeting naval escort operation (no unit in water!), '
	DB	'X: %d, Y: %d', 00H
	ORG $+3
$SG222481 DB	'Retargeting naval escort operation (path lost to target)'
	DB	', X: %d, Y: %d', 00H
	ORG $+1
$SG222501 DB	'Retargeting naval escort operation (path lost to target)'
	DB	', X: %d, Y: %d', 00H
	ORG $+1
$SG222529 DB	'Retargeting naval escort operation (no unit in water!), '
	DB	'X: %d, Y: %d', 00H
	ORG $+3
$SG222644 DB	'Operation aborting. Army ID: %d. Not enough spaces to de'
	DB	'ploy near target', 00H
	ORG $+3
$SG222667 DB	'No gather move for %d units', 00H
$SG222691 DB	'Operation aborting. Army ID: %d. Not enough spaces to de'
	DB	'ploy along formation''s path', 00H
$SG222714 DB	'No army deployment move for %d melee units', 00H
	ORG $+1
$SG222709 DB	'Deploying melee unit, %s, To X: %d, To Y: %d, At X: %d, '
	DB	'At Y: %d', 00H
	ORG $+7
$SG222731 DB	'Deploying ranged unit, %s, To X: %d, To Y: %d, At X: %d,'
	DB	' At Y: %d', 00H
	ORG $+6
$SG222747 DB	'Deploying ranged unit (Pass 2), %s, To X: %d, To Y: %d, '
	DB	'At X: %d, At Y: %d', 00H
	ORG $+1
$SG222752 DB	'No army deployment move for %d ranged units', 00H
$SG222889 DB	'Operation aborting. Army ID: %d. Not enough spaces to de'
	DB	'ploy near turn target', 00H
	ORG $+2
$SG222909 DB	'No naval deployment move for %d units in first pass', 00H
$SG222933 DB	'No naval deployment move for %d units in second pass', 00H
	ORG $+3
$SG223273 DB	'Set up %s for ranged attack', 00H
$SG223283 DB	'Not attacking with unit. We''ll destroy ourself, %s, X: '
	DB	'%d, Y: %d', 00H
	ORG $+3
$SG223287 DB	'Not attacking with unit. Can''t generate a good damage r'
	DB	'atio.', 00H
	ORG $+7
$SG223483 DB	'Not enough free hexes next for all melee units to attack'
	DB	', Target X: %d, Y: %d', 00H
	ORG $+2
$SG223488 DB	'Moving adjacent for attack next turn, Now at X: %d, Y: %'
	DB	'd', 00H
	ORG $+6
$SG223497 DB	'Not attacking with unit. We''ll destroy ourself, %s, X: '
	DB	'%d, Y: %d', 00H
	ORG $+3
$SG223501 DB	'Not attacking with unit. Can''t generate a good damage r'
	DB	'atio.', 00H
	ORG $+7
$SG223521 DB	'%s moved to empty space near target, X: %d, Y: %d, Curre'
	DB	'nt X: %d, Current Y: %d', 00H
$SG223817 DB	'Moving %s to safety, To X: %d, Y: %d, From X: %d, Y: %d', 00H
$SG223822 DB	'Failed to find destination moving %s to safety from, X: '
	DB	'%d, Y: %d', 00H
	ORG $+6
$SG223858 DB	'%s moved to empty space near target, X: %d, Y: %d, Curre'
	DB	'nt X: %d, Current Y: %d', 00H
$SG223862 DB	'No target for %s at position, Current X: %d, Current Y: '
	DB	'%d', 00H
	ORG $+5
$SG223876 DB	'Moving %s to new position, X: %d, Y: %d, Current X: %d, '
	DB	'Current Y: %d', 00H
	ORG $+2
$SG223880 DB	'No target for %s at position, Current X: %d, Current Y: '
	DB	'%d', 00H
	ORG $+5
$SG223913 DB	'Retargeting civilian escort operation (path lost to targ'
	DB	'et), X: %d, Y: %d', 00H
	ORG $+2
$SG223928 DB	'Moving escorting %s to take over camp defense, X: %d, Y:'
	DB	' %d', 00H
$SG223929 DB	'Moving %s to camp, X: %d, Y: %d', 00H
$SG223935 DB	'Moving %s to camp, X: %d, Y: %d', 00H
$SG223941 DB	'Moving %s to camp, X: %d, Y: %d', 00H
$SG223948 DB	'Moving %s without escort to target, X: %d, Y: %d', 00H
	ORG $+3
$SG223957 DB	'Moving escorting %s to target, X: %d, Y: %d', 00H
$SG223958 DB	'Moving %s to target, X: %d, Y: %d', 00H
	ORG $+6
$SG223967 DB	'Retargeting civilian escort operation (path lost to targ'
	DB	'et), X: %d, Y: %d', 00H
	ORG $+2
$SG223976 DB	'Moving escorting %s to target, X: %d, Y: %d', 00H
$SG223977 DB	'Moving %s to target, X: %d, Y: %d', 00H
	ORG $+6
$SG223981 DB	'Retargeting civilian escort operation. Too many blocking'
	DB	' units.', 00H
$SG223990 DB	'Moving escorting %s to target, X: %d, Y: %d', 00H
$SG223991 DB	'Moving %s to target, X: %d, Y: %d', 00H
	ORG $+2
$SG223995 DB	'Retargeting civilian escort operation. Could not move bl'
	DB	'ocking unit.', 00H
	ORG $+3
$SG224037 DB	'Moving blocking %s out of way, Leaving X: %d, Y: %d, Now'
	DB	' At X: %d, Y: %d', 00H
	ORG $+3
$SG224296 DB	'Set up %s for ranged attack', 00H
$SG224301 DB	'Making a safe bombard (no move) with %s, Target X: %d, T'
	DB	'arget Y: %d, At X: %d, At Y: %d', 00H
$SG224348 DB	'Moving closer for safe bombard with %s, Target X: %d, Y:'
	DB	' %d, Bombard From X: %d, Y: %d, Now At X: %d, Y: %d', 00H
$SG224353 DB	'Set up %s for ranged attack', 00H
$SG224358 DB	'Making a safe bombard (half move) with %s, Target X: %d,'
	DB	' Target Y: %d, At X: %d, At Y: %d', 00H
	ORG $+2
$SG224444 DB	'Moving to cover a protected bombard with %s, X: %d, Y: %'
	DB	'd', 00H
	ORG $+2
$SG224450 DB	'Pillaging during a protected bombard with %s, X: %d, Y: '
	DB	'%d', 00H
	ORG $+1
$SG224456 DB	'Fortifying during a protected bombard with %s, X: %d, Y:'
	DB	' %d', 00H
$SG224461 DB	'Sitting during a protected bombard with %s, X: %d, Y: %d'
	DB	00H
	ORG $+7
$SG224468 DB	'Moving closer for protected bombard with %s, Target X: %'
	DB	'd, Target Y: %d, At X: %d, At Y: %d', 00H
$SG224473 DB	'Set up %s for ranged attack', 00H
$SG224478 DB	'Making a protected bombard with %s, Target X: %d, Target'
	DB	' Y: %d, At X: %d, At Y: %d', 00H
	ORG $+1
$SG224541 DB	'Already in a flanking position with %s, X: %d, Y: %d', 00H
	ORG $+3
$SG224546 DB	'Moving into a flanking position with %s, X: %d, Y: %d', 00H
	ORG $+2
$SG224744 DB	'%s withdrew toward %s, Current X: %d, Current Y: %d', 00H
$SG224781 DB	'%s escorted embarked unit at, Current X: %d, Current Y: '
	DB	'%d', 00H
	ORG $+5
$SG225697 DB	'Deploying %s (to get out of way), To X: %d, To Y: %d, At'
	DB	' X: %d, At Y: %d, Distance Before Move: %d', 00H
	ORG $+5
$SG225713 DB	'Deploying %s, To X: %d, To Y: %d, At X: %d, At Y: %d, Di'
	DB	'stance Before Move: %d', 00H
	ORG $+1
$SG225730 DB	'Deploying %s to space near target, Target X: %d, Target '
	DB	'Y: %d, At X: %d, At Y: %d, Distance Before Move: %d', 00H
$SG225769 DB	'Already in position, no move for %s, X: %d, Y: %d', 00H
	ORG $+2
$SG225746 DB	'Deploying %s to space within 2 of target, Target X: %d, '
	DB	'Target Y: %d, At X: %d, At Y: %d, Distance Before Move: %d', 00H
	ORG $+1
$SG225758 DB	'Already in position, will pillage with %s, X: %d, Y: %d', 00H
$SG225764 DB	'Already in position, will fortify with %s, X: %d, Y: %d', 00H
$SG226154 DB	', ', 00H
	ORG $+1
$SG225807 DB	'Deploying %s, To X: %d, To Y: %d, At X: %d, At Y: %d, Pl'
	DB	'ot Score: %d, Dist from COM: %d', 00H
$SG226152 DB	'%03d, ', 00H
	ORG $+1
$SG226155 DB	'no zone, ', 00H
	ORG $+2
$SG226159 DB	'Zone ID: %d, ', 00H
	ORG $+2
$SG226170 DB	'.csv', 00H
	ORG $+3
$SG226171 DB	'PlayerTacticalAILog_', 00H
	ORG $+3
$SG226173 DB	'PlayerTacticalAILog.csv', 00H
$SG226185 DB	'No Tactic', 00H
	ORG $+2
$SG226187 DB	'Attack Stationary Target', 00H
	ORG $+3
$SG226189 DB	'Pillage Enemy Improvements', 00H
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	??0CvTacticalUnit@@QAE@XZ			; CvTacticalUnit::CvTacticalUnit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
;	COMDAT ??0CvTacticalUnit@@QAE@XZ
_TEXT	SEGMENT
??0CvTacticalUnit@@QAE@XZ PROC				; CvTacticalUnit::CvTacticalUnit, COMDAT
; _this$ = ecx

; 28   : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx

; 29   : }

	ret	0
??0CvTacticalUnit@@QAE@XZ ENDP				; CvTacticalUnit::CvTacticalUnit
_TEXT	ENDS
PUBLIC	?CacheResults@CvTacticalMoveXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvTacticalMoveXMLEntry::CacheResults
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvTacticalMoveXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvTacticalMoveXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvTacticalMoveXMLEntry::CacheResults, COMDAT
; _this$ = ecx

; 57   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul
	pop	edi
	pop	esi

; 72   : }

	ret	8
$LN1@CacheResul:
	push	ebx

; 58   : 		return false;
; 59   : 
; 60   : 	const char* szMoveType = kResults.GetText("Type");

	push	OFFSET $SG219922
	mov	ecx, edi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 61   : 	m_eMoveType = (TacticalAIMoveTypes)GC.getInfoTypeForString(szMoveType);

	push	0
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 62   : 
; 63   : 	m_iPriority = kResults.GetInt("Priority");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG219924
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 64   : 
; 65   : 	m_iOffenseWeight = kResults.GetInt("OffenseFlavorWeight");

	push	OFFSET $SG219925
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 66   : 	m_iDefenseWeight = kResults.GetInt("DefenseFlavorWeight");

	push	OFFSET $SG219926
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 67   : 
; 68   : 	m_bOperationsCanRecruit = kResults.GetInt("OperationsCanRecruit");

	push	OFFSET $SG219927
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx
	test	eax, eax
	setne	cl
	mov	BYTE PTR [esi+276], cl

; 69   : 	m_bDominanceZoneMove = kResults.GetInt("DominanceZoneMove");

	push	OFFSET $SG219928
	mov	ecx, edi
	call	ebx
	test	eax, eax
	pop	ebx
	setne	dl
	pop	edi
	mov	BYTE PTR [esi+277], dl

; 70   : 
; 71   : 	return true;

	mov	al, 1
	pop	esi

; 72   : }

	ret	8
?CacheResults@CvTacticalMoveXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvTacticalMoveXMLEntry::CacheResults
_TEXT	ENDS
PUBLIC	?GetTacticalMoveEntries@CvTacticalMoveXMLEntries@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ ; CvTacticalMoveXMLEntries::GetTacticalMoveEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetTacticalMoveEntries@CvTacticalMoveXMLEntries@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetTacticalMoveEntries@CvTacticalMoveXMLEntries@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ PROC ; CvTacticalMoveXMLEntries::GetTacticalMoveEntries, COMDAT
; _this$ = ecx

; 90   : {

	mov	eax, ecx

; 91   : 	return m_paTacticalMoveEntries;
; 92   : }

	ret	0
?GetTacticalMoveEntries@CvTacticalMoveXMLEntries@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ ENDP ; CvTacticalMoveXMLEntries::GetTacticalMoveEntries
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?Uninit@CvTacticalAI@@QAEXXZ			; CvTacticalAI::Uninit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
;	COMDAT ?Uninit@CvTacticalAI@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvTacticalAI@@QAEXXZ PROC			; CvTacticalAI::Uninit, COMDAT
; _this$ = ecx

; 326  : }

	ret	0
?Uninit@CvTacticalAI@@QAEXXZ ENDP			; CvTacticalAI::Uninit
_TEXT	ENDS
PUBLIC	?Reset@CvTacticalAI@@QAEXXZ			; CvTacticalAI::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvTacticalAI@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvTacticalAI@@QAEXXZ PROC			; CvTacticalAI::Reset, COMDAT
; _this$ = ecx

; 331  : 	m_MovePriorityTurn = -1;

	mov	DWORD PTR [ecx+2132], -1

; 332  : 	m_pMap = NULL;

	mov	DWORD PTR [ecx+4], 0

; 333  : }

	ret	0
?Reset@CvTacticalAI@@QAEXXZ ENDP			; CvTacticalAI::Reset
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?DoTurn@CvTacticalAI@@QAEXXZ			; CvTacticalAI::DoTurn
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
;	COMDAT ?DoTurn@CvTacticalAI@@QAEXXZ
_TEXT	SEGMENT
?DoTurn@CvTacticalAI@@QAEXXZ PROC			; CvTacticalAI::DoTurn, COMDAT
; _this$ = ecx

; 421  : }

	ret	0
?DoTurn@CvTacticalAI@@QAEXXZ ENDP			; CvTacticalAI::DoTurn
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?GetDescription@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescription
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetDescription@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescription@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescription, COMDAT
; _this$ = ecx

; 64   : 		return m_strDescription.c_str();

	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescription@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescription
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE, COMDAT
; _this$ = ecx

; 1485 : 		return m_iAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE;

	mov	eax, DWORD PTR [ecx+2420]

; 1486 : 	}

	ret	0
?getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_MAP_TEMP_ZONE_TURNS@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_MAP_TEMP_ZONE_TURNS
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_MAP_TEMP_ZONE_TURNS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_MAP_TEMP_ZONE_TURNS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_MAP_TEMP_ZONE_TURNS, COMDAT
; _this$ = ecx

; 1517 : 		return m_iAI_TACTICAL_MAP_TEMP_ZONE_TURNS;

	mov	eax, DWORD PTR [ecx+2452]

; 1518 : 	}

	ret	0
?getAI_TACTICAL_MAP_TEMP_ZONE_TURNS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_MAP_TEMP_ZONE_TURNS
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_RECRUIT_RANGE@CvGlobals@@QAEHXZ	; CvGlobals::getAI_TACTICAL_RECRUIT_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_RECRUIT_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_RECRUIT_RANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_TACTICAL_RECRUIT_RANGE, COMDAT
; _this$ = ecx

; 1525 : 		return m_iAI_TACTICAL_RECRUIT_RANGE;

	mov	eax, DWORD PTR [ecx+2460]

; 1526 : 	}

	ret	0
?getAI_TACTICAL_RECRUIT_RANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_TACTICAL_RECRUIT_RANGE
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_REPOSITION_RANGE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_REPOSITION_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_REPOSITION_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_REPOSITION_RANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_TACTICAL_REPOSITION_RANGE, COMDAT
; _this$ = ecx

; 1529 : 		return m_iAI_TACTICAL_REPOSITION_RANGE;

	mov	eax, DWORD PTR [ecx+2464]

; 1530 : 	}

	ret	0
?getAI_TACTICAL_REPOSITION_RANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_TACTICAL_REPOSITION_RANGE
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_OVERKILL_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_OVERKILL_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_OVERKILL_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_OVERKILL_PERCENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_TACTICAL_OVERKILL_PERCENT, COMDAT
; _this$ = ecx

; 1533 : 		return m_iAI_TACTICAL_OVERKILL_PERCENT;

	mov	eax, DWORD PTR [ecx+2468]

; 1534 : 	}

	ret	0
?getAI_TACTICAL_OVERKILL_PERCENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_TACTICAL_OVERKILL_PERCENT
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_MOVE_PRIORITY_RANDOMNESS@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_MOVE_PRIORITY_RANDOMNESS
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_MOVE_PRIORITY_RANDOMNESS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_MOVE_PRIORITY_RANDOMNESS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_MOVE_PRIORITY_RANDOMNESS, COMDAT
; _this$ = ecx

; 1541 : 		return m_iAI_TACTICAL_MOVE_PRIORITY_RANDOMNESS;

	mov	eax, DWORD PTR [ecx+2476]

; 1542 : 	}

	ret	0
?getAI_TACTICAL_MOVE_PRIORITY_RANDOMNESS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_MOVE_PRIORITY_RANDOMNESS
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_CAPTURE_CITY@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_CAPTURE_CITY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_CAPTURE_CITY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_CAPTURE_CITY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_CAPTURE_CITY, COMDAT
; _this$ = ecx

; 1545 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_CAPTURE_CITY;

	mov	eax, DWORD PTR [ecx+2480]

; 1546 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_CAPTURE_CITY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_CAPTURE_CITY
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_DAMAGE_CITY@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DAMAGE_CITY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_DAMAGE_CITY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_DAMAGE_CITY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DAMAGE_CITY, COMDAT
; _this$ = ecx

; 1549 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_DAMAGE_CITY;

	mov	eax, DWORD PTR [ecx+2484]

; 1550 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_DAMAGE_CITY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DAMAGE_CITY
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_HIGH_UNIT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_HIGH_UNIT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_HIGH_UNIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_HIGH_UNIT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_HIGH_UNIT, COMDAT
; _this$ = ecx

; 1553 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_HIGH_UNIT;

	mov	eax, DWORD PTR [ecx+2488]

; 1554 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_HIGH_UNIT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_HIGH_UNIT
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_MEDIUM_UNIT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_MEDIUM_UNIT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_MEDIUM_UNIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_MEDIUM_UNIT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_MEDIUM_UNIT, COMDAT
; _this$ = ecx

; 1557 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_MEDIUM_UNIT;

	mov	eax, DWORD PTR [ecx+2492]

; 1558 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_MEDIUM_UNIT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_MEDIUM_UNIT
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_LOW_UNIT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_LOW_UNIT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_LOW_UNIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_LOW_UNIT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_LOW_UNIT, COMDAT
; _this$ = ecx

; 1561 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_LOW_UNIT;

	mov	eax, DWORD PTR [ecx+2496]

; 1562 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_LOW_UNIT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_LOW_UNIT
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_TO_SAFETY@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_TO_SAFETY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_TO_SAFETY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_TO_SAFETY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_TO_SAFETY, COMDAT
; _this$ = ecx

; 1565 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_TO_SAFETY;

	mov	eax, DWORD PTR [ecx+2500]

; 1566 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_TO_SAFETY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_TO_SAFETY
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_HIGH_UNIT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_HIGH_UNIT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_HIGH_UNIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_HIGH_UNIT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_HIGH_UNIT, COMDAT
; _this$ = ecx

; 1569 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_HIGH_UNIT;

	mov	eax, DWORD PTR [ecx+2504]

; 1570 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_HIGH_UNIT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_HIGH_UNIT
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_MEDIUM_UNIT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_MEDIUM_UNIT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_MEDIUM_UNIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_MEDIUM_UNIT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_MEDIUM_UNIT, COMDAT
; _this$ = ecx

; 1573 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_MEDIUM_UNIT;

	mov	eax, DWORD PTR [ecx+2508]

; 1574 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_MEDIUM_UNIT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_MEDIUM_UNIT
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_LOW_UNIT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_LOW_UNIT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_LOW_UNIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_LOW_UNIT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_LOW_UNIT, COMDAT
; _this$ = ecx

; 1577 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_LOW_UNIT;

	mov	eax, DWORD PTR [ecx+2512]

; 1578 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_LOW_UNIT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_LOW_UNIT
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_DESPERATE_ATTACK@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DESPERATE_ATTACK
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_DESPERATE_ATTACK@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_DESPERATE_ATTACK@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DESPERATE_ATTACK, COMDAT
; _this$ = ecx

; 1581 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_DESPERATE_ATTACK;

	mov	eax, DWORD PTR [ecx+2516]

; 1582 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_DESPERATE_ATTACK@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_DESPERATE_ATTACK
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE, COMDAT
; _this$ = ecx

; 1585 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE;

	mov	eax, DWORD PTR [ecx+2520]

; 1586 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_CITADEL@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_CITADEL
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_CITADEL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_CITADEL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_CITADEL, COMDAT
; _this$ = ecx

; 1589 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_CITADEL;

	mov	eax, DWORD PTR [ecx+2524]

; 1590 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_CITADEL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_CITADEL
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_NEXT_TURN@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_NEXT_TURN
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_NEXT_TURN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_NEXT_TURN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_NEXT_TURN, COMDAT
; _this$ = ecx

; 1593 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_NEXT_TURN;

	mov	eax, DWORD PTR [ecx+2528]

; 1594 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_NEXT_TURN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_NEXT_TURN
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE, COMDAT
; _this$ = ecx

; 1597 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE;

	mov	eax, DWORD PTR [ecx+2532]

; 1598 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_CIVILIAN_ATTACK@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_CIVILIAN_ATTACK
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_CIVILIAN_ATTACK@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_CIVILIAN_ATTACK@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_CIVILIAN_ATTACK, COMDAT
; _this$ = ecx

; 1601 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_CIVILIAN_ATTACK;

	mov	eax, DWORD PTR [ecx+2536]

; 1602 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_CIVILIAN_ATTACK@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_CIVILIAN_ATTACK
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_PASSIVE_MOVE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PASSIVE_MOVE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_PASSIVE_MOVE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_PASSIVE_MOVE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PASSIVE_MOVE, COMDAT
; _this$ = ecx

; 1605 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_PASSIVE_MOVE;

	mov	eax, DWORD PTR [ecx+2540]

; 1606 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_PASSIVE_MOVE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PASSIVE_MOVE
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_AGGRESSIVE_MOVE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_AGGRESSIVE_MOVE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_AGGRESSIVE_MOVE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_AGGRESSIVE_MOVE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_AGGRESSIVE_MOVE, COMDAT
; _this$ = ecx

; 1609 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_AGGRESSIVE_MOVE;

	mov	eax, DWORD PTR [ecx+2544]

; 1610 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_AGGRESSIVE_MOVE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_AGGRESSIVE_MOVE
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_CAMP_DEFENSE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_CAMP_DEFENSE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_CAMP_DEFENSE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_CAMP_DEFENSE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_CAMP_DEFENSE, COMDAT
; _this$ = ecx

; 1613 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_CAMP_DEFENSE;

	mov	eax, DWORD PTR [ecx+2548]

; 1614 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_CAMP_DEFENSE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_CAMP_DEFENSE
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_ESCORT_CIVILIAN@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_ESCORT_CIVILIAN
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_ESCORT_CIVILIAN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_ESCORT_CIVILIAN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_ESCORT_CIVILIAN, COMDAT
; _this$ = ecx

; 1617 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_ESCORT_CIVILIAN;

	mov	eax, DWORD PTR [ecx+2552]

; 1618 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_ESCORT_CIVILIAN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_ESCORT_CIVILIAN
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_BARBARIAN_PRIORITY_PLUNDER_TRADE_UNIT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PLUNDER_TRADE_UNIT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_BARBARIAN_PRIORITY_PLUNDER_TRADE_UNIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_BARBARIAN_PRIORITY_PLUNDER_TRADE_UNIT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PLUNDER_TRADE_UNIT, COMDAT
; _this$ = ecx

; 1621 : 		return m_iAI_TACTICAL_BARBARIAN_PRIORITY_PLUNDER_TRADE_UNIT;

	mov	eax, DWORD PTR [ecx+2556]

; 1622 : 	}

	ret	0
?getAI_TACTICAL_BARBARIAN_PRIORITY_PLUNDER_TRADE_UNIT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_BARBARIAN_PRIORITY_PLUNDER_TRADE_UNIT
_TEXT	ENDS
PUBLIC	?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ; FObjectHandle<CvUnit>::pointer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC ; FObjectHandle<CvUnit>::pointer, COMDAT
; _this$ = ecx

; 78   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 79   : 	}

	ret	0
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP ; FObjectHandle<CvUnit>::pointer
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??D?$FObjectHandle@VCvUnit@@@@QAEAAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$FObjectHandle@VCvUnit@@@@QAEAAVCvUnit@@XZ
_TEXT	SEGMENT
??D?$FObjectHandle@VCvUnit@@@@QAEAAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator*, COMDAT
; _this$ = ecx

; 98   : 		return *m_target;

	mov	eax, DWORD PTR [ecx]

; 99   : 	}

	ret	0
??D?$FObjectHandle@VCvUnit@@@@QAEAAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator*
_TEXT	ENDS
PUBLIC	??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator bool, COMDAT
; _this$ = ecx

; 108  : 		return m_target != 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 109  : 	}

	ret	0
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator bool
_TEXT	ENDS
PUBLIC	??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator!
; Function compile flags: /Ogtpy
;	COMDAT ??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator!, COMDAT
; _this$ = ecx

; 113  : 		return m_target == 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	sete	al

; 114  : 	}

	ret	0
??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator!
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 215  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0

; 216  : 		OBJECT_HANDLE_STACK;
; 217  : 	}

	ret	0
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAPAVCvTacticalMoveXMLEntry@@I@Z ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAPAVCvTacticalMoveXMLEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAPAVCvTacticalMoveXMLEntry@@I@Z PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAPAVCvTacticalMoveXMLEntry@@I@Z ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ	; std::list<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::list<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 620  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 621  : 		}

	ret	0
?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::list<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEIXZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAVCvTacticalUnit@@I@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAVCvTacticalUnit@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAVCvTacticalUnit@@I@Z PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]

; 786  : 		}

	ret	4
??A?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAVCvTacticalUnit@@I@Z ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEIXZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAVCvTacticalCity@@I@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAVCvTacticalCity@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAVCvTacticalCity@@I@Z PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 786  : 		}

	ret	4
??A?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAVCvTacticalCity@@I@Z ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::operator[]
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvTacticalMove@@$00@@QAEPAVCvTacticalMove@@XZ ; BaseVector<CvTacticalMove,1>::begin
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?begin@?$BaseVector@VCvTacticalMove@@$00@@QAEPAVCvTacticalMove@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvTacticalMove@@$00@@QAEPAVCvTacticalMove@@XZ PROC ; BaseVector<CvTacticalMove,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvTacticalMove@@$00@@QAEPAVCvTacticalMove@@XZ ENDP ; BaseVector<CvTacticalMove,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvTacticalMove@@$00@@QAEPAVCvTacticalMove@@XZ ; BaseVector<CvTacticalMove,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvTacticalMove@@$00@@QAEPAVCvTacticalMove@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvTacticalMove@@$00@@QAEPAVCvTacticalMove@@XZ PROC ; BaseVector<CvTacticalMove,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvTacticalMove@@$00@@QAEPAVCvTacticalMove@@XZ ENDP ; BaseVector<CvTacticalMove,1>::end
_TEXT	ENDS
PUBLIC	?size@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEIXZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?size@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEIXZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::size, COMDAT
; _this$ = ecx

; 620  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 621  : 		}

	ret	0
?size@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEIXZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvTacticalTarget@@$0A@@@QAEAAVCvTacticalTarget@@I@Z ; BaseVector<CvTacticalTarget,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@VCvTacticalTarget@@$0A@@@QAEAAVCvTacticalTarget@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvTacticalTarget@@$0A@@@QAEAAVCvTacticalTarget@@I@Z PROC ; BaseVector<CvTacticalTarget,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvTacticalTarget@@$0A@@@QAEAAVCvTacticalTarget@@I@Z ENDP ; BaseVector<CvTacticalTarget,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvTacticalTarget@@$0A@@@QBEIXZ ; BaseVector<CvTacticalTarget,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvTacticalTarget@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvTacticalTarget@@$0A@@@QBEIXZ PROC	; BaseVector<CvTacticalTarget,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvTacticalTarget@@$0A@@@QBEIXZ ENDP	; BaseVector<CvTacticalTarget,0>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvTacticalTarget@@$0A@@@QAEPAVCvTacticalTarget@@XZ ; BaseVector<CvTacticalTarget,0>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvTacticalTarget@@$0A@@@QAEPAVCvTacticalTarget@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvTacticalTarget@@$0A@@@QAEPAVCvTacticalTarget@@XZ PROC ; BaseVector<CvTacticalTarget,0>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvTacticalTarget@@$0A@@@QAEPAVCvTacticalTarget@@XZ ENDP ; BaseVector<CvTacticalTarget,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvTacticalTarget@@$0A@@@QAEPAVCvTacticalTarget@@XZ ; BaseVector<CvTacticalTarget,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvTacticalTarget@@$0A@@@QAEPAVCvTacticalTarget@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvTacticalTarget@@$0A@@@QAEPAVCvTacticalTarget@@XZ PROC ; BaseVector<CvTacticalTarget,0>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvTacticalTarget@@$0A@@@QAEPAVCvTacticalTarget@@XZ ENDP ; BaseVector<CvTacticalTarget,0>::end
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvTacticalTarget@@$00@@QAEAAVCvTacticalTarget@@I@Z ; BaseVector<CvTacticalTarget,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvTacticalTarget@@$00@@QAEAAVCvTacticalTarget@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvTacticalTarget@@$00@@QAEAAVCvTacticalTarget@@I@Z PROC ; BaseVector<CvTacticalTarget,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvTacticalTarget@@$00@@QAEAAVCvTacticalTarget@@I@Z ENDP ; BaseVector<CvTacticalTarget,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvTacticalTarget@@$00@@QBEIXZ ; BaseVector<CvTacticalTarget,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvTacticalTarget@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvTacticalTarget@@$00@@QBEIXZ PROC	; BaseVector<CvTacticalTarget,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvTacticalTarget@@$00@@QBEIXZ ENDP	; BaseVector<CvTacticalTarget,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvTacticalTarget@@$00@@QAEPAVCvTacticalTarget@@XZ ; BaseVector<CvTacticalTarget,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvTacticalTarget@@$00@@QAEPAVCvTacticalTarget@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvTacticalTarget@@$00@@QAEPAVCvTacticalTarget@@XZ PROC ; BaseVector<CvTacticalTarget,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvTacticalTarget@@$00@@QAEPAVCvTacticalTarget@@XZ ENDP ; BaseVector<CvTacticalTarget,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvTacticalTarget@@$00@@QAEPAVCvTacticalTarget@@XZ ; BaseVector<CvTacticalTarget,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvTacticalTarget@@$00@@QAEPAVCvTacticalTarget@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvTacticalTarget@@$00@@QAEPAVCvTacticalTarget@@XZ PROC ; BaseVector<CvTacticalTarget,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvTacticalTarget@@$00@@QAEPAVCvTacticalTarget@@XZ ENDP ; BaseVector<CvTacticalTarget,1>::end
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvTacticalPosture@@$00@@QAEAAVCvTacticalPosture@@I@Z ; BaseVector<CvTacticalPosture,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvTacticalPosture@@$00@@QAEAAVCvTacticalPosture@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvTacticalPosture@@$00@@QAEAAVCvTacticalPosture@@I@Z PROC ; BaseVector<CvTacticalPosture,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvTacticalPosture@@$00@@QAEAAVCvTacticalPosture@@I@Z ENDP ; BaseVector<CvTacticalPosture,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvTacticalPosture@@$00@@QBEIXZ ; BaseVector<CvTacticalPosture,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvTacticalPosture@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvTacticalPosture@@$00@@QBEIXZ PROC	; BaseVector<CvTacticalPosture,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvTacticalPosture@@$00@@QBEIXZ ENDP	; BaseVector<CvTacticalPosture,1>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvTemporaryZone@@$00@@QAEAAVCvTemporaryZone@@I@Z ; BaseVector<CvTemporaryZone,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvTemporaryZone@@$00@@QAEAAVCvTemporaryZone@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvTemporaryZone@@$00@@QAEAAVCvTemporaryZone@@I@Z PROC ; BaseVector<CvTemporaryZone,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvTemporaryZone@@$00@@QAEAAVCvTemporaryZone@@I@Z ENDP ; BaseVector<CvTemporaryZone,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvTemporaryZone@@$00@@QBEIXZ ; BaseVector<CvTemporaryZone,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvTemporaryZone@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvTemporaryZone@@$00@@QBEIXZ PROC	; BaseVector<CvTemporaryZone,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvTemporaryZone@@$00@@QBEIXZ ENDP	; BaseVector<CvTemporaryZone,1>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvBlockingUnit@@$00@@QAEAAVCvBlockingUnit@@I@Z ; BaseVector<CvBlockingUnit,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvBlockingUnit@@$00@@QAEAAVCvBlockingUnit@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvBlockingUnit@@$00@@QAEAAVCvBlockingUnit@@I@Z PROC ; BaseVector<CvBlockingUnit,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvBlockingUnit@@$00@@QAEAAVCvBlockingUnit@@I@Z ENDP ; BaseVector<CvBlockingUnit,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvBlockingUnit@@$00@@QBEIXZ	; BaseVector<CvBlockingUnit,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvBlockingUnit@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvBlockingUnit@@$00@@QBEIXZ PROC	; BaseVector<CvBlockingUnit,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvBlockingUnit@@$00@@QBEIXZ ENDP	; BaseVector<CvBlockingUnit,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvBlockingUnit@@$00@@QAEPAVCvBlockingUnit@@XZ ; BaseVector<CvBlockingUnit,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvBlockingUnit@@$00@@QAEPAVCvBlockingUnit@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvBlockingUnit@@$00@@QAEPAVCvBlockingUnit@@XZ PROC ; BaseVector<CvBlockingUnit,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvBlockingUnit@@$00@@QAEPAVCvBlockingUnit@@XZ ENDP ; BaseVector<CvBlockingUnit,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvBlockingUnit@@$00@@QAEPAVCvBlockingUnit@@XZ ; BaseVector<CvBlockingUnit,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvBlockingUnit@@$00@@QAEPAVCvBlockingUnit@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvBlockingUnit@@$00@@QAEPAVCvBlockingUnit@@XZ PROC ; BaseVector<CvBlockingUnit,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvBlockingUnit@@$00@@QAEPAVCvBlockingUnit@@XZ ENDP ; BaseVector<CvBlockingUnit,1>::end
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvOperationUnit@@$00@@QAEAAVCvOperationUnit@@I@Z ; BaseVector<CvOperationUnit,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvOperationUnit@@$00@@QAEAAVCvOperationUnit@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvOperationUnit@@$00@@QAEAAVCvOperationUnit@@I@Z PROC ; BaseVector<CvOperationUnit,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvOperationUnit@@$00@@QAEAAVCvOperationUnit@@I@Z ENDP ; BaseVector<CvOperationUnit,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvOperationUnit@@$00@@QBEIXZ ; BaseVector<CvOperationUnit,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvOperationUnit@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvOperationUnit@@$00@@QBEIXZ PROC	; BaseVector<CvOperationUnit,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvOperationUnit@@$00@@QBEIXZ ENDP	; BaseVector<CvOperationUnit,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvOperationUnit@@$00@@QAEPAVCvOperationUnit@@XZ ; BaseVector<CvOperationUnit,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvOperationUnit@@$00@@QAEPAVCvOperationUnit@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvOperationUnit@@$00@@QAEPAVCvOperationUnit@@XZ PROC ; BaseVector<CvOperationUnit,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvOperationUnit@@$00@@QAEPAVCvOperationUnit@@XZ ENDP ; BaseVector<CvOperationUnit,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvOperationUnit@@$00@@QAEPAVCvOperationUnit@@XZ ; BaseVector<CvOperationUnit,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvOperationUnit@@$00@@QAEPAVCvOperationUnit@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvOperationUnit@@$00@@QAEPAVCvOperationUnit@@XZ PROC ; BaseVector<CvOperationUnit,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvOperationUnit@@$00@@QAEPAVCvOperationUnit@@XZ ENDP ; BaseVector<CvOperationUnit,1>::end
_TEXT	ENDS
PUBLIC	??8?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??8?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator==, COMDAT
; _this$ = ecx

; 291  : 
; 292  :  #if _HAS_ITERATOR_DEBUGGING
; 293  : 			_Compat(_Right);
; 294  :  #else
; 295  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 296  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 297  : 
; 298  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 299  : 			}

	ret	4
??8?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator==
_TEXT	ENDS
PUBLIC	??9?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator!=, COMDAT
; _this$ = ecx

; 303  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 304  : 			}

	ret	4
??9?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator!=
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalMoveXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTacticalMoveXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalMoveXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTacticalMoveXMLEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalMoveXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTacticalMoveXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAE@XZ ; std::allocator<CvTacticalMoveXMLEntry *>::allocator<CvTacticalMoveXMLEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAE@XZ PROC ; std::allocator<CvTacticalMoveXMLEntry *>::allocator<CvTacticalMoveXMLEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAE@XZ ENDP ; std::allocator<CvTacticalMoveXMLEntry *>::allocator<CvTacticalMoveXMLEntry *>
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z ; std::list<int,std::allocator<int> >::_Nextnode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Nextnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z PROC ; std::list<int,std::allocator<int> >::_Nextnode, COMDAT

; 115  : 		return ((_Nodepref)(*_Pnode)._Next);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 116  : 		}

	ret	0
?_Nextnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z ENDP ; std::list<int,std::allocator<int> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Prevnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z ; std::list<int,std::allocator<int> >::_Prevnode
; Function compile flags: /Ogtpy
;	COMDAT ?_Prevnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z PROC ; std::list<int,std::allocator<int> >::_Prevnode, COMDAT

; 120  : 		return ((_Nodepref)(*_Pnode)._Prev);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 121  : 		}

	ret	0
?_Prevnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z ENDP ; std::list<int,std::allocator<int> >::_Prevnode
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEIXZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalUnit> >::~_Container_base_aux_alloc_empty<std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalUnit> >::~_Container_base_aux_alloc_empty<std::allocator<CvTacticalUnit> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalUnit> >::~_Container_base_aux_alloc_empty<std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvTacticalUnit@@@std@@QAE@XZ	; std::allocator<CvTacticalUnit>::allocator<CvTacticalUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvTacticalUnit@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvTacticalUnit@@@std@@QAE@XZ PROC	; std::allocator<CvTacticalUnit>::allocator<CvTacticalUnit>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvTacticalUnit@@@std@@QAE@XZ ENDP	; std::allocator<CvTacticalUnit>::allocator<CvTacticalUnit>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEIXZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity@2

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::capacity
_TEXT	ENDS
PUBLIC	?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ		; CvGlobals::getMOVE_DENOMINATOR
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMOVE_DENOMINATOR, COMDAT
; _this$ = ecx

; 5312 : 		return m_iMOVE_DENOMINATOR;

	mov	eax, DWORD PTR [ecx+6236]

; 5313 : 	}

	ret	0
?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMOVE_DENOMINATOR
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalCity> >::~_Container_base_aux_alloc_empty<std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalCity> >::~_Container_base_aux_alloc_empty<std::allocator<CvTacticalCity> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalCity> >::~_Container_base_aux_alloc_empty<std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvTacticalCity@@@std@@QAE@XZ	; std::allocator<CvTacticalCity>::allocator<CvTacticalCity>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvTacticalCity@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvTacticalCity@@@std@@QAE@XZ PROC	; std::allocator<CvTacticalCity>::allocator<CvTacticalCity>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvTacticalCity@@@std@@QAE@XZ ENDP	; std::allocator<CvTacticalCity>::allocator<CvTacticalCity>
_TEXT	ENDS
PUBLIC	??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEPAVCvTacticalMove@@I@Z ; FStaticVector<CvTacticalMove,256,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@ DB 'c:\users\eno'
	DB	'rmousapplepie\desktop\lekmod files\lekmod dll versions\v29\le'
	DB	'kmod_dll\fireplace\include\fireworks\FFastVector.h', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEPAVCvTacticalMove@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEPAVCvTacticalMove@@I@Z PROC ; FStaticVector<CvTacticalMove,256,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 256				; 00000100H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 256			; 00000100H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEPAVCvTacticalMove@@I@Z ENDP ; FStaticVector<CvTacticalMove,256,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvTacticalMove@@$00@@QAE@XZ	; BaseVector<CvTacticalMove,1>::~BaseVector<CvTacticalMove,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvTacticalMove@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvTacticalMove@@$00@@QAE@XZ PROC	; BaseVector<CvTacticalMove,1>::~BaseVector<CvTacticalMove,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvTacticalMove@@$00@@QAE@XZ ENDP	; BaseVector<CvTacticalMove,1>::~BaseVector<CvTacticalMove,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvTacticalMove@@$00@@IAE@XZ	; BaseVector<CvTacticalMove,1>::BaseVector<CvTacticalMove,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvTacticalMove@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvTacticalMove@@$00@@IAE@XZ PROC	; BaseVector<CvTacticalMove,1>::BaseVector<CvTacticalMove,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvTacticalMove@@$00@@IAE@XZ ENDP	; BaseVector<CvTacticalMove,1>::BaseVector<CvTacticalMove,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvTacticalMove@@$00@@IAEXPAVCvTacticalMove@@I@Z ; BaseVector<CvTacticalMove,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvTacticalMove@@$00@@IAEXPAVCvTacticalMove@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvTacticalMove@@$00@@IAEXPAVCvTacticalMove@@I@Z PROC ; BaseVector<CvTacticalMove,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvTacticalMove@@$00@@IAEXPAVCvTacticalMove@@I@Z ENDP ; BaseVector<CvTacticalMove,1>::Destroy
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@KAAAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Nextnode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Nextnode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@KAAAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@KAAAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Nextnode, COMDAT

; 115  : 		return ((_Nodepref)(*_Pnode)._Next);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 116  : 		}

	ret	0
?_Nextnode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@KAAAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Prevnode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@KAAAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Prevnode
; Function compile flags: /Ogtpy
;	COMDAT ?_Prevnode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@KAAAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@KAAAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Prevnode, COMDAT

; 120  : 		return ((_Nodepref)(*_Pnode)._Prev);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 121  : 		}

	ret	0
?_Prevnode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@KAAAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Prevnode
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvQueuedAttack> >::~_Container_base_aux_alloc_empty<std::allocator<CvQueuedAttack> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvQueuedAttack> >::~_Container_base_aux_alloc_empty<std::allocator<CvQueuedAttack> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvQueuedAttack> >::~_Container_base_aux_alloc_empty<std::allocator<CvQueuedAttack> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvQueuedAttack@@@std@@QAE@XZ	; std::allocator<CvQueuedAttack>::allocator<CvQueuedAttack>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvQueuedAttack@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvQueuedAttack@@@std@@QAE@XZ PROC	; std::allocator<CvQueuedAttack>::allocator<CvQueuedAttack>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvQueuedAttack@@@std@@QAE@XZ ENDP	; std::allocator<CvQueuedAttack>::allocator<CvQueuedAttack>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@I@Z ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEPAVCvTacticalTarget@@I@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEPAVCvTacticalTarget@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEPAVCvTacticalTarget@@I@Z PROC ; FStaticVector<CvTacticalTarget,256,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 256				; 00000100H
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 256			; 00000100H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEPAVCvTacticalTarget@@I@Z ENDP ; FStaticVector<CvTacticalTarget,256,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvTacticalTarget@@$0A@@@QAE@XZ	; BaseVector<CvTacticalTarget,0>::~BaseVector<CvTacticalTarget,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvTacticalTarget@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvTacticalTarget@@$0A@@@QAE@XZ PROC	; BaseVector<CvTacticalTarget,0>::~BaseVector<CvTacticalTarget,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvTacticalTarget@@$0A@@@QAE@XZ ENDP	; BaseVector<CvTacticalTarget,0>::~BaseVector<CvTacticalTarget,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvTacticalTarget@@$0A@@@IAE@XZ	; BaseVector<CvTacticalTarget,0>::BaseVector<CvTacticalTarget,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvTacticalTarget@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvTacticalTarget@@$0A@@@IAE@XZ PROC	; BaseVector<CvTacticalTarget,0>::BaseVector<CvTacticalTarget,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvTacticalTarget@@$0A@@@IAE@XZ ENDP	; BaseVector<CvTacticalTarget,0>::BaseVector<CvTacticalTarget,0>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvTacticalTarget@@$0A@@@IAEXPAVCvTacticalTarget@@I@Z ; BaseVector<CvTacticalTarget,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvTacticalTarget@@$0A@@@IAEXPAVCvTacticalTarget@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvTacticalTarget@@$0A@@@IAEXPAVCvTacticalTarget@@I@Z PROC ; BaseVector<CvTacticalTarget,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvTacticalTarget@@$0A@@@IAEXPAVCvTacticalTarget@@I@Z ENDP ; BaseVector<CvTacticalTarget,0>::Destroy
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@VCvTacticalTarget@@$0A@@@IAEXABV1@@Z ; BaseVector<CvTacticalTarget,0>::Copy
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@VCvTacticalTarget@@$0A@@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@VCvTacticalTarget@@$0A@@@IAEXABV1@@Z PROC ; BaseVector<CvTacticalTarget,0>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	ebx
	push	ebp

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	ebp, DWORD PTR _RHS$[esp+4]
	mov	eax, DWORD PTR [ebp+4]
	mov	edx, ecx

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);
; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	xor	ebx, ebx
	mov	DWORD PTR [edx+4], eax
	test	eax, eax
	jbe	SHORT $LN1@Copy
	push	esi
	xor	eax, eax
	push	edi
$LL3@Copy:

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	mov	edi, DWORD PTR [edx]
	add	edi, eax
	je	SHORT $LN2@Copy
	mov	esi, DWORD PTR [ebp]
	add	esi, eax
	mov	ecx, 7
	rep movsd
$LN2@Copy:
	inc	ebx
	add	eax, 28					; 0000001cH
	cmp	ebx, DWORD PTR [edx+4]
	jb	SHORT $LL3@Copy
	pop	edi
	pop	esi
$LN1@Copy:
	pop	ebp
	pop	ebx

; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@VCvTacticalTarget@@$0A@@@IAEXABV1@@Z ENDP ; BaseVector<CvTacticalTarget,0>::Copy
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEPAVCvTacticalTarget@@I@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEPAVCvTacticalTarget@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEPAVCvTacticalTarget@@I@Z PROC ; FStaticVector<CvTacticalTarget,37,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 37					; 00000025H
	jbe	SHORT $LN2@Alloc@3

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@3:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 37			; 00000025H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEPAVCvTacticalTarget@@I@Z ENDP ; FStaticVector<CvTacticalTarget,37,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvTacticalTarget@@$00@@QAE@XZ	; BaseVector<CvTacticalTarget,1>::~BaseVector<CvTacticalTarget,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvTacticalTarget@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvTacticalTarget@@$00@@QAE@XZ PROC	; BaseVector<CvTacticalTarget,1>::~BaseVector<CvTacticalTarget,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvTacticalTarget@@$00@@QAE@XZ ENDP	; BaseVector<CvTacticalTarget,1>::~BaseVector<CvTacticalTarget,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvTacticalTarget@@$00@@IAE@XZ	; BaseVector<CvTacticalTarget,1>::BaseVector<CvTacticalTarget,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvTacticalTarget@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvTacticalTarget@@$00@@IAE@XZ PROC	; BaseVector<CvTacticalTarget,1>::BaseVector<CvTacticalTarget,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvTacticalTarget@@$00@@IAE@XZ ENDP	; BaseVector<CvTacticalTarget,1>::BaseVector<CvTacticalTarget,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvTacticalTarget@@$00@@IAEXPAVCvTacticalTarget@@I@Z ; BaseVector<CvTacticalTarget,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvTacticalTarget@@$00@@IAEXPAVCvTacticalTarget@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvTacticalTarget@@$00@@IAEXPAVCvTacticalTarget@@I@Z PROC ; BaseVector<CvTacticalTarget,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvTacticalTarget@@$00@@IAEXPAVCvTacticalTarget@@I@Z ENDP ; BaseVector<CvTacticalTarget,1>::Destroy
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEPAVCvTacticalPosture@@I@Z ; FStaticVector<CvTacticalPosture,64,1,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEPAVCvTacticalPosture@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEPAVCvTacticalPosture@@I@Z PROC ; FStaticVector<CvTacticalPosture,64,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN2@Alloc@4

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi+edi*2]
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@4:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 64			; 00000040H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEPAVCvTacticalPosture@@I@Z ENDP ; FStaticVector<CvTacticalPosture,64,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvTacticalPosture@@$00@@QAE@XZ	; BaseVector<CvTacticalPosture,1>::~BaseVector<CvTacticalPosture,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvTacticalPosture@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvTacticalPosture@@$00@@QAE@XZ PROC	; BaseVector<CvTacticalPosture,1>::~BaseVector<CvTacticalPosture,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvTacticalPosture@@$00@@QAE@XZ ENDP	; BaseVector<CvTacticalPosture,1>::~BaseVector<CvTacticalPosture,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvTacticalPosture@@$00@@IAE@XZ	; BaseVector<CvTacticalPosture,1>::BaseVector<CvTacticalPosture,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvTacticalPosture@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvTacticalPosture@@$00@@IAE@XZ PROC	; BaseVector<CvTacticalPosture,1>::BaseVector<CvTacticalPosture,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvTacticalPosture@@$00@@IAE@XZ ENDP	; BaseVector<CvTacticalPosture,1>::BaseVector<CvTacticalPosture,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvTacticalPosture@@$00@@IAEXPAVCvTacticalPosture@@I@Z ; BaseVector<CvTacticalPosture,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvTacticalPosture@@$00@@IAEXPAVCvTacticalPosture@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvTacticalPosture@@$00@@IAEXPAVCvTacticalPosture@@I@Z PROC ; BaseVector<CvTacticalPosture,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvTacticalPosture@@$00@@IAEXPAVCvTacticalPosture@@I@Z ENDP ; BaseVector<CvTacticalPosture,1>::Destroy
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@VCvTacticalPosture@@$00@@IAEXABV1@@Z ; BaseVector<CvTacticalPosture,1>::Copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@VCvTacticalPosture@@$00@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@VCvTacticalPosture@@$00@@IAEXABV1@@Z PROC ; BaseVector<CvTacticalPosture,1>::Copy, COMDAT
; _this$ = ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _RHS$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){
; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );
; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@VCvTacticalPosture@@$00@@IAEXABV1@@Z ENDP ; BaseVector<CvTacticalPosture,1>::Copy
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEPAVCvTemporaryZone@@I@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEPAVCvTemporaryZone@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEPAVCvTemporaryZone@@I@Z PROC ; FStaticVector<CvTemporaryZone,10,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 10					; 0000000aH
	jbe	SHORT $LN2@Alloc@5

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi+edi*4]
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@5:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 10			; 0000000aH
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEPAVCvTemporaryZone@@I@Z ENDP ; FStaticVector<CvTemporaryZone,10,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvTemporaryZone@@$00@@QAE@XZ	; BaseVector<CvTemporaryZone,1>::~BaseVector<CvTemporaryZone,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvTemporaryZone@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvTemporaryZone@@$00@@QAE@XZ PROC	; BaseVector<CvTemporaryZone,1>::~BaseVector<CvTemporaryZone,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvTemporaryZone@@$00@@QAE@XZ ENDP	; BaseVector<CvTemporaryZone,1>::~BaseVector<CvTemporaryZone,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvTemporaryZone@@$00@@IAE@XZ	; BaseVector<CvTemporaryZone,1>::BaseVector<CvTemporaryZone,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvTemporaryZone@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvTemporaryZone@@$00@@IAE@XZ PROC	; BaseVector<CvTemporaryZone,1>::BaseVector<CvTemporaryZone,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvTemporaryZone@@$00@@IAE@XZ ENDP	; BaseVector<CvTemporaryZone,1>::BaseVector<CvTemporaryZone,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvTemporaryZone@@$00@@IAEXPAVCvTemporaryZone@@I@Z ; BaseVector<CvTemporaryZone,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvTemporaryZone@@$00@@IAEXPAVCvTemporaryZone@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvTemporaryZone@@$00@@IAEXPAVCvTemporaryZone@@I@Z PROC ; BaseVector<CvTemporaryZone,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvTemporaryZone@@$00@@IAEXPAVCvTemporaryZone@@I@Z ENDP ; BaseVector<CvTemporaryZone,1>::Destroy
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@VCvTemporaryZone@@$00@@IAEXABV1@@Z ; BaseVector<CvTemporaryZone,1>::Copy
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@VCvTemporaryZone@@$00@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@VCvTemporaryZone@@$00@@IAEXABV1@@Z PROC ; BaseVector<CvTemporaryZone,1>::Copy, COMDAT
; _this$ = ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _RHS$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edx+edx*4]
	add	edx, edx
	add	edx, edx
	push	edx
	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){
; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );
; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@VCvTemporaryZone@@$00@@IAEXABV1@@Z ENDP ; BaseVector<CvTemporaryZone,1>::Copy
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEPAVCvBlockingUnit@@I@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEPAVCvBlockingUnit@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEPAVCvBlockingUnit@@I@Z PROC ; FStaticVector<CvBlockingUnit,25,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 25					; 00000019H
	jbe	SHORT $LN2@Alloc@6

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	mov	eax, edi
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@6:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 25			; 00000019H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEPAVCvBlockingUnit@@I@Z ENDP ; FStaticVector<CvBlockingUnit,25,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvBlockingUnit@@$00@@QAE@XZ	; BaseVector<CvBlockingUnit,1>::~BaseVector<CvBlockingUnit,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvBlockingUnit@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvBlockingUnit@@$00@@QAE@XZ PROC	; BaseVector<CvBlockingUnit,1>::~BaseVector<CvBlockingUnit,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvBlockingUnit@@$00@@QAE@XZ ENDP	; BaseVector<CvBlockingUnit,1>::~BaseVector<CvBlockingUnit,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvBlockingUnit@@$00@@IAE@XZ	; BaseVector<CvBlockingUnit,1>::BaseVector<CvBlockingUnit,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvBlockingUnit@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvBlockingUnit@@$00@@IAE@XZ PROC	; BaseVector<CvBlockingUnit,1>::BaseVector<CvBlockingUnit,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvBlockingUnit@@$00@@IAE@XZ ENDP	; BaseVector<CvBlockingUnit,1>::BaseVector<CvBlockingUnit,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvBlockingUnit@@$00@@IAEXPAVCvBlockingUnit@@I@Z ; BaseVector<CvBlockingUnit,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvBlockingUnit@@$00@@IAEXPAVCvBlockingUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvBlockingUnit@@$00@@IAEXPAVCvBlockingUnit@@I@Z PROC ; BaseVector<CvBlockingUnit,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvBlockingUnit@@$00@@IAEXPAVCvBlockingUnit@@I@Z ENDP ; BaseVector<CvBlockingUnit,1>::Destroy
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@VCvBlockingUnit@@$00@@IAEXABV1@@Z ; BaseVector<CvBlockingUnit,1>::Copy
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@VCvBlockingUnit@@$00@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@VCvBlockingUnit@@$00@@IAEXABV1@@Z PROC ; BaseVector<CvBlockingUnit,1>::Copy, COMDAT
; _this$ = ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _RHS$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	shl	edx, 4
	push	edx
	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){
; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );
; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@VCvBlockingUnit@@$00@@IAEXABV1@@Z ENDP ; BaseVector<CvBlockingUnit,1>::Copy
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEPAVCvBlockingUnit@@I@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEPAVCvBlockingUnit@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEPAVCvBlockingUnit@@I@Z PROC ; FStaticVector<CvBlockingUnit,37,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 37					; 00000025H
	jbe	SHORT $LN2@Alloc@7

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	mov	eax, edi
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@7:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 37			; 00000025H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEPAVCvBlockingUnit@@I@Z ENDP ; FStaticVector<CvBlockingUnit,37,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXPAVCvBlockingUnit@@I@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXPAVCvBlockingUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXPAVCvBlockingUnit@@I@Z PROC ; FStaticVector<CvBlockingUnit,37,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXPAVCvBlockingUnit@@I@Z ENDP ; FStaticVector<CvBlockingUnit,37,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEPAVCvOperationUnit@@I@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEPAVCvOperationUnit@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEPAVCvOperationUnit@@I@Z PROC ; FStaticVector<CvOperationUnit,20,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 20					; 00000014H
	jbe	SHORT $LN2@Alloc@8

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@8:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 20			; 00000014H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEPAVCvOperationUnit@@I@Z ENDP ; FStaticVector<CvOperationUnit,20,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvOperationUnit@@$00@@QAE@XZ	; BaseVector<CvOperationUnit,1>::~BaseVector<CvOperationUnit,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvOperationUnit@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvOperationUnit@@$00@@QAE@XZ PROC	; BaseVector<CvOperationUnit,1>::~BaseVector<CvOperationUnit,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvOperationUnit@@$00@@QAE@XZ ENDP	; BaseVector<CvOperationUnit,1>::~BaseVector<CvOperationUnit,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvOperationUnit@@$00@@IAE@XZ	; BaseVector<CvOperationUnit,1>::BaseVector<CvOperationUnit,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvOperationUnit@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvOperationUnit@@$00@@IAE@XZ PROC	; BaseVector<CvOperationUnit,1>::BaseVector<CvOperationUnit,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvOperationUnit@@$00@@IAE@XZ ENDP	; BaseVector<CvOperationUnit,1>::BaseVector<CvOperationUnit,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvOperationUnit@@$00@@IAEXPAVCvOperationUnit@@I@Z ; BaseVector<CvOperationUnit,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvOperationUnit@@$00@@IAEXPAVCvOperationUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvOperationUnit@@$00@@IAEXPAVCvOperationUnit@@I@Z PROC ; BaseVector<CvOperationUnit,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvOperationUnit@@$00@@IAEXPAVCvOperationUnit@@I@Z ENDP ; BaseVector<CvOperationUnit,1>::Destroy
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@3
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPlot@@@std@@QAE@XZ		; std::allocator<CvPlot *>::allocator<CvPlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPlot@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvPlot@@@std@@QAE@XZ PROC		; std::allocator<CvPlot *>::allocator<CvPlot *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvPlot@@@std@@QAE@XZ ENDP		; std::allocator<CvPlot *>::allocator<CvPlot *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEABQAVCvTacticalMoveXMLEntry@@XZ ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEABQAVCvTacticalMoveXMLEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEABQAVCvTacticalMoveXMLEntry@@XZ PROC ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEABQAVCvTacticalMoveXMLEntry@@XZ ENDP ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::_Const_iterator<0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??0?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::_Const_iterator<0>, COMDAT
; _this$ = ecx

; 163  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 164  : 			}

	ret	0
??0?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::_Const_iterator<0>
_TEXT	ENDS
PUBLIC	??8?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBE_NABV012@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBE_NABV012@@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator==, COMDAT
; _this$ = ecx

; 291  : 
; 292  :  #if _HAS_ITERATOR_DEBUGGING
; 293  : 			_Compat(_Right);
; 294  :  #else
; 295  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 296  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 297  : 
; 298  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 299  : 			}

	ret	4
??8?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@3@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@3@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::_Mynode, COMDAT
; _this$ = ecx

; 308  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 309  : 			}

	ret	0
?_Mynode@?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@3@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::_Mynode
_TEXT	ENDS
PUBLIC	?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ		; CvGlobals::getMAX_HIT_POINTS
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMAX_HIT_POINTS, COMDAT
; _this$ = ecx

; 6497 : 		return m_iMAX_HIT_POINTS;

	mov	eax, DWORD PTR [ecx+7368]

; 6498 : 	}

	ret	0
?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMAX_HIT_POINTS
_TEXT	ENDS
PUBLIC	??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Const_iterator<0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Const_iterator<0>, COMDAT
; _this$ = ecx

; 163  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 164  : 			}

	ret	0
??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Const_iterator<0>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@XZ ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@XZ PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@XZ ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator*
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator==
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ PROC ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ENDP ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 24			; 00000018H

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator==
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T238464 = -80						; size = 28
$T238463 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T238464[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T238463[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T238464[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T238463[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T238463[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T238463[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T238463[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T238464[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T238463[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTacticalMoveXMLEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalMoveXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvTacticalMoveXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTacticalMoveXMLEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTacticalMoveXMLEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalMoveXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvTacticalMoveXMLEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTacticalMoveXMLEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalMoveXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvTacticalMoveXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvTacticalMoveXMLEntry *>::allocator<CvTacticalMoveXMLEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvTacticalMoveXMLEntry *>::allocator<CvTacticalMoveXMLEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvTacticalMoveXMLEntry *>::allocator<CvTacticalMoveXMLEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAEXPAPAVCvTacticalMoveXMLEntry@@I@Z ; std::allocator<CvTacticalMoveXMLEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAEXPAPAVCvTacticalMoveXMLEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAEXPAPAVCvTacticalMoveXMLEntry@@I@Z PROC ; std::allocator<CvTacticalMoveXMLEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAEXPAPAVCvTacticalMoveXMLEntry@@I@Z ENDP ; std::allocator<CvTacticalMoveXMLEntry *>::deallocate
_TEXT	ENDS
PUBLIC	?_Myval@?$list@HV?$allocator@H@std@@@std@@KAAAHPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ; std::list<int,std::allocator<int> >::_Myval
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Myval@?$list@HV?$allocator@H@std@@@std@@KAAAHPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@HV?$allocator@H@std@@@std@@KAAAHPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z PROC ; std::list<int,std::allocator<int> >::_Myval, COMDAT

; 125  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 126  : 		}

	ret	0
?_Myval@?$list@HV?$allocator@H@std@@@std@@KAAAHPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ENDP ; std::list<int,std::allocator<int> >::_Myval
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T238513 = -80						; size = 28
$T238512 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T238513[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T238512[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T238513[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T238512[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T238512[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T238512[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T238512[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T238513[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T238512[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE@V?$allocator@VCvTacticalUnit@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalUnit> >::_Container_base_aux_alloc_empty<std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE@V?$allocator@VCvTacticalUnit@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE@V?$allocator@VCvTacticalUnit@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalUnit> >::_Container_base_aux_alloc_empty<std::allocator<CvTacticalUnit> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE@V?$allocator@VCvTacticalUnit@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalUnit> >::_Container_base_aux_alloc_empty<std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvTacticalUnit@@@std@@QAE@ABV01@@Z ; std::allocator<CvTacticalUnit>::allocator<CvTacticalUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvTacticalUnit@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvTacticalUnit@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvTacticalUnit>::allocator<CvTacticalUnit>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvTacticalUnit@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvTacticalUnit>::allocator<CvTacticalUnit>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvTacticalUnit@@@std@@QAEXPAVCvTacticalUnit@@I@Z ; std::allocator<CvTacticalUnit>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@VCvTacticalUnit@@@std@@QAEXPAVCvTacticalUnit@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvTacticalUnit@@@std@@QAEXPAVCvTacticalUnit@@I@Z PROC ; std::allocator<CvTacticalUnit>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvTacticalUnit@@@std@@QAEXPAVCvTacticalUnit@@I@Z ENDP ; std::allocator<CvTacticalUnit>::deallocate
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION@CvGlobals@@QAEMXZ ; CvGlobals::getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION, COMDAT
; _this$ = ecx

; 7112 : 		return m_fAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION;

	fld	DWORD PTR [ecx+8100]

; 7113 : 	}

	ret	0
?getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T238551 = -80						; size = 28
$T238550 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T238551[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T238550[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T238551[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T238550[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T238550[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T238550[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T238550[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T238551[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T238550[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE@V?$allocator@VCvTacticalCity@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalCity> >::_Container_base_aux_alloc_empty<std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE@V?$allocator@VCvTacticalCity@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE@V?$allocator@VCvTacticalCity@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalCity> >::_Container_base_aux_alloc_empty<std::allocator<CvTacticalCity> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE@V?$allocator@VCvTacticalCity@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTacticalCity> >::_Container_base_aux_alloc_empty<std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvTacticalCity@@@std@@QAE@ABV01@@Z ; std::allocator<CvTacticalCity>::allocator<CvTacticalCity>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvTacticalCity@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvTacticalCity@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvTacticalCity>::allocator<CvTacticalCity>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvTacticalCity@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvTacticalCity>::allocator<CvTacticalCity>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvTacticalCity@@@std@@QAEXPAVCvTacticalCity@@I@Z ; std::allocator<CvTacticalCity>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@VCvTacticalCity@@@std@@QAEXPAVCvTacticalCity@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvTacticalCity@@@std@@QAEXPAVCvTacticalCity@@I@Z PROC ; std::allocator<CvTacticalCity>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvTacticalCity@@@std@@QAEXPAVCvTacticalCity@@I@Z ENDP ; std::allocator<CvTacticalCity>::deallocate
_TEXT	ENDS
PUBLIC	?_Myval@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@KAAAVCvQueuedAttack@@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Myval
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Myval@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@KAAAVCvQueuedAttack@@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@KAAAVCvQueuedAttack@@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Myval, COMDAT

; 125  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 126  : 		}

	ret	0
?_Myval@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@KAAAVCvQueuedAttack@@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvQueuedAttack@@@std@@QAE@ABV01@@Z ; std::allocator<CvQueuedAttack>::allocator<CvQueuedAttack>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvQueuedAttack@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvQueuedAttack@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvQueuedAttack>::allocator<CvQueuedAttack>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvQueuedAttack@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvQueuedAttack>::allocator<CvQueuedAttack>
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T238591 = -80						; size = 28
$T238590 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T238591[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T238590[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T238591[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T238590[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T238590[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T238590[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T238590[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@4:
$LN12@Xlen@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T238591[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T238590[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z	; std::allocator<CvPlot *>::allocator<CvPlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvPlot *>::allocator<CvPlot *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvPlot *>::allocator<CvPlot *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvPlot@@@std@@QAEXPAPAVCvPlot@@I@Z ; std::allocator<CvPlot *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvPlot@@@std@@QAEXPAPAVCvPlot@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvPlot@@@std@@QAEXPAPAVCvPlot@@I@Z PROC ; std::allocator<CvPlot *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvPlot@@@std@@QAEXPAPAVCvPlot@@I@Z ENDP ; std::allocator<CvPlot *>::deallocate
_TEXT	ENDS
PUBLIC	?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT, COMDAT
; _this$ = ecx

; 7355 : 		return m_iBARBARIAN_CAMP_IMPROVEMENT;

	mov	eax, DWORD PTR [ecx+8548]

; 7356 : 	}

	ret	0
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@PAPAVCvTacticalMoveXMLEntry@@@Z ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@PAPAVCvTacticalMoveXMLEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@PAPAVCvTacticalMoveXMLEntry@@@Z PROC ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@PAPAVCvTacticalMoveXMLEntry@@@Z ENDP ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::_Const_iterator<0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??0?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::_Const_iterator<0>, COMDAT
; _this$ = ecx

; 184  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 185  : 			}

	ret	4
??0?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::_Const_iterator<0>
_TEXT	ENDS
PUBLIC	??E?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEAAV012@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEAAV012@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// preincrement

	mov	eax, ecx

; 236  : 
; 237  :  #if _HAS_ITERATOR_DEBUGGING
; 238  : 			if (this->_Mycont == 0
; 239  : 				|| _Ptr == 0
; 240  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 241  : 				{
; 242  : 				_DEBUG_ERROR("list iterator not incrementable");
; 243  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 244  : 				}
; 245  :  #else
; 246  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 247  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 248  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 249  : 
; 250  : 			_Ptr = _Nextnode(_Ptr);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 251  : 			return (*this);
; 252  : 			}

	ret	0
??E?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Const_iterator<0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Const_iterator<0>, COMDAT
; _this$ = ecx

; 184  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 185  : 			}

	ret	4
??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Const_iterator<0>
_TEXT	ENDS
PUBLIC	??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// preincrement

	mov	eax, ecx

; 236  : 
; 237  :  #if _HAS_ITERATOR_DEBUGGING
; 238  : 			if (this->_Mycont == 0
; 239  : 				|| _Ptr == 0
; 240  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 241  : 				{
; 242  : 				_DEBUG_ERROR("list iterator not incrementable");
; 243  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 244  : 				}
; 245  :  #else
; 246  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 247  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 248  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 249  : 
; 250  : 			_Ptr = _Nextnode(_Ptr);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 251  : 			return (*this);
; 252  : 			}

	ret	0
??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator++, COMDAT
; _this$ = ecx

; 256  : 			_Myt_iter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 257  : 			++*this;

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 258  : 			return (_Tmp);
; 259  : 			}

	ret	8
??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator++
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@3@XZ ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@3@XZ PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Mynode, COMDAT
; _this$ = ecx

; 308  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 309  : 			}

	ret	0
?_Mynode@?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@3@XZ ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Mynode
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator-
_TEXT	ENDS
PUBLIC	?getPILLAGE_HEAL_AMOUNT@CvGlobals@@QAEHXZ	; CvGlobals::getPILLAGE_HEAL_AMOUNT
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getPILLAGE_HEAL_AMOUNT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPILLAGE_HEAL_AMOUNT@CvGlobals@@QAEHXZ PROC		; CvGlobals::getPILLAGE_HEAL_AMOUNT, COMDAT
; _this$ = ecx

; 7495 : 		return m_iPILLAGE_HEAL_AMOUNT;

	mov	eax, DWORD PTR [ecx+8184]

; 7496 : 	}

	ret	0
?getPILLAGE_HEAL_AMOUNT@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getPILLAGE_HEAL_AMOUNT
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 1
	jbe	SHORT $LN2@Alloc@9

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@9:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 1
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@ABU01@@Z ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@PAVCvTacticalUnit@@@Z ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@PAVCvTacticalUnit@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@PAVCvTacticalUnit@@@Z PROC ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@PAVCvTacticalUnit@@@Z ENDP ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEABVCvTacticalUnit@@XZ ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEABVCvTacticalUnit@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEABVCvTacticalUnit@@XZ PROC ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEABVCvTacticalUnit@@XZ ENDP ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator*
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@PAVCvTacticalCity@@@Z ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@PAVCvTacticalCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@PAVCvTacticalCity@@@Z PROC ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@PAVCvTacticalCity@@@Z ENDP ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator-
_TEXT	ENDS
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@SAPAXIIII@Z ; BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator::AllocAligned
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@SAPAXIIII@Z PROC ; BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@SAPAXIIII@Z ENDP ; BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@SAXPAX@Z ; BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator::FreeAligned
; Function compile flags: /Ogtpy
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@SAXPAX@Z PROC ; BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@SAXPAX@Z ENDP ; BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QBEIXZ ; std::allocator<CvTacticalMoveXMLEntry *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QBEIXZ PROC ; std::allocator<CvTacticalMoveXMLEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvTacticalMoveXMLEntry *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvTacticalUnit@@@std@@QBEIXZ ; std::allocator<CvTacticalUnit>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@VCvTacticalUnit@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvTacticalUnit@@@std@@QBEIXZ PROC ; std::allocator<CvTacticalUnit>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 178956970				; 0aaaaaaaH

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvTacticalUnit@@@std@@QBEIXZ ENDP ; std::allocator<CvTacticalUnit>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvTacticalCity@@@std@@QBEIXZ ; std::allocator<CvTacticalCity>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@VCvTacticalCity@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvTacticalCity@@@std@@QBEIXZ PROC ; std::allocator<CvTacticalCity>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 357913941				; 15555555H

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvTacticalCity@@@std@@QBEIXZ ENDP ; std::allocator<CvTacticalCity>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ	; std::allocator<CvPlot *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ PROC	; std::allocator<CvPlot *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ ENDP	; std::allocator<CvPlot *>::max_size
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@V?$allocator@VCvQueuedAttack@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvQueuedAttack> >::_Container_base_aux_alloc_empty<std::allocator<CvQueuedAttack> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@V?$allocator@VCvQueuedAttack@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@V?$allocator@VCvQueuedAttack@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvQueuedAttack> >::_Container_base_aux_alloc_empty<std::allocator<CvQueuedAttack> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@V?$allocator@VCvQueuedAttack@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvQueuedAttack> >::_Container_base_aux_alloc_empty<std::allocator<CvQueuedAttack> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvQueuedAttack@@@std@@QBEIXZ ; std::allocator<CvQueuedAttack>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@VCvQueuedAttack@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvQueuedAttack@@@std@@QBEIXZ PROC ; std::allocator<CvQueuedAttack>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 107374182				; 06666666H

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvQueuedAttack@@@std@@QBEIXZ ENDP ; std::allocator<CvQueuedAttack>::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator+=
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvTacticalMoveXMLEntry@@@@YAXAAPAVCvTacticalMoveXMLEntry@@@Z ; SAFE_DELETE<CvTacticalMoveXMLEntry>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvTacticalMoveXMLEntry@@@@YAXAAPAVCvTacticalMoveXMLEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvTacticalMoveXMLEntry@@@@YAXAAPAVCvTacticalMoveXMLEntry@@@Z PROC ; SAFE_DELETE<CvTacticalMoveXMLEntry>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvTacticalMoveXMLEntry@@@@YAXAAPAVCvTacticalMoveXMLEntry@@@Z ENDP ; SAFE_DELETE<CvTacticalMoveXMLEntry>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z ; std::_Destroy<std::_List_nod<int,std::allocator<int> >::_Node>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z PROC ; std::_Destroy<std::_List_nod<int,std::allocator<int> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<int,std::allocator<int> >::_Node>
_TEXT	ENDS
PUBLIC	?GetBarbarianReleaseTurn@CvGame@@QBEHXZ		; CvGame::GetBarbarianReleaseTurn
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvgame.h
;	COMDAT ?GetBarbarianReleaseTurn@CvGame@@QBEHXZ
_TEXT	SEGMENT
?GetBarbarianReleaseTurn@CvGame@@QBEHXZ PROC		; CvGame::GetBarbarianReleaseTurn, COMDAT
; _this$ = ecx

; 501  : 		return m_iEarliestBarbarianReleaseTurn;

	mov	eax, DWORD PTR [ecx+604]

; 502  : 	};

	ret	0
?GetBarbarianReleaseTurn@CvGame@@QBEHXZ ENDP		; CvGame::GetBarbarianReleaseTurn
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@@Z PROC ; std::_Destroy<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>
_TEXT	ENDS
PUBLIC	?GetLastTurnMoved@CvAIOperation@@QBEHXZ		; CvAIOperation::GetLastTurnMoved
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
;	COMDAT ?GetLastTurnMoved@CvAIOperation@@QBEHXZ
_TEXT	SEGMENT
?GetLastTurnMoved@CvAIOperation@@QBEHXZ PROC		; CvAIOperation::GetLastTurnMoved, COMDAT
; _this$ = ecx

; 174  : 		return m_iLastTurnMoved;

	mov	eax, DWORD PTR [ecx+68]

; 175  : 	};

	ret	0
?GetLastTurnMoved@CvAIOperation@@QBEHXZ ENDP		; CvAIOperation::GetLastTurnMoved
_TEXT	ENDS
PUBLIC	?SetLastTurnMoved@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetLastTurnMoved
; Function compile flags: /Ogtpy
;	COMDAT ?SetLastTurnMoved@CvAIOperation@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetLastTurnMoved@CvAIOperation@@QAEXH@Z PROC		; CvAIOperation::SetLastTurnMoved, COMDAT
; _this$ = ecx

; 178  : 		m_iLastTurnMoved = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+68], eax

; 179  : 	};

	ret	4
?SetLastTurnMoved@CvAIOperation@@QAEXH@Z ENDP		; CvAIOperation::SetLastTurnMoved
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvTacticalMoveXMLEntry@@@std@@YAPAPAVCvTacticalMoveXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvTacticalMoveXMLEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvTacticalMoveXMLEntry@@@std@@YAPAPAVCvTacticalMoveXMLEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T238791 = -12						; size = 12
$T238795 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvTacticalMoveXMLEntry@@@std@@YAPAPAVCvTacticalMoveXMLEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvTacticalMoveXMLEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T238795[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T238791[esp+16]
	mov	DWORD PTR $T238795[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T238791[esp+16]
	push	ecx
	mov	DWORD PTR $T238791[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvTacticalMoveXMLEntry@@@std@@YAPAPAVCvTacticalMoveXMLEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvTacticalMoveXMLEntry *>
_TEXT	ENDS
PUBLIC	??$?0H@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::allocator<std::_List_nod<int,std::allocator<int> >::_Node *><int>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0H@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0H@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::allocator<std::_List_nod<int,std::allocator<int> >::_Node *><int>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0H@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::allocator<std::_List_nod<int,std::allocator<int> >::_Node *><int>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<int,std::allocator<int> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T238804 = -12						; size = 12
$T238808 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<int,std::allocator<int> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T238808[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T238804[esp+16]
	mov	DWORD PTR $T238808[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T238804[esp+16]
	push	ecx
	mov	DWORD PTR $T238804[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<int,std::allocator<int> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<int,std::allocator<int> >::_Node *,std::_List_nod<int,std::allocator<int> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_List_nod<int,std::allocator<int> >::_Node *,std::_List_nod<int,std::allocator<int> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<int,std::allocator<int> >::_Node *,std::_List_nod<int,std::allocator<int> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z ; std::_Destroy<std::_List_nod<int,std::allocator<int> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z PROC ; std::_Destroy<std::_List_nod<int,std::allocator<int> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<int,std::allocator<int> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Allocate@VCvTacticalUnit@@@std@@YAPAVCvTacticalUnit@@IPAV1@@Z ; std::_Allocate<CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@VCvTacticalUnit@@@std@@YAPAVCvTacticalUnit@@IPAV1@@Z
_TEXT	SEGMENT
$T238826 = -12						; size = 12
$T238830 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvTacticalUnit@@@std@@YAPAVCvTacticalUnit@@IPAV1@@Z PROC ; std::_Allocate<CvTacticalUnit>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T238830[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T238826[esp+16]
	mov	DWORD PTR $T238830[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T238826[esp+16]
	push	ecx
	mov	DWORD PTR $T238826[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@VCvTacticalUnit@@@std@@YAPAVCvTacticalUnit@@IPAV1@@Z ENDP ; std::_Allocate<CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$_Allocate@VCvTacticalCity@@@std@@YAPAVCvTacticalCity@@IPAV1@@Z ; std::_Allocate<CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@VCvTacticalCity@@@std@@YAPAVCvTacticalCity@@IPAV1@@Z
_TEXT	SEGMENT
$T238836 = -12						; size = 12
$T238840 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvTacticalCity@@@std@@YAPAVCvTacticalCity@@IPAV1@@Z PROC ; std::_Allocate<CvTacticalCity>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T238840[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T238836[esp+16]
	mov	DWORD PTR $T238840[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T238836[esp+16]
	push	ecx
	mov	DWORD PTR $T238836[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@VCvTacticalCity@@@std@@YAPAVCvTacticalCity@@IPAV1@@Z ENDP ; std::_Allocate<CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$?0VCvQueuedAttack@@@?$allocator@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAE@ABV?$allocator@VCvQueuedAttack@@@1@@Z ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *><CvQueuedAttack>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0VCvQueuedAttack@@@?$allocator@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAE@ABV?$allocator@VCvQueuedAttack@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0VCvQueuedAttack@@@?$allocator@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAE@ABV?$allocator@VCvQueuedAttack@@@1@@Z PROC ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *><CvQueuedAttack>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0VCvQueuedAttack@@@?$allocator@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAE@ABV?$allocator@VCvQueuedAttack@@@1@@Z ENDP ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *><CvQueuedAttack>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T238849 = -12						; size = 12
$T238853 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	shl	edx, 4
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 48					; 00000030H
	jae	SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T238853[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T238849[esp+16]
	mov	DWORD PTR $T238853[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T238849[esp+16]
	push	ecx
	mov	DWORD PTR $T238849[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@5:
$LN8@Allocate@5:
	int	3
??$_Allocate@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *,std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *,std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *,std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@@Z PROC ; std::_Destroy<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z
_TEXT	SEGMENT
$T238871 = -12						; size = 12
$T238875 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z PROC ; std::_Allocate<CvPlot *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T238875[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T238871[esp+16]
	mov	DWORD PTR $T238875[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T238871[esp+16]
	push	ecx
	mov	DWORD PTR $T238871[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@6:
$LN8@Allocate@6:
	int	3
??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ENDP ; std::_Allocate<CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Construct@HH@std@@YAXPAHABH@Z		; std::_Construct<int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@HH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@HH@std@@YAXPAHABH@Z PROC			; std::_Construct<int,int>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@3:

; 53   : 	}

	ret	0
??$_Construct@HH@std@@YAXPAHABH@Z ENDP			; std::_Construct<int,int>
_TEXT	ENDS
PUBLIC	??$?0H@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocator<std::_List_nod<int,std::allocator<int> >::_Node><int>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0H@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0H@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocator<std::_List_nod<int,std::allocator<int> >::_Node><int>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0H@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocator<std::_List_nod<int,std::allocator<int> >::_Node><int>
_TEXT	ENDS
PUBLIC	??$?0VCvQueuedAttack@@@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAE@ABV?$allocator@VCvQueuedAttack@@@1@@Z ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node><CvQueuedAttack>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0VCvQueuedAttack@@@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAE@ABV?$allocator@VCvQueuedAttack@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0VCvQueuedAttack@@@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAE@ABV?$allocator@VCvQueuedAttack@@@1@@Z PROC ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node><CvQueuedAttack>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0VCvQueuedAttack@@@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAE@ABV?$allocator@VCvQueuedAttack@@@1@@Z ENDP ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node><CvQueuedAttack>
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvTemporaryZone@@$00@@QBEABVCvTemporaryZone@@I@Z ; BaseVector<CvTemporaryZone,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@VCvTemporaryZone@@$00@@QBEABVCvTemporaryZone@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvTemporaryZone@@$00@@QBEABVCvTemporaryZone@@I@Z PROC ; BaseVector<CvTemporaryZone,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 137  : 	};

	ret	4
??A?$BaseVector@VCvTemporaryZone@@$00@@QBEABVCvTemporaryZone@@I@Z ENDP ; BaseVector<CvTemporaryZone,1>::operator[]
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAVCvTacticalMove@@@std@@YAPAHPAVCvTacticalMove@@@Z ; std::_Dist_type<CvTacticalMove *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PAVCvTacticalMove@@@std@@YAPAHPAVCvTacticalMove@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAVCvTacticalMove@@@std@@YAPAHPAVCvTacticalMove@@@Z PROC ; std::_Dist_type<CvTacticalMove *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAVCvTacticalMove@@@std@@YAPAHPAVCvTacticalMove@@@Z ENDP ; std::_Dist_type<CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAVCvTacticalMove@@@std@@YAPAVCvTacticalMove@@PAV1@@Z ; std::_Val_type<CvTacticalMove *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAVCvTacticalMove@@@std@@YAPAVCvTacticalMove@@PAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAVCvTacticalMove@@@std@@YAPAVCvTacticalMove@@PAV1@@Z PROC ; std::_Val_type<CvTacticalMove *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAVCvTacticalMove@@@std@@YAPAVCvTacticalMove@@PAV1@@Z ENDP ; std::_Val_type<CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAVCvTacticalTarget@@@std@@YAPAHPAVCvTacticalTarget@@@Z ; std::_Dist_type<CvTacticalTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@PAVCvTacticalTarget@@@std@@YAPAHPAVCvTacticalTarget@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAVCvTacticalTarget@@@std@@YAPAHPAVCvTacticalTarget@@@Z PROC ; std::_Dist_type<CvTacticalTarget *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAVCvTacticalTarget@@@std@@YAPAHPAVCvTacticalTarget@@@Z ENDP ; std::_Dist_type<CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAVCvTacticalTarget@@@std@@YAPAVCvTacticalTarget@@PAV1@@Z ; std::_Val_type<CvTacticalTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAVCvTacticalTarget@@@std@@YAPAVCvTacticalTarget@@PAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAVCvTacticalTarget@@@std@@YAPAVCvTacticalTarget@@PAV1@@Z PROC ; std::_Val_type<CvTacticalTarget *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAVCvTacticalTarget@@@std@@YAPAVCvTacticalTarget@@PAV1@@Z ENDP ; std::_Val_type<CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Val_type@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAPAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAPAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAPAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAPAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Dist_type@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Val_type@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAPAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAPAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAPAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAPAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAVCvBlockingUnit@@@std@@YAPAHPAVCvBlockingUnit@@@Z ; std::_Dist_type<CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@PAVCvBlockingUnit@@@std@@YAPAHPAVCvBlockingUnit@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAVCvBlockingUnit@@@std@@YAPAHPAVCvBlockingUnit@@@Z PROC ; std::_Dist_type<CvBlockingUnit *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAVCvBlockingUnit@@@std@@YAPAHPAVCvBlockingUnit@@@Z ENDP ; std::_Dist_type<CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAVCvBlockingUnit@@@std@@YAPAVCvBlockingUnit@@PAV1@@Z ; std::_Val_type<CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAVCvBlockingUnit@@@std@@YAPAVCvBlockingUnit@@PAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAVCvBlockingUnit@@@std@@YAPAVCvBlockingUnit@@PAV1@@Z PROC ; std::_Val_type<CvBlockingUnit *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAVCvBlockingUnit@@@std@@YAPAVCvBlockingUnit@@PAV1@@Z ENDP ; std::_Val_type<CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvPlot@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@0@Z ; std::_Iter_random<CvPlot * *,CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvPlot@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvPlot@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@0@Z PROC ; std::_Iter_random<CvPlot * *,CvPlot * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvPlot@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@0@Z ENDP ; std::_Iter_random<CvPlot * *,CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvPlot@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlot@@0@Z ; std::_Ptr_cat<CvPlot * *,CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvPlot@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlot@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvPlot@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlot@@0@Z PROC ; std::_Ptr_cat<CvPlot * *,CvPlot * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvPlot@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlot@@0@Z ENDP ; std::_Ptr_cat<CvPlot * *,CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTacticalMoveXMLEntry@@0@Z ; std::_Iter_random<CvTacticalMoveXMLEntry * *,CvTacticalMoveXMLEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTacticalMoveXMLEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTacticalMoveXMLEntry@@0@Z PROC ; std::_Iter_random<CvTacticalMoveXMLEntry * *,CvTacticalMoveXMLEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTacticalMoveXMLEntry@@0@Z ENDP ; std::_Iter_random<CvTacticalMoveXMLEntry * *,CvTacticalMoveXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTacticalMoveXMLEntry@@0@Z ; std::_Ptr_cat<CvTacticalMoveXMLEntry * *,CvTacticalMoveXMLEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTacticalMoveXMLEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTacticalMoveXMLEntry@@0@Z PROC ; std::_Ptr_cat<CvTacticalMoveXMLEntry * *,CvTacticalMoveXMLEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTacticalMoveXMLEntry@@0@Z ENDP ; std::_Ptr_cat<CvTacticalMoveXMLEntry * *,CvTacticalMoveXMLEntry * *>
_TEXT	ENDS
PUBLIC	?GetUnitID@CvArmyFormationSlot@@QAEHXZ		; CvArmyFormationSlot::GetUnitID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.h
;	COMDAT ?GetUnitID@CvArmyFormationSlot@@QAEHXZ
_TEXT	SEGMENT
?GetUnitID@CvArmyFormationSlot@@QAEHXZ PROC		; CvArmyFormationSlot::GetUnitID, COMDAT
; _this$ = ecx

; 41   : 		return m_iUnitID;

	mov	eax, DWORD PTR [ecx]

; 42   : 	};

	ret	0
?GetUnitID@CvArmyFormationSlot@@QAEHXZ ENDP		; CvArmyFormationSlot::GetUnitID
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTacticalMoveXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalMoveXMLEntry * *,CvTacticalMoveXMLEntry * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTacticalMoveXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTacticalMoveXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTacticalMoveXMLEntry * *,CvTacticalMoveXMLEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@2:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTacticalMoveXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTacticalMoveXMLEntry * *,CvTacticalMoveXMLEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@0@Z ; std::_Iter_random<CvTacticalUnit *,CvTacticalUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvTacticalUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvTacticalUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@0@Z PROC ; std::_Iter_random<CvTacticalUnit *,CvTacticalUnit *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvTacticalUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@0@Z ENDP ; std::_Iter_random<CvTacticalUnit *,CvTacticalUnit *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvTacticalUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalUnit@@0@Z ; std::_Ptr_cat<CvTacticalUnit *,CvTacticalUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvTacticalUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalUnit@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvTacticalUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalUnit@@0@Z PROC ; std::_Ptr_cat<CvTacticalUnit *,CvTacticalUnit *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvTacticalUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalUnit@@0@Z ENDP ; std::_Ptr_cat<CvTacticalUnit *,CvTacticalUnit *>
_TEXT	ENDS
PUBLIC	?HasStartedOnOperation@CvArmyFormationSlot@@QAE_NXZ ; CvArmyFormationSlot::HasStartedOnOperation
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.h
;	COMDAT ?HasStartedOnOperation@CvArmyFormationSlot@@QAE_NXZ
_TEXT	SEGMENT
?HasStartedOnOperation@CvArmyFormationSlot@@QAE_NXZ PROC ; CvArmyFormationSlot::HasStartedOnOperation, COMDAT
; _this$ = ecx

; 57   : 		return m_bStartedOnOperation;

	cmp	DWORD PTR [ecx+8], 0
	setne	al

; 58   : 	};

	ret	0
?HasStartedOnOperation@CvArmyFormationSlot@@QAE_NXZ ENDP ; CvArmyFormationSlot::HasStartedOnOperation
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@3
	push	esi
$LL3@Copy_opt@3:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
	add	ecx, 24					; 00000018H
	add	eax, 24					; 00000018H
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@3
	pop	esi
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?SetStartedOnOperation@CvArmyFormationSlot@@QAEX_N@Z ; CvArmyFormationSlot::SetStartedOnOperation
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.h
;	COMDAT ?SetStartedOnOperation@CvArmyFormationSlot@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetStartedOnOperation@CvArmyFormationSlot@@QAEX_N@Z PROC ; CvArmyFormationSlot::SetStartedOnOperation, COMDAT
; _this$ = ecx

; 61   : 		m_bStartedOnOperation = bValue;

	movzx	eax, BYTE PTR _bValue$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 62   : 	};

	ret	4
?SetStartedOnOperation@CvArmyFormationSlot@@QAEX_N@Z ENDP ; CvArmyFormationSlot::SetStartedOnOperation
_TEXT	ENDS
PUBLIC	?GetOperationID@CvArmyAI@@QBEHXZ		; CvArmyAI::GetOperationID
; Function compile flags: /Ogtpy
;	COMDAT ?GetOperationID@CvArmyAI@@QBEHXZ
_TEXT	SEGMENT
?GetOperationID@CvArmyAI@@QBEHXZ PROC			; CvArmyAI::GetOperationID, COMDAT
; _this$ = ecx

; 131  : 		return m_iOperationID;

	mov	eax, DWORD PTR [ecx+12]

; 132  : 	}

	ret	0
?GetOperationID@CvArmyAI@@QBEHXZ ENDP			; CvArmyAI::GetOperationID
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalCity@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@0@Z ; std::_Iter_random<CvTacticalCity *,CvTacticalCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvTacticalCity@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvTacticalCity@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@0@Z PROC ; std::_Iter_random<CvTacticalCity *,CvTacticalCity *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvTacticalCity@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@0@Z ENDP ; std::_Iter_random<CvTacticalCity *,CvTacticalCity *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvTacticalCity@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalCity@@0@Z ; std::_Ptr_cat<CvTacticalCity *,CvTacticalCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvTacticalCity@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalCity@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvTacticalCity@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalCity@@0@Z PROC ; std::_Ptr_cat<CvTacticalCity *,CvTacticalCity *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvTacticalCity@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalCity@@0@Z ENDP ; std::_Ptr_cat<CvTacticalCity *,CvTacticalCity *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvTacticalCity@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalCity@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalCity *,CvTacticalCity *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvTacticalCity@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalCity@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvTacticalCity@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalCity@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTacticalCity *,CvTacticalCity *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@4
	push	esi
$LL3@Copy_opt@4:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@4
	pop	esi
$LN1@Copy_opt@4:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvTacticalCity@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalCity@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTacticalCity *,CvTacticalCity *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPlot *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@YAXPAPAVCvTacticalMoveXMLEntry@@0AAV?$allocator@PAVCvTacticalMoveXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvTacticalMoveXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@YAXPAPAVCvTacticalMoveXMLEntry@@0AAV?$allocator@PAVCvTacticalMoveXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@YAXPAPAVCvTacticalMoveXMLEntry@@0AAV?$allocator@PAVCvTacticalMoveXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTacticalMoveXMLEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@YAXPAPAVCvTacticalMoveXMLEntry@@0AAV?$allocator@PAVCvTacticalMoveXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTacticalMoveXMLEntry *> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@0ABV1@@Z ; std::_Fill<CvTacticalUnit *,CvTacticalUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAVCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@0ABV1@@Z PROC ; std::_Fill<CvTacticalUnit *,CvTacticalUnit>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
	add	eax, 24					; 00000018H
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAVCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@0ABV1@@Z ENDP ; std::_Fill<CvTacticalUnit *,CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvTacticalUnit@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvTacticalUnit@@@Z ; std::_Move_cat<CvTacticalUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvTacticalUnit@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvTacticalUnit@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvTacticalUnit@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvTacticalUnit@@@Z PROC ; std::_Move_cat<CvTacticalUnit *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvTacticalUnit@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvTacticalUnit@@@Z ENDP ; std::_Move_cat<CvTacticalUnit *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@0ABV1@@Z ; std::_Fill<CvTacticalCity *,CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAVCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@0ABV1@@Z PROC ; std::_Fill<CvTacticalCity *,CvTacticalCity>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAVCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@0ABV1@@Z ENDP ; std::_Fill<CvTacticalCity *,CvTacticalCity>
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvTacticalCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvTacticalCity@@@Z ; std::_Move_cat<CvTacticalCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvTacticalCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvTacticalCity@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvTacticalCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvTacticalCity@@@Z PROC ; std::_Move_cat<CvTacticalCity *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvTacticalCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvTacticalCity@@@Z ENDP ; std::_Move_cat<CvTacticalCity *>
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ; std::_Fill<CvPlot * *,CvPlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z PROC ; std::_Fill<CvPlot * *,CvPlot *>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@3
	pop	esi
$LN1@Fill@3:

; 3160 : 	}

	ret	0
??$_Fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ENDP ; std::_Fill<CvPlot * *,CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAPAVCvPlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvPlot@@@Z ; std::_Move_cat<CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAPAVCvPlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvPlot@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVCvPlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvPlot@@@Z PROC ; std::_Move_cat<CvPlot * *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAPAVCvPlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvPlot@@@Z ENDP ; std::_Move_cat<CvPlot * *>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@H@Z ; std::_Temp_iterator<CvTacticalMove>::_Temp_iterator<CvTacticalMove>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@H@Z PROC	; std::_Temp_iterator<CvTacticalMove>::_Temp_iterator<CvTacticalMove>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@H@Z ENDP	; std::_Temp_iterator<CvTacticalMove>::_Temp_iterator<CvTacticalMove>
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@H@Z ; std::_Temp_iterator<CvTacticalTarget>::_Temp_iterator<CvTacticalTarget>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@H@Z PROC ; std::_Temp_iterator<CvTacticalTarget>::_Temp_iterator<CvTacticalTarget>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@H@Z ENDP ; std::_Temp_iterator<CvTacticalTarget>::_Temp_iterator<CvTacticalTarget>
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@H@Z ; std::_Temp_iterator<CvTacticalUnit>::_Temp_iterator<CvTacticalUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@H@Z PROC	; std::_Temp_iterator<CvTacticalUnit>::_Temp_iterator<CvTacticalUnit>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@H@Z ENDP	; std::_Temp_iterator<CvTacticalUnit>::_Temp_iterator<CvTacticalUnit>
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@H@Z ; std::_Temp_iterator<CvTacticalCity>::_Temp_iterator<CvTacticalCity>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@H@Z PROC	; std::_Temp_iterator<CvTacticalCity>::_Temp_iterator<CvTacticalCity>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@H@Z ENDP	; std::_Temp_iterator<CvTacticalCity>::_Temp_iterator<CvTacticalCity>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@H@Z ; std::_Temp_iterator<CvBlockingUnit>::_Temp_iterator<CvBlockingUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@H@Z PROC	; std::_Temp_iterator<CvBlockingUnit>::_Temp_iterator<CvBlockingUnit>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@H@Z ENDP	; std::_Temp_iterator<CvBlockingUnit>::_Temp_iterator<CvBlockingUnit>
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-24]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR [eax-24], esi
	mov	esi, DWORD PTR [ecx+4]
	sub	eax, 24					; 00000018H
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvTacticalCity@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalCity@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalCity *,CvTacticalCity *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvTacticalCity@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalCity@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvTacticalCity@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalCity@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvTacticalCity *,CvTacticalCity *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvTacticalCity@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalCity@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvTacticalCity *,CvTacticalCity *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@3

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@3:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@ABV1@@Z ; std::_Construct<CvTacticalUnit,CvTacticalUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@VCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@ABV1@@Z PROC ; std::_Construct<CvTacticalUnit,CvTacticalUnit>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx
$LN3@Construct@4:

; 53   : 	}

	ret	0
??$_Construct@VCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@ABV1@@Z ENDP ; std::_Construct<CvTacticalUnit,CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvTacticalUnit@@@std@@YAXPAVCvTacticalUnit@@@Z ; std::_Destroy<CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvTacticalUnit@@@std@@YAXPAVCvTacticalUnit@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvTacticalUnit@@@std@@YAXPAVCvTacticalUnit@@@Z PROC ; std::_Destroy<CvTacticalUnit>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvTacticalUnit@@@std@@YAXPAVCvTacticalUnit@@@Z ENDP ; std::_Destroy<CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@ABV1@@Z ; std::_Construct<CvTacticalCity,CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@VCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@ABV1@@Z PROC ; std::_Construct<CvTacticalCity,CvTacticalCity>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@5
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN3@Construct@5:

; 53   : 	}

	ret	0
??$_Construct@VCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@ABV1@@Z ENDP ; std::_Construct<CvTacticalCity,CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvTacticalCity@@@std@@YAXPAVCvTacticalCity@@@Z ; std::_Destroy<CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvTacticalCity@@@std@@YAXPAVCvTacticalCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvTacticalCity@@@std@@YAXPAVCvTacticalCity@@@Z PROC ; std::_Destroy<CvTacticalCity>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvTacticalCity@@@std@@YAXPAVCvTacticalCity@@@Z ENDP ; std::_Destroy<CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@@Z ; std::_Destroy<CvTacticalMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@@Z PROC ; std::_Destroy<CvTacticalMove>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@@Z ENDP ; std::_Destroy<CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@VCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@@Z ; std::return_temporary_buffer<CvTacticalMove>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@VCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@VCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@@Z PROC ; std::return_temporary_buffer<CvTacticalMove>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@VCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@@Z ENDP ; std::return_temporary_buffer<CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@@Z ; std::_Destroy<CvTacticalTarget>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@VCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@@Z PROC ; std::_Destroy<CvTacticalTarget>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@@Z ENDP ; std::_Destroy<CvTacticalTarget>
_TEXT	ENDS
PUBLIC	?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z	; CvTacticalAnalysisCell::GetBit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z
_TEXT	SEGMENT
_uiFlag$ = 8						; size = 4
?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z PROC		; CvTacticalAnalysisCell::GetBit, COMDAT
; _this$ = ecx

; 83   : 	FBITFLAGS(uint);

	mov	eax, DWORD PTR [ecx]
	and	eax, DWORD PTR _uiFlag$[esp-4]
	neg	eax
	sbb	eax, eax
	neg	eax
	ret	4
?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z ENDP		; CvTacticalAnalysisCell::GetBit
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@VCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@@Z ; std::return_temporary_buffer<CvTacticalTarget>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@VCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@VCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@@Z PROC ; std::return_temporary_buffer<CvTacticalTarget>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@VCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@@Z ENDP ; std::return_temporary_buffer<CvTacticalTarget>
_TEXT	ENDS
PUBLIC	?SetBit@CvTacticalAnalysisCell@@QAEXI_N@Z	; CvTacticalAnalysisCell::SetBit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?SetBit@CvTacticalAnalysisCell@@QAEXI_N@Z
_TEXT	SEGMENT
_uiFlag$ = 8						; size = 4
_bOn$ = 12						; size = 1
?SetBit@CvTacticalAnalysisCell@@QAEXI_N@Z PROC		; CvTacticalAnalysisCell::SetBit, COMDAT
; _this$ = ecx

; 83   : 	FBITFLAGS(uint);

	cmp	BYTE PTR _bOn$[esp-4], 0
	je	SHORT $LN2@SetBit
	mov	eax, DWORD PTR _uiFlag$[esp-4]
	or	DWORD PTR [ecx], eax
	ret	8
$LN2@SetBit:
	mov	edx, DWORD PTR _uiFlag$[esp-4]
	not	edx
	and	DWORD PTR [ecx], edx
	ret	8
?SetBit@CvTacticalAnalysisCell@@QAEXI_N@Z ENDP		; CvTacticalAnalysisCell::SetBit
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@VCvTacticalUnit@@@std@@YAXPAVCvTacticalUnit@@@Z ; std::return_temporary_buffer<CvTacticalUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@VCvTacticalUnit@@@std@@YAXPAVCvTacticalUnit@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@VCvTacticalUnit@@@std@@YAXPAVCvTacticalUnit@@@Z PROC ; std::return_temporary_buffer<CvTacticalUnit>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@VCvTacticalUnit@@@std@@YAXPAVCvTacticalUnit@@@Z ENDP ; std::return_temporary_buffer<CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@VCvTacticalCity@@@std@@YAXPAVCvTacticalCity@@@Z ; std::return_temporary_buffer<CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$return_temporary_buffer@VCvTacticalCity@@@std@@YAXPAVCvTacticalCity@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@VCvTacticalCity@@@std@@YAXPAVCvTacticalCity@@@Z PROC ; std::return_temporary_buffer<CvTacticalCity>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@VCvTacticalCity@@@std@@YAXPAVCvTacticalCity@@@Z ENDP ; std::return_temporary_buffer<CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@@Z ; std::_Destroy<CvBlockingUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@VCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@@Z PROC ; std::_Destroy<CvBlockingUnit>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@@Z ENDP ; std::_Destroy<CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@VCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@@Z ; std::return_temporary_buffer<CvBlockingUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@VCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@VCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@@Z PROC ; std::return_temporary_buffer<CvBlockingUnit>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@VCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@@Z ENDP ; std::return_temporary_buffer<CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBE_NABU01@@Z ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsRevealed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsRevealed, COMDAT
; _this$ = ecx

; 92   : 		return GetBit(TACTICAL_FLAG_REVEALED);

	mov	eax, DWORD PTR [ecx]
	and	eax, 1

; 93   : 	};

	ret	0
?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsRevealed
_TEXT	ENDS
PUBLIC	?IsSubjectToAttack@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsSubjectToAttack
; Function compile flags: /Ogtpy
;	COMDAT ?IsSubjectToAttack@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsSubjectToAttack@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsSubjectToAttack, COMDAT
; _this$ = ecx

; 132  : 		return GetBit(TACTICAL_FLAG_SUBJECT_TO_ENEMY_ATTACK);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 5
	and	eax, 1

; 133  : 	};

	ret	0
?IsSubjectToAttack@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsSubjectToAttack
_TEXT	ENDS
PUBLIC	?IsEnemyCanMovePast@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsEnemyCanMovePast
; Function compile flags: /Ogtpy
;	COMDAT ?IsEnemyCanMovePast@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsEnemyCanMovePast@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsEnemyCanMovePast, COMDAT
; _this$ = ecx

; 140  : 		return GetBit(TACTICAL_FLAG_ENEMY_CAN_REACH_WITH_MOVES);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 6
	and	eax, 1

; 141  : 	};

	ret	0
?IsEnemyCanMovePast@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsEnemyCanMovePast
_TEXT	ENDS
PUBLIC	?IsFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsFriendlyTurnEndTile
; Function compile flags: /Ogtpy
;	COMDAT ?IsFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsFriendlyTurnEndTile, COMDAT
; _this$ = ecx

; 148  : 		return GetBit(TACTICAL_FLAG_FRIENDLY_TURN_END_TILE);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 7
	and	eax, 1

; 149  : 	};

	ret	0
?IsFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsFriendlyTurnEndTile
_TEXT	ENDS
PUBLIC	?SetFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetFriendlyTurnEndTile
; Function compile flags: /Ogtpy
;	COMDAT ?SetFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetFriendlyTurnEndTile, COMDAT
; _this$ = ecx

; 152  : 		SetBit(TACTICAL_FLAG_FRIENDLY_TURN_END_TILE, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetFriendl
	or	DWORD PTR [ecx], 128			; 00000080H

; 153  : 	};

	ret	4

; 152  : 		SetBit(TACTICAL_FLAG_FRIENDLY_TURN_END_TILE, bNewValue);

$LN4@SetFriendl:
	and	DWORD PTR [ecx], -129			; ffffff7fH

; 153  : 	};

	ret	4
?SetFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetFriendlyTurnEndTile
_TEXT	ENDS
PUBLIC	?IsEnemyCity@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsEnemyCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsEnemyCity@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsEnemyCity@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsEnemyCity, COMDAT
; _this$ = ecx

; 164  : 		return GetBit(TACTICAL_FLAG_ENEMY_CITY);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 9
	and	eax, 1

; 165  : 	};

	ret	0
?IsEnemyCity@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsEnemyCity
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::pair<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>::pair<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::pair<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>::pair<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::pair<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>::pair<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAVCvTacticalMove@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalMove@@@Z ; std::_Iter_cat<CvTacticalMove *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAVCvTacticalMove@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalMove@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVCvTacticalMove@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalMove@@@Z PROC ; std::_Iter_cat<CvTacticalMove *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAVCvTacticalMove@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalMove@@@Z ENDP ; std::_Iter_cat<CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$_Distance2@PAVCvTacticalMove@@H@std@@YAXPAVCvTacticalMove@@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CvTacticalMove *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance2@PAVCvTacticalMove@@H@std@@YAXPAVCvTacticalMove@@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAVCvTacticalMove@@H@std@@YAXPAVCvTacticalMove@@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CvTacticalMove *,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 3
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@PAVCvTacticalMove@@H@std@@YAXPAVCvTacticalMove@@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CvTacticalMove *,int>
_TEXT	ENDS
PUBLIC	?IsWater@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsWater
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?IsWater@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsWater@CvTacticalAnalysisCell@@QAE_NXZ PROC		; CvTacticalAnalysisCell::IsWater, COMDAT
; _this$ = ecx

; 184  : 		return GetBit(TACTICAL_FLAG_WATER);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 11					; 0000000bH
	and	eax, 1

; 185  : 	};

	ret	0
?IsWater@CvTacticalAnalysisCell@@QAE_NXZ ENDP		; CvTacticalAnalysisCell::IsWater
_TEXT	ENDS
PUBLIC	?IsOcean@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsOcean
; Function compile flags: /Ogtpy
;	COMDAT ?IsOcean@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsOcean@CvTacticalAnalysisCell@@QAE_NXZ PROC		; CvTacticalAnalysisCell::IsOcean, COMDAT
; _this$ = ecx

; 192  : 		return GetBit(TACTICAL_FLAG_OCEAN);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 12					; 0000000cH
	and	eax, 1

; 193  : 	};

	ret	0
?IsOcean@CvTacticalAnalysisCell@@QAE_NXZ ENDP		; CvTacticalAnalysisCell::IsOcean
_TEXT	ENDS
PUBLIC	?IsWithinRangeOfTarget@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsWithinRangeOfTarget
; Function compile flags: /Ogtpy
;	COMDAT ?IsWithinRangeOfTarget@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsWithinRangeOfTarget@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsWithinRangeOfTarget, COMDAT
; _this$ = ecx

; 233  : 		return GetBit(TACTICAL_FLAG_WITHIN_RANGE_OF_TARGET);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 17					; 00000011H
	and	eax, 1

; 234  : 	};

	ret	0
?IsWithinRangeOfTarget@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsWithinRangeOfTarget
_TEXT	ENDS
PUBLIC	?IsHelpsProvidesFlankBonus@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsHelpsProvidesFlankBonus
; Function compile flags: /Ogtpy
;	COMDAT ?IsHelpsProvidesFlankBonus@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsHelpsProvidesFlankBonus@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsHelpsProvidesFlankBonus, COMDAT
; _this$ = ecx

; 241  : 		return GetBit(TACTICAL_FLAG_CAN_USE_TO_FLANK);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 18					; 00000012H
	and	eax, 1

; 242  : 	};

	ret	0
?IsHelpsProvidesFlankBonus@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsHelpsProvidesFlankBonus
_TEXT	ENDS
PUBLIC	?SetSafeForDeployment@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetSafeForDeployment
; Function compile flags: /Ogtpy
;	COMDAT ?SetSafeForDeployment@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetSafeForDeployment@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetSafeForDeployment, COMDAT
; _this$ = ecx

; 253  : 		SetBit(TACTICAL_FLAG_SAFE_DEPLOYMENT, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetSafeFor
	or	DWORD PTR [ecx], 524288			; 00080000H

; 254  : 	};

	ret	4

; 253  : 		SetBit(TACTICAL_FLAG_SAFE_DEPLOYMENT, bNewValue);

$LN4@SetSafeFor:
	and	DWORD PTR [ecx], -524289		; fff7ffffH

; 254  : 	};

	ret	4
?SetSafeForDeployment@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetSafeForDeployment
_TEXT	ENDS
PUBLIC	?GetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ; CvTacticalAnalysisCell::GetEnemyMilitaryUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?GetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ PROC ; CvTacticalAnalysisCell::GetEnemyMilitaryUnit, COMDAT
; _this$ = ecx

; 258  : 		return m_pEnemyMilitary;

	mov	eax, DWORD PTR [ecx+4]

; 259  : 	};

	ret	0
?GetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ENDP ; CvTacticalAnalysisCell::GetEnemyMilitaryUnit
_TEXT	ENDS
PUBLIC	?GetFriendlyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ; CvTacticalAnalysisCell::GetFriendlyMilitaryUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?GetFriendlyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ PROC ; CvTacticalAnalysisCell::GetFriendlyMilitaryUnit, COMDAT
; _this$ = ecx

; 274  : 		return m_pFriendlyMilitary;

	mov	eax, DWORD PTR [ecx+20]

; 275  : 	};

	ret	0
?GetFriendlyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ENDP ; CvTacticalAnalysisCell::GetFriendlyMilitaryUnit
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAVCvTacticalTarget@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalTarget@@@Z ; std::_Iter_cat<CvTacticalTarget *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAVCvTacticalTarget@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalTarget@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVCvTacticalTarget@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalTarget@@@Z PROC ; std::_Iter_cat<CvTacticalTarget *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAVCvTacticalTarget@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalTarget@@@Z ENDP ; std::_Iter_cat<CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$_Distance2@PAVCvTacticalTarget@@H@std@@YAXPAVCvTacticalTarget@@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CvTacticalTarget *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance2@PAVCvTacticalTarget@@H@std@@YAXPAVCvTacticalTarget@@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAVCvTacticalTarget@@H@std@@YAXPAVCvTacticalTarget@@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CvTacticalTarget *,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@PAVCvTacticalTarget@@H@std@@YAXPAVCvTacticalTarget@@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CvTacticalTarget *,int>
_TEXT	ENDS
PUBLIC	?GetDefenseModifier@CvTacticalAnalysisCell@@QBEHXZ ; CvTacticalAnalysisCell::GetDefenseModifier
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?GetDefenseModifier@CvTacticalAnalysisCell@@QBEHXZ
_TEXT	SEGMENT
?GetDefenseModifier@CvTacticalAnalysisCell@@QBEHXZ PROC	; CvTacticalAnalysisCell::GetDefenseModifier, COMDAT
; _this$ = ecx

; 307  : 		return m_iDefenseModifier;

	mov	eax, DWORD PTR [ecx+28]

; 308  : 	};

	ret	0
?GetDefenseModifier@CvTacticalAnalysisCell@@QBEHXZ ENDP	; CvTacticalAnalysisCell::GetDefenseModifier
_TEXT	ENDS
PUBLIC	?SetDeploymentScore@CvTacticalAnalysisCell@@QAEXH@Z ; CvTacticalAnalysisCell::SetDeploymentScore
; Function compile flags: /Ogtpy
;	COMDAT ?SetDeploymentScore@CvTacticalAnalysisCell@@QAEXH@Z
_TEXT	SEGMENT
_iScore$ = 8						; size = 4
?SetDeploymentScore@CvTacticalAnalysisCell@@QAEXH@Z PROC ; CvTacticalAnalysisCell::SetDeploymentScore, COMDAT
; _this$ = ecx

; 319  : 		m_iDeploymentScore = iScore;

	mov	eax, DWORD PTR _iScore$[esp-4]
	mov	DWORD PTR [ecx+32], eax

; 320  : 	};

	ret	4
?SetDeploymentScore@CvTacticalAnalysisCell@@QAEXH@Z ENDP ; CvTacticalAnalysisCell::SetDeploymentScore
_TEXT	ENDS
PUBLIC	?GetDominanceZone@CvTacticalAnalysisCell@@QBEHXZ ; CvTacticalAnalysisCell::GetDominanceZone
; Function compile flags: /Ogtpy
;	COMDAT ?GetDominanceZone@CvTacticalAnalysisCell@@QBEHXZ
_TEXT	SEGMENT
?GetDominanceZone@CvTacticalAnalysisCell@@QBEHXZ PROC	; CvTacticalAnalysisCell::GetDominanceZone, COMDAT
; _this$ = ecx

; 323  : 		return m_iDominanceZoneID;

	mov	eax, DWORD PTR [ecx+40]

; 324  : 	};

	ret	0
?GetDominanceZone@CvTacticalAnalysisCell@@QBEHXZ ENDP	; CvTacticalAnalysisCell::GetDominanceZone
_TEXT	ENDS
PUBLIC	?GetDominanceZoneID@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetDominanceZoneID
; Function compile flags: /Ogtpy
;	COMDAT ?GetDominanceZoneID@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetDominanceZoneID@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetDominanceZoneID, COMDAT
; _this$ = ecx

; 396  : 		return m_iDominanceZoneID;

	mov	eax, DWORD PTR [ecx]

; 397  : 	};

	ret	0
?GetDominanceZoneID@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetDominanceZoneID
_TEXT	ENDS
PUBLIC	?GetTerritoryType@CvTacticalDominanceZone@@QBE?AW4eDominanceTerritoryTypes@@XZ ; CvTacticalDominanceZone::GetTerritoryType
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerritoryType@CvTacticalDominanceZone@@QBE?AW4eDominanceTerritoryTypes@@XZ
_TEXT	SEGMENT
?GetTerritoryType@CvTacticalDominanceZone@@QBE?AW4eDominanceTerritoryTypes@@XZ PROC ; CvTacticalDominanceZone::GetTerritoryType, COMDAT
; _this$ = ecx

; 404  : 		return m_eTerritoryType;

	mov	eax, DWORD PTR [ecx+4]

; 405  : 	};

	ret	0
?GetTerritoryType@CvTacticalDominanceZone@@QBE?AW4eDominanceTerritoryTypes@@XZ ENDP ; CvTacticalDominanceZone::GetTerritoryType
_TEXT	ENDS
PUBLIC	?GetDominanceFlag@CvTacticalDominanceZone@@QBE?AW4eTacticalDominanceFlags@@XZ ; CvTacticalDominanceZone::GetDominanceFlag
; Function compile flags: /Ogtpy
;	COMDAT ?GetDominanceFlag@CvTacticalDominanceZone@@QBE?AW4eTacticalDominanceFlags@@XZ
_TEXT	SEGMENT
?GetDominanceFlag@CvTacticalDominanceZone@@QBE?AW4eTacticalDominanceFlags@@XZ PROC ; CvTacticalDominanceZone::GetDominanceFlag, COMDAT
; _this$ = ecx

; 412  : 		return m_eDominanceFlag;

	mov	eax, DWORD PTR [ecx+8]

; 413  : 	};

	ret	0
?GetDominanceFlag@CvTacticalDominanceZone@@QBE?AW4eTacticalDominanceFlags@@XZ ENDP ; CvTacticalDominanceZone::GetDominanceFlag
_TEXT	ENDS
PUBLIC	?GetOwner@CvTacticalDominanceZone@@QBE?AW4PlayerTypes@@XZ ; CvTacticalDominanceZone::GetOwner
; Function compile flags: /Ogtpy
;	COMDAT ?GetOwner@CvTacticalDominanceZone@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetOwner@CvTacticalDominanceZone@@QBE?AW4PlayerTypes@@XZ PROC ; CvTacticalDominanceZone::GetOwner, COMDAT
; _this$ = ecx

; 420  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+12]

; 421  : 	};

	ret	0
?GetOwner@CvTacticalDominanceZone@@QBE?AW4PlayerTypes@@XZ ENDP ; CvTacticalDominanceZone::GetOwner
_TEXT	ENDS
PUBLIC	?GetFriendlyStrength@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetFriendlyStrength
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyStrength@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyStrength@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetFriendlyStrength, COMDAT
; _this$ = ecx

; 440  : 		return m_iFriendlyStrength;

	mov	eax, DWORD PTR [ecx+24]

; 441  : 	};

	ret	0
?GetFriendlyStrength@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetFriendlyStrength
_TEXT	ENDS
PUBLIC	?GetEnemyStrength@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetEnemyStrength
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyStrength@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetEnemyStrength@CvTacticalDominanceZone@@QBEHXZ PROC	; CvTacticalDominanceZone::GetEnemyStrength, COMDAT
; _this$ = ecx

; 448  : 		return m_iEnemyStrength;

	mov	eax, DWORD PTR [ecx+28]

; 449  : 	};

	ret	0
?GetEnemyStrength@CvTacticalDominanceZone@@QBEHXZ ENDP	; CvTacticalDominanceZone::GetEnemyStrength
_TEXT	ENDS
PUBLIC	??$_Iter_cat@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	?GetFriendlyRangedStrength@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetFriendlyRangedStrength
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?GetFriendlyRangedStrength@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyRangedStrength@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetFriendlyRangedStrength, COMDAT
; _this$ = ecx

; 456  : 		return m_iFriendlyRangedStrength;

	mov	eax, DWORD PTR [ecx+32]

; 457  : 	};

	ret	0
?GetFriendlyRangedStrength@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetFriendlyRangedStrength
_TEXT	ENDS
PUBLIC	?GetEnemyRangedStrength@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetEnemyRangedStrength
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyRangedStrength@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetEnemyRangedStrength@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetEnemyRangedStrength, COMDAT
; _this$ = ecx

; 464  : 		return m_iEnemyRangedStrength;

	mov	eax, DWORD PTR [ecx+36]

; 465  : 	};

	ret	0
?GetEnemyRangedStrength@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetEnemyRangedStrength
_TEXT	ENDS
PUBLIC	?GetFriendlyUnitCount@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetFriendlyUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyUnitCount@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyUnitCount@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetFriendlyUnitCount, COMDAT
; _this$ = ecx

; 472  : 		return m_iFriendlyUnitCount;

	mov	eax, DWORD PTR [ecx+40]

; 473  : 	};

	ret	0
?GetFriendlyUnitCount@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetFriendlyUnitCount
_TEXT	ENDS
PUBLIC	?GetEnemyUnitCount@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetEnemyUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyUnitCount@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetEnemyUnitCount@CvTacticalDominanceZone@@QBEHXZ PROC	; CvTacticalDominanceZone::GetEnemyUnitCount, COMDAT
; _this$ = ecx

; 480  : 		return m_iEnemyUnitCount;

	mov	eax, DWORD PTR [ecx+44]

; 481  : 	};

	ret	0
?GetEnemyUnitCount@CvTacticalDominanceZone@@QBEHXZ ENDP	; CvTacticalDominanceZone::GetEnemyUnitCount
_TEXT	ENDS
PUBLIC	?GetFriendlyRangedUnitCount@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetFriendlyRangedUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyRangedUnitCount@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyRangedUnitCount@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetFriendlyRangedUnitCount, COMDAT
; _this$ = ecx

; 488  : 		return m_iFriendlyRangedUnitCount;

	mov	eax, DWORD PTR [ecx+48]

; 489  : 	};

	ret	0
?GetFriendlyRangedUnitCount@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetFriendlyRangedUnitCount
_TEXT	ENDS
PUBLIC	?GetEnemyNavalUnitCount@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetEnemyNavalUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyNavalUnitCount@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetEnemyNavalUnitCount@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetEnemyNavalUnitCount, COMDAT
; _this$ = ecx

; 504  : 		return m_iEnemyNavalUnitCount;

	mov	eax, DWORD PTR [ecx+56]

; 505  : 	};

	ret	0
?GetEnemyNavalUnitCount@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetEnemyNavalUnitCount
_TEXT	ENDS
PUBLIC	?IsWater@CvTacticalDominanceZone@@QBE_NXZ	; CvTacticalDominanceZone::IsWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsWater@CvTacticalDominanceZone@@QBE_NXZ
_TEXT	SEGMENT
?IsWater@CvTacticalDominanceZone@@QBE_NXZ PROC		; CvTacticalDominanceZone::IsWater, COMDAT
; _this$ = ecx

; 520  : 		return m_bIsWater;

	mov	al, BYTE PTR [ecx+68]

; 521  : 	};

	ret	0
?IsWater@CvTacticalDominanceZone@@QBE_NXZ ENDP		; CvTacticalDominanceZone::IsWater
_TEXT	ENDS
PUBLIC	?IsNavalInvasion@CvTacticalDominanceZone@@QBE_NXZ ; CvTacticalDominanceZone::IsNavalInvasion
; Function compile flags: /Ogtpy
;	COMDAT ?IsNavalInvasion@CvTacticalDominanceZone@@QBE_NXZ
_TEXT	SEGMENT
?IsNavalInvasion@CvTacticalDominanceZone@@QBE_NXZ PROC	; CvTacticalDominanceZone::IsNavalInvasion, COMDAT
; _this$ = ecx

; 528  : 		return m_bIsNavalInvasion;

	mov	al, BYTE PTR [ecx+69]

; 529  : 	};

	ret	0
?IsNavalInvasion@CvTacticalDominanceZone@@QBE_NXZ ENDP	; CvTacticalDominanceZone::IsNavalInvasion
_TEXT	ENDS
PUBLIC	?GetTempZoneCenter@CvTacticalDominanceZone@@QBEPAVCvPlot@@XZ ; CvTacticalDominanceZone::GetTempZoneCenter
; Function compile flags: /Ogtpy
;	COMDAT ?GetTempZoneCenter@CvTacticalDominanceZone@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetTempZoneCenter@CvTacticalDominanceZone@@QBEPAVCvPlot@@XZ PROC ; CvTacticalDominanceZone::GetTempZoneCenter, COMDAT
; _this$ = ecx

; 536  : 		return m_pTempZoneCenter;

	mov	eax, DWORD PTR [ecx+72]

; 537  : 	};

	ret	0
?GetTempZoneCenter@CvTacticalDominanceZone@@QBEPAVCvPlot@@XZ ENDP ; CvTacticalDominanceZone::GetTempZoneCenter
_TEXT	ENDS
PUBLIC	?IsBuilt@CvTacticalAnalysisMap@@QBE_NXZ		; CvTacticalAnalysisMap::IsBuilt
; Function compile flags: /Ogtpy
;	COMDAT ?IsBuilt@CvTacticalAnalysisMap@@QBE_NXZ
_TEXT	SEGMENT
?IsBuilt@CvTacticalAnalysisMap@@QBE_NXZ PROC		; CvTacticalAnalysisMap::IsBuilt, COMDAT
; _this$ = ecx

; 620  : 		return m_bIsBuilt;

	mov	al, BYTE PTR [ecx+34]

; 621  : 	};

	ret	0
?IsBuilt@CvTacticalAnalysisMap@@QBE_NXZ ENDP		; CvTacticalAnalysisMap::IsBuilt
_TEXT	ENDS
PUBLIC	?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z ; CvTacticalAnalysisMap::GetCell
; Function compile flags: /Ogtpy
;	COMDAT ?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z
_TEXT	SEGMENT
_iPlotIndex$ = 8					; size = 4
?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z PROC ; CvTacticalAnalysisMap::GetCell, COMDAT
; _this$ = ecx

; 630  : 		return &m_pPlots[iPlotIndex];

	mov	eax, DWORD PTR _iPlotIndex$[esp-4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+12]

; 631  : 	};

	ret	4
?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z ENDP ; CvTacticalAnalysisMap::GetCell
_TEXT	ENDS
PUBLIC	??$_Iter_cat@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	?GetDominancePercentage@CvTacticalAnalysisMap@@QBEHXZ ; CvTacticalAnalysisMap::GetDominancePercentage
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?GetDominancePercentage@CvTacticalAnalysisMap@@QBEHXZ
_TEXT	SEGMENT
?GetDominancePercentage@CvTacticalAnalysisMap@@QBEHXZ PROC ; CvTacticalAnalysisMap::GetDominancePercentage, COMDAT
; _this$ = ecx

; 634  : 		return m_iDominancePercentage;

	mov	eax, DWORD PTR [ecx]

; 635  : 	};

	ret	0
?GetDominancePercentage@CvTacticalAnalysisMap@@QBEHXZ ENDP ; CvTacticalAnalysisMap::GetDominancePercentage
_TEXT	ENDS
PUBLIC	?GetBestFriendlyRange@CvTacticalAnalysisMap@@QBEHXZ ; CvTacticalAnalysisMap::GetBestFriendlyRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetBestFriendlyRange@CvTacticalAnalysisMap@@QBEHXZ
_TEXT	SEGMENT
?GetBestFriendlyRange@CvTacticalAnalysisMap@@QBEHXZ PROC ; CvTacticalAnalysisMap::GetBestFriendlyRange, COMDAT
; _this$ = ecx

; 641  : 		return m_iBestFriendlyRange;

	mov	eax, DWORD PTR [ecx+28]

; 642  : 	};

	ret	0
?GetBestFriendlyRange@CvTacticalAnalysisMap@@QBEHXZ ENDP ; CvTacticalAnalysisMap::GetBestFriendlyRange
_TEXT	ENDS
PUBLIC	?CanIgnoreLOS@CvTacticalAnalysisMap@@QBE_NXZ	; CvTacticalAnalysisMap::CanIgnoreLOS
; Function compile flags: /Ogtpy
;	COMDAT ?CanIgnoreLOS@CvTacticalAnalysisMap@@QBE_NXZ
_TEXT	SEGMENT
?CanIgnoreLOS@CvTacticalAnalysisMap@@QBE_NXZ PROC	; CvTacticalAnalysisMap::CanIgnoreLOS, COMDAT
; _this$ = ecx

; 649  : 		return m_bIgnoreLOS;

	mov	al, BYTE PTR [ecx+32]

; 650  : 	};

	ret	0
?CanIgnoreLOS@CvTacticalAnalysisMap@@QBE_NXZ ENDP	; CvTacticalAnalysisMap::CanIgnoreLOS
_TEXT	ENDS
PUBLIC	?GetTacticalRange@CvTacticalAnalysisMap@@QBEHXZ	; CvTacticalAnalysisMap::GetTacticalRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetTacticalRange@CvTacticalAnalysisMap@@QBEHXZ
_TEXT	SEGMENT
?GetTacticalRange@CvTacticalAnalysisMap@@QBEHXZ PROC	; CvTacticalAnalysisMap::GetTacticalRange, COMDAT
; _this$ = ecx

; 668  : 	int GetTacticalRange() const {return m_iTacticalRange;};

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?GetTacticalRange@CvTacticalAnalysisMap@@QBEHXZ ENDP	; CvTacticalAnalysisMap::GetTacticalRange
_TEXT	ENDS
PUBLIC	?GetPriority@CvTacticalMoveXMLEntry@@QBEHXZ	; CvTacticalMoveXMLEntry::GetPriority
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.h
;	COMDAT ?GetPriority@CvTacticalMoveXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPriority@CvTacticalMoveXMLEntry@@QBEHXZ PROC	; CvTacticalMoveXMLEntry::GetPriority, COMDAT
; _this$ = ecx

; 33   : 		return m_iPriority;

	mov	eax, DWORD PTR [ecx+264]

; 34   : 	};

	ret	0
?GetPriority@CvTacticalMoveXMLEntry@@QBEHXZ ENDP	; CvTacticalMoveXMLEntry::GetPriority
_TEXT	ENDS
PUBLIC	?IsDominanceZoneMove@CvTacticalMoveXMLEntry@@QBEHXZ ; CvTacticalMoveXMLEntry::IsDominanceZoneMove
; Function compile flags: /Ogtpy
;	COMDAT ?IsDominanceZoneMove@CvTacticalMoveXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?IsDominanceZoneMove@CvTacticalMoveXMLEntry@@QBEHXZ PROC ; CvTacticalMoveXMLEntry::IsDominanceZoneMove, COMDAT
; _this$ = ecx

; 65   : 		return m_bDominanceZoneMove;

	movzx	eax, BYTE PTR [ecx+277]

; 66   : 	};

	ret	0
?IsDominanceZoneMove@CvTacticalMoveXMLEntry@@QBEHXZ ENDP ; CvTacticalMoveXMLEntry::IsDominanceZoneMove
_TEXT	ENDS
PUBLIC	??0CvTacticalMove@@QAE@XZ			; CvTacticalMove::CvTacticalMove
; Function compile flags: /Ogtpy
;	COMDAT ??0CvTacticalMove@@QAE@XZ
_TEXT	SEGMENT
??0CvTacticalMove@@QAE@XZ PROC				; CvTacticalMove::CvTacticalMove, COMDAT
; _this$ = ecx

; 139  : 	CvTacticalMove()

	mov	eax, ecx

; 140  : 	{
; 141  : 		m_eMoveType = NO_TACTICAL_MOVE;

	mov	DWORD PTR [eax], -1

; 142  : 		m_iPriority = 0;

	mov	DWORD PTR [eax+4], 0

; 143  : 	}

	ret	0
??0CvTacticalMove@@QAE@XZ ENDP				; CvTacticalMove::CvTacticalMove
_TEXT	ENDS
PUBLIC	??MCvTacticalMove@@QBE_NABV0@@Z			; CvTacticalMove::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MCvTacticalMove@@QBE_NABV0@@Z
_TEXT	SEGMENT
_move$ = 8						; size = 4
??MCvTacticalMove@@QBE_NABV0@@Z PROC			; CvTacticalMove::operator<, COMDAT
; _this$ = ecx

; 147  : 		return (m_iPriority > move.m_iPriority);

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _move$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 148  : 	}

	ret	4
??MCvTacticalMove@@QBE_NABV0@@Z ENDP			; CvTacticalMove::operator<
_TEXT	ENDS
PUBLIC	?SetID@CvTacticalUnit@@QAEXH@Z			; CvTacticalUnit::SetID
; Function compile flags: /Ogtpy
;	COMDAT ?SetID@CvTacticalUnit@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetID@CvTacticalUnit@@QAEXH@Z PROC			; CvTacticalUnit::SetID, COMDAT
; _this$ = ecx

; 168  : 		m_iID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx], eax

; 169  : 	};

	ret	4
?SetID@CvTacticalUnit@@QAEXH@Z ENDP			; CvTacticalUnit::SetID
_TEXT	ENDS
PUBLIC	?GetID@CvTacticalUnit@@QBEHXZ			; CvTacticalUnit::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvTacticalUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvTacticalUnit@@QBEHXZ PROC			; CvTacticalUnit::GetID, COMDAT
; _this$ = ecx

; 172  : 		return m_iID;

	mov	eax, DWORD PTR [ecx]

; 173  : 	};

	ret	0
?GetID@CvTacticalUnit@@QBEHXZ ENDP			; CvTacticalUnit::GetID
_TEXT	ENDS
PUBLIC	?SetHealthPercent@CvTacticalUnit@@QAEXHH@Z	; CvTacticalUnit::SetHealthPercent
; Function compile flags: /Ogtpy
;	COMDAT ?SetHealthPercent@CvTacticalUnit@@QAEXHH@Z
_TEXT	SEGMENT
_curHitPoints$ = 8					; size = 4
_maxHitPoints$ = 12					; size = 4
?SetHealthPercent@CvTacticalUnit@@QAEXHH@Z PROC		; CvTacticalUnit::SetHealthPercent, COMDAT
; _this$ = ecx

; 176  : 		CvAssert(maxHitPoints != 0);
; 177  : 		m_iHealthPercent = curHitPoints * 100 / maxHitPoints;

	mov	eax, DWORD PTR _curHitPoints$[esp-4]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _maxHitPoints$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 178  : 	}

	ret	8
?SetHealthPercent@CvTacticalUnit@@QAEXHH@Z ENDP		; CvTacticalUnit::SetHealthPercent
_TEXT	ENDS
PUBLIC	?SetAttackStrength@CvTacticalUnit@@QAEXH@Z	; CvTacticalUnit::SetAttackStrength
; Function compile flags: /Ogtpy
;	COMDAT ?SetAttackStrength@CvTacticalUnit@@QAEXH@Z
_TEXT	SEGMENT
_iAttackStrength$ = 8					; size = 4
?SetAttackStrength@CvTacticalUnit@@QAEXH@Z PROC		; CvTacticalUnit::SetAttackStrength, COMDAT
; _this$ = ecx

; 185  : 		m_iAttackStrength = iAttackStrength;

	mov	eax, DWORD PTR _iAttackStrength$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 186  : 	};

	ret	4
?SetAttackStrength@CvTacticalUnit@@QAEXH@Z ENDP		; CvTacticalUnit::SetAttackStrength
_TEXT	ENDS
PUBLIC	?SetExpectedTargetDamage@CvTacticalUnit@@QAEXH@Z ; CvTacticalUnit::SetExpectedTargetDamage
; Function compile flags: /Ogtpy
;	COMDAT ?SetExpectedTargetDamage@CvTacticalUnit@@QAEXH@Z
_TEXT	SEGMENT
_iExpectedDamage$ = 8					; size = 4
?SetExpectedTargetDamage@CvTacticalUnit@@QAEXH@Z PROC	; CvTacticalUnit::SetExpectedTargetDamage, COMDAT
; _this$ = ecx

; 193  : 		m_iExpectedTargetDamage = iExpectedDamage;

	mov	eax, DWORD PTR _iExpectedDamage$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 194  : 	};

	ret	4
?SetExpectedTargetDamage@CvTacticalUnit@@QAEXH@Z ENDP	; CvTacticalUnit::SetExpectedTargetDamage
_TEXT	ENDS
PUBLIC	?GetExpectedTargetDamage@CvTacticalUnit@@QBEHXZ	; CvTacticalUnit::GetExpectedTargetDamage
; Function compile flags: /Ogtpy
;	COMDAT ?GetExpectedTargetDamage@CvTacticalUnit@@QBEHXZ
_TEXT	SEGMENT
?GetExpectedTargetDamage@CvTacticalUnit@@QBEHXZ PROC	; CvTacticalUnit::GetExpectedTargetDamage, COMDAT
; _this$ = ecx

; 197  : 		return m_iExpectedTargetDamage;

	mov	eax, DWORD PTR [ecx+16]

; 198  : 	};

	ret	0
?GetExpectedTargetDamage@CvTacticalUnit@@QBEHXZ ENDP	; CvTacticalUnit::GetExpectedTargetDamage
_TEXT	ENDS
PUBLIC	?SetExpectedSelfDamage@CvTacticalUnit@@QAEXH@Z	; CvTacticalUnit::SetExpectedSelfDamage
; Function compile flags: /Ogtpy
;	COMDAT ?SetExpectedSelfDamage@CvTacticalUnit@@QAEXH@Z
_TEXT	SEGMENT
_iExpectedDamage$ = 8					; size = 4
?SetExpectedSelfDamage@CvTacticalUnit@@QAEXH@Z PROC	; CvTacticalUnit::SetExpectedSelfDamage, COMDAT
; _this$ = ecx

; 201  : 		m_iExpectedSelfDamage = iExpectedDamage;

	mov	eax, DWORD PTR _iExpectedDamage$[esp-4]
	mov	DWORD PTR [ecx+20], eax

; 202  : 	};

	ret	4
?SetExpectedSelfDamage@CvTacticalUnit@@QAEXH@Z ENDP	; CvTacticalUnit::SetExpectedSelfDamage
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAVCvBlockingUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvBlockingUnit@@@Z ; std::_Iter_cat<CvBlockingUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAVCvBlockingUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvBlockingUnit@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVCvBlockingUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvBlockingUnit@@@Z PROC ; std::_Iter_cat<CvBlockingUnit *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAVCvBlockingUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvBlockingUnit@@@Z ENDP ; std::_Iter_cat<CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	?GetExpectedSelfDamage@CvTacticalUnit@@QBEHXZ	; CvTacticalUnit::GetExpectedSelfDamage
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.h
;	COMDAT ?GetExpectedSelfDamage@CvTacticalUnit@@QBEHXZ
_TEXT	SEGMENT
?GetExpectedSelfDamage@CvTacticalUnit@@QBEHXZ PROC	; CvTacticalUnit::GetExpectedSelfDamage, COMDAT
; _this$ = ecx

; 205  : 		return m_iExpectedSelfDamage;

	mov	eax, DWORD PTR [ecx+20]

; 206  : 	};

	ret	0
?GetExpectedSelfDamage@CvTacticalUnit@@QBEHXZ ENDP	; CvTacticalUnit::GetExpectedSelfDamage
_TEXT	ENDS
PUBLIC	??$_Distance2@PAVCvBlockingUnit@@H@std@@YAXPAVCvBlockingUnit@@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CvBlockingUnit *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance2@PAVCvBlockingUnit@@H@std@@YAXPAVCvBlockingUnit@@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAVCvBlockingUnit@@H@std@@YAXPAVCvBlockingUnit@@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CvBlockingUnit *,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 4
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@PAVCvBlockingUnit@@H@std@@YAXPAVCvBlockingUnit@@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CvBlockingUnit *,int>
_TEXT	ENDS
PUBLIC	?SetMovesToTarget@CvTacticalUnit@@QAEXH@Z	; CvTacticalUnit::SetMovesToTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.h
;	COMDAT ?SetMovesToTarget@CvTacticalUnit@@QAEXH@Z
_TEXT	SEGMENT
_iMoves$ = 8						; size = 4
?SetMovesToTarget@CvTacticalUnit@@QAEXH@Z PROC		; CvTacticalUnit::SetMovesToTarget, COMDAT
; _this$ = ecx

; 209  : 		m_iMovesToTarget = iMoves;

	mov	eax, DWORD PTR _iMoves$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 210  : 	};

	ret	4
?SetMovesToTarget@CvTacticalUnit@@QAEXH@Z ENDP		; CvTacticalUnit::SetMovesToTarget
_TEXT	ENDS
PUBLIC	?GetMovesToTarget@CvTacticalUnit@@QBEHXZ	; CvTacticalUnit::GetMovesToTarget
; Function compile flags: /Ogtpy
;	COMDAT ?GetMovesToTarget@CvTacticalUnit@@QBEHXZ
_TEXT	SEGMENT
?GetMovesToTarget@CvTacticalUnit@@QBEHXZ PROC		; CvTacticalUnit::GetMovesToTarget, COMDAT
; _this$ = ecx

; 213  : 		return m_iMovesToTarget;

	mov	eax, DWORD PTR [ecx+12]

; 214  : 	};

	ret	0
?GetMovesToTarget@CvTacticalUnit@@QBEHXZ ENDP		; CvTacticalUnit::GetMovesToTarget
_TEXT	ENDS
PUBLIC	?GetAttackPriority@CvTacticalUnit@@QBEHXZ	; CvTacticalUnit::GetAttackPriority
; Function compile flags: /Ogtpy
;	COMDAT ?GetAttackPriority@CvTacticalUnit@@QBEHXZ
_TEXT	SEGMENT
?GetAttackPriority@CvTacticalUnit@@QBEHXZ PROC		; CvTacticalUnit::GetAttackPriority, COMDAT
; _this$ = ecx

; 219  : 		return m_iAttackStrength * m_iHealthPercent;

	mov	eax, DWORD PTR [ecx+8]
	imul	eax, DWORD PTR [ecx+4]

; 220  : 	}

	ret	0
?GetAttackPriority@CvTacticalUnit@@QBEHXZ ENDP		; CvTacticalUnit::GetAttackPriority
_TEXT	ENDS
PUBLIC	??0CvTacticalCity@@QAE@XZ			; CvTacticalCity::CvTacticalCity
; Function compile flags: /Ogtpy
;	COMDAT ??0CvTacticalCity@@QAE@XZ
_TEXT	SEGMENT
??0CvTacticalCity@@QAE@XZ PROC				; CvTacticalCity::CvTacticalCity, COMDAT
; _this$ = ecx

; 235  : 	CvTacticalCity()

	mov	eax, ecx

; 236  : 	{
; 237  : 		m_iID = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 238  : 		m_iAttackStrength = 0;

	mov	DWORD PTR [eax+4], ecx

; 239  : 		m_iExpectedTargetDamage = 0;

	mov	DWORD PTR [eax+8], ecx

; 240  : #ifdef DEL_RANGED_COUNTERATTACKS
; 241  : 		m_iExpectedSelfDamage = 0;
; 242  : #endif
; 243  : 	}

	ret	0
??0CvTacticalCity@@QAE@XZ ENDP				; CvTacticalCity::CvTacticalCity
_TEXT	ENDS
PUBLIC	?SetID@CvTacticalCity@@QAEXH@Z			; CvTacticalCity::SetID
; Function compile flags: /Ogtpy
;	COMDAT ?SetID@CvTacticalCity@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetID@CvTacticalCity@@QAEXH@Z PROC			; CvTacticalCity::SetID, COMDAT
; _this$ = ecx

; 253  : 		m_iID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx], eax

; 254  : 	};

	ret	4
?SetID@CvTacticalCity@@QAEXH@Z ENDP			; CvTacticalCity::SetID
_TEXT	ENDS
PUBLIC	?GetID@CvTacticalCity@@QBEHXZ			; CvTacticalCity::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvTacticalCity@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvTacticalCity@@QBEHXZ PROC			; CvTacticalCity::GetID, COMDAT
; _this$ = ecx

; 257  : 		return m_iID;

	mov	eax, DWORD PTR [ecx]

; 258  : 	};

	ret	0
?GetID@CvTacticalCity@@QBEHXZ ENDP			; CvTacticalCity::GetID
_TEXT	ENDS
PUBLIC	?SetExpectedTargetDamage@CvTacticalCity@@QAEXH@Z ; CvTacticalCity::SetExpectedTargetDamage
; Function compile flags: /Ogtpy
;	COMDAT ?SetExpectedTargetDamage@CvTacticalCity@@QAEXH@Z
_TEXT	SEGMENT
_iExpectedDamage$ = 8					; size = 4
?SetExpectedTargetDamage@CvTacticalCity@@QAEXH@Z PROC	; CvTacticalCity::SetExpectedTargetDamage, COMDAT
; _this$ = ecx

; 261  : 		m_iExpectedTargetDamage = iExpectedDamage;

	mov	eax, DWORD PTR _iExpectedDamage$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 262  : 	};

	ret	4
?SetExpectedTargetDamage@CvTacticalCity@@QAEXH@Z ENDP	; CvTacticalCity::SetExpectedTargetDamage
_TEXT	ENDS
PUBLIC	?GetExpectedTargetDamage@CvTacticalCity@@QBEHXZ	; CvTacticalCity::GetExpectedTargetDamage
; Function compile flags: /Ogtpy
;	COMDAT ?GetExpectedTargetDamage@CvTacticalCity@@QBEHXZ
_TEXT	SEGMENT
?GetExpectedTargetDamage@CvTacticalCity@@QBEHXZ PROC	; CvTacticalCity::GetExpectedTargetDamage, COMDAT
; _this$ = ecx

; 265  : 		return m_iExpectedTargetDamage;

	mov	eax, DWORD PTR [ecx+8]

; 266  : 	};

	ret	0
?GetExpectedTargetDamage@CvTacticalCity@@QBEHXZ ENDP	; CvTacticalCity::GetExpectedTargetDamage
_TEXT	ENDS
PUBLIC	?GetAttackPriority@CvTacticalCity@@QBEHXZ	; CvTacticalCity::GetAttackPriority
; Function compile flags: /Ogtpy
;	COMDAT ?GetAttackPriority@CvTacticalCity@@QBEHXZ
_TEXT	SEGMENT
?GetAttackPriority@CvTacticalCity@@QBEHXZ PROC		; CvTacticalCity::GetAttackPriority, COMDAT
; _this$ = ecx

; 281  : 		return m_iAttackStrength;

	mov	eax, DWORD PTR [ecx+4]

; 282  : 	}

	ret	0
?GetAttackPriority@CvTacticalCity@@QBEHXZ ENDP		; CvTacticalCity::GetAttackPriority
_TEXT	ENDS
PUBLIC	?Clear@CvTacticalTarget@@QAEXXZ			; CvTacticalTarget::Clear
; Function compile flags: /Ogtpy
;	COMDAT ?Clear@CvTacticalTarget@@QAEXXZ
_TEXT	SEGMENT
?Clear@CvTacticalTarget@@QAEXXZ PROC			; CvTacticalTarget::Clear, COMDAT
; _this$ = ecx

; 310  : 		m_eTargetType = AI_TACTICAL_TARGET_NONE;
; 311  : 		m_iTargetX = -1;

	or	eax, -1
	xor	edx, edx
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 312  : 		m_iTargetY = -1;

	mov	DWORD PTR [ecx+8], eax

; 313  : 		m_eTargetPlayer = NO_PLAYER;

	mov	DWORD PTR [ecx+12], eax

; 314  : 		m_iDominanceZoneID = -1;

	mov	DWORD PTR [ecx+24], eax

; 315  : 		m_pAuxData = NULL;

	mov	DWORD PTR [ecx+16], edx

; 316  : 		m_iAuxData = 0;

	mov	DWORD PTR [ecx+20], edx

; 317  : 	};

	ret	0
?Clear@CvTacticalTarget@@QAEXXZ ENDP			; CvTacticalTarget::Clear
_TEXT	ENDS
PUBLIC	??MCvTacticalTarget@@QBE_NABV0@@Z		; CvTacticalTarget::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MCvTacticalTarget@@QBE_NABV0@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??MCvTacticalTarget@@QBE_NABV0@@Z PROC			; CvTacticalTarget::operator<, COMDAT
; _this$ = ecx

; 320  : 		return (m_iAuxData > target.m_iAuxData);

	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _target$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+20]
	setg	cl
	mov	al, cl

; 321  : 	};

	ret	4
??MCvTacticalTarget@@QBE_NABV0@@Z ENDP			; CvTacticalTarget::operator<
_TEXT	ENDS
PUBLIC	?GetTargetType@CvTacticalTarget@@QAE?AW4AITacticalTargetType@@XZ ; CvTacticalTarget::GetTargetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetTargetType@CvTacticalTarget@@QAE?AW4AITacticalTargetType@@XZ
_TEXT	SEGMENT
?GetTargetType@CvTacticalTarget@@QAE?AW4AITacticalTargetType@@XZ PROC ; CvTacticalTarget::GetTargetType, COMDAT
; _this$ = ecx

; 328  : 		return m_eTargetType;

	mov	eax, DWORD PTR [ecx]

; 329  : 	}

	ret	0
?GetTargetType@CvTacticalTarget@@QAE?AW4AITacticalTargetType@@XZ ENDP ; CvTacticalTarget::GetTargetType
_TEXT	ENDS
PUBLIC	?SetTargetType@CvTacticalTarget@@QAEXW4AITacticalTargetType@@@Z ; CvTacticalTarget::SetTargetType
; Function compile flags: /Ogtpy
;	COMDAT ?SetTargetType@CvTacticalTarget@@QAEXW4AITacticalTargetType@@@Z
_TEXT	SEGMENT
_eTargetType$ = 8					; size = 4
?SetTargetType@CvTacticalTarget@@QAEXW4AITacticalTargetType@@@Z PROC ; CvTacticalTarget::SetTargetType, COMDAT
; _this$ = ecx

; 332  : 		m_eTargetType = eTargetType;

	mov	eax, DWORD PTR _eTargetType$[esp-4]
	mov	DWORD PTR [ecx], eax

; 333  : 	}

	ret	4
?SetTargetType@CvTacticalTarget@@QAEXW4AITacticalTargetType@@@Z ENDP ; CvTacticalTarget::SetTargetType
_TEXT	ENDS
PUBLIC	?GetTargetX@CvTacticalTarget@@QAEHXZ		; CvTacticalTarget::GetTargetX
; Function compile flags: /Ogtpy
;	COMDAT ?GetTargetX@CvTacticalTarget@@QAEHXZ
_TEXT	SEGMENT
?GetTargetX@CvTacticalTarget@@QAEHXZ PROC		; CvTacticalTarget::GetTargetX, COMDAT
; _this$ = ecx

; 340  : 		return m_iTargetX;

	mov	eax, DWORD PTR [ecx+4]

; 341  : 	}

	ret	0
?GetTargetX@CvTacticalTarget@@QAEHXZ ENDP		; CvTacticalTarget::GetTargetX
_TEXT	ENDS
PUBLIC	?SetTargetX@CvTacticalTarget@@QAEXH@Z		; CvTacticalTarget::SetTargetX
; Function compile flags: /Ogtpy
;	COMDAT ?SetTargetX@CvTacticalTarget@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetTargetX@CvTacticalTarget@@QAEXH@Z PROC		; CvTacticalTarget::SetTargetX, COMDAT
; _this$ = ecx

; 344  : 		m_iTargetX = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 345  : 	}

	ret	4
?SetTargetX@CvTacticalTarget@@QAEXH@Z ENDP		; CvTacticalTarget::SetTargetX
_TEXT	ENDS
PUBLIC	?GetTargetY@CvTacticalTarget@@QAEHXZ		; CvTacticalTarget::GetTargetY
; Function compile flags: /Ogtpy
;	COMDAT ?GetTargetY@CvTacticalTarget@@QAEHXZ
_TEXT	SEGMENT
?GetTargetY@CvTacticalTarget@@QAEHXZ PROC		; CvTacticalTarget::GetTargetY, COMDAT
; _this$ = ecx

; 352  : 		return m_iTargetY;

	mov	eax, DWORD PTR [ecx+8]

; 353  : 	}

	ret	0
?GetTargetY@CvTacticalTarget@@QAEHXZ ENDP		; CvTacticalTarget::GetTargetY
_TEXT	ENDS
PUBLIC	?SetTargetY@CvTacticalTarget@@QAEXH@Z		; CvTacticalTarget::SetTargetY
; Function compile flags: /Ogtpy
;	COMDAT ?SetTargetY@CvTacticalTarget@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetTargetY@CvTacticalTarget@@QAEXH@Z PROC		; CvTacticalTarget::SetTargetY, COMDAT
; _this$ = ecx

; 356  : 		m_iTargetY = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 357  : 	}

	ret	4
?SetTargetY@CvTacticalTarget@@QAEXH@Z ENDP		; CvTacticalTarget::SetTargetY
_TEXT	ENDS
PUBLIC	?GetTargetPlayer@CvTacticalTarget@@QAE?AW4PlayerTypes@@XZ ; CvTacticalTarget::GetTargetPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetTargetPlayer@CvTacticalTarget@@QAE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetTargetPlayer@CvTacticalTarget@@QAE?AW4PlayerTypes@@XZ PROC ; CvTacticalTarget::GetTargetPlayer, COMDAT
; _this$ = ecx

; 364  : 		return m_eTargetPlayer;

	mov	eax, DWORD PTR [ecx+12]

; 365  : 	}

	ret	0
?GetTargetPlayer@CvTacticalTarget@@QAE?AW4PlayerTypes@@XZ ENDP ; CvTacticalTarget::GetTargetPlayer
_TEXT	ENDS
PUBLIC	?SetTargetPlayer@CvTacticalTarget@@QAEXW4PlayerTypes@@@Z ; CvTacticalTarget::SetTargetPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?SetTargetPlayer@CvTacticalTarget@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eValue$ = 8						; size = 4
?SetTargetPlayer@CvTacticalTarget@@QAEXW4PlayerTypes@@@Z PROC ; CvTacticalTarget::SetTargetPlayer, COMDAT
; _this$ = ecx

; 368  : 		m_eTargetPlayer = eValue;

	mov	eax, DWORD PTR _eValue$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 369  : 	}

	ret	4
?SetTargetPlayer@CvTacticalTarget@@QAEXW4PlayerTypes@@@Z ENDP ; CvTacticalTarget::SetTargetPlayer
_TEXT	ENDS
PUBLIC	?GetDominanceZone@CvTacticalTarget@@QBEHXZ	; CvTacticalTarget::GetDominanceZone
; Function compile flags: /Ogtpy
;	COMDAT ?GetDominanceZone@CvTacticalTarget@@QBEHXZ
_TEXT	SEGMENT
?GetDominanceZone@CvTacticalTarget@@QBEHXZ PROC		; CvTacticalTarget::GetDominanceZone, COMDAT
; _this$ = ecx

; 372  : 		return m_iDominanceZoneID;

	mov	eax, DWORD PTR [ecx+24]

; 373  : 	};

	ret	0
?GetDominanceZone@CvTacticalTarget@@QBEHXZ ENDP		; CvTacticalTarget::GetDominanceZone
_TEXT	ENDS
PUBLIC	?SetDominanceZone@CvTacticalTarget@@QAEXH@Z	; CvTacticalTarget::SetDominanceZone
; Function compile flags: /Ogtpy
;	COMDAT ?SetDominanceZone@CvTacticalTarget@@QAEXH@Z
_TEXT	SEGMENT
_iZone$ = 8						; size = 4
?SetDominanceZone@CvTacticalTarget@@QAEXH@Z PROC	; CvTacticalTarget::SetDominanceZone, COMDAT
; _this$ = ecx

; 376  : 		m_iDominanceZoneID = iZone;

	mov	eax, DWORD PTR _iZone$[esp-4]
	mov	DWORD PTR [ecx+24], eax

; 377  : 	};

	ret	4
?SetDominanceZone@CvTacticalTarget@@QAEXH@Z ENDP	; CvTacticalTarget::SetDominanceZone
_TEXT	ENDS
PUBLIC	?GetAuxData@CvTacticalTarget@@QAEPAXXZ		; CvTacticalTarget::GetAuxData
; Function compile flags: /Ogtpy
;	COMDAT ?GetAuxData@CvTacticalTarget@@QAEPAXXZ
_TEXT	SEGMENT
?GetAuxData@CvTacticalTarget@@QAEPAXXZ PROC		; CvTacticalTarget::GetAuxData, COMDAT
; _this$ = ecx

; 389  : 		return m_pAuxData;

	mov	eax, DWORD PTR [ecx+16]

; 390  : 	}

	ret	0
?GetAuxData@CvTacticalTarget@@QAEPAXXZ ENDP		; CvTacticalTarget::GetAuxData
_TEXT	ENDS
PUBLIC	?SetAuxData@CvTacticalTarget@@QAEXPAX@Z		; CvTacticalTarget::SetAuxData
; Function compile flags: /Ogtpy
;	COMDAT ?SetAuxData@CvTacticalTarget@@QAEXPAX@Z
_TEXT	SEGMENT
_pAuxData$ = 8						; size = 4
?SetAuxData@CvTacticalTarget@@QAEXPAX@Z PROC		; CvTacticalTarget::SetAuxData, COMDAT
; _this$ = ecx

; 393  : 		m_pAuxData = pAuxData;

	mov	eax, DWORD PTR _pAuxData$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 394  : 	}

	ret	4
?SetAuxData@CvTacticalTarget@@QAEXPAX@Z ENDP		; CvTacticalTarget::SetAuxData
_TEXT	ENDS
PUBLIC	?GetAuxIntData@CvTacticalTarget@@QAEHXZ		; CvTacticalTarget::GetAuxIntData
; Function compile flags: /Ogtpy
;	COMDAT ?GetAuxIntData@CvTacticalTarget@@QAEHXZ
_TEXT	SEGMENT
?GetAuxIntData@CvTacticalTarget@@QAEHXZ PROC		; CvTacticalTarget::GetAuxIntData, COMDAT
; _this$ = ecx

; 406  : 		return m_iAuxData;

	mov	eax, DWORD PTR [ecx+20]

; 407  : 	}

	ret	0
?GetAuxIntData@CvTacticalTarget@@QAEHXZ ENDP		; CvTacticalTarget::GetAuxIntData
_TEXT	ENDS
PUBLIC	?SetAuxIntData@CvTacticalTarget@@QAEXH@Z	; CvTacticalTarget::SetAuxIntData
; Function compile flags: /Ogtpy
;	COMDAT ?SetAuxIntData@CvTacticalTarget@@QAEXH@Z
_TEXT	SEGMENT
_iAuxData$ = 8						; size = 4
?SetAuxIntData@CvTacticalTarget@@QAEXH@Z PROC		; CvTacticalTarget::SetAuxIntData, COMDAT
; _this$ = ecx

; 410  : 		m_iAuxData = iAuxData;

	mov	eax, DWORD PTR _iAuxData$[esp-4]
	mov	DWORD PTR [ecx+20], eax

; 411  : 	}

	ret	4
?SetAuxIntData@CvTacticalTarget@@QAEXH@Z ENDP		; CvTacticalTarget::SetAuxIntData
_TEXT	ENDS
PUBLIC	??0CvQueuedAttack@@QAE@ABV0@@Z			; CvQueuedAttack::CvQueuedAttack
; Function compile flags: /Ogtpy
;	COMDAT ??0CvQueuedAttack@@QAE@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0CvQueuedAttack@@QAE@ABV0@@Z PROC			; CvQueuedAttack::CvQueuedAttack, COMDAT
; _this$ = ecx

; 443  : 	CvQueuedAttack(const CvQueuedAttack& rhs) : m_pAttacker(rhs.m_pAttacker), m_kTarget(rhs.m_kTarget), m_iSeriesID(rhs.m_iSeriesID), m_bRanged(rhs.m_bRanged), m_bCityAttack(rhs.m_bCityAttack) {}

	mov	edx, DWORD PTR _rhs$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR [edx]
	push	esi
	mov	DWORD PTR [eax], ecx
	push	edi
	lea	esi, DWORD PTR [edx+4]
	lea	edi, DWORD PTR [eax+4]
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR [eax+32], ecx
	mov	cl, BYTE PTR [edx+36]
	mov	BYTE PTR [eax+36], cl
	mov	dl, BYTE PTR [edx+37]
	pop	edi
	mov	BYTE PTR [eax+37], dl
	pop	esi
	ret	4
??0CvQueuedAttack@@QAE@ABV0@@Z ENDP			; CvQueuedAttack::CvQueuedAttack
_TEXT	ENDS
PUBLIC	?GetAttacker@CvQueuedAttack@@QAEPAXXZ		; CvQueuedAttack::GetAttacker
; Function compile flags: /Ogtpy
;	COMDAT ?GetAttacker@CvQueuedAttack@@QAEPAXXZ
_TEXT	SEGMENT
?GetAttacker@CvQueuedAttack@@QAEPAXXZ PROC		; CvQueuedAttack::GetAttacker, COMDAT
; _this$ = ecx

; 446  : 		return m_pAttacker;

	mov	eax, DWORD PTR [ecx]

; 447  : 	}

	ret	0
?GetAttacker@CvQueuedAttack@@QAEPAXXZ ENDP		; CvQueuedAttack::GetAttacker
_TEXT	ENDS
PUBLIC	?SetAttacker@CvQueuedAttack@@QAEXPAX@Z		; CvQueuedAttack::SetAttacker
; Function compile flags: /Ogtpy
;	COMDAT ?SetAttacker@CvQueuedAttack@@QAEXPAX@Z
_TEXT	SEGMENT
_pAttacker$ = 8						; size = 4
?SetAttacker@CvQueuedAttack@@QAEXPAX@Z PROC		; CvQueuedAttack::SetAttacker, COMDAT
; _this$ = ecx

; 450  : 		m_pAttacker = pAttacker;

	mov	eax, DWORD PTR _pAttacker$[esp-4]
	mov	DWORD PTR [ecx], eax

; 451  : 	}

	ret	4
?SetAttacker@CvQueuedAttack@@QAEXPAX@Z ENDP		; CvQueuedAttack::SetAttacker
_TEXT	ENDS
PUBLIC	?GetTarget@CvQueuedAttack@@QAEPAVCvTacticalTarget@@XZ ; CvQueuedAttack::GetTarget
; Function compile flags: /Ogtpy
;	COMDAT ?GetTarget@CvQueuedAttack@@QAEPAVCvTacticalTarget@@XZ
_TEXT	SEGMENT
?GetTarget@CvQueuedAttack@@QAEPAVCvTacticalTarget@@XZ PROC ; CvQueuedAttack::GetTarget, COMDAT
; _this$ = ecx

; 454  : 		return &m_kTarget;

	lea	eax, DWORD PTR [ecx+4]

; 455  : 	}

	ret	0
?GetTarget@CvQueuedAttack@@QAEPAVCvTacticalTarget@@XZ ENDP ; CvQueuedAttack::GetTarget
_TEXT	ENDS
PUBLIC	?SetTarget@CvQueuedAttack@@QAEXPAVCvTacticalTarget@@@Z ; CvQueuedAttack::SetTarget
; Function compile flags: /Ogtpy
;	COMDAT ?SetTarget@CvQueuedAttack@@QAEXPAVCvTacticalTarget@@@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
?SetTarget@CvQueuedAttack@@QAEXPAVCvTacticalTarget@@@Z PROC ; CvQueuedAttack::SetTarget, COMDAT
; _this$ = ecx

; 457  : 	{

	push	esi

; 458  : 		m_kTarget = *pTarget;

	mov	esi, DWORD PTR _pTarget$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+4]
	mov	ecx, 7
	rep movsd
	pop	edi
	pop	esi

; 459  : 	}

	ret	4
?SetTarget@CvQueuedAttack@@QAEXPAVCvTacticalTarget@@@Z ENDP ; CvQueuedAttack::SetTarget
_TEXT	ENDS
PUBLIC	?GetSeriesID@CvQueuedAttack@@QAEHXZ		; CvQueuedAttack::GetSeriesID
; Function compile flags: /Ogtpy
;	COMDAT ?GetSeriesID@CvQueuedAttack@@QAEHXZ
_TEXT	SEGMENT
?GetSeriesID@CvQueuedAttack@@QAEHXZ PROC		; CvQueuedAttack::GetSeriesID, COMDAT
; _this$ = ecx

; 462  : 		return m_iSeriesID;

	mov	eax, DWORD PTR [ecx+32]

; 463  : 	}

	ret	0
?GetSeriesID@CvQueuedAttack@@QAEHXZ ENDP		; CvQueuedAttack::GetSeriesID
_TEXT	ENDS
PUBLIC	?SetSeriesID@CvQueuedAttack@@QAEXH@Z		; CvQueuedAttack::SetSeriesID
; Function compile flags: /Ogtpy
;	COMDAT ?SetSeriesID@CvQueuedAttack@@QAEXH@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
?SetSeriesID@CvQueuedAttack@@QAEXH@Z PROC		; CvQueuedAttack::SetSeriesID, COMDAT
; _this$ = ecx

; 466  : 		m_iSeriesID = id;

	mov	eax, DWORD PTR _id$[esp-4]
	mov	DWORD PTR [ecx+32], eax

; 467  : 	}

	ret	4
?SetSeriesID@CvQueuedAttack@@QAEXH@Z ENDP		; CvQueuedAttack::SetSeriesID
_TEXT	ENDS
PUBLIC	?IsRanged@CvQueuedAttack@@QAE_NXZ		; CvQueuedAttack::IsRanged
; Function compile flags: /Ogtpy
;	COMDAT ?IsRanged@CvQueuedAttack@@QAE_NXZ
_TEXT	SEGMENT
?IsRanged@CvQueuedAttack@@QAE_NXZ PROC			; CvQueuedAttack::IsRanged, COMDAT
; _this$ = ecx

; 470  : 		return m_bRanged;

	mov	al, BYTE PTR [ecx+36]

; 471  : 	}

	ret	0
?IsRanged@CvQueuedAttack@@QAE_NXZ ENDP			; CvQueuedAttack::IsRanged
_TEXT	ENDS
PUBLIC	?SetRanged@CvQueuedAttack@@QAEX_N@Z		; CvQueuedAttack::SetRanged
; Function compile flags: /Ogtpy
;	COMDAT ?SetRanged@CvQueuedAttack@@QAEX_N@Z
_TEXT	SEGMENT
_bRanged$ = 8						; size = 1
?SetRanged@CvQueuedAttack@@QAEX_N@Z PROC		; CvQueuedAttack::SetRanged, COMDAT
; _this$ = ecx

; 474  : 		m_bRanged = bRanged;

	mov	al, BYTE PTR _bRanged$[esp-4]
	mov	BYTE PTR [ecx+36], al

; 475  : 	}

	ret	4
?SetRanged@CvQueuedAttack@@QAEX_N@Z ENDP		; CvQueuedAttack::SetRanged
_TEXT	ENDS
PUBLIC	?IsCityAttack@CvQueuedAttack@@QAE_NXZ		; CvQueuedAttack::IsCityAttack
; Function compile flags: /Ogtpy
;	COMDAT ?IsCityAttack@CvQueuedAttack@@QAE_NXZ
_TEXT	SEGMENT
?IsCityAttack@CvQueuedAttack@@QAE_NXZ PROC		; CvQueuedAttack::IsCityAttack, COMDAT
; _this$ = ecx

; 478  : 		return m_bCityAttack;

	mov	al, BYTE PTR [ecx+37]

; 479  : 	}

	ret	0
?IsCityAttack@CvQueuedAttack@@QAE_NXZ ENDP		; CvQueuedAttack::IsCityAttack
_TEXT	ENDS
PUBLIC	?SetCityAttack@CvQueuedAttack@@QAEX_N@Z		; CvQueuedAttack::SetCityAttack
; Function compile flags: /Ogtpy
;	COMDAT ?SetCityAttack@CvQueuedAttack@@QAEX_N@Z
_TEXT	SEGMENT
_bCityAttack$ = 8					; size = 1
?SetCityAttack@CvQueuedAttack@@QAEX_N@Z PROC		; CvQueuedAttack::SetCityAttack, COMDAT
; _this$ = ecx

; 482  : 		m_bCityAttack = bCityAttack;

	mov	al, BYTE PTR _bCityAttack$[esp-4]
	mov	BYTE PTR [ecx+37], al

; 483  : 	}

	ret	4
?SetCityAttack@CvQueuedAttack@@QAEX_N@Z ENDP		; CvQueuedAttack::SetCityAttack
_TEXT	ENDS
PUBLIC	??0CvTacticalPosture@@QAE@W4PlayerTypes@@_NHW4AITacticalPosture@@@Z ; CvTacticalPosture::CvTacticalPosture
; Function compile flags: /Ogtpy
;	COMDAT ??0CvTacticalPosture@@QAE@W4PlayerTypes@@_NHW4AITacticalPosture@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_bIsWater$ = 12						; size = 1
_iCityID$ = 16						; size = 4
_ePosture$ = 20						; size = 4
??0CvTacticalPosture@@QAE@W4PlayerTypes@@_NHW4AITacticalPosture@@@Z PROC ; CvTacticalPosture::CvTacticalPosture, COMDAT
; _this$ = ecx

; 519  : 	{
; 520  : 		m_iPlayerWaterInfo = (int)ePlayer * 2 + (int)bIsWater;

	mov	edx, DWORD PTR _ePlayer$[esp-4]
	mov	eax, ecx
	movzx	ecx, BYTE PTR _bIsWater$[esp-4]
	lea	ecx, DWORD PTR [ecx+edx*2]

; 521  : 		m_iCityID = iCityID;

	mov	edx, DWORD PTR _iCityID$[esp-4]
	mov	DWORD PTR [eax], ecx

; 522  : 		m_ePosture = ePosture;

	mov	ecx, DWORD PTR _ePosture$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx

; 523  : 	}

	ret	16					; 00000010H
??0CvTacticalPosture@@QAE@W4PlayerTypes@@_NHW4AITacticalPosture@@@Z ENDP ; CvTacticalPosture::CvTacticalPosture
_TEXT	ENDS
PUBLIC	?GetPlayer@CvTacticalPosture@@QBE?AW4PlayerTypes@@XZ ; CvTacticalPosture::GetPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayer@CvTacticalPosture@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetPlayer@CvTacticalPosture@@QBE?AW4PlayerTypes@@XZ PROC ; CvTacticalPosture::GetPlayer, COMDAT
; _this$ = ecx

; 527  : 		return (PlayerTypes)(m_iPlayerWaterInfo / 2);

	mov	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1

; 528  : 	};

	ret	0
?GetPlayer@CvTacticalPosture@@QBE?AW4PlayerTypes@@XZ ENDP ; CvTacticalPosture::GetPlayer
_TEXT	ENDS
PUBLIC	?IsWater@CvTacticalPosture@@QAE_NXZ		; CvTacticalPosture::IsWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsWater@CvTacticalPosture@@QAE_NXZ
_TEXT	SEGMENT
?IsWater@CvTacticalPosture@@QAE_NXZ PROC		; CvTacticalPosture::IsWater, COMDAT
; _this$ = ecx

; 531  : 		return m_iPlayerWaterInfo & 0x1;

	mov	eax, DWORD PTR [ecx]
	and	eax, 1

; 532  : 	};

	ret	0
?IsWater@CvTacticalPosture@@QAE_NXZ ENDP		; CvTacticalPosture::IsWater
_TEXT	ENDS
PUBLIC	?GetCityID@CvTacticalPosture@@QAEHXZ		; CvTacticalPosture::GetCityID
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityID@CvTacticalPosture@@QAEHXZ
_TEXT	SEGMENT
?GetCityID@CvTacticalPosture@@QAEHXZ PROC		; CvTacticalPosture::GetCityID, COMDAT
; _this$ = ecx

; 535  : 		return m_iCityID;

	mov	eax, DWORD PTR [ecx+4]

; 536  : 	};

	ret	0
?GetCityID@CvTacticalPosture@@QAEHXZ ENDP		; CvTacticalPosture::GetCityID
_TEXT	ENDS
PUBLIC	?GetPosture@CvTacticalPosture@@QAE?AW4AITacticalPosture@@XZ ; CvTacticalPosture::GetPosture
; Function compile flags: /Ogtpy
;	COMDAT ?GetPosture@CvTacticalPosture@@QAE?AW4AITacticalPosture@@XZ
_TEXT	SEGMENT
?GetPosture@CvTacticalPosture@@QAE?AW4AITacticalPosture@@XZ PROC ; CvTacticalPosture::GetPosture, COMDAT
; _this$ = ecx

; 539  : 		return m_ePosture;

	mov	eax, DWORD PTR [ecx+8]

; 540  : 	};

	ret	0
?GetPosture@CvTacticalPosture@@QAE?AW4AITacticalPosture@@XZ ENDP ; CvTacticalPosture::GetPosture
_TEXT	ENDS
PUBLIC	?GetX@CvTemporaryZone@@QBEHXZ			; CvTemporaryZone::GetX
; Function compile flags: /Ogtpy
;	COMDAT ?GetX@CvTemporaryZone@@QBEHXZ
_TEXT	SEGMENT
?GetX@CvTemporaryZone@@QBEHXZ PROC			; CvTemporaryZone::GetX, COMDAT
; _this$ = ecx

; 577  : 		return m_iX;

	mov	eax, DWORD PTR [ecx]

; 578  : 	};

	ret	0
?GetX@CvTemporaryZone@@QBEHXZ ENDP			; CvTemporaryZone::GetX
_TEXT	ENDS
PUBLIC	?SetX@CvTemporaryZone@@QAEXH@Z			; CvTemporaryZone::SetX
; Function compile flags: /Ogtpy
;	COMDAT ?SetX@CvTemporaryZone@@QAEXH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
?SetX@CvTemporaryZone@@QAEXH@Z PROC			; CvTemporaryZone::SetX, COMDAT
; _this$ = ecx

; 581  : 		m_iX = iX;

	mov	eax, DWORD PTR _iX$[esp-4]
	mov	DWORD PTR [ecx], eax

; 582  : 	};

	ret	4
?SetX@CvTemporaryZone@@QAEXH@Z ENDP			; CvTemporaryZone::SetX
_TEXT	ENDS
PUBLIC	?GetY@CvTemporaryZone@@QBEHXZ			; CvTemporaryZone::GetY
; Function compile flags: /Ogtpy
;	COMDAT ?GetY@CvTemporaryZone@@QBEHXZ
_TEXT	SEGMENT
?GetY@CvTemporaryZone@@QBEHXZ PROC			; CvTemporaryZone::GetY, COMDAT
; _this$ = ecx

; 585  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+4]

; 586  : 	};

	ret	0
?GetY@CvTemporaryZone@@QBEHXZ ENDP			; CvTemporaryZone::GetY
_TEXT	ENDS
PUBLIC	?SetY@CvTemporaryZone@@QAEXH@Z			; CvTemporaryZone::SetY
; Function compile flags: /Ogtpy
;	COMDAT ?SetY@CvTemporaryZone@@QAEXH@Z
_TEXT	SEGMENT
_iY$ = 8						; size = 4
?SetY@CvTemporaryZone@@QAEXH@Z PROC			; CvTemporaryZone::SetY, COMDAT
; _this$ = ecx

; 589  : 		m_iY = iY;

	mov	eax, DWORD PTR _iY$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 590  : 	};

	ret	4
?SetY@CvTemporaryZone@@QAEXH@Z ENDP			; CvTemporaryZone::SetY
_TEXT	ENDS
PUBLIC	?GetTargetType@CvTemporaryZone@@QBE?AW4AITacticalTargetType@@XZ ; CvTemporaryZone::GetTargetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetTargetType@CvTemporaryZone@@QBE?AW4AITacticalTargetType@@XZ
_TEXT	SEGMENT
?GetTargetType@CvTemporaryZone@@QBE?AW4AITacticalTargetType@@XZ PROC ; CvTemporaryZone::GetTargetType, COMDAT
; _this$ = ecx

; 593  : 		return m_eTargetType;

	mov	eax, DWORD PTR [ecx+8]

; 594  : 	};

	ret	0
?GetTargetType@CvTemporaryZone@@QBE?AW4AITacticalTargetType@@XZ ENDP ; CvTemporaryZone::GetTargetType
_TEXT	ENDS
PUBLIC	?SetTargetType@CvTemporaryZone@@QAEXW4AITacticalTargetType@@@Z ; CvTemporaryZone::SetTargetType
; Function compile flags: /Ogtpy
;	COMDAT ?SetTargetType@CvTemporaryZone@@QAEXW4AITacticalTargetType@@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?SetTargetType@CvTemporaryZone@@QAEXW4AITacticalTargetType@@@Z PROC ; CvTemporaryZone::SetTargetType, COMDAT
; _this$ = ecx

; 597  : 		m_eTargetType = eType;

	mov	eax, DWORD PTR _eType$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 598  : 	};

	ret	4
?SetTargetType@CvTemporaryZone@@QAEXW4AITacticalTargetType@@@Z ENDP ; CvTemporaryZone::SetTargetType
_TEXT	ENDS
PUBLIC	?GetLastTurn@CvTemporaryZone@@QBEHXZ		; CvTemporaryZone::GetLastTurn
; Function compile flags: /Ogtpy
;	COMDAT ?GetLastTurn@CvTemporaryZone@@QBEHXZ
_TEXT	SEGMENT
?GetLastTurn@CvTemporaryZone@@QBEHXZ PROC		; CvTemporaryZone::GetLastTurn, COMDAT
; _this$ = ecx

; 601  : 		return m_iLastTurn;

	mov	eax, DWORD PTR [ecx+12]

; 602  : 	};

	ret	0
?GetLastTurn@CvTemporaryZone@@QBEHXZ ENDP		; CvTemporaryZone::GetLastTurn
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z ; std::_Dist_type<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?SetLastTurn@CvTemporaryZone@@QAEXH@Z		; CvTemporaryZone::SetLastTurn
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.h
;	COMDAT ?SetLastTurn@CvTemporaryZone@@QAEXH@Z
_TEXT	SEGMENT
_iTurn$ = 8						; size = 4
?SetLastTurn@CvTemporaryZone@@QAEXH@Z PROC		; CvTemporaryZone::SetLastTurn, COMDAT
; _this$ = ecx

; 605  : 		m_iLastTurn = iTurn;

	mov	eax, DWORD PTR _iTurn$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 606  : 	};

	ret	4
?SetLastTurn@CvTemporaryZone@@QAEXH@Z ENDP		; CvTemporaryZone::SetLastTurn
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?IsNavalInvasion@CvTemporaryZone@@QBE_NXZ	; CvTemporaryZone::IsNavalInvasion
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.h
;	COMDAT ?IsNavalInvasion@CvTemporaryZone@@QBE_NXZ
_TEXT	SEGMENT
?IsNavalInvasion@CvTemporaryZone@@QBE_NXZ PROC		; CvTemporaryZone::IsNavalInvasion, COMDAT
; _this$ = ecx

; 609  : 		return m_bIsNavalInvasion;

	mov	al, BYTE PTR [ecx+16]

; 610  : 	};

	ret	0
?IsNavalInvasion@CvTemporaryZone@@QBE_NXZ ENDP		; CvTemporaryZone::IsNavalInvasion
_TEXT	ENDS
PUBLIC	?SetNavalInvasion@CvTemporaryZone@@QAEX_N@Z	; CvTemporaryZone::SetNavalInvasion
; Function compile flags: /Ogtpy
;	COMDAT ?SetNavalInvasion@CvTemporaryZone@@QAEX_N@Z
_TEXT	SEGMENT
_bIsNavalInvasion$ = 8					; size = 1
?SetNavalInvasion@CvTemporaryZone@@QAEX_N@Z PROC	; CvTemporaryZone::SetNavalInvasion, COMDAT
; _this$ = ecx

; 613  : 		m_bIsNavalInvasion = bIsNavalInvasion;

	mov	al, BYTE PTR _bIsNavalInvasion$[esp-4]
	mov	BYTE PTR [ecx+16], al

; 614  : 	};

	ret	4
?SetNavalInvasion@CvTemporaryZone@@QAEX_N@Z ENDP	; CvTemporaryZone::SetNavalInvasion
_TEXT	ENDS
PUBLIC	??0CvBlockingUnit@@QAE@XZ			; CvBlockingUnit::CvBlockingUnit
; Function compile flags: /Ogtpy
;	COMDAT ??0CvBlockingUnit@@QAE@XZ
_TEXT	SEGMENT
??0CvBlockingUnit@@QAE@XZ PROC				; CvBlockingUnit::CvBlockingUnit, COMDAT
; _this$ = ecx

; 639  : 	CvBlockingUnit()

	mov	eax, ecx

; 640  : 	{
; 641  : 		m_pPlot = NULL;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 642  : 		m_iUnitID = 0;

	mov	DWORD PTR [eax+4], ecx

; 643  : 		m_iNumChoices = 0;

	mov	DWORD PTR [eax+8], ecx

; 644  : 		m_iDistanceToTarget = 0;

	mov	DWORD PTR [eax+12], ecx

; 645  : 	};

	ret	0
??0CvBlockingUnit@@QAE@XZ ENDP				; CvBlockingUnit::CvBlockingUnit
_TEXT	ENDS
PUBLIC	??MCvBlockingUnit@@QBE_NABV0@@Z			; CvBlockingUnit::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MCvBlockingUnit@@QBE_NABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??MCvBlockingUnit@@QBE_NABV0@@Z PROC			; CvBlockingUnit::operator<, COMDAT
; _this$ = ecx

; 648  : 		return (m_iUnitID < rhs.m_iUnitID);

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _rhs$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setl	cl
	mov	al, cl

; 649  : 	};

	ret	4
??MCvBlockingUnit@@QBE_NABV0@@Z ENDP			; CvBlockingUnit::operator<
_TEXT	ENDS
PUBLIC	?GetPlot@CvBlockingUnit@@QBEPAVCvPlot@@XZ	; CvBlockingUnit::GetPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlot@CvBlockingUnit@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetPlot@CvBlockingUnit@@QBEPAVCvPlot@@XZ PROC		; CvBlockingUnit::GetPlot, COMDAT
; _this$ = ecx

; 652  : 		return m_pPlot;

	mov	eax, DWORD PTR [ecx]

; 653  : 	};

	ret	0
?GetPlot@CvBlockingUnit@@QBEPAVCvPlot@@XZ ENDP		; CvBlockingUnit::GetPlot
_TEXT	ENDS
PUBLIC	?SetPlot@CvBlockingUnit@@QAEXPAVCvPlot@@@Z	; CvBlockingUnit::SetPlot
; Function compile flags: /Ogtpy
;	COMDAT ?SetPlot@CvBlockingUnit@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?SetPlot@CvBlockingUnit@@QAEXPAVCvPlot@@@Z PROC		; CvBlockingUnit::SetPlot, COMDAT
; _this$ = ecx

; 656  : 		m_pPlot = pPlot;

	mov	eax, DWORD PTR _pPlot$[esp-4]
	mov	DWORD PTR [ecx], eax

; 657  : 	};

	ret	4
?SetPlot@CvBlockingUnit@@QAEXPAVCvPlot@@@Z ENDP		; CvBlockingUnit::SetPlot
_TEXT	ENDS
PUBLIC	?GetUnitID@CvBlockingUnit@@QBEHXZ		; CvBlockingUnit::GetUnitID
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitID@CvBlockingUnit@@QBEHXZ
_TEXT	SEGMENT
?GetUnitID@CvBlockingUnit@@QBEHXZ PROC			; CvBlockingUnit::GetUnitID, COMDAT
; _this$ = ecx

; 660  : 		return m_iUnitID;

	mov	eax, DWORD PTR [ecx+4]

; 661  : 	};

	ret	0
?GetUnitID@CvBlockingUnit@@QBEHXZ ENDP			; CvBlockingUnit::GetUnitID
_TEXT	ENDS
PUBLIC	?SetUnitID@CvBlockingUnit@@QAEXH@Z		; CvBlockingUnit::SetUnitID
; Function compile flags: /Ogtpy
;	COMDAT ?SetUnitID@CvBlockingUnit@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetUnitID@CvBlockingUnit@@QAEXH@Z PROC			; CvBlockingUnit::SetUnitID, COMDAT
; _this$ = ecx

; 664  : 		m_iUnitID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 665  : 	};

	ret	4
?SetUnitID@CvBlockingUnit@@QAEXH@Z ENDP			; CvBlockingUnit::SetUnitID
_TEXT	ENDS
PUBLIC	?GetNumChoices@CvBlockingUnit@@QBEHXZ		; CvBlockingUnit::GetNumChoices
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumChoices@CvBlockingUnit@@QBEHXZ
_TEXT	SEGMENT
?GetNumChoices@CvBlockingUnit@@QBEHXZ PROC		; CvBlockingUnit::GetNumChoices, COMDAT
; _this$ = ecx

; 668  : 		return m_iNumChoices;

	mov	eax, DWORD PTR [ecx+8]

; 669  : 	};

	ret	0
?GetNumChoices@CvBlockingUnit@@QBEHXZ ENDP		; CvBlockingUnit::GetNumChoices
_TEXT	ENDS
PUBLIC	?SetNumChoices@CvBlockingUnit@@QAEXH@Z		; CvBlockingUnit::SetNumChoices
; Function compile flags: /Ogtpy
;	COMDAT ?SetNumChoices@CvBlockingUnit@@QAEXH@Z
_TEXT	SEGMENT
_iChoices$ = 8						; size = 4
?SetNumChoices@CvBlockingUnit@@QAEXH@Z PROC		; CvBlockingUnit::SetNumChoices, COMDAT
; _this$ = ecx

; 672  : 		m_iNumChoices = iChoices;

	mov	eax, DWORD PTR _iChoices$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 673  : 	};

	ret	4
?SetNumChoices@CvBlockingUnit@@QAEXH@Z ENDP		; CvBlockingUnit::SetNumChoices
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAPAVCvPlot@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@@Z ; std::_Iter_cat<CvPlot * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPAVCvPlot@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVCvPlot@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@@Z PROC ; std::_Iter_cat<CvPlot * *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAPAVCvPlot@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@@Z ENDP ; std::_Iter_cat<CvPlot * *>
_TEXT	ENDS
PUBLIC	?GetDistanceToTarget@CvBlockingUnit@@QBEHXZ	; CvBlockingUnit::GetDistanceToTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.h
;	COMDAT ?GetDistanceToTarget@CvBlockingUnit@@QBEHXZ
_TEXT	SEGMENT
?GetDistanceToTarget@CvBlockingUnit@@QBEHXZ PROC	; CvBlockingUnit::GetDistanceToTarget, COMDAT
; _this$ = ecx

; 676  : 		return m_iDistanceToTarget;

	mov	eax, DWORD PTR [ecx+12]

; 677  : 	};

	ret	0
?GetDistanceToTarget@CvBlockingUnit@@QBEHXZ ENDP	; CvBlockingUnit::GetDistanceToTarget
_TEXT	ENDS
PUBLIC	?SetDistanceToTarget@CvBlockingUnit@@QAEXH@Z	; CvBlockingUnit::SetDistanceToTarget
; Function compile flags: /Ogtpy
;	COMDAT ?SetDistanceToTarget@CvBlockingUnit@@QAEXH@Z
_TEXT	SEGMENT
_iDistanceToTarget$ = 8					; size = 4
?SetDistanceToTarget@CvBlockingUnit@@QAEXH@Z PROC	; CvBlockingUnit::SetDistanceToTarget, COMDAT
; _this$ = ecx

; 680  : 		m_iDistanceToTarget = iDistanceToTarget;

	mov	eax, DWORD PTR _iDistanceToTarget$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 681  : 	};

	ret	4
?SetDistanceToTarget@CvBlockingUnit@@QAEXH@Z ENDP	; CvBlockingUnit::SetDistanceToTarget
_TEXT	ENDS
PUBLIC	??0CvOperationUnit@@QAE@XZ			; CvOperationUnit::CvOperationUnit
; Function compile flags: /Ogtpy
;	COMDAT ??0CvOperationUnit@@QAE@XZ
_TEXT	SEGMENT
??0CvOperationUnit@@QAE@XZ PROC				; CvOperationUnit::CvOperationUnit, COMDAT
; _this$ = ecx

; 697  : 	CvOperationUnit()

	mov	eax, ecx

; 698  : 	{
; 699  : 		m_iUnitID = 0;

	mov	DWORD PTR [eax], 0

; 700  : 		m_ePosition = NO_MUPOSITION;

	mov	DWORD PTR [eax+4], -1

; 701  : 	};

	ret	0
??0CvOperationUnit@@QAE@XZ ENDP				; CvOperationUnit::CvOperationUnit
_TEXT	ENDS
PUBLIC	?GetUnitID@CvOperationUnit@@QBEHXZ		; CvOperationUnit::GetUnitID
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitID@CvOperationUnit@@QBEHXZ
_TEXT	SEGMENT
?GetUnitID@CvOperationUnit@@QBEHXZ PROC			; CvOperationUnit::GetUnitID, COMDAT
; _this$ = ecx

; 704  : 		return m_iUnitID;

	mov	eax, DWORD PTR [ecx]

; 705  : 	};

	ret	0
?GetUnitID@CvOperationUnit@@QBEHXZ ENDP			; CvOperationUnit::GetUnitID
_TEXT	ENDS
PUBLIC	?SetUnitID@CvOperationUnit@@QAEXH@Z		; CvOperationUnit::SetUnitID
; Function compile flags: /Ogtpy
;	COMDAT ?SetUnitID@CvOperationUnit@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetUnitID@CvOperationUnit@@QAEXH@Z PROC		; CvOperationUnit::SetUnitID, COMDAT
; _this$ = ecx

; 708  : 		m_iUnitID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx], eax

; 709  : 	};

	ret	4
?SetUnitID@CvOperationUnit@@QAEXH@Z ENDP		; CvOperationUnit::SetUnitID
_TEXT	ENDS
PUBLIC	?SetPosition@CvOperationUnit@@QAEXW4MultiunitPositionTypes@@@Z ; CvOperationUnit::SetPosition
; Function compile flags: /Ogtpy
;	COMDAT ?SetPosition@CvOperationUnit@@QAEXW4MultiunitPositionTypes@@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?SetPosition@CvOperationUnit@@QAEXW4MultiunitPositionTypes@@@Z PROC ; CvOperationUnit::SetPosition, COMDAT
; _this$ = ecx

; 716  : 		m_ePosition = eType;

	mov	eax, DWORD PTR _eType$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 717  : 	};

	ret	4
?SetPosition@CvOperationUnit@@QAEXW4MultiunitPositionTypes@@@Z ENDP ; CvOperationUnit::SetPosition
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@1@@Z ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@1@@Z PROC ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator-, COMDAT
; _this$ = ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 399  : 		}

	ret	4
??G?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@1@@Z ENDP ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@1@@Z ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@1@@Z PROC ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator-, COMDAT
; _this$ = ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 399  : 		}

	ret	4
??G?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@1@@Z ENDP ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator-
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CvTacticalMove>::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Init@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CvTacticalMove>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CvTacticalMove>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@VCvTacticalMove@@@std@@QBEPAVCvTacticalMove@@XZ ; std::_Temp_iterator<CvTacticalMove>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@VCvTacticalMove@@@std@@QBEPAVCvTacticalMove@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@VCvTacticalMove@@@std@@QBEPAVCvTacticalMove@@XZ PROC ; std::_Temp_iterator<CvTacticalMove>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@VCvTacticalMove@@@std@@QBEPAVCvTacticalMove@@XZ ENDP ; std::_Temp_iterator<CvTacticalMove>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@VCvTacticalMove@@@std@@QBEPAVCvTacticalMove@@XZ ; std::_Temp_iterator<CvTacticalMove>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@VCvTacticalMove@@@std@@QBEPAVCvTacticalMove@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@VCvTacticalMove@@@std@@QBEPAVCvTacticalMove@@XZ PROC ; std::_Temp_iterator<CvTacticalMove>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@VCvTacticalMove@@@std@@QBEPAVCvTacticalMove@@XZ ENDP ; std::_Temp_iterator<CvTacticalMove>::_Last
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CvTacticalTarget>::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CvTacticalTarget>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CvTacticalTarget>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@VCvTacticalTarget@@@std@@QBEPAVCvTacticalTarget@@XZ ; std::_Temp_iterator<CvTacticalTarget>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@VCvTacticalTarget@@@std@@QBEPAVCvTacticalTarget@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@VCvTacticalTarget@@@std@@QBEPAVCvTacticalTarget@@XZ PROC ; std::_Temp_iterator<CvTacticalTarget>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@VCvTacticalTarget@@@std@@QBEPAVCvTacticalTarget@@XZ ENDP ; std::_Temp_iterator<CvTacticalTarget>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@VCvTacticalTarget@@@std@@QBEPAVCvTacticalTarget@@XZ ; std::_Temp_iterator<CvTacticalTarget>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@VCvTacticalTarget@@@std@@QBEPAVCvTacticalTarget@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@VCvTacticalTarget@@@std@@QBEPAVCvTacticalTarget@@XZ PROC ; std::_Temp_iterator<CvTacticalTarget>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@VCvTacticalTarget@@@std@@QBEPAVCvTacticalTarget@@XZ ENDP ; std::_Temp_iterator<CvTacticalTarget>::_Last
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CvTacticalUnit>::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CvTacticalUnit>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CvTacticalUnit>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@VCvTacticalUnit@@@std@@QBEPAVCvTacticalUnit@@XZ ; std::_Temp_iterator<CvTacticalUnit>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@VCvTacticalUnit@@@std@@QBEPAVCvTacticalUnit@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@VCvTacticalUnit@@@std@@QBEPAVCvTacticalUnit@@XZ PROC ; std::_Temp_iterator<CvTacticalUnit>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@VCvTacticalUnit@@@std@@QBEPAVCvTacticalUnit@@XZ ENDP ; std::_Temp_iterator<CvTacticalUnit>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@VCvTacticalUnit@@@std@@QBEPAVCvTacticalUnit@@XZ ; std::_Temp_iterator<CvTacticalUnit>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@VCvTacticalUnit@@@std@@QBEPAVCvTacticalUnit@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@VCvTacticalUnit@@@std@@QBEPAVCvTacticalUnit@@XZ PROC ; std::_Temp_iterator<CvTacticalUnit>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@VCvTacticalUnit@@@std@@QBEPAVCvTacticalUnit@@XZ ENDP ; std::_Temp_iterator<CvTacticalUnit>::_Last
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CvTacticalCity>::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CvTacticalCity>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CvTacticalCity>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@VCvTacticalCity@@@std@@QBEPAVCvTacticalCity@@XZ ; std::_Temp_iterator<CvTacticalCity>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@VCvTacticalCity@@@std@@QBEPAVCvTacticalCity@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@VCvTacticalCity@@@std@@QBEPAVCvTacticalCity@@XZ PROC ; std::_Temp_iterator<CvTacticalCity>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@VCvTacticalCity@@@std@@QBEPAVCvTacticalCity@@XZ ENDP ; std::_Temp_iterator<CvTacticalCity>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@VCvTacticalCity@@@std@@QBEPAVCvTacticalCity@@XZ ; std::_Temp_iterator<CvTacticalCity>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@VCvTacticalCity@@@std@@QBEPAVCvTacticalCity@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@VCvTacticalCity@@@std@@QBEPAVCvTacticalCity@@XZ PROC ; std::_Temp_iterator<CvTacticalCity>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@VCvTacticalCity@@@std@@QBEPAVCvTacticalCity@@XZ ENDP ; std::_Temp_iterator<CvTacticalCity>::_Last
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CvBlockingUnit>::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CvBlockingUnit>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CvBlockingUnit>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@VCvBlockingUnit@@@std@@QBEPAVCvBlockingUnit@@XZ ; std::_Temp_iterator<CvBlockingUnit>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@VCvBlockingUnit@@@std@@QBEPAVCvBlockingUnit@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@VCvBlockingUnit@@@std@@QBEPAVCvBlockingUnit@@XZ PROC ; std::_Temp_iterator<CvBlockingUnit>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@VCvBlockingUnit@@@std@@QBEPAVCvBlockingUnit@@XZ ENDP ; std::_Temp_iterator<CvBlockingUnit>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@VCvBlockingUnit@@@std@@QBEPAVCvBlockingUnit@@XZ ; std::_Temp_iterator<CvBlockingUnit>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@VCvBlockingUnit@@@std@@QBEPAVCvBlockingUnit@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@VCvBlockingUnit@@@std@@QBEPAVCvBlockingUnit@@XZ PROC ; std::_Temp_iterator<CvBlockingUnit>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@VCvBlockingUnit@@@std@@QBEPAVCvBlockingUnit@@XZ ENDP ; std::_Temp_iterator<CvBlockingUnit>::_Last
_TEXT	ENDS
PUBLIC	??0?$pair@PAVCvTacticalMove@@H@std@@QAE@ABQAVCvTacticalMove@@ABH@Z ; std::pair<CvTacticalMove *,int>::pair<CvTacticalMove *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAVCvTacticalMove@@H@std@@QAE@ABQAVCvTacticalMove@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAVCvTacticalMove@@H@std@@QAE@ABQAVCvTacticalMove@@ABH@Z PROC ; std::pair<CvTacticalMove *,int>::pair<CvTacticalMove *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAVCvTacticalMove@@H@std@@QAE@ABQAVCvTacticalMove@@ABH@Z ENDP ; std::pair<CvTacticalMove *,int>::pair<CvTacticalMove *,int>
_TEXT	ENDS
PUBLIC	??0?$pair@PAVCvTacticalTarget@@H@std@@QAE@ABQAVCvTacticalTarget@@ABH@Z ; std::pair<CvTacticalTarget *,int>::pair<CvTacticalTarget *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@PAVCvTacticalTarget@@H@std@@QAE@ABQAVCvTacticalTarget@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAVCvTacticalTarget@@H@std@@QAE@ABQAVCvTacticalTarget@@ABH@Z PROC ; std::pair<CvTacticalTarget *,int>::pair<CvTacticalTarget *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAVCvTacticalTarget@@H@std@@QAE@ABQAVCvTacticalTarget@@ABH@Z ENDP ; std::pair<CvTacticalTarget *,int>::pair<CvTacticalTarget *,int>
_TEXT	ENDS
PUBLIC	??0?$pair@PAVCvTacticalUnit@@H@std@@QAE@ABQAVCvTacticalUnit@@ABH@Z ; std::pair<CvTacticalUnit *,int>::pair<CvTacticalUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@PAVCvTacticalUnit@@H@std@@QAE@ABQAVCvTacticalUnit@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAVCvTacticalUnit@@H@std@@QAE@ABQAVCvTacticalUnit@@ABH@Z PROC ; std::pair<CvTacticalUnit *,int>::pair<CvTacticalUnit *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAVCvTacticalUnit@@H@std@@QAE@ABQAVCvTacticalUnit@@ABH@Z ENDP ; std::pair<CvTacticalUnit *,int>::pair<CvTacticalUnit *,int>
_TEXT	ENDS
PUBLIC	??0?$pair@PAVCvTacticalCity@@H@std@@QAE@ABQAVCvTacticalCity@@ABH@Z ; std::pair<CvTacticalCity *,int>::pair<CvTacticalCity *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@PAVCvTacticalCity@@H@std@@QAE@ABQAVCvTacticalCity@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAVCvTacticalCity@@H@std@@QAE@ABQAVCvTacticalCity@@ABH@Z PROC ; std::pair<CvTacticalCity *,int>::pair<CvTacticalCity *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAVCvTacticalCity@@H@std@@QAE@ABQAVCvTacticalCity@@ABH@Z ENDP ; std::pair<CvTacticalCity *,int>::pair<CvTacticalCity *,int>
_TEXT	ENDS
PUBLIC	??0?$pair@PAVCvBlockingUnit@@H@std@@QAE@ABQAVCvBlockingUnit@@ABH@Z ; std::pair<CvBlockingUnit *,int>::pair<CvBlockingUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@PAVCvBlockingUnit@@H@std@@QAE@ABQAVCvBlockingUnit@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAVCvBlockingUnit@@H@std@@QAE@ABQAVCvBlockingUnit@@ABH@Z PROC ; std::pair<CvBlockingUnit *,int>::pair<CvBlockingUnit *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAVCvBlockingUnit@@H@std@@QAE@ABQAVCvBlockingUnit@@ABH@Z ENDP ; std::pair<CvBlockingUnit *,int>::pair<CvBlockingUnit *,int>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEABVCvTacticalCity@@XZ ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEABVCvTacticalCity@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEABVCvTacticalCity@@XZ PROC ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEABVCvTacticalCity@@XZ ENDP ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator*
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CvTacticalMove>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CvTacticalMove>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CvTacticalMove>::operator=
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CvTacticalTarget>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CvTacticalTarget>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CvTacticalTarget>::operator=
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CvTacticalUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CvTacticalUnit>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CvTacticalUnit>::operator=
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CvTacticalCity>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CvTacticalCity>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CvTacticalCity>::operator=
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CvBlockingUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CvBlockingUnit>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CvBlockingUnit>::operator=
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??$_Advance@PAVCvTacticalMove@@H@std@@YAXAAPAVCvTacticalMove@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CvTacticalMove *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Advance@PAVCvTacticalMove@@H@std@@YAXAAPAVCvTacticalMove@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAVCvTacticalMove@@H@std@@YAXAAPAVCvTacticalMove@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CvTacticalMove *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAVCvTacticalMove@@H@std@@YAXAAPAVCvTacticalMove@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CvTacticalMove *,int>
_TEXT	ENDS
PUBLIC	??$_Advance@PAVCvTacticalTarget@@H@std@@YAXAAPAVCvTacticalTarget@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CvTacticalTarget *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Advance@PAVCvTacticalTarget@@H@std@@YAXAAPAVCvTacticalTarget@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAVCvTacticalTarget@@H@std@@YAXAAPAVCvTacticalTarget@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CvTacticalTarget *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAVCvTacticalTarget@@H@std@@YAXAAPAVCvTacticalTarget@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CvTacticalTarget *,int>
_TEXT	ENDS
PUBLIC	??$_Advance@PAVCvBlockingUnit@@H@std@@YAXAAPAVCvBlockingUnit@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CvBlockingUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Advance@PAVCvBlockingUnit@@H@std@@YAXAAPAVCvBlockingUnit@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAVCvBlockingUnit@@H@std@@YAXAAPAVCvBlockingUnit@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CvBlockingUnit *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR __Where$[esp-4]
	shl	ecx, 4
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAVCvBlockingUnit@@H@std@@YAXAAPAVCvBlockingUnit@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CvBlockingUnit *,int>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::swap<CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::swap<CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::swap<CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvPlot@@IPAV1@@std@@YAXPAPAVCvPlot@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCvPlot@@IPAV1@@std@@YAXPAPAVCvPlot@@IABQAV1@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVCvPlot@@IPAV1@@std@@YAXPAPAVCvPlot@@IABQAV1@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAVCvPlot@@IPAV1@@std@@YAXPAPAVCvPlot@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??F?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??F?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator--, COMDAT
; _this$ = ecx

; 137  : 		{	// predecrement

	mov	eax, ecx

; 138  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 139  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 140  : 
; 141  :  #if _HAS_ITERATOR_DEBUGGING
; 142  : 		if (this->_Mycont == 0
; 143  : 			|| _Myptr == ((_Myvec *)this->_Mycont)->_Myfirst)
; 144  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 145  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 146  : 
; 147  : 		--_Myptr;

	add	DWORD PTR [eax], -24			; ffffffe8H

; 148  : 		return (*this);
; 149  : 		}

	ret	0
??F?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator--
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 12			; 0000000cH

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator--, COMDAT
; _this$ = ecx

; 137  : 		{	// predecrement

	mov	eax, ecx

; 138  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 139  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 140  : 
; 141  :  #if _HAS_ITERATOR_DEBUGGING
; 142  : 		if (this->_Mycont == 0
; 143  : 			|| _Myptr == ((_Myvec *)this->_Mycont)->_Myfirst)
; 144  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 145  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 146  : 
; 147  : 		--_Myptr;

	add	DWORD PTR [eax], -12			; fffffff4H

; 148  : 		return (*this);
; 149  : 		}

	ret	0
??F?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator--
_TEXT	ENDS
PUBLIC	??$swap@VCvTacticalMove@@@std@@YAXAAVCvTacticalMove@@0@Z ; std::swap<CvTacticalMove>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@VCvTacticalMove@@@std@@YAXAAVCvTacticalMove@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvTacticalMove@@@std@@YAXAAVCvTacticalMove@@0@Z PROC ; std::swap<CvTacticalMove>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@VCvTacticalMove@@@std@@YAXAAVCvTacticalMove@@0@Z ENDP ; std::swap<CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalMove@@ABV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Iter_random<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalMove@@ABV?$_Temp_iterator@VCvTacticalMove@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalMove@@ABV?$_Temp_iterator@VCvTacticalMove@@@0@@Z PROC ; std::_Iter_random<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalMove@@ABV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ENDP ; std::_Iter_random<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalMove@@AAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Ptr_cat<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalMove@@AAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalMove@@AAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z PROC ; std::_Ptr_cat<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalMove@@AAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ENDP ; std::_Ptr_cat<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalMove@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalMove@@00@Z ; std::_Iter_random<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvTacticalMove@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalMove@@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvTacticalMove@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalMove@@00@Z PROC ; std::_Iter_random<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvTacticalMove@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalMove@@00@Z ENDP ; std::_Iter_random<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$swap@VCvTacticalTarget@@@std@@YAXAAVCvTacticalTarget@@0@Z ; std::swap<CvTacticalTarget>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@VCvTacticalTarget@@@std@@YAXAAVCvTacticalTarget@@0@Z
_TEXT	SEGMENT
__Tmp$234235 = -28					; size = 28
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvTacticalTarget@@@std@@YAXAAVCvTacticalTarget@@0@Z PROC ; std::swap<CvTacticalTarget>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR __Right$[esp-4]
	sub	esp, 28					; 0000001cH
	cmp	eax, edx
	je	SHORT $LN1@swap@3
	push	esi
	push	edi

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, 7
	mov	esi, eax
	lea	edi, DWORD PTR __Tmp$234235[esp+36]
	rep movsd

; 21   : 
; 22   : 		_Left = _Right;

	mov	ecx, 7
	mov	esi, edx
	mov	edi, eax
	rep movsd

; 23   : 		_Right = _Tmp;

	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$234235[esp+36]
	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
$LN1@swap@3:

; 24   : 		}
; 25   : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$swap@VCvTacticalTarget@@@std@@YAXAAVCvTacticalTarget@@0@Z ENDP ; std::swap<CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalTarget@@ABV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Iter_random<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalTarget@@ABV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalTarget@@ABV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z PROC ; std::_Iter_random<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalTarget@@ABV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ENDP ; std::_Iter_random<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalTarget@@AAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Ptr_cat<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalTarget@@AAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalTarget@@AAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z PROC ; std::_Ptr_cat<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalTarget@@AAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ENDP ; std::_Ptr_cat<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalTarget@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalTarget@@00@Z ; std::_Iter_random<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvTacticalTarget@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalTarget@@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvTacticalTarget@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalTarget@@00@Z PROC ; std::_Iter_random<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvTacticalTarget@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalTarget@@00@Z ENDP ; std::_Iter_random<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$swap@VCvTacticalUnit@@@std@@YAXAAVCvTacticalUnit@@0@Z ; std::swap<CvTacticalUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@VCvTacticalUnit@@@std@@YAXAAVCvTacticalUnit@@0@Z
_TEXT	SEGMENT
__Tmp$234476 = -24					; size = 24
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvTacticalUnit@@@std@@YAXAAVCvTacticalUnit@@0@Z PROC ; std::swap<CvTacticalUnit>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	esp, 24					; 00000018H
	cmp	eax, ecx
	je	SHORT $LN1@swap@4

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	push	ebp
	mov	ebp, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$234476[esp+48], ebp
	mov	ebp, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$234476[esp+52], ebp

; 21   : 
; 22   : 		_Left = _Right;

	mov	ebp, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	ebp, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ebp
	mov	ebp, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ebp

; 23   : 		_Right = _Tmp;

	mov	eax, DWORD PTR __Tmp$234476[esp+56]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Tmp$234476[esp+60]
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+12], ebx
	pop	ebp
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], edx
	pop	ebx
$LN1@swap@4:

; 24   : 		}
; 25   : 	}

	add	esp, 24					; 00000018H
	ret	0
??$swap@VCvTacticalUnit@@@std@@YAXAAVCvTacticalUnit@@0@Z ENDP ; std::swap<CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@ABV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@ABV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@ABV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@ABV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@AAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Ptr_cat<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@AAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@AAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@AAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@1@Z ; std::_Iter_random<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@1@Z PROC ; std::_Iter_random<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@1@Z ENDP ; std::_Iter_random<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$swap@VCvTacticalCity@@@std@@YAXAAVCvTacticalCity@@0@Z ; std::swap<CvTacticalCity>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@VCvTacticalCity@@@std@@YAXAAVCvTacticalCity@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvTacticalCity@@@std@@YAXAAVCvTacticalCity@@0@Z PROC ; std::swap<CvTacticalCity>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@5

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	ebx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	pop	ebx
$LN1@swap@5:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@VCvTacticalCity@@@std@@YAXAAVCvTacticalCity@@0@Z ENDP ; std::swap<CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@ABV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@ABV?$_Temp_iterator@VCvTacticalCity@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@ABV?$_Temp_iterator@VCvTacticalCity@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@ABV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@AAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Ptr_cat<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@AAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@AAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@AAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@1@Z ; std::_Iter_random<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@1@Z PROC ; std::_Iter_random<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@1@Z ENDP ; std::_Iter_random<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$swap@VCvBlockingUnit@@@std@@YAXAAVCvBlockingUnit@@0@Z ; std::swap<CvBlockingUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@VCvBlockingUnit@@@std@@YAXAAVCvBlockingUnit@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvBlockingUnit@@@std@@YAXAAVCvBlockingUnit@@0@Z PROC ; std::swap<CvBlockingUnit>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@6

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	push	ebp

; 21   : 
; 22   : 		_Left = _Right;

	mov	ebp, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+12], ebx
	pop	ebx
$LN1@swap@6:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@VCvBlockingUnit@@@std@@YAXAAVCvBlockingUnit@@0@Z ENDP ; std::swap<CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvBlockingUnit@@ABV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Iter_random<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvBlockingUnit@@ABV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvBlockingUnit@@ABV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z PROC ; std::_Iter_random<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvBlockingUnit@@ABV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ENDP ; std::_Iter_random<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvBlockingUnit@@AAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Ptr_cat<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvBlockingUnit@@AAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvBlockingUnit@@AAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z PROC ; std::_Ptr_cat<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvBlockingUnit@@AAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ENDP ; std::_Ptr_cat<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvBlockingUnit@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvBlockingUnit@@00@Z ; std::_Iter_random<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvBlockingUnit@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvBlockingUnit@@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvBlockingUnit@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvBlockingUnit@@00@Z PROC ; std::_Iter_random<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvBlockingUnit@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvBlockingUnit@@00@Z ENDP ; std::_Iter_random<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap
	npad	1
$LL3@Push_heap:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Iter_random<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@4
	push	esi
$LL2@Copy_backw@4:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@4
	pop	esi
$LN1@Copy_backw@4:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvTacticalMove>::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??D?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvTacticalMove>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvTacticalMove>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvTacticalMove>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvTacticalMove>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvTacticalMove>::operator++
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvTacticalTarget>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvTacticalTarget>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvTacticalTarget>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvTacticalTarget>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvTacticalTarget>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvTacticalTarget>::operator++
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@ABVCvTacticalUnit@@@Z ; std::_Temp_iterator<CvTacticalUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@ABVCvTacticalUnit@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@ABVCvTacticalUnit@@@Z PROC ; std::_Temp_iterator<CvTacticalUnit>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN2@operator@2

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], esi
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 24			; 00000018H
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@2:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	mov	edx, ecx
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN7@operator@2
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], esi
	mov	esi, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], esi
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], edx
$LN7@operator@2:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 24			; 00000018H
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@ABVCvTacticalUnit@@@Z ENDP ; std::_Temp_iterator<CvTacticalUnit>::operator=
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvTacticalUnit>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvTacticalUnit>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvTacticalUnit>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvTacticalUnit>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvTacticalUnit>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvTacticalUnit>::operator++
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@ABVCvTacticalCity@@@Z ; std::_Temp_iterator<CvTacticalCity>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@ABVCvTacticalCity@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@ABVCvTacticalCity@@@Z PROC ; std::_Temp_iterator<CvTacticalCity>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	jae	SHORT $LN2@operator@3
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 12			; 0000000cH
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@3:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	test	ecx, ecx
	je	SHORT $LN7@operator@3
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
$LN7@operator@3:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 12			; 0000000cH
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@ABVCvTacticalCity@@@Z ENDP ; std::_Temp_iterator<CvTacticalCity>::operator=
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvTacticalCity>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvTacticalCity>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvTacticalCity>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvTacticalCity>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvTacticalCity>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvTacticalCity>::operator++
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvBlockingUnit>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvBlockingUnit>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvBlockingUnit>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvBlockingUnit>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvBlockingUnit>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvBlockingUnit>::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalMove@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalMove@@0@Z ; std::_Iter_random<CvTacticalMove *,CvTacticalMove *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvTacticalMove@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalMove@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvTacticalMove@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalMove@@0@Z PROC ; std::_Iter_random<CvTacticalMove *,CvTacticalMove *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvTacticalMove@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalMove@@0@Z ENDP ; std::_Iter_random<CvTacticalMove *,CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvTacticalMove@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalMove@@0@Z ; std::_Ptr_cat<CvTacticalMove *,CvTacticalMove *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvTacticalMove@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalMove@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvTacticalMove@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalMove@@0@Z PROC ; std::_Ptr_cat<CvTacticalMove *,CvTacticalMove *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvTacticalMove@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalMove@@0@Z ENDP ; std::_Ptr_cat<CvTacticalMove *,CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvTacticalMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvTacticalMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvTacticalMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@5
	push	esi
$LL2@Copy_backw@5:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@5
	pop	esi
$LN1@Copy_backw@5:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvTacticalMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvTacticalMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvTacticalMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvTacticalMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@5
	push	esi
$LL3@Copy_opt@5:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@5
	pop	esi
$LN1@Copy_opt@5:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvTacticalMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalTarget@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalTarget@@0@Z ; std::_Iter_random<CvTacticalTarget *,CvTacticalTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvTacticalTarget@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalTarget@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvTacticalTarget@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalTarget@@0@Z PROC ; std::_Iter_random<CvTacticalTarget *,CvTacticalTarget *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvTacticalTarget@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalTarget@@0@Z ENDP ; std::_Iter_random<CvTacticalTarget *,CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvTacticalTarget@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalTarget@@0@Z ; std::_Ptr_cat<CvTacticalTarget *,CvTacticalTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvTacticalTarget@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalTarget@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvTacticalTarget@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalTarget@@0@Z PROC ; std::_Ptr_cat<CvTacticalTarget *,CvTacticalTarget *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvTacticalTarget@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalTarget@@0@Z ENDP ; std::_Ptr_cat<CvTacticalTarget *,CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvTacticalTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvTacticalTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvTacticalTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First$[esp]
	cmp	ebx, edx
	je	SHORT $LN1@Copy_backw@6
	push	esi
	push	edi
$LL2@Copy_backw@6:

; 2676 : 		*--_Dest = *--_Last;

	sub	edx, 28					; 0000001cH
	sub	eax, 28					; 0000001cH
	mov	ecx, 7
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL2@Copy_backw@6
	pop	edi
	pop	esi
$LN1@Copy_backw@6:
	pop	ebx

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvTacticalTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvTacticalTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvTacticalTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvTacticalTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN1@Copy_opt@6
	push	esi
	push	edi
$LL3@Copy_opt@6:

; 2472 : 		*_Dest = *_First;

	mov	esi, edx
	mov	edi, eax
	add	edx, 28					; 0000001cH
	mov	ecx, 7
	add	eax, 28					; 0000001cH
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL3@Copy_opt@6
	pop	edi
	pop	esi
$LN1@Copy_opt@6:
	pop	ebx

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvTacticalTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z ; std::_Iter_random<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z PROC ; std::_Iter_random<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z ENDP ; std::_Iter_random<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalUnit@@AAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z ; std::_Ptr_cat<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalUnit@@AAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalUnit@@AAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z PROC ; std::_Ptr_cat<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalUnit@@AAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z ENDP ; std::_Ptr_cat<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z ; std::_Iter_random<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z PROC ; std::_Iter_random<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z ENDP ; std::_Iter_random<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalCity@@AAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z ; std::_Ptr_cat<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalCity@@AAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalCity@@AAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z PROC ; std::_Ptr_cat<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalCity@@AAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z ENDP ; std::_Ptr_cat<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvBlockingUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvBlockingUnit@@0@Z ; std::_Iter_random<CvBlockingUnit *,CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvBlockingUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvBlockingUnit@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvBlockingUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvBlockingUnit@@0@Z PROC ; std::_Iter_random<CvBlockingUnit *,CvBlockingUnit *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvBlockingUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvBlockingUnit@@0@Z ENDP ; std::_Iter_random<CvBlockingUnit *,CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvBlockingUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvBlockingUnit@@0@Z ; std::_Ptr_cat<CvBlockingUnit *,CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvBlockingUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvBlockingUnit@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvBlockingUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvBlockingUnit@@0@Z PROC ; std::_Ptr_cat<CvBlockingUnit *,CvBlockingUnit *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvBlockingUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvBlockingUnit@@0@Z ENDP ; std::_Ptr_cat<CvBlockingUnit *,CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvBlockingUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvBlockingUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvBlockingUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@7
	push	esi
$LL2@Copy_backw@7:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@7
	pop	esi
$LN1@Copy_backw@7:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvBlockingUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvBlockingUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvBlockingUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvBlockingUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@7
	push	esi
$LL3@Copy_opt@7:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@7
	pop	esi
$LN1@Copy_opt@7:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvBlockingUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvTacticalMove@@V1@@std@@YAXPAVCvTacticalMove@@ABV1@@Z ; std::_Construct<CvTacticalMove,CvTacticalMove>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@VCvTacticalMove@@V1@@std@@YAXPAVCvTacticalMove@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvTacticalMove@@V1@@std@@YAXPAVCvTacticalMove@@ABV1@@Z PROC ; std::_Construct<CvTacticalMove,CvTacticalMove>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@6
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@6:

; 53   : 	}

	ret	0
??$_Construct@VCvTacticalMove@@V1@@std@@YAXPAVCvTacticalMove@@ABV1@@Z ENDP ; std::_Construct<CvTacticalMove,CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvTacticalTarget@@V1@@std@@YAXPAVCvTacticalTarget@@ABV1@@Z ; std::_Construct<CvTacticalTarget,CvTacticalTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@VCvTacticalTarget@@V1@@std@@YAXPAVCvTacticalTarget@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvTacticalTarget@@V1@@std@@YAXPAVCvTacticalTarget@@ABV1@@Z PROC ; std::_Construct<CvTacticalTarget,CvTacticalTarget>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	edi

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	edi, DWORD PTR __Ptr$[esp]
	test	edi, edi
	je	SHORT $LN3@Construct@7
	push	esi
	mov	esi, DWORD PTR __Val$[esp+4]
	mov	ecx, 7
	rep movsd
	pop	esi
$LN3@Construct@7:
	pop	edi

; 53   : 	}

	ret	0
??$_Construct@VCvTacticalTarget@@V1@@std@@YAXPAVCvTacticalTarget@@ABV1@@Z ENDP ; std::_Construct<CvTacticalTarget,CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvBlockingUnit@@V1@@std@@YAXPAVCvBlockingUnit@@ABV1@@Z ; std::_Construct<CvBlockingUnit,CvBlockingUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@VCvBlockingUnit@@V1@@std@@YAXPAVCvBlockingUnit@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvBlockingUnit@@V1@@std@@YAXPAVCvBlockingUnit@@ABV1@@Z PROC ; std::_Construct<CvBlockingUnit,CvBlockingUnit>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@8
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN3@Construct@8:

; 53   : 	}

	ret	0
??$_Construct@VCvBlockingUnit@@V1@@std@@YAXPAVCvBlockingUnit@@ABV1@@Z ENDP ; std::_Construct<CvBlockingUnit,CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalMove@@0ABV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Iter_random<CvTacticalMove *,CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalMove@@0ABV?$_Temp_iterator@VCvTacticalMove@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalMove@@0ABV?$_Temp_iterator@VCvTacticalMove@@@0@@Z PROC ; std::_Iter_random<CvTacticalMove *,CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalMove@@0ABV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ENDP ; std::_Iter_random<CvTacticalMove *,CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00PAH0@Z ; std::_Rotate<CvTacticalMove *,int,CvTacticalMove>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00PAH0@Z
_TEXT	SEGMENT
__Holeval$236014 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00PAH0@Z PROC ; std::_Rotate<CvTacticalMove *,int,CvTacticalMove>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	sub	esp, 8
	push	ebx

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	ebx, DWORD PTR __Mid$[esp+8]
	push	ebp

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ebp, DWORD PTR __Last$[esp+12]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+20]
	sub	ebx, edi
	mov	ecx, ebp
	sub	ecx, edi
	sar	ebx, 3
	sar	ecx, 3
	mov	eax, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate
$LL8@Rotate:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, esi
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate
$LN7@Rotate:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	eax, ecx
	jge	SHORT $LN3@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	test	eax, eax
	jle	SHORT $LN3@Rotate
	lea	edi, DWORD PTR [edi+eax*8]
	npad	3
$LL5@Rotate:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR __Holeval$236014[esp+24], ecx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	lea	ecx, DWORD PTR [edi+ebx*8]
	mov	esi, edi
	mov	DWORD PTR __Holeval$236014[esp+28], edx
	cmp	ecx, ebp
	jne	SHORT $LN11@Rotate
	mov	ecx, DWORD PTR __First$[esp+20]
$LN11@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, edi
	je	SHORT $LN1@Rotate
	npad	2
$LL2@Rotate:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [esi], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], edx

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, ebp
	sub	edx, ecx
	sar	edx, 3
	cmp	ebx, edx
	mov	esi, ecx
	jge	SHORT $LN13@Rotate
	lea	edx, DWORD PTR [ebx*8]
	add	ecx, edx
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	ecx, ebx
	sub	ecx, edx
	mov	edx, DWORD PTR __First$[esp+20]
	lea	ecx, DWORD PTR [edx+ecx*8]
$LN14@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, edi
	jne	SHORT $LL2@Rotate
$LN1@Rotate:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	ecx, DWORD PTR __Holeval$236014[esp+24]
	mov	edx, DWORD PTR __Holeval$236014[esp+28]
	dec	eax
	sub	edi, 8
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], edx
	test	eax, eax
	jg	SHORT $LL5@Rotate
$LN3@Rotate:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 8
	ret	0
??$_Rotate@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00PAH0@Z ENDP ; std::_Rotate<CvTacticalMove *,int,CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalTarget@@0ABV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Iter_random<CvTacticalTarget *,CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalTarget@@0ABV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalTarget@@0ABV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z PROC ; std::_Iter_random<CvTacticalTarget *,CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalTarget@@0ABV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ENDP ; std::_Iter_random<CvTacticalTarget *,CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00PAH0@Z ; std::_Rotate<CvTacticalTarget *,int,CvTacticalTarget>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00PAH0@Z
_TEXT	SEGMENT
tv257 = -40						; size = 4
tv172 = -36						; size = 4
__Next$236052 = -32					; size = 4
__Holeval$236053 = -28					; size = 28
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00PAH0@Z PROC ; std::_Rotate<CvTacticalTarget *,int,CvTacticalTarget>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	sub	esp, 40					; 00000028H

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	ecx, DWORD PTR __Mid$[esp+36]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+48]
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+48]
	sar	edx, 4
	mov	ebp, edx
	sub	ecx, edi
	shr	ebp, 31					; 0000001fH
	add	ebp, edx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	eax, ecx
	mov	DWORD PTR __Count$[esp+48], eax

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebp
	test	ebp, ebp
	je	SHORT $LN7@Rotate@2
$LL21@Rotate@2:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	DWORD PTR __Count$[esp+48], esi
	mov	eax, DWORD PTR __Count$[esp+48]
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL21@Rotate@2
$LN7@Rotate@2:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	eax, ecx
	jge	$LN3@Rotate@2

; 1692 : 		for (; 0 < _Count; --_Count)

	test	eax, eax
	jle	$LN3@Rotate@2
	push	ebx
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR tv172[esp+56], ebx
	mov	DWORD PTR tv257[esp+56], edx
	jmp	SHORT $LN5@Rotate@2
	npad	3
$LL22@Rotate@2:
	mov	ebx, DWORD PTR tv172[esp+56]
$LN5@Rotate@2:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;
; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	add	ebx, edx
	mov	ecx, 7
	mov	esi, edx
	lea	edi, DWORD PTR __Holeval$236053[esp+56]
	mov	eax, edx
	rep movsd
	cmp	ebx, DWORD PTR __Last$[esp+52]
	jne	SHORT $LN11@Rotate@2
	mov	ebx, DWORD PTR __First$[esp+52]
$LN11@Rotate@2:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ebx, edx
	je	SHORT $LN1@Rotate@2
$LL2@Rotate@2:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edi, eax
	mov	ecx, 7
	mov	esi, ebx
	rep movsd

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	ecx, DWORD PTR __Last$[esp+52]
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	mov	DWORD PTR __Next$236052[esp+56], ebx
	jge	SHORT $LN13@Rotate@2
	add	ebx, DWORD PTR tv172[esp+56]
	jmp	SHORT $LN14@Rotate@2
$LN13@Rotate@2:
	mov	ecx, ebp
	sub	ecx, eax
	mov	eax, DWORD PTR __First$[esp+52]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	lea	ebx, DWORD PTR [eax+edx*4]
$LN14@Rotate@2:
	mov	eax, DWORD PTR __Next$236052[esp+56]
	cmp	ebx, DWORD PTR tv257[esp+56]
	jne	SHORT $LL2@Rotate@2

; 1698 : 			while (_Next1 != _Hole)

	mov	edx, DWORD PTR tv257[esp+56]
$LN1@Rotate@2:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	edi, eax
	mov	eax, DWORD PTR __Count$[esp+52]
	dec	eax
	sub	edx, 28					; 0000001cH
	mov	ecx, 7
	lea	esi, DWORD PTR __Holeval$236053[esp+56]
	rep movsd
	mov	DWORD PTR __Count$[esp+52], eax
	mov	DWORD PTR tv257[esp+56], edx
	test	eax, eax
	jg	$LL22@Rotate@2
	pop	ebx
$LN3@Rotate@2:
	pop	edi
	pop	esi
	pop	ebp

; 1706 : 			}
; 1707 : 	}

	add	esp, 40					; 00000028H
	ret	0
??$_Rotate@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00PAH0@Z ENDP ; std::_Rotate<CvTacticalTarget *,int,CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0ABV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0ABV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0ABV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0ABV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAVCvTacticalUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@@Z ; std::_Iter_cat<CvTacticalUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAVCvTacticalUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVCvTacticalUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@@Z PROC ; std::_Iter_cat<CvTacticalUnit *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAVCvTacticalUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@@Z ENDP ; std::_Iter_cat<CvTacticalUnit *>
_TEXT	ENDS
PUBLIC	??$_Advance@PAVCvTacticalUnit@@H@std@@YAXAAPAVCvTacticalUnit@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CvTacticalUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Advance@PAVCvTacticalUnit@@H@std@@YAXAAPAVCvTacticalUnit@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAVCvTacticalUnit@@H@std@@YAXAAPAVCvTacticalUnit@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CvTacticalUnit *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAVCvTacticalUnit@@H@std@@YAXAAPAVCvTacticalUnit@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CvTacticalUnit *,int>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@0ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z ; std::_Iter_random<CvTacticalUnit *,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@0ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@0ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z PROC ; std::_Iter_random<CvTacticalUnit *,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalUnit@@0ABV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@@Z ENDP ; std::_Iter_random<CvTacticalUnit *,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0ABV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0ABV?$_Temp_iterator@VCvTacticalCity@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0ABV?$_Temp_iterator@VCvTacticalCity@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0ABV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAVCvTacticalCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@@Z ; std::_Iter_cat<CvTacticalCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAVCvTacticalCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVCvTacticalCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@@Z PROC ; std::_Iter_cat<CvTacticalCity *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAVCvTacticalCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@@Z ENDP ; std::_Iter_cat<CvTacticalCity *>
_TEXT	ENDS
PUBLIC	??$_Advance@PAVCvTacticalCity@@H@std@@YAXAAPAVCvTacticalCity@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CvTacticalCity *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Advance@PAVCvTacticalCity@@H@std@@YAXAAPAVCvTacticalCity@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAVCvTacticalCity@@H@std@@YAXAAPAVCvTacticalCity@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CvTacticalCity *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAVCvTacticalCity@@H@std@@YAXAAPAVCvTacticalCity@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CvTacticalCity *,int>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@0ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z ; std::_Iter_random<CvTacticalCity *,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@0ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@0ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z PROC ; std::_Iter_random<CvTacticalCity *,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalCity@@0ABV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@@Z ENDP ; std::_Iter_random<CvTacticalCity *,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvBlockingUnit@@0ABV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Iter_random<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvBlockingUnit@@0ABV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvBlockingUnit@@0ABV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z PROC ; std::_Iter_random<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvBlockingUnit@@0ABV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ENDP ; std::_Iter_random<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00PAH0@Z ; std::_Rotate<CvBlockingUnit *,int,CvBlockingUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00PAH0@Z
_TEXT	SEGMENT
__Holeval$236230 = -16					; size = 16
__First$ = 8						; size = 4
tv172 = 12						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00PAH0@Z PROC ; std::_Rotate<CvBlockingUnit *,int,CvBlockingUnit>, COMDAT

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;
; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, DWORD PTR __Mid$[esp+16]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+24]
	sub	ebx, edi
	sub	ecx, edi
	sar	ebx, 4
	sar	ecx, 4
	mov	eax, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate@3
$LL8@Rotate@3:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, esi
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate@3
$LN7@Rotate@3:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	eax, ecx
	jge	$LN3@Rotate@3

; 1692 : 		for (; 0 < _Count; --_Count)

	test	eax, eax
	jle	$LN3@Rotate@3
	mov	ecx, ebx
	mov	esi, eax
	shl	ecx, 4
	shl	esi, 4
	push	ebp
	mov	DWORD PTR tv172[esp+28], ecx
	add	esi, edi
	jmp	SHORT $LN5@Rotate@3
$LL21@Rotate@3:
	mov	ecx, DWORD PTR tv172[esp+28]
$LN5@Rotate@3:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	edi, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi]
	mov	DWORD PTR __Holeval$236230[esp+36], edi
	mov	edi, DWORD PTR [esi+8]
	mov	DWORD PTR __Holeval$236230[esp+40], edi
	mov	edi, DWORD PTR [esi+12]

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	add	ecx, esi
	mov	edx, esi
	mov	DWORD PTR __Holeval$236230[esp+44], edi
	cmp	ecx, DWORD PTR __Last$[esp+28]
	jne	SHORT $LN11@Rotate@3
	mov	ecx, DWORD PTR __First$[esp+28]
$LN11@Rotate@3:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, esi
	je	SHORT $LN1@Rotate@3
	npad	1
$LL2@Rotate@3:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], edi
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], edi
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], edi

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edi, DWORD PTR __Last$[esp+28]
	sub	edi, ecx
	sar	edi, 4
	cmp	ebx, edi
	mov	edx, ecx
	jge	SHORT $LN13@Rotate@3
	add	ecx, DWORD PTR tv172[esp+28]
	jmp	SHORT $LN14@Rotate@3
$LN13@Rotate@3:
	mov	ecx, ebx
	sub	ecx, edi
	shl	ecx, 4
	add	ecx, DWORD PTR __First$[esp+28]
$LN14@Rotate@3:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, esi
	jne	SHORT $LL2@Rotate@3
$LN1@Rotate@3:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	ecx, DWORD PTR __Holeval$236230[esp+36]
	mov	DWORD PTR [edx], ebp
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR __Holeval$236230[esp+40]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR __Holeval$236230[esp+44]
	dec	eax
	sub	esi, 16					; 00000010H
	mov	DWORD PTR [edx+12], ecx
	test	eax, eax
	jg	$LL21@Rotate@3
	pop	ebp
$LN3@Rotate@3:
	pop	edi
	pop	esi
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Rotate@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00PAH0@Z ENDP ; std::_Rotate<CvBlockingUnit *,int,CvBlockingUnit>
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvArmyFormationSlot@@$00@@QAEAAVCvArmyFormationSlot@@I@Z ; BaseVector<CvArmyFormationSlot,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@VCvArmyFormationSlot@@$00@@QAEAAVCvArmyFormationSlot@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvArmyFormationSlot@@$00@@QAEAAVCvArmyFormationSlot@@I@Z PROC ; BaseVector<CvArmyFormationSlot,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvArmyFormationSlot@@$00@@QAEAAVCvArmyFormationSlot@@I@Z ENDP ; BaseVector<CvArmyFormationSlot,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvTacticalDominanceZone@@$00@@QBEIXZ ; BaseVector<CvTacticalDominanceZone,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvTacticalDominanceZone@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvTacticalDominanceZone@@$00@@QBEIXZ PROC ; BaseVector<CvTacticalDominanceZone,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvTacticalDominanceZone@@$00@@QBEIXZ ENDP ; BaseVector<CvTacticalDominanceZone,1>::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T240065 = -80						; size = 28
$T240064 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T240065[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T240064[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T240065[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T240064[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T240064[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T240064[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T240064[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@5:
$LN12@Xlen@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T240065[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T240064[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ	; FAutoVariable<bool,CvUnit>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ PROC		; FAutoVariable<bool,CvUnit>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ ENDP		; FAutoVariable<bool,CvUnit>::operator bool const &
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T240133 = -12						; size = 12
$T240137 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@7

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@7:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T240137[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T240133[esp+16]
	mov	DWORD PTR $T240137[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T240133[esp+16]
	push	ecx
	mov	DWORD PTR $T240133[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@7:
$LN8@Allocate@7:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@4
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@4:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@4:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@4
	pop	esi
$LN1@Fill@4:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@8

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@8:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n@2:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@2
	pop	esi
$LN1@Fill_n@2:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop@2:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvTacticalMoveXMLEntry@@6B@			; CvTacticalMoveXMLEntry::`vftable'
PUBLIC	??1CvTacticalMoveXMLEntry@@UAE@XZ		; CvTacticalMoveXMLEntry::~CvTacticalMoveXMLEntry
PUBLIC	??_R4CvTacticalMoveXMLEntry@@6B@		; CvTacticalMoveXMLEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvTacticalMoveXMLEntry@@@8		; CvTacticalMoveXMLEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvTacticalMoveXMLEntry@@8			; CvTacticalMoveXMLEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvTacticalMoveXMLEntry@@8			; CvTacticalMoveXMLEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvTacticalMoveXMLEntry@@8		; CvTacticalMoveXMLEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
EXTRN	??_ECvTacticalMoveXMLEntry@@UAEPAXI@Z:PROC	; CvTacticalMoveXMLEntry::`vector deleting destructor'
;	COMDAT ??_R2CvBaseInfo@@8
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvTacticalMoveXMLEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvTacticalMoveXMLEntry@@8 DD FLAT:??_R0?AVCvTacticalMoveXMLEntry@@@8 ; CvTacticalMoveXMLEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvTacticalMoveXMLEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvTacticalMoveXMLEntry@@8
rdata$r	SEGMENT
??_R2CvTacticalMoveXMLEntry@@8 DD FLAT:??_R1A@?0A@EA@CvTacticalMoveXMLEntry@@8 ; CvTacticalMoveXMLEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvTacticalMoveXMLEntry@@8
rdata$r	SEGMENT
??_R3CvTacticalMoveXMLEntry@@8 DD 00H			; CvTacticalMoveXMLEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvTacticalMoveXMLEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvTacticalMoveXMLEntry@@@8
_DATA	SEGMENT
??_R0?AVCvTacticalMoveXMLEntry@@@8 DD FLAT:??_7type_info@@6B@ ; CvTacticalMoveXMLEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvTacticalMoveXMLEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvTacticalMoveXMLEntry@@6B@
rdata$r	SEGMENT
??_R4CvTacticalMoveXMLEntry@@6B@ DD 00H			; CvTacticalMoveXMLEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvTacticalMoveXMLEntry@@@8
	DD	FLAT:??_R3CvTacticalMoveXMLEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvTacticalMoveXMLEntry@@6B@
CONST	SEGMENT
??_7CvTacticalMoveXMLEntry@@6B@ DD FLAT:??_R4CvTacticalMoveXMLEntry@@6B@ ; CvTacticalMoveXMLEntry::`vftable'
	DD	FLAT:?CacheResults@CvTacticalMoveXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvTacticalMoveXMLEntry@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??1CvTacticalMoveXMLEntry@@UAE@XZ
_TEXT	SEGMENT
??1CvTacticalMoveXMLEntry@@UAE@XZ PROC			; CvTacticalMoveXMLEntry::~CvTacticalMoveXMLEntry, COMDAT
; _this$ = ecx

; 51   : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvTacticalMoveXMLEntry@@6B@

; 52   : }

	jmp	??1CvBaseInfo@@QAE@XZ
??1CvTacticalMoveXMLEntry@@UAE@XZ ENDP			; CvTacticalMoveXMLEntry::~CvTacticalMoveXMLEntry
_TEXT	ENDS
PUBLIC	?GetNumTacticalMoves@CvTacticalMoveXMLEntries@@QAEHXZ ; CvTacticalMoveXMLEntries::GetNumTacticalMoves
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTacticalMoves@CvTacticalMoveXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumTacticalMoves@CvTacticalMoveXMLEntries@@QAEHXZ PROC ; CvTacticalMoveXMLEntries::GetNumTacticalMoves, COMDAT
; _this$ = ecx

; 97   : 	return m_paTacticalMoveEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 98   : }

	ret	0
?GetNumTacticalMoves@CvTacticalMoveXMLEntries@@QAEHXZ ENDP ; CvTacticalMoveXMLEntries::GetNumTacticalMoves
_TEXT	ENDS
PUBLIC	?GetEntry@CvTacticalMoveXMLEntries@@QAEPAVCvTacticalMoveXMLEntry@@H@Z ; CvTacticalMoveXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvTacticalMoveXMLEntries@@QAEPAVCvTacticalMoveXMLEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvTacticalMoveXMLEntries@@QAEPAVCvTacticalMoveXMLEntry@@H@Z PROC ; CvTacticalMoveXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 103  : 	return m_paTacticalMoveEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 104  : }

	ret	4
?GetEntry@CvTacticalMoveXMLEntries@@QAEPAVCvTacticalMoveXMLEntry@@H@Z ENDP ; CvTacticalMoveXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	?IsTargetValidInThisDomain@CvTacticalTarget@@QAE_NW4DomainTypes@@@Z ; CvTacticalTarget::IsTargetValidInThisDomain
; Function compile flags: /Ogtpy
;	COMDAT ?IsTargetValidInThisDomain@CvTacticalTarget@@QAE_NW4DomainTypes@@@Z
_TEXT	SEGMENT
_eDomain$ = 8						; size = 4
?IsTargetValidInThisDomain@CvTacticalTarget@@QAE_NW4DomainTypes@@@Z PROC ; CvTacticalTarget::IsTargetValidInThisDomain, COMDAT
; _this$ = ecx

; 156  : 	bool bRtnValue = false;
; 157  : 
; 158  : 	switch(GetTargetType())

	mov	ecx, DWORD PTR [ecx]
	dec	ecx
	xor	al, al
	cmp	ecx, 23					; 00000017H
	ja	SHORT $LN4@IsTargetVa
	movzx	ecx, BYTE PTR $LN10@IsTargetVa[ecx]
	jmp	DWORD PTR $LN11@IsTargetVa[ecx*4]
$LN3@IsTargetVa:

; 159  : 	{
; 160  : 	case AI_TACTICAL_TARGET_DEFENSIVE_BASTION:
; 161  : 	case AI_TACTICAL_TARGET_BARBARIAN_CAMP:
; 162  : 	case AI_TACTICAL_TARGET_IMPROVEMENT:
; 163  : 	case AI_TACTICAL_TARGET_IMPROVEMENT_TO_DEFEND:
; 164  : 	case AI_TACTICAL_TARGET_ANCIENT_RUINS:
; 165  : 	case AI_TACTICAL_TARGET_TRADE_UNIT_LAND:
; 166  : 	case AI_TACTICAL_TARGET_TRADE_UNIT_LAND_PLOT:
; 167  : 	case AI_TACTICAL_TARGET_CITADEL:
; 168  : 	case AI_TACTICAL_TARGET_IMPROVEMENT_RESOURCE:
; 169  : 		bRtnValue = (eDomain == DOMAIN_LAND);

	cmp	DWORD PTR _eDomain$[esp-4], 2
	sete	al

; 191  : 		break;
; 192  : 	}
; 193  : 
; 194  : 	return bRtnValue;
; 195  : }

	ret	4
$LN2@IsTargetVa:

; 170  : 		break;
; 171  : 
; 172  : 	case AI_TACTICAL_TARGET_BLOCKADE_RESOURCE_POINT:
; 173  : 	case AI_TACTICAL_TARGET_BOMBARDMENT_ZONE:
; 174  : 	case AI_TACTICAL_TARGET_EMBARKED_CIVILIAN:
; 175  : 	case AI_TACTICAL_TARGET_EMBARKED_MILITARY_UNIT:
; 176  : 	case AI_TACTICAL_TARGET_TRADE_UNIT_SEA:
; 177  : 	case AI_TACTICAL_TARGET_TRADE_UNIT_SEA_PLOT:
; 178  : 		bRtnValue = (eDomain == DOMAIN_SEA);

	cmp	DWORD PTR _eDomain$[esp-4], 0
	sete	al

; 191  : 		break;
; 192  : 	}
; 193  : 
; 194  : 	return bRtnValue;
; 195  : }

	ret	4
$LN1@IsTargetVa:

; 179  : 		break;
; 180  : 
; 181  : 	case AI_TACTICAL_TARGET_CITY:
; 182  : 	case AI_TACTICAL_TARGET_CITY_TO_DEFEND:
; 183  : 	case AI_TACTICAL_TARGET_LOW_PRIORITY_CIVILIAN:
; 184  : 	case AI_TACTICAL_TARGET_MEDIUM_PRIORITY_CIVILIAN:
; 185  : 	case AI_TACTICAL_TARGET_HIGH_PRIORITY_CIVILIAN:
; 186  : 	case AI_TACTICAL_TARGET_VERY_HIGH_PRIORITY_CIVILIAN:
; 187  : 	case AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT:
; 188  : 	case AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT:
; 189  : 	case AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT:
; 190  : 		bRtnValue = true;

	mov	al, 1
$LN4@IsTargetVa:

; 191  : 		break;
; 192  : 	}
; 193  : 
; 194  : 	return bRtnValue;
; 195  : }

	ret	4
	npad	1
$LN11@IsTargetVa:
	DD	$LN1@IsTargetVa
	DD	$LN3@IsTargetVa
	DD	$LN2@IsTargetVa
$LN10@IsTargetVa:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	1
	DB	2
	DB	1
	DB	1
	DB	1
?IsTargetValidInThisDomain@CvTacticalTarget@@QAE_NW4DomainTypes@@@Z ENDP ; CvTacticalTarget::IsTargetValidInThisDomain
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvTemporaryZone@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvTemporaryZone@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T240486 = 8						; size = 4
$T240485 = 8						; size = 4
$T240484 = 8						; size = 4
$T240483 = 8						; size = 4
$T240482 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvTemporaryZone@@@Z PROC	; operator<<, COMDAT

; 198  : {

	push	ecx
	push	esi

; 199  : 	uint uiVersion = 1;
; 200  : 	saveTo << uiVersion;

	mov	esi, DWORD PTR _saveTo$[esp+4]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+16], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 201  : 
; 202  : 	saveTo << (int)readFrom.GetTargetType();

	mov	edi, DWORD PTR _readFrom$[esp+8]
	mov	ecx, DWORD PTR [edi+8]
	lea	edx, DWORD PTR $T240482[esp+8]
	mov	DWORD PTR $T240482[esp+8], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 203  : 	saveTo << readFrom.GetLastTurn();

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR $T240483[esp+8]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T240483[esp+12], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 204  : 	saveTo << readFrom.GetX();

	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR $T240484[esp+8]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T240484[esp+12], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 205  : 	saveTo << readFrom.GetY();

	mov	ecx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR $T240485[esp+8]
	mov	DWORD PTR $T240485[esp+8], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 206  : 	saveTo << (int)readFrom.IsNavalInvasion();

	movzx	eax, BYTE PTR [edi+16]
	lea	ecx, DWORD PTR $T240486[esp+8]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T240486[esp+12], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi

; 207  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 208  : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvTemporaryZone@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvTemporaryZone@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvTemporaryZone@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_iTemp$ = 8						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvTemporaryZone@@@Z PROC	; operator>>, COMDAT

; 211  : {

	push	ecx
	push	esi

; 212  : 	uint uiVersion;
; 213  : 	loadFrom >> uiVersion;

	mov	esi, DWORD PTR _loadFrom$[esp+4]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 214  : 
; 215  : 	int iTemp;
; 216  : 	loadFrom >> iTemp;

	lea	ecx, DWORD PTR _iTemp$[esp+8]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 217  : 	writeTo.SetTargetType((AITacticalTargetType)iTemp);

	mov	edx, DWORD PTR _iTemp$[esp+8]
	mov	edi, DWORD PTR _writeTo$[esp+8]

; 218  : 	loadFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[esp+8]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [edi+8], edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 219  : 	writeTo.SetLastTurn(iTemp);

	mov	ecx, DWORD PTR _iTemp$[esp+8]

; 220  : 	loadFrom >> iTemp;

	lea	edx, DWORD PTR _iTemp$[esp+8]
	mov	DWORD PTR [edi+12], ecx
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 221  : 	writeTo.SetX(iTemp);

	mov	eax, DWORD PTR _iTemp$[esp+8]

; 222  : 	loadFrom >> iTemp;

	lea	ecx, DWORD PTR _iTemp$[esp+8]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [edi], eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 223  : 	writeTo.SetY(iTemp);

	mov	edx, DWORD PTR _iTemp$[esp+8]

; 224  : 	loadFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[esp+8]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [edi+4], edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 225  : 	writeTo.SetNavalInvasion(iTemp != 0);

	cmp	DWORD PTR _iTemp$[esp+8], 0

; 226  : 	return loadFrom;

	mov	eax, esi
	setne	cl
	mov	BYTE PTR [edi+16], cl
	pop	edi
	pop	esi

; 227  : }

	pop	ecx
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvTemporaryZone@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	?Init@CvTacticalAI@@QAEXPAVCvPlayer@@@Z		; CvTacticalAI::Init
EXTRN	?getBarbarianSeaTargetRange@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getBarbarianSeaTargetRange
EXTRN	?getBarbarianLandTargetRange@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getBarbarianLandTargetRange
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ:PROC ; CvGame::GetTacticalAnalysisMap
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvTacticalAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?Init@CvTacticalAI@@QAEXPAVCvPlayer@@@Z PROC		; CvTacticalAI::Init, COMDAT
; _this$ = ecx

; 248  : 	// Store off the pointer to the objects we need elsewhere in the game engine
; 249  : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _pPlayer$[esp-4]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], eax

; 250  : 
; 251  : 	Reset();

	mov	DWORD PTR [esi+2132], -1
	mov	DWORD PTR [esi+4], 0

; 252  : 
; 253  : 	m_pMap = GC.getGame().GetTacticalAnalysisMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	DWORD PTR [esi+4], eax

; 254  : 
; 255  : 	// Initialize AI constants from XML
; 256  : 	m_iRecruitRange = GC.getAI_TACTICAL_RECRUIT_RANGE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2460
	mov	DWORD PTR [esi+24756], ecx

; 257  : 	m_iLandBarbarianRange = GC.getGame().getHandicapInfo().getBarbarianLandTargetRange();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?getBarbarianLandTargetRange@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getBarbarianLandTargetRange
	mov	DWORD PTR [esi+24760], eax

; 258  : 	m_iSeaBarbarianRange = GC.getGame().getHandicapInfo().getBarbarianSeaTargetRange();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?getBarbarianSeaTargetRange@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getBarbarianSeaTargetRange
	mov	DWORD PTR [esi+24764], eax

; 259  : 	m_iRepositionRange = GC.getAI_TACTICAL_REPOSITION_RANGE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2464
	mov	DWORD PTR [esi+24768], edx

; 260  : 	m_iDeployRadius = GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420
	mov	DWORD PTR [esi+24772], eax

; 261  : 	m_iRandomRange = GC.getAI_TACTICAL_MOVE_PRIORITY_RANDOMNESS();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2476
	mov	DWORD PTR [esi+24776], ecx

; 262  : 	m_fFlavorDampening = GC.getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8100

; 263  : 
; 264  : 	// cache TypeInfos rather than doing a hash map look up of the string every time it is being used
; 265  : 	m_CachedInfoTypes[eTACTICAL_UNASSIGNED] = GC.getInfoTypeForString("TACTICAL_UNASSIGNED");

	push	0
	fstp	QWORD PTR [esi+24784]
	push	OFFSET $SG220174
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 266  : 	m_CachedInfoTypes[eTACTICAL_POSTURE_SIT_AND_BOMBARD] = GC.getInfoTypeForString("TACTICAL_POSTURE_SIT_AND_BOMBARD");

	push	0
	push	OFFSET $SG220175
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29172], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 267  : 	m_CachedInfoTypes[eTACTICAL_POSTURE_ATTRIT_FROM_RANGE] = GC.getInfoTypeForString("TACTICAL_POSTURE_ATTRIT_FROM_RANGE");

	push	0
	push	OFFSET $SG220176
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29176], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 268  : 	m_CachedInfoTypes[eTACTICAL_POSTURE_EXPLOIT_FLANKS] = GC.getInfoTypeForString("TACTICAL_POSTURE_EXPLOIT_FLANKS");

	push	0
	push	OFFSET $SG220177
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29180], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 269  : 	m_CachedInfoTypes[eTACTICAL_POSTURE_STEAMROLL] = GC.getInfoTypeForString("TACTICAL_POSTURE_STEAMROLL");

	push	0
	push	OFFSET $SG220178
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29184], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 270  : 	m_CachedInfoTypes[eTACTICAL_POSTURE_SURGICAL_CITY_STRIKE] = GC.getInfoTypeForString("TACTICAL_POSTURE_SURGICAL_CITY_STRIKE");

	push	0
	push	OFFSET $SG220179
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29188], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 271  : 	m_CachedInfoTypes[eTACTICAL_POSTURE_COUNTERATTACK] = GC.getInfoTypeForString("TACTICAL_POSTURE_COUNTERATTACK");

	push	0
	push	OFFSET $SG220180
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29192], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 272  : 	m_CachedInfoTypes[eTACTICAL_MOVE_NONCOMBATANTS_TO_SAFETY] = GC.getInfoTypeForString("TACTICAL_MOVE_NONCOMBATANTS_TO_SAFETY");

	push	0
	push	OFFSET $SG220181
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29196], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 273  : 	m_CachedInfoTypes[eTACTICAL_CAPTURE_CITY] = GC.getInfoTypeForString("TACTICAL_CAPTURE_CITY");

	push	0
	push	OFFSET $SG220182
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29200], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 274  : 	m_CachedInfoTypes[eTACTICAL_DAMAGE_CITY] = GC.getInfoTypeForString("TACTICAL_DAMAGE_CITY");

	push	0
	push	OFFSET $SG220183
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29204], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 275  : 	m_CachedInfoTypes[eTACTICAL_DESTROY_HIGH_UNIT] = GC.getInfoTypeForString("TACTICAL_DESTROY_HIGH_UNIT");

	push	0
	mov	DWORD PTR [esi+29208], eax
	push	OFFSET $SG220184
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 276  : 	m_CachedInfoTypes[eTACTICAL_DESTROY_MEDIUM_UNIT] = GC.getInfoTypeForString("TACTICAL_DESTROY_MEDIUM_UNIT");

	push	0
	push	OFFSET $SG220185
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29212], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 277  : 	m_CachedInfoTypes[eTACTICAL_DESTROY_LOW_UNIT] = GC.getInfoTypeForString("TACTICAL_DESTROY_LOW_UNIT");

	push	0
	push	OFFSET $SG220186
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29216], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 278  : 	m_CachedInfoTypes[eTACTICAL_TO_SAFETY] = GC.getInfoTypeForString("TACTICAL_TO_SAFETY");

	push	0
	push	OFFSET $SG220187
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29220], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 279  : 	m_CachedInfoTypes[eTACTICAL_ATTRIT_HIGH_UNIT] = GC.getInfoTypeForString("TACTICAL_ATTRIT_HIGH_UNIT");

	push	0
	push	OFFSET $SG220188
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29224], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 280  : 	m_CachedInfoTypes[eTACTICAL_ATTRIT_MEDIUM_UNIT] = GC.getInfoTypeForString("TACTICAL_ATTRIT_MEDIUM_UNIT");

	push	0
	push	OFFSET $SG220189
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29228], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 281  : 	m_CachedInfoTypes[eTACTICAL_ATTRIT_LOW_UNIT] = GC.getInfoTypeForString("TACTICAL_ATTRIT_LOW_UNIT");

	push	0
	push	OFFSET $SG220190
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29232], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 282  : 	m_CachedInfoTypes[eTACTICAL_REPOSITION] = GC.getInfoTypeForString("TACTICAL_REPOSITION");

	push	0
	push	OFFSET $SG220191
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29236], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 283  : 	m_CachedInfoTypes[eTACTICAL_BARBARIAN_CAMP] = GC.getInfoTypeForString("TACTICAL_BARBARIAN_CAMP");

	push	0
	push	OFFSET $SG220192
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29240], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 284  : 	m_CachedInfoTypes[eTACTICAL_PILLAGE] = GC.getInfoTypeForString("TACTICAL_PILLAGE");

	push	0
	push	OFFSET $SG220193
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29244], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 285  : 	m_CachedInfoTypes[eTACTICAL_ATTACK_VERY_HIGH_PRIORITY_CIVILIAN] = GC.getInfoTypeForString("TACTICAL_ATTACK_VERY_HIGH_PRIORITY_CIVILIAN");

	push	0
	push	OFFSET $SG220194
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29248], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 286  : 	m_CachedInfoTypes[eTACTICAL_ATTACK_HIGH_PRIORITY_CIVILIAN] = GC.getInfoTypeForString("TACTICAL_ATTACK_HIGH_PRIORITY_CIVILIAN");

	push	0
	push	OFFSET $SG220195
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29252], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 287  : 	m_CachedInfoTypes[eTACTICAL_ATTACK_MEDIUM_PRIORITY_CIVILIAN] = GC.getInfoTypeForString("TACTICAL_ATTACK_MEDIUM_PRIORITY_CIVILIAN");

	push	0
	push	OFFSET $SG220196
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29256], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 288  : 	m_CachedInfoTypes[eTACTICAL_ATTACK_LOW_PRIORITY_CIVILIAN] = GC.getInfoTypeForString("TACTICAL_ATTACK_LOW_PRIORITY_CIVILIAN");

	push	0
	push	OFFSET $SG220197
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29260], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 289  : 	m_CachedInfoTypes[eTACTICAL_SAFE_BOMBARDS] = GC.getInfoTypeForString("TACTICAL_SAFE_BOMBARDS");

	push	0
	push	OFFSET $SG220198
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29264], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 290  : 	m_CachedInfoTypes[eTACTICAL_HEAL] = GC.getInfoTypeForString("TACTICAL_HEAL");

	push	0
	push	OFFSET $SG220199
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29268], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 291  : 	m_CachedInfoTypes[eTACTICAL_ANCIENT_RUINS] = GC.getInfoTypeForString("TACTICAL_ANCIENT_RUINS");

	push	0
	mov	DWORD PTR [esi+29272], eax
	push	OFFSET $SG220200
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 292  : 	m_CachedInfoTypes[eTACTICAL_GARRISON_TO_ALLOW_BOMBARD] = GC.getInfoTypeForString("TACTICAL_GARRISON_TO_ALLOW_BOMBARD");

	push	0
	push	OFFSET $SG220201
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29276], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 293  : 	m_CachedInfoTypes[eTACTICAL_GARRISON_ALREADY_THERE] = GC.getInfoTypeForString("TACTICAL_GARRISON_ALREADY_THERE");

	push	0
	push	OFFSET $SG220202
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29280], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 294  : 	m_CachedInfoTypes[eTACTICAL_BASTION_ALREADY_THERE] = GC.getInfoTypeForString("TACTICAL_BASTION_ALREADY_THERE");

	push	0
	push	OFFSET $SG220203
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29284], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 295  : 	m_CachedInfoTypes[eTACTICAL_GUARD_IMPROVEMENT_ALREADY_THERE] = GC.getInfoTypeForString("TACTICAL_GUARD_IMPROVEMENT_ALREADY_THERE");

	push	0
	push	OFFSET $SG220204
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29288], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 296  : 	m_CachedInfoTypes[eTACTICAL_GARRISON_1_TURN] = GC.getInfoTypeForString("TACTICAL_GARRISON_1_TURN");

	push	0
	push	OFFSET $SG220205
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29292], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 297  : 	m_CachedInfoTypes[eTACTICAL_BASTION_1_TURN] = GC.getInfoTypeForString("TACTICAL_BASTION_1_TURN");

	push	0
	push	OFFSET $SG220206
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29296], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 298  : 	m_CachedInfoTypes[eTACTICAL_GUARD_IMPROVEMENT_1_TURN] = GC.getInfoTypeForString("TACTICAL_GUARD_IMPROVEMENT_1_TURN");

	push	0
	push	OFFSET $SG220207
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29300], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 299  : 	m_CachedInfoTypes[eTACTICAL_AIR_INTERCEPT] = GC.getInfoTypeForString("TACTICAL_AIR_INTERCEPT");

	push	0
	push	OFFSET $SG220208
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29304], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 300  : 	m_CachedInfoTypes[eTACTICAL_AIR_SWEEP] = GC.getInfoTypeForString("TACTICAL_AIR_SWEEP");

	push	0
	push	OFFSET $SG220209
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29308], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 301  : 	m_CachedInfoTypes[eTACTICAL_POSTURE_HEDGEHOG] = GC.getInfoTypeForString("TACTICAL_POSTURE_HEDGEHOG");

	push	0
	push	OFFSET $SG220210
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29312], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 302  : 	m_CachedInfoTypes[eTACTICAL_POSTURE_WITHDRAW] = GC.getInfoTypeForString("TACTICAL_POSTURE_WITHDRAW");

	push	0
	push	OFFSET $SG220211
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29316], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 303  : 	m_CachedInfoTypes[eTACTICAL_POSTURE_SHORE_BOMBARDMENT] = GC.getInfoTypeForString("TACTICAL_POSTURE_SHORE_BOMBARDMENT");

	push	0
	push	OFFSET $SG220212
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29320], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 304  : 	m_CachedInfoTypes[eTACTICAL_CLOSE_ON_TARGET] = GC.getInfoTypeForString("TACTICAL_CLOSE_ON_TARGET");

	push	0
	push	OFFSET $SG220213
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29324], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 305  : 	m_CachedInfoTypes[eTACTICAL_MOVE_OPERATIONS] = GC.getInfoTypeForString("TACTICAL_MOVE_OPERATIONS");

	push	0
	push	OFFSET $SG220214
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29328], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 306  : 	m_CachedInfoTypes[eTACTICAL_EMERGENCY_PURCHASES] = GC.getInfoTypeForString("TACTICAL_EMERGENCY_PURCHASES");

	push	0
	push	OFFSET $SG220215
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29332], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 307  : 	m_CachedInfoTypes[eTACTICAL_ESCORT_EMBARKED_UNIT] = GC.getInfoTypeForString("TACTICAL_ESCORT_EMBARKED_UNIT");

	push	0
	push	OFFSET $SG220216
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29336], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 308  : 	m_CachedInfoTypes[eTACTICAL_PLUNDER_TRADE_UNIT] = GC.getInfoTypeForString("TACTICAL_PLUNDER_TRADE_UNIT");

	push	0
	push	OFFSET $SG220217
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29340], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 309  : 	m_CachedInfoTypes[eTACTICAL_PARK_ON_TRADE_ROUTE] = GC.getInfoTypeForString("TACTICAL_PARK_ON_TRADE_ROUTE");

	push	0
	push	OFFSET $SG220218
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29344], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 310  : 	m_CachedInfoTypes[eTACTICAL_DEFENSIVE_AIRLIFT] = GC.getInfoTypeForString("TACTICAL_DEFENSIVE_AIRLIFT");

	push	0
	push	OFFSET $SG220219
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29348], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 311  : 	m_CachedInfoTypes[eTACTICAL_PILLAGE_CITADEL] = GC.getInfoTypeForString("TACTICAL_PILLAGE_CITADEL");

	push	0
	push	OFFSET $SG220220
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29352], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 312  : 	m_CachedInfoTypes[eTACTICAL_PILLAGE_RESOURCE] = GC.getInfoTypeForString("TACTICAL_PILLAGE_RESOURCE");

	push	0
	push	OFFSET $SG220221
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29356], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 313  : 	m_CachedInfoTypes[eTACTICAL_PILLAGE_CITADEL_NEXT_TURN] = GC.getInfoTypeForString("TACTICAL_PILLAGE_CITADEL_NEXT_TURN");

	push	0
	push	OFFSET $SG220222
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29360], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 314  : 	m_CachedInfoTypes[eTACTICAL_PILLAGE_RESOURCE_NEXT_TURN] = GC.getInfoTypeForString("TACTICAL_PILLAGE_RESOURCE_NEXT_TURN");

	push	0
	push	OFFSET $SG220223
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29364], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 315  : 	m_CachedInfoTypes[eTACTICAL_PILLAGE_NEXT_TURN] = GC.getInfoTypeForString("TACTICAL_PILLAGE_NEXT_TURN");

	push	0
	push	OFFSET $SG220224
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29368], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 316  : 	m_CachedInfoTypes[eMUPOSITION_CIVILIAN_SUPPORT] = GC.getInfoTypeForString("MUPOSITION_CIVILIAN_SUPPORT");

	push	0
	push	OFFSET $SG220225
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29372], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 317  : 	m_CachedInfoTypes[eMUPOSITION_NAVAL_ESCORT] = GC.getInfoTypeForString("MUPOSITION_NAVAL_ESCORT");

	push	0
	push	OFFSET $SG220226
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29376], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 318  : 	m_CachedInfoTypes[eMUPOSITION_BOMBARD] = GC.getInfoTypeForString("MUPOSITION_BOMBARD");

	push	0
	push	OFFSET $SG220227
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29380], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 319  : 	m_CachedInfoTypes[eMUPOSITION_FRONT_LINE] = GC.getInfoTypeForString("MUPOSITION_FRONT_LINE");

	push	0
	push	OFFSET $SG220228
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+29384], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+29388], eax
	pop	esi

; 320  : 
; 321  : }

	ret	4
?Init@CvTacticalAI@@QAEXPAVCvPlayer@@@Z ENDP		; CvTacticalAI::Init
_TEXT	ENDS
PUBLIC	?GetFirstTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ ; CvTacticalAI::GetFirstTemporaryZone
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ
_TEXT	SEGMENT
?GetFirstTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ PROC ; CvTacticalAI::GetFirstTemporaryZone, COMDAT
; _this$ = ecx

; 439  : 	CvTemporaryZone* pRtnValue = NULL;

	xor	eax, eax

; 440  : 
; 441  : 	m_iCurrentTempZoneIndex = 0;
; 442  : 	if((int)m_TempZones.size() > m_iCurrentTempZoneIndex)

	cmp	DWORD PTR [ecx+26384], eax
	mov	DWORD PTR [ecx+26376], eax
	jle	SHORT $LN1@GetFirstTe

; 443  : 	{
; 444  : 		pRtnValue = &m_TempZones[m_iCurrentTempZoneIndex];
; 445  : 	}
; 446  : 
; 447  : 	return pRtnValue;

	mov	eax, DWORD PTR [ecx+26380]
$LN1@GetFirstTe:

; 448  : }

	ret	0
?GetFirstTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ ENDP ; CvTacticalAI::GetFirstTemporaryZone
_TEXT	ENDS
PUBLIC	?GetNextTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ ; CvTacticalAI::GetNextTemporaryZone
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ
_TEXT	SEGMENT
?GetNextTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ PROC ; CvTacticalAI::GetNextTemporaryZone, COMDAT
; _this$ = ecx

; 453  : 	CvTemporaryZone* pRtnValue = NULL;
; 454  : 
; 455  : 	m_iCurrentTempZoneIndex++;

	inc	DWORD PTR [ecx+26376]
	mov	edx, DWORD PTR [ecx+26376]
	xor	eax, eax

; 456  : 	if((int)m_TempZones.size() > m_iCurrentTempZoneIndex)

	cmp	DWORD PTR [ecx+26384], edx
	jle	SHORT $LN1@GetNextTem

; 457  : 	{
; 458  : 		pRtnValue = &m_TempZones[m_iCurrentTempZoneIndex];

	mov	ecx, DWORD PTR [ecx+26380]
	lea	eax, DWORD PTR [edx+edx*4]
	lea	eax, DWORD PTR [ecx+eax*4]
$LN1@GetNextTem:

; 459  : 	}
; 460  : 
; 461  : 	return pRtnValue;
; 462  : }

	ret	0
?GetNextTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ ENDP ; CvTacticalAI::GetNextTemporaryZone
_TEXT	ENDS
PUBLIC	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z PROC ; CvTacticalAI::GetFirstZoneTarget, COMDAT
; _this$ = ecx

; 6110 : 	m_eCurrentTargetType = eType;
; 6111 : 	m_iCurrentTargetIndex = 0;
; 6112 : 
; 6113 : 	while(m_iCurrentTargetIndex < (int)m_ZoneTargets.size())

	cmp	DWORD PTR [ecx+9340], 0
	mov	edx, DWORD PTR _eType$[esp-4]
	push	esi
	push	edi
	mov	DWORD PTR [ecx+24796], edx
	mov	DWORD PTR [ecx+24800], 0
	jle	SHORT $LN3@GetFirstZo
	npad	1
$LL4@GetFirstZo:

; 6114 : 	{
; 6115 : 		if(m_eCurrentTargetType == AI_TACTICAL_TARGET_NONE || m_ZoneTargets[m_iCurrentTargetIndex].GetTargetType() == m_eCurrentTargetType)

	test	edx, edx
	je	SHORT $LN16@GetFirstZo
	mov	eax, DWORD PTR [ecx+24800]
	mov	edi, DWORD PTR [ecx+9336]
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	cmp	DWORD PTR [edi+esi*4], edx
	je	SHORT $LN16@GetFirstZo

; 6118 : 		}
; 6119 : 		m_iCurrentTargetIndex++;

	inc	eax
	mov	DWORD PTR [ecx+24800], eax
	cmp	eax, DWORD PTR [ecx+9340]
	jl	SHORT $LL4@GetFirstZo
$LN3@GetFirstZo:
	pop	edi

; 6120 : 	}
; 6121 : 
; 6122 : 	return NULL;

	xor	eax, eax
	pop	esi

; 6123 : }

	ret	4
$LN16@GetFirstZo:

; 6116 : 		{
; 6117 : 			return &m_ZoneTargets[m_iCurrentTargetIndex];

	mov	eax, DWORD PTR [ecx+24800]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+9336]
	pop	edi
	lea	eax, DWORD PTR [eax+edx*4]
	pop	esi

; 6123 : }

	ret	4
?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ENDP ; CvTacticalAI::GetFirstZoneTarget
_TEXT	ENDS
PUBLIC	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ
_TEXT	SEGMENT
?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ PROC ; CvTacticalAI::GetNextZoneTarget, COMDAT
; _this$ = ecx

; 6128 : 	m_iCurrentTargetIndex++;

	inc	DWORD PTR [ecx+24800]
	mov	eax, DWORD PTR [ecx+24800]

; 6129 : 
; 6130 : 	while(m_iCurrentTargetIndex < (int)m_ZoneTargets.size())

	cmp	eax, DWORD PTR [ecx+9340]
	push	esi
	push	edi
	jge	SHORT $LN3@GetNextZon
	mov	edx, DWORD PTR [ecx+24796]
	npad	4
$LL4@GetNextZon:

; 6131 : 	{
; 6132 : 		if(m_eCurrentTargetType == AI_TACTICAL_TARGET_NONE || m_ZoneTargets[m_iCurrentTargetIndex].GetTargetType() == m_eCurrentTargetType)

	test	edx, edx
	je	SHORT $LN16@GetNextZon
	mov	edi, DWORD PTR [ecx+9336]
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	cmp	DWORD PTR [edi+esi*4], edx
	je	SHORT $LN16@GetNextZon

; 6135 : 		}
; 6136 : 		m_iCurrentTargetIndex++;

	inc	eax
	mov	esi, eax
	mov	DWORD PTR [ecx+24800], eax
	cmp	esi, DWORD PTR [ecx+9340]
	jl	SHORT $LL4@GetNextZon
$LN3@GetNextZon:
	pop	edi

; 6137 : 	}
; 6138 : 
; 6139 : 	return NULL;

	xor	eax, eax
	pop	esi

; 6140 : }

	ret	0
$LN16@GetNextZon:

; 6133 : 		{
; 6134 : 			return &m_ZoneTargets[m_iCurrentTargetIndex];

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+9336]
	pop	edi
	lea	eax, DWORD PTR [eax+edx*4]
	pop	esi

; 6140 : }

	ret	0
?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ENDP ; CvTacticalAI::GetNextZoneTarget
_TEXT	ENDS
PUBLIC	?GetFirstUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetFirstUnitTarget
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ
_TEXT	SEGMENT
?GetFirstUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ PROC ; CvTacticalAI::GetFirstUnitTarget, COMDAT
; _this$ = ecx

; 6145 : 	m_iCurrentUnitTargetIndex = 0;
; 6146 : 
; 6147 : 	while(m_iCurrentUnitTargetIndex < (int)m_AllTargets.size())

	cmp	DWORD PTR [ecx+2156], 0
	push	esi
	mov	DWORD PTR [ecx+24804], 0
	jle	SHORT $LN3@GetFirstUn
	mov	esi, DWORD PTR [ecx+2152]
	npad	6
$LL4@GetFirstUn:

; 6148 : 	{
; 6149 : 		if(m_AllTargets[m_iCurrentUnitTargetIndex].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 6150 : 		        m_AllTargets[m_iCurrentUnitTargetIndex].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 6151 : 		        m_AllTargets[m_iCurrentUnitTargetIndex].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	mov	eax, DWORD PTR [ecx+24804]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	edx, DWORD PTR [esi+edx*4]
	cmp	edx, 7
	je	SHORT $LN24@GetFirstUn
	cmp	edx, 6
	je	SHORT $LN24@GetFirstUn
	cmp	edx, 5
	je	SHORT $LN24@GetFirstUn

; 6154 : 		}
; 6155 : 		m_iCurrentUnitTargetIndex++;

	inc	eax
	mov	DWORD PTR [ecx+24804], eax
	cmp	eax, DWORD PTR [ecx+2156]
	jl	SHORT $LL4@GetFirstUn
$LN3@GetFirstUn:

; 6156 : 	}
; 6157 : 
; 6158 : 	return NULL;

	xor	eax, eax
	pop	esi

; 6159 : }

	ret	0
$LN24@GetFirstUn:

; 6152 : 		{
; 6153 : 			return &m_AllTargets[m_iCurrentUnitTargetIndex];

	mov	ecx, eax
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	lea	eax, DWORD PTR [esi+edx*4]
	pop	esi

; 6159 : }

	ret	0
?GetFirstUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ENDP ; CvTacticalAI::GetFirstUnitTarget
_TEXT	ENDS
PUBLIC	?GetNextUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextUnitTarget
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ
_TEXT	SEGMENT
?GetNextUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ PROC ; CvTacticalAI::GetNextUnitTarget, COMDAT
; _this$ = ecx

; 6164 : 	m_iCurrentUnitTargetIndex++;

	inc	DWORD PTR [ecx+24804]
	mov	eax, DWORD PTR [ecx+24804]

; 6165 : 
; 6166 : 	while(m_iCurrentUnitTargetIndex < (int)m_AllTargets.size())

	cmp	eax, DWORD PTR [ecx+2156]
	push	esi
	jge	SHORT $LN3@GetNextUni
	mov	esi, DWORD PTR [ecx+2152]
	npad	5
$LL4@GetNextUni:

; 6167 : 	{
; 6168 : 		if(m_AllTargets[m_iCurrentUnitTargetIndex].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 6169 : 		        m_AllTargets[m_iCurrentUnitTargetIndex].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 6170 : 		        m_AllTargets[m_iCurrentUnitTargetIndex].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	edx, DWORD PTR [esi+edx*4]
	cmp	edx, 7
	je	SHORT $LN24@GetNextUni
	cmp	edx, 6
	je	SHORT $LN24@GetNextUni
	cmp	edx, 5
	je	SHORT $LN24@GetNextUni

; 6173 : 		}
; 6174 : 		m_iCurrentUnitTargetIndex++;

	inc	eax
	mov	edx, eax
	mov	DWORD PTR [ecx+24804], eax
	cmp	edx, DWORD PTR [ecx+2156]
	jl	SHORT $LL4@GetNextUni
$LN3@GetNextUni:

; 6175 : 	}
; 6176 : 
; 6177 : 	return NULL;

	xor	eax, eax
	pop	esi

; 6178 : }

	ret	0
$LN24@GetNextUni:

; 6171 : 		{
; 6172 : 			return &m_AllTargets[m_iCurrentUnitTargetIndex];

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]
	pop	esi

; 6178 : }

	ret	0
?GetNextUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ENDP ; CvTacticalAI::GetNextUnitTarget
_TEXT	ENDS
PUBLIC	?TurnOffMove@CvTacticalAI@@AAEXW4TacticalAIMoveTypes@@@Z ; CvTacticalAI::TurnOffMove
; Function compile flags: /Ogtpy
;	COMDAT ?TurnOffMove@CvTacticalAI@@AAEXW4TacticalAIMoveTypes@@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?TurnOffMove@CvTacticalAI@@AAEXW4TacticalAIMoveTypes@@@Z PROC ; CvTacticalAI::TurnOffMove, COMDAT
; _this$ = ecx

; 8712 : 	FStaticVector<CvTacticalMove, 256, true, c_eCiv5GameplayDLL >::iterator it;
; 8713 : 
; 8714 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 8715 : 	for (it = m_MovePriorityList.begin(); it != m_MovePriorityList.end(); ++it)
; 8716 : #else
; 8717 : 	for(it = m_MovePriorityList.begin(); it != m_MovePriorityList.end(); it++)

	mov	eax, DWORD PTR [ecx+68]
	mov	edx, DWORD PTR [ecx+72]
	push	esi
	mov	esi, eax
	lea	edx, DWORD PTR [esi+edx*8]
	pop	esi
	cmp	eax, edx
	je	SHORT $LN2@TurnOffMov
	mov	edx, DWORD PTR [ecx+72]

; 8718 : #endif
; 8719 : 	{
; 8720 : 		if(it->m_eMoveType == eType)

	mov	ecx, eax
	lea	ecx, DWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR _eType$[esp-4]
	npad	3
$LL4@TurnOffMov:
	cmp	DWORD PTR [eax], edx
	je	SHORT $LN12@TurnOffMov
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL4@TurnOffMov

; 8723 : 			return;
; 8724 : 		}
; 8725 : 	}
; 8726 : }

	ret	4
$LN12@TurnOffMov:

; 8721 : 		{
; 8722 : 			it->m_iPriority = -1;

	mov	DWORD PTR [eax+4], -1
$LN2@TurnOffMov:

; 8723 : 			return;
; 8724 : 		}
; 8725 : 	}
; 8726 : }

	ret	4
?TurnOffMove@CvTacticalAI@@AAEXW4TacticalAIMoveTypes@@@Z ENDP ; CvTacticalAI::TurnOffMove
_TEXT	ENDS
PUBLIC	?isEmbarked@CvUnit@@QBE_NXZ			; CvUnit::isEmbarked
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?isEmbarked@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?isEmbarked@CvUnit@@QBE_NXZ PROC			; CvUnit::isEmbarked, COMDAT
; _this$ = ecx

; 257  : 		return m_bEmbarked;

	mov	al, BYTE PTR [ecx+1652]

; 258  : 	}

	ret	0
?isEmbarked@CvUnit@@QBE_NXZ ENDP			; CvUnit::isEmbarked
_TEXT	ENDS
PUBLIC	?GetID@CvUnit@@QBEHXZ				; CvUnit::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvUnit@@QBEHXZ PROC				; CvUnit::GetID, COMDAT
; _this$ = ecx

; 662  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+100]

; 663  : 	}

	ret	0
?GetID@CvUnit@@QBEHXZ ENDP				; CvUnit::GetID
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?GetDeployFromOperationTurn@CvUnit@@QBEHXZ	; CvUnit::GetDeployFromOperationTurn
; Function compile flags: /Ogtpy
;	COMDAT ?GetDeployFromOperationTurn@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetDeployFromOperationTurn@CvUnit@@QBEHXZ PROC		; CvUnit::GetDeployFromOperationTurn, COMDAT
; _this$ = ecx

; 697  : 		return m_iDeployFromOperationTurn;

	mov	eax, DWORD PTR [ecx+124]

; 698  : 	};

	ret	0
?GetDeployFromOperationTurn@CvUnit@@QBEHXZ ENDP		; CvUnit::GetDeployFromOperationTurn
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
PUBLIC	?IsInChosenMoves@CvTacticalAI@@AAE_NPAVCvPlot@@@Z ; CvTacticalAI::IsInChosenMoves
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
;	COMDAT ?IsInChosenMoves@CvTacticalAI@@AAE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?IsInChosenMoves@CvTacticalAI@@AAE_NPAVCvPlot@@@Z PROC	; CvTacticalAI::IsInChosenMoves, COMDAT
; _this$ = ecx

; 10745: {

	mov	edx, DWORD PTR [ecx+27432]

; 10746: #ifdef AUI_ITERATORIZE
; 10747: 	for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it = m_ChosenBlocks.begin(); it != m_ChosenBlocks.end(); ++it)
; 10748: 	{
; 10749: 		if (it->GetPlot() == pPlot)
; 10750: #else
; 10751: 	for(unsigned int iI = 0; iI < m_ChosenBlocks.size(); iI++)

	xor	eax, eax
	push	esi
	test	edx, edx
	jbe	SHORT $LN2@IsInChosen
	mov	ecx, DWORD PTR [ecx+27428]
	mov	esi, DWORD PTR _pPlot$[esp]
$LL4@IsInChosen:

; 10752: 	{
; 10753: 		if(m_ChosenBlocks[iI].GetPlot() == pPlot)

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN14@IsInChosen
	inc	eax
	add	ecx, 16					; 00000010H
	cmp	eax, edx
	jb	SHORT $LL4@IsInChosen
$LN2@IsInChosen:

; 10757: 		}
; 10758: 	}
; 10759: 
; 10760: 	return false;

	xor	al, al
	pop	esi

; 10761: }

	ret	4
$LN14@IsInChosen:

; 10754: #endif
; 10755: 		{
; 10756: 			return true;

	mov	al, 1
	pop	esi

; 10761: }

	ret	4
?IsInChosenMoves@CvTacticalAI@@AAE_NPAVCvPlot@@@Z ENDP	; CvTacticalAI::IsInChosenMoves
_TEXT	ENDS
PUBLIC	?HaveDuplicateUnit@CvTacticalAI@@AAE_NXZ	; CvTacticalAI::HaveDuplicateUnit
; Function compile flags: /Ogtpy
;	COMDAT ?HaveDuplicateUnit@CvTacticalAI@@AAE_NXZ
_TEXT	SEGMENT
?HaveDuplicateUnit@CvTacticalAI@@AAE_NXZ PROC		; CvTacticalAI::HaveDuplicateUnit, COMDAT
; _this$ = ecx

; 10765: {

	push	ebx
	push	ebp
	push	esi

; 10766: #ifdef AUI_ITERATORIZE
; 10767: 	for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it = m_NewlyChosen.begin(); it + 1 != m_NewlyChosen.end(); ++it)
; 10768: 	{
; 10769: 		for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = it + 1; it2 != m_NewlyChosen.end(); ++it2)
; 10770: 		{
; 10771: 			if (it->GetUnitID() == it2->GetUnitID())
; 10772: #else
; 10773: 	for(unsigned int iI = 0; iI < m_NewlyChosen.size()- 1; iI++)

	mov	esi, DWORD PTR [ecx+28040]
	lea	edx, DWORD PTR [esi-1]
	xor	eax, eax
	push	edi
	test	edx, edx
	jbe	SHORT $LN5@HaveDuplic
	xor	edi, edi
$LL7@HaveDuplic:
	lea	ebp, DWORD PTR [eax+1]

; 10774: 	{
; 10775: 		for(unsigned int jJ = iI + 1; jJ < m_NewlyChosen.size(); jJ++)

	mov	eax, ebp
	cmp	eax, esi
	jae	SHORT $LN6@HaveDuplic
	mov	edx, DWORD PTR [ecx+28036]
	mov	ebx, DWORD PTR [edi+edx+4]
	lea	edx, DWORD PTR [edi+edx+20]
	npad	4
$LL4@HaveDuplic:

; 10776: 		{
; 10777: 			if(m_NewlyChosen[iI].GetUnitID() == m_NewlyChosen[jJ].GetUnitID())

	cmp	ebx, DWORD PTR [edx]
	je	SHORT $LN24@HaveDuplic
	inc	eax
	add	edx, 16					; 00000010H
	cmp	eax, esi
	jb	SHORT $LL4@HaveDuplic
$LN6@HaveDuplic:

; 10766: #ifdef AUI_ITERATORIZE
; 10767: 	for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it = m_NewlyChosen.begin(); it + 1 != m_NewlyChosen.end(); ++it)
; 10768: 	{
; 10769: 		for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = it + 1; it2 != m_NewlyChosen.end(); ++it2)
; 10770: 		{
; 10771: 			if (it->GetUnitID() == it2->GetUnitID())
; 10772: #else
; 10773: 	for(unsigned int iI = 0; iI < m_NewlyChosen.size()- 1; iI++)

	mov	eax, ebp
	lea	edx, DWORD PTR [esi-1]
	add	edi, 16					; 00000010H
	cmp	eax, edx
	jb	SHORT $LL7@HaveDuplic
$LN5@HaveDuplic:
	pop	edi
	pop	esi
	pop	ebp

; 10781: 			}
; 10782: 		}
; 10783: 	}
; 10784: 	return false;

	xor	al, al
	pop	ebx

; 10785: }

	ret	0
$LN24@HaveDuplic:
	pop	edi
	pop	esi
	pop	ebp

; 10778: #endif
; 10779: 			{
; 10780: 				return true;

	mov	al, 1
	pop	ebx

; 10785: }

	ret	0
?HaveDuplicateUnit@CvTacticalAI@@AAE_NXZ ENDP		; CvTacticalAI::HaveDuplicateUnit
_TEXT	ENDS
PUBLIC	?ScoreAssignments@CvTacticalAI@@AAEH_N@Z	; CvTacticalAI::ScoreAssignments
EXTRN	?GetPower@CvUnit@@QBEHXZ:PROC			; CvUnit::GetPower
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
; Function compile flags: /Ogtpy
;	COMDAT ?ScoreAssignments@CvTacticalAI@@AAEH_N@Z
_TEXT	SEGMENT
_iScore$ = -8						; size = 4
tv410 = -4						; size = 4
_bCanLeaveOpenings$ = 8					; size = 1
?ScoreAssignments@CvTacticalAI@@AAEH_N@Z PROC		; CvTacticalAI::ScoreAssignments, COMDAT
; _this$ = ecx

; 11027: {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 11028: 	int iScore = 0;
; 11029: 
; 11030: 	// Any assignment appear twice?
; 11031: #ifdef AUI_ITERATORIZE
; 11032: 	for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_TemporaryBlocks.begin(); it + 1 != m_TemporaryBlocks.end(); ++it)
; 11033: 	{
; 11034: 		for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>::iterator it2 = it + 1; it2 != m_TemporaryBlocks.end(); ++it2)
; 11035: 		{
; 11036: 			if (it->GetUnitID() == it2->GetUnitID())
; 11037: #else
; 11038: 	for(unsigned int iI = 0; iI < m_TemporaryBlocks.size(); iI++)

	mov	eax, DWORD PTR [esi+27016]
	xor	edx, edx
	xor	ebp, ebp
	push	edi
	mov	DWORD PTR _iScore$[esp+24], edx
	cmp	eax, edx
	jbe	SHORT $LN67@ScoreAssig
	mov	edi, 1
	mov	DWORD PTR tv410[esp+24], edi
$LL15@ScoreAssig:

; 11039: 	{
; 11040: 		for(unsigned int jJ = iI + 1; jJ < m_TemporaryBlocks.size(); jJ++)

	cmp	edi, eax
	jae	SHORT $LN14@ScoreAssig

; 11028: 	int iScore = 0;
; 11029: 
; 11030: 	// Any assignment appear twice?
; 11031: #ifdef AUI_ITERATORIZE
; 11032: 	for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_TemporaryBlocks.begin(); it + 1 != m_TemporaryBlocks.end(); ++it)
; 11033: 	{
; 11034: 		for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>::iterator it2 = it + 1; it2 != m_TemporaryBlocks.end(); ++it2)
; 11035: 		{
; 11036: 			if (it->GetUnitID() == it2->GetUnitID())
; 11037: #else
; 11038: 	for(unsigned int iI = 0; iI < m_TemporaryBlocks.size(); iI++)

	lea	eax, DWORD PTR [edx+16]
	npad	5
$LL12@ScoreAssig:

; 11041: 		{
; 11042: 			if(m_TemporaryBlocks[iI].GetUnitID() == m_TemporaryBlocks[jJ].GetUnitID())

	mov	ecx, DWORD PTR [esi+27012]
	mov	ebx, DWORD PTR [edx+ecx+4]
	cmp	ebx, DWORD PTR [eax+ecx+4]
	jne	SHORT $LN11@ScoreAssig

; 11043: #endif
; 11044: 			{
; 11045: 				if(!bCanLeaveOpenings)

	cmp	BYTE PTR _bCanLeaveOpenings$[esp+20], 0
	je	$LN63@ScoreAssig

; 11048: 				}
; 11049: 				else
; 11050: 				{
; 11051: 					// "Clear" the move with greater distance by setting it to MAX_INT distance
; 11052: #ifdef AUI_ITERATORIZE
; 11053: 					if (it->GetDistanceToTarget() < it2->GetDistanceToTarget())
; 11054: 					{
; 11055: 						it2->SetDistanceToTarget(MAX_INT);
; 11056: 					}
; 11057: 					else
; 11058: 					{
; 11059: 						it->SetDistanceToTarget(MAX_INT);
; 11060: #else
; 11061: 					if(m_TemporaryBlocks[iI].GetDistanceToTarget() < m_TemporaryBlocks[jJ].GetDistanceToTarget())

	mov	ebx, DWORD PTR [edx+ecx+12]
	cmp	ebx, DWORD PTR [eax+ecx+12]
	jge	SHORT $LN6@ScoreAssig

; 11062: 					{
; 11063: 						m_TemporaryBlocks[jJ].SetDistanceToTarget(MAX_INT);

	mov	DWORD PTR [ecx+eax+12], 2147483647	; 7fffffffH

; 11064: 					}
; 11065: 					else

	jmp	SHORT $LN11@ScoreAssig
$LN6@ScoreAssig:

; 11066: 					{
; 11067: 						m_TemporaryBlocks[iI].SetDistanceToTarget(MAX_INT);

	mov	DWORD PTR [ecx+edx+12], 2147483647	; 7fffffffH
$LN11@ScoreAssig:

; 11039: 	{
; 11040: 		for(unsigned int jJ = iI + 1; jJ < m_TemporaryBlocks.size(); jJ++)

	inc	edi
	add	eax, 16					; 00000010H
	cmp	edi, DWORD PTR [esi+27016]
	jb	SHORT $LL12@ScoreAssig
	mov	edi, DWORD PTR tv410[esp+24]
$LN14@ScoreAssig:

; 11028: 	int iScore = 0;
; 11029: 
; 11030: 	// Any assignment appear twice?
; 11031: #ifdef AUI_ITERATORIZE
; 11032: 	for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_TemporaryBlocks.begin(); it + 1 != m_TemporaryBlocks.end(); ++it)
; 11033: 	{
; 11034: 		for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>::iterator it2 = it + 1; it2 != m_TemporaryBlocks.end(); ++it2)
; 11035: 		{
; 11036: 			if (it->GetUnitID() == it2->GetUnitID())
; 11037: #else
; 11038: 	for(unsigned int iI = 0; iI < m_TemporaryBlocks.size(); iI++)

	mov	eax, DWORD PTR [esi+27016]
	inc	ebp
	inc	edi
	add	edx, 16					; 00000010H
	mov	DWORD PTR tv410[esp+24], edi
	cmp	ebp, eax
	jb	SHORT $LL15@ScoreAssig
$LN67@ScoreAssig:

; 11068: #endif
; 11069: 					}
; 11070: 				}
; 11071: 			}
; 11072: 		}
; 11073: 	}
; 11074: 
; 11075: 	// Legal, so let's score it
; 11076: #ifdef AUI_ITERATORIZE
; 11077: 	for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>::const_iterator it = m_TemporaryBlocks.begin(); it != m_TemporaryBlocks.end(); ++it)
; 11078: 	{
; 11079: 		if (it->GetDistanceToTarget() != MAX_INT)
; 11080: 		{
; 11081: 			iScore += (10000 - (it->GetDistanceToTarget() * 1000));
; 11082: 			iScore += m_pPlayer->getUnit(it->GetUnitID())->GetPower();
; 11083: #else
; 11084: 	for(unsigned int iI = 0; iI < m_TemporaryBlocks.size(); iI++)

	xor	ebp, ebp
	cmp	DWORD PTR [esi+27016], ebp
	jbe	SHORT $LN2@ScoreAssig
	xor	edi, edi
	npad	10
$LL4@ScoreAssig:

; 11085: 	{
; 11086: 		if(m_TemporaryBlocks[iI].GetDistanceToTarget() != MAX_INT)

	mov	edx, DWORD PTR [esi+27012]
	cmp	DWORD PTR [edx+edi+12], 2147483647	; 7fffffffH
	je	SHORT $LN3@ScoreAssig

; 11087: 		{
; 11088: 			iScore += (10000 - (m_TemporaryBlocks[iI].GetDistanceToTarget() * 1000));
; 11089: 			iScore += m_pPlayer->getUnit(m_TemporaryBlocks[iI].GetUnitID())->GetPower();

	mov	ecx, DWORD PTR [esi]
	mov	eax, edx
	mov	ebx, DWORD PTR [eax+edi+12]
	add	eax, edi
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ecx, eax
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	mov	ecx, 10					; 0000000aH
	sub	ecx, ebx
	imul	ecx, 1000				; 000003e8H
	add	ecx, DWORD PTR _iScore$[esp+24]
	add	ecx, eax
	mov	DWORD PTR _iScore$[esp+24], ecx
$LN3@ScoreAssig:
	inc	ebp
	add	edi, 16					; 00000010H
	cmp	ebp, DWORD PTR [esi+27016]
	jb	SHORT $LL4@ScoreAssig
$LN2@ScoreAssig:

; 11090: #endif
; 11091: 		}
; 11092: 	}
; 11093: 
; 11094: 	return iScore;

	mov	eax, DWORD PTR _iScore$[esp+24]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 11095: }

	add	esp, 8
	ret	4
$LN63@ScoreAssig:
	pop	edi
	pop	esi
	pop	ebp

; 11046: 				{
; 11047: 					return -1;

	or	eax, -1
	pop	ebx

; 11095: }

	add	esp, 8
	ret	4
?ScoreAssignments@CvTacticalAI@@AAEH_N@Z ENDP		; CvTacticalAI::ScoreAssignments
_TEXT	ENDS
PUBLIC	?IsVeryHighPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z ; CvTacticalAI::IsVeryHighPriorityCivilianTarget
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
; Function compile flags: /Ogtpy
;	COMDAT ?IsVeryHighPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
?IsVeryHighPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z PROC ; CvTacticalAI::IsVeryHighPriorityCivilianTarget, COMDAT
; _this$ = ecx

; 11493: 	bool bRtnValue = false;
; 11494: 	CvUnit* pUnit = (CvUnit*)pTarget->GetAuxData();

	mov	eax, DWORD PTR _pTarget$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [eax+16]
	xor	bl, bl

; 11495: 	if(pUnit)

	test	esi, esi
	je	SHORT $LN9@IsVeryHigh

; 11496: 	{
; 11497: 		if(pUnit->AI_getUnitAIType() == UNITAI_GENERAL || pUnit->AI_getUnitAIType() == UNITAI_ADMIRAL)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN1@IsVeryHigh
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN9@IsVeryHigh
$LN1@IsVeryHigh:
	pop	esi

; 11498: 		{
; 11499: 			bRtnValue = true;

	mov	al, 1
	pop	ebx

; 11503: }

	ret	4
$LN9@IsVeryHigh:
	pop	esi

; 11500: 		}
; 11501: 	}
; 11502: 	return bRtnValue;

	mov	al, bl
	pop	ebx

; 11503: }

	ret	4
?IsVeryHighPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z ENDP ; CvTacticalAI::IsVeryHighPriorityCivilianTarget
_TEXT	ENDS
PUBLIC	?IsHighPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z ; CvTacticalAI::IsHighPriorityCivilianTarget
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?IsCramped@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsCramped
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?GetCivilianAttackPriority@CvUnitEntry@@QBEHXZ:PROC ; CvUnitEntry::GetCivilianAttackPriority
EXTRN	?getEstimateEndTurn@CvGame@@QBEHXZ:PROC		; CvGame::getEstimateEndTurn
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
; Function compile flags: /Ogtpy
;	COMDAT ?IsHighPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pTarget$ = 8						; size = 4
?IsHighPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z PROC ; CvTacticalAI::IsHighPriorityCivilianTarget, COMDAT
; _this$ = ecx

; 11507: {

	push	ecx

; 11508: 	bool bRtnValue = false;
; 11509: 	CvUnit* pUnit = (CvUnit*)pTarget->GetAuxData();

	mov	eax, DWORD PTR _pTarget$[esp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [eax+16]
	xor	bl, bl
	mov	DWORD PTR _this$[esp+12], ecx

; 11510: 	if(pUnit)

	test	esi, esi
	je	$LN1@IsHighPrio
	push	ebp
	push	edi

; 11511: 	{
; 11512: 		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pUnit->getUnitType());

	mov	ecx, esi
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 11513: 		int iEstimatedEndTurn = GC.getGame().getEstimateEndTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, eax
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	mov	ebp, eax

; 11514: 		if(pkUnitInfo)

	test	edi, edi
	je	$LN38@IsHighPrio

; 11515: 		{
; 11516: 			// Priorities defined in XML
; 11517: 			if(pkUnitInfo->GetCivilianAttackPriority() == CIVILIAN_ATTACK_PRIORITY_HIGH)

	mov	ecx, edi
	call	?GetCivilianAttackPriority@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetCivilianAttackPriority
	test	eax, eax

; 11518: 			{
; 11519: 				bRtnValue = true;

	je	$LN40@IsHighPrio

; 11520: 			}
; 11521: 			else if(pkUnitInfo->GetCivilianAttackPriority() == CIVILIAN_ATTACK_PRIORITY_HIGH_EARLY_GAME_ONLY)

	mov	ecx, edi
	call	?GetCivilianAttackPriority@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetCivilianAttackPriority
	cmp	eax, 1
	jne	SHORT $LN36@IsHighPrio

; 11522: 			{
; 11523: 				if(GC.getGame().getGameTurn() < (iEstimatedEndTurn / 3))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, eax
	mov	eax, 1431655766				; 55555556H
	imul	ebp
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ecx, eax

; 11524: 				{
; 11525: 					bRtnValue =  true;
; 11526: 				}
; 11527: 			}
; 11528: 			if(!bRtnValue && pUnit->AI_getUnitAIType() == UNITAI_SETTLE)

	jl	SHORT $LN40@IsHighPrio
$LN36@IsHighPrio:
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 1
	jne	SHORT $LN37@IsHighPrio

; 11529: 			{
; 11530: 				//Settlers
; 11531: 				if(GET_PLAYER(pUnit->getOwner()).getNumCities() < 5)  //small player?

	mov	ecx, DWORD PTR [esi+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 5

; 11532: 				{
; 11533: 					bRtnValue = true;

	jl	SHORT $LN40@IsHighPrio

; 11534: 				}
; 11535: 				else if(GC.getGame().getGameTurn() < (iEstimatedEndTurn / 3))  //early game?

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, eax
	mov	eax, 1431655766				; 55555556H
	imul	ebp
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ecx, eax

; 11536: 				{
; 11537: 					bRtnValue =  true;

	jl	SHORT $LN40@IsHighPrio

; 11538: 				}
; 11539: 				else if(GET_PLAYER(pUnit->getOwner()).IsCramped())  //player really needs to expand?

	mov	ecx, DWORD PTR [esi+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?IsCramped@CvPlayer@@QBE_NXZ		; CvPlayer::IsCramped
	test	al, al

; 11540: 				{
; 11541: 					bRtnValue = true;
; 11542: 				}
; 11543: 			}
; 11544: 			if(!bRtnValue && m_pPlayer->isBarbarian())

	jne	SHORT $LN40@IsHighPrio
$LN37@IsHighPrio:
	mov	ecx, DWORD PTR _this$[esp+20]
	mov	ecx, DWORD PTR [ecx]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	je	SHORT $LN38@IsHighPrio
$LN40@IsHighPrio:

; 11545: 			{
; 11546: 				bRtnValue = true; //always high priority for barbs

	mov	bl, 1
$LN38@IsHighPrio:
	pop	edi
	pop	ebp
$LN1@IsHighPrio:
	pop	esi

; 11547: 			}
; 11548: 		}
; 11549: 	}
; 11550: 	return bRtnValue;

	mov	al, bl
	pop	ebx

; 11551: }

	pop	ecx
	ret	4
?IsHighPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z ENDP ; CvTacticalAI::IsHighPriorityCivilianTarget
_TEXT	ENDS
PUBLIC	?IsMediumPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z ; CvTacticalAI::IsMediumPriorityCivilianTarget
; Function compile flags: /Ogtpy
;	COMDAT ?IsMediumPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
?IsMediumPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z PROC ; CvTacticalAI::IsMediumPriorityCivilianTarget, COMDAT
; _this$ = ecx

; 11556: 	bool bRtnValue = false;
; 11557: 	CvUnit* pUnit = (CvUnit*)pTarget->GetAuxData();

	mov	eax, DWORD PTR _pTarget$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [eax+16]
	xor	bl, bl

; 11558: 	if(pUnit)

	test	esi, esi
	je	$LN29@IsMediumPr

; 11559: 	{
; 11560: 		int iEstimatedEndTurn = GC.getGame().getEstimateEndTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	mov	edi, eax

; 11561: 		if(pUnit->isEmbarked() && !pUnit->IsCombatUnit())  //embarked civilians

	cmp	BYTE PTR [esi+1652], bl
	je	SHORT $LN7@IsMediumPr
	cmp	DWORD PTR [esi+1044], 0

; 11562: 		{
; 11563: 			bRtnValue = true;

	jle	SHORT $LN32@IsMediumPr
$LN7@IsMediumPr:

; 11564: 		}
; 11565: 		else if(pUnit->AI_getUnitAIType() == UNITAI_SETTLE)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 1
	jne	SHORT $LN5@IsMediumPr

; 11566: 		{
; 11567: 			if(GC.getGame().getGameTurn() >= (iEstimatedEndTurn / 3))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, eax
	mov	eax, 1431655766				; 55555556H
	imul	edi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ecx, eax
	jl	SHORT $LN30@IsMediumPr
	pop	edi
	pop	esi

; 11568: 			{
; 11569: 				bRtnValue =  true;

	mov	al, 1
	pop	ebx

; 11581: }

	ret	4
$LN5@IsMediumPr:

; 11570: 			}
; 11571: 		}
; 11572: 		else if(pUnit->AI_getUnitAIType() == UNITAI_WORKER)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	jne	SHORT $LN30@IsMediumPr

; 11573: 		{
; 11574: 			if(GC.getGame().getGameTurn() < (iEstimatedEndTurn / 3))  //early game?

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, eax
	mov	eax, 1431655766				; 55555556H
	imul	edi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ecx, eax
	jge	SHORT $LN30@IsMediumPr
$LN32@IsMediumPr:
	pop	edi
	pop	esi

; 11575: 			{
; 11576: 				bRtnValue =  true;

	mov	al, 1
	pop	ebx

; 11581: }

	ret	4
$LN29@IsMediumPr:
	pop	esi

; 11577: 			}
; 11578: 		}
; 11579: 	}
; 11580: 	return bRtnValue;

	mov	al, bl
	pop	ebx

; 11581: }

	ret	4
$LN30@IsMediumPr:
	pop	edi
	pop	esi

; 11577: 			}
; 11578: 		}
; 11579: 	}
; 11580: 	return bRtnValue;

	mov	al, bl
	pop	ebx

; 11581: }

	ret	4
?IsMediumPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z ENDP ; CvTacticalAI::IsMediumPriorityCivilianTarget
_TEXT	ENDS
PUBLIC	?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z ; CvTacticalAI::GetLogFileName
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z$2
__ehfuncinfo$?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z
_TEXT	SEGMENT
$T241030 = -72						; size = 4
$T241028 = -68						; size = 28
$T241027 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z PROC ; CvTacticalAI::GetLogFileName, COMDAT
; _this$ = ecx

; 11618: {

	push	-1
	push	__ehhandler$?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T241030[esp+80], ebx

; 11619: 	CvString strLogName;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+76]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 11629: 	}
; 11630: 
; 11631: 	return strLogName;

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	mov	DWORD PTR $T241030[esp+80], 1
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	SHORT $LN2@GetLogFile
	mov	eax, DWORD PTR _playerName$[esp+76]
	push	eax
	lea	ecx, DWORD PTR $T241027[esp+84]
	push	OFFSET $SG226171
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG226170
	push	eax
	lea	edx, DWORD PTR $T241028[esp+100]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+88], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T241028[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T241027[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	pop	ebx

; 11632: }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
$LN2@GetLogFile:

; 11620: 
; 11621: 	// Open the log file
; 11622: 	if(GC.getPlayerAndCityAILogSplit())
; 11623: 	{
; 11624: 		strLogName = "PlayerTacticalAILog_" + playerName + ".csv";
; 11625: 	}
; 11626: 	else
; 11627: 	{
; 11628: 		strLogName = "PlayerTacticalAILog.csv";

	push	OFFSET $SG226173
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 11632: }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z$0:
	mov	eax, DWORD PTR $T241030[ebp]
	and	eax, 1
	je	$LN6@GetLogFile
	and	DWORD PTR $T241030[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLogFile:
	ret	0
__unwindfunclet$?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z$1:
	lea	ecx, DWORD PTR $T241027[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z$2:
	lea	ecx, DWORD PTR $T241028[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z ENDP ; CvTacticalAI::GetLogFileName
PUBLIC	?GetTacticalMissionName@CvTacticalAI@@ABE?AVCvString@@W4AITacticalMission@@@Z ; CvTacticalAI::GetTacticalMissionName
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetTacticalMissionName@CvTacticalAI@@ABE?AVCvString@@W4AITacticalMission@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTacticalMissionName@CvTacticalAI@@ABE?AVCvString@@W4AITacticalMission@@@Z$0
__ehfuncinfo$?GetTacticalMissionName@CvTacticalAI@@ABE?AVCvString@@W4AITacticalMission@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetTacticalMissionName@CvTacticalAI@@ABE?AVCvString@@W4AITacticalMission@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?GetTacticalMissionName@CvTacticalAI@@ABE?AVCvString@@W4AITacticalMission@@@Z
_TEXT	SEGMENT
$T241058 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_eMission$ = 12						; size = 4
?GetTacticalMissionName@CvTacticalAI@@ABE?AVCvString@@W4AITacticalMission@@@Z PROC ; CvTacticalAI::GetTacticalMissionName, COMDAT
; _this$ = ecx

; 11636: {

	push	-1
	push	__ehhandler$?GetTacticalMissionName@CvTacticalAI@@ABE?AVCvString@@W4AITacticalMission@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	DWORD PTR $T241058[esp+20], 0

; 11637: 	CvString strMissionName;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 11650: 	}
; 11651: 
; 11652: 	return strMissionName;

	mov	eax, DWORD PTR _eMission$[esp+16]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	mov	DWORD PTR $T241058[esp+20], 1
	cmp	eax, -1
	je	SHORT $LN3@GetTactica

; 11638: 
; 11639: 	// Open the log file
; 11640: 	switch(eMission)

	test	eax, eax
	je	SHORT $LN2@GetTactica
	cmp	eax, 1
	jne	SHORT $LN25@GetTactica

; 11648: 	case AI_TACTICAL_MISSION_PILLAGE_ENEMY_IMPROVEMENTS:
; 11649: 		strMissionName = "Pillage Enemy Improvements";

	push	OFFSET $SG226189
	jmp	SHORT $LN27@GetTactica
$LN2@GetTactica:

; 11644: 		break;
; 11645: 	case AI_TACTICAL_MISSION_ATTACK_STATIONARY_TARGET:
; 11646: 		strMissionName = "Attack Stationary Target";

	push	OFFSET $SG226187

; 11647: 		break;

	jmp	SHORT $LN27@GetTactica
$LN3@GetTactica:

; 11641: 	{
; 11642: 	case AI_TACTICAL_MISSION_NONE:
; 11643: 		strMissionName = "No Tactic";

	push	OFFSET $SG226185
$LN27@GetTactica:
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN25@GetTactica:

; 11653: }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTacticalMissionName@CvTacticalAI@@ABE?AVCvString@@W4AITacticalMission@@@Z$0:
	mov	eax, DWORD PTR $T241058[ebp]
	and	eax, 1
	je	$LN9@GetTactica
	and	DWORD PTR $T241058[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN9@GetTactica:
	ret	0
__ehhandler$?GetTacticalMissionName@CvTacticalAI@@ABE?AVCvString@@W4AITacticalMission@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetTacticalMissionName@CvTacticalAI@@ABE?AVCvString@@W4AITacticalMission@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTacticalMissionName@CvTacticalAI@@ABE?AVCvString@@W4AITacticalMission@@@Z ENDP ; CvTacticalAI::GetTacticalMissionName
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABW4AITacticalMission@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABW4AITacticalMission@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABW4AITacticalMission@@@Z PROC ; operator<<, COMDAT

; 11657: 	int v = static_cast<int>(readFrom);

	mov	eax, DWORD PTR _readFrom$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi

; 11658: 	saveTo << v;

	mov	esi, DWORD PTR _saveTo$[esp]
	lea	edx, DWORD PTR _v$[esp]
	mov	DWORD PTR _v$[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 11659: 	return saveTo;

	mov	eax, esi
	pop	esi

; 11660: }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABW4AITacticalMission@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAW4AITacticalMission@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAW4AITacticalMission@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAW4AITacticalMission@@@Z PROC ; operator>>, COMDAT

; 11663: {

	push	esi

; 11664: 	int v;
; 11665: 	loadFrom >> v;

	mov	esi, DWORD PTR _loadFrom$[esp]
	lea	eax, DWORD PTR _v$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 11666: 	writeTo = static_cast<AITacticalMission>(v);

	mov	ecx, DWORD PTR _writeTo$[esp]
	mov	edx, DWORD PTR _v$[esp]

; 11667: 	return loadFrom;

	mov	eax, esi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 11668: }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAW4AITacticalMission@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	?CvBlockingUnitDistanceSort@TacticalAIHelpers@@YA_NVCvBlockingUnit@@0@Z ; TacticalAIHelpers::CvBlockingUnitDistanceSort
; Function compile flags: /Ogtpy
;	COMDAT ?CvBlockingUnitDistanceSort@TacticalAIHelpers@@YA_NVCvBlockingUnit@@0@Z
_TEXT	SEGMENT
_obj1$ = 8						; size = 16
_obj2$ = 24						; size = 16
?CvBlockingUnitDistanceSort@TacticalAIHelpers@@YA_NVCvBlockingUnit@@0@Z PROC ; TacticalAIHelpers::CvBlockingUnitDistanceSort, COMDAT

; 11675: 	return obj1.GetDistanceToTarget() < obj2.GetDistanceToTarget();

	mov	ecx, DWORD PTR _obj1$[esp+8]
	xor	eax, eax
	cmp	ecx, DWORD PTR _obj2$[esp+8]
	setl	al

; 11676: }

	ret	0
?CvBlockingUnitDistanceSort@TacticalAIHelpers@@YA_NVCvBlockingUnit@@0@Z ENDP ; TacticalAIHelpers::CvBlockingUnitDistanceSort
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 156  : 	{

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [esi+4], 0

; 157  : 		OBJECT_HANDLE_STACK;
; 158  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 159  : 		{
; 160  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 161  : 		}
; 162  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z PROC ; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 165  : 	{

	push	esi
	mov	esi, ecx

; 166  : 		OBJECT_HANDLE_STACK;
; 167  : 		if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@operator@4

; 168  : 		{
; 169  : 			m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@operator@4:

; 170  : 		}
; 171  : 		m_target = target;

	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx

; 172  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN9@operator@4

; 173  : 		{
; 174  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@operator@4:

; 175  : 		}
; 176  : 		return *this;

	mov	eax, esi
	pop	esi

; 177  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ENDP ; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z	; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z PROC	; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 195  : 	{

	push	esi
	push	edi

; 196  : 		if(&rhs != this)

	mov	edi, DWORD PTR _rhs$[esp+4]
	mov	esi, ecx
	cmp	edi, esi
	je	SHORT $LN11@operator@5

; 197  : 		{
; 198  : 			OBJECT_HANDLE_STACK;
; 199  : 			if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@operator@5

; 200  : 			{
; 201  : 				const_cast<FObjectHandle *>(this)->m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@operator@5:

; 202  : 			}
; 203  : 			const_cast<FObjectHandle *>(this)->m_target = rhs.m_target;

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 204  : 			if(m_target)

	test	ecx, ecx
	je	SHORT $LN11@operator@5

; 205  : 			{
; 206  : 				const_cast<FObjectHandle *>(this)->m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@operator@5:
	pop	edi

; 207  : 			}
; 208  : 		}
; 209  : 		return *this;

	mov	eax, esi
	pop	esi

; 210  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z ENDP	; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 222  : 	{

	mov	eax, DWORD PTR _source$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	dl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], dl

; 223  : 		OBJECT_HANDLE_STACK;
; 224  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@3

; 225  : 		{
; 226  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@3:

; 227  : 		}
; 228  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalMove,256,1,297,0>::FStaticVector<CvTacticalMove,256,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTacticalMove,256,1,297,0>::FStaticVector<CvTacticalMove,256,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 256			; 00000100H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTacticalMove,256,1,297,0>::FStaticVector<CvTacticalMove,256,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvTacticalMove@@$00@@QAEXXZ ; BaseVector<CvTacticalMove,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvTacticalMove@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvTacticalMove@@$00@@QAEXXZ PROC	; BaseVector<CvTacticalMove,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvTacticalMove@@$00@@QAEXXZ ENDP	; BaseVector<CvTacticalMove,1>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,256,0,297,0>::FStaticVector<CvTacticalTarget,256,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTacticalTarget,256,0,297,0>::FStaticVector<CvTacticalTarget,256,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 256			; 00000100H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTacticalTarget,256,0,297,0>::FStaticVector<CvTacticalTarget,256,0,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvTacticalTarget@@$0A@@@QAEXXZ ; BaseVector<CvTacticalTarget,0>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvTacticalTarget@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvTacticalTarget@@$0A@@@QAEXXZ PROC ; BaseVector<CvTacticalTarget,0>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvTacticalTarget@@$0A@@@QAEXXZ ENDP ; BaseVector<CvTacticalTarget,0>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,37,1,297,0>::FStaticVector<CvTacticalTarget,37,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTacticalTarget,37,1,297,0>::FStaticVector<CvTacticalTarget,37,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 37			; 00000025H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTacticalTarget,37,1,297,0>::FStaticVector<CvTacticalTarget,37,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvTacticalTarget@@$00@@QAEXXZ ; BaseVector<CvTacticalTarget,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvTacticalTarget@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvTacticalTarget@@$00@@QAEXXZ PROC	; BaseVector<CvTacticalTarget,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvTacticalTarget@@$00@@QAEXXZ ENDP	; BaseVector<CvTacticalTarget,1>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalPosture,64,1,297,0>::FStaticVector<CvTacticalPosture,64,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTacticalPosture,64,1,297,0>::FStaticVector<CvTacticalPosture,64,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTacticalPosture,64,1,297,0>::FStaticVector<CvTacticalPosture,64,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvTacticalPosture@@$00@@QAEXXZ ; BaseVector<CvTacticalPosture,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvTacticalPosture@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvTacticalPosture@@$00@@QAEXXZ PROC ; BaseVector<CvTacticalPosture,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvTacticalPosture@@$00@@QAEXXZ ENDP ; BaseVector<CvTacticalPosture,1>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTemporaryZone,10,1,297,0>::FStaticVector<CvTemporaryZone,10,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTemporaryZone,10,1,297,0>::FStaticVector<CvTemporaryZone,10,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 10			; 0000000aH
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTemporaryZone,10,1,297,0>::FStaticVector<CvTemporaryZone,10,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvTemporaryZone@@$00@@QAEXXZ ; BaseVector<CvTemporaryZone,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvTemporaryZone@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvTemporaryZone@@$00@@QAEXXZ PROC	; BaseVector<CvTemporaryZone,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvTemporaryZone@@$00@@QAEXXZ ENDP	; BaseVector<CvTemporaryZone,1>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvBlockingUnit,25,1,297,0>::FStaticVector<CvBlockingUnit,25,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvBlockingUnit,25,1,297,0>::FStaticVector<CvBlockingUnit,25,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 25			; 00000019H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvBlockingUnit,25,1,297,0>::FStaticVector<CvBlockingUnit,25,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvBlockingUnit@@$00@@QAEXXZ ; BaseVector<CvBlockingUnit,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvBlockingUnit@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvBlockingUnit@@$00@@QAEXXZ PROC	; BaseVector<CvBlockingUnit,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvBlockingUnit@@$00@@QAEXXZ ENDP	; BaseVector<CvBlockingUnit,1>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvBlockingUnit,37,1,297,0>::FStaticVector<CvBlockingUnit,37,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvBlockingUnit,37,1,297,0>::FStaticVector<CvBlockingUnit,37,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 37			; 00000025H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvBlockingUnit,37,1,297,0>::FStaticVector<CvBlockingUnit,37,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvBlockingUnit,37,1,297,0>::~FStaticVector<CvBlockingUnit,37,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvBlockingUnit,37,1,297,0>::~FStaticVector<CvBlockingUnit,37,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvBlockingUnit,37,1,297,0>::~FStaticVector<CvBlockingUnit,37,1,297,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationUnit,20,1,297,0>::FStaticVector<CvOperationUnit,20,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvOperationUnit,20,1,297,0>::FStaticVector<CvOperationUnit,20,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 20			; 00000014H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvOperationUnit,20,1,297,0>::FStaticVector<CvOperationUnit,20,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvOperationUnit@@$00@@QAEXXZ ; BaseVector<CvOperationUnit,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvOperationUnit@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvOperationUnit@@$00@@QAEXXZ PROC	; BaseVector<CvOperationUnit,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvOperationUnit@@$00@@QAEXXZ ENDP	; BaseVector<CvOperationUnit,1>::clear
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 131  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 132  : 		++*this;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 133  : 		return (_Tmp);
; 134  : 		}

	ret	8
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEAAPAVCvTacticalMoveXMLEntry@@XZ ; std::_Vector_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEAAPAVCvTacticalMoveXMLEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEAAPAVCvTacticalMoveXMLEntry@@XZ PROC ; std::_Vector_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEAAPAVCvTacticalMoveXMLEntry@@XZ ENDP ; std::_Vector_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::_Iterator<0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??0?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::_Iterator<0>, COMDAT
; _this$ = ecx

; 348  : 		_Iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 349  : 			{	// construct with null node
; 350  : 			}

	ret	0
??0?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::_Iterator<0>
_TEXT	ENDS
PUBLIC	??9?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBE_NABV012@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBE_NABV012@@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator!=, COMDAT
; _this$ = ecx

; 303  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 304  : 			}

	ret	4
??9?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::_Iterator<0>::_Iterator<0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC ; std::list<int,std::allocator<int> >::_Iterator<0>::_Iterator<0>, COMDAT
; _this$ = ecx

; 348  : 		_Iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 349  : 			{	// construct with null node
; 350  : 			}

	ret	0
??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::list<int,std::allocator<int> >::_Iterator<0>::_Iterator<0>
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEAAPAVCvPlot@@XZ ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEAAPAVCvPlot@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEAAPAVCvPlot@@XZ PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEAAPAVCvPlot@@XZ ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator*
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator!=
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBEABQAVCvPlot@@I@Z ; CvWeightedVector<CvPlot *,1,1>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBEABQAVCvPlot@@I@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBEABQAVCvPlot@@I@Z PROC ; CvWeightedVector<CvPlot *,1,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBEABQAVCvPlot@@I@Z ENDP ; CvWeightedVector<CvPlot *,1,1>::GetElement
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEHXZ ; CvWeightedVector<CvPlot *,1,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEHXZ PROC	; CvWeightedVector<CvPlot *,1,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEHXZ ENDP	; CvWeightedVector<CvPlot *,1,1>::size
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 24			; 00000018H

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::~_Vector_val<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::~_Vector_val<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::~_Vector_val<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvTacticalUnit,std::allocator<CvTacticalUnit> >::~_Vector_val<CvTacticalUnit,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvTacticalUnit,std::allocator<CvTacticalUnit> >::~_Vector_val<CvTacticalUnit,std::allocator<CvTacticalUnit> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvTacticalUnit,std::allocator<CvTacticalUnit> >::~_Vector_val<CvTacticalUnit,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvTacticalCity,std::allocator<CvTacticalCity> >::~_Vector_val<CvTacticalCity,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvTacticalCity,std::allocator<CvTacticalCity> >::~_Vector_val<CvTacticalCity,std::allocator<CvTacticalCity> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvTacticalCity,std::allocator<CvTacticalCity> >::~_Vector_val<CvTacticalCity,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::~_Vector_val<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::~_Vector_val<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::~_Vector_val<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??1?$_List_nod@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_List_nod<int,std::allocator<int> >::~_List_nod<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_List_nod@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_nod@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_List_nod<int,std::allocator<int> >::~_List_nod<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_List_nod@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_List_nod<int,std::allocator<int> >::~_List_nod<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ; std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ PROC ; std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ENDP ; std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTacticalMoveXMLEntry@@@1@@Z ; std::_Vector_val<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Vector_val<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTacticalMoveXMLEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTacticalMoveXMLEntry@@@1@@Z PROC ; std::_Vector_val<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Vector_val<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTacticalMoveXMLEntry@@@1@@Z ENDP ; std::_Vector_val<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Vector_val<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE@V?$allocator@VCvTacticalUnit@@@1@@Z ; std::_Vector_val<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_val<CvTacticalUnit,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE@V?$allocator@VCvTacticalUnit@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE@V?$allocator@VCvTacticalUnit@@@1@@Z PROC ; std::_Vector_val<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_val<CvTacticalUnit,std::allocator<CvTacticalUnit> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE@V?$allocator@VCvTacticalUnit@@@1@@Z ENDP ; std::_Vector_val<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_val<CvTacticalUnit,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE@V?$allocator@VCvTacticalCity@@@1@@Z ; std::_Vector_val<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_val<CvTacticalCity,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE@V?$allocator@VCvTacticalCity@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE@V?$allocator@VCvTacticalCity@@@1@@Z PROC ; std::_Vector_val<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_val<CvTacticalCity,std::allocator<CvTacticalCity> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE@V?$allocator@VCvTacticalCity@@@1@@Z ENDP ; std::_Vector_val<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_val<CvTacticalCity,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEXPAVCvTacticalMove@@I@Z ; FStaticVector<CvTacticalMove,256,1,297,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEXPAVCvTacticalMove@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEXPAVCvTacticalMove@@I@Z PROC ; FStaticVector<CvTacticalMove,256,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEXPAVCvTacticalMove@@I@Z ENDP ; FStaticVector<CvTacticalMove,256,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z PROC ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXPAVCvTacticalTarget@@I@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXPAVCvTacticalTarget@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXPAVCvTacticalTarget@@I@Z PROC ; FStaticVector<CvTacticalTarget,256,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@3

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@3:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXPAVCvTacticalTarget@@I@Z ENDP ; FStaticVector<CvTacticalTarget,256,0,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXPAVCvTacticalTarget@@I@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXPAVCvTacticalTarget@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXPAVCvTacticalTarget@@I@Z PROC ; FStaticVector<CvTacticalTarget,37,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@4

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@4:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXPAVCvTacticalTarget@@I@Z ENDP ; FStaticVector<CvTacticalTarget,37,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEXPAVCvTacticalPosture@@I@Z ; FStaticVector<CvTacticalPosture,64,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEXPAVCvTacticalPosture@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEXPAVCvTacticalPosture@@I@Z PROC ; FStaticVector<CvTacticalPosture,64,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@5

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@5:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEXPAVCvTacticalPosture@@I@Z ENDP ; FStaticVector<CvTacticalPosture,64,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXPAVCvTemporaryZone@@I@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXPAVCvTemporaryZone@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXPAVCvTemporaryZone@@I@Z PROC ; FStaticVector<CvTemporaryZone,10,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@6

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@6:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXPAVCvTemporaryZone@@I@Z ENDP ; FStaticVector<CvTemporaryZone,10,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXPAVCvBlockingUnit@@I@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXPAVCvBlockingUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXPAVCvBlockingUnit@@I@Z PROC ; FStaticVector<CvBlockingUnit,25,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@7

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@7:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXPAVCvBlockingUnit@@I@Z ENDP ; FStaticVector<CvBlockingUnit,25,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvBlockingUnit,37,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 37					; 00000025H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	mov	eax, ebp
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 37			; 00000025H
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	shl	ecx, 4
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+604], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvBlockingUnit,37,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEXPAVCvOperationUnit@@I@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEXPAVCvOperationUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEXPAVCvOperationUnit@@I@Z PROC ; FStaticVector<CvOperationUnit,20,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@8

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@8:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEXPAVCvOperationUnit@@I@Z ENDP ; FStaticVector<CvOperationUnit,20,1,297,0>::Free
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::_Vector_val<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::_Vector_val<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::_Vector_val<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@PAPAVCvTacticalMoveXMLEntry@@@Z ; std::_Vector_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Vector_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@PAPAVCvTacticalMoveXMLEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@PAPAVCvTacticalMoveXMLEntry@@@Z PROC ; std::_Vector_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Vector_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@PAPAVCvTacticalMoveXMLEntry@@@Z ENDP ; std::_Vector_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Vector_iterator<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::_Iterator<0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??0?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::_Iterator<0>, COMDAT
; _this$ = ecx

; 367  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 368  : 			}

	ret	4
??0?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::_Iterator<0>
_TEXT	ENDS
PUBLIC	??E?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEAAV012@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEAAV012@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::operator++, COMDAT
; _this$ = ecx

; 403  : 			{	// preincrement

	mov	eax, ecx

; 404  : 			++(*(_Mybase_iter *)this);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 405  : 			return (*this);
; 406  : 			}

	ret	0
??E?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??D?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEABVCvQueuedAttack@@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEABVCvQueuedAttack@@XZ
_TEXT	SEGMENT
??D?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEABVCvQueuedAttack@@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator*, COMDAT
; _this$ = ecx

; 212  : 
; 213  :  #if _HAS_ITERATOR_DEBUGGING
; 214  : 			if (this->_Mycont == 0
; 215  : 				|| _Ptr == 0
; 216  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 217  : 				{
; 218  : 				_DEBUG_ERROR("list iterator not dereferencable");
; 219  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 220  : 				}
; 221  :  #else
; 222  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 223  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 224  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 225  : 
; 226  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 227  : 			}

	ret	0
??D?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEABVCvQueuedAttack@@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV012@H@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV012@H@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator++, COMDAT
; _this$ = ecx

; 256  : 			_Myt_iter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 257  : 			++*this;

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 258  : 			return (_Tmp);
; 259  : 			}

	ret	8
??E?$_Const_iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Const_iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ; std::list<int,std::allocator<int> >::_Iterator<0>::_Iterator<0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z PROC ; std::list<int,std::allocator<int> >::_Iterator<0>::_Iterator<0>, COMDAT
; _this$ = ecx

; 367  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 368  : 			}

	ret	4
??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ENDP ; std::list<int,std::allocator<int> >::_Iterator<0>::_Iterator<0>
_TEXT	ENDS
PUBLIC	??E?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::list<int,std::allocator<int> >::_Iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ PROC ; std::list<int,std::allocator<int> >::_Iterator<0>::operator++, COMDAT
; _this$ = ecx

; 403  : 			{	// preincrement

	mov	eax, ecx

; 404  : 			++(*(_Mybase_iter *)this);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 405  : 			return (*this);
; 406  : 			}

	ret	0
??E?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ENDP ; std::list<int,std::allocator<int> >::_Iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??D?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator*, COMDAT
; _this$ = ecx

; 212  : 
; 213  :  #if _HAS_ITERATOR_DEBUGGING
; 214  : 			if (this->_Mycont == 0
; 215  : 				|| _Ptr == 0
; 216  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 217  : 				{
; 218  : 				_DEBUG_ERROR("list iterator not dereferencable");
; 219  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 220  : 				}
; 221  :  #else
; 222  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 223  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 224  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 225  : 
; 226  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 227  : 			}

	ret	0
??D?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator*
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEPAVCvTacticalTarget@@I@Z ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEPAVCvTacticalTarget@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEPAVCvTacticalTarget@@I@Z PROC ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc@10

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc@10:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEPAVCvTacticalTarget@@I@Z ENDP ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEXPAVCvTacticalTarget@@I@Z ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEXPAVCvTacticalTarget@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEXPAVCvTacticalTarget@@I@Z PROC ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEXPAVCvTacticalTarget@@I@Z ENDP ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 1
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEXXZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEXXZ PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEXXZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@PAVCvTacticalUnit@@@Z ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@PAVCvTacticalUnit@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@PAVCvTacticalUnit@@@Z PROC ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@PAVCvTacticalUnit@@@Z ENDP ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEAAVCvTacticalUnit@@XZ ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEAAVCvTacticalUnit@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEAAVCvTacticalUnit@@XZ PROC ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEAAVCvTacticalUnit@@XZ ENDP ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@PAVCvTacticalCity@@@Z ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@PAVCvTacticalCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@PAVCvTacticalCity@@@Z PROC ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@PAVCvTacticalCity@@@Z ENDP ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@@Z ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@@Z PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@@Z ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAEPAPAVCvTacticalMoveXMLEntry@@I@Z ; std::allocator<CvTacticalMoveXMLEntry *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAEPAPAVCvTacticalMoveXMLEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAEPAPAVCvTacticalMoveXMLEntry@@I@Z PROC ; std::allocator<CvTacticalMoveXMLEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvTacticalMoveXMLEntry@@@std@@YAPAPAVCvTacticalMoveXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvTacticalMoveXMLEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@QAEPAPAVCvTacticalMoveXMLEntry@@I@Z ENDP ; std::allocator<CvTacticalMoveXMLEntry *>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z PROC ; std::list<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 580  : 		return (iterator(_Where._Ptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 581  : 		}

	ret	8
?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ENDP ; std::list<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<int,std::allocator<int> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@@Z PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@@Z ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEIXZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 732  : 		}

	ret	0
?max_size@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvTacticalUnit@@@std@@QAEPAVCvTacticalUnit@@I@Z ; std::allocator<CvTacticalUnit>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvTacticalUnit@@@std@@QAEPAVCvTacticalUnit@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvTacticalUnit@@@std@@QAEPAVCvTacticalUnit@@I@Z PROC ; std::allocator<CvTacticalUnit>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvTacticalUnit@@@std@@YAPAVCvTacticalUnit@@IPAV1@@Z ; std::_Allocate<CvTacticalUnit>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvTacticalUnit@@@std@@QAEPAVCvTacticalUnit@@I@Z ENDP ; std::allocator<CvTacticalUnit>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@@Z PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@@Z ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEIXZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 357913941				; 15555555H

; 732  : 		}

	ret	0
?max_size@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvTacticalCity@@@std@@QAEPAVCvTacticalCity@@I@Z ; std::allocator<CvTacticalCity>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvTacticalCity@@@std@@QAEPAVCvTacticalCity@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvTacticalCity@@@std@@QAEPAVCvTacticalCity@@I@Z PROC ; std::allocator<CvTacticalCity>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvTacticalCity@@@std@@YAPAVCvTacticalCity@@IPAV1@@Z ; std::_Allocate<CvTacticalCity>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvTacticalCity@@@std@@QAEPAVCvTacticalCity@@I@Z ENDP ; std::allocator<CvTacticalCity>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@I@Z ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>::allocate
; Function compile flags: /Ogtpy
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z PROC ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvPlot@@@std@@QAEPAPAVCvPlot@@I@Z ; std::allocator<CvPlot *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvPlot@@@std@@QAEPAPAVCvPlot@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvPlot@@@std@@QAEPAPAVCvPlot@@I@Z PROC ; std::allocator<CvPlot *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvPlot@@@std@@QAEPAPAVCvPlot@@I@Z ENDP ; std::allocator<CvPlot *>::allocate
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@9

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@9:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::Free
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator!=
_TEXT	ENDS
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC		; std::allocator<int>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@3:

; 156  : 		}

	ret	8
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
_TEXT	ENDS
PUBLIC	?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ; std::list<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::list<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 625  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 626  : 		}

	ret	0
?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::list<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_List_nod@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_List_nod<int,std::allocator<int> >::_List_nod<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_nod@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_List_nod<int,std::allocator<int> >::_List_nod<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct allocator from _Al

	mov	eax, ecx

; 48   : 		}

	ret	4
??0?$_List_nod@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_List_nod<int,std::allocator<int> >::_List_nod<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEIXZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEIXZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::max_size, COMDAT
; _this$ = ecx

; 625  : 		return (this->_Alval.max_size());

	mov	eax, 107374182				; 06666666H

; 626  : 		}

	ret	0
?max_size@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEIXZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@V?$allocator@VCvQueuedAttack@@@1@@Z ; std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@V?$allocator@VCvQueuedAttack@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@V?$allocator@VCvQueuedAttack@@@1@@Z PROC ; std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct allocator from _Al

	mov	eax, ecx

; 48   : 		}

	ret	4
??0?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@V?$allocator@VCvQueuedAttack@@@1@@Z ENDP ; std::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_List_nod<CvQueuedAttack,std::allocator<CvQueuedAttack> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator+=
_TEXT	ENDS
PUBLIC	??$?6VCvTemporaryZone@@$09$00$0BCJ@$0A@@@YAAAVFDataStream@@AAV0@ABV?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@@Z ; operator<<<CvTemporaryZone,10,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6VCvTemporaryZone@@$09$00$0BCJ@$0A@@@YAAAVFDataStream@@AAV0@ABV?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
$T242090 = 12						; size = 4
_kVec$ = 12						; size = 4
??$?6VCvTemporaryZone@@$09$00$0BCJ@$0A@@@YAAAVFDataStream@@AAV0@ABV?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@@Z PROC ; operator<<<CvTemporaryZone,10,1,297,0>, COMDAT

; 631  : {

	push	ebp

; 632  : 	kStream << (unsigned int)kVec.size();

	mov	ebp, DWORD PTR _kStream$[esp]
	push	esi
	mov	esi, DWORD PTR _kVec$[esp+4]
	mov	eax, DWORD PTR [esi+4]
	push	edi
	lea	ecx, DWORD PTR $T242090[esp+8]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR $T242090[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 633  : 
; 634  : 	for( unsigned int i = 0; i < kVec.size(); ++i )

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jbe	SHORT $LN16@operator@6
	push	ebx
	xor	ebx, ebx
$LL3@operator@6:

; 635  : 	{
; 636  : 		kStream << kVec[i];

	mov	edx, DWORD PTR [esi]
	add	edx, ebx
	push	edx
	push	ebp
	call	??6@YAAAVFDataStream@@AAV0@ABVCvTemporaryZone@@@Z ; operator<<
	inc	edi
	add	esp, 8
	add	ebx, 20					; 00000014H
	cmp	edi, DWORD PTR [esi+4]
	jb	SHORT $LL3@operator@6
	pop	ebx
$LN16@operator@6:
	pop	edi
	pop	esi

; 637  : 	}
; 638  : 	return kStream;

	mov	eax, ebp
	pop	ebp

; 639  : }

	ret	0
??$?6VCvTemporaryZone@@$09$00$0BCJ@$0A@@@YAAAVFDataStream@@AAV0@ABV?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@@Z ENDP ; operator<<<CvTemporaryZone,10,1,297,0>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ; stdext::unchecked_copy<CvPlot * *,CvPlot * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvPlot * *,CvPlot * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvPlot * *,CvPlot * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvTacticalMoveXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvTacticalMoveXMLEntry * *,CvTacticalMoveXMLEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvTacticalMoveXMLEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvTacticalMoveXMLEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvTacticalMoveXMLEntry * *,CvTacticalMoveXMLEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvTacticalMoveXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvTacticalMoveXMLEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvTacticalMoveXMLEntry * *,CvTacticalMoveXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvTacticalUnit@@PAV1@@stdext@@YAPAVCvTacticalUnit@@PAV1@00@Z ; stdext::unchecked_copy<CvTacticalUnit *,CvTacticalUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAVCvTacticalUnit@@PAV1@@stdext@@YAPAVCvTacticalUnit@@PAV1@00@Z
_TEXT	SEGMENT
$T242167 = -4						; size = 1
__Cat$242172 = -4					; size = 1
$T242169 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvTacticalUnit@@PAV1@@stdext@@YAPAVCvTacticalUnit@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvTacticalUnit *,CvTacticalUnit *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T242167[esp+4], 0
	mov	eax, DWORD PTR $T242167[esp+4]
	mov	ecx, DWORD PTR __Cat$242172[esp+4]
	mov	edx, DWORD PTR $T242169[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>

; 3607 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy@PAVCvTacticalUnit@@PAV1@@stdext@@YAPAVCvTacticalUnit@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvTacticalUnit *,CvTacticalUnit *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvTacticalCity@@PAV1@@stdext@@YAPAVCvTacticalCity@@PAV1@00@Z ; stdext::unchecked_copy<CvTacticalCity *,CvTacticalCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAVCvTacticalCity@@PAV1@@stdext@@YAPAVCvTacticalCity@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvTacticalCity@@PAV1@@stdext@@YAPAVCvTacticalCity@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvTacticalCity *,CvTacticalCity *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@3
	push	esi
$LL9@unchecked_@3:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvTacticalCity@@PAV1@@stdext@@YAPAVCvTacticalCity@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvTacticalCity *,CvTacticalCity *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@@Z ; std::_Destroy_range<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPlot *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@YAXPAPAVCvTacticalMoveXMLEntry@@0AAV?$allocator@PAVCvTacticalMoveXMLEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvTacticalMoveXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@YAXPAPAVCvTacticalMoveXMLEntry@@0AAV?$allocator@PAVCvTacticalMoveXMLEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@YAXPAPAVCvTacticalMoveXMLEntry@@0AAV?$allocator@PAVCvTacticalMoveXMLEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTacticalMoveXMLEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@YAXPAPAVCvTacticalMoveXMLEntry@@0AAV?$allocator@PAVCvTacticalMoveXMLEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTacticalMoveXMLEntry *> >
_TEXT	ENDS
PUBLIC	??$fill@PAVCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@0ABV1@@Z ; std::fill<CvTacticalUnit *,CvTacticalUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAVCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@0ABV1@@Z PROC ; std::fill<CvTacticalUnit *,CvTacticalUnit>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	jmp	??$_Fill@PAVCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@0ABV1@@Z ; std::_Fill<CvTacticalUnit *,CvTacticalUnit>
??$fill@PAVCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@0ABV1@@Z ENDP ; std::fill<CvTacticalUnit *,CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$fill@PAVCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@0ABV1@@Z ; std::fill<CvTacticalCity *,CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAVCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@0ABV1@@Z PROC ; std::fill<CvTacticalCity *,CvTacticalCity>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAVCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@0ABV1@@Z ENDP ; std::fill<CvTacticalCity *,CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ; std::fill<CvPlot * *,CvPlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z PROC ; std::fill<CvPlot * *,CvPlot *>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ENDP ; std::fill<CvPlot * *,CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvQueuedAttack@@V1@@std@@YAXPAVCvQueuedAttack@@ABV1@@Z ; std::_Construct<CvQueuedAttack,CvQueuedAttack>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@VCvQueuedAttack@@V1@@std@@YAXPAVCvQueuedAttack@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvQueuedAttack@@V1@@std@@YAXPAVCvQueuedAttack@@ABV1@@Z PROC ; std::_Construct<CvQueuedAttack,CvQueuedAttack>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@9
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [edx]
	push	esi
	mov	DWORD PTR [eax], ecx
	push	edi
	lea	esi, DWORD PTR [edx+4]
	lea	edi, DWORD PTR [eax+4]
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR [eax+32], ecx
	mov	cl, BYTE PTR [edx+36]
	mov	BYTE PTR [eax+36], cl
	mov	dl, BYTE PTR [edx+37]
	pop	edi
	mov	BYTE PTR [eax+37], dl
	pop	esi
$LN3@Construct@9:

; 53   : 	}

	ret	0
??$_Construct@VCvQueuedAttack@@V1@@std@@YAXPAVCvQueuedAttack@@ABV1@@Z ENDP ; std::_Construct<CvQueuedAttack,CvQueuedAttack>
_TEXT	ENDS
PUBLIC	?GetID@CvCity@@QBEHXZ				; CvCity::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?GetID@CvCity@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvCity@@QBEHXZ PROC				; CvCity::GetID, COMDAT
; _this$ = ecx

; 331  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+120]

; 332  : 	}

	ret	0
?GetID@CvCity@@QBEHXZ ENDP				; CvCity::GetID
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?GetFormationSlot@CvArmyAI@@QAEPAVCvArmyFormationSlot@@H@Z ; CvArmyAI::GetFormationSlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.h
;	COMDAT ?GetFormationSlot@CvArmyAI@@QAEPAVCvArmyFormationSlot@@H@Z
_TEXT	SEGMENT
_iSlotID$ = 8						; size = 4
?GetFormationSlot@CvArmyAI@@QAEPAVCvArmyFormationSlot@@H@Z PROC ; CvArmyAI::GetFormationSlot, COMDAT
; _this$ = ecx

; 142  : 		return &m_FormationEntries[iSlotID];

	mov	eax, DWORD PTR _iSlotID$[esp-4]
	mov	ecx, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 143  : 	};

	ret	4
?GetFormationSlot@CvArmyAI@@QAEPAVCvArmyFormationSlot@@H@Z ENDP ; CvArmyAI::GetFormationSlot
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayerID$ = 8						; size = 4
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlayer::getTeam, COMDAT

; 1173 : 		return CvPreGame::teamType(ePlayerID);

	mov	eax, DWORD PTR _ePlayerID$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1174 : 	}

	ret	0

; 1173 : 		return CvPreGame::teamType(ePlayerID);

$LN3@getTeam:
	or	eax, -1

; 1174 : 	}

	ret	0
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam@2:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_backward_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T242344 = -4						; size = 1
__Cat$242348 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __First_dest_cat$[esp]
	mov	BYTE PTR $T242344[esp+4], 0
	mov	eax, DWORD PTR $T242344[esp+4]
	mov	ecx, DWORD PTR __Cat$242348[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>

; 2755 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Move_backward_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvTacticalCity@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalCity@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvTacticalCity *,CvTacticalCity *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAVCvTacticalCity@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalCity@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvTacticalCity@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalCity@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvTacticalCity *,CvTacticalCity *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAVCvTacticalCity@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalCity@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvTacticalCity *,CvTacticalCity *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@2:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvTacticalUnit@@@std@@QAEXPAVCvTacticalUnit@@ABV3@@Z ; std::allocator<CvTacticalUnit>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@VCvTacticalUnit@@@std@@QAEXPAVCvTacticalUnit@@ABV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvTacticalUnit@@@std@@QAEXPAVCvTacticalUnit@@ABV3@@Z PROC ; std::allocator<CvTacticalUnit>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx
$LN5@construct@4:

; 156  : 		}

	ret	8
?construct@?$allocator@VCvTacticalUnit@@@std@@QAEXPAVCvTacticalUnit@@ABV3@@Z ENDP ; std::allocator<CvTacticalUnit>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCvTacticalUnit@@@std@@QAEXPAVCvTacticalUnit@@@Z ; std::allocator<CvTacticalUnit>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@VCvTacticalUnit@@@std@@QAEXPAVCvTacticalUnit@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvTacticalUnit@@@std@@QAEXPAVCvTacticalUnit@@@Z PROC ; std::allocator<CvTacticalUnit>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@VCvTacticalUnit@@@std@@QAEXPAVCvTacticalUnit@@@Z ENDP ; std::allocator<CvTacticalUnit>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvTacticalCity@@@std@@QAEXPAVCvTacticalCity@@ABV3@@Z ; std::allocator<CvTacticalCity>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@VCvTacticalCity@@@std@@QAEXPAVCvTacticalCity@@ABV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvTacticalCity@@@std@@QAEXPAVCvTacticalCity@@ABV3@@Z PROC ; std::allocator<CvTacticalCity>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@5
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN5@construct@5:

; 156  : 		}

	ret	8
?construct@?$allocator@VCvTacticalCity@@@std@@QAEXPAVCvTacticalCity@@ABV3@@Z ENDP ; std::allocator<CvTacticalCity>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCvTacticalCity@@@std@@QAEXPAVCvTacticalCity@@@Z ; std::allocator<CvTacticalCity>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@VCvTacticalCity@@@std@@QAEXPAVCvTacticalCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvTacticalCity@@@std@@QAEXPAVCvTacticalCity@@@Z PROC ; std::allocator<CvTacticalCity>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@VCvTacticalCity@@@std@@QAEXPAVCvTacticalCity@@@Z ENDP ; std::allocator<CvTacticalCity>::destroy
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isVisible
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 210  : 		if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible

; 211  : 			return false;

	xor	al, al

; 214  : 	}

	ret	4
$LN1@isVisible:

; 212  : 
; 213  : 		return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [ecx+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	setg	dl
	mov	al, dl

; 214  : 	}

	ret	4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 232  : 		PlayerTypes playerID = getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 233  : 		if(playerID != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getTeam@3

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getTeam@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 240  : 		}
; 241  : 	}

	ret	0
$LN2@getTeam@3:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1

; 240  : 		}
; 241  : 	}

	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalMove>::~_Temp_iterator<CvTacticalMove>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@XZ PROC	; std::_Temp_iterator<CvTacticalMove>::~_Temp_iterator<CvTacticalMove>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@XZ ENDP	; std::_Temp_iterator<CvTacticalMove>::~_Temp_iterator<CvTacticalMove>
_TEXT	ENDS
PUBLIC	?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z		; CvPlot::isEnemyCity
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z
_TEXT	SEGMENT
_kUnit$ = 8						; size = 4
?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z PROC		; CvPlot::isEnemyCity, COMDAT
; _this$ = ecx

; 252  : 	{

	push	esi
	mov	esi, ecx

; 253  : 		CvCity* pCity = getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN1@isEnemyCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isEnemyCit
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 254  : 		if(pCity != NULL)

	test	eax, eax
	je	SHORT $LN1@isEnemyCit

; 255  : 			return kUnit.isEnemy(pCity->getTeam(), this);

	push	esi
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	ecx, DWORD PTR _kUnit$[esp+4]
	push	eax
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	pop	esi

; 258  : 	}

	ret	4
$LN1@isEnemyCit:

; 256  : 
; 257  : 		return false;

	xor	al, al
	pop	esi

; 258  : 	}

	ret	4
?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z ENDP		; CvPlot::isEnemyCity
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalTarget>::~_Temp_iterator<CvTacticalTarget>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CvTacticalTarget>::~_Temp_iterator<CvTacticalTarget>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera@2

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera@2:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CvTacticalTarget>::~_Temp_iterator<CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalUnit>::~_Temp_iterator<CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@XZ PROC	; std::_Temp_iterator<CvTacticalUnit>::~_Temp_iterator<CvTacticalUnit>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera@3

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera@3:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@XZ ENDP	; std::_Temp_iterator<CvTacticalUnit>::~_Temp_iterator<CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalCity>::~_Temp_iterator<CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@XZ PROC	; std::_Temp_iterator<CvTacticalCity>::~_Temp_iterator<CvTacticalCity>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera@4

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera@4:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@XZ ENDP	; std::_Temp_iterator<CvTacticalCity>::~_Temp_iterator<CvTacticalCity>
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvBlockingUnit>::~_Temp_iterator<CvBlockingUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@XZ PROC	; std::_Temp_iterator<CvBlockingUnit>::~_Temp_iterator<CvBlockingUnit>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera@5

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera@5:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@XZ ENDP	; std::_Temp_iterator<CvBlockingUnit>::~_Temp_iterator<CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??$_Distance@PAVCvTacticalMove@@H@std@@YAXPAVCvTacticalMove@@0AAH@Z ; std::_Distance<CvTacticalMove *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@PAVCvTacticalMove@@H@std@@YAXPAVCvTacticalMove@@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAVCvTacticalMove@@H@std@@YAXPAVCvTacticalMove@@0AAH@Z PROC ; std::_Distance<CvTacticalMove *,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 3
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@PAVCvTacticalMove@@H@std@@YAXPAVCvTacticalMove@@0AAH@Z ENDP ; std::_Distance<CvTacticalMove *,int>
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	??$_Distance@PAVCvTacticalTarget@@H@std@@YAXPAVCvTacticalTarget@@0AAH@Z ; std::_Distance<CvTacticalTarget *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@PAVCvTacticalTarget@@H@std@@YAXPAVCvTacticalTarget@@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAVCvTacticalTarget@@H@std@@YAXPAVCvTacticalTarget@@0AAH@Z PROC ; std::_Distance<CvTacticalTarget *,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@PAVCvTacticalTarget@@H@std@@YAXPAVCvTacticalTarget@@0AAH@Z ENDP ; std::_Distance<CvTacticalTarget *,int>
_TEXT	ENDS
PUBLIC	??$_Distance@PAVCvBlockingUnit@@H@std@@YAXPAVCvBlockingUnit@@0AAH@Z ; std::_Distance<CvBlockingUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance@PAVCvBlockingUnit@@H@std@@YAXPAVCvBlockingUnit@@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAVCvBlockingUnit@@H@std@@YAXPAVCvBlockingUnit@@0AAH@Z PROC ; std::_Distance<CvBlockingUnit *,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 4
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@PAVCvBlockingUnit@@H@std@@YAXPAVCvBlockingUnit@@0AAH@Z ENDP ; std::_Distance<CvBlockingUnit *,int>
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	??$advance@PAVCvTacticalMove@@H@std@@YAXAAPAVCvTacticalMove@@H@Z ; std::advance<CvTacticalMove *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$advance@PAVCvTacticalMove@@H@std@@YAXAAPAVCvTacticalMove@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAVCvTacticalMove@@H@std@@YAXAAPAVCvTacticalMove@@H@Z PROC ; std::advance<CvTacticalMove *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAVCvTacticalMove@@H@std@@YAXAAPAVCvTacticalMove@@H@Z ENDP ; std::advance<CvTacticalMove *,int>
_TEXT	ENDS
PUBLIC	??$advance@PAVCvTacticalTarget@@H@std@@YAXAAPAVCvTacticalTarget@@H@Z ; std::advance<CvTacticalTarget *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@PAVCvTacticalTarget@@H@std@@YAXAAPAVCvTacticalTarget@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAVCvTacticalTarget@@H@std@@YAXAAPAVCvTacticalTarget@@H@Z PROC ; std::advance<CvTacticalTarget *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAVCvTacticalTarget@@H@std@@YAXAAPAVCvTacticalTarget@@H@Z ENDP ; std::advance<CvTacticalTarget *,int>
_TEXT	ENDS
PUBLIC	??$_Distance2@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance2@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
_TEXT	ENDS
PUBLIC	?GetNumZones@CvTacticalAnalysisMap@@QBEHXZ	; CvTacticalAnalysisMap::GetNumZones
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?GetNumZones@CvTacticalAnalysisMap@@QBEHXZ
_TEXT	SEGMENT
?GetNumZones@CvTacticalAnalysisMap@@QBEHXZ PROC		; CvTacticalAnalysisMap::GetNumZones, COMDAT
; _this$ = ecx

; 624  : 		return m_DominanceZones.size();

	mov	eax, DWORD PTR [ecx+116]

; 625  : 	};

	ret	0
?GetNumZones@CvTacticalAnalysisMap@@QBEHXZ ENDP		; CvTacticalAnalysisMap::GetNumZones
_TEXT	ENDS
PUBLIC	??$_Distance2@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
_TEXT	ENDS
PUBLIC	??MCvTacticalUnit@@QBE_NABV0@@Z			; CvTacticalUnit::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.h
;	COMDAT ??MCvTacticalUnit@@QBE_NABV0@@Z
_TEXT	SEGMENT
_unit$ = 8						; size = 4
??MCvTacticalUnit@@QBE_NABV0@@Z PROC			; CvTacticalUnit::operator<, COMDAT
; _this$ = ecx

; 162  : 		return (GetAttackPriority() > unit.GetAttackPriority());

	mov	eax, DWORD PTR _unit$[esp-4]
	mov	edx, DWORD PTR [eax+8]
	imul	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+8]
	imul	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, edx
	setg	cl
	mov	al, cl

; 163  : 	}

	ret	4
??MCvTacticalUnit@@QBE_NABV0@@Z ENDP			; CvTacticalUnit::operator<
_TEXT	ENDS
PUBLIC	??$advance@PAVCvBlockingUnit@@H@std@@YAXAAPAVCvBlockingUnit@@H@Z ; std::advance<CvBlockingUnit *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$advance@PAVCvBlockingUnit@@H@std@@YAXAAPAVCvBlockingUnit@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAVCvBlockingUnit@@H@std@@YAXAAPAVCvBlockingUnit@@H@Z PROC ; std::advance<CvBlockingUnit *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR __Where$[esp-4]
	shl	ecx, 4
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAVCvBlockingUnit@@H@std@@YAXAAPAVCvBlockingUnit@@H@Z ENDP ; std::advance<CvBlockingUnit *,int>
_TEXT	ENDS
PUBLIC	??MCvTacticalCity@@QBE_NABV0@@Z			; CvTacticalCity::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.h
;	COMDAT ??MCvTacticalCity@@QBE_NABV0@@Z
_TEXT	SEGMENT
_city$ = 8						; size = 4
??MCvTacticalCity@@QBE_NABV0@@Z PROC			; CvTacticalCity::operator<, COMDAT
; _this$ = ecx

; 247  : 		return (GetAttackPriority() > city.GetAttackPriority());

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _city$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 248  : 	}

	ret	4
??MCvTacticalCity@@QBE_NABV0@@Z ENDP			; CvTacticalCity::operator<
_TEXT	ENDS
PUBLIC	??0CvTacticalTarget@@QAE@XZ			; CvTacticalTarget::CvTacticalTarget
; Function compile flags: /Ogtpy
;	COMDAT ??0CvTacticalTarget@@QAE@XZ
_TEXT	SEGMENT
??0CvTacticalTarget@@QAE@XZ PROC			; CvTacticalTarget::CvTacticalTarget, COMDAT
; _this$ = ecx

; 304  : 	CvTacticalTarget()

	mov	eax, ecx

; 305  : 	{
; 306  : 		Clear();

	or	ecx, -1
	xor	edx, edx
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], edx

; 307  : 	};

	ret	0
??0CvTacticalTarget@@QAE@XZ ENDP			; CvTacticalTarget::CvTacticalTarget
_TEXT	ENDS
PUBLIC	??0CvQueuedAttack@@QAE@XZ			; CvQueuedAttack::CvQueuedAttack
; Function compile flags: /Ogtpy
;	COMDAT ??0CvQueuedAttack@@QAE@XZ
_TEXT	SEGMENT
??0CvQueuedAttack@@QAE@XZ PROC				; CvQueuedAttack::CvQueuedAttack, COMDAT
; _this$ = ecx

; 436  : 	CvQueuedAttack()

	mov	eax, ecx
	xor	ecx, ecx
	or	edx, -1
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+28], edx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx

; 437  : 	{
; 438  : 		m_pAttacker = NULL;

	mov	DWORD PTR [eax], ecx

; 439  : 		m_iSeriesID = 0;

	mov	DWORD PTR [eax+32], ecx

; 440  : 		m_bRanged = false;

	mov	BYTE PTR [eax+36], cl

; 441  : 		m_bCityAttack = false;

	mov	BYTE PTR [eax+37], cl

; 442  : 	};

	ret	0
??0CvQueuedAttack@@QAE@XZ ENDP				; CvQueuedAttack::CvQueuedAttack
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::iter_swap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvPlot@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCvPlot@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVCvPlot@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@3
	pop	esi
$LN3@Fill_n@3:

; 3243 : 	}

	ret	0
??$_Fill_n@PAPAVCvPlot@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@4
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@4:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvTacticalMove@@@std@@YA?AU?$pair@PAVCvTacticalMove@@H@0@H@Z ; std::get_temporary_buffer<CvTacticalMove>
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Ogtpy
;	COMDAT ??$get_temporary_buffer@VCvTacticalMove@@@std@@YA?AU?$pair@PAVCvTacticalMove@@H@0@H@Z
_TEXT	SEGMENT
$T242830 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T242834 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvTacticalMove@@@std@@YA?AU?$pair@PAVCvTacticalMove@@H@0@H@Z PROC ; std::get_temporary_buffer<CvTacticalMove>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor
	npad	12
$LL4@get_tempor:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	lea	edx, DWORD PTR [esi*8]
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor
$LN15@get_tempor:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 8
	jae	SHORT $LN5@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T242834[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T242830[esp+20]
	mov	DWORD PTR $T242834[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T242830[esp+20]
	push	ecx
	mov	DWORD PTR $T242830[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor:
$LN17@get_tempor:
	int	3
??$get_temporary_buffer@VCvTacticalMove@@@std@@YA?AU?$pair@PAVCvTacticalMove@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvTacticalTarget@@@std@@YA?AU?$pair@PAVCvTacticalTarget@@H@0@H@Z ; std::get_temporary_buffer<CvTacticalTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$get_temporary_buffer@VCvTacticalTarget@@@std@@YA?AU?$pair@PAVCvTacticalTarget@@H@0@H@Z
_TEXT	SEGMENT
$T242846 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T242850 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvTacticalTarget@@@std@@YA?AU?$pair@PAVCvTacticalTarget@@H@0@H@Z PROC ; std::get_temporary_buffer<CvTacticalTarget>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor@2

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor@2:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor@2
$LL4@get_tempor@2:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi
	add	edx, edx
	add	edx, edx
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor@2
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor@2
$LN15@get_tempor@2:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor@2:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 28					; 0000001cH
	jae	SHORT $LN5@get_tempor@2

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T242850[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T242846[esp+20]
	mov	DWORD PTR $T242850[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T242846[esp+20]
	push	ecx
	mov	DWORD PTR $T242846[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor@2:
$LN17@get_tempor@2:
	int	3
??$get_temporary_buffer@VCvTacticalTarget@@@std@@YA?AU?$pair@PAVCvTacticalTarget@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvTacticalUnit@@@std@@YA?AU?$pair@PAVCvTacticalUnit@@H@0@H@Z ; std::get_temporary_buffer<CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$get_temporary_buffer@VCvTacticalUnit@@@std@@YA?AU?$pair@PAVCvTacticalUnit@@H@0@H@Z
_TEXT	SEGMENT
$T242862 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T242866 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvTacticalUnit@@@std@@YA?AU?$pair@PAVCvTacticalUnit@@H@0@H@Z PROC ; std::get_temporary_buffer<CvTacticalUnit>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor@3

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor@3:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor@3
$LL4@get_tempor@3:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	lea	edx, DWORD PTR [esi+esi*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor@3
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor@3
$LN15@get_tempor@3:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor@3:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN5@get_tempor@3

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T242866[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T242862[esp+20]
	mov	DWORD PTR $T242866[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T242862[esp+20]
	push	ecx
	mov	DWORD PTR $T242862[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor@3:
$LN17@get_tempor@3:
	int	3
??$get_temporary_buffer@VCvTacticalUnit@@@std@@YA?AU?$pair@PAVCvTacticalUnit@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvTacticalCity@@@std@@YA?AU?$pair@PAVCvTacticalCity@@H@0@H@Z ; std::get_temporary_buffer<CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$get_temporary_buffer@VCvTacticalCity@@@std@@YA?AU?$pair@PAVCvTacticalCity@@H@0@H@Z
_TEXT	SEGMENT
$T242878 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T242882 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvTacticalCity@@@std@@YA?AU?$pair@PAVCvTacticalCity@@H@0@H@Z PROC ; std::get_temporary_buffer<CvTacticalCity>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor@4

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor@4:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor@4
$LL4@get_tempor@4:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	lea	edx, DWORD PTR [esi+esi*2]
	add	edx, edx
	add	edx, edx
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor@4
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor@4
$LN15@get_tempor@4:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor@4:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN5@get_tempor@4

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T242882[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T242878[esp+20]
	mov	DWORD PTR $T242882[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T242878[esp+20]
	push	ecx
	mov	DWORD PTR $T242878[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor@4:
$LN17@get_tempor@4:
	int	3
??$get_temporary_buffer@VCvTacticalCity@@@std@@YA?AU?$pair@PAVCvTacticalCity@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvBlockingUnit@@@std@@YA?AU?$pair@PAVCvBlockingUnit@@H@0@H@Z ; std::get_temporary_buffer<CvBlockingUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$get_temporary_buffer@VCvBlockingUnit@@@std@@YA?AU?$pair@PAVCvBlockingUnit@@H@0@H@Z
_TEXT	SEGMENT
$T242894 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T242898 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvBlockingUnit@@@std@@YA?AU?$pair@PAVCvBlockingUnit@@H@0@H@Z PROC ; std::get_temporary_buffer<CvBlockingUnit>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor@5

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor@5:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor@5
$LL4@get_tempor@5:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	mov	edx, esi
	shl	edx, 4
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor@5
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor@5
$LN15@get_tempor@5:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor@5:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN5@get_tempor@5

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T242898[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T242894[esp+20]
	mov	DWORD PTR $T242898[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T242894[esp+20]
	push	ecx
	mov	DWORD PTR $T242894[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor@5:
$LN17@get_tempor@5:
	int	3
??$get_temporary_buffer@VCvBlockingUnit@@@std@@YA?AU?$pair@PAVCvBlockingUnit@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEAAVCvTacticalCity@@XZ ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEAAVCvTacticalCity@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEAAVCvTacticalCity@@XZ PROC ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBEAAVCvTacticalCity@@XZ ENDP ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CvTacticalMove>::_Temp_iterator<CvTacticalMove>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CvTacticalMove>::_Temp_iterator<CvTacticalMove>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CvTacticalMove>::_Temp_iterator<CvTacticalMove>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CvTacticalTarget>::_Temp_iterator<CvTacticalTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CvTacticalTarget>::_Temp_iterator<CvTacticalTarget>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CvTacticalTarget>::_Temp_iterator<CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CvTacticalUnit>::_Temp_iterator<CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CvTacticalUnit>::_Temp_iterator<CvTacticalUnit>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CvTacticalUnit>::_Temp_iterator<CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CvTacticalCity>::_Temp_iterator<CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CvTacticalCity>::_Temp_iterator<CvTacticalCity>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CvTacticalCity>::_Temp_iterator<CvTacticalCity>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CvBlockingUnit>::_Temp_iterator<CvBlockingUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CvBlockingUnit>::_Temp_iterator<CvBlockingUnit>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CvBlockingUnit>::_Temp_iterator<CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAVCvTacticalMove@@PAV1@@std@@YAXPAVCvTacticalMove@@0@Z ; std::iter_swap<CvTacticalMove *,CvTacticalMove *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAVCvTacticalMove@@PAV1@@std@@YAXPAVCvTacticalMove@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAVCvTacticalMove@@PAV1@@std@@YAXPAVCvTacticalMove@@0@Z PROC ; std::iter_swap<CvTacticalMove *,CvTacticalMove *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap@2
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap@2:

; 595  : 	}

	ret	0
??$iter_swap@PAVCvTacticalMove@@PAV1@@std@@YAXPAVCvTacticalMove@@0@Z ENDP ; std::iter_swap<CvTacticalMove *,CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAVCvTacticalTarget@@PAV1@@std@@YAXPAVCvTacticalTarget@@0@Z ; std::iter_swap<CvTacticalTarget *,CvTacticalTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$iter_swap@PAVCvTacticalTarget@@PAV1@@std@@YAXPAVCvTacticalTarget@@0@Z
_TEXT	SEGMENT
__Tmp$242965 = -28					; size = 28
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAVCvTacticalTarget@@PAV1@@std@@YAXPAVCvTacticalTarget@@0@Z PROC ; std::iter_swap<CvTacticalTarget *,CvTacticalTarget *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR __Right$[esp-4]
	sub	esp, 28					; 0000001cH
	cmp	eax, edx
	je	SHORT $LN3@iter_swap@3
	push	esi
	push	edi
	mov	ecx, 7
	mov	esi, eax
	lea	edi, DWORD PTR __Tmp$242965[esp+36]
	rep movsd
	mov	ecx, 7
	mov	esi, edx
	mov	edi, eax
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$242965[esp+36]
	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
$LN3@iter_swap@3:

; 595  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$iter_swap@PAVCvTacticalTarget@@PAV1@@std@@YAXPAVCvTacticalTarget@@0@Z ENDP ; std::iter_swap<CvTacticalTarget *,CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$_Advance@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Advance@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
_TEXT	ENDS
PUBLIC	??$iter_swap@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z ; std::iter_swap<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR __Left$[esp-4]
	push	eax
	push	ecx
	call	??$swap@VCvTacticalUnit@@@std@@YAXAAVCvTacticalUnit@@0@Z ; std::swap<CvTacticalUnit>
	add	esp, 8

; 595  : 	}

	ret	0
??$iter_swap@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Advance@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Advance@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
_TEXT	ENDS
PUBLIC	??$iter_swap@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z ; std::iter_swap<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	ecx, DWORD PTR __Left$[esp-4]
	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, ecx
	cmp	ecx, eax
	je	SHORT $LN11@iter_swap@4
	push	ebx
	mov	ebx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+8], ecx
	pop	ebx
$LN11@iter_swap@4:

; 595  : 	}

	ret	0
??$iter_swap@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$iter_swap@PAVCvBlockingUnit@@PAV1@@std@@YAXPAVCvBlockingUnit@@0@Z ; std::iter_swap<CvBlockingUnit *,CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$iter_swap@PAVCvBlockingUnit@@PAV1@@std@@YAXPAVCvBlockingUnit@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAVCvBlockingUnit@@PAV1@@std@@YAXPAVCvBlockingUnit@@0@Z PROC ; std::iter_swap<CvBlockingUnit *,CvBlockingUnit *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap@5
	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	push	ebp
	mov	ebp, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+12], ebx
	pop	ebx
$LN3@iter_swap@5:

; 595  : 	}

	ret	0
??$iter_swap@PAVCvBlockingUnit@@PAV1@@std@@YAXPAVCvBlockingUnit@@0@Z ENDP ; std::iter_swap<CvBlockingUnit *,CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea
	npad	7
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea
$LN14@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@5
	push	esi
$LL8@unchecked_@5:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@5
	pop	esi
$LN7@unchecked_@5:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@3
	push	esi
$LL6@Uninit_cop@3:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
$LN5@Uninit_cop@3:
	add	ecx, 24					; 00000018H
	add	eax, 24					; 00000018H
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@3
	pop	esi
$LN4@Uninit_cop@3:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@4
	push	esi
$LL6@Uninit_cop@4:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@4
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_cop@4:
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@4
	pop	esi
$LN4@Uninit_cop@4:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??F?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??F?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator--, COMDAT
; _this$ = ecx

; 361  : 		{	// predecrement

	mov	eax, ecx

; 362  : 		--(*(_Mybase *)this);

	add	DWORD PTR [eax], -24			; ffffffe8H

; 363  : 		return (*this);
; 364  : 		}

	ret	0
??F?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator--
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 12			; 0000000cH

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator--, COMDAT
; _this$ = ecx

; 361  : 		{	// predecrement

	mov	eax, ecx

; 362  : 		--(*(_Mybase *)this);

	add	DWORD PTR [eax], -12			; fffffff4H

; 363  : 		return (*this);
; 364  : 		}

	ret	0
??F?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator--
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAVCvTacticalMove@@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvTacticalMove *,CvTacticalMove *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAVCvTacticalMove@@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAVCvTacticalMove@@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@00@Z PROC ; stdext::unchecked_copy_backward<CvTacticalMove *,CvTacticalMove *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@6
	push	esi
$LL8@unchecked_@6:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@6
	pop	esi
$LN7@unchecked_@6:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAVCvTacticalMove@@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@00@Z ENDP ; stdext::unchecked_copy_backward<CvTacticalMove *,CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@PAVCvTacticalMove@@PAV1@PAV1@@std@@YAPAVCvTacticalMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge_backward@PAVCvTacticalMove@@PAV1@PAV1@@std@@YAPAVCvTacticalMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvTacticalMove@@PAV1@PAV1@@std@@YAPAVCvTacticalMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>, COMDAT

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	ecx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	edx, DWORD PTR __Last2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __First1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __First2$[esp+8]
	cmp	esi, ecx
	je	SHORT $LN37@Merge_back
	npad	5
$LL8@Merge_back:

; 2714 : 		else if (_First2 == _Last2)

	cmp	edi, edx
	je	SHORT $LN38@Merge_back

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ebx, DWORD PTR [edx-4]
	sub	edx, 8
	sub	ecx, 8

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	sub	eax, 8
	cmp	ebx, DWORD PTR [ecx+4]
	jle	SHORT $LN2@Merge_back
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	add	edx, 8

; 2718 : 		else

	jmp	SHORT $LN42@Merge_back
$LN2@Merge_back:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	add	ecx, 8
$LN42@Merge_back:
	mov	DWORD PTR [eax+4], ebx
	cmp	esi, ecx
	jne	SHORT $LL8@Merge_back
$LN37@Merge_back:

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ecx, edx
	cmp	edi, edx
	je	SHORT $LN7@Merge_back
	npad	8
$LL18@Merge_back:
	mov	edx, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	cmp	ecx, edi
	jne	SHORT $LL18@Merge_back
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
$LN38@Merge_back:

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	cmp	esi, ecx
	je	SHORT $LN7@Merge_back
	npad	3
$LL28@Merge_back:
	mov	edx, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	cmp	ecx, esi
	jne	SHORT $LL28@Merge_back
$LN7@Merge_back:
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
??$_Merge_backward@PAVCvTacticalMove@@PAV1@PAV1@@std@@YAPAVCvTacticalMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@PAVCvTacticalMove@@V1@H@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvTacticalMove *,CvTacticalMove,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@PAVCvTacticalMove@@V1@H@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvTacticalMove@@V1@H@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvTacticalMove *,CvTacticalMove,int>, COMDAT

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;
; 2255 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN22@Lower_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	npad	6
$LL4@Lower_boun:

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2260 : 		_FwdIt _Mid = _First;
; 2261 : 		std::advance(_Mid, _Count2);
; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	cmp	DWORD PTR [esi+eax*8+4], edi
	jle	SHORT $LN2@Lower_boun

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	sub	edx, eax
	lea	esi, DWORD PTR [esi+eax*8+8]
	add	ecx, edx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2267 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun
	pop	edi
$LN22@Lower_boun:

; 2268 : 		}
; 2269 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2270 : 	}

	ret	0
??$_Lower_bound@PAVCvTacticalMove@@V1@H@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvTacticalMove *,CvTacticalMove,int>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAVCvTacticalMove@@V1@H@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvTacticalMove *,CvTacticalMove,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@PAVCvTacticalMove@@V1@H@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvTacticalMove@@V1@H@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvTacticalMove *,CvTacticalMove,int>, COMDAT

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;
; 2327 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN22@Upper_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	npad	6
$LL4@Upper_boun:

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2331 : 		_FwdIt _Mid = _First;
; 2332 : 		std::advance(_Mid, _Count2);
; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	cmp	edi, DWORD PTR [esi+eax*8+4]
	jg	SHORT $LN2@Upper_boun

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	sub	edx, eax
	lea	esi, DWORD PTR [esi+eax*8+8]
	add	ecx, edx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2338 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun:

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun
	pop	edi
$LN22@Upper_boun:

; 2339 : 		}
; 2340 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2341 : 	}

	ret	0
??$_Upper_bound@PAVCvTacticalMove@@V1@H@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvTacticalMove *,CvTacticalMove,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvTacticalMove@@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@00@Z ; stdext::unchecked_copy<CvTacticalMove *,CvTacticalMove *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvTacticalMove@@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvTacticalMove@@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvTacticalMove *,CvTacticalMove *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@7
	push	esi
$LL9@unchecked_@7:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@7
	pop	esi
$LN7@unchecked_@7:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvTacticalMove@@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvTacticalMove *,CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAVCvTacticalTarget@@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvTacticalTarget *,CvTacticalTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@PAVCvTacticalTarget@@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAVCvTacticalTarget@@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@00@Z PROC ; stdext::unchecked_copy_backward<CvTacticalTarget *,CvTacticalTarget *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First$[esp]
	cmp	ebx, edx
	je	SHORT $LN7@unchecked_@8
	push	esi
	push	edi
$LL8@unchecked_@8:
	sub	edx, 28					; 0000001cH
	sub	eax, 28					; 0000001cH
	mov	ecx, 7
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL8@unchecked_@8
	pop	edi
	pop	esi
$LN7@unchecked_@8:
	pop	ebx

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAVCvTacticalTarget@@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@00@Z ENDP ; stdext::unchecked_copy_backward<CvTacticalTarget *,CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@PAVCvTacticalTarget@@PAV1@PAV1@@std@@YAPAVCvTacticalTarget@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge_backward@PAVCvTacticalTarget@@PAV1@PAV1@@std@@YAPAVCvTacticalTarget@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvTacticalTarget@@PAV1@PAV1@@std@@YAPAVCvTacticalTarget@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>, COMDAT

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	edx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Last2$[esp]
	push	ebp
	mov	ebp, DWORD PTR __First1$[esp+4]
	push	esi
	push	edi
	cmp	ebp, edx
	je	SHORT $LN37@Merge_back@2
$LL8@Merge_back@2:

; 2714 : 		else if (_First2 == _Last2)

	cmp	DWORD PTR __First2$[esp+12], ebx
	je	SHORT $LN38@Merge_back@2

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ecx, DWORD PTR [ebx-8]
	sub	ebx, 28					; 0000001cH
	sub	edx, 28					; 0000001cH

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	sub	eax, 28					; 0000001cH
	cmp	ecx, DWORD PTR [edx+20]
	mov	edi, eax
	mov	ecx, 7
	jle	SHORT $LN2@Merge_back@2
	mov	esi, edx
	add	ebx, 28					; 0000001cH

; 2718 : 		else

	jmp	SHORT $LN42@Merge_back@2
$LN2@Merge_back@2:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	esi, ebx
	add	edx, 28					; 0000001cH
$LN42@Merge_back@2:
	rep movsd
	cmp	ebp, edx
	jne	SHORT $LL8@Merge_back@2
$LN37@Merge_back@2:

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ebp, DWORD PTR __First2$[esp+12]
	mov	edx, ebx
	cmp	ebp, ebx
	je	SHORT $LN7@Merge_back@2
$LL18@Merge_back@2:
	sub	edx, 28					; 0000001cH
	sub	eax, 28					; 0000001cH
	mov	ecx, 7
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebp
	jne	SHORT $LL18@Merge_back@2
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2720 : 	}

	ret	0
$LN38@Merge_back@2:

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	cmp	ebp, edx
	je	SHORT $LN7@Merge_back@2
$LL28@Merge_back@2:
	sub	edx, 28					; 0000001cH
	sub	eax, 28					; 0000001cH
	mov	ecx, 7
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebp
	jne	SHORT $LL28@Merge_back@2
$LN7@Merge_back@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2720 : 	}

	ret	0
??$_Merge_backward@PAVCvTacticalTarget@@PAV1@PAV1@@std@@YAPAVCvTacticalTarget@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@PAVCvTacticalTarget@@V1@H@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvTacticalTarget *,CvTacticalTarget,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@PAVCvTacticalTarget@@V1@H@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvTacticalTarget@@V1@H@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvTacticalTarget *,CvTacticalTarget,int>, COMDAT

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;
; 2255 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN22@Lower_boun@2
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+20]
	npad	6
$LL4@Lower_boun@2:

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2260 : 		_FwdIt _Mid = _First;
; 2261 : 		std::advance(_Mid, _Count2);

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	cmp	DWORD PTR [esi+edx*4+20], edi
	lea	edx, DWORD PTR [esi+edx*4]
	jle	SHORT $LN2@Lower_boun@2

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	esi, DWORD PTR [edx+28]
	or	edx, -1
	sub	edx, eax
	add	ecx, edx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun@2
$LN2@Lower_boun@2:

; 2267 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun@2:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun@2
	pop	edi
$LN22@Lower_boun@2:

; 2268 : 		}
; 2269 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2270 : 	}

	ret	0
??$_Lower_bound@PAVCvTacticalTarget@@V1@H@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvTacticalTarget *,CvTacticalTarget,int>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAVCvTacticalTarget@@V1@H@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvTacticalTarget *,CvTacticalTarget,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@PAVCvTacticalTarget@@V1@H@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvTacticalTarget@@V1@H@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvTacticalTarget *,CvTacticalTarget,int>, COMDAT

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;
; 2327 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN22@Upper_boun@2
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+20]
	npad	6
$LL4@Upper_boun@2:

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2331 : 		_FwdIt _Mid = _First;
; 2332 : 		std::advance(_Mid, _Count2);

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	cmp	edi, DWORD PTR [esi+edx*4+20]
	lea	edx, DWORD PTR [esi+edx*4]
	jg	SHORT $LN2@Upper_boun@2

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	esi, DWORD PTR [edx+28]
	or	edx, -1
	sub	edx, eax
	add	ecx, edx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun@2
$LN2@Upper_boun@2:

; 2338 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun@2:

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun@2
	pop	edi
$LN22@Upper_boun@2:

; 2339 : 		}
; 2340 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2341 : 	}

	ret	0
??$_Upper_bound@PAVCvTacticalTarget@@V1@H@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvTacticalTarget *,CvTacticalTarget,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvTacticalTarget@@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@00@Z ; stdext::unchecked_copy<CvTacticalTarget *,CvTacticalTarget *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvTacticalTarget@@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvTacticalTarget@@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvTacticalTarget *,CvTacticalTarget *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN7@unchecked_@9
	push	esi
	push	edi
$LL9@unchecked_@9:
	mov	esi, edx
	mov	edi, eax
	add	edx, 28					; 0000001cH
	mov	ecx, 7
	add	eax, 28					; 0000001cH
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL9@unchecked_@9
	pop	edi
	pop	esi
$LN7@unchecked_@9:
	pop	ebx

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvTacticalTarget@@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvTacticalTarget *,CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@0@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@0@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T243720 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@0@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T243720[esp+12], edi
	cmp	eax, DWORD PTR __Last$[esp+8]
	je	SHORT $LN1@Copy_opt@8
$LL13@Copy_opt@8:

; 2472 : 		*_Dest = *_First;

	push	eax
	lea	ecx, DWORD PTR __Dest$[esp+12]
	call	??4?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@ABVCvTacticalUnit@@@Z ; std::_Temp_iterator<CvTacticalUnit>::operator=
	mov	eax, DWORD PTR __First$[esp+8]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __First$[esp+8], eax
	cmp	eax, DWORD PTR __Last$[esp+8]
	jne	SHORT $LL13@Copy_opt@8
$LN1@Copy_opt@8:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	eax, DWORD PTR __Dest$[esp+24]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	cmp	eax, edi
	je	SHORT $LN43@Copy_opt@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN43@Copy_opt@8:
	pop	edi
	mov	eax, esi
	pop	esi

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@0@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@0@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@0@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T243789 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@0@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T243789[esp+12], edi
	cmp	ecx, DWORD PTR __Last$[esp+8]
	je	SHORT $LN1@Copy_opt@9
	lea	esi, DWORD PTR [edi+12]
$LL13@Copy_opt@9:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __Dest$[esp+24]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN26@Copy_opt@9
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR __Dest$[esp+24]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN2@Copy_opt@9
$LN26@Copy_opt@9:
	cmp	eax, edi
	je	SHORT $LN31@Copy_opt@9
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Dest$[esp+24]
$LN31@Copy_opt@9:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+24]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Copy_opt@9:
	mov	ecx, DWORD PTR __First$[esp+8]
	add	ecx, esi
	mov	DWORD PTR __First$[esp+8], ecx
	cmp	ecx, DWORD PTR __Last$[esp+8]
	jne	SHORT $LL13@Copy_opt@9
$LN1@Copy_opt@9:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	eax, DWORD PTR __Dest$[esp+24]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	cmp	eax, edi
	je	SHORT $LN53@Copy_opt@9
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN53@Copy_opt@9:
	pop	edi
	mov	eax, esi
	pop	esi

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@0@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvBlockingUnit *,CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z PROC ; stdext::unchecked_copy_backward<CvBlockingUnit *,CvBlockingUnit *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@10
	push	esi
$LL8@unchecked_@10:
	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@10
	pop	esi
$LN7@unchecked_@10:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z ENDP ; stdext::unchecked_copy_backward<CvBlockingUnit *,CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 4
___formal$ = 32						; size = 1
??$_Merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 2839 : 	{	// merge backwards to _Dest, using _Pred

	push	ebx

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	mov	ebx, DWORD PTR __Dest$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+8]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+12]
	cmp	DWORD PTR __First1$[esp+12], esi
	je	$LN13@Merge_back@3
	mov	ebp, DWORD PTR __Pred$[esp+12]
	npad	2
$LL8@Merge_back@3:

; 2843 : 		else if (_First2 == _Last2)

	cmp	DWORD PTR __First2$[esp+12], edi
	je	$LN14@Merge_back@3

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	ecx, DWORD PTR [esi-16]
	mov	edx, DWORD PTR [esi-12]
	sub	esi, 16					; 00000010H
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edi-16]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [edi-12]
	sub	edi, 16					; 00000010H
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	ebp
	add	esp, 32					; 00000020H

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	sub	ebx, 16					; 00000010H
	test	al, al
	je	SHORT $LN2@Merge_back@3
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+8], edx
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ebx+12], eax
	add	edi, 16					; 00000010H

; 2847 : 		else

	jmp	SHORT $LN1@Merge_back@3
$LN2@Merge_back@3:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ebx], ecx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+4], edx
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [ebx+8], eax
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [ebx+12], ecx
	add	esi, 16					; 00000010H
$LN1@Merge_back@3:

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	cmp	DWORD PTR __First1$[esp+12], esi
	jne	$LL8@Merge_back@3
$LN13@Merge_back@3:

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __First2$[esp+12]
	push	ebx
	push	edi
	push	edx

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	call	??$unchecked_copy_backward@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvBlockingUnit *,CvBlockingUnit *>
	add	esp, 12					; 0000000cH

; 2849 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN14@Merge_back@3:

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	eax, DWORD PTR __First1$[esp+12]
	push	ebx
	push	esi
	push	eax
	call	??$unchecked_copy_backward@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvBlockingUnit *,CvBlockingUnit *>
	add	esp, 12					; 0000000cH

; 2849 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@PAVCvBlockingUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Lower_bound<CvBlockingUnit *,CvBlockingUnit,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@PAVCvBlockingUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Lower_bound@PAVCvBlockingUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z PROC ; std::_Lower_bound<CvBlockingUnit *,CvBlockingUnit,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;
; 2292 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+4]
	sub	ebp, ecx
	sar	ebp, 4
	push	esi
	push	edi

; 2293 : 	for (; 0 < _Count; )

	test	ebp, ebp
	jle	SHORT $LN20@Lower_boun@3
	mov	ebx, DWORD PTR __Val$[esp+12]
	jmp	SHORT $LN4@Lower_boun@3
	npad	5
$LL21@Lower_boun@3:
	mov	ecx, DWORD PTR __First$[esp+12]
$LN4@Lower_boun@3:

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ebp
	cdq
	sub	eax, edx

; 2296 : 		_FwdIt _Mid = _First;
; 2297 : 		std::advance(_Mid, _Count2);
; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	mov	edx, DWORD PTR [ebx+4]
	mov	edi, eax
	sar	edi, 1
	mov	esi, edi
	shl	esi, 4
	add	esi, ecx
	mov	ecx, DWORD PTR [ebx]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [esi+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[esp+44]
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN2@Lower_boun@3

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	eax, -1
	add	esi, 16					; 00000010H
	sub	eax, edi
	mov	DWORD PTR __First$[esp+12], esi
	add	ebp, eax

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun@3
$LN2@Lower_boun@3:

; 2303 : 			_Count = _Count2;

	mov	ebp, edi
$LN1@Lower_boun@3:

; 2293 : 	for (; 0 < _Count; )

	test	ebp, ebp
	jg	SHORT $LL21@Lower_boun@3

; 2304 : 		}
; 2305 : 	return (_First);

	mov	eax, DWORD PTR __First$[esp+12]

; 2306 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN20@Lower_boun@3:
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx
	ret	0
??$_Lower_bound@PAVCvBlockingUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ENDP ; std::_Lower_bound<CvBlockingUnit *,CvBlockingUnit,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAVCvBlockingUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Upper_bound<CvBlockingUnit *,CvBlockingUnit,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@PAVCvBlockingUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Upper_bound@PAVCvBlockingUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z PROC ; std::_Upper_bound<CvBlockingUnit *,CvBlockingUnit,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;
; 2363 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+4]
	sub	ebp, ecx
	sar	ebp, 4
	push	esi
	push	edi

; 2364 : 	for (; 0 < _Count; )

	test	ebp, ebp
	jle	$LN20@Upper_boun@3
	mov	ebx, DWORD PTR __Val$[esp+12]
	jmp	SHORT $LN4@Upper_boun@3
	npad	1
$LL21@Upper_boun@3:
	mov	ecx, DWORD PTR __First$[esp+12]
$LN4@Upper_boun@3:

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ebp
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1

; 2367 : 		_FwdIt _Mid = _First;
; 2368 : 		std::advance(_Mid, _Count2);

	mov	esi, edi
	shl	esi, 4

; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	mov	edx, DWORD PTR [esi+ecx+4]
	add	esi, ecx
	mov	ecx, DWORD PTR [esi]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ebx+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[esp+44]
	add	esp, 32					; 00000020H
	test	al, al
	jne	SHORT $LN2@Upper_boun@3

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	eax, -1
	add	esi, 16					; 00000010H
	sub	eax, edi
	mov	DWORD PTR __First$[esp+12], esi
	add	ebp, eax

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun@3
$LN2@Upper_boun@3:

; 2374 : 			_Count = _Count2;

	mov	ebp, edi
$LN1@Upper_boun@3:

; 2364 : 	for (; 0 < _Count; )

	test	ebp, ebp
	jg	SHORT $LL21@Upper_boun@3

; 2375 : 		}
; 2376 : 	return (_First);

	mov	eax, DWORD PTR __First$[esp+12]

; 2377 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN20@Upper_boun@3:
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx
	ret	0
??$_Upper_bound@PAVCvBlockingUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ENDP ; std::_Upper_bound<CvBlockingUnit *,CvBlockingUnit,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z ; stdext::unchecked_copy<CvBlockingUnit *,CvBlockingUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvBlockingUnit *,CvBlockingUnit *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@11
	push	esi
$LL9@unchecked_@11:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@11
	pop	esi
$LN7@unchecked_@11:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvBlockingUnit *,CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	edx, DWORD PTR __First1$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+8]
	cmp	edx, esi
	je	SHORT $LN16@Merge
	npad	5
$LL5@Merge:
	cmp	ecx, edi
	je	SHORT $LN3@Merge

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	ebx, DWORD PTR [ecx+4]
	cmp	ebx, DWORD PTR [edx+4]
	jge	SHORT $LN2@Merge

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	add	ecx, 16					; 00000010H

; 2516 : 		else

	jmp	SHORT $LN40@Merge
$LN2@Merge:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [edx+12]
	add	edx, 16					; 00000010H
$LN40@Merge:
	mov	DWORD PTR [eax+12], ebx
	add	eax, 16					; 00000010H
	cmp	edx, esi
	jne	SHORT $LL5@Merge
$LN3@Merge:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	edx, esi
	je	SHORT $LN16@Merge
$LL18@Merge:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ebx
	add	edx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	edx, esi
	jne	SHORT $LL18@Merge
$LN16@Merge:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	cmp	ecx, edi
	je	SHORT $LN27@Merge
	npad	4
$LL29@Merge:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edi
	jne	SHORT $LL29@Merge
$LN27@Merge:
	pop	edi
	pop	esi
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@@std@@YAPAVCvBlockingUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@@std@@YAPAVCvBlockingUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@@std@@YAPAVCvBlockingUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>, COMDAT

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	ecx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	edx, DWORD PTR __Last2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __First1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __First2$[esp+8]
	cmp	esi, ecx
	je	SHORT $LN15@Merge_back@4
	npad	5
$LL8@Merge_back@4:

; 2714 : 		else if (_First2 == _Last2)

	cmp	edi, edx
	je	SHORT $LN16@Merge_back@4

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ebx, DWORD PTR [edx-12]
	sub	edx, 16					; 00000010H
	sub	ecx, 16					; 00000010H

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	sub	eax, 16					; 00000010H
	cmp	ebx, DWORD PTR [ecx+4]
	jge	SHORT $LN2@Merge_back@4
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	add	edx, 16					; 00000010H

; 2718 : 		else

	jmp	SHORT $LN18@Merge_back@4
$LN2@Merge_back@4:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [edx+12]
	add	ecx, 16					; 00000010H
$LN18@Merge_back@4:
	mov	DWORD PTR [eax+12], ebx
	cmp	esi, ecx
	jne	SHORT $LL8@Merge_back@4
$LN15@Merge_back@4:

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	push	eax
	push	edx
	push	edi

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	call	??$unchecked_copy_backward@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvBlockingUnit *,CvBlockingUnit *>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
$LN16@Merge_back@4:

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	push	eax
	push	ecx
	push	esi
	call	??$unchecked_copy_backward@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvBlockingUnit *,CvBlockingUnit *>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
??$_Merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@@std@@YAPAVCvBlockingUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@PAVCvBlockingUnit@@V1@H@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvBlockingUnit *,CvBlockingUnit,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@PAVCvBlockingUnit@@V1@H@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvBlockingUnit@@V1@H@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvBlockingUnit *,CvBlockingUnit,int>, COMDAT

; 2252 : 	{	// find first element not before _Val, using operator<

	push	esi

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;
; 2255 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	sub	esi, edi
	sar	esi, 4

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	esi, esi
	jle	SHORT $LN22@Lower_boun@4
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR [eax+4]
	npad	5
$LL4@Lower_boun@4:

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1

; 2260 : 		_FwdIt _Mid = _First;
; 2261 : 		std::advance(_Mid, _Count2);

	mov	ecx, eax
	shl	ecx, 4
	add	ecx, edi

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	cmp	DWORD PTR [ecx+4], ebx
	jge	SHORT $LN2@Lower_boun@4

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	edi, DWORD PTR [ecx+16]
	or	ecx, -1
	sub	ecx, eax
	add	esi, ecx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun@4
$LN2@Lower_boun@4:

; 2267 : 			_Count = _Count2;

	mov	esi, eax
$LN1@Lower_boun@4:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	esi, esi
	jg	SHORT $LL4@Lower_boun@4
	pop	ebx
$LN22@Lower_boun@4:

; 2268 : 		}
; 2269 : 	return (_First);

	mov	eax, edi
	pop	edi
	pop	esi

; 2270 : 	}

	ret	0
??$_Lower_bound@PAVCvBlockingUnit@@V1@H@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvBlockingUnit *,CvBlockingUnit,int>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAVCvBlockingUnit@@V1@H@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvBlockingUnit *,CvBlockingUnit,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@PAVCvBlockingUnit@@V1@H@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvBlockingUnit@@V1@H@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvBlockingUnit *,CvBlockingUnit,int>, COMDAT

; 2324 : 	{	// find first element that _Val is before, using operator<

	push	esi

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;
; 2327 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	sub	esi, edi
	sar	esi, 4

; 2328 : 	for (; 0 < _Count; )

	test	esi, esi
	jle	SHORT $LN22@Upper_boun@4
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR [eax+4]
	npad	5
$LL4@Upper_boun@4:

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1

; 2331 : 		_FwdIt _Mid = _First;
; 2332 : 		std::advance(_Mid, _Count2);

	mov	ecx, eax
	shl	ecx, 4
	add	ecx, edi

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	cmp	ebx, DWORD PTR [ecx+4]
	jl	SHORT $LN2@Upper_boun@4

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	edi, DWORD PTR [ecx+16]
	or	ecx, -1
	sub	ecx, eax
	add	esi, ecx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun@4
$LN2@Upper_boun@4:

; 2338 : 			_Count = _Count2;

	mov	esi, eax
$LN1@Upper_boun@4:

; 2328 : 	for (; 0 < _Count; )

	test	esi, esi
	jg	SHORT $LL4@Upper_boun@4
	pop	ebx
$LN22@Upper_boun@4:

; 2339 : 		}
; 2340 : 	return (_First);

	mov	eax, edi
	pop	edi
	pop	esi

; 2341 : 	}

	ret	0
??$_Upper_bound@PAVCvBlockingUnit@@V1@H@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvBlockingUnit *,CvBlockingUnit,int>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@ABVCvTacticalMove@@@Z ; std::_Temp_iterator<CvTacticalMove>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@ABVCvTacticalMove@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@ABVCvTacticalMove@@@Z PROC ; std::_Temp_iterator<CvTacticalMove>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	jae	SHORT $LN2@operator@7
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 8
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@7:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	test	ecx, ecx
	je	SHORT $LN7@operator@7
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
$LN7@operator@7:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 8
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@VCvTacticalMove@@@std@@QAEAAV01@ABVCvTacticalMove@@@Z ENDP ; std::_Temp_iterator<CvTacticalMove>::operator=
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@ABVCvTacticalTarget@@@Z ; std::_Temp_iterator<CvTacticalTarget>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@ABVCvTacticalTarget@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@ABVCvTacticalTarget@@@Z PROC ; std::_Temp_iterator<CvTacticalTarget>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN2@operator@8

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	esi, DWORD PTR __Val$[esp+4]
	mov	edx, ecx
	mov	edi, DWORD PTR [edx+4]
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 28			; 0000001cH
	pop	edi
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@8:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	mov	edi, DWORD PTR [ecx+4]
	test	edi, edi
	je	SHORT $LN7@operator@8
	mov	esi, DWORD PTR __Val$[esp+4]
	mov	ecx, 7
	rep movsd
$LN7@operator@8:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 28			; 0000001cH
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	pop	edi
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEAAV01@ABVCvTacticalTarget@@@Z ENDP ; std::_Temp_iterator<CvTacticalTarget>::operator=
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@ABVCvBlockingUnit@@@Z ; std::_Temp_iterator<CvBlockingUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@ABVCvBlockingUnit@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@ABVCvBlockingUnit@@@Z PROC ; std::_Temp_iterator<CvBlockingUnit>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	jae	SHORT $LN2@operator@9
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], esi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 16			; 00000010H
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@9:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	test	ecx, ecx
	je	SHORT $LN7@operator@9
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], esi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
$LN7@operator@9:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 16			; 00000010H
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@ABVCvBlockingUnit@@@Z ENDP ; std::_Temp_iterator<CvBlockingUnit>::operator=
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<CvTacticalMove *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<CvTacticalMove *>, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00PAH0@Z ; std::_Rotate<CvTacticalMove *,int,CvTacticalMove>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<CvTacticalTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<CvTacticalTarget *>, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00PAH0@Z ; std::_Rotate<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	je	SHORT $LN27@Copy_backw@9
	npad	6
$LL2@Copy_backw@9:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp-4]
	sub	eax, 24					; 00000018H
	mov	DWORD PTR __Last$[esp-4], eax
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR __Dest$[esp-4], ecx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+16], ecx
	mov	eax, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	jne	SHORT $LL2@Copy_backw@9

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2678 : 	}

	ret	0
$LN27@Copy_backw@9:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$advance@PAVCvTacticalUnit@@H@std@@YAXAAPAVCvTacticalUnit@@H@Z ; std::advance<CvTacticalUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@PAVCvTacticalUnit@@H@std@@YAXAAPAVCvTacticalUnit@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAVCvTacticalUnit@@H@std@@YAXAAPAVCvTacticalUnit@@H@Z PROC ; std::advance<CvTacticalUnit *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAVCvTacticalUnit@@H@std@@YAXAAPAVCvTacticalUnit@@H@Z ENDP ; std::advance<CvTacticalUnit *,int>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	cmp	eax, DWORD PTR __Last$[esp-4]
	je	SHORT $LN28@Copy_opt@10
	mov	ecx, 24					; 00000018H
	push	esi
$LL12@Copy_opt@10:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi], edx
	mov	edx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [edx+20], eax
	mov	eax, DWORD PTR __First$[esp]
	add	DWORD PTR __Dest$[esp], ecx
	add	eax, ecx
	mov	DWORD PTR __First$[esp], eax
	cmp	eax, DWORD PTR __Last$[esp]
	jne	SHORT $LL12@Copy_opt@10

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	ecx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2474 : 	}

	ret	0
$LN28@Copy_opt@10:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2474 : 	}

	ret	0
??$_Copy_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	edx, eax
	je	SHORT $LN15@Copy_backw@10
	push	esi
	npad	3
$LL2@Copy_backw@10:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	esi, DWORD PTR [eax-24]
	sub	eax, 24					; 00000018H
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR __Dest$[esp], ecx
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+16], ecx
	mov	ecx, DWORD PTR [eax+20]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+20], ecx
	cmp	eax, edx
	jne	SHORT $LL2@Copy_backw@10

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], edx
	pop	esi

; 2678 : 	}

	ret	0
$LN15@Copy_backw@10:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN16@Copy_opt@11
	push	esi
	mov	edx, 24					; 00000018H
	push	edi
$LL3@Copy_opt@11:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi], esi
	mov	esi, DWORD PTR [eax+4]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+4], esi
	mov	esi, DWORD PTR [eax+8]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+8], esi
	mov	esi, DWORD PTR [eax+12]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+12], esi
	mov	esi, DWORD PTR [eax+16]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+16], esi
	mov	esi, DWORD PTR [eax+20]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+20], esi
	add	DWORD PTR __Dest$[esp+4], edx
	add	eax, edx
	cmp	eax, ecx
	jne	SHORT $LL3@Copy_opt@11

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2474 : 	}

	ret	0
$LN16@Copy_opt@11:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	je	SHORT $LN27@Copy_backw@11
	npad	6
$LL2@Copy_backw@11:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp-4]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR __Last$[esp-4], eax
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[esp-4], ecx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	jne	SHORT $LL2@Copy_backw@11

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2678 : 	}

	ret	0
$LN27@Copy_backw@11:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$advance@PAVCvTacticalCity@@H@std@@YAXAAPAVCvTacticalCity@@H@Z ; std::advance<CvTacticalCity *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@PAVCvTacticalCity@@H@std@@YAXAAPAVCvTacticalCity@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAVCvTacticalCity@@H@std@@YAXAAPAVCvTacticalCity@@H@Z PROC ; std::advance<CvTacticalCity *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAVCvTacticalCity@@H@std@@YAXAAPAVCvTacticalCity@@H@Z ENDP ; std::advance<CvTacticalCity *,int>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	cmp	eax, DWORD PTR __Last$[esp-4]
	je	SHORT $LN28@Copy_opt@12
	mov	ecx, 12					; 0000000cH
	push	esi
$LL12@Copy_opt@12:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi], edx
	mov	edx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR __First$[esp]
	add	DWORD PTR __Dest$[esp], ecx
	add	eax, ecx
	mov	DWORD PTR __First$[esp], eax
	cmp	eax, DWORD PTR __Last$[esp]
	jne	SHORT $LL12@Copy_opt@12

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	ecx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2474 : 	}

	ret	0
$LN28@Copy_opt@12:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2474 : 	}

	ret	0
??$_Copy_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	edx, eax
	je	SHORT $LN15@Copy_backw@12
	push	esi
	npad	3
$LL2@Copy_backw@12:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	esi, DWORD PTR [eax-12]
	sub	eax, 12					; 0000000cH
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[esp], ecx
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+8], ecx
	cmp	eax, edx
	jne	SHORT $LL2@Copy_backw@12

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], edx
	pop	esi

; 2678 : 	}

	ret	0
$LN15@Copy_backw@12:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN16@Copy_opt@13
	push	esi
	mov	edx, 12					; 0000000cH
	push	edi
$LL3@Copy_opt@13:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi], esi
	mov	esi, DWORD PTR [eax+4]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+4], esi
	mov	esi, DWORD PTR [eax+8]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+8], esi
	add	DWORD PTR __Dest$[esp+4], edx
	add	eax, edx
	cmp	eax, ecx
	jne	SHORT $LL3@Copy_opt@13

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2474 : 	}

	ret	0
$LN16@Copy_opt@13:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<CvBlockingUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<CvBlockingUnit *>, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00PAH0@Z ; std::_Rotate<CvBlockingUnit *,int,CvBlockingUnit>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@3
	pop	esi
$LN3@fill@3:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@3
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@3:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@4
	pop	esi
$LN3@Fill_n@4:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@12
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@12:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 245  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	pop	esi

; 261  : }

	ret	0
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 261  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	??0CvTacticalMoveXMLEntry@@QAE@XZ		; CvTacticalMoveXMLEntry::CvTacticalMoveXMLEntry
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
;	COMDAT ??0CvTacticalMoveXMLEntry@@QAE@XZ
_TEXT	SEGMENT
??0CvTacticalMoveXMLEntry@@QAE@XZ PROC			; CvTacticalMoveXMLEntry::CvTacticalMoveXMLEntry, COMDAT
; _this$ = ecx

; 36   : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo

; 37   : 	m_iPriority = -1;
; 38   : 	m_iOffenseWeight = 0;
; 39   : #ifdef AUI_WARNING_FIXES
; 40   : 	m_eMoveType = NO_TACTICAL_MOVE;
; 41   : 	m_iDefenseWeight = 0;
; 42   : 	m_bDominanceZoneMove = false;
; 43   : #else
; 44   : 	m_iOffenseWeight = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+268], eax

; 45   : #endif
; 46   : 	m_bOperationsCanRecruit = false;

	mov	BYTE PTR [esi+276], al
	mov	DWORD PTR [esi], OFFSET ??_7CvTacticalMoveXMLEntry@@6B@
	mov	DWORD PTR [esi+264], -1

; 47   : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvTacticalMoveXMLEntry@@QAE@XZ ENDP			; CvTacticalMoveXMLEntry::CvTacticalMoveXMLEntry
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvTacticalMoveXMLEntry@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvTacticalMoveXMLEntry@@UAEPAXI@Z PROC		; CvTacticalMoveXMLEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvTacticalMoveXMLEntry@@6B@
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvTacticalMoveXMLEntry@@UAEPAXI@Z ENDP		; CvTacticalMoveXMLEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
EXTRN	?isDelayedDeath@CvUnit@@QBE_NXZ:PROC		; CvUnit::isDelayedDeath
EXTRN	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z:PROC ; CvPlot::getVisibleEnemyDefender
; Function compile flags: /Ogtpy
;	COMDAT ?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_m_eAttackingPlayer$ = 8				; size = 4
?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z PROC ; CvTacticalTarget::IsTargetStillAlive, COMDAT
; _this$ = ecx

; 122  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 123  : 	bool bRtnValue = false;
; 124  : 
; 125  : 	AITacticalTargetType eType = GetTargetType();

	mov	eax, DWORD PTR [esi]
	xor	cl, cl
	push	edi
	mov	DWORD PTR _this$[esp+20], esi

; 126  : 	if(eType == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT ||
; 127  : 	        eType == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 128  : 	        eType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)

	cmp	eax, 5
	je	$LN5@IsTargetSt
	cmp	eax, 6
	je	$LN5@IsTargetSt
	cmp	eax, 7
	je	$LN5@IsTargetSt

; 137  : 		}
; 138  : 	}
; 139  : 	else if(eType == AI_TACTICAL_TARGET_CITY)

	cmp	eax, 1
	jne	$LN103@IsTargetSt

; 140  : 	{
; 141  : 		CvCity* pCity;
; 142  : 		CvPlot* pPlot;
; 143  : 		pPlot = GC.getMap().plot(m_iTargetX, m_iTargetY);

	mov	eax, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN53@IsTargetSt
	cmp	ebp, -2147483647			; 80000001H
	je	$LN53@IsTargetSt
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	ecx, DWORD PTR [ebx+4020]
	je	SHORT $LN104@IsTargetSt
	test	eax, eax
	jge	SHORT $LN65@IsTargetSt
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN67@IsTargetSt
$LN65@IsTargetSt:
	cmp	eax, ecx
	jl	SHORT $LN104@IsTargetSt
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN67@IsTargetSt
$LN104@IsTargetSt:
	mov	esi, eax
$LN67@IsTargetSt:
	cmp	BYTE PTR [ebx+4057], 0
	mov	edi, DWORD PTR [ebx+4024]
	je	SHORT $LN106@IsTargetSt
	test	ebp, ebp
	jge	SHORT $LN75@IsTargetSt
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN77@IsTargetSt
$LN75@IsTargetSt:
	cmp	ebp, edi
	jl	SHORT $LN106@IsTargetSt
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN77@IsTargetSt
$LN106@IsTargetSt:
	mov	edx, ebp
$LN77@IsTargetSt:
	test	esi, esi
	jl	SHORT $LN57@IsTargetSt
	cmp	esi, ecx
	jge	SHORT $LN57@IsTargetSt
	test	edx, edx
	jl	SHORT $LN57@IsTargetSt
	cmp	edx, edi
	jge	SHORT $LN57@IsTargetSt
	imul	ecx, edx
	add	ecx, esi
	mov	esi, DWORD PTR _this$[esp+20]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	jmp	SHORT $LN55@IsTargetSt
$LN57@IsTargetSt:
	mov	esi, DWORD PTR _this$[esp+20]
$LN53@IsTargetSt:
	xor	ecx, ecx
$LN55@IsTargetSt:

; 144  : 		pCity = pPlot->getPlotCity();

	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity

; 145  : 		if(pCity != NULL && pCity->getOwner() == GetTargetPlayer())

	test	eax, eax
	je	$LN99@IsTargetSt
	mov	eax, DWORD PTR [eax+84]
	cmp	eax, DWORD PTR [esi+12]
	jne	$LN99@IsTargetSt
	pop	edi
	pop	esi
	pop	ebp

; 146  : 		{
; 147  : 			bRtnValue = true;

	mov	al, 1
	pop	ebx

; 151  : }

	pop	ecx
	ret	4
$LN5@IsTargetSt:

; 129  : 	{
; 130  : 		CvUnit* pUnit;
; 131  : 		CvPlot* pPlot;
; 132  : 		pPlot = GC.getMap().plot(m_iTargetX, m_iTargetY);

	mov	eax, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN13@IsTargetSt
	cmp	ebp, -2147483647			; 80000001H
	je	SHORT $LN13@IsTargetSt
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	ecx, DWORD PTR [ebx+4020]
	je	SHORT $LN23@IsTargetSt
	test	eax, eax
	jge	SHORT $LN25@IsTargetSt
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN27@IsTargetSt
$LN25@IsTargetSt:
	cmp	eax, ecx
	jl	SHORT $LN23@IsTargetSt
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN27@IsTargetSt
$LN23@IsTargetSt:
	mov	esi, eax
$LN27@IsTargetSt:
	cmp	BYTE PTR [ebx+4057], 0
	mov	edi, DWORD PTR [ebx+4024]
	je	SHORT $LN105@IsTargetSt
	test	ebp, ebp
	jge	SHORT $LN35@IsTargetSt
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN37@IsTargetSt
$LN35@IsTargetSt:
	cmp	ebp, edi
	jl	SHORT $LN105@IsTargetSt
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN37@IsTargetSt
$LN105@IsTargetSt:
	mov	edx, ebp
$LN37@IsTargetSt:
	test	esi, esi
	jl	SHORT $LN13@IsTargetSt
	cmp	esi, ecx
	jge	SHORT $LN13@IsTargetSt
	test	edx, edx
	jl	SHORT $LN13@IsTargetSt
	cmp	edx, edi
	jge	SHORT $LN13@IsTargetSt
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	jmp	SHORT $LN15@IsTargetSt
$LN13@IsTargetSt:
	xor	ecx, ecx
$LN15@IsTargetSt:

; 133  : 		pUnit = pPlot->getVisibleEnemyDefender(m_eAttackingPlayer);

	mov	edx, DWORD PTR _m_eAttackingPlayer$[esp+16]
	push	edx
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender

; 134  : 		if(pUnit != NULL && !pUnit->isDelayedDeath())

	test	eax, eax
	je	SHORT $LN99@IsTargetSt
	mov	ecx, eax
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	SHORT $LN99@IsTargetSt
	pop	edi
	pop	esi
	pop	ebp

; 135  : 		{
; 136  : 			bRtnValue = true;

	mov	al, 1
	pop	ebx

; 151  : }

	pop	ecx
	ret	4
$LN99@IsTargetSt:
	pop	edi
	pop	esi
	pop	ebp

; 148  : 		}
; 149  : 	}
; 150  : 	return bRtnValue;

	xor	al, al
	pop	ebx

; 151  : }

	pop	ecx
	ret	4
$LN103@IsTargetSt:
	pop	edi
	pop	esi
	pop	ebp

; 148  : 		}
; 149  : 	}
; 150  : 	return bRtnValue;

	mov	al, cl
	pop	ebx

; 151  : }

	pop	ecx
	ret	4
?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ENDP ; CvTacticalTarget::IsTargetStillAlive
_TEXT	ENDS
PUBLIC	?Write@CvTacticalAI@@QAEXAAVFDataStream@@@Z	; CvTacticalAI::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvTacticalAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_phony$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvTacticalAI@@QAEXAAVFDataStream@@@Z PROC	; CvTacticalAI::Write, COMDAT
; _this$ = ecx

; 349  : {

	push	ecx
	push	esi

; 350  : 	// Current version number
; 351  : 	uint uiVersion = 1;
; 352  : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+4]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+16], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 353  : 	int phony = 0;
; 354  : 	kStream << phony;

	lea	ecx, DWORD PTR _phony$[esp+8]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _phony$[esp+12], 0
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 355  : 	kStream << m_TempZones;

	add	edi, 26380				; 0000670cH
	push	edi
	push	esi
	call	??$?6VCvTemporaryZone@@$09$00$0BCJ@$0A@@@YAAAVFDataStream@@AAV0@ABV?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@@Z ; operator<<<CvTemporaryZone,10,1,297,0>
	add	esp, 8
	pop	edi
	pop	esi

; 356  : }

	pop	ecx
	ret	4
?Write@CvTacticalAI@@QAEXAAVFDataStream@@@Z ENDP	; CvTacticalAI::Write
_TEXT	ENDS
PUBLIC	?IsTemporaryZoneCity@CvTacticalAI@@QAE_NPAVCvCity@@@Z ; CvTacticalAI::IsTemporaryZoneCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsTemporaryZoneCity@CvTacticalAI@@QAE_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?IsTemporaryZoneCity@CvTacticalAI@@QAE_NPAVCvCity@@@Z PROC ; CvTacticalAI::IsTemporaryZoneCity, COMDAT
; _this$ = ecx

; 513  : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR [ecx+26384]

; 514  : 	for(unsigned int iI = 0; iI < m_TempZones.size(); iI++)

	xor	edx, edx
	push	edi
	test	esi, esi
	jbe	SHORT $LN2@IsTemporar
	mov	edi, DWORD PTR _pCity$[esp+12]
	mov	ebx, DWORD PTR [edi+96]
	mov	ecx, DWORD PTR [ecx+26380]
	lea	eax, DWORD PTR [edx+1]
$LL4@IsTemporar:

; 515  : 	{
; 516  : 		if(m_TempZones[iI].GetX() == pCity->getX() &&
; 517  : 		        m_TempZones[iI].GetY() == pCity->getY() &&
; 518  : 		        m_TempZones[iI].GetTargetType() == AI_TACTICAL_TARGET_CITY)

	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN3@IsTemporar
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, DWORD PTR [edi+108]
	jne	SHORT $LN3@IsTemporar
	cmp	DWORD PTR [ecx+8], eax
	je	SHORT $LN5@IsTemporar
$LN3@IsTemporar:

; 514  : 	for(unsigned int iI = 0; iI < m_TempZones.size(); iI++)

	add	edx, eax
	add	ecx, 20					; 00000014H
	cmp	edx, esi
	jb	SHORT $LL4@IsTemporar
$LN2@IsTemporar:

; 519  : 		{
; 520  : 			return true;
; 521  : 		}
; 522  : 	}
; 523  : 	return false;

	xor	al, al
$LN5@IsTemporar:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 524  : }

	ret	4
?IsTemporaryZoneCity@CvTacticalAI@@QAE_NPAVCvCity@@@Z ENDP ; CvTacticalAI::IsTemporaryZoneCity
_TEXT	ENDS
PUBLIC	?SelectPosture@CvTacticalAI@@AAE?AW4AITacticalPosture@@PAVCvTacticalDominanceZone@@W42@@Z ; CvTacticalAI::SelectPosture
EXTRN	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ:PROC ; CvPlayer::GetTacticalAI
EXTRN	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ:PROC ; CvTacticalDominanceZone::GetClosestCity
; Function compile flags: /Ogtpy
;	COMDAT ?SelectPosture@CvTacticalAI@@AAE?AW4AITacticalPosture@@PAVCvTacticalDominanceZone@@W42@@Z
_TEXT	SEGMENT
_eRangedDominance$ = -8					; size = 4
_eUnitCountDominance$ = -4				; size = 4
_pZone$ = 8						; size = 4
_eLastPosture$ = 12					; size = 4
?SelectPosture@CvTacticalAI@@AAE?AW4AITacticalPosture@@PAVCvTacticalDominanceZone@@W42@@Z PROC ; CvTacticalAI::SelectPosture, COMDAT
; _this$ = ecx

; 944  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 945  : 	AITacticalPosture eChosenPosture = AI_TACTICAL_POSTURE_NONE;
; 946  : 	int iDominancePercentage = GC.getGame().GetTacticalAnalysisMap()->GetDominancePercentage();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	or	esi, -1
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap

; 947  : 	eTacticalDominanceFlags eRangedDominance = TACTICAL_DOMINANCE_EVEN;
; 948  : 	eTacticalDominanceFlags eUnitCountDominance = TACTICAL_DOMINANCE_EVEN;
; 949  : 	int iRatio;
; 950  : 
; 951  : 	// Compute who is dominant in various areas
; 952  : 	//   Ranged strength
; 953  : 	if(pZone->GetEnemyRangedStrength() <= 0)

	mov	edi, DWORD PTR _pZone$[esp+20]
	mov	ebx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, 3
	mov	DWORD PTR _eRangedDominance$[esp+24], eax
	mov	DWORD PTR _eUnitCountDominance$[esp+24], eax
	test	ecx, ecx
	jg	SHORT $LN62@SelectPost

; 954  : 	{
; 955  : 		eRangedDominance = TACTICAL_DOMINANCE_FRIENDLY;

	mov	DWORD PTR _eRangedDominance$[esp+24], 1

; 956  : 	}
; 957  : 	else

	jmp	SHORT $LN131@SelectPost
$LN62@SelectPost:

; 958  : 	{
; 959  : 		iRatio = (pZone->GetFriendlyRangedStrength() * 100) / pZone->GetEnemyRangedStrength();

	mov	eax, DWORD PTR [edi+32]
	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx

; 960  : 		if(iRatio > 100 + iDominancePercentage)

	lea	ecx, DWORD PTR [ebx+100]
	cmp	eax, ecx
	jle	SHORT $LN60@SelectPost

; 961  : 		{
; 962  : 			eRangedDominance = TACTICAL_DOMINANCE_FRIENDLY;

	mov	DWORD PTR _eRangedDominance$[esp+24], 1
	jmp	SHORT $LN131@SelectPost
$LN60@SelectPost:

; 963  : 		}
; 964  : 		else if(iRatio < 100 - iDominancePercentage)

	mov	edx, 100				; 00000064H
	sub	edx, ebx
	cmp	eax, edx
	jge	SHORT $LN131@SelectPost

; 965  : 		{
; 966  : 			eRangedDominance = TACTICAL_DOMINANCE_ENEMY;

	mov	DWORD PTR _eRangedDominance$[esp+24], 2
$LN131@SelectPost:

; 967  : 		}
; 968  : 	}
; 969  : 
; 970  : 	//   Number of units
; 971  : 	if(pZone->GetEnemyUnitCount() <= 0)

	mov	ecx, DWORD PTR [edi+44]
	test	ecx, ecx
	jg	SHORT $LN57@SelectPost

; 972  : 	{
; 973  : 		eUnitCountDominance = TACTICAL_DOMINANCE_FRIENDLY;

	mov	ebx, 1

; 974  : 	}
; 975  : 	else

	jmp	SHORT $LN53@SelectPost
$LN57@SelectPost:

; 976  : 	{
; 977  : 		iRatio = (pZone->GetFriendlyUnitCount()  * 100) / pZone->GetEnemyUnitCount();

	mov	eax, DWORD PTR [edi+40]
	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx

; 978  : 		if(iRatio > 100 + iDominancePercentage)

	lea	edx, DWORD PTR [ebx+100]
	cmp	eax, edx
	jle	SHORT $LN55@SelectPost

; 979  : 		{
; 980  : 			eUnitCountDominance = TACTICAL_DOMINANCE_FRIENDLY;

	mov	DWORD PTR _eUnitCountDominance$[esp+24], 1
	jmp	SHORT $LN132@SelectPost
$LN55@SelectPost:

; 981  : 		}
; 982  : 		else if(iRatio < 100 - iDominancePercentage)

	mov	edx, 100				; 00000064H
	sub	edx, ebx
	cmp	eax, edx
	jge	SHORT $LN132@SelectPost

; 983  : 		{
; 984  : 			eUnitCountDominance = TACTICAL_DOMINANCE_ENEMY;

	mov	DWORD PTR _eUnitCountDominance$[esp+24], 2
$LN132@SelectPost:
	mov	ebx, DWORD PTR _eUnitCountDominance$[esp+24]
$LN53@SelectPost:

; 985  : 		}
; 986  : 	}
; 987  : 
; 988  : 	// Choice based on whose territory this is
; 989  : 	switch(pZone->GetTerritoryType())

	mov	eax, DWORD PTR [edi+4]
	dec	eax
	cmp	eax, 4
	ja	$LN2@SelectPost
	jmp	DWORD PTR $LN141@SelectPost[eax*4]
$LN50@SelectPost:

; 990  : 	{
; 991  : 	case TACTICAL_TERRITORY_ENEMY:
; 992  : 	{
; 993  : 		bool bTemporaryZone = false;
; 994  : 		CvCity *pClosestCity = pZone->GetClosestCity();

	mov	ecx, edi
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity

; 995  : 
; 996  : 		// Always push again for a few turns after each operation reaches destination
; 997  : 		if (pClosestCity)

	test	eax, eax
	je	SHORT $LN130@SelectPost

; 998  : 		{
; 999  : 			bTemporaryZone = m_pPlayer->GetTacticalAI()->IsTemporaryZoneCity(pClosestCity);

	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?IsTemporaryZoneCity@CvTacticalAI@@QAE_NPAVCvCity@@@Z ; CvTacticalAI::IsTemporaryZoneCity

; 1000 : 		}
; 1001 : 
; 1002 : 		// Withdraw if enemy dominant overall or we have nothing but ranged left
; 1003 : 		if(!bTemporaryZone && (pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_ENEMY || pZone->GetFriendlyRangedUnitCount() == pZone->GetFriendlyUnitCount()))

	test	al, al
	jne	SHORT $LN129@SelectPost
$LN130@SelectPost:
	mov	eax, DWORD PTR [edi+8]
	cmp	eax, 2
	je	SHORT $LN47@SelectPost
	mov	ecx, DWORD PTR [edi+48]
	cmp	ecx, DWORD PTR [edi+40]
	jne	SHORT $LN45@SelectPost
$LN47@SelectPost:

; 1004 : 		{
; 1005 : 			eChosenPosture = AI_TACTICAL_POSTURE_WITHDRAW;

	xor	esi, esi
	pop	edi

; 1162 : 		{
; 1163 : 			eChosenPosture = AI_TACTICAL_POSTURE_SHORE_BOMBARDMENT;
; 1164 : 		}
; 1165 : 		else
; 1166 : 		{
; 1167 : 			// Should be a barbarian camp
; 1168 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1169 : 		}
; 1170 : 	}
; 1171 : 	}
; 1172 : 
; 1173 : 	return eChosenPosture;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1174 : }

	add	esp, 8
	ret	8
$LN129@SelectPost:

; 1006 : 		}
; 1007 : 
; 1008 : 		// Temporary zone: want Steamroll of Surgical Strike so we close in on city
; 1009 : 		else if (bTemporaryZone)
; 1010 : 		{
; 1011 : 			if (pZone->GetDominanceFlag() != TACTICAL_DOMINANCE_ENEMY)

	xor	edx, edx
	cmp	DWORD PTR [edi+8], 2
	pop	edi
	sete	dl
	add	edx, 4
	mov	esi, edx

; 1162 : 		{
; 1163 : 			eChosenPosture = AI_TACTICAL_POSTURE_SHORE_BOMBARDMENT;
; 1164 : 		}
; 1165 : 		else
; 1166 : 		{
; 1167 : 			// Should be a barbarian camp
; 1168 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1169 : 		}
; 1170 : 	}
; 1171 : 	}
; 1172 : 
; 1173 : 	return eChosenPosture;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1174 : }

	add	esp, 8
	ret	8
$LN45@SelectPost:

; 1012 : 			{
; 1013 : 				eChosenPosture = AI_TACTICAL_POSTURE_STEAMROLL;
; 1014 : 			}
; 1015 : 			else
; 1016 : 			{
; 1017 : 				eChosenPosture = AI_TACTICAL_POSTURE_SURGICAL_CITY_STRIKE;
; 1018 : 			}
; 1019 : 		}
; 1020 : 
; 1021 : 		// Destroy units then assault - for first time need dominance in total strength but not enemy dominance in ranged units OR just double total strength
; 1022 : 		else if(pZone->GetEnemyUnitCount() > 0 && pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_FRIENDLY &&
; 1023 : 		        (eRangedDominance != TACTICAL_DOMINANCE_ENEMY || pZone->GetFriendlyStrength() > pZone->GetEnemyStrength() * 2))

	mov	ecx, DWORD PTR [edi+44]
	test	ecx, ecx
	jle	SHORT $LN133@SelectPost
	cmp	eax, 1
	jne	SHORT $LN133@SelectPost
	cmp	DWORD PTR _eRangedDominance$[esp+24], 2
	jne	SHORT $LN40@SelectPost
	mov	edx, DWORD PTR [edi+28]
	add	edx, edx
	cmp	DWORD PTR [edi+24], edx

; 1024 : 		{
; 1025 : 			eChosenPosture = AI_TACTICAL_POSTURE_STEAMROLL;

	jg	SHORT $LN40@SelectPost
$LN133@SelectPost:

; 1026 : 		}
; 1027 : 
; 1028 : 		//                 - less stringent if continuing this from a previous turn
; 1029 : 		else if(eLastPosture == AI_TACTICAL_POSTURE_STEAMROLL && pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_FRIENDLY && pZone->GetEnemyUnitCount() > 0)

	mov	edx, DWORD PTR _eLastPosture$[esp+20]
	cmp	edx, 4
	jne	SHORT $LN138@SelectPost
	cmp	eax, 1
	jne	SHORT $LN138@SelectPost
	test	ecx, ecx
	jle	SHORT $LN138@SelectPost
$LN40@SelectPost:

; 1030 : 		{
; 1031 : 			eChosenPosture = AI_TACTICAL_POSTURE_STEAMROLL;

	mov	esi, 4
	pop	edi

; 1162 : 		{
; 1163 : 			eChosenPosture = AI_TACTICAL_POSTURE_SHORE_BOMBARDMENT;
; 1164 : 		}
; 1165 : 		else
; 1166 : 		{
; 1167 : 			// Should be a barbarian camp
; 1168 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1169 : 		}
; 1170 : 	}
; 1171 : 	}
; 1172 : 
; 1173 : 	return eChosenPosture;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1174 : }

	add	esp, 8
	ret	8
$LN138@SelectPost:

; 1032 : 		}
; 1033 : 
; 1034 : 		// Sit and bombard - for first time need dominance in ranged strength and total unit count
; 1035 : 		else if(eRangedDominance == TACTICAL_DOMINANCE_FRIENDLY && eUnitCountDominance != TACTICAL_DOMINANCE_ENEMY)

	mov	esi, DWORD PTR _eRangedDominance$[esp+24]
	cmp	esi, 1
	jne	SHORT $LN36@SelectPost
	cmp	ebx, 2

; 1036 : 		{
; 1037 : 			eChosenPosture = AI_TACTICAL_POSTURE_SIT_AND_BOMBARD;

	jne	SHORT $LN139@SelectPost
$LN36@SelectPost:

; 1038 : 		}
; 1039 : 
; 1040 : 		//                 - less stringent if continuing this from a previous turn
; 1041 : 		else if(eLastPosture == AI_TACTICAL_POSTURE_SIT_AND_BOMBARD && eRangedDominance != TACTICAL_DOMINANCE_ENEMY && eUnitCountDominance != TACTICAL_DOMINANCE_ENEMY)

	cmp	edx, 1
	jne	SHORT $LN34@SelectPost
	cmp	esi, 2
	je	SHORT $LN34@SelectPost
	cmp	ebx, 2
	je	SHORT $LN34@SelectPost
$LN139@SelectPost:

; 1042 : 		{
; 1043 : 			eChosenPosture = AI_TACTICAL_POSTURE_SIT_AND_BOMBARD;

	mov	esi, 1
	pop	edi

; 1162 : 		{
; 1163 : 			eChosenPosture = AI_TACTICAL_POSTURE_SHORE_BOMBARDMENT;
; 1164 : 		}
; 1165 : 		else
; 1166 : 		{
; 1167 : 			// Should be a barbarian camp
; 1168 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1169 : 		}
; 1170 : 	}
; 1171 : 	}
; 1172 : 
; 1173 : 	return eChosenPosture;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1174 : }

	add	esp, 8
	ret	8
$LN34@SelectPost:

; 1044 : 		}
; 1045 : 
; 1046 : 		// Go right after the city - need tactical dominance
; 1047 : 		else if(pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_FRIENDLY)

	cmp	eax, 1

; 1048 : 		{
; 1049 : 			eChosenPosture = AI_TACTICAL_POSTURE_SURGICAL_CITY_STRIKE;

	je	SHORT $LN28@SelectPost

; 1050 : 		}
; 1051 : 
; 1052 : 		// Exploit flanks - for first time need dominance in unit count
; 1053 : 		else if(eUnitCountDominance == TACTICAL_DOMINANCE_FRIENDLY && pZone->GetEnemyUnitCount() > 1)

	cmp	ebx, 1
	jne	SHORT $LN30@SelectPost
	cmp	ecx, ebx

; 1054 : 		{
; 1055 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;

	jg	SHORT $LN19@SelectPost
$LN30@SelectPost:

; 1056 : 		}
; 1057 : 
; 1058 : 		//                 - less stringent if continuing this from a previous turn
; 1059 : 		else if(eLastPosture == AI_TACTICAL_POSTURE_EXPLOIT_FLANKS && eUnitCountDominance != TACTICAL_DOMINANCE_ENEMY && pZone->GetEnemyUnitCount() > 1)

	cmp	edx, 3
	jne	SHORT $LN28@SelectPost
	cmp	ebx, 2
	je	SHORT $LN28@SelectPost
	cmp	ecx, 1

; 1060 : 		{
; 1061 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1062 : 		}
; 1063 : 
; 1064 : 		// Default for this zone
; 1065 : 		else

	jg	SHORT $LN19@SelectPost
$LN28@SelectPost:

; 1066 : 		{
; 1067 : 			eChosenPosture = AI_TACTICAL_POSTURE_SURGICAL_CITY_STRIKE;

	mov	esi, 5
	pop	edi

; 1162 : 		{
; 1163 : 			eChosenPosture = AI_TACTICAL_POSTURE_SHORE_BOMBARDMENT;
; 1164 : 		}
; 1165 : 		else
; 1166 : 		{
; 1167 : 			// Should be a barbarian camp
; 1168 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1169 : 		}
; 1170 : 	}
; 1171 : 	}
; 1172 : 
; 1173 : 	return eChosenPosture;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1174 : }

	add	esp, 8
	ret	8
$LN26@SelectPost:

; 1068 : 		}
; 1069 : 		break;
; 1070 : 	}
; 1071 : 
; 1072 : 	case TACTICAL_TERRITORY_NEUTRAL:
; 1073 : 	case TACTICAL_TERRITORY_NO_OWNER:
; 1074 : 	{
; 1075 : 		if(eRangedDominance == TACTICAL_DOMINANCE_FRIENDLY && eUnitCountDominance != TACTICAL_DOMINANCE_ENEMY)

	mov	edx, DWORD PTR _eRangedDominance$[esp+24]
	cmp	edx, 1
	jne	SHORT $LN135@SelectPost
	cmp	ebx, 2

; 1076 : 		{
; 1077 : 			eChosenPosture = AI_TACTICAL_POSTURE_ATTRIT_FROM_RANGE;

	jne	SHORT $LN140@SelectPost
$LN135@SelectPost:

; 1078 : 		}
; 1079 : 
; 1080 : 		//                 - less stringent if continuing this from a previous turn
; 1081 : 		else if(eLastPosture == AI_TACTICAL_POSTURE_ATTRIT_FROM_RANGE && eRangedDominance != TACTICAL_DOMINANCE_ENEMY)

	mov	eax, DWORD PTR _eLastPosture$[esp+20]
	cmp	eax, 2
	jne	SHORT $LN19@SelectPost
	cmp	edx, eax
	je	SHORT $LN19@SelectPost
$LN140@SelectPost:

; 1082 : 		{
; 1083 : 			eChosenPosture = AI_TACTICAL_POSTURE_ATTRIT_FROM_RANGE;

	mov	esi, 2
	pop	edi

; 1162 : 		{
; 1163 : 			eChosenPosture = AI_TACTICAL_POSTURE_SHORE_BOMBARDMENT;
; 1164 : 		}
; 1165 : 		else
; 1166 : 		{
; 1167 : 			// Should be a barbarian camp
; 1168 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1169 : 		}
; 1170 : 	}
; 1171 : 	}
; 1172 : 
; 1173 : 	return eChosenPosture;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1174 : }

	add	esp, 8
	ret	8
$LN19@SelectPost:

; 1084 : 		}
; 1085 : 
; 1086 : 		// Exploit flanks - for first time need dominance in unit count
; 1087 : 		else if(eUnitCountDominance == TACTICAL_DOMINANCE_FRIENDLY && pZone->GetEnemyUnitCount() > 0)
; 1088 : 		{
; 1089 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1090 : 		}
; 1091 : 
; 1092 : 		//                 - less stringent if continuing this from a previous turn
; 1093 : 		else if(eLastPosture == AI_TACTICAL_POSTURE_EXPLOIT_FLANKS && eUnitCountDominance != TACTICAL_DOMINANCE_ENEMY && pZone->GetEnemyUnitCount() > 0)
; 1094 : 		{
; 1095 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1096 : 		}
; 1097 : 
; 1098 : 		// Default for this zone
; 1099 : 		else
; 1100 : 		{
; 1101 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;

	mov	esi, 3
	pop	edi

; 1162 : 		{
; 1163 : 			eChosenPosture = AI_TACTICAL_POSTURE_SHORE_BOMBARDMENT;
; 1164 : 		}
; 1165 : 		else
; 1166 : 		{
; 1167 : 			// Should be a barbarian camp
; 1168 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1169 : 		}
; 1170 : 	}
; 1171 : 	}
; 1172 : 
; 1173 : 	return eChosenPosture;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1174 : }

	add	esp, 8
	ret	8
$LN17@SelectPost:

; 1102 : 		}
; 1103 : 		break;
; 1104 : #ifndef AUI_WARNING_FIXES
; 1105 : 
; 1106 : 		break;
; 1107 : #endif
; 1108 : 	}
; 1109 : 	case TACTICAL_TERRITORY_FRIENDLY:
; 1110 : 	{
; 1111 : 		if(eRangedDominance == TACTICAL_DOMINANCE_FRIENDLY && pZone->GetFriendlyRangedUnitCount() > 1)

	mov	edx, DWORD PTR _eRangedDominance$[esp+24]
	mov	esi, 1
	cmp	edx, esi
	jne	SHORT $LN16@SelectPost
	cmp	DWORD PTR [edi+48], esi

; 1112 : 		{
; 1113 : 			eChosenPosture = AI_TACTICAL_POSTURE_ATTRIT_FROM_RANGE;

	jg	SHORT $LN140@SelectPost
$LN16@SelectPost:

; 1114 : 		}
; 1115 : 
; 1116 : 		//                 - less stringent if continuing this from a previous turn
; 1117 : 		else if(eLastPosture == AI_TACTICAL_POSTURE_ATTRIT_FROM_RANGE && pZone->GetFriendlyRangedUnitCount() > 1 && eRangedDominance != TACTICAL_DOMINANCE_ENEMY)

	mov	eax, DWORD PTR _eLastPosture$[esp+20]
	cmp	eax, 2
	jne	SHORT $LN14@SelectPost
	cmp	DWORD PTR [edi+48], esi
	jle	SHORT $LN14@SelectPost
	cmp	edx, eax

; 1118 : 		{
; 1119 : 			eChosenPosture = AI_TACTICAL_POSTURE_ATTRIT_FROM_RANGE;

	jne	SHORT $LN140@SelectPost
$LN14@SelectPost:

; 1120 : 		}
; 1121 : 
; 1122 : 		// Exploit flanks - for first time need dominance in unit count
; 1123 : 		else if(eUnitCountDominance == TACTICAL_DOMINANCE_FRIENDLY && pZone->GetEnemyUnitCount() > 0)

	cmp	ebx, esi
	jne	SHORT $LN137@SelectPost
	test	ecx, ecx

; 1124 : 		{
; 1125 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;

	jg	SHORT $LN19@SelectPost
$LN137@SelectPost:

; 1126 : 		}
; 1127 : 
; 1128 : 		//                 - less stringent if continuing this from a previous turn
; 1129 : 		else if(eLastPosture == AI_TACTICAL_POSTURE_EXPLOIT_FLANKS && eUnitCountDominance != TACTICAL_DOMINANCE_ENEMY && pZone->GetEnemyUnitCount() > 0)

	cmp	eax, 3
	jne	SHORT $LN10@SelectPost
	cmp	ebx, 2
	je	SHORT $LN10@SelectPost
	test	ecx, ecx

; 1130 : 		{
; 1131 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1132 : 		}
; 1133 : 
; 1134 : 		// Counterattack - for first time must be stronger or even with enemy having a ranged advantage
; 1135 : 		else if(pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_FRIENDLY ||

	jg	SHORT $LN19@SelectPost
$LN10@SelectPost:

; 1136 : #ifdef AUI_WARNING_FIXES
; 1137 : 				(pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_EVEN && eRangedDominance == TACTICAL_DOMINANCE_ENEMY))
; 1138 : #else
; 1139 : 		        pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_EVEN && eRangedDominance == TACTICAL_DOMINANCE_ENEMY)

	mov	edi, DWORD PTR [edi+8]
	cmp	edi, esi
	je	SHORT $LN7@SelectPost
	cmp	edi, 3
	jne	SHORT $LN8@SelectPost
	cmp	edx, 2
	je	SHORT $LN7@SelectPost
$LN8@SelectPost:

; 1143 : 		}
; 1144 : 
; 1145 : 		//                 - less stringent if continuing this from a previous turn
; 1146 : 		else if(eLastPosture == AI_TACTICAL_POSTURE_COUNTERATTACK && pZone->GetDominanceFlag() != TACTICAL_DOMINANCE_ENEMY)

	cmp	eax, 7
	jne	SHORT $LN5@SelectPost
	cmp	edi, 2

; 1147 : 		{
; 1148 : 			eChosenPosture = AI_TACTICAL_POSTURE_COUNTERATTACK;
; 1149 : 		}
; 1150 : 
; 1151 : 		// Default for this zone
; 1152 : 		else

	jne	SHORT $LN7@SelectPost
$LN5@SelectPost:

; 1153 : 		{
; 1154 : 			eChosenPosture = AI_TACTICAL_POSTURE_HEDGEHOG;

	mov	esi, 6
	pop	edi

; 1162 : 		{
; 1163 : 			eChosenPosture = AI_TACTICAL_POSTURE_SHORE_BOMBARDMENT;
; 1164 : 		}
; 1165 : 		else
; 1166 : 		{
; 1167 : 			// Should be a barbarian camp
; 1168 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1169 : 		}
; 1170 : 	}
; 1171 : 	}
; 1172 : 
; 1173 : 	return eChosenPosture;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1174 : }

	add	esp, 8
	ret	8
$LN7@SelectPost:

; 1140 : #endif
; 1141 : 		{
; 1142 : 			eChosenPosture = AI_TACTICAL_POSTURE_COUNTERATTACK;

	mov	esi, 7
	pop	edi

; 1162 : 		{
; 1163 : 			eChosenPosture = AI_TACTICAL_POSTURE_SHORE_BOMBARDMENT;
; 1164 : 		}
; 1165 : 		else
; 1166 : 		{
; 1167 : 			// Should be a barbarian camp
; 1168 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1169 : 		}
; 1170 : 	}
; 1171 : 	}
; 1172 : 
; 1173 : 	return eChosenPosture;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1174 : }

	add	esp, 8
	ret	8
$LN3@SelectPost:

; 1155 : 		}
; 1156 : 		break;
; 1157 : 	}
; 1158 : 	case TACTICAL_TERRITORY_TEMP_ZONE:
; 1159 : 	{
; 1160 : 		// Land or water?
; 1161 : 		if(pZone->IsWater())

	movzx	esi, BYTE PTR [edi+68]
	neg	esi
	sbb	esi, esi
	and	esi, 5
	add	esi, 3
$LN2@SelectPost:
	pop	edi

; 1162 : 		{
; 1163 : 			eChosenPosture = AI_TACTICAL_POSTURE_SHORE_BOMBARDMENT;
; 1164 : 		}
; 1165 : 		else
; 1166 : 		{
; 1167 : 			// Should be a barbarian camp
; 1168 : 			eChosenPosture = AI_TACTICAL_POSTURE_EXPLOIT_FLANKS;
; 1169 : 		}
; 1170 : 	}
; 1171 : 	}
; 1172 : 
; 1173 : 	return eChosenPosture;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1174 : }

	add	esp, 8
	ret	8
$LN141@SelectPost:
	DD	$LN26@SelectPost
	DD	$LN17@SelectPost
	DD	$LN50@SelectPost
	DD	$LN26@SelectPost
	DD	$LN3@SelectPost
?SelectPosture@CvTacticalAI@@AAE?AW4AITacticalPosture@@PAVCvTacticalDominanceZone@@W42@@Z ENDP ; CvTacticalAI::SelectPosture
_TEXT	ENDS
PUBLIC	?FindPosture@CvTacticalAI@@AAE?AW4AITacticalPosture@@PAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::FindPosture
; Function compile flags: /Ogtpy
;	COMDAT ?FindPosture@CvTacticalAI@@AAE?AW4AITacticalPosture@@PAVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
_iI$220782 = 8						; size = 4
_pZone$ = 8						; size = 4
?FindPosture@CvTacticalAI@@AAE?AW4AITacticalPosture@@PAVCvTacticalDominanceZone@@@Z PROC ; CvTacticalAI::FindPosture, COMDAT
; _this$ = ecx

; 1178 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 1179 : 	if(pZone != NULL)

	mov	edi, DWORD PTR _pZone$[esp+12]
	xor	ebp, ebp
	mov	esi, ecx
	cmp	edi, ebp
	je	SHORT $LN4@FindPostur

; 1180 : 	{
; 1181 : 		for(unsigned int iI = 0; iI < m_Postures.size(); iI++)

	mov	DWORD PTR _iI$220782[esp+12], ebp
	cmp	DWORD PTR [esi+24812], ebp
	jbe	SHORT $LN4@FindPostur
	npad	4
$LL6@FindPostur:

; 1182 : 		{
; 1183 : 			if(m_Postures[iI].GetPlayer() == pZone->GetOwner() &&
; 1184 : 			        m_Postures[iI].IsWater() == pZone->IsWater())

	mov	eax, DWORD PTR [esi+24808]
	lea	ecx, DWORD PTR [eax+ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	eax, DWORD PTR [edi+12]
	jne	SHORT $LN5@FindPostur
	mov	cl, BYTE PTR [ecx]
	and	cl, 1
	cmp	cl, BYTE PTR [edi+68]
	jne	SHORT $LN5@FindPostur

; 1185 : 			{
; 1186 : 				int iCityID = -1;
; 1187 : 				if(pZone->GetClosestCity() != NULL)

	mov	ecx, edi
	or	ebx, -1
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	test	eax, eax
	je	SHORT $LN24@FindPostur

; 1188 : 				{
; 1189 : 					iCityID = pZone->GetClosestCity()->GetID();

	mov	ecx, edi
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ebx, DWORD PTR [eax+120]
$LN24@FindPostur:

; 1190 : 				}
; 1191 : 				if(m_Postures[iI].GetCityID() == iCityID)

	mov	edx, DWORD PTR [esi+24808]
	cmp	DWORD PTR [edx+ebp+4], ebx
	je	SHORT $LN37@FindPostur
$LN5@FindPostur:

; 1180 : 	{
; 1181 : 		for(unsigned int iI = 0; iI < m_Postures.size(); iI++)

	mov	eax, DWORD PTR _iI$220782[esp+12]
	inc	eax
	add	ebp, 12					; 0000000cH
	mov	DWORD PTR _iI$220782[esp+12], eax
	cmp	eax, DWORD PTR [esi+24812]
	jb	SHORT $LL6@FindPostur
$LN4@FindPostur:
	pop	edi
	pop	esi
	pop	ebp

; 1194 : 				}
; 1195 : 			}
; 1196 : 		}
; 1197 : 	}
; 1198 : 
; 1199 : 	return AI_TACTICAL_POSTURE_NONE;

	or	eax, -1
	pop	ebx

; 1200 : }

	ret	4
$LN37@FindPostur:

; 1192 : 				{
; 1193 : 					return m_Postures[iI].GetPosture();

	mov	eax, DWORD PTR _iI$220782[esp+12]
	pop	edi
	pop	esi
	lea	eax, DWORD PTR [eax+eax*2]
	mov	ecx, edx
	mov	eax, DWORD PTR [ecx+eax*4+8]
	pop	ebp
	pop	ebx

; 1200 : }

	ret	4
?FindPosture@CvTacticalAI@@AAE?AW4AITacticalPosture@@PAVCvTacticalDominanceZone@@@Z ENDP ; CvTacticalAI::FindPosture
_TEXT	ENDS
PUBLIC	?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotEmergencyPurchases
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z:PROC ; CvMilitaryAI::BuyEmergencyUnit
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
EXTRN	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getNumDefenders
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z:PROC ; CvMilitaryAI::BuyEmergencyBuilding
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z:PROC ; CvTacticalAnalysisMap::GetZone
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ$1
__ehfuncinfo$?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_pCityDefender$ = -28					; size = 8
$T245639 = -20						; size = 8
__$EHRec$ = -12						; size = 12
?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotEmergencyPurchases, COMDAT
; _this$ = ecx

; 3201 : {

	push	-1
	push	__ehhandler$?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx

; 3202 : 	CvCity* pCity;
; 3203 : 	UnitHandle pCityDefender;

	xor	ebx, ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _pCityDefender$[esp+36], ebx
	mov	BYTE PTR _pCityDefender$[esp+40], bl

; 3204 : 	CvUnit* pUnit;
; 3205 : 
; 3206 : 	if(m_pPlayer->isMinorCiv())

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN84@PlotEmerge

; 3207 : 	{
; 3208 : 		return;
; 3209 : 	}
; 3210 : 
; 3211 : 	// Is this a dominance zone where we're defending a city?
; 3212 : 	CvTacticalDominanceZone* pZone = GC.getGame().GetTacticalAnalysisMap()->GetZone(m_iCurrentZoneIndex);

	mov	eax, DWORD PTR [esi+24792]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebp
	push	edi
	push	eax
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	ecx, eax
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
	mov	ebp, eax

; 3213 : 	pCity = pZone->GetClosestCity();

	mov	ecx, ebp
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	edi, eax

; 3214 : 	if(pCity && pCity->getOwner() == m_pPlayer->GetID() && pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY && pZone->GetEnemyUnitCount() > 0)

	cmp	edi, ebx
	je	$LN93@PlotEmerge
	mov	eax, DWORD PTR [edi+84]
	mov	ecx, DWORD PTR [esi]
	cmp	eax, DWORD PTR [ecx+44]
	jne	$LN93@PlotEmerge
	mov	eax, DWORD PTR [ebp+4]
	cmp	eax, 2
	jne	$LN93@PlotEmerge
	cmp	DWORD PTR [ebp+44], ebx
	jle	$LN93@PlotEmerge

; 3215 : 	{
; 3216 : 		// Make sure the city isn't about to fall.  Test by seeing if there are high priority unit targets
; 3217 : 		for(unsigned int iI = 0; iI < m_ZoneTargets.size() && !pCity->isCapital(); iI++)

	mov	eax, DWORD PTR [esi+9340]
	xor	ebp, ebp
	cmp	eax, ebx
	jbe	SHORT $LN91@PlotEmerge
$LL16@PlotEmerge:
	mov	ecx, edi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	jne	SHORT $LN91@PlotEmerge

; 3218 : 		{
; 3219 : 			if(m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)

	mov	edx, DWORD PTR [esi+9336]
	cmp	DWORD PTR [ebx+edx], 7
	je	$LN96@PlotEmerge
	inc	ebp
	add	ebx, 28					; 0000001cH
	cmp	ebp, DWORD PTR [esi+9340]
	jb	SHORT $LL16@PlotEmerge
$LN91@PlotEmerge:

; 3220 : 			{
; 3221 : 				return;   // Abandon hope for this city; save our money to use elsewhere
; 3222 : 			}
; 3223 : 		}
; 3224 : 
; 3225 : 		m_pPlayer->GetMilitaryAI()->BuyEmergencyBuilding(pCity);

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyBuilding

; 3226 : 
; 3227 : 		// If two defenders, assume already have land and sea and skip this city
; 3228 : 		if (pCity->plot()->getNumDefenders(m_pPlayer->GetID()) < 2)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, edi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	cmp	eax, 2
	jge	$LN93@PlotEmerge

; 3229 : 		{
; 3230 : 			bool bBuyNavalUnit = false;
; 3231 : 			bool bBuyLandUnit = false;
; 3232 : 
; 3233 : 			pCityDefender = pCity->plot()->getBestDefender(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+44]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	eax
	lea	edx, DWORD PTR $T245639[esp+72]
	push	edx
	mov	ecx, edi
	xor	bl, bl
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	lea	ecx, DWORD PTR _pCityDefender$[esp+44]
	mov	BYTE PTR __$EHRec$[esp+52], 1
	cmp	eax, ecx
	je	SHORT $LN92@PlotEmerge
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pCityDefender$[esp+44], eax
	test	eax, eax
	je	SHORT $LN92@PlotEmerge
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN92@PlotEmerge:
	mov	ecx, DWORD PTR $T245639[esp+44]
	mov	BYTE PTR __$EHRec$[esp+52], 0
	test	ecx, ecx
	je	SHORT $LN75@PlotEmerge
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN75@PlotEmerge:

; 3234 : 			if (!pCityDefender)

	mov	ecx, DWORD PTR _pCityDefender$[esp+44]
	test	ecx, ecx
	jne	$LN11@PlotEmerge

; 3235 : 			{
; 3236 : 				bBuyLandUnit = true;
; 3237 : 				if (pCity->isCoastal())

	push	-1
	mov	ecx, edi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN8@PlotEmerge

; 3238 : 				{
; 3239 : 					bBuyNavalUnit = true;

	mov	bl, 1
$LN8@PlotEmerge:

; 3252 : 				{
; 3253 : 					bBuyLandUnit = true;
; 3254 : 				}
; 3255 : 			}
; 3256 : 
; 3257 : 			if (bBuyLandUnit)
; 3258 : 			{
; 3259 : 				pUnit = m_pPlayer->GetMilitaryAI()->BuyEmergencyUnit(UNITAI_CITY_BOMBARD, pCity);

	mov	ecx, DWORD PTR [esi]
	push	edi
	push	4
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit

; 3260 : 				if(!pUnit)

	test	eax, eax
	jne	SHORT $LN4@PlotEmerge

; 3261 : 				{
; 3262 : 					pUnit = m_pPlayer->GetMilitaryAI()->BuyEmergencyUnit(UNITAI_RANGED, pCity);

	mov	ecx, DWORD PTR [esi]
	push	edi
	push	8
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
$LN4@PlotEmerge:

; 3263 : 				}
; 3264 : 			}
; 3265 : 
; 3266 : 			if (bBuyNavalUnit)

	test	bl, bl
$LN98@PlotEmerge:
	je	SHORT $LN2@PlotEmerge

; 3267 : 			{
; 3268 : 				pUnit = m_pPlayer->GetMilitaryAI()->BuyEmergencyUnit(UNITAI_ASSAULT_SEA, pCity);

	mov	ecx, DWORD PTR [esi]
	push	edi
	push	22					; 00000016H
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
$LN2@PlotEmerge:

; 3269 : 				if (pUnit)
; 3270 : 				{
; 3271 : 					// Bought one, don't need to buy melee naval later
; 3272 : 					bBuyNavalUnit = false;
; 3273 : 				}
; 3274 : 			}
; 3275 : 
; 3276 : 			// Always can try to buy air units
; 3277 : 			pUnit = m_pPlayer->GetMilitaryAI()->BuyEmergencyUnit(UNITAI_ATTACK_AIR, pCity);

	mov	ecx, DWORD PTR [esi]
	push	edi
	push	27					; 0000001bH
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit

; 3278 : 			if (!pUnit)

	test	eax, eax
	jne	SHORT $LN93@PlotEmerge

; 3279 : 			{
; 3280 : 				pUnit = m_pPlayer->GetMilitaryAI()->BuyEmergencyUnit(UNITAI_DEFENSE_AIR, pCity);

	mov	ecx, DWORD PTR [esi]
	push	edi
	push	28					; 0000001cH
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
$LN93@PlotEmerge:

; 3281 : 			}
; 3282 : 
; 3283 : 			// Melee naval if didn't buy Ranged naval, (or not)
; 3284 : 			//if (bBuyNavalUnit)
; 3285 : 			//{
; 3286 : 			//	pUnit = m_pPlayer->GetMilitaryAI()->BuyEmergencyUnit(UNITAI_ATTACK_SEA, pCity);
; 3287 : 			//}
; 3288 : 		}
; 3289 : 	}
; 3290 : }

	mov	ecx, DWORD PTR _pCityDefender$[esp+44]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	ecx, ecx
	je	SHORT $LN96@PlotEmerge
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN96@PlotEmerge:
	pop	edi
	pop	ebp
$LN84@PlotEmerge:
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	0
$LN11@PlotEmerge:

; 3240 : 				}
; 3241 : 			}
; 3242 : 			else
; 3243 : 			{
; 3244 : 				if (pCityDefender->getDomainType() == DOMAIN_LAND)

	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	$LN8@PlotEmerge

; 3245 : 				{
; 3246 : 					if (pCity->isCoastal())

	push	-1
	mov	ecx, edi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al

; 3247 : 					{
; 3248 : 						bBuyNavalUnit = true;
; 3249 : 					}
; 3250 : 				}
; 3251 : 				else

	jmp	SHORT $LN98@PlotEmerge
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pCityDefender$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR $T245639[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotEmergencyPurchases
PUBLIC	?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ ; CvTacticalAI::IdentifyPriorityBarbarianTargets
EXTRN	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z:PROC ; CanReachInXTurns
EXTRN	?canEverRangeStrikeAt@CvUnit@@QBE_NHH@Z:PROC	; CvUnit::canEverRangeStrikeAt
EXTRN	?GetRange@CvUnit@@QBEHXZ:PROC			; CvUnit::GetRange
EXTRN	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z:PROC ; CvUnit::GetMaxRangedCombatStrength
EXTRN	?GetMaxAttackStrength@CvUnit@@QBEHPBVCvPlot@@0PBV1@@Z:PROC ; CvUnit::GetMaxAttackStrength
EXTRN	?IsCanAttackRanged@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttackRanged
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_pLoopPlot$ = -40					; size = 4
$T245785 = -36						; size = 4
_pTarget$ = -36						; size = 4
tv521 = -32						; size = 4
_this$ = -28						; size = 4
_iI$223093 = -24					; size = 4
_pEnemyUnit$223104 = -20				; size = 8
__$EHRec$ = -12						; size = 12
?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ PROC ; CvTacticalAI::IdentifyPriorityBarbarianTargets, COMDAT
; _this$ = ecx

; 5936 : {

	push	-1
	push	__ehhandler$?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 5937 : 	CvPlot* pLoopPlot;
; 5938 : 	CvTacticalTarget* pTarget;
; 5939 : 
; 5940 : #ifdef AUI_WARNING_FIXES
; 5941 : 	for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 5942 : #else
; 5943 : 	for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	ebp
	mov	ebp, ecx
	xor	ecx, ecx
	cmp	DWORD PTR [eax+4028], ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+56], ebp
	mov	DWORD PTR _iI$223093[esp+56], ecx
	jle	$LN11@IdentifyPr
	mov	DWORD PTR tv521[esp+56], ecx
	npad	3
$LL13@IdentifyPr:

; 5944 : #endif
; 5945 : 	{
; 5946 : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	edi, DWORD PTR [eax+4068]
	add	edi, DWORD PTR tv521[esp+56]

; 5947 : 		if(pLoopPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	ecx, edi
	mov	DWORD PTR _pLoopPlot$[esp+56], edi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, esi
	jne	$LN12@IdentifyPr

; 5948 : 		{
; 5949 : 			pTarget = GetFirstUnitTarget();

	mov	ecx, ebp
	call	?GetFirstUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetFirstUnitTarget
	mov	ebx, eax
	mov	DWORD PTR _pTarget$[esp+56], ebx

; 5950 : 			while(pTarget != NULL)

	test	ebx, ebx
	je	$LN12@IdentifyPr
	jmp	SHORT $LN9@IdentifyPr
	npad	6
$LL131@IdentifyPr:
	mov	ebx, DWORD PTR _pTarget$[esp+56]
$LN9@IdentifyPr:

; 5951 : 			{
; 5952 : 				bool bPriorityTarget = false;
; 5953 : 
; 5954 : 				// Skip if already a priority target (because was able to strike another camp)
; 5955 : 				if(pTarget->GetTargetType() != AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)

	cmp	DWORD PTR [ebx], 7
	je	$LN123@IdentifyPr

; 5956 : 				{
; 5957 : 					CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [ebx+4]
	mov	ebp, DWORD PTR [ebx+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN36@IdentifyPr
	cmp	ebp, -2147483647			; 80000001H
	je	$LN36@IdentifyPr
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN46@IdentifyPr
	test	eax, eax
	jge	SHORT $LN48@IdentifyPr
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN50@IdentifyPr
$LN48@IdentifyPr:
	cmp	eax, ecx
	jl	SHORT $LN46@IdentifyPr
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN50@IdentifyPr
$LN46@IdentifyPr:
	mov	esi, eax
$LN50@IdentifyPr:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN56@IdentifyPr
	test	ebp, ebp
	jge	SHORT $LN58@IdentifyPr
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN60@IdentifyPr
$LN58@IdentifyPr:
	cmp	ebp, edi
	jl	SHORT $LN56@IdentifyPr
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN60@IdentifyPr
$LN56@IdentifyPr:
	mov	edx, ebp
$LN60@IdentifyPr:
	test	esi, esi
	jl	SHORT $LN40@IdentifyPr
	cmp	esi, ecx
	jge	SHORT $LN40@IdentifyPr
	test	edx, edx
	jl	SHORT $LN40@IdentifyPr
	cmp	edx, edi
	jge	SHORT $LN40@IdentifyPr
	mov	edi, DWORD PTR _pLoopPlot$[esp+56]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	ebx, DWORD PTR _pTarget$[esp+56]
	jmp	SHORT $LN38@IdentifyPr
$LN40@IdentifyPr:
	mov	edi, DWORD PTR _pLoopPlot$[esp+56]
	mov	ebx, DWORD PTR _pTarget$[esp+56]
$LN36@IdentifyPr:
	xor	ecx, ecx
$LN38@IdentifyPr:

; 5958 : 					UnitHandle pEnemyUnit = pPlot->getVisibleEnemyDefender(m_pPlayer->GetID());

	mov	eax, DWORD PTR _this$[esp+56]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	mov	esi, eax
	mov	DWORD PTR _pEnemyUnit$223104[esp+56], esi
	mov	BYTE PTR _pEnemyUnit$223104[esp+60], 0
	test	esi, esi
	je	SHORT $LN81@IdentifyPr
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN81@IdentifyPr:

; 5959 : 					if(pEnemyUnit->IsCanAttackRanged() && pEnemyUnit->GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true) > pEnemyUnit->GetMaxAttackStrength(NULL, pLoopPlot, NULL))

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+64], 0
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	SHORT $LN6@IdentifyPr
	push	0
	push	edi
	push	0
	mov	ecx, esi
	call	?GetMaxAttackStrength@CvUnit@@QBEHPBVCvPlot@@0PBV1@@Z ; CvUnit::GetMaxAttackStrength
	push	1
	push	1
	push	0
	push	0
	mov	ecx, esi
	mov	ebp, eax
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength
	cmp	eax, ebp
	jle	SHORT $LN6@IdentifyPr

; 5960 : 					{
; 5961 : 						if(plotDistance(pEnemyUnit->getX(), pEnemyUnit->getY(), pLoopPlot->getX(), pLoopPlot->getY()) <= pEnemyUnit->GetRange())

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	mov	edx, DWORD PTR [esi+88]
	mov	edi, DWORD PTR [esi+76]
	push	eax
	push	ecx
	push	edx
	push	edi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	ecx, esi
	mov	edi, eax
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	cmp	edi, eax
	jg	SHORT $LN134@IdentifyPr

; 5962 : 						{
; 5963 : 							if(pEnemyUnit->canEverRangeStrikeAt(pLoopPlot->getX(), pLoopPlot->getY()))

	mov	ecx, DWORD PTR _pLoopPlot$[esp+56]
	movsx	eax, WORD PTR [ecx+2]
	movsx	ecx, WORD PTR [ecx]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?canEverRangeStrikeAt@CvUnit@@QBE_NHH@Z	; CvUnit::canEverRangeStrikeAt
	test	al, al
	je	SHORT $LN134@IdentifyPr

; 5964 : 							{
; 5965 : 								bPriorityTarget = true;
; 5966 : 							}
; 5967 : 						}
; 5968 : 					}

	mov	ebx, DWORD PTR _pTarget$[esp+56]
	mov	edi, DWORD PTR _pLoopPlot$[esp+56]

; 5970 : 					{
; 5971 : 						bPriorityTarget = true;
; 5972 : 					}
; 5973 : 					if(bPriorityTarget)
; 5974 : 					{
; 5975 : 						pTarget->SetTargetType(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT);

	mov	DWORD PTR [ebx], 7
	jmp	SHORT $LN118@IdentifyPr
$LN6@IdentifyPr:

; 5969 : 					else if(CanReachInXTurns(pEnemyUnit, pLoopPlot, 1))

	push	0
	push	0
	push	1
	push	edi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T245785[esp+80], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	test	esi, esi
	je	SHORT $LN116@IdentifyPr
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN116@IdentifyPr:
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	test	al, al
	je	SHORT $LN118@IdentifyPr

; 5970 : 					{
; 5971 : 						bPriorityTarget = true;
; 5972 : 					}
; 5973 : 					if(bPriorityTarget)
; 5974 : 					{
; 5975 : 						pTarget->SetTargetType(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT);

	mov	DWORD PTR [ebx], 7
	jmp	SHORT $LN118@IdentifyPr
$LN134@IdentifyPr:
	mov	edi, DWORD PTR _pLoopPlot$[esp+56]
$LN118@IdentifyPr:

; 5976 : 					}
; 5977 : 				}

	mov	DWORD PTR __$EHRec$[esp+64], -1
	test	esi, esi
	je	SHORT $LN123@IdentifyPr
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN123@IdentifyPr:

; 5978 : 				pTarget = GetNextUnitTarget();

	mov	ebp, DWORD PTR _this$[esp+56]
	mov	ecx, ebp
	call	?GetNextUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextUnitTarget
	mov	DWORD PTR _pTarget$[esp+56], eax
	test	eax, eax
	jne	$LL131@IdentifyPr
$LN12@IdentifyPr:

; 5937 : 	CvPlot* pLoopPlot;
; 5938 : 	CvTacticalTarget* pTarget;
; 5939 : 
; 5940 : #ifdef AUI_WARNING_FIXES
; 5941 : 	for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 5942 : #else
; 5943 : 	for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	ecx, DWORD PTR _iI$223093[esp+56]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv521[esp+56], 484		; 000001e4H
	inc	ecx
	cmp	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR _iI$223093[esp+56], ecx
	jl	$LL13@IdentifyPr
$LN11@IdentifyPr:

; 5979 : 			}
; 5980 : 		}
; 5981 : 	}
; 5982 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pEnemyUnit$223104[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ ENDP ; CvTacticalAI::IdentifyPriorityBarbarianTargets
PUBLIC	?IdentifyPriorityTargetsByType@CvTacticalAI@@AAEXXZ ; CvTacticalAI::IdentifyPriorityTargetsByType
EXTRN	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetNearbyEnemyDamage
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
; Function compile flags: /Ogtpy
;	COMDAT ?IdentifyPriorityTargetsByType@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_iI$223115 = -4						; size = 4
?IdentifyPriorityTargetsByType@CvTacticalAI@@AAEXXZ PROC ; CvTacticalAI::IdentifyPriorityTargetsByType, COMDAT
; _this$ = ecx

; 5986 : {

	push	ecx
	push	ebx
	push	edi

; 5987 : 	// Look through all the enemies we can see
; 5988 : 	for(unsigned int iI = 0; iI < m_AllTargets.size(); iI++)

	xor	ebx, ebx
	mov	edi, ecx
	mov	DWORD PTR _iI$223115[esp+12], ebx
	cmp	DWORD PTR [edi+2156], ebx
	jbe	$LN7@IdentifyPr@2
	push	ebp
	push	esi
	npad	7
$LL9@IdentifyPr@2:

; 5989 : 	{
; 5990 : 		// Don't consider units that are already medium priority
; 5991 : 		if(m_AllTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 5992 : 		        m_AllTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	mov	eax, DWORD PTR [edi+2152]
	lea	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 7
	je	SHORT $LN54@IdentifyPr@2
	cmp	eax, 5
	jne	SHORT $LN57@IdentifyPr@2
$LN54@IdentifyPr@2:

; 5993 : 		{
; 5994 : 			// Ranged units will always be medium priority targets
; 5995 : 			CvUnit* pUnit = (CvUnit*)m_AllTargets[iI].GetAuxData();
; 5996 : 			if(pUnit->IsCanAttackRanged())

	mov	ecx, DWORD PTR [ecx+16]
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	SHORT $LN57@IdentifyPr@2

; 5997 : 			{
; 5998 : 				m_AllTargets[iI].SetTargetType(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT);

	mov	ecx, DWORD PTR [edi+2152]
	mov	DWORD PTR [ebx+ecx], 6
$LN57@IdentifyPr@2:

; 5999 : 			}
; 6000 : 		}
; 6001 : 
; 6002 : 		// Don't consider units that are already high priority
; 6003 : 		if(m_AllTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 6004 : 		        m_AllTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	mov	edx, DWORD PTR [edi+2152]
	mov	ecx, DWORD PTR [ebx+edx]
	lea	eax, DWORD PTR [ebx+edx]
	cmp	ecx, 6
	je	SHORT $LN2@IdentifyPr@2
	cmp	ecx, 5
	jne	SHORT $LN8@IdentifyPr@2
$LN2@IdentifyPr@2:

; 6005 : 		{
; 6006 : 			// Units defending citadels will always be high priority targets
; 6007 : 			CvUnit* pUnit = (CvUnit*)m_AllTargets[iI].GetAuxData();

	mov	esi, DWORD PTR [eax+16]

; 6008 : 			ImprovementTypes eImprovement = pUnit->plot()->getImprovementType();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType

; 6009 : 			if(pUnit->plot()->getOwner() == pUnit->getOwner() &&
; 6010 : 			        eImprovement != NO_IMPROVEMENT && GC.getImprovementInfo(eImprovement)->GetNearbyEnemyDamage() > 0)

	mov	ecx, esi
	mov	ebp, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	eax, BYTE PTR [eax+4]
	cmp	eax, DWORD PTR [esi+40]
	jne	SHORT $LN8@IdentifyPr@2
	cmp	ebp, -1
	je	SHORT $LN8@IdentifyPr@2
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetNearbyEnemyDamage
	test	eax, eax
	jle	SHORT $LN8@IdentifyPr@2

; 6011 : 			{
; 6012 : 				m_AllTargets[iI].SetTargetType(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT);

	mov	ecx, DWORD PTR [edi+2152]
	mov	DWORD PTR [ebx+ecx], 7
$LN8@IdentifyPr@2:
	mov	eax, DWORD PTR _iI$223115[esp+20]
	inc	eax
	add	ebx, 28					; 0000001cH
	mov	DWORD PTR _iI$223115[esp+20], eax
	cmp	eax, DWORD PTR [edi+2156]
	jb	$LL9@IdentifyPr@2
	pop	esi
	pop	ebp
$LN7@IdentifyPr@2:
	pop	edi
	pop	ebx

; 6013 : 			}
; 6014 : 		}
; 6015 : 	}
; 6016 : }

	pop	ecx
	ret	0
?IdentifyPriorityTargetsByType@CvTacticalAI@@AAEXXZ ENDP ; CvTacticalAI::IdentifyPriorityTargetsByType
_TEXT	ENDS
PUBLIC	?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z ; CvTacticalAI::ComputeTotalExpectedDamage
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
EXTRN	?getStrengthValue@CvCity@@QBEH_N@Z:PROC		; CvCity::getStrengthValue
EXTRN	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z:PROC	; CvUnit::getCombatDamage
EXTRN	?getDamage@CvUnit@@QBEHXZ:PROC			; CvUnit::getDamage
EXTRN	?GetFireSupportUnit@CvUnitCombat@@SAPAVCvUnit@@W4PlayerTypes@@HHHH@Z:PROC ; CvUnitCombat::GetFireSupportUnit
EXTRN	?GetMaxDefenseStrength@CvUnit@@QBEHPBVCvPlot@@PBV1@_N@Z:PROC ; CvUnit::GetMaxDefenseStrength
EXTRN	?GetRangeCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z:PROC ; CvUnit::GetRangeCombatDamage
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z$2
__ehfuncinfo$?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z
_TEXT	SEGMENT
tv675 = -60						; size = 4
_rtnValue$ = -56					; size = 4
_this$ = -52						; size = 4
_iDefenderStrength$225266 = -48				; size = 4
_iAttackerStrength$225255 = -48				; size = 4
_iAttackerStrength$225265 = -44				; size = 4
_iDefenderStrength$225256 = -44				; size = 4
_iExpectedSelfDamage$ = -44				; size = 4
_iI$225241 = -40					; size = 4
_pAttacker$225245 = -36					; size = 8
_pDefender$225251 = -28					; size = 8
_pFireSupportUnit$225257 = -20				; size = 8
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
_iDefenderFireSupportCombatDamage$225268 = 12		; size = 4
_iDefenderFireSupportCombatDamage$225258 = 12		; size = 4
_iExpectedDamage$ = 12					; size = 4
_pTargetPlot$ = 12					; size = 4
?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z PROC ; CvTacticalAI::ComputeTotalExpectedDamage, COMDAT
; _this$ = ecx

; 9275 : {

	push	-1
	push	__ehhandler$?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	mov	ebx, ecx

; 9276 : 	int rtnValue = 0;
; 9277 : 	int iExpectedDamage;
; 9278 : 	int iExpectedSelfDamage;
; 9279 : 
; 9280 : 	// Loop through all units who can reach the target
; 9281 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	ecx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebx+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	push	ebp
	mov	eax, edx
	push	esi
	xor	ebp, ebp
	xor	esi, esi
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _this$[esp+72], ebx
	mov	DWORD PTR _rtnValue$[esp+72], esi
	mov	DWORD PTR _iI$225241[esp+72], ebp
	je	$LN174@ComputeTot
	push	edi
	mov	edi, DWORD PTR _pTargetPlot$[esp+72]
	mov	DWORD PTR tv675[esp+76], ebp
$LL15@ComputeTot:

; 9282 : 	{
; 9283 : 		UnitHandle pAttacker = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [ebx+24]
	add	eax, DWORD PTR tv675[esp+76]
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pAttacker$225245[esp+76], esi
	mov	BYTE PTR _pAttacker$225245[esp+80], 0
	cmp	esi, ebp
	je	SHORT $LN30@ComputeTot
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@ComputeTot:

; 9284 : 
; 9285 : 		// Is target a unit?
; 9286 : 		switch(pTarget->GetTargetType())

	mov	ecx, DWORD PTR _pTarget$[esp+72]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __$EHRec$[esp+84], ebp
	cmp	eax, 1
	je	$LN5@ComputeTot
	add	eax, -5					; fffffffbH
	cmp	eax, 2
	ja	$LN177@ComputeTot

; 9287 : 		{
; 9288 : 		case AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT:
; 9289 : 		case AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT:
; 9290 : 		case AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT:
; 9291 : 		{
; 9292 : 			UnitHandle pDefender = pTargetPlot->getVisibleEnemyDefender(m_pPlayer->GetID());

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, edi
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	mov	ebp, eax
	mov	DWORD PTR _pDefender$225251[esp+76], ebp
	mov	BYTE PTR _pDefender$225251[esp+80], 0
	test	ebp, ebp
	je	SHORT $LN41@ComputeTot
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@ComputeTot:
	mov	BYTE PTR __$EHRec$[esp+84], 1

; 9293 : 			if(pDefender)

	test	ebp, ebp
	je	$LN9@ComputeTot

; 9294 : 			{
; 9295 : 				if(pAttacker->IsCanAttackRanged())

	mov	ecx, esi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged

; 9296 : 				{
; 9297 : 					iExpectedDamage = pAttacker->GetRangeCombatDamage(pDefender.pointer(), NULL, false);

	push	0
	mov	ecx, esi
	test	al, al
	je	SHORT $LN8@ComputeTot
	push	0
	push	0
	push	ebp
	call	?GetRangeCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z ; CvUnit::GetRangeCombatDamage

; 9298 : 					iExpectedSelfDamage = 0;

	mov	DWORD PTR _iExpectedSelfDamage$[esp+76], 0

; 9299 : #ifdef DEL_RANGED_COUNTERATTACKS
; 9300 : 					if (GC.getGame().isOption("GAMEOPTION_ENABLE_RANGED_COUNTERATTACKS") && !pDefender->IsCityAttackOnly())
; 9301 : 					{
; 9302 : 						if ((pDefender->canRangeStrike() && pDefender->GetRange() >= pAttacker->GetRange()) ||
; 9303 : 							(pDefender->IsCanAttackWithMove() && pAttacker->plot()->isAdjacent(pDefender->plot()) && pDefender->PlotValid(pDefender->plot()) && pDefender->PlotValid(pAttacker->plot())))
; 9304 : 						{
; 9305 : 							if (pDefender->IsCanAttackRanged())
; 9306 : 							{
; 9307 : 								iExpectedSelfDamage = pDefender->GetRangeCombatDamage(pAttacker.pointer(), NULL, true);
; 9308 : 							}
; 9309 : 							else if (iExpectedDamage + pDefender->getDamage() < pDefender->GetMaxHitPoints())
; 9310 : 							{
; 9311 : 								// Melee unit (defender) is counterattacking by attacking into the plot from which they were bombarded, where the attacker is
; 9312 : 								int iAttackerStrength = pAttacker->GetMaxDefenseStrength(pAttacker->plot(), pDefender.pointer());
; 9313 : 								int iDefenderStrength = pDefender->GetMaxAttackStrength(pDefender->plot(), pAttacker->plot(), pAttacker.pointer());
; 9314 : 								iExpectedSelfDamage = pDefender->getCombatDamage(iDefenderStrength, iAttackerStrength, iExpectedDamage + pDefender->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);
; 9315 : 							}
; 9316 : 						}
; 9317 : 					}
; 9318 : #endif
; 9319 : 				}
; 9320 : 				else

	jmp	$LN101@ComputeTot
$LN8@ComputeTot:

; 9321 : 				{
; 9322 : 					int iAttackerStrength = pAttacker->GetMaxAttackStrength(NULL, pTargetPlot, NULL);

	push	edi
	push	0
	call	?GetMaxAttackStrength@CvUnit@@QBEHPBVCvPlot@@0PBV1@@Z ; CvUnit::GetMaxAttackStrength

; 9323 : 					int iDefenderStrength = pDefender->GetMaxDefenseStrength(pTargetPlot, pAttacker.pointer());

	push	0
	push	esi
	push	edi
	mov	ecx, ebp
	mov	DWORD PTR _iAttackerStrength$225255[esp+88], eax
	call	?GetMaxDefenseStrength@CvUnit@@QBEHPBVCvPlot@@PBV1@_N@Z ; CvUnit::GetMaxDefenseStrength

; 9324 : 					UnitHandle pFireSupportUnit = CvUnitCombat::GetFireSupportUnit(pDefender->getOwner(), pTargetPlot->getX(), pTargetPlot->getY(), pAttacker->getX(), pAttacker->getY());

	mov	ecx, DWORD PTR [esi+76]
	movsx	edx, WORD PTR [edi+2]
	mov	ebx, DWORD PTR [ebp+40]
	mov	DWORD PTR _iDefenderStrength$225256[esp+76], eax
	mov	eax, DWORD PTR [esi+88]
	push	eax
	movsx	eax, WORD PTR [edi]
	push	ecx
	push	edx
	push	eax
	push	ebx
	call	?GetFireSupportUnit@CvUnitCombat@@SAPAVCvUnit@@W4PlayerTypes@@HHHH@Z ; CvUnitCombat::GetFireSupportUnit
	mov	ebx, eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pFireSupportUnit$225257[esp+76], ebx
	mov	BYTE PTR _pFireSupportUnit$225257[esp+80], 0
	test	ebx, ebx
	je	SHORT $LN82@ComputeTot
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN82@ComputeTot:
	mov	BYTE PTR __$EHRec$[esp+84], 2

; 9325 : 					int iDefenderFireSupportCombatDamage = 0;

	mov	DWORD PTR _iDefenderFireSupportCombatDamage$225258[esp+72], 0

; 9326 : 					if(pFireSupportUnit)

	test	ebx, ebx
	je	SHORT $LN6@ComputeTot

; 9327 : 					{
; 9328 : 						iDefenderFireSupportCombatDamage = pFireSupportUnit->GetRangeCombatDamage(pAttacker.pointer(), NULL, false);

	push	0
	push	0
	push	0
	push	esi
	mov	ecx, ebx
	call	?GetRangeCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z ; CvUnit::GetRangeCombatDamage
	mov	DWORD PTR _iDefenderFireSupportCombatDamage$225258[esp+72], eax
$LN6@ComputeTot:

; 9329 : 					}
; 9330 : 					iExpectedDamage = pAttacker->getCombatDamage(iAttackerStrength, iDefenderStrength, pAttacker->getDamage() + iDefenderFireSupportCombatDamage, /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);

	push	0
	push	0
	push	0
	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, DWORD PTR _iDefenderFireSupportCombatDamage$225258[esp+84]
	mov	ecx, DWORD PTR _iAttackerStrength$225255[esp+88]
	push	eax
	mov	eax, DWORD PTR _iDefenderStrength$225256[esp+92]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z	; CvUnit::getCombatDamage

; 9331 : 					iExpectedSelfDamage = pDefender->getCombatDamage(iDefenderStrength, iAttackerStrength, pDefender->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);

	push	0
	push	0
	push	0
	mov	ecx, ebp
	mov	DWORD PTR _iExpectedDamage$[esp+84], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	edx, DWORD PTR _iAttackerStrength$225255[esp+88]
	push	eax
	mov	eax, DWORD PTR _iDefenderStrength$225256[esp+92]
	push	edx
	push	eax
	mov	ecx, ebp
	call	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z	; CvUnit::getCombatDamage
	mov	DWORD PTR _iExpectedSelfDamage$[esp+76], eax

; 9332 : 				}

	mov	BYTE PTR __$EHRec$[esp+84], 1
	test	ebx, ebx
	je	SHORT $LN176@ComputeTot
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN176@ComputeTot:
	mov	eax, DWORD PTR _iExpectedDamage$[esp+72]
	mov	ebx, DWORD PTR _this$[esp+76]
$LN101@ComputeTot:

; 9333 : 				m_CurrentMoveUnits[iI].SetExpectedTargetDamage(iExpectedDamage);

	mov	ecx, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR tv675[esp+76]
	add	ecx, edx
	mov	DWORD PTR [ecx+16], eax

; 9334 : 				m_CurrentMoveUnits[iI].SetExpectedSelfDamage(iExpectedSelfDamage);

	mov	ecx, DWORD PTR [ebx+24]
	add	ecx, edx
	mov	edx, DWORD PTR _iExpectedSelfDamage$[esp+76]

; 9335 : 				rtnValue += iExpectedDamage;

	add	DWORD PTR _rtnValue$[esp+76], eax
	mov	DWORD PTR [ecx+20], edx
$LN9@ComputeTot:

; 9336 : 			}
; 9337 : 		}

	mov	BYTE PTR __$EHRec$[esp+84], 0
	test	ebp, ebp
	je	$LN177@ComputeTot
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 9338 : 		break;

	jmp	$LN177@ComputeTot
$LN5@ComputeTot:

; 9339 : 
; 9340 : 		case AI_TACTICAL_TARGET_CITY:
; 9341 : 		{
; 9342 : 			CvCity* pCity = pTargetPlot->getPlotCity();

	mov	eax, DWORD PTR [edi+104]
	cmp	eax, ebp
	jl	$LN177@ComputeTot
	cmp	eax, 64					; 00000040H
	jge	$LN177@ComputeTot
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebp, eax

; 9343 : 			if(pCity != NULL)

	test	ebp, ebp
	je	$LN177@ComputeTot

; 9344 : 			{
; 9345 : 				if(pAttacker->IsCanAttackRanged() && pAttacker->GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true) > pAttacker->GetMaxAttackStrength(NULL, pTargetPlot, NULL))

	mov	ecx, esi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	SHORT $LN3@ComputeTot
	push	1
	push	1
	push	0
	push	0
	mov	ecx, esi
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength
	push	0
	push	edi
	push	0
	mov	ecx, esi
	mov	ebx, eax
	call	?GetMaxAttackStrength@CvUnit@@QBEHPBVCvPlot@@0PBV1@@Z ; CvUnit::GetMaxAttackStrength
	cmp	ebx, eax
	jle	SHORT $LN175@ComputeTot

; 9346 : 				{
; 9347 : 					iExpectedDamage = pAttacker->GetRangeCombatDamage(NULL, pCity, false);

	push	0
	push	0
	push	ebp
	push	0
	mov	ecx, esi
	call	?GetRangeCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z ; CvUnit::GetRangeCombatDamage

; 9348 : 					iExpectedSelfDamage = 0;
; 9349 : #ifdef DEL_RANGED_COUNTERATTACKS
; 9350 : 					if (GC.getGame().isOption("GAMEOPTION_ENABLE_RANGED_COUNTERATTACKS"))
; 9351 : 					{
; 9352 : 						if (pCity->canRangeStrikeAt(pAttacker->getX(), pAttacker->getY(), true))
; 9353 : 						{
; 9354 : 							iExpectedSelfDamage = pCity->rangeCombatDamage(pAttacker.pointer(), NULL, true);
; 9355 : 						}
; 9356 : 					}
; 9357 : #endif
; 9358 : 				}
; 9359 : 				else

	mov	ebx, DWORD PTR _this$[esp+76]
	mov	ecx, eax
	xor	eax, eax
	jmp	$LN2@ComputeTot
$LN175@ComputeTot:
	mov	ebx, DWORD PTR _this$[esp+76]
$LN3@ComputeTot:

; 9360 : 				{
; 9361 : 					int iAttackerStrength = pAttacker->GetMaxAttackStrength(NULL, pTargetPlot, NULL);

	push	0
	push	edi
	push	0
	mov	ecx, esi
	call	?GetMaxAttackStrength@CvUnit@@QBEHPBVCvPlot@@0PBV1@@Z ; CvUnit::GetMaxAttackStrength

; 9362 : 					int iDefenderStrength = pCity->getStrengthValue();

	push	0
	mov	ecx, ebp
	mov	DWORD PTR _iAttackerStrength$225265[esp+80], eax
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue

; 9363 : 					CvUnit* pFireSupportUnit = CvUnitCombat::GetFireSupportUnit(pCity->getOwner(), pTargetPlot->getX(), pTargetPlot->getY(), pAttacker->getX(), pAttacker->getY());

	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [ebp+84]
	mov	DWORD PTR _iDefenderStrength$225266[esp+76], eax
	mov	eax, DWORD PTR [esi+88]
	push	eax
	movsx	eax, WORD PTR [edi+2]
	push	ecx
	push	eax
	movsx	eax, WORD PTR [edi]
	push	eax
	push	edx
	call	?GetFireSupportUnit@CvUnitCombat@@SAPAVCvUnit@@W4PlayerTypes@@HHHH@Z ; CvUnitCombat::GetFireSupportUnit
	add	esp, 20					; 00000014H

; 9364 : 					int iDefenderFireSupportCombatDamage = 0;

	mov	DWORD PTR _iDefenderFireSupportCombatDamage$225268[esp+72], 0

; 9365 : 					if(pFireSupportUnit != NULL)

	test	eax, eax
	je	SHORT $LN1@ComputeTot

; 9366 : 					{
; 9367 : 						iDefenderFireSupportCombatDamage = pFireSupportUnit->GetRangeCombatDamage(pAttacker.pointer(), NULL, false);

	push	0
	push	0
	push	0
	push	esi
	mov	ecx, eax
	call	?GetRangeCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z ; CvUnit::GetRangeCombatDamage
	mov	DWORD PTR _iDefenderFireSupportCombatDamage$225268[esp+72], eax
$LN1@ComputeTot:

; 9368 : 					}
; 9369 : 					iExpectedDamage = pAttacker->getCombatDamage(iAttackerStrength, iDefenderStrength, pAttacker->getDamage() + iDefenderFireSupportCombatDamage, /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ true);

	push	1
	push	0
	push	0
	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, DWORD PTR _iDefenderFireSupportCombatDamage$225268[esp+84]
	mov	edx, DWORD PTR _iDefenderStrength$225266[esp+88]
	push	eax
	mov	eax, DWORD PTR _iAttackerStrength$225265[esp+92]
	push	edx
	push	eax
	mov	ecx, esi
	call	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z	; CvUnit::getCombatDamage

; 9370 : 					iExpectedSelfDamage = pAttacker->getCombatDamage(iDefenderStrength, iAttackerStrength, pCity->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ true, /*bDefenderIsCity*/ false);

	push	0
	push	1
	push	0
	mov	ecx, ebp
	mov	DWORD PTR _iExpectedDamage$[esp+84], eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	ecx, DWORD PTR _iAttackerStrength$225265[esp+88]
	mov	edx, DWORD PTR _iDefenderStrength$225266[esp+88]
	push	eax
	push	ecx
	push	edx
	mov	ecx, esi
	call	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z	; CvUnit::getCombatDamage
	mov	ecx, DWORD PTR _iExpectedDamage$[esp+72]
$LN2@ComputeTot:

; 9371 : 				}
; 9372 : 				m_CurrentMoveUnits[iI].SetExpectedTargetDamage(iExpectedDamage);

	mov	edx, DWORD PTR [ebx+24]
	mov	ebp, DWORD PTR tv675[esp+76]
	add	edx, ebp
	mov	DWORD PTR [edx+16], ecx

; 9373 : 				m_CurrentMoveUnits[iI].SetExpectedSelfDamage(iExpectedSelfDamage);

	mov	edx, DWORD PTR [ebx+24]
	add	edx, ebp

; 9374 : 				rtnValue += iExpectedDamage;

	add	DWORD PTR _rtnValue$[esp+76], ecx
	mov	DWORD PTR [edx+20], eax
$LN177@ComputeTot:

; 9375 : 			}
; 9376 : 		}
; 9377 : 		break;
; 9378 : 		}
; 9379 : 	}

	xor	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+84], -1
	cmp	esi, ebp
	je	SHORT $LN14@ComputeTot
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN14@ComputeTot:
	mov	ecx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR _iI$225241[esp+76]
	add	DWORD PTR tv675[esp+76], 24		; 00000018H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	esi
	add	eax, edx
	mov	DWORD PTR _iI$225241[esp+76], esi
	cmp	esi, eax
	jb	$LL15@ComputeTot

; 9380 : 
; 9381 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+76]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 9382 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	mov	DWORD PTR fs:0, ecx
	add	esp, 60					; 0000003cH
	ret	8
$LN174@ComputeTot:
	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 60					; 0000003cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pAttacker$225245[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR _pDefender$225251[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR _pFireSupportUnit$225257[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z ENDP ; CvTacticalAI::ComputeTotalExpectedDamage
PUBLIC	?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::ComputeTotalExpectedBombardDamage
EXTRN	?rangeCombatDamage@CvCity@@QBEHPBVCvUnit@@PAV1@_N@Z:PROC ; CvCity::rangeCombatDamage
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z$0
__ehfuncinfo$?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 8
?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvTacticalAI::ComputeTotalExpectedBombardDamage, COMDAT
; _this$ = ecx

; 9386 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 9387 : 	int rtnValue = 0;
; 9388 : 	int iExpectedDamage;
; 9389 : #ifdef DEL_RANGED_COUNTERATTACKS
; 9390 : 	int iExpectedSelfDamage = 0;
; 9391 : #endif
; 9392 : 
; 9393 : 	// Now loop through all the cities that can bombard it
; 9394 : 	for(unsigned int iI = 0; iI < m_CurrentMoveCities.size(); iI++)

	mov	ecx, DWORD PTR [esi+60]
	sub	ecx, DWORD PTR [esi+56]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	xor	edi, edi
	shr	eax, 31					; 0000001fH
	xor	ebp, ebp
	xor	ebx, ebx
	add	eax, edx
	mov	DWORD PTR __$EHRec$[esp+36], edi
	je	SHORT $LN1@ComputeTot@2
	npad	3
$LL3@ComputeTot@2:

; 9395 : 	{
; 9396 : 		CvCity* pAttackingCity = m_pPlayer->getCity(m_CurrentMoveCities[iI].GetID());

	mov	eax, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [esi]
	add	eax, edi
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 9397 : 		iExpectedDamage = pAttackingCity->rangeCombatDamage(pTarget.pointer(), NULL, false);

	mov	ecx, DWORD PTR _pTarget$[esp+24]
	push	0
	push	0
	push	ecx
	mov	ecx, eax
	call	?rangeCombatDamage@CvCity@@QBEHPBVCvUnit@@PAV1@_N@Z ; CvCity::rangeCombatDamage

; 9398 : #ifdef DEL_RANGED_COUNTERATTACKS
; 9399 : 		iExpectedSelfDamage = 0;
; 9400 : 		if (GC.getGame().isOption("GAMEOPTION_ENABLE_RANGED_COUNTERATTACKS"))
; 9401 : 		{
; 9402 : 			if (// Ranged unit counterattacks
; 9403 : 				(pTarget->canRangeStrike() && pTarget->canEverRangeStrikeAt(pAttackingCity->getX(), pAttackingCity->getY())) ||
; 9404 : 				// Melee unit counterattacks
; 9405 : 				(pTarget->IsCanAttackWithMove() && pTarget->plot()->isAdjacent(pAttackingCity->plot()) && pTarget->PlotValid(pTarget->plot()) && pTarget->PlotValid(pAttackingCity->plot())))
; 9406 : 			{
; 9407 : 				if (pTarget->IsCanAttackRanged())
; 9408 : 				{
; 9409 : 					iExpectedSelfDamage = pTarget->GetRangeCombatDamage(NULL, pAttackingCity, false);
; 9410 : 				}
; 9411 : 				else if (iExpectedDamage + pTarget->getDamage() < pTarget->GetMaxHitPoints())
; 9412 : 				{
; 9413 : 					// Melee unit (defender) is counterattacking by attacking into the plot from which they were bombarded, where the attacker is
; 9414 : 					int iAttackerStrength = pAttackingCity->getStrengthValue();
; 9415 : 					int iDefenderStrength = pTarget->GetMaxAttackStrength(pTarget->plot(), pAttackingCity->plot(), NULL);
; 9416 : 					iExpectedSelfDamage = pTarget->getCombatDamage(iDefenderStrength, iAttackerStrength, iExpectedDamage + pTarget->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ true);
; 9417 : 					iExpectedDamage = MAX(iExpectedDamage, pTarget->getCombatDamage(iAttackerStrength, iDefenderStrength, pAttackingCity->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ true, /*bDefenderIsCity*/ false));
; 9418 : 				}
; 9419 : 			}
; 9420 : 
; 9421 : 			// Cities can't be knocked to less than 1 HP by counterattacks
; 9422 : 			if (iExpectedSelfDamage + pAttackingCity->getDamage() >= pAttackingCity->GetMaxHitPoints())
; 9423 : 			{
; 9424 : 				iExpectedSelfDamage = pAttackingCity->GetMaxHitPoints() - pAttackingCity->getDamage() - 1;
; 9425 : 			}
; 9426 : 		}
; 9427 : 		m_CurrentMoveCities[iI].SetExpectedSelfDamage(iExpectedSelfDamage);
; 9428 : #endif
; 9429 : 		m_CurrentMoveCities[iI].SetExpectedTargetDamage(iExpectedDamage);

	mov	ecx, DWORD PTR [esi+56]
	add	ecx, edi
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR [esi+60]
	sub	ecx, DWORD PTR [esi+56]

; 9430 : 		rtnValue += iExpectedDamage;

	add	ebp, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	add	edi, 12					; 0000000cH
	cmp	ebx, eax
	jb	SHORT $LL3@ComputeTot@2
$LN1@ComputeTot@2:

; 9431 : 	}
; 9432 : 
; 9433 : 	return rtnValue;

	mov	ecx, DWORD PTR _pTarget$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	ecx, ecx
	je	SHORT $LN26@ComputeTot@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN26@ComputeTot@2:

; 9434 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pTarget$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvTacticalAI::ComputeTotalExpectedBombardDamage
PUBLIC	?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z ; CvTacticalAI::IsExpectedToDamageWithRangedAttack
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z$1
__ehfuncinfo$?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_pDefender$225291 = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pAttacker$ = 8						; size = 8
_pTargetPlot$ = 16					; size = 4
?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z PROC ; CvTacticalAI::IsExpectedToDamageWithRangedAttack, COMDAT
; _this$ = ecx

; 9441 : {

	push	-1
	push	__ehhandler$?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 9442 : 	int iExpectedDamage = 0;
; 9443 : 
; 9444 : 	if(pTargetPlot->isCity())

	mov	esi, DWORD PTR _pTargetPlot$[esp+32]
	mov	eax, DWORD PTR [esi+104]
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+44], 0
	test	eax, eax
	jl	SHORT $LN3@IsExpected
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN3@IsExpected
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN3@IsExpected

; 9445 : 	{
; 9446 : 		CvCity* pCity = pTargetPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN13@IsExpected
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN13@IsExpected
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN14@IsExpected
$LN13@IsExpected:
	xor	eax, eax
$LN14@IsExpected:

; 9447 : 		iExpectedDamage = pAttacker->GetRangeCombatDamage(NULL, pCity, /*bIncludeRand*/ false);

	mov	ecx, DWORD PTR _pAttacker$[esp+32]
	push	0
	push	0
	push	eax
	push	0
	call	?GetRangeCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z ; CvUnit::GetRangeCombatDamage
	mov	edi, eax

; 9448 : 	}
; 9449 : 	else

	jmp	SHORT $LN33@IsExpected
$LN3@IsExpected:

; 9450 : 	{
; 9451 : 		UnitHandle pDefender = pTargetPlot->getBestDefender(NO_PLAYER, m_pPlayer->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	-1
	lea	ecx, DWORD PTR _pDefender$225291[esp+64]
	push	ecx
	mov	ecx, esi
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender

; 9452 : 		if(pDefender)

	mov	ecx, DWORD PTR _pDefender$225291[esp+36]
	mov	BYTE PTR __$EHRec$[esp+44], 1
	test	ecx, ecx
	je	SHORT $LN1@IsExpected

; 9453 : 		{
; 9454 : 			iExpectedDamage = pAttacker->GetRangeCombatDamage(pDefender.pointer(), NULL, false);

	push	0
	push	0
	push	0
	push	ecx
	mov	ecx, DWORD PTR _pAttacker$[esp+48]
	call	?GetRangeCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z ; CvUnit::GetRangeCombatDamage
	mov	ecx, DWORD PTR _pDefender$225291[esp+36]
	mov	edi, eax
$LN1@IsExpected:

; 9455 : 		}
; 9456 : 	}

	mov	BYTE PTR __$EHRec$[esp+44], 0
	test	ecx, ecx
	je	SHORT $LN33@IsExpected
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN33@IsExpected:

; 9457 : 
; 9458 : 	return iExpectedDamage > 0;

	mov	ecx, DWORD PTR _pAttacker$[esp+32]
	test	edi, edi
	setg	bl
	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	ecx, ecx
	je	SHORT $LN40@IsExpected
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN40@IsExpected:

; 9459 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pAttacker$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR _pDefender$225291[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z ENDP ; CvTacticalAI::IsExpectedToDamageWithRangedAttack
PUBLIC	?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z ; CvTacticalAI::MoveToUsingSafeEmbark
EXTRN	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z:PROC ; CvUnit::PushMission
EXTRN	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_MOVE_TO
EXTRN	?IsInEnemyDominatedZone@CvTacticalAnalysisMap@@QAE_NPAVCvPlot@@@Z:PROC ; CvTacticalAnalysisMap::IsInEnemyDominatedZone
EXTRN	?GetPathEndTurnPlot@CvUnit@@QBEPAVCvPlot@@XZ:PROC ; CvUnit::GetPathEndTurnPlot
EXTRN	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z:PROC ; CvUnit::GeneratePath
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z$0
__ehfuncinfo$?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_pTargetPlot$ = 16					; size = 4
_bMoveWasSafe$ = 20					; size = 4
?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z PROC ; CvTacticalAI::MoveToUsingSafeEmbark, COMDAT
; _this$ = ecx

; 9536 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 9537 : 	bMoveWasSafe = true;

	mov	ebx, DWORD PTR _bMoveWasSafe$[esp+20]

; 9538 : 
; 9539 : 	// Move right away if not a land unit
; 9540 : 	if (pUnit->getDomainType() != DOMAIN_LAND)

	mov	ecx, DWORD PTR _pUnit$[esp+20]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	BYTE PTR [ebx], 1
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 9541 : 	{
; 9542 : 		pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTargetPlot->getX(), pTargetPlot->getY());

	push	0
	push	0
	cmp	eax, 2
	je	SHORT $LN12@MoveToUsin
	mov	eax, DWORD PTR _pTargetPlot$[esp+28]
	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	-1
	push	0
	push	0
	push	0
	push	ecx
	push	eax

; 9543 : 		return true;

	jmp	$LN113@MoveToUsin
$LN12@MoveToUsin:

; 9544 : 	}
; 9545 : 
; 9546 : 	// If a land unit, get path to target
; 9547 : 	if(!pUnit->GeneratePath(pTargetPlot))

	mov	esi, DWORD PTR _pTargetPlot$[esp+28]
	mov	ecx, DWORD PTR _pUnit$[esp+28]
	push	0
	push	esi
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath

; 9548 : 	{
; 9549 : 		// No path this may happen if a unit has moved up and blocked our path to our target plot
; 9550 : 		// If calling routine is moving a bunch of units like this it should retry these units
; 9551 : 		bMoveWasSafe = false;
; 9552 : 		return false;

	mov	ecx, DWORD PTR _pUnit$[esp+20]
	test	al, al
	jne	SHORT $LN11@MoveToUsin
	mov	BYTE PTR [ebx], al
	mov	DWORD PTR __$EHRec$[esp+32], -1
	test	ecx, ecx
	je	SHORT $LN34@MoveToUsin
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN34@MoveToUsin:
	xor	al, al

; 9611 : 				}
; 9612 : 			}
; 9613 : 		}
; 9614 : 	}
; 9615 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
$LN11@MoveToUsin:

; 9553 : 	}
; 9554 : 
; 9555 : 	else
; 9556 : 	{
; 9557 : 		CvPlot *pMovePlot = pUnit->GetPathEndTurnPlot();

	call	?GetPathEndTurnPlot@CvUnit@@QBEPAVCvPlot@@XZ ; CvUnit::GetPathEndTurnPlot

; 9558 : 		
; 9559 : 		// On land?  If so go ahead and move there
; 9560 : 		if (!pMovePlot->isWater())

	cmp	BYTE PTR [eax+5], 3
	je	SHORT $LN9@MoveToUsin

; 9561 : 		{
; 9562 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTargetPlot->getX(), pTargetPlot->getY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0

; 9563 : 			return true;

	jmp	$LN114@MoveToUsin
$LN9@MoveToUsin:

; 9564 : 		}
; 9565 : 
; 9566 : 		// How dangerous is this plot?
; 9567 : 		else
; 9568 : 		{
; 9569 : 			bool bDangerous = false;
; 9570 : 
; 9571 : 			int iPlotIndex = GC.getMap().plotNum(pTargetPlot->getX(), pTargetPlot->getY());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [eax+4020]
	movsx	eax, WORD PTR [esi+2]

; 9572 : 			CvTacticalAnalysisCell *pCell = m_pMap->GetCell(iPlotIndex);

	mov	edx, DWORD PTR [edi+4]
	imul	eax, ecx
	movsx	ecx, WORD PTR [esi]
	add	eax, ecx
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [edx+12]

; 9573 : 			if (pCell->IsSubjectToAttack())

	mov	eax, DWORD PTR [eax]
	shr	eax, 5
	test	al, 1

; 9574 : 			{
; 9575 : 				// Enemy naval unit can definitely attack this plot
; 9576 : 				bDangerous = true;
; 9577 : 			}
; 9578 : 
; 9579 : 			else

	jne	SHORT $LN4@MoveToUsin

; 9580 : 			{
; 9581 : 				if (GC.getGame().GetTacticalAnalysisMap()->IsInEnemyDominatedZone(pTargetPlot))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	ecx, eax
	call	?IsInEnemyDominatedZone@CvTacticalAnalysisMap@@QAE_NPAVCvPlot@@@Z ; CvTacticalAnalysisMap::IsInEnemyDominatedZone
	test	al, al

; 9582 : 				{
; 9583 : 					// Also dangerous in an enemy dominated naval zone
; 9584 : 					bDangerous = true;
; 9585 : 				}
; 9586 : 			}
; 9587 : 
; 9588 : 			// Not dangerous, proceed
; 9589 : 			if (!bDangerous)

	jne	SHORT $LN4@MoveToUsin

; 9590 : 			{
; 9591 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTargetPlot->getX(), pTargetPlot->getY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0

; 9592 : 				return true;	

	jmp	SHORT $LN114@MoveToUsin
$LN4@MoveToUsin:

; 9593 : 			}
; 9594 : 
; 9595 : 			// Dangerous - try to move just on land
; 9596 : 			else
; 9597 : 			{
; 9598 : 				if(!pUnit->GeneratePath(pTargetPlot, CvUnit::MOVEFLAG_STAY_ON_LAND))

	mov	ecx, DWORD PTR _pUnit$[esp+20]
	push	0
	push	0
	push	256					; 00000100H
	push	esi
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath

; 9599 : 				{
; 9600 : 					// No land path so just risk move to sea
; 9601 : 					pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTargetPlot->getX(), pTargetPlot->getY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	test	al, al
	jne	SHORT $LN2@MoveToUsin
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	mov	esi, DWORD PTR _pUnit$[esp+40]
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 9602 : 
; 9603 : 					// Hopefully the calling routine might be able to pull escort over to stack with this unit
; 9604 : 					bMoveWasSafe = false;

	mov	BYTE PTR [ebx], 0

; 9605 : 					return true;	

	jmp	SHORT $LN115@MoveToUsin
$LN2@MoveToUsin:

; 9606 : 				}
; 9607 : 				else
; 9608 : 				{
; 9609 : 					pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTargetPlot->getX(), pTargetPlot->getY(), CvUnit::MOVEFLAG_STAY_ON_LAND);

	push	256					; 00000100H
$LN114@MoveToUsin:
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
$LN113@MoveToUsin:
	mov	esi, DWORD PTR _pUnit$[esp+52]
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission
$LN115@MoveToUsin:

; 9610 : 					return true;	

	mov	ecx, DWORD PTR _pUnit$[esp+20]
	mov	DWORD PTR __$EHRec$[esp+32], -1
	test	ecx, ecx
	je	SHORT $LN102@MoveToUsin
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN102@MoveToUsin:

; 9611 : 				}
; 9612 : 			}
; 9613 : 		}
; 9614 : 	}
; 9615 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	al, 1
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z ENDP ; CvTacticalAI::MoveToUsingSafeEmbark
PUBLIC	?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::FindBarbarianExploreTarget
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?isAdjacentOwned@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentOwned
EXTRN	?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z:PROC ; CvEconomicAI::ScoreExplorePlot
EXTRN	?GetBaseSightRange@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetBaseSightRange
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
EXTRN	?area@CvUnit@@QBEPAVCvArea@@XZ:PROC		; CvUnit::area
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
EXTRN	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z:PROC		; CvUnit::atPlot
EXTRN	?movesLeft@CvUnit@@QBEHXZ:PROC			; CvUnit::movesLeft
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$0
__ehfuncinfo$?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
tv448 = -48						; size = 4
tv463 = -44						; size = 4
_iMovementRange$ = -40					; size = 4
_iX$225475 = -36					; size = 4
_iBestValue$ = -32					; size = 4
_pBestMovePlot$ = -28					; size = 4
tv331 = -24						; size = 4
tv321 = -20						; size = 4
$T246767 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvTacticalAI::FindBarbarianExploreTarget, COMDAT
; _this$ = ecx

; 9849 : {

	push	-1
	push	__ehhandler$?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 9850 : 	CvPlot* pBestMovePlot = NULL;
; 9851 : 	int iBestValue;
; 9852 : 	int iValue;
; 9853 : 
; 9854 : 	// Now looking for BEST score
; 9855 : 	iBestValue = 0;
; 9856 : 	int iMovementRange = pUnit->movesLeft() / GC.getMOVE_DENOMINATOR();

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	mov	DWORD PTR _pBestMovePlot$[esp+64], ebx
	mov	DWORD PTR _iBestValue$[esp+64], ebx
	call	?movesLeft@CvUnit@@QBEHXZ		; CvUnit::movesLeft
	cdq
	idiv	esi
	mov	ebp, DWORD PTR _pUnit$[esp+60]

; 9857 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 9858 : 	int iMaxDX, iX;
; 9859 : 	CvPlot* pPlot;
; 9860 : 	for (int iY = -iMovementRange; iY <= iMovementRange; iY++)
; 9861 : 	{
; 9862 : 		iMaxDX = iMovementRange - MAX(0, iY);
; 9863 : 		for (iX = -iMovementRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 9864 : 		{
; 9865 : 			pPlot = plotXY(pUnit->getX(), pUnit->getY(), iX, iY);
; 9866 : #else
; 9867 : 	for(int iX = -iMovementRange; iX <= iMovementRange; iX++)

	mov	ecx, eax
	neg	ecx
	mov	edi, ecx
	cmp	edi, eax
	mov	DWORD PTR _iMovementRange$[esp+64], eax
	mov	DWORD PTR tv321[esp+64], ecx
	mov	DWORD PTR _iX$225475[esp+64], edi
	jg	$LN14@FindBarbar
	mov	edx, edi
	neg	edx
	mov	DWORD PTR tv463[esp+64], edx
$LL16@FindBarbar:

; 9868 : 	{
; 9869 : 		for(int iY = -iMovementRange; iY <= iMovementRange; iY++)

	mov	ebx, ecx
	cmp	ebx, eax
	jg	$LN15@FindBarbar

; 9870 : 		{
; 9871 : 			CvPlot* pPlot = plotXYWithRangeCheck(pUnit->getX(), pUnit->getY(), iX, iY, iMovementRange);

	xor	eax, eax
	test	edi, edi
	setge	al
	mov	DWORD PTR tv331[esp+64], eax
	mov	eax, ebx
	neg	eax
	mov	DWORD PTR tv448[esp+64], eax
$LN13@FindBarbar:
	mov	edx, DWORD PTR [ebp+88]
	mov	esi, DWORD PTR [ebp+76]
	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	cmp	DWORD PTR tv331[esp+64], ecx
	mov	ecx, edi
	jne	SHORT $LN39@FindBarbar
	test	edi, edi
	jge	SHORT $LN43@FindBarbar
	mov	ecx, DWORD PTR tv463[esp+64]
$LN43@FindBarbar:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN45@FindBarbar
	mov	eax, DWORD PTR tv448[esp+64]
$LN45@FindBarbar:
	add	eax, ecx
	jmp	SHORT $LN50@FindBarbar
$LN39@FindBarbar:
	test	edi, edi
	jge	SHORT $LN47@FindBarbar
	mov	ecx, DWORD PTR tv463[esp+64]
$LN47@FindBarbar:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN49@FindBarbar
	mov	eax, DWORD PTR tv448[esp+64]
$LN49@FindBarbar:
	cmp	ecx, eax
	jl	SHORT $LN50@FindBarbar
	mov	eax, ecx
$LN50@FindBarbar:
	cmp	eax, DWORD PTR _iMovementRange$[esp+64]
	jg	$LN12@FindBarbar
	push	ebx
	push	edi
	push	edx
	push	esi
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	esi, eax
	add	esp, 16					; 00000010H

; 9872 : #endif
; 9873 : 			if(!pPlot)

	test	esi, esi
	je	$LN12@FindBarbar

; 9874 : 			{
; 9875 : 				continue;
; 9876 : 			}
; 9877 : 
; 9878 : 			if(pUnit->atPlot(*pPlot))

	push	esi
	mov	ecx, ebp
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	test	al, al
	jne	$LN99@FindBarbar

; 9879 : 			{
; 9880 : 				continue;
; 9881 : 			}
; 9882 : 
; 9883 : 			if(!pPlot->isRevealed(pUnit->getTeam()))

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	ebp, ecx
	mov	ecx, eax
	sub	ecx, ebp
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [esi+edx*4+8]
	je	$LN99@FindBarbar

; 9884 : 			{
; 9885 : 				continue;
; 9886 : 			}
; 9887 : 
; 9888 : 			if(pPlot->area() != pUnit->area())

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	call	?area@CvUnit@@QBEPAVCvArea@@XZ		; CvUnit::area
	mov	ecx, esi
	mov	ebp, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	eax, ebp
	jne	$LN99@FindBarbar

; 9889 : 			{
; 9890 : 				continue;
; 9891 : 			}
; 9892 : 
; 9893 : 			if(!CanReachInXTurns(pUnit, pPlot, 1))

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	push	0
	push	0
	push	1
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _pUnit$[esp+88]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T246767[esp+88], esp
	test	eax, eax
	je	SHORT $LN65@FindBarbar
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@FindBarbar:
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	test	al, al
	je	$LN99@FindBarbar

; 9894 : 			{
; 9895 : 				continue;
; 9896 : 			}
; 9897 : 
; 9898 : 			// Value them based on their explore value
; 9899 : 			DomainTypes eDomain = pUnit->getDomainType();

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 9900 : 			iValue = CvEconomicAI::ScoreExplorePlot(pPlot, pUnit->getTeam(), pUnit->getUnitInfo().GetBaseSightRange(), eDomain);

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	push	eax
	mov	edi, ecx
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetBaseSightRange@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetBaseSightRange
	push	eax
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	push	esi
	call	?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z ; CvEconomicAI::ScoreExplorePlot
	add	esp, 16					; 00000010H

; 9901 : 
; 9902 : 			// Add special value for popping up on hills or near enemy lands
; 9903 : 			if(pPlot->isAdjacentOwned())

	mov	ecx, esi
	mov	edi, eax
	call	?isAdjacentOwned@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentOwned
	test	al, al
	je	SHORT $LN5@FindBarbar

; 9904 : 			{
; 9905 : 				iValue += 100;

	add	edi, 100				; 00000064H
	jmp	SHORT $LN3@FindBarbar
$LN5@FindBarbar:

; 9906 : 			}
; 9907 : 			else if(pPlot->isOwned())

	mov	ecx, esi
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	je	SHORT $LN3@FindBarbar

; 9908 : 			{
; 9909 : 				iValue += 200;

	add	edi, 200				; 000000c8H
$LN3@FindBarbar:

; 9910 : 			}
; 9911 : 
; 9912 : 			// If still have no value, score equal to distance from my current plot
; 9913 : 			if(iValue == 0)

	mov	ebp, DWORD PTR _pUnit$[esp+60]
	test	edi, edi
	jne	SHORT $LN2@FindBarbar

; 9914 : 			{
; 9915 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 9916 : 				iValue = hexDistance(iX, iY);
; 9917 : #else
; 9918 : 				iValue = plotDistance(pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	mov	eax, DWORD PTR [ebp+88]
	mov	ecx, DWORD PTR [ebp+76]
	push	edx
	movsx	edx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	edi, eax
$LN2@FindBarbar:

; 9919 : #endif
; 9920 : 			}
; 9921 : 
; 9922 : 			if(iValue > iBestValue)

	cmp	edi, DWORD PTR _iBestValue$[esp+64]
	jle	SHORT $LN103@FindBarbar

; 9923 : 			{
; 9924 : 				pBestMovePlot = pPlot;

	mov	DWORD PTR _pBestMovePlot$[esp+64], esi

; 9925 : 				iBestValue = iValue;

	mov	DWORD PTR _iBestValue$[esp+64], edi
$LN103@FindBarbar:
	mov	edi, DWORD PTR _iX$225475[esp+64]
$LN12@FindBarbar:

; 9868 : 	{
; 9869 : 		for(int iY = -iMovementRange; iY <= iMovementRange; iY++)

	dec	DWORD PTR tv448[esp+64]
	inc	ebx
	cmp	ebx, DWORD PTR _iMovementRange$[esp+64]
	jle	$LN13@FindBarbar
	mov	eax, DWORD PTR _iMovementRange$[esp+64]
	mov	ecx, DWORD PTR tv321[esp+64]
$LN15@FindBarbar:
	dec	DWORD PTR tv463[esp+64]
	inc	edi
	cmp	edi, eax
	mov	DWORD PTR _iX$225475[esp+64], edi
	jle	$LL16@FindBarbar

; 9857 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 9858 : 	int iMaxDX, iX;
; 9859 : 	CvPlot* pPlot;
; 9860 : 	for (int iY = -iMovementRange; iY <= iMovementRange; iY++)
; 9861 : 	{
; 9862 : 		iMaxDX = iMovementRange - MAX(0, iY);
; 9863 : 		for (iX = -iMovementRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 9864 : 		{
; 9865 : 			pPlot = plotXY(pUnit->getX(), pUnit->getY(), iX, iY);
; 9866 : #else
; 9867 : 	for(int iX = -iMovementRange; iX <= iMovementRange; iX++)

	mov	ebx, DWORD PTR _pBestMovePlot$[esp+64]
$LN14@FindBarbar:

; 9926 : 			}
; 9927 : 		}
; 9928 : 	}
; 9929 : 	return pBestMovePlot;

	mov	DWORD PTR __$EHRec$[esp+72], -1
	test	ebp, ebp
	je	SHORT $LN98@FindBarbar
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN98@FindBarbar:

; 9930 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 48					; 00000030H
	ret	8
$LN99@FindBarbar:

; 9925 : 				iBestValue = iValue;

	mov	ebp, DWORD PTR _pUnit$[esp+60]
	jmp	SHORT $LN12@FindBarbar
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvTacticalAI::FindBarbarianExploreTarget
PUBLIC	?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::FindBarbarianGankTradeRouteTarget
EXTRN	?GetNumTradeRoutesInPlot@CvGameTrade@@QAEHPAVCvPlot@@@Z:PROC ; CvGameTrade::GetNumTradeRoutesInPlot
EXTRN	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ:PROC ; CvGame::GetGameTrade
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$0
__ehfuncinfo$?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
tv362 = -44						; size = 4
tv377 = -40						; size = 4
_iMovementRange$ = -36					; size = 4
_iBestValue$ = -32					; size = 4
_pBestMovePlot$ = -28					; size = 4
tv267 = -24						; size = 4
tv257 = -20						; size = 4
$T246940 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvTacticalAI::FindBarbarianGankTradeRouteTarget, COMDAT
; _this$ = ecx

; 9934 : {

	push	-1
	push	__ehhandler$?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 9935 : 	CvPlot* pBestMovePlot = NULL;
; 9936 : 	int iBestValue;
; 9937 : 	int iValue;
; 9938 : 
; 9939 : 	// Now looking for BEST score
; 9940 : 	iBestValue = 0;
; 9941 : 	int iMovementRange = pUnit->movesLeft() / GC.getMOVE_DENOMINATOR();

	mov	ecx, DWORD PTR _pUnit$[esp+56]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+68], edi
	mov	DWORD PTR _pBestMovePlot$[esp+60], edi
	mov	DWORD PTR _iBestValue$[esp+60], edi
	call	?movesLeft@CvUnit@@QBEHXZ		; CvUnit::movesLeft
	cdq
	idiv	esi
	mov	ebp, DWORD PTR _pUnit$[esp+56]

; 9942 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 9943 : 	int iMaxDX, iX;
; 9944 : 	CvPlot* pPlot;
; 9945 : 	for (int iY = -iMovementRange; iY <= iMovementRange; iY++)
; 9946 : 	{
; 9947 : 		iMaxDX = iMovementRange - MAX(0, iY);
; 9948 : 		for (iX = -iMovementRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 9949 : 		{
; 9950 : 			pPlot = plotXY(pUnit->getX(), pUnit->getY(), iX, iY);
; 9951 : #else
; 9952 : 	for(int iX = -iMovementRange; iX <= iMovementRange; iX++)

	mov	ecx, eax
	neg	ecx
	mov	ebx, ecx
	cmp	ebx, eax
	mov	DWORD PTR _iMovementRange$[esp+60], eax
	mov	DWORD PTR tv257[esp+60], ecx
	jg	$LN10@FindBarbar@2
	mov	edx, ebx
	neg	edx
	mov	DWORD PTR tv377[esp+60], edx
	npad	2
$LL12@FindBarbar@2:

; 9953 : 	{
; 9954 : 		for(int iY = -iMovementRange; iY <= iMovementRange; iY++)

	mov	edi, ecx
	cmp	edi, eax
	jg	$LN11@FindBarbar@2

; 9955 : 		{
; 9956 : 			CvPlot* pPlot = plotXYWithRangeCheck(pUnit->getX(), pUnit->getY(), iX, iY, iMovementRange);

	xor	eax, eax
	test	ebx, ebx
	setge	al
	mov	DWORD PTR tv267[esp+60], eax
	mov	eax, edi
	neg	eax
	mov	DWORD PTR tv362[esp+60], eax
$LN9@FindBarbar@2:
	mov	edx, DWORD PTR [ebp+88]
	mov	esi, DWORD PTR [ebp+76]
	xor	ecx, ecx
	test	edi, edi
	setge	cl
	cmp	DWORD PTR tv267[esp+60], ecx
	mov	ecx, ebx
	jne	SHORT $LN35@FindBarbar@2
	test	ebx, ebx
	jge	SHORT $LN39@FindBarbar@2
	mov	ecx, DWORD PTR tv377[esp+60]
$LN39@FindBarbar@2:
	mov	eax, edi
	test	edi, edi
	jge	SHORT $LN41@FindBarbar@2
	mov	eax, DWORD PTR tv362[esp+60]
$LN41@FindBarbar@2:
	add	eax, ecx
	jmp	SHORT $LN46@FindBarbar@2
$LN35@FindBarbar@2:
	test	ebx, ebx
	jge	SHORT $LN43@FindBarbar@2
	mov	ecx, DWORD PTR tv377[esp+60]
$LN43@FindBarbar@2:
	mov	eax, edi
	test	edi, edi
	jge	SHORT $LN45@FindBarbar@2
	mov	eax, DWORD PTR tv362[esp+60]
$LN45@FindBarbar@2:
	cmp	ecx, eax
	jl	SHORT $LN46@FindBarbar@2
	mov	eax, ecx
$LN46@FindBarbar@2:
	cmp	eax, DWORD PTR _iMovementRange$[esp+60]
	jg	$LN8@FindBarbar@2
	push	edi
	push	ebx
	push	edx
	push	esi
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	esi, eax
	add	esp, 16					; 00000010H

; 9957 : #endif
; 9958 : 			if(!pPlot)

	test	esi, esi
	je	$LN8@FindBarbar@2

; 9959 : 			{
; 9960 : 				continue;
; 9961 : 			}
; 9962 : 
; 9963 : 			if(pUnit->atPlot(*pPlot))

	push	esi
	mov	ecx, ebp
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	test	al, al
	jne	$LN75@FindBarbar@2

; 9964 : 			{
; 9965 : 				continue;
; 9966 : 			}
; 9967 : 
; 9968 : 			if(!pPlot->isRevealed(pUnit->getTeam()))

	mov	ecx, DWORD PTR _pUnit$[esp+56]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	ebp, ecx
	mov	ecx, eax
	sub	ecx, ebp
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [esi+edx*4+8]
	je	SHORT $LN75@FindBarbar@2

; 9969 : 			{
; 9970 : 				continue;
; 9971 : 			}
; 9972 : 
; 9973 : 			if(pPlot->area() != pUnit->area())

	mov	ecx, DWORD PTR _pUnit$[esp+56]
	call	?area@CvUnit@@QBEPAVCvArea@@XZ		; CvUnit::area
	mov	ecx, esi
	mov	ebp, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	eax, ebp
	jne	SHORT $LN75@FindBarbar@2

; 9974 : 			{
; 9975 : 				continue;
; 9976 : 			}
; 9977 : 
; 9978 : 			if(!CanReachInXTurns(pUnit, pPlot, 1))

	mov	ecx, DWORD PTR _pUnit$[esp+56]
	push	0
	push	0
	push	1
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _pUnit$[esp+84]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T246940[esp+84], esp
	test	eax, eax
	je	SHORT $LN61@FindBarbar@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN61@FindBarbar@2:
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	test	al, al
	je	SHORT $LN75@FindBarbar@2

; 9979 : 			{
; 9980 : 				continue;
; 9981 : 			}
; 9982 : 
; 9983 : 			iValue = GC.getGame().GetGameTrade()->GetNumTradeRoutesInPlot(pPlot);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetNumTradeRoutesInPlot@CvGameTrade@@QAEHPAVCvPlot@@@Z ; CvGameTrade::GetNumTradeRoutesInPlot

; 9984 : 
; 9985 : 			if(iValue > iBestValue)

	cmp	eax, DWORD PTR _iBestValue$[esp+60]
	jle	SHORT $LN75@FindBarbar@2

; 9986 : 			{
; 9987 : 				pBestMovePlot = pPlot;

	mov	DWORD PTR _pBestMovePlot$[esp+60], esi

; 9988 : 				iBestValue = iValue;

	mov	DWORD PTR _iBestValue$[esp+60], eax
$LN75@FindBarbar@2:
	mov	ebp, DWORD PTR _pUnit$[esp+56]
$LN8@FindBarbar@2:

; 9953 : 	{
; 9954 : 		for(int iY = -iMovementRange; iY <= iMovementRange; iY++)

	dec	DWORD PTR tv362[esp+60]
	inc	edi
	cmp	edi, DWORD PTR _iMovementRange$[esp+60]
	jle	$LN9@FindBarbar@2
	mov	ecx, DWORD PTR tv257[esp+60]
	mov	eax, DWORD PTR _iMovementRange$[esp+60]
$LN11@FindBarbar@2:
	dec	DWORD PTR tv377[esp+60]
	inc	ebx
	cmp	ebx, eax
	jle	$LL12@FindBarbar@2

; 9942 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 9943 : 	int iMaxDX, iX;
; 9944 : 	CvPlot* pPlot;
; 9945 : 	for (int iY = -iMovementRange; iY <= iMovementRange; iY++)
; 9946 : 	{
; 9947 : 		iMaxDX = iMovementRange - MAX(0, iY);
; 9948 : 		for (iX = -iMovementRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 9949 : 		{
; 9950 : 			pPlot = plotXY(pUnit->getX(), pUnit->getY(), iX, iY);
; 9951 : #else
; 9952 : 	for(int iX = -iMovementRange; iX <= iMovementRange; iX++)

	mov	edi, DWORD PTR _pBestMovePlot$[esp+60]
$LN10@FindBarbar@2:

; 9989 : 			}
; 9990 : 		}
; 9991 : 	}
; 9992 : 	return pBestMovePlot;

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	ebp, ebp
	je	SHORT $LN74@FindBarbar@2
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN74@FindBarbar@2:

; 9993 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 44					; 0000002cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvTacticalAI::FindBarbarianGankTradeRouteTarget
PUBLIC	?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z ; CvTacticalAI::FindNearbyTarget
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
EXTRN	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z:PROC ; CvPlot::getNumFriendlyUnitsOfType
EXTRN	?getArea@CvUnit@@QBEHXZ:PROC			; CvUnit::getArea
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z$0
__ehfuncinfo$?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
_iBestValue$ = -32					; size = 4
_iI$225533 = -28					; size = 4
tv621 = -24						; size = 4
_pBestMovePlot$ = -20					; size = 4
$T247076 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_iRange$ = 16						; size = 4
_eType$ = 20						; size = 4
_pNoLikeUnit$ = 24					; size = 4
?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z PROC ; CvTacticalAI::FindNearbyTarget, COMDAT
; _this$ = ecx

; 9998 : {

	push	-1
	push	__ehhandler$?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	edx, ecx
	push	edi
	mov	DWORD PTR _this$[esp+52], edx
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+60], eax

; 9999 : 	CvPlot* pBestMovePlot = NULL;
; 10000: 	int iBestValue;
; 10001: 	int iValue;
; 10002: 	CvPlot* pPlot;
; 10003: 
; 10004: 	iBestValue = MAX_INT;

	mov	DWORD PTR _iBestValue$[esp+52], 2147483647 ; 7fffffffH

; 10005: 	pBestMovePlot = NULL;

	mov	DWORD PTR _pBestMovePlot$[esp+52], eax

; 10006: 
; 10007: 	// Loop through all appropriate targets to find the closest
; 10008: 	for(unsigned int iI = 0; iI < m_ZoneTargets.size(); iI++)

	mov	DWORD PTR _iI$225533[esp+52], eax
	cmp	DWORD PTR [edx+9340], eax
	jbe	$LN14@FindNearby

; 9998 : {

	mov	DWORD PTR tv621[esp+52], eax
$LN16@FindNearby:

; 10009: 	{
; 10010: 		// Is the target of an appropriate type?
; 10011: 		bool bTypeMatch = false;
; 10012: 		if(eType == AI_TACTICAL_TARGET_NONE)

	mov	ecx, DWORD PTR _eType$[esp+48]
	test	ecx, ecx
	jne	SHORT $LN13@FindNearby

; 10013: 		{
; 10014: 			if(m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 10015: 			        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 10016: 			        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT ||
; 10017: 			        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_CITY ||
; 10018: 			        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_IMPROVEMENT)

	mov	ecx, DWORD PTR [edx+9336]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 7
	je	SHORT $LN137@FindNearby
	cmp	ecx, 6
	je	SHORT $LN137@FindNearby
	cmp	ecx, 5
	je	SHORT $LN137@FindNearby
	cmp	ecx, 1
	je	SHORT $LN137@FindNearby
	cmp	ecx, 3

; 10019: 			{
; 10020: 				bTypeMatch = true;
; 10021: 			}
; 10022: 		}

	jmp	SHORT $LN148@FindNearby
$LN13@FindNearby:

; 10023: 		else if(m_ZoneTargets[iI].GetTargetType() ==  eType)

	mov	esi, DWORD PTR [edx+9336]
	add	eax, esi
	cmp	DWORD PTR [eax], ecx
$LN148@FindNearby:
	jne	$LN15@FindNearby
$LN137@FindNearby:

; 10024: 		{
; 10025: 			bTypeMatch = true;
; 10026: 		}
; 10027: 
; 10028: 		// Is this unit near enough?
; 10029: 		if(bTypeMatch)
; 10030: 		{
; 10031: 			pPlot = GC.getMap().plot(m_ZoneTargets[iI].GetTargetX(), m_ZoneTargets[iI].GetTargetY());

	mov	ebx, DWORD PTR [eax+4]
	mov	ebp, DWORD PTR [eax+8]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN57@FindNearby
	cmp	ebp, -2147483647			; 80000001H
	je	$LN57@FindNearby
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4056]
	mov	ecx, DWORD PTR [edx+4020]
	test	al, al
	je	SHORT $LN67@FindNearby
	test	ebx, ebx
	jge	SHORT $LN69@FindNearby
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esi, ecx
	jmp	SHORT $LN71@FindNearby
$LN69@FindNearby:
	cmp	ebx, ecx
	jl	SHORT $LN67@FindNearby
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN71@FindNearby
$LN67@FindNearby:
	mov	esi, ebx
$LN71@FindNearby:
	mov	al, BYTE PTR [edx+4057]
	mov	edi, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN77@FindNearby
	test	ebp, ebp
	jge	SHORT $LN79@FindNearby
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN81@FindNearby
$LN79@FindNearby:
	cmp	ebp, edi
	jl	SHORT $LN77@FindNearby
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN81@FindNearby
$LN77@FindNearby:
	mov	edx, ebp
$LN81@FindNearby:
	test	esi, esi
	jl	SHORT $LN57@FindNearby
	cmp	esi, ecx
	jge	SHORT $LN57@FindNearby
	test	edx, edx
	jl	SHORT $LN57@FindNearby
	cmp	edx, edi
	jge	SHORT $LN57@FindNearby
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	esi, ecx
	jmp	SHORT $LN59@FindNearby
$LN57@FindNearby:
	xor	esi, esi
$LN59@FindNearby:

; 10032: 			int iDistance = plotDistance(pUnit->getX(), pUnit->getY(), m_ZoneTargets[iI].GetTargetX(), m_ZoneTargets[iI].GetTargetY());

	mov	edi, DWORD PTR _pUnit$[esp+48]
	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	ebp
	push	ebx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 10033: 			if(iDistance == 0)

	test	eax, eax
	je	$LN135@FindNearby

; 10036: 			}
; 10037: 			else if(iDistance < iRange)

	cmp	eax, DWORD PTR _iRange$[esp+48]
	jge	SHORT $LN145@FindNearby

; 10038: 			{
; 10039: 				if(pUnit->getArea() == pPlot->getArea())

	mov	ebx, DWORD PTR [esi+356]
	mov	ecx, edi
	call	?getArea@CvUnit@@QBEHXZ			; CvUnit::getArea
	cmp	eax, ebx
	jne	SHORT $LN145@FindNearby

; 10040: 				{
; 10041: 					if(!pNoLikeUnit || pPlot->getNumFriendlyUnitsOfType(pNoLikeUnit) == 0)

	mov	eax, DWORD PTR _pNoLikeUnit$[esp+48]
	test	eax, eax
	je	SHORT $LN2@FindNearby
	push	1
	push	eax
	mov	ecx, esi
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	test	eax, eax
	jne	SHORT $LN145@FindNearby
$LN2@FindNearby:

; 10042: 					{
; 10043: 						iValue = TurnsToReachTarget(pUnit, pPlot, true /*bReusePaths*/);

	mov	ecx, DWORD PTR _pUnit$[esp+48]
	push	0
	push	0
	push	1
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _pUnit$[esp+76]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T247076[esp+76], esp
	test	eax, eax
	je	SHORT $LN127@FindNearby
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN127@FindNearby:
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 10044: 						if(iValue < iBestValue)

	cmp	eax, DWORD PTR _iBestValue$[esp+52]
	jge	SHORT $LN145@FindNearby

; 10045: 						{
; 10046: 							pBestMovePlot = pPlot;

	mov	DWORD PTR _pBestMovePlot$[esp+52], esi

; 10047: 							iBestValue = iValue;

	mov	DWORD PTR _iBestValue$[esp+52], eax
$LN145@FindNearby:
	mov	edx, DWORD PTR _this$[esp+52]
$LN15@FindNearby:

; 10006: 
; 10007: 	// Loop through all appropriate targets to find the closest
; 10008: 	for(unsigned int iI = 0; iI < m_ZoneTargets.size(); iI++)

	mov	ecx, DWORD PTR _iI$225533[esp+52]
	mov	eax, DWORD PTR tv621[esp+52]
	inc	ecx
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _iI$225533[esp+52], ecx
	mov	DWORD PTR tv621[esp+52], eax
	cmp	ecx, DWORD PTR [edx+9340]
	jb	$LN16@FindNearby
$LN14@FindNearby:

; 10048: 						}
; 10049: 					}
; 10050: 				}
; 10051: 			}
; 10052: 		}
; 10053: 	}
; 10054: 
; 10055: 	return pBestMovePlot;

	mov	ecx, DWORD PTR _pUnit$[esp+48]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	test	ecx, ecx
	je	SHORT $LN132@FindNearby
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN132@FindNearby:
	mov	eax, DWORD PTR _pBestMovePlot$[esp+52]

; 10056: }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	20					; 00000014H
$LN135@FindNearby:

; 10034: 			{
; 10035: 				return pPlot;

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 10056: }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 36					; 00000024H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z ENDP ; CvTacticalAI::FindNearbyTarget
PUBLIC	?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z ; CvTacticalAI::NearVisibleEnemy
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z$1
__ehfuncinfo$?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z
_TEXT	SEGMENT
_iLoop$ = -32						; size = 4
_this$ = -28						; size = 4
tv554 = -24						; size = 4
_pLoopUnit$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_iRange$ = 16						; size = 4
?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z PROC ; CvTacticalAI::NearVisibleEnemy, COMDAT
; _this$ = ecx

; 10061: {

	push	-1
	push	__ehhandler$?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+48], edi
	xor	eax, eax

; 10062: 	UnitHandle pLoopUnit;

	xor	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+56], eax
	mov	DWORD PTR _pLoopUnit$[esp+48], ebp
	mov	BYTE PTR _pLoopUnit$[esp+52], al
	mov	BYTE PTR __$EHRec$[esp+56], 1
	mov	DWORD PTR tv554[esp+48], eax
	npad	5
$LL182@NearVisibl:

; 10068: 	{
; 10069: 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 10070: 		if(kPlayer.isAlive() && atWar(kPlayer.getTeam(), m_pPlayer->getTeam()))

	cmp	BYTE PTR [eax+ecx+2256], 0
	lea	ebx, DWORD PTR [eax+ecx]
	je	$LN13@NearVisibl
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN31@NearVisibl
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN32@NearVisibl
$LN31@NearVisibl:
	or	eax, -1
$LN32@NearVisibl:
	mov	ecx, DWORD PTR [ebx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN40@NearVisibl
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN41@NearVisibl
$LN40@NearVisibl:
	or	ecx, -1
$LN41@NearVisibl:
	push	eax
	push	ecx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	$LN181@NearVisibl

; 10071: 		{
; 10072: 			// Loop through their units
; 10073: 			for(pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit; pLoopUnit = kPlayer.nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[esp+52]
	push	eax
	mov	ecx, ebx
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
$LN187@NearVisibl:
	mov	esi, eax
	test	ebp, ebp
	je	SHORT $LN49@NearVisibl
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN49@NearVisibl:
	mov	ebp, esi
	mov	DWORD PTR _pLoopUnit$[esp+48], ebp
	test	esi, esi
	je	SHORT $LN180@NearVisibl
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 10074: 			{
; 10075: 				// Make sure this tile is visible to us
; 10076: 				if(pLoopUnit->plot()->isVisible(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN67@NearVisibl
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN68@NearVisibl
$LN67@NearVisibl:
	or	esi, -1
$LN68@NearVisibl:
	mov	ecx, ebp
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	esi, -1
	je	SHORT $LN9@NearVisibl
	mov	edx, DWORD PTR [eax+156]
	cmp	WORD PTR [edx+esi*2], 0
	setg	al
	test	al, al
	je	SHORT $LN9@NearVisibl

; 10077: 				{
; 10078: 					// Check distance
; 10079: 					if(plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pUnit->getX(), pUnit->getY()) <= iRange)

	mov	eax, DWORD PTR _pUnit$[esp+44]
	mov	ecx, DWORD PTR [eax+88]
	mov	eax, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [ebp+88]
	mov	esi, DWORD PTR [ebp+76]
	push	ecx
	push	eax
	push	edx
	push	esi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iRange$[esp+44]
	jle	$LN170@NearVisibl
$LN9@NearVisibl:

; 10071: 		{
; 10072: 			// Loop through their units
; 10073: 			for(pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit; pLoopUnit = kPlayer.nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[esp+52]
	push	eax
	mov	ecx, ebx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	jmp	$LN187@NearVisibl
$LN180@NearVisibl:

; 10082: 					}
; 10083: 				}
; 10084: 			}
; 10085: 
; 10086: 			// Loop through their cities
; 10087: 			for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+52]
	push	ecx
	mov	ecx, ebx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN181@NearVisibl
	npad	7
$LL5@NearVisibl:

; 10088: 			{
; 10089: 				// Make sure this tile is visible to us
; 10090: 				if(pLoopCity->plot()->isVisible(m_pPlayer->getTeam()))

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN117@NearVisibl
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN118@NearVisibl
$LN117@NearVisibl:
	or	edi, -1
$LN118@NearVisibl:
	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	edi, -1
	je	SHORT $LN4@NearVisibl
	mov	eax, DWORD PTR [eax+156]
	cmp	WORD PTR [eax+edi*2], 0
	setg	al
	test	al, al
	je	SHORT $LN4@NearVisibl

; 10091: 				{
; 10092: 					// Check distance
; 10093: 					if(plotDistance(pLoopCity->getX(), pLoopCity->getY(), pUnit->getX(), pUnit->getY()) <= iRange)

	mov	edi, DWORD PTR _pUnit$[esp+44]
	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	mov	edx, DWORD PTR [esi+108]
	mov	esi, DWORD PTR [esi+96]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iRange$[esp+44]
	jle	$LN171@NearVisibl
$LN4@NearVisibl:

; 10082: 					}
; 10083: 				}
; 10084: 			}
; 10085: 
; 10086: 			// Loop through their cities
; 10087: 			for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+52]
	push	ecx
	mov	ecx, ebx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, DWORD PTR _this$[esp+48]
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL5@NearVisibl
$LN181@NearVisibl:
	mov	eax, DWORD PTR tv554[esp+48]
$LN13@NearVisibl:

; 10063: 	CvCity* pLoopCity = NULL;
; 10064: 	int iLoop;
; 10065: 
; 10066: 	// Loop through enemies
; 10067: 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	add	eax, 63236				; 0000f704H
	cmp	eax, 4047104				; 003dc100H
	mov	DWORD PTR tv554[esp+48], eax
	jl	$LL182@NearVisibl

; 10096: 					}
; 10097: 				}
; 10098: 			}
; 10099: 		}
; 10100: 	}
; 10101: 	return false;

	mov	BYTE PTR __$EHRec$[esp+56], 0
	test	ebp, ebp
	je	SHORT $LN160@NearVisibl
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN160@NearVisibl:
	mov	ecx, DWORD PTR _pUnit$[esp+44]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	test	ecx, ecx
	je	SHORT $LN165@NearVisibl
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN165@NearVisibl:
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx

; 10102: }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	12					; 0000000cH
$LN170@NearVisibl:

; 10080: 					{
; 10081: 						return true;

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+56], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, DWORD PTR _pUnit$[esp+44]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	test	ecx, ecx
	je	SHORT $LN111@NearVisibl
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN111@NearVisibl:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 10102: }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	12					; 0000000cH
$LN171@NearVisibl:

; 10094: 					{
; 10095: 						return true;

	mov	BYTE PTR __$EHRec$[esp+56], 0
	test	ebp, ebp
	je	SHORT $LN150@NearVisibl
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	edi, DWORD PTR _pUnit$[esp+44]
$LN150@NearVisibl:
	mov	DWORD PTR __$EHRec$[esp+56], -1
	test	edi, edi
	je	SHORT $LN155@NearVisibl
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN155@NearVisibl:

; 10102: }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z$1:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z ENDP ; CvTacticalAI::NearVisibleEnemy
PUBLIC	?UseThisDominanceZone@CvTacticalAI@@AAE_NPAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::UseThisDominanceZone
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Ogtpy
;	COMDAT ?UseThisDominanceZone@CvTacticalAI@@AAE_NPAVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
_bIsOurCapital$ = -1					; size = 1
_pZone$ = 8						; size = 4
?UseThisDominanceZone@CvTacticalAI@@AAE_NPAVCvTacticalDominanceZone@@@Z PROC ; CvTacticalAI::UseThisDominanceZone, COMDAT
; _this$ = ecx

; 11472: {

	push	ecx
	push	ebx
	push	esi

; 11473: 	bool bIsOurCapital = false;
; 11474: 	bool bTempZone = false;
; 11475: 	int iCityID = -1;
; 11476: 	if(pZone->GetClosestCity() != NULL)

	mov	esi, DWORD PTR _pZone$[esp+8]
	push	edi
	mov	edi, ecx
	mov	ecx, esi
	mov	BYTE PTR _bIsOurCapital$[esp+16], 0
	xor	bl, bl
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	test	eax, eax
	je	SHORT $LN1@UseThisDom

; 11477: 	{
; 11478: 		iCityID = pZone->GetClosestCity()->GetID();

	mov	ecx, esi
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity

; 11479: 		bIsOurCapital = (pZone->GetClosestCity() == m_pPlayer->getCapitalCity());

	mov	ecx, DWORD PTR [edi]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, esi
	mov	ebx, eax
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	cmp	eax, ebx

; 11480: 		bTempZone = IsTemporaryZoneCity(pZone->GetClosestCity());

	mov	ecx, esi
	sete	BYTE PTR _bIsOurCapital$[esp+16]
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	push	eax
	mov	ecx, edi
	call	?IsTemporaryZoneCity@CvTacticalAI@@QAE_NPAVCvCity@@@Z ; CvTacticalAI::IsTemporaryZoneCity
	mov	bl, al
$LN1@UseThisDom:

; 11481: 	}
; 11482: 	bool bWeHaveUnitsNearEnemy = pZone->GetFriendlyUnitCount() > 0 && pZone->GetTerritoryType() == TACTICAL_TERRITORY_ENEMY;

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jle	SHORT $LN4@UseThisDom
	cmp	DWORD PTR [esi+4], 3
	jne	SHORT $LN4@UseThisDom
	mov	dl, 1
	jmp	SHORT $LN5@UseThisDom
$LN4@UseThisDom:
	xor	dl, dl
$LN5@UseThisDom:

; 11483: 	bool bTheyHaveUnitsNearUs = pZone->GetDominanceFlag() != TACTICAL_DOMINANCE_NO_UNITS_VISIBLE && pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY;

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN6@UseThisDom
	cmp	DWORD PTR [esi+4], 2
	jne	SHORT $LN6@UseThisDom
	mov	cl, 1
	jmp	SHORT $LN7@UseThisDom
$LN6@UseThisDom:
	xor	cl, cl
$LN7@UseThisDom:

; 11484: 	bool bBothHaveUnits = pZone->GetFriendlyUnitCount() > 0 && pZone->GetEnemyUnitCount() > 0;

	test	eax, eax
	jle	SHORT $LN8@UseThisDom
	cmp	DWORD PTR [esi+44], 0
	jle	SHORT $LN8@UseThisDom
	mov	al, 1
	jmp	SHORT $LN9@UseThisDom
$LN8@UseThisDom:
	xor	al, al
$LN9@UseThisDom:
	pop	edi
	pop	esi

; 11485: 
; 11486: 	return (bTempZone || bIsOurCapital || bWeHaveUnitsNearEnemy || bTheyHaveUnitsNearUs || bBothHaveUnits);

	test	bl, bl
	pop	ebx
	jne	SHORT $LN10@UseThisDom
	cmp	BYTE PTR _bIsOurCapital$[esp+4], 0
	jne	SHORT $LN10@UseThisDom
	test	dl, dl
	jne	SHORT $LN10@UseThisDom
	test	cl, cl
	jne	SHORT $LN10@UseThisDom
	test	al, al
	jne	SHORT $LN10@UseThisDom
	xor	eax, eax

; 11487: }

	pop	ecx
	ret	4
$LN10@UseThisDom:

; 11485: 
; 11486: 	return (bTempZone || bIsOurCapital || bWeHaveUnitsNearEnemy || bTheyHaveUnitsNearUs || bBothHaveUnits);

	mov	eax, 1

; 11487: }

	pop	ecx
	ret	4
?UseThisDominanceZone@CvTacticalAI@@AAE_NPAVCvTacticalDominanceZone@@@Z ENDP ; CvTacticalAI::UseThisDominanceZone
_TEXT	ENDS
PUBLIC	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z
_TEXT	SEGMENT
_strPlayerName$226148 = -180				; size = 28
_strBaseString$226147 = -152				; size = 28
_strTemp$226149 = -124					; size = 28
$T247738 = -96						; size = 28
$T247737 = -96						; size = 28
_strOutBuf$226146 = -68					; size = 28
$T247736 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 4
_bSkipLogDominanceZone$ = 12				; size = 1
?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z PROC ; CvTacticalAI::LogTacticalMessage, COMDAT
; _this$ = ecx

; 11585: {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 168				; 000000a8H
	push	edi
	mov	edi, ecx

; 11586: 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN3@LogTactica
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN3@LogTactica
	push	ebx
	push	esi

; 11587: 	{
; 11588: 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$226146[esp+192]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 11589: 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226147[esp+192]
	mov	DWORD PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 11590: 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$226148[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 11591: 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226149[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 11592: 		FILogFile* pLog;
; 11593: 
; 11594: 		strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	bl, 3
	mov	BYTE PTR __$EHRec$[esp+200], bl
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$226148[esp+192]
	test	eax, eax
	je	SHORT $LN26@LogTactica
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN25@LogTactica
$LN26@LogTactica:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN25@LogTactica:

; 11595: 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	lea	eax, DWORD PTR _strPlayerName$226148[esp+192]
	push	eax
	lea	ecx, DWORD PTR $T247736[esp+196]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvTacticalAI@@ABE?AVCvString@@AAV2@@Z ; CvTacticalAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+200], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T247736[esp+192]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+200], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 11596: 
; 11597: 		// Get the leading info for this line
; 11598: 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226147[esp+196]
	push	OFFSET $SG226152
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 11599: 		strBaseString += strPlayerName + ", ";

	push	OFFSET $SG226154
	lea	edx, DWORD PTR _strPlayerName$226148[esp+208]
	push	edx
	lea	eax, DWORD PTR $T247737[esp+212]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226147[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 5
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T247737[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 11600: 		strTemp = "no zone, ";

	push	OFFSET $SG226155
	lea	ecx, DWORD PTR _strTemp$226149[esp+196]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 11601: 		if(!bSkipLogDominanceZone)

	cmp	BYTE PTR _bSkipLogDominanceZone$[esp+188], 0
	jne	SHORT $LN1@LogTactica

; 11602: 		{
; 11603: 			CvTacticalDominanceZone* pZone = GC.getGame().GetTacticalAnalysisMap()->GetZone(m_iCurrentZoneIndex);

	mov	ecx, DWORD PTR [edi+24792]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	ecx, eax
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone

; 11604: 			if(pZone != NULL)

	test	eax, eax
	je	SHORT $LN1@LogTactica

; 11605: 			{
; 11606: 				strTemp.Format("Zone ID: %d, ", pZone->GetDominanceZoneID());

	mov	eax, DWORD PTR [eax]
	push	eax
	lea	edx, DWORD PTR _strTemp$226149[esp+196]
	push	OFFSET $SG226159
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH
$LN1@LogTactica:

; 11607: 			}
; 11608: 		}
; 11609: 		strBaseString += strTemp;

	lea	eax, DWORD PTR _strTemp$226149[esp+192]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$226147[esp+196]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 11610: 		strOutBuf = strBaseString + strMsg;

	mov	ecx, DWORD PTR _strMsg$[esp+188]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$226147[esp+196]
	push	edx
	lea	eax, DWORD PTR $T247738[esp+200]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+200], 6
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226146[esp+196]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T247738[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 11611: 
; 11612: 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226146[esp+192]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 11613: 	}

	lea	ecx, DWORD PTR _strTemp$226149[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$226148[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$226147[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$226146[esp+192]
	mov	DWORD PTR __$EHRec$[esp+200], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebx
$LN3@LogTactica:

; 11614: }

	mov	ecx, DWORD PTR __$EHRec$[esp+184]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 180				; 000000b4H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$226146[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$1:
	lea	ecx, DWORD PTR _strBaseString$226147[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$2:
	lea	ecx, DWORD PTR _strPlayerName$226148[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$3:
	lea	ecx, DWORD PTR _strTemp$226149[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$4:
	lea	ecx, DWORD PTR $T247736[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$5:
	lea	ecx, DWORD PTR $T247737[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z$6:
	lea	ecx, DWORD PTR $T247738[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ENDP ; CvTacticalAI::LogTacticalMessage
PUBLIC	?begin@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@XZ ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@XZ PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@XZ ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@XZ ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@XZ PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@XZ ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ; std::list<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ PROC ; std::list<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 560  : 		return (iterator(_Nextnode(_Myhead)));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 561  : 		}

	ret	4
?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ENDP ; std::list<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ; std::list<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ PROC ; std::list<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 570  : 		return (iterator(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 571  : 		}

	ret	4
?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ENDP ; std::list<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ	; std::list<int,std::allocator<int> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::list<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 825  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 826  : 
; 827  :  #if _HAS_ITERATOR_DEBUGGING
; 828  : 		this->_Orphan_ptr(*this, 0);
; 829  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 830  : 
; 831  : 		_Nodeptr _Pnext;
; 832  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx]

; 833  : 		_Nextnode(_Myhead) = _Myhead;

	mov	DWORD PTR [ecx], ecx

; 834  : 		_Prevnode(_Myhead) = _Myhead;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ecx

; 835  : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0

; 836  : 
; 837  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN1@clear
	push	edi
	npad	3
$LL3@clear:

; 838  : 			{	// delete an element
; 839  : 			_Pnext = _Nextnode(_Pnode);

	mov	edi, DWORD PTR [eax]

; 840  : 			this->_Alnod.destroy(_Pnode);
; 841  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, edi
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LL3@clear
	pop	edi
$LN1@clear:
	pop	esi

; 842  : 			}
; 843  : 		}

	ret	0
?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::list<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@XZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@XZ PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@XZ ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@XZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@XZ PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@XZ ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@XZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@XZ PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@XZ ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@XZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@XZ PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@XZ ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::end
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalMove,256,1,297,0>::~FStaticVector<CvTacticalMove,256,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTacticalMove,256,1,297,0>::~FStaticVector<CvTacticalMove,256,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTacticalMove,256,1,297,0>::~FStaticVector<CvTacticalMove,256,1,297,0>
_TEXT	ENDS
PUBLIC	?begin@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?begin@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::begin, COMDAT
; _this$ = ecx

; 560  : 		return (iterator(_Nextnode(_Myhead)));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 561  : 		}

	ret	4
?begin@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::end, COMDAT
; _this$ = ecx

; 570  : 		return (iterator(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 571  : 		}

	ret	4
?end@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::end
_TEXT	ENDS
PUBLIC	?clear@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEXXZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEXXZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::clear, COMDAT
; _this$ = ecx

; 825  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 826  : 
; 827  :  #if _HAS_ITERATOR_DEBUGGING
; 828  : 		this->_Orphan_ptr(*this, 0);
; 829  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 830  : 
; 831  : 		_Nodeptr _Pnext;
; 832  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx]

; 833  : 		_Nextnode(_Myhead) = _Myhead;

	mov	DWORD PTR [ecx], ecx

; 834  : 		_Prevnode(_Myhead) = _Myhead;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ecx

; 835  : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0

; 836  : 
; 837  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN1@clear@2
	push	edi
	npad	3
$LL3@clear@2:

; 838  : 			{	// delete an element
; 839  : 			_Pnext = _Nextnode(_Pnode);

	mov	edi, DWORD PTR [eax]

; 840  : 			this->_Alnod.destroy(_Pnode);
; 841  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, edi
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LL3@clear@2
	pop	edi
$LN1@clear@2:
	pop	esi

; 842  : 			}
; 843  : 		}

	ret	0
?clear@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEXXZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::clear
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,256,0,297,0>::~FStaticVector<CvTacticalTarget,256,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTacticalTarget,256,0,297,0>::~FStaticVector<CvTacticalTarget,256,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@3:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTacticalTarget,256,0,297,0>::~FStaticVector<CvTacticalTarget,256,0,297,0>
_TEXT	ENDS
PUBLIC	??4?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??4?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<CvTacticalTarget,256,0,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	esi
	mov	esi, ecx

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	edi, DWORD PTR _RHS$[esp+4]
	cmp	eax, DWORD PTR [edi+4]
	ja	SHORT $LN2@operator@10

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN5@operator@10
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN5@operator@10:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edx, DWORD PTR [edi+8]
	push	edx
	mov	ecx, esi
	call	?Alloc@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEPAVCvTacticalTarget@@I@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::Alloc
	mov	DWORD PTR [esi], eax
$LN2@operator@10:

; 624  : 		}else{
; 625  : 			Destroy(m_pData, m_uiCurrSize);
; 626  : 		}
; 627  : 		Copy(RHS);

	push	edi
	mov	ecx, esi
	call	?Copy@?$BaseVector@VCvTacticalTarget@@$0A@@@IAEXABV1@@Z ; BaseVector<CvTacticalTarget,0>::Copy
	pop	edi
	pop	esi

; 628  : 	};

	ret	4
??4?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<CvTacticalTarget,256,0,297,0>::operator=
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,37,1,297,0>::~FStaticVector<CvTacticalTarget,37,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTacticalTarget,37,1,297,0>::~FStaticVector<CvTacticalTarget,37,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@4
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@4:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTacticalTarget,37,1,297,0>::~FStaticVector<CvTacticalTarget,37,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalPosture,64,1,297,0>::~FStaticVector<CvTacticalPosture,64,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTacticalPosture,64,1,297,0>::~FStaticVector<CvTacticalPosture,64,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@5:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTacticalPosture,64,1,297,0>::~FStaticVector<CvTacticalPosture,64,1,297,0>
_TEXT	ENDS
PUBLIC	??4?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvTacticalPosture,64,1,297,0>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??4?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<CvTacticalPosture,64,1,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	ebp, DWORD PTR _RHS$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [ebp+4]
	ja	SHORT $LN2@operator@11

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	ebx
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	cmp	eax, ebx
	je	SHORT $LN5@operator@11
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN5@operator@11:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebp+8]
	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN16@operator@11
	push	798					; 0000031eH
	lea	ecx, DWORD PTR [edi+edi*2]
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	ecx, ecx
	add	ecx, ecx
	push	4
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN15@operator@11
$LN16@operator@11:
	mov	eax, ebx
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN15@operator@11:
	pop	edi
	mov	DWORD PTR [esi], eax
	pop	ebx
$LN2@operator@11:

; 624  : 		}else{
; 625  : 			Destroy(m_pData, m_uiCurrSize);
; 626  : 		}
; 627  : 		Copy(RHS);

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+4], edx
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebp

; 628  : 	};

	ret	4
??4?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<CvTacticalPosture,64,1,297,0>::operator=
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTemporaryZone,10,1,297,0>::~FStaticVector<CvTemporaryZone,10,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTemporaryZone,10,1,297,0>::~FStaticVector<CvTemporaryZone,10,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@6
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@6:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTemporaryZone,10,1,297,0>::~FStaticVector<CvTemporaryZone,10,1,297,0>
_TEXT	ENDS
PUBLIC	??4?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??4?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<CvTemporaryZone,10,1,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	ebp, DWORD PTR _RHS$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [ebp+4]
	ja	SHORT $LN2@operator@12

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	ebx
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	cmp	eax, ebx
	je	SHORT $LN5@operator@12
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN5@operator@12:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebp+8]
	cmp	edi, 10					; 0000000aH
	jbe	SHORT $LN16@operator@12
	push	798					; 0000031eH
	lea	ecx, DWORD PTR [edi+edi*4]
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	ecx, ecx
	add	ecx, ecx
	push	4
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN15@operator@12
$LN16@operator@12:
	mov	eax, ebx
	mov	DWORD PTR [esi+8], 10			; 0000000aH
$LN15@operator@12:
	pop	edi
	mov	DWORD PTR [esi], eax
	pop	ebx
$LN2@operator@12:

; 624  : 		}else{
; 625  : 			Destroy(m_pData, m_uiCurrSize);
; 626  : 		}
; 627  : 		Copy(RHS);

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+4], edx
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebp

; 628  : 	};

	ret	4
??4?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<CvTemporaryZone,10,1,297,0>::operator=
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvBlockingUnit,25,1,297,0>::~FStaticVector<CvBlockingUnit,25,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvBlockingUnit,25,1,297,0>::~FStaticVector<CvBlockingUnit,25,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@7
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@7:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvBlockingUnit,25,1,297,0>::~FStaticVector<CvBlockingUnit,25,1,297,0>
_TEXT	ENDS
PUBLIC	??4?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??4?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<CvBlockingUnit,25,1,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	ebp, DWORD PTR _RHS$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [ebp+4]
	ja	SHORT $LN2@operator@13

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	ebx
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	cmp	eax, ebx
	je	SHORT $LN5@operator@13
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN5@operator@13:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebp+8]
	cmp	edi, 25					; 00000019H
	jbe	SHORT $LN16@operator@13
	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	mov	ecx, edi
	shl	ecx, 4
	push	4
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN15@operator@13
$LN16@operator@13:
	mov	eax, ebx
	mov	DWORD PTR [esi+8], 25			; 00000019H
$LN15@operator@13:
	pop	edi
	mov	DWORD PTR [esi], eax
	pop	ebx
$LN2@operator@13:

; 624  : 		}else{
; 625  : 			Destroy(m_pData, m_uiCurrSize);
; 626  : 		}
; 627  : 		Copy(RHS);

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+4], edx
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [esi]
	shl	eax, 4
	push	eax
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebp

; 628  : 	};

	ret	4
??4?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<CvBlockingUnit,25,1,297,0>::operator=
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAEIABVCvBlockingUnit@@@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAEIABVCvBlockingUnit@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAEIABVCvBlockingUnit@@@Z PROC ; FStaticVector<CvBlockingUnit,37,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+604], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAEIABVCvBlockingUnit@@@Z ENDP ; FStaticVector<CvBlockingUnit,37,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationUnit,20,1,297,0>::~FStaticVector<CvOperationUnit,20,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvOperationUnit,20,1,297,0>::~FStaticVector<CvOperationUnit,20,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@8
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@8:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvOperationUnit,20,1,297,0>::~FStaticVector<CvOperationUnit,20,1,297,0>
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::end
_TEXT	ENDS
PUBLIC	??D?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEAAVCvQueuedAttack@@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??D?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEAAVCvQueuedAttack@@XZ
_TEXT	SEGMENT
??D?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEAAVCvQueuedAttack@@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::operator*, COMDAT
; _this$ = ecx

; 394  : 			return ((reference)**(_Mybase_iter *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 395  : 			}

	ret	0
??D?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEAAVCvQueuedAttack@@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::operator*
_TEXT	ENDS
PUBLIC	??C?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEPAVCvQueuedAttack@@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEPAVCvQueuedAttack@@XZ
_TEXT	SEGMENT
??C?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEPAVCvQueuedAttack@@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::operator->, COMDAT
; _this$ = ecx

; 399  : 			return (&**this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 400  : 			}

	ret	0
??C?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBEPAVCvQueuedAttack@@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::operator->
_TEXT	ENDS
PUBLIC	??E?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV012@H@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV012@H@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::operator++, COMDAT
; _this$ = ecx

; 410  : 			_Myt_iter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 411  : 			++*this;

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 412  : 			return (_Tmp);
; 413  : 			}

	ret	8
??E?$_Iterator@$0A@@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??D?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::list<int,std::allocator<int> >::_Iterator<0>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC ; std::list<int,std::allocator<int> >::_Iterator<0>::operator*, COMDAT
; _this$ = ecx

; 394  : 			return ((reference)**(_Mybase_iter *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 395  : 			}

	ret	0
??D?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::list<int,std::allocator<int> >::_Iterator<0>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z ; std::list<int,std::allocator<int> >::_Iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z PROC ; std::list<int,std::allocator<int> >::_Iterator<0>::operator++, COMDAT
; _this$ = ecx

; 410  : 			_Myt_iter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 411  : 			++*this;

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 412  : 			return (_Tmp);
; 413  : 			}

	ret	8
??E?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<int,std::allocator<int> >::_Iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??0?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAE@I@Z ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAE@I@Z PROC ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	esi
	xor	eax, eax
	push	edi

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	mov	edi, DWORD PTR _uiStartingMaxSize$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	jbe	SHORT $LN5@FFastVecto
	push	85					; 00000055H
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN5@FFastVecto:
	mov	DWORD PTR [esi], eax
	pop	edi

; 315  : 	};

	mov	eax, esi
	pop	esi
	ret	4
??0?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAE@I@Z ENDP ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??1?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAE@XZ ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::~FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAE@XZ PROC ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::~FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 318  : 	};

	ret	0
??1?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAE@XZ ENDP ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::~FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++, COMDAT
; _this$ = ecx

; 355  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 356  : 		++*this;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 357  : 		return (_Tmp);
; 358  : 		}

	ret	8
??E?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
_TEXT	ENDS
PUBLIC	?clear@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXXZ ; CvWeightedVector<CvPlot *,1,1>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?clear@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXXZ PROC ; CvWeightedVector<CvPlot *,1,1>::clear, COMDAT
; _this$ = ecx

; 116  : 		m_pItems.clear();

	mov	DWORD PTR [ecx+4], 0

; 117  : 	};

	ret	0
?clear@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXXZ ENDP ; CvWeightedVector<CvPlot *,1,1>::clear
_TEXT	ENDS
PUBLIC	??C?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEPAVCvTacticalUnit@@XZ ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator->
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??C?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEPAVCvTacticalUnit@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEPAVCvTacticalUnit@@XZ PROC ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator->, COMDAT
; _this$ = ecx

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [ecx]

; 345  : 		}

	ret	0
??C?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBEPAVCvTacticalUnit@@XZ ENDP ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator->
_TEXT	ENDS
PUBLIC	??1?$_List_ptr@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_List_ptr<int,std::allocator<int> >::~_List_ptr<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_List_ptr@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_ptr@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_List_ptr<int,std::allocator<int> >::~_List_ptr<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_List_ptr@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_List_ptr<int,std::allocator<int> >::~_List_ptr<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1?$_List_ptr@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ; std::_List_ptr<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~_List_ptr<CvQueuedAttack,std::allocator<CvQueuedAttack> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_List_ptr@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_ptr@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ PROC ; std::_List_ptr<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~_List_ptr<CvQueuedAttack,std::allocator<CvQueuedAttack> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_List_ptr@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ENDP ; std::_List_ptr<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~_List_ptr<CvQueuedAttack,std::allocator<CvQueuedAttack> >
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvTacticalMoveXMLEntry@@@std@@YAPAPAVCvTacticalMoveXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvTacticalMoveXMLEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z PROC ; std::list<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 787  : 
; 788  :  #if _HAS_ITERATOR_DEBUGGING
; 789  : 		if (_Where._Mycont != this || _Where._Ptr == _Myhead)
; 790  : 			_DEBUG_ERROR("list erase iterator outside range");
; 791  : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 792  : 		_Orphan_ptr(*this, _Pnode);
; 793  : 
; 794  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 795  : 		_Nodeptr _Pnode = (_Where++)._Mynode();

	mov	eax, DWORD PTR __Where$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Where$[esp], ecx

; 796  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 797  : 
; 798  : 		if (_Pnode != _Myhead)

	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN32@erase

; 799  : 			{	// not list head, safe to erase
; 800  : 			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 801  : 			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 802  : 			this->_Alnod.destroy(_Pnode);
; 803  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	eax
	mov	DWORD PTR [ecx+4], edx
	call	??3@YAXPAX@Z				; operator delete

; 804  : 			--_Mysize;
; 805  : 			}
; 806  : 		return (_Make_iter(_Where));

	mov	ecx, DWORD PTR __Where$[esp+4]
	add	esp, 4
	dec	DWORD PTR [esi+8]
$LN32@erase:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 807  : 		}

	ret	8
?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ENDP ; std::list<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Buynode, COMDAT
; _this$ = ecx

; 1172 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1173 : 		int _Linkcnt = 0;
; 1174 : 
; 1175 : 		_TRY_BEGIN
; 1176 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

	test	eax, eax
	je	SHORT $LN26@Buynode
	mov	DWORD PTR [eax], eax
$LN26@Buynode:

; 1177 : 		++_Linkcnt;
; 1178 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN36@Buynode
	mov	DWORD PTR [ecx], eax
$LN36@Buynode:

; 1179 : 		_CATCH_ALL
; 1180 : 		if (0 < _Linkcnt)
; 1181 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1182 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1183 : 		_RERAISE;
; 1184 : 		_CATCH_END
; 1185 : 		return (_Pnode);
; 1186 : 		}

	ret	0
?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@HV?$allocator@H@std@@@std@@IAEXXZ	; std::list<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$list@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::list<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1212 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1213 : 		clear();

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ecx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ecx
	mov	DWORD PTR [esi+8], 0
	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN3@Tidy
	push	edi
	npad	3
$LL5@Tidy:
	mov	edi, DWORD PTR [eax]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, edi
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LL5@Tidy
	pop	edi
$LN3@Tidy:

; 1214 : 		this->_Alptr.destroy(&_Nextnode(_Myhead));
; 1215 : 		this->_Alptr.destroy(&_Prevnode(_Myhead));
; 1216 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1217 : 		_Myhead = 0;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 1218 : 		}

	ret	0
?_Tidy@?$list@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::list<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE_NI@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@VCvTacticalUnit@@@std@@YAPAVCvTacticalUnit@@IPAV1@@Z ; std::_Allocate<CvTacticalUnit>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@VCvTacticalCity@@@std@@YAPAVCvTacticalCity@@IPAV1@@Z ; std::_Allocate<CvTacticalCity>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Buy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalMove,256,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvTacticalMove,256,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@2
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@2
	npad	6
$LL8@GrowSize@2:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@2

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@2

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@2
$LN31@GrowSize@2:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@2:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 256				; 00000100H
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@2
$LN15@GrowSize@2:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 256			; 00000100H
$LN14@GrowSize@2:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+2060], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvTacticalMove,256,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?_Make_iter@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Make_iter@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Make_iter, COMDAT
; _this$ = ecx

; 580  : 		return (iterator(_Where._Ptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 581  : 		}

	ret	8
?_Make_iter@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Buynode, COMDAT
; _this$ = ecx

; 1172 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1173 : 		int _Linkcnt = 0;
; 1174 : 
; 1175 : 		_TRY_BEGIN
; 1176 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

	test	eax, eax
	je	SHORT $LN26@Buynode@2
	mov	DWORD PTR [eax], eax
$LN26@Buynode@2:

; 1177 : 		++_Linkcnt;
; 1178 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN36@Buynode@2
	mov	DWORD PTR [ecx], eax
$LN36@Buynode@2:

; 1179 : 		_CATCH_ALL
; 1180 : 		if (0 < _Linkcnt)
; 1181 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1182 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1183 : 		_RERAISE;
; 1184 : 		_CATCH_END
; 1185 : 		return (_Pnode);
; 1186 : 		}

	ret	0
?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXXZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXXZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Tidy, COMDAT
; _this$ = ecx

; 1212 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1213 : 		clear();

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ecx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ecx
	mov	DWORD PTR [esi+8], 0
	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN3@Tidy@2
	push	edi
	npad	3
$LL5@Tidy@2:
	mov	edi, DWORD PTR [eax]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, edi
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LL5@Tidy@2
	pop	edi
$LN3@Tidy@2:

; 1214 : 		this->_Alptr.destroy(&_Nextnode(_Myhead));
; 1215 : 		this->_Alptr.destroy(&_Prevnode(_Myhead));
; 1216 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1217 : 		_Myhead = 0;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 1218 : 		}

	ret	0
?_Tidy@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXXZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Tidy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_pRet$249137 = 8					; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvTacticalTarget,256,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [ebp+8], 0
	jne	SHORT $LN38@GrowSize@3
	mov	DWORD PTR [ebp+8], 1
$LN38@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp]
	cmp	edx, DWORD PTR [ebp+8]
	jb	SHORT $LN7@GrowSize@3
	npad	7
$LL8@GrowSize@3:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [ebp+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN33@GrowSize@3

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [ebp+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@3

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@3
$LN33@GrowSize@3:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [ebp+8], edx
$LN7@GrowSize@3:
	push	ebx
	push	esi

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	esi, DWORD PTR [ebp+8]
	cmp	esi, 256				; 00000100H
	jbe	SHORT $LN15@GrowSize@3
	push	798					; 0000031eH
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$249137[esp+8], eax
	mov	DWORD PTR [ebp+8], esi
	jmp	SHORT $LN14@GrowSize@3
$LN15@GrowSize@3:
	lea	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR _pRet$249137[esp+8], ecx
	mov	DWORD PTR [ebp+8], 256			; 00000100H
$LN14@GrowSize@3:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	ebx, ebx
	cmp	DWORD PTR [ebp+4], ebx
	jbe	SHORT $LN1@GrowSize@3
	mov	eax, DWORD PTR _pRet$249137[esp+8]
	xor	edx, edx
	push	edi
	npad	6
$LL39@GrowSize@3:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	eax, eax
	je	SHORT $LN2@GrowSize@3
	mov	esi, DWORD PTR [ebp]
	add	esi, edx
	mov	ecx, 7
	mov	edi, eax
	rep movsd
$LN2@GrowSize@3:
	inc	ebx
	add	edx, 28					; 0000001cH
	add	eax, 28					; 0000001cH
	cmp	ebx, DWORD PTR [ebp+4]
	jb	SHORT $LL39@GrowSize@3
	pop	edi
$LN1@GrowSize@3:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ebp]
	lea	edx, DWORD PTR [ebp+12]
	pop	esi
	pop	ebx
	cmp	eax, edx
	je	SHORT $LN37@GrowSize@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _pRet$249137[esp+4]
	add	esp, 4
	mov	DWORD PTR [ebp], eax

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [ebp+7180], 1
	pop	ebp

; 772  : 	};

	ret	4
$LN37@GrowSize@3:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _pRet$249137[esp]
	mov	DWORD PTR [ebp], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [ebp+7180], 1
	pop	ebp

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvTacticalTarget,256,0,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvTacticalTarget,37,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@4
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@4:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@4
	npad	6
$LL8@GrowSize@4:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@4

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@4

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@4
$LN31@GrowSize@4:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@4:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 37					; 00000025H
	jbe	SHORT $LN15@GrowSize@4
	push	798					; 0000031eH
	lea	eax, DWORD PTR [ebp*8]
	sub	eax, ebp
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@4
$LN15@GrowSize@4:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 37			; 00000025H
$LN14@GrowSize@4:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@4
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@4:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+1048], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvTacticalTarget,37,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalPosture,64,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvTacticalPosture,64,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@5
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@5:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@5
	npad	6
$LL8@GrowSize@5:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@5

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@5

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@5
$LN31@GrowSize@5:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@5:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 64					; 00000040H
	jbe	SHORT $LN15@GrowSize@5
	push	798					; 0000031eH
	lea	eax, DWORD PTR [ebp+ebp*2]
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@5
$LN15@GrowSize@5:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN14@GrowSize@5:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*2]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@5:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+780], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvTacticalPosture,64,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvTemporaryZone,10,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@6
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@6:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@6
	npad	6
$LL8@GrowSize@6:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@6

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@6

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@6
$LN31@GrowSize@6:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@6:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 10					; 0000000aH
	jbe	SHORT $LN15@GrowSize@6
	push	798					; 0000031eH
	lea	eax, DWORD PTR [ebp+ebp*4]
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@6
$LN15@GrowSize@6:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 10			; 0000000aH
$LN14@GrowSize@6:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@6
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@6:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+212], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvTemporaryZone,10,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@7
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@7:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@7
	npad	6
$LL8@GrowSize@7:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@7

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@7

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@7
$LN31@GrowSize@7:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@7:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 25					; 00000019H
	jbe	SHORT $LN15@GrowSize@7
	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	mov	eax, ebp
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@7
$LN15@GrowSize@7:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 25			; 00000019H
$LN14@GrowSize@7:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	shl	ecx, 4
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@7
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@7:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+412], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvOperationUnit,20,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@8
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@8:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@8
	npad	6
$LL8@GrowSize@8:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@8

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@8

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@8
$LN31@GrowSize@8:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@8:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 20					; 00000014H
	jbe	SHORT $LN15@GrowSize@8
	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@8
$LN15@GrowSize@8:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 20			; 00000014H
$LN14@GrowSize@8:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@8
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@8:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+172], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvOperationUnit,20,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@4
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
$LN16@Buy@4:
$LN2@Buy@4:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@4:
?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXPAPAVCvPlot@@0@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXPAPAVCvPlot@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXPAPAVCvPlot@@0@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXPAPAVCvPlot@@0@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEXI@Z ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
_pRet$249445 = 8					; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEXI@Z PROC ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebx
	push	ebp
	mov	ebx, ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR [ebx+8]
	push	esi
	push	edi
	mov	ebp, eax

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	test	eax, eax
	jne	SHORT $LN41@GrowSize@9
	mov	DWORD PTR [ebx+8], 1
$LN41@GrowSize@9:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+12]
	cmp	edx, DWORD PTR [ebx+8]
	jb	SHORT $LN9@GrowSize@9
	npad	1
$LL10@GrowSize@9:

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [ebx+8]
	lea	ecx, DWORD PTR [eax+eax]

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN37@GrowSize@9

; 433  : 				break;
; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [ebx+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL10@GrowSize@9

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN9@GrowSize@9
$LN37@GrowSize@9:

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [ebx+8], edx
$LN9@GrowSize@9:

; 438  : 		}
; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	esi, DWORD PTR [ebx+8]
	test	esi, esi
	jbe	SHORT $LN7@GrowSize@9
	push	85					; 00000055H
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	edi, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$249445[esp+12], edi
	mov	DWORD PTR [ebx+8], esi

; 441  : 		if (pTemp)

	test	edi, edi
	je	SHORT $LN7@GrowSize@9

; 442  : 		{
; 443  : 			if( bPODType ){
; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 445  : 			}else{
; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	ebp, ebp
	cmp	DWORD PTR [ebx+4], ebp
	jbe	SHORT $LN2@GrowSize@9
	xor	edx, edx
$LL42@GrowSize@9:

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	eax, eax
	je	SHORT $LN3@GrowSize@9
	mov	esi, DWORD PTR [ebx]
	add	esi, edx
	mov	ecx, 7
	mov	edi, eax
	rep movsd
	mov	edi, DWORD PTR _pRet$249445[esp+12]
$LN3@GrowSize@9:
	inc	ebp
	add	edx, 28					; 0000001cH
	add	eax, 28					; 0000001cH
	cmp	ebp, DWORD PTR [ebx+4]
	jb	SHORT $LL42@GrowSize@9
$LN2@GrowSize@9:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ebx]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
$LN7@GrowSize@9:
	pop	edi
	pop	esi

; 451  : 		}
; 452  : 		else
; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	DWORD PTR [ebx+8], ebp
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
?GrowSize@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@9
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@9:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAEXPAPAVCvTacticalMoveXMLEntry@@0@Z ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAEXPAPAVCvTacticalMoveXMLEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAEXPAPAVCvTacticalMoveXMLEntry@@0@Z PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAEXPAPAVCvTacticalMoveXMLEntry@@0@Z ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ; std::list<int,std::allocator<int> >::_Buynode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z PROC ; std::list<int,std::allocator<int> >::_Buynode, COMDAT
; _this$ = ecx

; 1191 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1192 : 		int _Linkcnt = 0;
; 1193 : 
; 1194 : 		_TRY_BEGIN
; 1195 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Next);

	test	eax, eax
	je	SHORT $LN27@Buynode@3
	mov	ecx, DWORD PTR __Next$[esp-4]
	mov	DWORD PTR [eax], ecx
$LN27@Buynode@3:

; 1196 : 		++_Linkcnt;
; 1197 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@3
	mov	edx, DWORD PTR __Prev$[esp-4]
	mov	DWORD PTR [ecx], edx
$LN37@Buynode@3:

; 1198 : 		++_Linkcnt;
; 1199 : 		this->_Alval.construct(&_Myval(_Pnode), _Val);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@3
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx
$LN47@Buynode@3:

; 1200 : 		_CATCH_ALL
; 1201 : 		if (1 < _Linkcnt)
; 1202 : 			this->_Alptr.destroy(&_Prevnode(_Pnode));
; 1203 : 		if (0 < _Linkcnt)
; 1204 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1205 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1206 : 		_RERAISE;
; 1207 : 		_CATCH_END
; 1208 : 		return (_Pnode);
; 1209 : 		}

	ret	12					; 0000000cH
?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ENDP ; std::list<int,std::allocator<int> >::_Buynode
_TEXT	ENDS
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::list<int,std::allocator<int> >::_Incsize
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T249659 = -80						; size = 28
$T249658 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z PROC ; std::list<int,std::allocator<int> >::_Incsize, COMDAT
; _this$ = ecx

; 1239 : 		{	// alter element count, with checking

	mov	eax, DWORD PTR fs:0

; 1240 : 		if (max_size() - _Mysize < _Count)

	mov	edx, DWORD PTR __Count$[esp-4]
	push	-1
	push	__ehhandler$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	sub	esp, 68					; 00000044H
	push	esi
	mov	esi, 1073741823				; 3fffffffH
	sub	esi, eax
	cmp	esi, edx
	pop	esi
	jae	SHORT $LN1@Incsize

; 1241 : 			_THROW(length_error, "list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T249659[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T249658[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T249659[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T249658[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T249658[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T249658[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T249658[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN20@Incsize:
$LN1@Incsize:

; 1242 : 		_Mysize += _Count;

	add	eax, edx
	mov	DWORD PTR [ecx+8], eax

; 1243 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	4
$LN19@Incsize:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z$0:
	lea	ecx, DWORD PTR $T249659[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z$2:
	lea	ecx, DWORD PTR $T249658[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ENDP ; std::list<int,std::allocator<int> >::_Incsize
PUBLIC	??0?$_List_ptr@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_List_ptr<int,std::allocator<int> >::_List_ptr<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_ptr@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_ptr@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_List_ptr<int,std::allocator<int> >::_List_ptr<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 67   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 68   : 		}

	ret	4
??0?$_List_ptr@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_List_ptr<int,std::allocator<int> >::_List_ptr<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Incsize
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T249734 = -80						; size = 28
$T249733 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Incsize, COMDAT
; _this$ = ecx

; 1239 : 		{	// alter element count, with checking

	mov	eax, DWORD PTR fs:0

; 1240 : 		if (max_size() - _Mysize < _Count)

	mov	edx, DWORD PTR __Count$[esp-4]
	push	-1
	push	__ehhandler$?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	sub	esp, 68					; 00000044H
	push	esi
	mov	esi, 107374182				; 06666666H
	sub	esi, eax
	cmp	esi, edx
	pop	esi
	jae	SHORT $LN1@Incsize@2

; 1241 : 			_THROW(length_error, "list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T249734[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T249733[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T249734[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T249733[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T249733[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T249733[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T249733[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN20@Incsize@2:
$LN1@Incsize@2:

; 1242 : 		_Mysize += _Count;

	add	eax, edx
	mov	DWORD PTR [ecx+8], eax

; 1243 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	4
$LN19@Incsize@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z$0:
	lea	ecx, DWORD PTR $T249734[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z$2:
	lea	ecx, DWORD PTR $T249733[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Incsize
PUBLIC	??0?$_List_ptr@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@V?$allocator@VCvQueuedAttack@@@1@@Z ; std::_List_ptr<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_List_ptr<CvQueuedAttack,std::allocator<CvQueuedAttack> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_ptr@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@V?$allocator@VCvQueuedAttack@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_ptr@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@V?$allocator@VCvQueuedAttack@@@1@@Z PROC ; std::_List_ptr<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_List_ptr<CvQueuedAttack,std::allocator<CvQueuedAttack> >, COMDAT
; _this$ = ecx

; 67   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 68   : 		}

	ret	4
??0?$_List_ptr@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAE@V?$allocator@VCvQueuedAttack@@@1@@Z ENDP ; std::_List_ptr<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_List_ptr<CvQueuedAttack,std::allocator<CvQueuedAttack> >
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebx
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	mov	ebx, 1
	jne	SHORT $LN33@GrowSize@10
	mov	DWORD PTR [esi+8], ebx
$LN33@GrowSize@10:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+8]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@10
	npad	4
$LL8@GrowSize@10:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@10

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@10

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@10
$LN34@GrowSize@10:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@10:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, ebx
	jbe	SHORT $LN16@GrowSize@10
	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@10
$LN16@GrowSize@10:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], ebx
$LN15@GrowSize@10:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@10
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@10:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+20], bl
	pop	esi
	pop	ebx

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit, COMDAT
; _this$ = ecx

; 776  : 	{

	push	esi
	push	edi

; 777  : 		if( uiFit <= m_uiCurrMaxSize )

	mov	edi, DWORD PTR _uiFit$[esp+4]
	mov	esi, ecx
	cmp	edi, DWORD PTR [esi+8]
	jbe	SHORT $LN7@GrowSizeTo
	push	ebp

; 778  : 			return;
; 779  : 
; 780  : 		m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edi

; 781  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	cmp	edi, 1
	jbe	SHORT $LN13@GrowSizeTo
	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebp, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN12@GrowSizeTo
$LN13@GrowSizeTo:
	lea	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 1
$LN12@GrowSizeTo:

; 782  : 		if( bPODType ){
; 783  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	ebp
	call	_memcpy

; 784  : 		}else{
; 785  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 786  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 787  : 		}
; 788  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN20@GrowSizeTo
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN20@GrowSizeTo:

; 789  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], ebp

; 790  : 
; 791  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+20], 1
	pop	ebp
$LN7@GrowSizeTo:
	pop	edi
	pop	esi

; 792  : 	};

	ret	4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >::operator+
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvQueuedAttack@@@std@@QAEXPAVCvQueuedAttack@@ABV3@@Z ; std::allocator<CvQueuedAttack>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@VCvQueuedAttack@@@std@@QAEXPAVCvQueuedAttack@@ABV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvQueuedAttack@@@std@@QAEXPAVCvQueuedAttack@@ABV3@@Z PROC ; std::allocator<CvQueuedAttack>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@6
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [edx]
	push	esi
	mov	DWORD PTR [eax], ecx
	push	edi
	lea	esi, DWORD PTR [edx+4]
	lea	edi, DWORD PTR [eax+4]
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR [eax+32], ecx
	mov	cl, BYTE PTR [edx+36]
	mov	BYTE PTR [eax+36], cl
	mov	dl, BYTE PTR [edx+37]
	pop	edi
	mov	BYTE PTR [eax+37], dl
	pop	esi
$LN5@construct@6:

; 156  : 		}

	ret	8
?construct@?$allocator@VCvQueuedAttack@@@std@@QAEXPAVCvQueuedAttack@@ABV3@@Z ENDP ; std::allocator<CvQueuedAttack>::construct
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvTacticalUnit@@PAV1@@stdext@@YAPAVCvTacticalUnit@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvTacticalUnit *,CvTacticalUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAVCvTacticalUnit@@PAV1@@stdext@@YAPAVCvTacticalUnit@@PAV1@00@Z
_TEXT	SEGMENT
$T249977 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$249981 = 16					; size = 1
$T249960 = 16						; size = 1
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvTacticalUnit@@PAV1@@stdext@@YAPAVCvTacticalUnit@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvTacticalUnit *,CvTacticalUnit *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$249981[esp]
	mov	edx, DWORD PTR $T249960[esp]
	mov	BYTE PTR $T249977[esp+4], 0
	mov	eax, DWORD PTR $T249977[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAVCvTacticalUnit@@PAV1@@stdext@@YAPAVCvTacticalUnit@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvTacticalUnit *,CvTacticalUnit *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvTacticalCity@@PAV1@@stdext@@YAPAVCvTacticalCity@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvTacticalCity *,CvTacticalCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAVCvTacticalCity@@PAV1@@stdext@@YAPAVCvTacticalCity@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvTacticalCity@@PAV1@@stdext@@YAPAVCvTacticalCity@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvTacticalCity *,CvTacticalCity *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAVCvTacticalCity@@PAV1@@stdext@@YAPAVCvTacticalCity@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvTacticalCity *,CvTacticalCity *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>
_TEXT	ENDS
PUBLIC	?resize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEXI@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::resize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?resize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEXI@Z PROC ; FStaticVector<CvTemporaryZone,10,1,297,0>::resize, COMDAT
; _this$ = ecx

; 666  : 	{

	push	esi
	push	edi

; 667  : 		if( m_uiCurrMaxSize < uiNewSize ){

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN4@resize

; 668  : 			GrowSize(uiNewSize);

	push	edi
	call	?GrowSize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::GrowSize
$LN4@resize:

; 669  : 		}
; 670  : 		m_uiCurrSize = uiNewSize;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 671  : 	};

	ret	4
?resize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEXI@Z ENDP ; FStaticVector<CvTemporaryZone,10,1,297,0>::resize
_TEXT	ENDS
PUBLIC	??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z ; std::_Find<std::list<int,std::allocator<int> >::_Iterator<0>,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z PROC ; std::_Find<std::list<int,std::allocator<int> >::_Iterator<0>,int>, COMDAT

; 38   : 	_DEBUG_RANGE(_First, _Last);
; 39   : 	for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN27@Find
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL9@Find:

; 40   : 		if (*_First == _Val)

	cmp	DWORD PTR [ecx+8], edx
	je	SHORT $LN27@Find
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR __First$[esp-4], ecx
	cmp	ecx, eax
	jne	SHORT $LL9@Find
$LN27@Find:

; 41   : 			break;
; 42   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	}

	ret	0
??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z ENDP ; std::_Find<std::list<int,std::allocator<int> >::_Iterator<0>,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvTacticalUnit@@IV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@IABV1@AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvTacticalUnit *,unsigned int,CvTacticalUnit,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAVCvTacticalUnit@@IV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@IABV1@AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvTacticalUnit@@IV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@IABV1@AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvTacticalUnit *,unsigned int,CvTacticalUnit,std::allocator<CvTacticalUnit> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	edx, DWORD PTR __Count$[esp-4]
	test	edx, edx
	jbe	SHORT $LN4@Uninit_fil
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
$LN5@Uninit_fil:
	dec	edx
	add	eax, 24					; 00000018H
	test	edx, edx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAVCvTacticalUnit@@IV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@IABV1@AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvTacticalUnit *,unsigned int,CvTacticalUnit,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvTacticalCity@@IV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@IABV1@AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvTacticalCity *,unsigned int,CvTacticalCity,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAVCvTacticalCity@@IV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@IABV1@AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvTacticalCity@@IV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@IABV1@AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvTacticalCity *,unsigned int,CvTacticalCity,std::allocator<CvTacticalCity> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@2:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@2
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_fil@2:
	dec	ecx
	add	eax, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@2
	pop	esi
$LN4@Uninit_fil@2:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAVCvTacticalCity@@IV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@IABV1@AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvTacticalCity *,unsigned int,CvTacticalCity,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@0AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@0AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@0AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTacticalUnit> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@0AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@0AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@0AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@0AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTacticalCity> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@0AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??$_Distance@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0AAH@Z ; std::_Distance<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0AAH@Z PROC ; std::_Distance<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0AAH@Z ENDP ; std::_Distance<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
_TEXT	ENDS
PUBLIC	??$_Distance@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0AAH@Z ; std::_Distance<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0AAH@Z PROC ; std::_Distance<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0AAH@Z ENDP ; std::_Distance<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z PROC ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@13
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@13:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@13
	pop	esi
$LN7@unchecked_@13:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z ENDP ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalMove>::_Maxlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$230617 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvTacticalMove>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$230617[esp+16]
	push	eax
	call	??$get_temporary_buffer@VCvTacticalMove@@@std@@YA?AU?$pair@PAVCvTacticalMove@@H@0@H@Z ; std::get_temporary_buffer<CvTacticalMove>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$230617[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$230617[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvTacticalMove>::_Maxlen
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalTarget>::_Maxlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$230666 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvTacticalTarget>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen@2
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen@2

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$230666[esp+16]
	push	eax
	call	??$get_temporary_buffer@VCvTacticalTarget@@@std@@YA?AU?$pair@PAVCvTacticalTarget@@H@0@H@Z ; std::get_temporary_buffer<CvTacticalTarget>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$230666[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$230666[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen@2:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen@2:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvTacticalTarget>::_Maxlen
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalUnit>::_Maxlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$230715 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvTacticalUnit>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen@3
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen@3

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$230715[esp+16]
	push	eax
	call	??$get_temporary_buffer@VCvTacticalUnit@@@std@@YA?AU?$pair@PAVCvTacticalUnit@@H@0@H@Z ; std::get_temporary_buffer<CvTacticalUnit>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$230715[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$230715[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen@3:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen@3:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvTacticalUnit>::_Maxlen
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalCity>::_Maxlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$230764 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvTacticalCity>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen@4
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen@4

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$230764[esp+16]
	push	eax
	call	??$get_temporary_buffer@VCvTacticalCity@@@std@@YA?AU?$pair@PAVCvTacticalCity@@H@0@H@Z ; std::get_temporary_buffer<CvTacticalCity>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$230764[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$230764[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen@4:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen@4:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvTacticalCity>::_Maxlen
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvBlockingUnit>::_Maxlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$230813 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvBlockingUnit>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen@5
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen@5

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$230813[esp+16]
	push	eax
	call	??$get_temporary_buffer@VCvBlockingUnit@@@std@@YA?AU?$pair@PAVCvBlockingUnit@@H@0@H@Z ; std::get_temporary_buffer<CvBlockingUnit>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$230813[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$230813[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen@5:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen@5:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvBlockingUnit>::_Maxlen
_TEXT	ENDS
PUBLIC	??$advance@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@H@Z ; std::advance<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$advance@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@H@Z PROC ; std::advance<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@H@Z ENDP ; std::advance<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
_TEXT	ENDS
PUBLIC	??$advance@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@H@Z ; std::advance<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@H@Z PROC ; std::advance<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@H@Z ENDP ; std::advance<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Median<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	npad	3
$LL2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_
	push	ebx
	push	esi
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_
	npad	7
$LL22@Insertion_:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_
$LN21@Insertion_:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_
	pop	esi
	pop	ebx
$LN6@Insertion_:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@stdext@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@stdext@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@std@@@Z
_TEXT	SEGMENT
$T250483 = -4						; size = 1
__Cat$250487 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@stdext@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T250483[esp+4], 0
	mov	eax, DWORD PTR $T250483[esp+4]
	mov	ecx, DWORD PTR __Cat$250487[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@stdext@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@stdext@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@stdext@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@std@@@Z
_TEXT	SEGMENT
$T250492 = -4						; size = 1
__Cat$250496 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@stdext@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T250492[esp+4], 0
	mov	eax, DWORD PTR $T250492[esp+4]
	mov	ecx, DWORD PTR __Cat$250496[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@stdext@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAVCvTacticalMove@@V1@@std@@YAXPAVCvTacticalMove@@00@Z ; std::_Insertion_sort1<CvTacticalMove *,CvTacticalMove>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@PAVCvTacticalMove@@V1@@std@@YAXPAVCvTacticalMove@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvTacticalMove@@V1@@std@@YAXPAVCvTacticalMove@@00@Z PROC ; std::_Insertion_sort1<CvTacticalMove *,CvTacticalMove>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_@2

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_@2
	push	ebx
	push	esi
$LL7@Insertion_@2:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_@2

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN19@Insertion_@2
	npad	7
$LL20@Insertion_@2:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL20@Insertion_@2
$LN19@Insertion_@2:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@2
$LN5@Insertion_@2:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_@2
$LL3@Insertion_@2:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_@2

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_@2:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_@2:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_@2
	pop	esi
	pop	ebx
$LN6@Insertion_@2:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAVCvTacticalMove@@V1@@std@@YAXPAVCvTacticalMove@@00@Z ENDP ; std::_Insertion_sort1<CvTacticalMove *,CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@PAVCvTacticalMove@@PAV1@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@0000@Z ; stdext::_Unchecked_merge_backward<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@PAVCvTacticalMove@@PAV1@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@0000@Z
_TEXT	SEGMENT
$T250554 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$_Unchecked_merge_backward@PAVCvTacticalMove@@PAV1@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@0000@Z PROC ; stdext::_Unchecked_merge_backward<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>, COMDAT

; 5202 : 	{

	push	ecx

; 5203 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR __Last2$[esp]
	mov	BYTE PTR $T250554[esp+4], 0
	mov	eax, DWORD PTR $T250554[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Merge_backward@PAVCvTacticalMove@@PAV1@PAV1@@std@@YAPAVCvTacticalMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>

; 5204 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_merge_backward@PAVCvTacticalMove@@PAV1@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@0000@Z ENDP ; stdext::_Unchecked_merge_backward<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$lower_bound@PAVCvTacticalMove@@V1@@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@@Z ; std::lower_bound<CvTacticalMove *,CvTacticalMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@PAVCvTacticalMove@@V1@@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$lower_bound@PAVCvTacticalMove@@V1@@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@@Z PROC ; std::lower_bound<CvTacticalMove *,CvTacticalMove>, COMDAT

; 2276 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Lower_bound@PAVCvTacticalMove@@V1@H@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvTacticalMove *,CvTacticalMove,int>
	add	esp, 16					; 00000010H

; 2277 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2278 : 	return _First;
; 2279 : 	}

	ret	0
??$lower_bound@PAVCvTacticalMove@@V1@@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@@Z ENDP ; std::lower_bound<CvTacticalMove *,CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$upper_bound@PAVCvTacticalMove@@V1@@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@@Z ; std::upper_bound<CvTacticalMove *,CvTacticalMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@PAVCvTacticalMove@@V1@@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$upper_bound@PAVCvTacticalMove@@V1@@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@@Z PROC ; std::upper_bound<CvTacticalMove *,CvTacticalMove>, COMDAT

; 2347 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Upper_bound@PAVCvTacticalMove@@V1@H@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvTacticalMove *,CvTacticalMove,int>
	add	esp, 16					; 00000010H

; 2348 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2349 : 	return _First;
; 2350 : 	}

	ret	0
??$upper_bound@PAVCvTacticalMove@@V1@@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@@Z ENDP ; std::upper_bound<CvTacticalMove *,CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAVCvTacticalTarget@@V1@@std@@YAXPAVCvTacticalTarget@@00@Z ; std::_Insertion_sort1<CvTacticalTarget *,CvTacticalTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAVCvTacticalTarget@@V1@@std@@YAXPAVCvTacticalTarget@@00@Z
_TEXT	SEGMENT
__Val$232372 = -28					; size = 28
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvTacticalTarget@@V1@@std@@YAXPAVCvTacticalTarget@@00@Z PROC ; std::_Insertion_sort1<CvTacticalTarget *,CvTacticalTarget>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	esp, 28					; 0000001cH
	cmp	eax, ecx
	je	$LN6@Insertion_@3
	push	ebx

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	ebx, DWORD PTR [eax+28]
	cmp	ebx, ecx
	je	$LN31@Insertion_@3
	push	ebp
	push	esi
	push	edi
	jmp	SHORT $LN7@Insertion_@3
$LL30@Insertion_@3:
	mov	eax, DWORD PTR __First$[esp+40]
$LN7@Insertion_@3:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	ecx, 7
	mov	esi, ebx
	lea	edi, DWORD PTR __Val$232372[esp+44]
	rep movsd

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	ebp, DWORD PTR __Val$232372[esp+64]
	cmp	ebp, DWORD PTR [eax+20]
	mov	edx, ebx
	jle	SHORT $LN5@Insertion_@3

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	edx, DWORD PTR __First$[esp+40]
	mov	eax, ebx
	cmp	edx, ebx
	je	SHORT $LN1@Insertion_@3
	npad	6
$LL20@Insertion_@3:
	sub	eax, 28					; 0000001cH
	lea	edi, DWORD PTR [eax+28]
	mov	ecx, 7
	mov	esi, eax
	rep movsd
	cmp	eax, edx
	jne	SHORT $LL20@Insertion_@3

; 2977 : 				*_First = _Val;
; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN1@Insertion_@3
$LN5@Insertion_@3:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	ebp, DWORD PTR [ebx-8]
	lea	eax, DWORD PTR [ebx-28]
	jle	SHORT $LN1@Insertion_@3
	npad	3
$LL3@Insertion_@3:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	edi, edx
	mov	esi, eax
	mov	ecx, 7
	mov	edx, eax
	sub	eax, 28					; 0000001cH
	rep movsd
	cmp	ebp, DWORD PTR [eax+20]
	jg	SHORT $LL3@Insertion_@3
$LN1@Insertion_@3:

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	add	ebx, 28					; 0000001cH

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, 7
	mov	edi, edx
	lea	esi, DWORD PTR __Val$232372[esp+44]
	rep movsd
	cmp	ebx, DWORD PTR __Last$[esp+40]
	jne	SHORT $LL30@Insertion_@3
	pop	edi
	pop	esi
	pop	ebp
$LN31@Insertion_@3:
	pop	ebx
$LN6@Insertion_@3:

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Insertion_sort1@PAVCvTacticalTarget@@V1@@std@@YAXPAVCvTacticalTarget@@00@Z ENDP ; std::_Insertion_sort1<CvTacticalTarget *,CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@PAVCvTacticalTarget@@PAV1@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@0000@Z ; stdext::_Unchecked_merge_backward<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@PAVCvTacticalTarget@@PAV1@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@0000@Z
_TEXT	SEGMENT
$T250626 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$_Unchecked_merge_backward@PAVCvTacticalTarget@@PAV1@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@0000@Z PROC ; stdext::_Unchecked_merge_backward<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>, COMDAT

; 5202 : 	{

	push	ecx

; 5203 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR __Last2$[esp]
	mov	BYTE PTR $T250626[esp+4], 0
	mov	eax, DWORD PTR $T250626[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Merge_backward@PAVCvTacticalTarget@@PAV1@PAV1@@std@@YAPAVCvTacticalTarget@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>

; 5204 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_merge_backward@PAVCvTacticalTarget@@PAV1@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@0000@Z ENDP ; stdext::_Unchecked_merge_backward<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$lower_bound@PAVCvTacticalTarget@@V1@@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@@Z ; std::lower_bound<CvTacticalTarget *,CvTacticalTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@PAVCvTacticalTarget@@V1@@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$lower_bound@PAVCvTacticalTarget@@V1@@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@@Z PROC ; std::lower_bound<CvTacticalTarget *,CvTacticalTarget>, COMDAT

; 2276 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Lower_bound@PAVCvTacticalTarget@@V1@H@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvTacticalTarget *,CvTacticalTarget,int>
	add	esp, 16					; 00000010H

; 2277 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2278 : 	return _First;
; 2279 : 	}

	ret	0
??$lower_bound@PAVCvTacticalTarget@@V1@@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@@Z ENDP ; std::lower_bound<CvTacticalTarget *,CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??$upper_bound@PAVCvTacticalTarget@@V1@@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@@Z ; std::upper_bound<CvTacticalTarget *,CvTacticalTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@PAVCvTacticalTarget@@V1@@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$upper_bound@PAVCvTacticalTarget@@V1@@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@@Z PROC ; std::upper_bound<CvTacticalTarget *,CvTacticalTarget>, COMDAT

; 2347 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Upper_bound@PAVCvTacticalTarget@@V1@H@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvTacticalTarget *,CvTacticalTarget,int>
	add	esp, 16					; 00000010H

; 2348 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2349 : 	return _First;
; 2350 : 	}

	ret	0
??$upper_bound@PAVCvTacticalTarget@@V1@@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@@Z ENDP ; std::upper_bound<CvTacticalTarget *,CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0V12@@Z
_TEXT	SEGMENT
$T250642 = -4						; size = 1
$T250649 = -4						; size = 4
$T250645 = -4						; size = 4
__Cat$250654 = 8					; size = 1
$T250644 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0V12@@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T250649[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$250654[esp+4]
	mov	edx, DWORD PTR $T250644[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T250642[esp+12], bl
	mov	eax, DWORD PTR $T250642[esp+12]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+40]
	mov	eax, DWORD PTR __First$[esp+40]
	mov	DWORD PTR $T250645[esp+44], esp
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@0@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@14
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@14:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0V12@@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0V12@@Z
_TEXT	SEGMENT
$T250693 = -4						; size = 1
$T250700 = -4						; size = 4
$T250696 = -4						; size = 4
__Cat$250704 = 8					; size = 1
$T250695 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0V12@@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T250700[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$250704[esp+4]
	mov	edx, DWORD PTR $T250695[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T250693[esp+12], bl
	mov	eax, DWORD PTR $T250693[esp+12]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+40]
	mov	eax, DWORD PTR __First$[esp+40]
	mov	DWORD PTR $T250696[esp+44], esp
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@0@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@15
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@15:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0V12@@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAVCvBlockingUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),CvBlockingUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@PAVCvBlockingUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z0@Z
_TEXT	SEGMENT
__Val$233338 = -16					; size = 16
tv242 = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAVCvBlockingUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z0@Z PROC ; std::_Insertion_sort1<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),CvBlockingUnit>, COMDAT

; 3124 : 	if (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __First$[esp+20]
	push	esi
	push	edi
	cmp	ebp, eax
	je	$LN6@Insertion_@4

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	ebx, DWORD PTR [ebp+16]
	cmp	ebx, eax
	je	$LN6@Insertion_@4
	lea	eax, DWORD PTR [ebx-16]
	mov	DWORD PTR tv242[esp+28], eax
	npad	7
$LL7@Insertion_@4:

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;
; 3128 : 			_Ty _Val = *_Next;

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx]
	mov	DWORD PTR __Val$233338[esp+36], ecx

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR __Val$233338[esp+40], edx
	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR __Val$233338[esp+44], eax
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ebp+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ebx+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+8], ecx
	mov	edi, ebx
	mov	DWORD PTR __Val$233338[esp+64], esi
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[esp+60]
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN5@Insertion_@4

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, ebx
	cmp	ebp, ebx
	je	SHORT $LN17@Insertion_@4
$LL18@Insertion_@4:
	mov	ecx, DWORD PTR [eax-16]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+28], edx
	cmp	eax, ebp
	jne	SHORT $LL18@Insertion_@4
$LN17@Insertion_@4:

; 3133 : 				*_First = _Val;

	mov	eax, DWORD PTR __Val$233338[esp+36]
	mov	ecx, DWORD PTR __Val$233338[esp+40]
	mov	edx, DWORD PTR __Val$233338[esp+44]
	mov	DWORD PTR [ebp], esi
	mov	DWORD PTR [ebp+4], eax
	mov	DWORD PTR [ebp+8], ecx
	mov	DWORD PTR [ebp+12], edx

; 3134 : 				}
; 3135 : 			else

	jmp	$LN4@Insertion_@4
$LN5@Insertion_@4:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;
; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	mov	esi, DWORD PTR tv242[esp+28]
	mov	ecx, esi
	mov	edx, DWORD PTR [ecx]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR __Val$233338[esp+48]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR __Val$233338[esp+52]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Val$233338[esp+72]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR __Val$233338[esp+76]
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], ecx
	call	DWORD PTR __Pred$[esp+60]
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN1@Insertion_@4
	npad	3
$LL3@Insertion_@4:

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edi], edx
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], edx
	mov	ecx, DWORD PTR [esi-16]
	mov	edx, DWORD PTR [esi-12]
	mov	edi, esi
	sub	esi, 16					; 00000010H
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$233338[esp+48]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR __Val$233338[esp+52]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Val$233338[esp+72]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$233338[esp+76]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[esp+60]
	add	esp, 32					; 00000020H
	test	al, al
	jne	SHORT $LL3@Insertion_@4
$LN1@Insertion_@4:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	eax, DWORD PTR __Val$233338[esp+32]
	mov	ecx, DWORD PTR __Val$233338[esp+36]
	mov	edx, DWORD PTR __Val$233338[esp+40]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR __Val$233338[esp+44]
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi+8], edx
	mov	DWORD PTR [edi+12], eax
$LN4@Insertion_@4:
	add	DWORD PTR tv242[esp+28], 16		; 00000010H
	add	ebx, 16					; 00000010H
	cmp	ebx, DWORD PTR __Last$[esp+28]
	jne	$LL7@Insertion_@4
$LN6@Insertion_@4:

; 3142 : 				}
; 3143 : 			}
; 3144 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
??$_Insertion_sort1@PAVCvBlockingUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z0@Z ENDP ; std::_Insertion_sort1<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@Z@Z ; stdext::_Unchecked_merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@Z@Z
_TEXT	SEGMENT
$T250791 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 4
??$_Unchecked_merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@Z@Z PROC ; stdext::_Unchecked_merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 5227 : 	{

	push	ecx

; 5228 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	BYTE PTR $T250791[esp+4], 0
	mov	eax, DWORD PTR $T250791[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>

; 5229 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unchecked_merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@Z@Z ENDP ; stdext::_Unchecked_merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$lower_bound@PAVCvBlockingUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z ; std::lower_bound<CvBlockingUnit *,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@PAVCvBlockingUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$lower_bound@PAVCvBlockingUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z PROC ; std::lower_bound<CvBlockingUnit *,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 2314 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	push	edx
	push	eax
	call	??$_Lower_bound@PAVCvBlockingUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Lower_bound<CvBlockingUnit *,CvBlockingUnit,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
	add	esp, 20					; 00000014H

; 2315 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2316 : 	return _First;
; 2317 : 	}

	ret	0
??$lower_bound@PAVCvBlockingUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z ENDP ; std::lower_bound<CvBlockingUnit *,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$upper_bound@PAVCvBlockingUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z ; std::upper_bound<CvBlockingUnit *,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@PAVCvBlockingUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$upper_bound@PAVCvBlockingUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z PROC ; std::upper_bound<CvBlockingUnit *,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 2385 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	push	edx
	push	eax
	call	??$_Upper_bound@PAVCvBlockingUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Upper_bound<CvBlockingUnit *,CvBlockingUnit,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
	add	esp, 20					; 00000014H

; 2386 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2387 : 	return _First;
; 2388 : 	}

	ret	0
??$upper_bound@PAVCvBlockingUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z ENDP ; std::upper_bound<CvBlockingUnit *,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAVCvBlockingUnit@@V1@@std@@YAXPAVCvBlockingUnit@@00@Z ; std::_Insertion_sort1<CvBlockingUnit *,CvBlockingUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAVCvBlockingUnit@@V1@@std@@YAXPAVCvBlockingUnit@@00@Z
_TEXT	SEGMENT
__Val$233618 = -16					; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvBlockingUnit@@V1@@std@@YAXPAVCvBlockingUnit@@00@Z PROC ; std::_Insertion_sort1<CvBlockingUnit *,CvBlockingUnit>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 16					; 00000010H
	push	edi
	mov	edi, DWORD PTR __First$[esp+16]
	cmp	edi, eax
	je	$LN6@Insertion_@5

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+16]
	cmp	edx, eax
	je	$LN6@Insertion_@5
	push	ebx
	push	ebp
	push	esi
$LL7@Insertion_@5:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebp, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [edx+12]
	mov	ebx, DWORD PTR [edx]
	mov	eax, edx
	mov	DWORD PTR __Val$233618[esp+40], ebp
	mov	DWORD PTR __Val$233618[esp+44], ecx
	jge	SHORT $LN5@Insertion_@5

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	cmp	edi, edx
	je	SHORT $LN19@Insertion_@5
$LL20@Insertion_@5:
	mov	ecx, DWORD PTR [eax-16]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+20], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+24], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+28], ecx
	cmp	eax, edi
	jne	SHORT $LL20@Insertion_@5
$LN19@Insertion_@5:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __Val$233618[esp+44]
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi
	mov	DWORD PTR [edi+8], ebp
	mov	DWORD PTR [edi+12], eax

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@5
$LN5@Insertion_@5:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-12]
	lea	ecx, DWORD PTR [edx-16]
	jge	SHORT $LN1@Insertion_@5
$LL3@Insertion_@5:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	eax, ecx
	sub	ecx, 16					; 00000010H
	cmp	esi, DWORD PTR [ecx+4]
	jl	SHORT $LL3@Insertion_@5

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Val$233618[esp+40]
$LN1@Insertion_@5:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, DWORD PTR __Val$233618[esp+44]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN4@Insertion_@5:
	add	edx, 16					; 00000010H
	cmp	edx, DWORD PTR __Last$[esp+28]
	jne	$LL7@Insertion_@5
	pop	esi
	pop	ebp
	pop	ebx
$LN6@Insertion_@5:
	pop	edi

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Insertion_sort1@PAVCvBlockingUnit@@V1@@std@@YAXPAVCvBlockingUnit@@00@Z ENDP ; std::_Insertion_sort1<CvBlockingUnit *,CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvBlockingUnit@@PAV1@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@0000@Z ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvBlockingUnit@@PAV1@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@0000@Z
_TEXT	SEGMENT
$T250860 = -4						; size = 1
$T250861 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$unchecked_merge@PAVCvBlockingUnit@@PAV1@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@0000@Z PROC ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Dest$[esp]
	mov	BYTE PTR $T250860[esp+4], 0
	mov	eax, DWORD PTR $T250860[esp+4]
	mov	ecx, DWORD PTR $T250861[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>

; 5117 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$unchecked_merge@PAVCvBlockingUnit@@PAV1@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@0000@Z ENDP ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@0000@Z ; stdext::_Unchecked_merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@0000@Z
_TEXT	SEGMENT
$T250869 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$_Unchecked_merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@0000@Z PROC ; stdext::_Unchecked_merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>, COMDAT

; 5202 : 	{

	push	ecx

; 5203 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR __Last2$[esp]
	mov	BYTE PTR $T250869[esp+4], 0
	mov	eax, DWORD PTR $T250869[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@@std@@YAPAVCvBlockingUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>

; 5204 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@0000@Z ENDP ; stdext::_Unchecked_merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$lower_bound@PAVCvBlockingUnit@@V1@@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@@Z ; std::lower_bound<CvBlockingUnit *,CvBlockingUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@PAVCvBlockingUnit@@V1@@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$lower_bound@PAVCvBlockingUnit@@V1@@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@@Z PROC ; std::lower_bound<CvBlockingUnit *,CvBlockingUnit>, COMDAT

; 2276 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Lower_bound@PAVCvBlockingUnit@@V1@H@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvBlockingUnit *,CvBlockingUnit,int>
	add	esp, 16					; 00000010H

; 2277 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2278 : 	return _First;
; 2279 : 	}

	ret	0
??$lower_bound@PAVCvBlockingUnit@@V1@@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@@Z ENDP ; std::lower_bound<CvBlockingUnit *,CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??$upper_bound@PAVCvBlockingUnit@@V1@@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@@Z ; std::upper_bound<CvBlockingUnit *,CvBlockingUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@PAVCvBlockingUnit@@V1@@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$upper_bound@PAVCvBlockingUnit@@V1@@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@@Z PROC ; std::upper_bound<CvBlockingUnit *,CvBlockingUnit>, COMDAT

; 2347 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Upper_bound@PAVCvBlockingUnit@@V1@H@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvBlockingUnit *,CvBlockingUnit,int>
	add	esp, 16					; 00000010H

; 2348 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2349 : 	return _First;
; 2350 : 	}

	ret	0
??$upper_bound@PAVCvBlockingUnit@@V1@@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@@Z ENDP ; std::upper_bound<CvBlockingUnit *,CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@0@PAVCvTacticalMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@0@PAVCvTacticalMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T250887 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@0@PAVCvTacticalMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+12]
	xor	ebx, ebx
	mov	DWORD PTR $T250887[esp+16], ebx
	cmp	ecx, edi
	je	SHORT $LN1@Copy_opt@14
	lea	esi, DWORD PTR [ebx+8]
	npad	7
$LL3@Copy_opt@14:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __Dest$[esp+28]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN14@Copy_opt@14
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR __Dest$[esp+28]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN2@Copy_opt@14
$LN14@Copy_opt@14:
	cmp	eax, ebx
	je	SHORT $LN19@Copy_opt@14
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Dest$[esp+28]
$LN19@Copy_opt@14:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Copy_opt@14:
	add	ecx, esi
	cmp	ecx, edi
	jne	SHORT $LL3@Copy_opt@14
$LN1@Copy_opt@14:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	cmp	eax, ebx
	je	SHORT $LN41@Copy_opt@14
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Copy_opt@14:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@0@PAVCvTacticalMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvTacticalMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvTacticalMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvTacticalMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+8]
	cmp	eax, esi
	je	SHORT $LN16@Merge@2
	npad	5
$LL5@Merge@2:
	cmp	ecx, edi
	je	SHORT $LN3@Merge@2

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	ebx, DWORD PTR [ecx+4]
	cmp	ebx, DWORD PTR [eax+4]
	jle	SHORT $LN2@Merge@2

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	add	ecx, 8

; 2516 : 		else

	jmp	SHORT $LN40@Merge@2
$LN2@Merge@2:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	add	eax, 8
$LN40@Merge@2:
	mov	DWORD PTR [edx+4], ebx
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL5@Merge@2
$LN3@Merge@2:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	eax, esi
	je	SHORT $LN16@Merge@2
$LL18@Merge@2:
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	add	eax, 8
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL18@Merge@2
$LN16@Merge@2:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	eax, edx
	cmp	ecx, edi
	je	SHORT $LN27@Merge@2
	npad	6
$LL29@Merge@2:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edi
	jne	SHORT $LL29@Merge@2
$LN27@Merge@2:
	pop	edi
	pop	esi
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAVCvTacticalMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$rotate@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@00@Z ; std::rotate<CvTacticalMove *>
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@00@Z PROC ; std::rotate<CvTacticalMove *>, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN6@rotate
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN6@rotate

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00PAH0@Z ; std::_Rotate<CvTacticalMove *,int,CvTacticalMove>
	add	esp, 20					; 00000014H
$LN6@rotate:

; 1721 : 	}

	ret	0
??$rotate@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@00@Z ENDP ; std::rotate<CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@0@PAVCvTacticalTarget@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@0@PAVCvTacticalTarget@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T251080 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@0@PAVCvTacticalTarget@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp]
	push	ebx
	mov	ebx, DWORD PTR __Last$[esp+4]
	push	ebp
	xor	ebp, ebp
	push	esi
	mov	DWORD PTR $T251080[esp+16], ebp
	cmp	eax, ebx
	je	SHORT $LN1@Copy_opt@15
	lea	edx, DWORD PTR [ebp+28]
	push	edi
	npad	6
$LL3@Copy_opt@15:

; 2472 : 		*_Dest = *_First;

	mov	ecx, DWORD PTR __Dest$[esp+32]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [ecx+8]
	jae	SHORT $LN14@Copy_opt@15
	mov	ecx, 7
	mov	esi, eax
	rep movsd
	mov	ecx, DWORD PTR __Dest$[esp+32]
	add	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN2@Copy_opt@15
$LN14@Copy_opt@15:
	cmp	edi, ebp
	je	SHORT $LN19@Copy_opt@15
	mov	ecx, 7
	mov	esi, eax
	rep movsd
	mov	ecx, DWORD PTR __Dest$[esp+32]
$LN19@Copy_opt@15:
	add	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Dest$[esp+32]
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], esi
$LN2@Copy_opt@15:
	add	eax, edx
	cmp	eax, ebx
	jne	SHORT $LL3@Copy_opt@15
	pop	edi
$LN1@Copy_opt@15:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], ebp
	mov	DWORD PTR [esi+8], ebp
	mov	DWORD PTR [esi+12], ebp
	cmp	eax, ebp
	je	SHORT $LN41@Copy_opt@15
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Copy_opt@15:
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@0@PAVCvTacticalTarget@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvTacticalTarget@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvTacticalTarget@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvTacticalTarget@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __First2$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Dest$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Last1$[esp+4]
	push	esi
	push	edi
	cmp	eax, ebp
	je	SHORT $LN16@Merge@3
$LL5@Merge@3:
	cmp	edx, DWORD PTR __Last2$[esp+12]
	je	SHORT $LN40@Merge@3

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+20]

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	edi, ebx
	mov	ecx, 7
	jle	SHORT $LN2@Merge@3
	mov	esi, edx
	add	edx, 28					; 0000001cH

; 2516 : 		else

	jmp	SHORT $LN41@Merge@3
$LN2@Merge@3:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	esi, eax
	add	eax, 28					; 0000001cH
$LN41@Merge@3:
	add	ebx, 28					; 0000001cH
	rep movsd
	cmp	eax, ebp
	jne	SHORT $LL5@Merge@3
$LN40@Merge@3:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	eax, ebp
	je	SHORT $LN16@Merge@3
$LL18@Merge@3:
	mov	esi, eax
	mov	edi, ebx
	add	eax, 28					; 0000001cH
	mov	ecx, 7
	add	ebx, 28					; 0000001cH
	rep movsd
	cmp	eax, ebp
	jne	SHORT $LL18@Merge@3
$LN16@Merge@3:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	eax, ebx
	cmp	edx, DWORD PTR __Last2$[esp+12]
	je	SHORT $LN27@Merge@3
$LL29@Merge@3:
	mov	esi, edx
	mov	edi, eax
	add	edx, 28					; 0000001cH
	mov	ecx, 7
	add	eax, 28					; 0000001cH
	rep movsd
	cmp	edx, DWORD PTR __Last2$[esp+12]
	jne	SHORT $LL29@Merge@3
$LN27@Merge@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAVCvTacticalTarget@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$rotate@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@00@Z ; std::rotate<CvTacticalTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@00@Z PROC ; std::rotate<CvTacticalTarget *>, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN6@rotate@2
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN6@rotate@2

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00PAH0@Z ; std::_Rotate<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 20					; 00000014H
$LN6@rotate@2:

; 1721 : 	}

	ret	0
??$rotate@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@00@Z ENDP ; std::rotate<CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T251272 = -4						; size = 1
__Cat$251277 = 8					; size = 1
$T251274 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$251277[esp]
	mov	edx, DWORD PTR $T251274[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T251272[esp+8], 0
	mov	eax, DWORD PTR $T251272[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Lower_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Lower_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Lower_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@PAH@Z PROC ; std::_Lower_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit,int>, COMDAT

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;
; 2255 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN42@Lower_boun@5
	mov	eax, DWORD PTR __Val$[esp]
	push	ebx
	push	edi
	mov	edi, DWORD PTR [eax+8]
	imul	edi, DWORD PTR [eax+4]
	npad	3
$LL4@Lower_boun@5:

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2260 : 		_FwdIt _Mid = _First;
; 2261 : 		std::advance(_Mid, _Count2);

	lea	edx, DWORD PTR [eax+eax*2]

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	mov	ebx, DWORD PTR [esi+edx*8+8]
	imul	ebx, DWORD PTR [esi+edx*8+4]
	cmp	ebx, edi
	lea	edx, DWORD PTR [esi+edx*8]
	jle	SHORT $LN2@Lower_boun@5

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	esi, DWORD PTR [edx+24]
	or	edx, -1
	sub	edx, eax
	mov	DWORD PTR __First$[esp+8], esi
	add	ecx, edx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun@5
$LN2@Lower_boun@5:

; 2267 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun@5:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun@5
	pop	edi
	pop	ebx
$LN42@Lower_boun@5:

; 2268 : 		}
; 2269 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2270 : 	}

	ret	0
??$_Lower_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@PAH@Z ENDP ; std::_Lower_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit,int>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Upper_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@PAH@Z PROC ; std::_Upper_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit,int>, COMDAT

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;
; 2327 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN42@Upper_boun@5
	mov	eax, DWORD PTR __Val$[esp]
	push	ebx
	push	edi
	mov	edi, DWORD PTR [eax+8]
	imul	edi, DWORD PTR [eax+4]
	npad	3
$LL4@Upper_boun@5:

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2331 : 		_FwdIt _Mid = _First;
; 2332 : 		std::advance(_Mid, _Count2);

	lea	edx, DWORD PTR [eax+eax*2]

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	mov	ebx, DWORD PTR [esi+edx*8+8]
	imul	ebx, DWORD PTR [esi+edx*8+4]
	cmp	edi, ebx
	lea	edx, DWORD PTR [esi+edx*8]
	jg	SHORT $LN2@Upper_boun@5

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	esi, DWORD PTR [edx+24]
	or	edx, -1
	sub	edx, eax
	mov	DWORD PTR __First$[esp+8], esi
	add	ecx, edx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun@5
$LN2@Upper_boun@5:

; 2338 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun@5:

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun@5
	pop	edi
	pop	ebx
$LN42@Upper_boun@5:

; 2339 : 		}
; 2340 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2341 : 	}

	ret	0
??$_Upper_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@PAH@Z ENDP ; std::_Upper_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T251492 = -4						; size = 1
__Cat$251497 = 8					; size = 1
$T251494 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$251497[esp]
	mov	edx, DWORD PTR $T251494[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T251492[esp+8], 0
	mov	eax, DWORD PTR $T251492[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@@Z ; stdext::unchecked_copy_backward<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@@Z
_TEXT	SEGMENT
$T251506 = -4						; size = 1
__Cat$251511 = 8					; size = 1
$T251508 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@@Z PROC ; stdext::unchecked_copy_backward<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$251511[esp]
	mov	edx, DWORD PTR $T251508[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T251506[esp+8], 0
	mov	eax, DWORD PTR $T251506[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@@Z ENDP ; stdext::unchecked_copy_backward<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@@Z ; stdext::unchecked_copy<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@@Z
_TEXT	SEGMENT
$T251520 = -4						; size = 1
__Cat$251525 = 8					; size = 1
$T251522 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@@Z PROC ; stdext::unchecked_copy<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$251525[esp]
	mov	edx, DWORD PTR $T251522[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T251520[esp+8], 0
	mov	eax, DWORD PTR $T251520[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@@Z ENDP ; stdext::unchecked_copy<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T251534 = -4						; size = 1
__Cat$251539 = 8					; size = 1
$T251536 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$251539[esp]
	mov	edx, DWORD PTR $T251536[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T251534[esp+8], 0
	mov	eax, DWORD PTR $T251534[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Lower_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Lower_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Lower_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@PAH@Z PROC ; std::_Lower_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity,int>, COMDAT

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;
; 2255 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN42@Lower_boun@6
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
$LL4@Lower_boun@6:

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2260 : 		_FwdIt _Mid = _First;
; 2261 : 		std::advance(_Mid, _Count2);

	lea	edx, DWORD PTR [eax+eax*2]

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	cmp	DWORD PTR [esi+edx*4+4], edi
	lea	edx, DWORD PTR [esi+edx*4]
	jle	SHORT $LN2@Lower_boun@6

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	esi, DWORD PTR [edx+12]
	or	edx, -1
	sub	edx, eax
	mov	DWORD PTR __First$[esp+4], esi
	add	ecx, edx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun@6
$LN2@Lower_boun@6:

; 2267 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun@6:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun@6
	pop	edi
$LN42@Lower_boun@6:

; 2268 : 		}
; 2269 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2270 : 	}

	ret	0
??$_Lower_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@PAH@Z ENDP ; std::_Lower_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity,int>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Upper_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@PAH@Z PROC ; std::_Upper_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity,int>, COMDAT

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;
; 2327 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN42@Upper_boun@6
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
$LL4@Upper_boun@6:

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2331 : 		_FwdIt _Mid = _First;
; 2332 : 		std::advance(_Mid, _Count2);

	lea	edx, DWORD PTR [eax+eax*2]

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	cmp	edi, DWORD PTR [esi+edx*4+4]
	lea	edx, DWORD PTR [esi+edx*4]
	jg	SHORT $LN2@Upper_boun@6

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	esi, DWORD PTR [edx+12]
	or	edx, -1
	sub	edx, eax
	mov	DWORD PTR __First$[esp+4], esi
	add	ecx, edx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun@6
$LN2@Upper_boun@6:

; 2338 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun@6:

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun@6
	pop	edi
$LN42@Upper_boun@6:

; 2339 : 		}
; 2340 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2341 : 	}

	ret	0
??$_Upper_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@PAH@Z ENDP ; std::_Upper_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T251758 = -4						; size = 1
__Cat$251763 = 8					; size = 1
$T251760 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$251763[esp]
	mov	edx, DWORD PTR $T251760[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T251758[esp+8], 0
	mov	eax, DWORD PTR $T251758[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@@Z ; stdext::unchecked_copy_backward<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@@Z
_TEXT	SEGMENT
$T251772 = -4						; size = 1
__Cat$251777 = 8					; size = 1
$T251774 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@@Z PROC ; stdext::unchecked_copy_backward<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$251777[esp]
	mov	edx, DWORD PTR $T251774[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T251772[esp+8], 0
	mov	eax, DWORD PTR $T251772[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@@Z ENDP ; stdext::unchecked_copy_backward<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@@Z ; stdext::unchecked_copy<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@@Z
_TEXT	SEGMENT
$T251786 = -4						; size = 1
__Cat$251791 = 8					; size = 1
$T251788 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@@Z PROC ; stdext::unchecked_copy<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$251791[esp]
	mov	edx, DWORD PTR $T251788[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T251786[esp+8], 0
	mov	eax, DWORD PTR $T251786[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@@Z ENDP ; stdext::unchecked_copy<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T251802 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+12]
	xor	ebx, ebx
	mov	DWORD PTR $T251802[esp+16], ebx
	cmp	ecx, edi
	je	SHORT $LN1@Copy_opt@16
	lea	esi, DWORD PTR [ebx+16]
	npad	7
$LL3@Copy_opt@16:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __Dest$[esp+28]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN14@Copy_opt@16
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __Dest$[esp+28]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN2@Copy_opt@16
$LN14@Copy_opt@16:
	cmp	eax, ebx
	je	SHORT $LN19@Copy_opt@16
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR __Dest$[esp+28]
$LN19@Copy_opt@16:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Copy_opt@16:
	add	ecx, esi
	cmp	ecx, edi
	jne	SHORT $LL3@Copy_opt@16
$LN1@Copy_opt@16:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	cmp	eax, ebx
	je	SHORT $LN41@Copy_opt@16
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Copy_opt@16:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 4
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),std::random_access_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebx

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ebx, DWORD PTR __Dest$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Last1$[esp+4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp+8]
	push	edi
	mov	edi, DWORD PTR __First2$[esp+12]
	cmp	esi, ebp
	je	$LN38@Merge@4
	npad	4
$LL5@Merge@4:
	mov	edx, DWORD PTR __Last2$[esp+12]
	cmp	edi, edx
	je	$LN3@Merge@4

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [edi+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[esp+44]
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN2@Merge@4

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [ebx+8], edx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [ebx+12], eax
	add	edi, 16					; 00000010H

; 2600 : 		else

	jmp	SHORT $LN4@Merge@4
$LN2@Merge@4:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx+4], edx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+8], eax
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [ebx+12], ecx
	add	esi, 16					; 00000010H
$LN4@Merge@4:
	add	ebx, 16					; 00000010H
	cmp	esi, ebp
	jne	$LL5@Merge@4
$LN38@Merge@4:

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	edx, DWORD PTR __Last2$[esp+12]
$LN3@Merge@4:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	eax, esi
	cmp	esi, ebp
	je	SHORT $LN14@Merge@4
$LL16@Merge@4:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ebx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ebx+12], ecx
	add	eax, 16					; 00000010H
	add	ebx, 16					; 00000010H
	cmp	eax, ebp
	jne	SHORT $LL16@Merge@4
$LN14@Merge@4:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	eax, ebx
	mov	ecx, edi
	cmp	edi, edx
	je	SHORT $LN25@Merge@4
	npad	2
$LL27@Merge@4:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL27@Merge@4
$LN25@Merge@4:

; 2605 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$rotate@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@00@Z ; std::rotate<CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@00@Z PROC ; std::rotate<CvBlockingUnit *>, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN6@rotate@3
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN6@rotate@3

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00PAH0@Z ; std::_Rotate<CvBlockingUnit *,int,CvBlockingUnit>
	add	esp, 20					; 00000014H
$LN6@rotate@3:

; 1721 : 	}

	ret	0
??$rotate@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@00@Z ENDP ; std::rotate<CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvBlockingUnit@@PAV1@H@std@@YAXPAVCvBlockingUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvBlockingUnit@@PAV1@H@std@@YAXPAVCvBlockingUnit@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T252031 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
$T252107 = 24						; size = 1
$T252108 = 24						; size = 1
$T252032 = 24						; size = 1
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvBlockingUnit@@PAV1@H@std@@YAXPAVCvBlockingUnit@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ecx

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edx, DWORD PTR __Count$[esp]
	mov	eax, DWORD PTR __Dest$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Chunk$[esp+4]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp+ebp]
	cmp	edi, edx
	jg	SHORT $LN3@Chunked_me
	shl	ebp, 4
	push	ebx
$LL50@Chunked_me:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	BYTE PTR $T252031[esp+20], 0
	mov	ebx, DWORD PTR $T252031[esp+20]
	push	ebx
	mov	ebx, DWORD PTR $T252032[esp+20]
	push	ebx
	lea	edx, DWORD PTR [ecx+ebp]
	push	eax
	lea	esi, DWORD PTR [edx+ebp]
	push	esi
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>
	mov	edx, DWORD PTR __Count$[esp+44]
	sub	edx, edi
	add	esp, 28					; 0000001cH
	cmp	edx, edi

; 3297 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+16], edx
	jge	SHORT $LL50@Chunked_me
	mov	ebp, DWORD PTR __Chunk$[esp+16]
	pop	ebx
$LN3@Chunked_me:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	cmp	edx, ebp
	jg	SHORT $LN2@Chunked_me

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Last$[esp+12]
	cmp	ecx, edx
	je	SHORT $LN41@Chunked_me
	sub	eax, ecx
$LL32@Chunked_me:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+ecx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+ecx+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+ecx+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+ecx+12], esi
	add	ecx, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL32@Chunked_me
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	pop	ecx
	ret	0
$LN2@Chunked_me:

; 3302 : 	else
; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	BYTE PTR $T252107[esp+12], 0
	mov	edx, DWORD PTR $T252107[esp+12]
	push	edx
	mov	edx, DWORD PTR $T252108[esp+16]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Last$[esp+24]
	push	eax
	shl	ebp, 4
	add	ebp, ecx
	push	ebp
	push	ebp
	push	ecx
	call	??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN41@Chunked_me:
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	pop	ecx
	ret	0
??$_Chunked_merge@PAVCvBlockingUnit@@PAV1@H@std@@YAXPAVCvBlockingUnit@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@0@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@0@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T252158 = -24						; size = 4
$T252152 = -24						; size = 4
$T252150 = -24						; size = 4
$T252151 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@0@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	sub	esp, 24					; 00000018H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp+20]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T252158[esp+32], edi
	cmp	eax, DWORD PTR __Last1$[esp+28]
	je	SHORT $LN3@Merge@5
	mov	ecx, DWORD PTR __First2$[esp+28]
	npad	7
$LL4@Merge@5:
	cmp	ecx, DWORD PTR __Last2$[esp+28]
	je	SHORT $LN3@Merge@5

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+8]
	imul	edx, DWORD PTR [eax+4]
	imul	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	jle	SHORT $LN2@Merge@5

; 2515 : 			*_Dest = *_First2, ++_First2;

	push	ecx
	lea	ecx, DWORD PTR __Dest$[esp+32]
	call	??4?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@ABVCvTacticalUnit@@@Z ; std::_Temp_iterator<CvTacticalUnit>::operator=
	mov	ecx, DWORD PTR __First2$[esp+28]

; 2516 : 		else

	mov	eax, DWORD PTR __First1$[esp+28]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __First2$[esp+28], ecx
	jmp	SHORT $LN56@Merge@5
$LN2@Merge@5:

; 2517 : 			*_Dest = *_First1, ++_First1;

	push	eax
	lea	ecx, DWORD PTR __Dest$[esp+32]
	call	??4?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEAAV01@ABVCvTacticalUnit@@@Z ; std::_Temp_iterator<CvTacticalUnit>::operator=
	mov	eax, DWORD PTR __First1$[esp+28]
	mov	ecx, DWORD PTR __First2$[esp+28]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __First1$[esp+28], eax
$LN56@Merge@5:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	eax, DWORD PTR __Last1$[esp+28]
	jne	SHORT $LL4@Merge@5
$LN3@Merge@5:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last1$[esp+48]
	mov	eax, DWORD PTR __First1$[esp+48]
	mov	DWORD PTR $T252150[esp+52], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T252151[esp+60]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T252151[esp+64]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+44], edx
	cmp	eax, edi
	je	SHORT $LN72@Merge@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN72@Merge@5:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+48]
	mov	eax, DWORD PTR __First2$[esp+48]
	mov	DWORD PTR $T252152[esp+52], esp
	push	edx
	push	eax
	push	esi
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN93@Merge@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN93@Merge@5:

; 2521 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@0@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalUnit *,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T252315 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
$T252392 = 20						; size = 1
$T252367 = 20						; size = 1
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Cat$252396 = 28					; size = 1
$T252394 = 28						; size = 1
__Cat$252371 = 28					; size = 1
$T252369 = 28						; size = 1
__Dest$ = 28						; size = 4
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvTacticalUnit *,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Last1$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __First2$[esp+8]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+12]
	cmp	eax, edx
	je	$LN3@Merge@6
$LL10@Merge@6:
	cmp	esi, edi
	je	$LN3@Merge@6

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	ebx, DWORD PTR [eax+8]
	mov	ebp, DWORD PTR [esi+8]
	imul	ebx, DWORD PTR [eax+4]
	imul	ebp, DWORD PTR [esi+4]
	cmp	ebp, ebx
	jle	SHORT $LN2@Merge@6

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+8], ecx
	mov	ecx, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+12], ecx
	mov	ecx, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+16], ecx
	mov	ecx, DWORD PTR [esi+20]
	add	esi, 24					; 00000018H

; 2516 : 		else

	jmp	SHORT $LN41@Merge@6
$LN2@Merge@6:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+16], ecx
	mov	ecx, DWORD PTR [eax+20]
	add	eax, 24					; 00000018H
$LN41@Merge@6:
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+20], ecx
	mov	ecx, DWORD PTR __Dest$[esp+12]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Dest$[esp+12], ecx
	cmp	eax, edx
	jne	$LL10@Merge@6
$LN3@Merge@6:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	xor	bl, bl
	mov	BYTE PTR $T252367[esp+12], bl
	mov	ebp, DWORD PTR $T252367[esp+12]
	push	ebp
	mov	ebp, DWORD PTR __Cat$252371[esp+16]
	push	ebp
	mov	ebp, DWORD PTR $T252369[esp+20]
	push	ebp
	push	ecx
	push	edx
	push	eax
	lea	edx, DWORD PTR $T252315[esp+36]
	push	edx
	call	??$_Copy_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Cat$252396[esp+40]
	mov	edx, DWORD PTR $T252394[esp+40]
	mov	BYTE PTR $T252392[esp+40], bl
	mov	eax, DWORD PTR $T252392[esp+40]
	push	eax
	mov	eax, DWORD PTR $T252315[esp+44]
	push	ecx
	push	edx
	push	eax
	push	edi
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+64]
	push	esi
	call	??$_Copy_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvTacticalUnit *,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00PAHPAVCvTacticalUnit@@@Z ; std::_Rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00PAHPAVCvTacticalUnit@@@Z
_TEXT	SEGMENT
tv364 = -44						; size = 4
tv431 = -40						; size = 4
$T252412 = -36						; size = 4
$T252416 = -32						; size = 4
$T252417 = -28						; size = 4
__Holeval$236116 = -24					; size = 24
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00PAHPAVCvTacticalUnit@@@Z PROC ; std::_Rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>, COMDAT

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	ecx, DWORD PTR __Mid$[esp-4]
	sub	esp, 44					; 0000002cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __First$[esp+52]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+52]
	sar	edx, 2
	mov	ebx, edx
	sub	ecx, esi
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	edi
	mov	ebp, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate@4
$LL8@Rotate@4:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, ebp
	cdq
	idiv	edi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	ebp, edi
	mov	edi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate@4
$LN7@Rotate@4:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	ebp, ecx
	jge	$LN3@Rotate@4

; 1692 : 		for (; 0 < _Count; --_Count)

	test	ebp, ebp
	jle	$LN3@Rotate@4
	lea	eax, DWORD PTR [ebx+ebx*2]
	add	eax, eax
	lea	edx, DWORD PTR [ebp+ebp*2]
	add	edx, edx
	add	eax, eax
	add	eax, eax
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv364[esp+60], eax
	mov	DWORD PTR tv431[esp+60], edx
	jmp	SHORT $LN5@Rotate@4
	npad	5
$LL93@Rotate@4:
	mov	esi, DWORD PTR __First$[esp+56]
	mov	eax, DWORD PTR tv364[esp+60]
$LN5@Rotate@4:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	lea	edi, DWORD PTR [edx+esi]

; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR __Holeval$236116[esp+60], esi
	mov	esi, DWORD PTR [edi+4]
	mov	DWORD PTR __Holeval$236116[esp+64], esi
	mov	esi, DWORD PTR [edi+8]
	mov	DWORD PTR __Holeval$236116[esp+68], esi
	mov	esi, DWORD PTR [edi+12]
	mov	DWORD PTR __Holeval$236116[esp+72], esi
	mov	esi, DWORD PTR [edi+16]
	mov	DWORD PTR __Holeval$236116[esp+76], esi
	mov	esi, DWORD PTR [edi+20]

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	add	eax, edi
	mov	ecx, edi
	mov	DWORD PTR __Holeval$236116[esp+80], esi
	cmp	eax, DWORD PTR __Last$[esp+56]
	jne	SHORT $LN11@Rotate@4
	lea	eax, DWORD PTR __First$[esp+56]
	jmp	SHORT $LN12@Rotate@4
$LN11@Rotate@4:
	mov	DWORD PTR $T252412[esp+60], eax
	lea	eax, DWORD PTR $T252412[esp+60]
$LN12@Rotate@4:
	mov	esi, DWORD PTR [eax]

; 1698 : 			while (_Next1 != _Hole)

	cmp	esi, edi
	je	SHORT $LN1@Rotate@4
$LL2@Rotate@4:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], eax
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [ecx+20], edx

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, DWORD PTR __Last$[esp+56]
	sub	edx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	mov	ecx, esi
	jge	SHORT $LN13@Rotate@4
	mov	eax, DWORD PTR tv364[esp+60]
	add	eax, esi
	mov	DWORD PTR $T252416[esp+60], eax
	lea	eax, DWORD PTR $T252416[esp+60]
	jmp	SHORT $LN14@Rotate@4
$LN13@Rotate@4:
	mov	edx, ebx
	sub	edx, eax
	mov	eax, DWORD PTR __First$[esp+56]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T252417[esp+60], edx
	lea	eax, DWORD PTR $T252417[esp+60]
$LN14@Rotate@4:
	mov	esi, DWORD PTR [eax]
	cmp	esi, edi
	jne	SHORT $LL2@Rotate@4

; 1698 : 			while (_Next1 != _Hole)

	mov	edx, DWORD PTR tv431[esp+60]
$LN1@Rotate@4:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	eax, DWORD PTR __Holeval$236116[esp+60]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Holeval$236116[esp+64]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Holeval$236116[esp+68]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Holeval$236116[esp+72]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __Holeval$236116[esp+76]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __Holeval$236116[esp+80]
	dec	ebp
	sub	edx, 24					; 00000018H
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR tv431[esp+60], edx
	test	ebp, ebp
	jg	$LL93@Rotate@4
$LN3@Rotate@4:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 44					; 0000002cH
	ret	0
??$_Rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00PAHPAVCvTacticalUnit@@@Z ENDP ; std::_Rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$_Merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@0@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@0@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T252602 = -24						; size = 4
$T252596 = -24						; size = 4
$T252594 = -24						; size = 4
$T252595 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@0@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	sub	esp, 24					; 00000018H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp+20]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T252602[esp+32], edi
	cmp	eax, DWORD PTR __Last1$[esp+28]
	je	SHORT $LN3@Merge@7
	mov	ecx, DWORD PTR __First2$[esp+28]
	npad	7
$LL4@Merge@7:
	cmp	ecx, DWORD PTR __Last2$[esp+28]
	je	SHORT $LN3@Merge@7

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	jle	SHORT $LN2@Merge@7

; 2515 : 			*_Dest = *_First2, ++_First2;

	push	ecx
	lea	ecx, DWORD PTR __Dest$[esp+32]
	call	??4?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@ABVCvTacticalCity@@@Z ; std::_Temp_iterator<CvTacticalCity>::operator=
	mov	ecx, DWORD PTR __First2$[esp+28]

; 2516 : 		else

	mov	eax, DWORD PTR __First1$[esp+28]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __First2$[esp+28], ecx
	jmp	SHORT $LN56@Merge@7
$LN2@Merge@7:

; 2517 : 			*_Dest = *_First1, ++_First1;

	push	eax
	lea	ecx, DWORD PTR __Dest$[esp+32]
	call	??4?$_Temp_iterator@VCvTacticalCity@@@std@@QAEAAV01@ABVCvTacticalCity@@@Z ; std::_Temp_iterator<CvTacticalCity>::operator=
	mov	eax, DWORD PTR __First1$[esp+28]
	mov	ecx, DWORD PTR __First2$[esp+28]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __First1$[esp+28], eax
$LN56@Merge@7:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	eax, DWORD PTR __Last1$[esp+28]
	jne	SHORT $LL4@Merge@7
$LN3@Merge@7:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last1$[esp+48]
	mov	eax, DWORD PTR __First1$[esp+48]
	mov	DWORD PTR $T252594[esp+52], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T252595[esp+60]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T252595[esp+64]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+44], edx
	cmp	eax, edi
	je	SHORT $LN72@Merge@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN72@Merge@7:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+48]
	mov	eax, DWORD PTR __First2$[esp+48]
	mov	DWORD PTR $T252596[esp+52], esp
	push	edx
	push	eax
	push	esi
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN93@Merge@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN93@Merge@7:

; 2521 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@0@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalCity *,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T252761 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
$T252840 = 20						; size = 1
$T252815 = 20						; size = 1
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Cat$252844 = 28					; size = 1
$T252842 = 28						; size = 1
__Cat$252819 = 28					; size = 1
$T252817 = 28						; size = 1
__Dest$ = 28						; size = 4
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvTacticalCity *,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Last1$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __First2$[esp+8]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+12]
	cmp	eax, edx
	je	SHORT $LN3@Merge@8
	npad	4
$LL10@Merge@8:
	cmp	esi, edi
	je	SHORT $LN3@Merge@8

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	ebx, DWORD PTR [esi+4]
	cmp	ebx, DWORD PTR [eax+4]
	jle	SHORT $LN2@Merge@8

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR [esi+8]
	add	esi, 12					; 0000000cH

; 2516 : 		else

	jmp	SHORT $LN41@Merge@8
$LN2@Merge@8:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	add	eax, 12					; 0000000cH
$LN41@Merge@8:
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+8], ecx
	mov	ecx, DWORD PTR __Dest$[esp+12]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[esp+12], ecx
	cmp	eax, edx
	jne	SHORT $LL10@Merge@8
$LN3@Merge@8:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	xor	bl, bl
	mov	BYTE PTR $T252815[esp+12], bl
	mov	ebp, DWORD PTR $T252815[esp+12]
	push	ebp
	mov	ebp, DWORD PTR __Cat$252819[esp+16]
	push	ebp
	mov	ebp, DWORD PTR $T252817[esp+20]
	push	ebp
	push	ecx
	push	edx
	push	eax
	lea	edx, DWORD PTR $T252761[esp+36]
	push	edx
	call	??$_Copy_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Cat$252844[esp+40]
	mov	edx, DWORD PTR $T252842[esp+40]
	mov	BYTE PTR $T252840[esp+40], bl
	mov	eax, DWORD PTR $T252840[esp+40]
	push	eax
	mov	eax, DWORD PTR $T252761[esp+44]
	push	ecx
	push	edx
	push	eax
	push	edi
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+64]
	push	esi
	call	??$_Copy_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvTacticalCity *,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00PAHPAVCvTacticalCity@@@Z ; std::_Rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00PAHPAVCvTacticalCity@@@Z
_TEXT	SEGMENT
tv364 = -32						; size = 4
tv431 = -28						; size = 4
$T252860 = -24						; size = 4
$T252864 = -20						; size = 4
$T252865 = -16						; size = 4
__Holeval$236185 = -12					; size = 12
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00PAHPAVCvTacticalCity@@@Z PROC ; std::_Rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>, COMDAT

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	ecx, DWORD PTR __Mid$[esp-4]
	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+44]
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+44]
	sar	edx, 1
	mov	ebx, edx
	sub	ecx, edi
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	ebp, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate@5
	npad	1
$LL8@Rotate@5:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, ebp
	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	ebp, esi
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate@5
$LN7@Rotate@5:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	ebp, ecx
	jge	$LN3@Rotate@5

; 1692 : 		for (; 0 < _Count; --_Count)

	test	ebp, ebp
	jle	$LN3@Rotate@5
	lea	eax, DWORD PTR [ebx+ebx*2]
	add	eax, eax
	lea	edx, DWORD PTR [ebp+ebp*2]
	add	eax, eax
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv364[esp+48], eax
	mov	DWORD PTR tv431[esp+48], edx
	jmp	SHORT $LN5@Rotate@5
	npad	10
$LL93@Rotate@5:
	mov	edi, DWORD PTR __First$[esp+44]
	mov	eax, DWORD PTR tv364[esp+48]
$LN5@Rotate@5:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, DWORD PTR [edi+edx]
	add	edi, edx
	mov	DWORD PTR __Holeval$236185[esp+48], ecx
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR __Holeval$236185[esp+52], ecx
	mov	ecx, DWORD PTR [edi+8]

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	add	eax, edi
	mov	esi, edi
	mov	DWORD PTR __Holeval$236185[esp+56], ecx
	cmp	eax, DWORD PTR __Last$[esp+44]
	jne	SHORT $LN11@Rotate@5
	lea	eax, DWORD PTR __First$[esp+44]
	jmp	SHORT $LN12@Rotate@5
$LN11@Rotate@5:
	mov	DWORD PTR $T252860[esp+48], eax
	lea	eax, DWORD PTR $T252860[esp+48]
$LN12@Rotate@5:
	mov	ecx, DWORD PTR [eax]

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, edi
	je	SHORT $LN1@Rotate@5
	npad	3
$LL2@Rotate@5:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], edx

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, DWORD PTR __Last$[esp+44]
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	mov	esi, ecx
	jge	SHORT $LN13@Rotate@5
	mov	eax, DWORD PTR tv364[esp+48]
	add	eax, ecx
	mov	DWORD PTR $T252864[esp+48], eax
	lea	eax, DWORD PTR $T252864[esp+48]
	jmp	SHORT $LN14@Rotate@5
$LN13@Rotate@5:
	mov	edx, DWORD PTR __First$[esp+44]
	mov	ecx, ebx
	sub	ecx, eax
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T252865[esp+48], eax
	lea	eax, DWORD PTR $T252865[esp+48]
$LN14@Rotate@5:
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, edi
	jne	SHORT $LL2@Rotate@5

; 1698 : 			while (_Next1 != _Hole)

	mov	edx, DWORD PTR tv431[esp+48]
$LN1@Rotate@5:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	ecx, DWORD PTR __Holeval$236185[esp+48]
	mov	eax, DWORD PTR __Holeval$236185[esp+52]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR __Holeval$236185[esp+56]
	dec	ebp
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR tv431[esp+48], edx
	test	ebp, ebp
	jg	$LL93@Rotate@5
$LN3@Rotate@5:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00PAHPAVCvTacticalCity@@@Z ENDP ; std::_Rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@5
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy@5:
$LN2@Buy@5:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@5:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@3:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@16
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@16:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@16
	pop	esi
$LN7@unchecked_@16:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?InitializeQueuedAttacks@CvTacticalAI@@QAEXXZ	; CvTacticalAI::InitializeQueuedAttacks
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
;	COMDAT ?InitializeQueuedAttacks@CvTacticalAI@@QAEXXZ
_TEXT	SEGMENT
?InitializeQueuedAttacks@CvTacticalAI@@QAEXXZ PROC	; CvTacticalAI::InitializeQueuedAttacks, COMDAT
; _this$ = ecx

; 528  : {

	push	esi
	mov	esi, ecx

; 529  : 	m_QueuedAttacks.clear();

	mov	ecx, DWORD PTR [esi+2140]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ecx
	mov	ecx, DWORD PTR [esi+2140]
	mov	DWORD PTR [ecx+4], ecx
	mov	DWORD PTR [esi+2144], 0
	cmp	eax, DWORD PTR [esi+2140]
	je	SHORT $LN20@Initialize
	push	edi
	npad	7
$LL5@Initialize:
	mov	edi, DWORD PTR [eax]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, edi
	cmp	edi, DWORD PTR [esi+2140]
	jne	SHORT $LL5@Initialize
	pop	edi
$LN20@Initialize:

; 530  : 	m_iCurrentSeriesID = 0;

	mov	DWORD PTR [esi+2148], 0
	pop	esi

; 531  : }

	ret	0
?InitializeQueuedAttacks@CvTacticalAI@@QAEXXZ ENDP	; CvTacticalAI::InitializeQueuedAttacks
_TEXT	ENDS
PUBLIC	?PlotAlreadyTargeted@CvTacticalAI@@QAEHPAVCvPlot@@@Z ; CvTacticalAI::PlotAlreadyTargeted
; Function compile flags: /Ogtpy
;	COMDAT ?PlotAlreadyTargeted@CvTacticalAI@@QAEHPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?PlotAlreadyTargeted@CvTacticalAI@@QAEHPAVCvPlot@@@Z PROC ; CvTacticalAI::PlotAlreadyTargeted, COMDAT
; _this$ = ecx

; 784  : 	if(m_QueuedAttacks.size() > 0)

	cmp	DWORD PTR [ecx+2144], 0
	push	esi
	push	edi
	jbe	SHORT $LN2@PlotAlread

; 785  : 	{
; 786  : 		std::list<CvQueuedAttack>::iterator it;
; 787  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 788  : 		for (it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); ++it)
; 789  : #else
; 790  : 		for(it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); it++)

	mov	ecx, DWORD PTR [ecx+2140]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, ecx
	je	SHORT $LN2@PlotAlread
	mov	edx, DWORD PTR _pPlot$[esp+4]
	movsx	esi, WORD PTR [edx]
	npad	2
$LL26@PlotAlread:

; 791  : #endif
; 792  : 		{
; 793  : 			if(it->GetTarget()->GetTargetX() == pPlot->getX() &&
; 794  : 			        it->GetTarget()->GetTargetY() == pPlot->getY())

	cmp	DWORD PTR [eax+16], esi
	jne	SHORT $LN3@PlotAlread
	movsx	edi, WORD PTR [edx+2]
	cmp	DWORD PTR [eax+20], edi
	je	SHORT $LN79@PlotAlread
$LN3@PlotAlread:

; 785  : 	{
; 786  : 		std::list<CvQueuedAttack>::iterator it;
; 787  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 788  : 		for (it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); ++it)
; 789  : #else
; 790  : 		for(it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); it++)

	mov	eax, DWORD PTR [eax]
	cmp	eax, ecx
	jne	SHORT $LL26@PlotAlread
$LN2@PlotAlread:
	pop	edi

; 797  : 			}
; 798  : 		}
; 799  : 	}
; 800  : 	return -1;

	or	eax, -1
	pop	esi

; 801  : }

	ret	4
$LN79@PlotAlread:

; 795  : 			{
; 796  : 				return it->GetSeriesID();

	mov	eax, DWORD PTR [eax+40]
	pop	edi
	pop	esi

; 801  : }

	ret	4
?PlotAlreadyTargeted@CvTacticalAI@@QAEHPAVCvPlot@@@Z ENDP ; CvTacticalAI::PlotAlreadyTargeted
_TEXT	ENDS
PUBLIC	?IsInQueuedAttack@CvTacticalAI@@QAE_NPBVCvUnit@@@Z ; CvTacticalAI::IsInQueuedAttack
; Function compile flags: /Ogtpy
;	COMDAT ?IsInQueuedAttack@CvTacticalAI@@QAE_NPBVCvUnit@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
?IsInQueuedAttack@CvTacticalAI@@QAE_NPBVCvUnit@@@Z PROC	; CvTacticalAI::IsInQueuedAttack, COMDAT
; _this$ = ecx

; 806  : 	if(m_QueuedAttacks.size() > 0)

	cmp	DWORD PTR [ecx+2144], 0
	jbe	SHORT $LN2@IsInQueued

; 807  : 	{
; 808  : 		std::list<CvQueuedAttack>::iterator it;
; 809  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 810  : 		for (it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); ++it)
; 811  : #else
; 812  : 		for(it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); it++)

	mov	ecx, DWORD PTR [ecx+2140]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, ecx
	je	SHORT $LN2@IsInQueued
	mov	edx, DWORD PTR _pUnit$[esp-4]
	npad	7
$LL26@IsInQueued:

; 813  : #endif
; 814  : 		{
; 815  : 			if(it->GetAttacker() == pUnit)

	cmp	DWORD PTR [eax+8], edx
	je	SHORT $LN51@IsInQueued
	mov	eax, DWORD PTR [eax]
	cmp	eax, ecx
	jne	SHORT $LL26@IsInQueued
$LN2@IsInQueued:

; 818  : 			}
; 819  : 		}
; 820  : 	}
; 821  : 	return false;

	xor	al, al

; 822  : }

	ret	4
$LN51@IsInQueued:

; 816  : 			{
; 817  : 				return true;

	mov	al, 1

; 822  : }

	ret	4
?IsInQueuedAttack@CvTacticalAI@@QAE_NPBVCvUnit@@@Z ENDP	; CvTacticalAI::IsInQueuedAttack
_TEXT	ENDS
PUBLIC	?IsCityInQueuedAttack@CvTacticalAI@@QAE_NPBVCvCity@@@Z ; CvTacticalAI::IsCityInQueuedAttack
; Function compile flags: /Ogtpy
;	COMDAT ?IsCityInQueuedAttack@CvTacticalAI@@QAE_NPBVCvCity@@@Z
_TEXT	SEGMENT
_pAttackCity$ = 8					; size = 4
?IsCityInQueuedAttack@CvTacticalAI@@QAE_NPBVCvCity@@@Z PROC ; CvTacticalAI::IsCityInQueuedAttack, COMDAT
; _this$ = ecx

; 827  : 	if(m_QueuedAttacks.size() > 0)

	cmp	DWORD PTR [ecx+2144], 0
	jbe	SHORT $LN2@IsCityInQu

; 828  : 	{
; 829  : 		std::list<CvQueuedAttack>::iterator it;
; 830  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 831  : 		for (it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); ++it)
; 832  : #else
; 833  : 		for(it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); it++)

	mov	ecx, DWORD PTR [ecx+2140]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, ecx
	je	SHORT $LN2@IsCityInQu
	mov	edx, DWORD PTR _pAttackCity$[esp-4]
	npad	7
$LL26@IsCityInQu:

; 834  : #endif
; 835  : 		{
; 836  : 			if(it->IsCityAttack() && it->GetAttacker() == (void*)pAttackCity)

	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LN3@IsCityInQu
	cmp	DWORD PTR [eax+8], edx
	je	SHORT $LN61@IsCityInQu
$LN3@IsCityInQu:

; 828  : 	{
; 829  : 		std::list<CvQueuedAttack>::iterator it;
; 830  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 831  : 		for (it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); ++it)
; 832  : #else
; 833  : 		for(it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); it++)

	mov	eax, DWORD PTR [eax]
	cmp	eax, ecx
	jne	SHORT $LL26@IsCityInQu
$LN2@IsCityInQu:

; 839  : 			}
; 840  : 		}
; 841  : 	}
; 842  : 	return false;

	xor	al, al

; 843  : }

	ret	4
$LN61@IsCityInQu:

; 837  : 			{
; 838  : 				return true;

	mov	al, 1

; 843  : }

	ret	4
?IsCityInQueuedAttack@CvTacticalAI@@QAE_NPBVCvCity@@@Z ENDP ; CvTacticalAI::IsCityInQueuedAttack
_TEXT	ENDS
PUBLIC	?NearXQueuedAttacks@CvTacticalAI@@QAEHPBVCvPlot@@H@Z ; CvTacticalAI::NearXQueuedAttacks
; Function compile flags: /Ogtpy
;	COMDAT ?NearXQueuedAttacks@CvTacticalAI@@QAEHPBVCvPlot@@H@Z
_TEXT	SEGMENT
_iNearbyAttacks$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_iRange$ = 12						; size = 4
?NearXQueuedAttacks@CvTacticalAI@@QAEHPBVCvPlot@@H@Z PROC ; CvTacticalAI::NearXQueuedAttacks, COMDAT
; _this$ = ecx

; 847  : {

	push	ecx

; 848  : 	int iNearbyAttacks = 0;

	xor	eax, eax
	mov	DWORD PTR _iNearbyAttacks$[esp+4], eax

; 849  : 
; 850  : 	if(m_QueuedAttacks.size() > 0)

	cmp	DWORD PTR [ecx+2144], eax
	jbe	SHORT $LN2@NearXQueue
	push	ebp

; 851  : 	{
; 852  : 		std::list<CvQueuedAttack>::iterator it;
; 853  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 854  : 		for (it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); ++it)
; 855  : #else
; 856  : 		for(it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); it++)

	mov	ebp, DWORD PTR [ecx+2140]
	push	esi
	mov	esi, DWORD PTR [ebp]
	cmp	esi, ebp
	je	SHORT $LN72@NearXQueue
	mov	eax, DWORD PTR _pPlot$[esp+8]
	push	ebx
	movsx	ebx, WORD PTR [eax]
	push	edi
	movsx	edi, WORD PTR [eax+2]
	npad	6
$LL26@NearXQueue:

; 857  : #endif
; 858  : 		{
; 859  : 			int iDistance;
; 860  : 			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), it->GetTarget()->GetTargetX(), it->GetTarget()->GetTargetY());

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+16]
	push	eax
	push	ecx
	push	edi
	push	ebx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 861  : 			if(iDistance <= iRange)

	cmp	eax, DWORD PTR _iRange$[esp+16]
	jg	SHORT $LN3@NearXQueue

; 862  : 			{
; 863  : 				iNearbyAttacks++;

	inc	DWORD PTR _iNearbyAttacks$[esp+20]
$LN3@NearXQueue:

; 851  : 	{
; 852  : 		std::list<CvQueuedAttack>::iterator it;
; 853  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 854  : 		for (it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); ++it)
; 855  : #else
; 856  : 		for(it = m_QueuedAttacks.begin(); it != m_QueuedAttacks.end(); it++)

	mov	esi, DWORD PTR [esi]
	cmp	esi, ebp
	jne	SHORT $LL26@NearXQueue

; 864  : 			}
; 865  : 		}
; 866  : 	}
; 867  : 	return iNearbyAttacks;

	mov	eax, DWORD PTR _iNearbyAttacks$[esp+20]
	pop	edi
	pop	ebx
$LN72@NearXQueue:
	pop	esi
	pop	ebp
$LN2@NearXQueue:

; 868  : }

	pop	ecx
	ret	8
?NearXQueuedAttacks@CvTacticalAI@@QAEHPBVCvPlot@@H@Z ENDP ; CvTacticalAI::NearXQueuedAttacks
_TEXT	ENDS
PUBLIC	?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ	; CvTacticalAI::ReviewUnassignedUnits
EXTRN	?SetTurnProcessed@CvUnit@@QAEX_N@Z:PROC		; CvUnit::SetTurnProcessed
EXTRN	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SKIP
EXTRN	?isBarbarian@CvUnit@@QBE_NXZ:PROC		; CvUnit::isBarbarian
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ$2
__ehfuncinfo$?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_pUnit$222147 = -76					; size = 8
_strTemp$222153 = -68					; size = 28
_strLogString$222152 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::ReviewUnassignedUnits, COMDAT
; _this$ = ecx

; 3862 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebp
	push	edi
	mov	edi, ecx

; 3863 : 	list<int>::iterator it;
; 3864 : 
; 3865 : 	// Loop through all remaining units
; 3866 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 3867 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 3868 : #else
; 3869 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [edi+12]
	mov	ebp, DWORD PTR [eax]
	cmp	ebp, eax
	je	$LN5@ReviewUnas
	push	ebx
	push	esi
	xor	ebx, ebx
	npad	3
$LL29@ReviewUnas:

; 3870 : #endif
; 3871 : 	{
; 3872 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$222147[esp+92], esi
	mov	BYTE PTR _pUnit$222147[esp+96], bl
	cmp	esi, ebx
	je	SHORT $LN52@ReviewUnas
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN52@ReviewUnas:
	mov	DWORD PTR __$EHRec$[esp+100], ebx

; 3873 : 		if(pUnit)

	cmp	esi, ebx
	je	$LN1@ReviewUnas

; 3874 : 		{
; 3875 : 			// Barbarians and air units aren't handled by the operational or homeland AIs
; 3876 : 			if(pUnit->isBarbarian() || pUnit->getDomainType() == DOMAIN_AIR)

	mov	ecx, esi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	SHORT $LN105@ReviewUnas
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	$LN1@ReviewUnas
$LN105@ReviewUnas:

; 3877 : 			{
; 3878 : 				pUnit->PushMission(CvTypes::getMISSION_SKIP());

	push	ebx
	push	ebx
	push	-1
	push	ebx
	push	ebx
	push	ebx
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3879 : 				pUnit->SetTurnProcessed(true);

	push	1
	mov	ecx, esi
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed

; 3880 : 
; 3881 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ReviewUnas
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ReviewUnas

; 3882 : 				{
; 3883 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222152[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3884 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222153[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3885 : 					strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+100], 2
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$222153[esp+92]
	cmp	eax, ebx
	je	SHORT $LN75@ReviewUnas
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN74@ReviewUnas
$LN75@ReviewUnas:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN74@ReviewUnas:

; 3886 : 					strLogString.Format("Unassigned %s at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$222153[esp+100]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$222152[esp+104]
	push	OFFSET $SG222154
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 3887 : 					LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$222152[esp+96]
	push	edx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 3888 : 				}

	lea	ecx, DWORD PTR _strTemp$222153[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$222152[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ReviewUnas:

; 3889 : 			}
; 3890 : 		}
; 3891 : 	}

	mov	DWORD PTR __$EHRec$[esp+100], -1
	cmp	esi, ebx
	je	SHORT $LN6@ReviewUnas
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@ReviewUnas:
	mov	ebp, DWORD PTR [ebp]
	cmp	ebp, DWORD PTR [edi+12]
	jne	$LL29@ReviewUnas
	pop	esi
	pop	ebx
$LN5@ReviewUnas:

; 3892 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$222147[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$222152[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$222153[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::ReviewUnassignedUnits
PUBLIC	?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::MoveToEmptySpaceNearTarget
EXTRN	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z:PROC ; CvPlot::isFriendlyCity
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z$0
__ehfuncinfo$?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z
_TEXT	SEGMENT
$T254093 = -28						; size = 8
$T254095 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_pTarget$ = 16						; size = 4
$T254096 = 20						; size = 4
_bMoveWasSafe$225317 = 20				; size = 1
_bLand$ = 20						; size = 1
?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z PROC ; CvTacticalAI::MoveToEmptySpaceNearTarget, COMDAT
; _this$ = ecx

; 9464 : {

	push	-1
	push	__ehhandler$?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	xor	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+52], ebp
$LN9@MoveToEmpt:

; 9469 : 	{
; 9470 : 		pLoopPlot = plotDirection(pTarget->getX(), pTarget->getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR _pTarget$[esp+40]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ebp
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 9471 : 		if(pLoopPlot != NULL && pLoopPlot->isWater() != bLand)

	test	esi, esi
	je	$LN8@MoveToEmpt
	cmp	BYTE PTR [esi+5], 3
	sete	al
	cmp	al, BYTE PTR _bLand$[esp+40]
	je	$LN8@MoveToEmpt

; 9472 : 		{
; 9473 : 			// Must be currently empty of friendly combat units
; 9474 : 			if(!pLoopPlot->getBestDefender(m_pPlayer->GetID()))

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+44]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	eax
	lea	edx, DWORD PTR $T254093[esp+72]
	push	edx
	mov	ecx, esi
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T254093[esp+44]
	sete	bl
	test	ecx, ecx
	je	SHORT $LN31@MoveToEmpt
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN31@MoveToEmpt:
	test	bl, bl
	je	$LN8@MoveToEmpt

; 9475 : 			{
; 9476 : 				// Enemies too
; 9477 : 				if(!pLoopPlot->getBestDefender(NO_PLAYER, m_pPlayer->GetID()))

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	-1
	lea	ecx, DWORD PTR $T254095[esp+72]
	push	ecx
	mov	ecx, esi
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T254095[esp+44]
	sete	bl
	test	ecx, ecx
	je	SHORT $LN42@MoveToEmpt
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN42@MoveToEmpt:
	test	bl, bl
	je	SHORT $LN8@MoveToEmpt

; 9478 : 				{
; 9479 : 					// And if it is a city, make sure we are friends with them, else we will automatically attack
; 9480 : 					if(pLoopPlot->getPlotCity() == NULL || pLoopPlot->isFriendlyCity(*pUnit, false))

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN2@MoveToEmpt
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN2@MoveToEmpt
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN2@MoveToEmpt
	mov	eax, DWORD PTR _pUnit$[esp+40]
	push	0
	push	eax
	mov	ecx, esi
	call	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z ; CvPlot::isFriendlyCity
	test	al, al
	je	SHORT $LN8@MoveToEmpt
$LN2@MoveToEmpt:

; 9481 : 					{
; 9482 : 						// Find a path to this space
; 9483 : 						if(pUnit->GeneratePath(pLoopPlot))

	mov	ecx, DWORD PTR _pUnit$[esp+40]
	push	0
	push	0
	push	0
	push	esi
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	jne	SHORT $LN69@MoveToEmpt
$LN8@MoveToEmpt:

; 9465 : 	CvPlot* pLoopPlot;
; 9466 : 
; 9467 : 	// Look at spaces adjacent to target
; 9468 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	inc	ebp
	cmp	ebp, 6
	jl	$LN9@MoveToEmpt

; 9489 : 						}
; 9490 : 					}
; 9491 : 				}
; 9492 : 			}
; 9493 : 		}
; 9494 : 	}
; 9495 : 	return false;

	mov	ecx, DWORD PTR _pUnit$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	ecx, ecx
	je	SHORT $LN66@MoveToEmpt
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN66@MoveToEmpt:
	xor	al, al

; 9496 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	16					; 00000010H
$LN69@MoveToEmpt:

; 9484 : 						{
; 9485 : 							// Go ahead with mission
; 9486 : 							bool bMoveWasSafe;
; 9487 : 							MoveToUsingSafeEmbark(pUnit, pLoopPlot, bMoveWasSafe);

	mov	edx, DWORD PTR _pUnit$[esp+40]
	lea	ecx, DWORD PTR _bMoveWasSafe$225317[esp+40]
	push	ecx
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	cl, BYTE PTR _pUnit$[esp+60]
	mov	BYTE PTR [eax+4], cl
	mov	eax, edx
	mov	DWORD PTR $T254096[esp+56], esp
	test	eax, eax
	je	SHORT $LN56@MoveToEmpt
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN56@MoveToEmpt:
	mov	ecx, edi
	call	?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z ; CvTacticalAI::MoveToUsingSafeEmbark

; 9488 : 							return true;

	mov	ecx, DWORD PTR _pUnit$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	ecx, ecx
	je	SHORT $LN61@MoveToEmpt
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN61@MoveToEmpt:

; 9496 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ENDP ; CvTacticalAI::MoveToEmptySpaceNearTarget
PUBLIC	?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::MoveToEmptySpaceTwoFromTarget
EXTRN	?plotCity@@YAPAVCvPlot@@HHH@Z:PROC		; plotCity
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z$0
__ehfuncinfo$?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z
_TEXT	SEGMENT
_iI$225328 = -32					; size = 4
$T254218 = -28						; size = 8
$T254220 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_pTarget$ = 16						; size = 4
$T254221 = 20						; size = 4
_bMoveWasSafe$225342 = 20				; size = 1
_bLand$ = 20						; size = 1
?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z PROC ; CvTacticalAI::MoveToEmptySpaceTwoFromTarget, COMDAT
; _this$ = ecx

; 9500 : {

	push	-1
	push	__ehhandler$?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 9501 : 	CvPlot* pLoopPlot;
; 9502 : 
; 9503 : 	// Look at spaces adjacent to target
; 9504 : 	for(int iI = 0; iI < NUM_CITY_PLOTS; iI++)

	mov	ebp, DWORD PTR _pTarget$[esp+44]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+56], ebx
	mov	DWORD PTR _iI$225328[esp+48], ebx
	npad	4
$LL9@MoveToEmpt@2:

; 9505 : 	{
; 9506 : 		pLoopPlot = plotCity(pTarget->getX(), pTarget->getY(), iI);

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	ebx
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 9507 : 		if(pLoopPlot != NULL && pLoopPlot->isWater() != bLand && plotDistance(pLoopPlot->getX(), pLoopPlot->getY(), pTarget->getX(), pTarget->getY() == 2))

	test	esi, esi
	je	$LN8@MoveToEmpt@2
	cmp	BYTE PTR [esi+5], 3
	sete	al
	cmp	al, BYTE PTR _bLand$[esp+44]
	je	$LN8@MoveToEmpt@2
	movsx	edx, WORD PTR [ebp]
	movsx	eax, WORD PTR [esi+2]
	xor	ecx, ecx
	cmp	WORD PTR [ebp+2], 2
	sete	cl
	push	ecx
	movsx	ecx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN8@MoveToEmpt@2

; 9508 : 		{
; 9509 : 			// Must be currently empty of friendly combat units
; 9510 : 			if(!pLoopPlot->getBestDefender(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+44]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	eax
	lea	eax, DWORD PTR $T254218[esp+76]
	push	eax
	mov	ecx, esi
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T254218[esp+48]
	sete	bl
	test	ecx, ecx
	je	SHORT $LN39@MoveToEmpt@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN39@MoveToEmpt@2:
	test	bl, bl
	je	$LN74@MoveToEmpt@2

; 9511 : 			{
; 9512 : 				// Enemies too
; 9513 : 				if(!pLoopPlot->getBestDefender(NO_PLAYER, m_pPlayer->GetID()))

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+44]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	-1
	lea	edx, DWORD PTR $T254220[esp+76]
	push	edx
	mov	ecx, esi
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T254220[esp+48]
	sete	bl
	test	ecx, ecx
	je	SHORT $LN50@MoveToEmpt@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN50@MoveToEmpt@2:
	test	bl, bl
	je	SHORT $LN74@MoveToEmpt@2

; 9514 : 				{
; 9515 : 					// And if it is a city, make sure we are friends with them, else we will automatically attack
; 9516 : 					if(pLoopPlot->getPlotCity() == NULL || pLoopPlot->isFriendlyCity(*pUnit, false))

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN2@MoveToEmpt@2
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN2@MoveToEmpt@2
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN2@MoveToEmpt@2
	mov	edx, DWORD PTR _pUnit$[esp+44]
	push	0
	push	edx
	mov	ecx, esi
	call	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z ; CvPlot::isFriendlyCity
	test	al, al
	je	SHORT $LN74@MoveToEmpt@2
$LN2@MoveToEmpt@2:

; 9517 : 					{
; 9518 : 						// Find a path to this space
; 9519 : 						if(pUnit->GeneratePath(pLoopPlot))

	mov	ecx, DWORD PTR _pUnit$[esp+44]
	push	0
	push	0
	push	0
	push	esi
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	jne	SHORT $LN72@MoveToEmpt@2
$LN74@MoveToEmpt@2:
	mov	ebx, DWORD PTR _iI$225328[esp+48]
$LN8@MoveToEmpt@2:

; 9501 : 	CvPlot* pLoopPlot;
; 9502 : 
; 9503 : 	// Look at spaces adjacent to target
; 9504 : 	for(int iI = 0; iI < NUM_CITY_PLOTS; iI++)

	inc	ebx
	cmp	ebx, 37					; 00000025H
	mov	DWORD PTR _iI$225328[esp+48], ebx
	jl	$LL9@MoveToEmpt@2

; 9525 : 						}
; 9526 : 					}
; 9527 : 				}
; 9528 : 			}
; 9529 : 		}
; 9530 : 	}
; 9531 : 	return false;

	mov	ecx, DWORD PTR _pUnit$[esp+44]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	test	ecx, ecx
	je	SHORT $LN69@MoveToEmpt@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN69@MoveToEmpt@2:
	xor	al, al

; 9532 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	16					; 00000010H
$LN72@MoveToEmpt@2:

; 9520 : 						{
; 9521 : 							// Go ahead with mission
; 9522 : 							bool bMoveWasSafe;
; 9523 : 							MoveToUsingSafeEmbark(pUnit, pLoopPlot, bMoveWasSafe);

	lea	eax, DWORD PTR _bMoveWasSafe$225342[esp+44]
	push	eax
	push	esi
	sub	esp, 8
	lea	edx, DWORD PTR _pUnit$[esp+60]
	mov	ecx, esp
	mov	DWORD PTR $T254221[esp+60], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z ; CvTacticalAI::MoveToUsingSafeEmbark

; 9524 : 							return true;

	mov	ecx, DWORD PTR _pUnit$[esp+44]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	test	ecx, ecx
	je	SHORT $LN64@MoveToEmpt@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN64@MoveToEmpt@2:

; 9532 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 32					; 00000020H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ENDP ; CvTacticalAI::MoveToEmptySpaceTwoFromTarget
PUBLIC	?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::FindBestBarbarianLandMove
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$0
__ehfuncinfo$?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
$T254347 = -16						; size = 4
$T254346 = -16						; size = 4
$T254345 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvTacticalAI::FindBestBarbarianLandMove, COMDAT
; _this$ = ecx

; 9619 : {

	push	-1
	push	__ehhandler$?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 9620 : 	CvPlot* pBestMovePlot = FindNearbyTarget(pUnit, m_iLandBarbarianRange);

	mov	eax, DWORD PTR [edi+24760]
	mov	ecx, DWORD PTR _pUnit$[esp+20]
	push	0
	push	0
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _pUnit$[esp+44]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+52], 0
	mov	DWORD PTR $T254345[esp+44], esp
	test	eax, eax
	je	SHORT $LN12@FindBestBa
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@FindBestBa:
	mov	ecx, edi
	call	?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z ; CvTacticalAI::FindNearbyTarget
	mov	esi, eax

; 9621 : 	
; 9622 : 	// move toward trade routes
; 9623 : 	if (pBestMovePlot == NULL)

	test	esi, esi
	jne	SHORT $LN1@FindBestBa

; 9624 : 	{
; 9625 : 		pBestMovePlot = FindBarbarianGankTradeRouteTarget(pUnit);

	mov	ecx, DWORD PTR _pUnit$[esp+20]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _pUnit$[esp+32]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T254346[esp+32], esp
	test	eax, eax
	je	SHORT $LN17@FindBestBa
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN17@FindBestBa:
	mov	ecx, edi
	call	?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::FindBarbarianGankTradeRouteTarget
	mov	esi, eax

; 9626 : 	}
; 9627 : 
; 9628 : 	// explore wander
; 9629 : 	if(pBestMovePlot == NULL)

	test	esi, esi
	jne	SHORT $LN1@FindBestBa

; 9630 : 	{
; 9631 : 		pBestMovePlot = FindBarbarianExploreTarget(pUnit);

	mov	ecx, DWORD PTR _pUnit$[esp+20]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _pUnit$[esp+32]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T254347[esp+32], esp
	test	eax, eax
	je	SHORT $LN22@FindBestBa
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN22@FindBestBa:
	mov	ecx, edi
	call	?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::FindBarbarianExploreTarget
	mov	esi, eax
$LN1@FindBestBa:

; 9632 : 	}
; 9633 : 
; 9634 : 	return pBestMovePlot;

	mov	ecx, DWORD PTR _pUnit$[esp+20]
	mov	DWORD PTR __$EHRec$[esp+32], -1
	test	ecx, ecx
	je	SHORT $LN29@FindBestBa
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN29@FindBestBa:

; 9635 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvTacticalAI::FindBestBarbarianLandMove
PUBLIC	?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::FindPassiveBarbarianLandMove
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$0
__ehfuncinfo$?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_iBestValue$ = -28					; size = 4
_iI$225392 = -24					; size = 4
tv322 = -20						; size = 4
$T254402 = -16						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvTacticalAI::FindPassiveBarbarianLandMove, COMDAT
; _this$ = ecx

; 9639 : {

	push	-1
	push	__ehhandler$?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+44], esi

; 9640 : 	CvPlot* pBestMovePlot = NULL;
; 9641 : 	int iBestValue;
; 9642 : 	int iValue;
; 9643 : 
; 9644 : 	iBestValue = MAX_INT;
; 9645 : 	pBestMovePlot = NULL;
; 9646 : 
; 9647 : 	for(unsigned int iI = 0; iI < m_AllTargets.size(); iI++)

	mov	eax, DWORD PTR [esi+2156]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+52], 0
	mov	DWORD PTR _iBestValue$[esp+44], 2147483647 ; 7fffffffH
	mov	DWORD PTR _iI$225392[esp+44], ebx
	mov	DWORD PTR tv322[esp+44], eax
	test	eax, eax
	jbe	$LN97@FindPassiv

; 9639 : {

	mov	ebp, DWORD PTR [esi+2152]
$LL6@FindPassiv:

; 9648 : 	{
; 9649 : 		// Is this target a camp?
; 9650 : 		if(m_AllTargets[iI].GetTargetType()==AI_TACTICAL_TARGET_BARBARIAN_CAMP)

	cmp	DWORD PTR [ebp], 2
	jne	$LN5@FindPassiv

; 9651 : 		{
; 9652 : 			iValue = plotDistance(pUnit->getX(), pUnit->getY(), m_AllTargets[iI].GetTargetX(), m_AllTargets[iI].GetTargetY());

	mov	edi, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR _pUnit$[esp+40]
	mov	esi, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [ecx+76]
	push	edi
	push	esi
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 9653 : 			if(iValue < iBestValue)

	cmp	eax, DWORD PTR _iBestValue$[esp+44]
	jge	$LN5@FindPassiv

; 9654 : 			{
; 9655 : 				iBestValue = iValue;

	mov	DWORD PTR _iBestValue$[esp+44], eax

; 9656 : 				pBestMovePlot = GC.getMap().plot(m_AllTargets[iI].GetTargetX(), m_AllTargets[iI].GetTargetY());

	cmp	esi, -2147483647			; 80000001H
	je	$LN47@FindPassiv
	cmp	edi, -2147483647			; 80000001H
	je	$LN47@FindPassiv
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4056]
	mov	ecx, DWORD PTR [edx+4020]
	test	al, al
	je	SHORT $LN57@FindPassiv
	test	esi, esi
	jge	SHORT $LN59@FindPassiv
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN103@FindPassiv
$LN59@FindPassiv:
	cmp	esi, ecx
	jl	SHORT $LN57@FindPassiv
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN103@FindPassiv:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
$LN57@FindPassiv:
	mov	al, BYTE PTR [edx+4057]
	mov	ebx, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN100@FindPassiv
	test	edi, edi
	jge	SHORT $LN69@FindPassiv
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN71@FindPassiv
$LN69@FindPassiv:
	cmp	edi, ebx
	jl	SHORT $LN100@FindPassiv
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN71@FindPassiv
$LN100@FindPassiv:
	mov	edx, edi
$LN71@FindPassiv:
	test	esi, esi
	jl	SHORT $LN47@FindPassiv
	cmp	esi, ecx
	jge	SHORT $LN47@FindPassiv
	test	edx, edx
	jl	SHORT $LN47@FindPassiv
	cmp	edx, ebx
	jge	SHORT $LN47@FindPassiv
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	ebx, ecx
	jmp	SHORT $LN5@FindPassiv
$LN47@FindPassiv:
	xor	ebx, ebx
$LN5@FindPassiv:

; 9640 : 	CvPlot* pBestMovePlot = NULL;
; 9641 : 	int iBestValue;
; 9642 : 	int iValue;
; 9643 : 
; 9644 : 	iBestValue = MAX_INT;
; 9645 : 	pBestMovePlot = NULL;
; 9646 : 
; 9647 : 	for(unsigned int iI = 0; iI < m_AllTargets.size(); iI++)

	mov	eax, DWORD PTR _iI$225392[esp+44]
	inc	eax
	add	ebp, 28					; 0000001cH
	mov	DWORD PTR _iI$225392[esp+44], eax
	cmp	eax, DWORD PTR tv322[esp+44]
	jb	$LL6@FindPassiv

; 9657 : 			}
; 9658 : 		}
; 9659 : 	}
; 9660 : 
; 9661 : 	if(pBestMovePlot == NULL)

	test	ebx, ebx
	jne	SHORT $LN1@FindPassiv
	mov	esi, DWORD PTR _this$[esp+44]
$LN97@FindPassiv:

; 9662 : 	{
; 9663 : 		pBestMovePlot = FindBarbarianExploreTarget(pUnit);

	mov	ecx, DWORD PTR _pUnit$[esp+40]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _pUnit$[esp+52]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T254402[esp+52], esp
	test	eax, eax
	je	SHORT $LN88@FindPassiv
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN88@FindPassiv:
	mov	ecx, esi
	call	?FindBarbarianExploreTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::FindBarbarianExploreTarget
	mov	ebx, eax
$LN1@FindPassiv:

; 9664 : 	}
; 9665 : 
; 9666 : 	return pBestMovePlot;

	mov	ecx, DWORD PTR _pUnit$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	ecx, ecx
	je	SHORT $LN99@FindPassiv
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN99@FindPassiv:

; 9667 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvTacticalAI::FindPassiveBarbarianLandMove
PUBLIC	?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::FindBestBarbarianSeaMove
EXTRN	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z:PROC	; CvUnit::baseMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$0
__ehfuncinfo$?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
tv1398 = -48						; size = 4
_this$ = -48						; size = 4
_pBestMovePlot$ = -44					; size = 4
_iBestValue$ = -40					; size = 4
_iMovementRange$225444 = -36				; size = 4
_pNearestCamp$225421 = -36				; size = 4
_iX$225445 = -32					; size = 4
_jJ$225428 = -32					; size = 4
tv1383 = -28						; size = 4
_iDistance$225426 = -28					; size = 4
tv1005 = -24						; size = 4
_iMovementRate$ = -24					; size = 4
tv1001 = -20						; size = 4
$T254612 = -20						; size = 4
$T254611 = -20						; size = 4
$T254610 = -20						; size = 4
$T254613 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvTacticalAI::FindBestBarbarianSeaMove, COMDAT
; _this$ = ecx

; 9671 : {

	push	-1
	push	__ehhandler$?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR _this$[esp+64], ebx

; 9672 : 	CvPlot* pBestMovePlot = NULL;
; 9673 : 	int iBestValue;
; 9674 : 	int iValue;
; 9675 : 	CvPlot* pPlot;
; 9676 : 	CvTacticalTarget* pTarget;
; 9677 : 	int iMovementRate;
; 9678 : 
; 9679 : 	iMovementRate = pUnit->baseMoves();

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	push	-1
	mov	DWORD PTR __$EHRec$[esp+76], 0
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves

; 9680 : 	iBestValue = MAX_INT;
; 9681 : 	pBestMovePlot = NULL;
; 9682 : 
; 9683 : 	// Loop through all unit targets to find the closest
; 9684 : 	pTarget = GetFirstUnitTarget();

	mov	ecx, ebx
	mov	DWORD PTR _iMovementRate$[esp+64], eax
	mov	DWORD PTR _iBestValue$[esp+64], 2147483647 ; 7fffffffH
	mov	DWORD PTR _pBestMovePlot$[esp+64], 0
	call	?GetFirstUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetFirstUnitTarget

; 9685 : 	while(pTarget != NULL)

	test	eax, eax
	je	$LN353@FindBestBa@2
$LN36@FindBestBa@2:

; 9686 : 	{
; 9687 : 		// Is this unit nearby enough?
; 9688 : 		if(plotDistance(pUnit->getX(), pUnit->getY(), pTarget->GetTargetX(), pTarget->GetTargetY()) < m_iSeaBarbarianRange)

	mov	edi, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _pUnit$[esp+60]
	mov	eax, DWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [ecx+76]
	push	edi
	push	esi
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR [ebx+24764]
	jge	$LN32@FindBestBa@2

; 9689 : 		{
; 9690 : 			pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	cmp	esi, -2147483647			; 80000001H
	je	$LN68@FindBestBa@2
	cmp	edi, -2147483647			; 80000001H
	je	$LN68@FindBestBa@2
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	al, al
	je	SHORT $LN78@FindBestBa@2
	test	esi, esi
	jge	SHORT $LN80@FindBestBa@2
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN78@FindBestBa@2
$LN80@FindBestBa@2:
	cmp	esi, ecx
	jl	SHORT $LN78@FindBestBa@2
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN78@FindBestBa@2:
	mov	al, BYTE PTR [ebx+4057]
	mov	ebp, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN88@FindBestBa@2
	test	edi, edi
	jge	SHORT $LN90@FindBestBa@2
	mov	eax, edi
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN92@FindBestBa@2
$LN90@FindBestBa@2:
	cmp	edi, ebp
	jl	SHORT $LN88@FindBestBa@2
	mov	eax, edi
	cdq
	idiv	ebp
	jmp	SHORT $LN92@FindBestBa@2
$LN88@FindBestBa@2:
	mov	edx, edi
$LN92@FindBestBa@2:
	test	esi, esi
	jl	SHORT $LN72@FindBestBa@2
	cmp	esi, ecx
	jge	SHORT $LN72@FindBestBa@2
	test	edx, edx
	jl	SHORT $LN72@FindBestBa@2
	cmp	edx, ebp
	jge	SHORT $LN72@FindBestBa@2
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	ebx, DWORD PTR _this$[esp+64]
	mov	esi, ecx
	jmp	SHORT $LN70@FindBestBa@2
$LN72@FindBestBa@2:
	mov	ebx, DWORD PTR _this$[esp+64]
$LN68@FindBestBa@2:
	xor	esi, esi
$LN70@FindBestBa@2:

; 9691 : 			if(pUnit->getArea() == pPlot->getArea())

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	mov	edi, DWORD PTR [esi+356]
	call	?getArea@CvUnit@@QBEHXZ			; CvUnit::getArea
	cmp	eax, edi
	jne	SHORT $LN32@FindBestBa@2

; 9692 : 			{
; 9693 : 				iValue = TurnsToReachTarget(pUnit, pPlot, true /*bReusePaths*/);

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	push	0
	push	0
	push	1
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _pUnit$[esp+88]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T254610[esp+88], esp
	test	eax, eax
	je	SHORT $LN113@FindBestBa@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN113@FindBestBa@2:
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 9694 : 				if(iValue < iBestValue)

	cmp	eax, DWORD PTR _iBestValue$[esp+64]
	jge	SHORT $LN32@FindBestBa@2

; 9695 : 				{
; 9696 : 					iBestValue = iValue;

	mov	DWORD PTR _iBestValue$[esp+64], eax

; 9697 : 					pBestMovePlot = pPlot;

	mov	DWORD PTR _pBestMovePlot$[esp+64], esi
$LN32@FindBestBa@2:

; 9698 : 				}
; 9699 : 			}
; 9700 : 		}
; 9701 : 		pTarget = GetNextUnitTarget();

	mov	ecx, ebx
	call	?GetNextUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextUnitTarget
	test	eax, eax
	jne	$LN36@FindBestBa@2

; 9702 : 	}
; 9703 : 
; 9704 : 	// move toward trade routes
; 9705 : 	if (pBestMovePlot == NULL)

	cmp	DWORD PTR _pBestMovePlot$[esp+64], eax
	jne	$LN14@FindBestBa@2
$LN353@FindBestBa@2:

; 9706 : 	{
; 9707 : 		pBestMovePlot = FindBarbarianGankTradeRouteTarget(pUnit);

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _pUnit$[esp+72]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T254611[esp+72], esp
	test	eax, eax
	je	SHORT $LN118@FindBestBa@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN118@FindBestBa@2:
	mov	ecx, ebx
	call	?FindBarbarianGankTradeRouteTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::FindBarbarianGankTradeRouteTarget
	mov	DWORD PTR _pBestMovePlot$[esp+64], eax

; 9708 : 	}
; 9709 : 
; 9710 : 	// No units to pick on, so sail to a tile adjacent to the second closest barbarian camp
; 9711 : 	if(pBestMovePlot == NULL)

	test	eax, eax
	jne	$LN14@FindBestBa@2

; 9712 : 	{
; 9713 : 		CvPlot* pNearestCamp = NULL;
; 9714 : 		int iBestCampDistance = MAX_INT;
; 9715 : 
; 9716 : 		// Start by finding the very nearest camp
; 9717 : 		pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_BARBARIAN_CAMP);

	mov	ecx, DWORD PTR _this$[esp+64]
	push	2
	mov	DWORD PTR _pNearestCamp$225421[esp+68], eax
	mov	ebp, 2147483647				; 7fffffffH
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget

; 9718 : 		while(pTarget != NULL)

	mov	ebx, DWORD PTR _pUnit$[esp+60]
	test	eax, eax
	je	$LN28@FindBestBa@2
	npad	1
$LL29@FindBestBa@2:

; 9719 : 		{
; 9720 : 			int iDistance = plotDistance(pUnit->getX(), pUnit->getY(), pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	edi, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ebx+88]
	mov	ecx, DWORD PTR [ebx+76]
	push	edi
	push	esi
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 9721 : 			if(iDistance < iBestCampDistance)

	cmp	eax, ebp
	mov	DWORD PTR _iDistance$225426[esp+64], eax
	jge	$LN27@FindBestBa@2

; 9722 : 			{
; 9723 : 				pNearestCamp = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	cmp	esi, -2147483647			; 80000001H
	je	$LN142@FindBestBa@2
	cmp	edi, -2147483647			; 80000001H
	je	$LN142@FindBestBa@2
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	al, al
	je	SHORT $LN152@FindBestBa@2
	test	esi, esi
	jge	SHORT $LN154@FindBestBa@2
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN152@FindBestBa@2
$LN154@FindBestBa@2:
	cmp	esi, ecx
	jl	SHORT $LN152@FindBestBa@2
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN152@FindBestBa@2:
	mov	al, BYTE PTR [ebx+4057]
	mov	ebp, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN162@FindBestBa@2
	test	edi, edi
	jge	SHORT $LN164@FindBestBa@2
	mov	eax, edi
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN166@FindBestBa@2
$LN164@FindBestBa@2:
	cmp	edi, ebp
	jl	SHORT $LN162@FindBestBa@2
	mov	eax, edi
	cdq
	idiv	ebp
	jmp	SHORT $LN166@FindBestBa@2
$LN162@FindBestBa@2:
	mov	edx, edi
$LN166@FindBestBa@2:
	test	esi, esi
	jl	SHORT $LN142@FindBestBa@2
	cmp	esi, ecx
	jge	SHORT $LN142@FindBestBa@2
	test	edx, edx
	jl	SHORT $LN142@FindBestBa@2
	cmp	edx, ebp
	jge	SHORT $LN142@FindBestBa@2
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	DWORD PTR _pNearestCamp$225421[esp+64], ecx
	jmp	SHORT $LN144@FindBestBa@2
$LN142@FindBestBa@2:
	mov	DWORD PTR _pNearestCamp$225421[esp+64], 0
$LN144@FindBestBa@2:

; 9724 : 				iBestCampDistance = iDistance;

	mov	ebp, DWORD PTR _iDistance$225426[esp+64]
	mov	ebx, DWORD PTR _pUnit$[esp+60]
$LN27@FindBestBa@2:

; 9725 : 			}
; 9726 : 			pTarget = GetNextZoneTarget();

	mov	ecx, DWORD PTR _this$[esp+64]
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	test	eax, eax
	jne	$LL29@FindBestBa@2
$LN28@FindBestBa@2:

; 9727 : 		}
; 9728 : 
; 9729 : 		// The obvious way to do this next part is to plot moves to each naval tile adjacent to each camp ...
; 9730 : 		// starting with the first camp and then proceeding to the final one.  But our optimization (to drop out
; 9731 : 		// targets that are further from the closest we've found so far) might in worst case not help at all if we
; 9732 : 		// check the closest camp last.  So instead we'll loop by DIRECTIONS first which should mean we pick up some plot
; 9733 : 		// from a close camp early (and the optimization will help)
; 9734 : 		for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	mov	DWORD PTR _jJ$225428[esp+64], 0
	npad	10
$LL26@FindBestBa@2:

; 9735 : 		{
; 9736 : 			pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_BARBARIAN_CAMP);

	mov	eax, DWORD PTR _this$[esp+64]
	cmp	DWORD PTR [eax+9340], 0
	mov	DWORD PTR [eax+24796], 2
	mov	DWORD PTR [eax+24800], 0
	jle	$LN25@FindBestBa@2
	mov	ecx, eax
	npad	9
$LL183@FindBestBa@2:
	mov	eax, DWORD PTR [ecx+24800]
	mov	esi, DWORD PTR [ecx+9336]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	cmp	DWORD PTR [esi+edx*4], 2
	je	SHORT $LN345@FindBestBa@2
	inc	eax
	mov	DWORD PTR [ecx+24800], eax
	mov	eax, DWORD PTR [ecx+9340]
	cmp	DWORD PTR [ecx+24800], eax
	jl	SHORT $LL183@FindBestBa@2
	jmp	$LN25@FindBestBa@2
$LN345@FindBestBa@2:
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, esi
	lea	eax, DWORD PTR [eax+edx*4]

; 9737 : 			while(pTarget != NULL)

	test	eax, eax
	je	$LN25@FindBestBa@2
	npad	5
$LL23@FindBestBa@2:

; 9738 : 			{
; 9739 : 				CvPlot* pCamp = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	ebp, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN200@FindBestBa@2
	cmp	ebp, -2147483647			; 80000001H
	je	SHORT $LN200@FindBestBa@2
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN210@FindBestBa@2
	test	eax, eax
	jge	SHORT $LN212@FindBestBa@2
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN214@FindBestBa@2
$LN212@FindBestBa@2:
	cmp	eax, ecx
	jl	SHORT $LN210@FindBestBa@2
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN214@FindBestBa@2
$LN210@FindBestBa@2:
	mov	esi, eax
$LN214@FindBestBa@2:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN220@FindBestBa@2
	test	ebp, ebp
	jge	SHORT $LN222@FindBestBa@2
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN224@FindBestBa@2
$LN222@FindBestBa@2:
	cmp	ebp, edi
	jl	SHORT $LN220@FindBestBa@2
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN224@FindBestBa@2
$LN220@FindBestBa@2:
	mov	edx, ebp
$LN224@FindBestBa@2:
	test	esi, esi
	jl	SHORT $LN200@FindBestBa@2
	cmp	esi, ecx
	jge	SHORT $LN200@FindBestBa@2
	test	edx, edx
	jl	SHORT $LN200@FindBestBa@2
	cmp	edx, edi
	jge	SHORT $LN200@FindBestBa@2
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	jmp	SHORT $LN202@FindBestBa@2
$LN200@FindBestBa@2:
	xor	ecx, ecx
$LN202@FindBestBa@2:

; 9740 : 				if(pCamp != pNearestCamp)

	cmp	ecx, DWORD PTR _pNearestCamp$225421[esp+64]
	je	$LN18@FindBestBa@2

; 9741 : 				{
; 9742 : 					pPlot = plotDirection(pCamp->getX(), pCamp->getY(), ((DirectionTypes)jJ));

	movsx	eax, WORD PTR [ecx+2]
	mov	edx, DWORD PTR _jJ$225428[esp+64]
	movsx	ecx, WORD PTR [ecx]
	push	edx
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 9743 : 					if(pPlot && pPlot->isWater())

	test	esi, esi
	je	SHORT $LN18@FindBestBa@2
	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN18@FindBestBa@2

; 9744 : 					{
; 9745 : 						int iDistance = plotDistance(pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	mov	edi, DWORD PTR _pUnit$[esp+60]
	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	edx
	movsx	edx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 9746 : 
; 9747 : 						// Optimization
; 9748 : 						if(iDistance < iMovementRate * iBestValue && iDistance < (m_iSeaBarbarianRange * 3))

	mov	ebx, DWORD PTR _iBestValue$[esp+80]
	mov	ecx, ebx
	imul	ecx, DWORD PTR _iMovementRate$[esp+80]
	add	esp, 16					; 00000010H
	cmp	eax, ecx
	jge	SHORT $LN18@FindBestBa@2
	mov	edx, DWORD PTR _this$[esp+64]
	mov	ecx, DWORD PTR [edx+24764]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	cmp	eax, ecx
	jge	SHORT $LN18@FindBestBa@2

; 9749 : 						{
; 9750 : 							iValue = TurnsToReachTarget(pUnit, pPlot, true /*bReusePaths*/);

	push	0
	push	0
	push	1
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	dl, BYTE PTR _pUnit$[esp+88]
	mov	BYTE PTR [eax+4], dl
	mov	eax, edi
	mov	DWORD PTR $T254612[esp+88], esp
	test	eax, eax
	je	SHORT $LN263@FindBestBa@2
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN263@FindBestBa@2:
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 9751 : 							if(iValue < iBestValue)

	cmp	eax, ebx
	jge	SHORT $LN18@FindBestBa@2

; 9752 : 							{
; 9753 : 								iBestValue = iValue;

	mov	DWORD PTR _iBestValue$[esp+64], eax

; 9754 : 								pBestMovePlot = pPlot;

	mov	DWORD PTR _pBestMovePlot$[esp+64], esi
$LN18@FindBestBa@2:

; 9755 : 							}
; 9756 : 						}
; 9757 : 					}
; 9758 : 				}
; 9759 : 				pTarget = GetNextZoneTarget();

	mov	ecx, DWORD PTR _this$[esp+64]
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	test	eax, eax
	jne	$LL23@FindBestBa@2
$LN25@FindBestBa@2:

; 9727 : 		}
; 9728 : 
; 9729 : 		// The obvious way to do this next part is to plot moves to each naval tile adjacent to each camp ...
; 9730 : 		// starting with the first camp and then proceeding to the final one.  But our optimization (to drop out
; 9731 : 		// targets that are further from the closest we've found so far) might in worst case not help at all if we
; 9732 : 		// check the closest camp last.  So instead we'll loop by DIRECTIONS first which should mean we pick up some plot
; 9733 : 		// from a close camp early (and the optimization will help)
; 9734 : 		for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	mov	eax, DWORD PTR _jJ$225428[esp+64]
	inc	eax
	cmp	eax, 6
	mov	DWORD PTR _jJ$225428[esp+64], eax
	jl	$LL26@FindBestBa@2

; 9760 : 			}
; 9761 : 		}
; 9762 : 	}
; 9763 : 
; 9764 : 	// No obvious target, let's scan nearby tiles for the best choice, borrowing some of the code from the explore AI
; 9765 : 	if(pBestMovePlot == NULL)

	cmp	DWORD PTR _pBestMovePlot$[esp+64], 0
	jne	$LN14@FindBestBa@2

; 9766 : 	{
; 9767 : 		// Now looking for BEST score
; 9768 : 		iBestValue = 0;
; 9769 : 		int iMovementRange = pUnit->movesLeft() / GC.getMOVE_DENOMINATOR();

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR _iBestValue$[esp+64], 0
	call	?movesLeft@CvUnit@@QBEHXZ		; CvUnit::movesLeft
	cdq
	idiv	esi

; 9770 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 9771 : 		int iMaxDX, iX;
; 9772 : 		CvPlot* pConsiderPlot;
; 9773 : 		for (int iY = -iMovementRange; iY <= iMovementRange; iY++)
; 9774 : 		{
; 9775 : 			iMaxDX = iMovementRange - MAX(0, iY);
; 9776 : 			for (iX = -iMovementRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 9777 : 			{
; 9778 : 				pConsiderPlot = plotXY(pUnit->getX(), pUnit->getY(), iX, iY);
; 9779 : #else
; 9780 : 		for(int iX = -iMovementRange; iX <= iMovementRange; iX++)

	mov	ebx, eax
	neg	ebx
	mov	edx, ebx
	cmp	edx, eax
	mov	DWORD PTR _iMovementRange$225444[esp+64], eax
	mov	DWORD PTR tv1001[esp+64], ebx
	mov	DWORD PTR _iX$225445[esp+64], edx
	jg	$LN14@FindBestBa@2
	mov	ebp, DWORD PTR _pUnit$[esp+60]
	mov	edi, edx
	neg	edi
	mov	DWORD PTR tv1398[esp+64], edi
	npad	7
$LL16@FindBestBa@2:

; 9781 : 		{
; 9782 : 			for(int iY = -iMovementRange; iY <= iMovementRange; iY++)

	cmp	ebx, DWORD PTR _iMovementRange$225444[esp+64]
	jg	$LN15@FindBestBa@2

; 9783 : 			{
; 9784 : 				CvPlot* pConsiderPlot = plotXYWithRangeCheck(pUnit->getX(), pUnit->getY(), iX, iY, iMovementRange);

	xor	eax, eax
	test	edx, edx
	setge	al
	mov	esi, ebx
	neg	esi
	mov	DWORD PTR tv1383[esp+64], esi
	mov	DWORD PTR tv1005[esp+64], eax
	npad	3
$LL13@FindBestBa@2:
	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	cmp	DWORD PTR tv1005[esp+64], ecx
	mov	ecx, edx
	jne	SHORT $LN283@FindBestBa@2
	test	edx, edx
	jge	SHORT $LN287@FindBestBa@2
	mov	ecx, edi
$LN287@FindBestBa@2:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN289@FindBestBa@2
	mov	eax, esi
$LN289@FindBestBa@2:
	add	eax, ecx
	jmp	SHORT $LN294@FindBestBa@2
$LN283@FindBestBa@2:
	test	edx, edx
	jge	SHORT $LN291@FindBestBa@2
	mov	ecx, edi
$LN291@FindBestBa@2:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN293@FindBestBa@2
	mov	eax, esi
$LN293@FindBestBa@2:
	cmp	ecx, eax
	jl	SHORT $LN294@FindBestBa@2
	mov	eax, ecx
$LN294@FindBestBa@2:
	cmp	eax, DWORD PTR _iMovementRange$225444[esp+64]
	jg	$LN12@FindBestBa@2
	mov	eax, DWORD PTR [ebp+88]
	push	ebx
	push	edx
	push	eax
	mov	eax, DWORD PTR [ebp+76]
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	esi, eax
	add	esp, 16					; 00000010H

; 9785 : #endif
; 9786 : 				if(!pConsiderPlot)

	test	esi, esi
	je	$LN12@FindBestBa@2

; 9787 : 				{
; 9788 : 					continue;
; 9789 : 				}
; 9790 : 
; 9791 : 				if(pUnit->atPlot(*pConsiderPlot))

	push	esi
	mov	ecx, ebp
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	test	al, al
	jne	$LN361@FindBestBa@2

; 9792 : 				{
; 9793 : 					continue;
; 9794 : 				}
; 9795 : 
; 9796 : 				if(!pConsiderPlot->isRevealed(pUnit->getTeam()))

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	edi, ecx
	mov	ecx, eax
	sub	ecx, edi
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [esi+edx*4+8]
	je	$LN361@FindBestBa@2

; 9797 : 				{
; 9798 : 					continue;
; 9799 : 				}
; 9800 : 
; 9801 : 				if(pConsiderPlot->area() != pUnit->area())

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	call	?area@CvUnit@@QBEPAVCvArea@@XZ		; CvUnit::area
	mov	ecx, esi
	mov	edi, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	eax, edi
	jne	$LN361@FindBestBa@2

; 9802 : 				{
; 9803 : 					continue;
; 9804 : 				}
; 9805 : 
; 9806 : 				if(!CanReachInXTurns(pUnit, pConsiderPlot, 1))

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	push	0
	push	0
	push	1
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _pUnit$[esp+88]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T254613[esp+88], esp
	test	eax, eax
	je	SHORT $LN309@FindBestBa@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN309@FindBestBa@2:
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	test	al, al
	je	$LN361@FindBestBa@2

; 9807 : 				{
; 9808 : 					continue;
; 9809 : 				}
; 9810 : 
; 9811 : 				// Value them based on their explore value
; 9812 : 				DomainTypes eDomain = pUnit->getDomainType();

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 9813 : 				iValue = CvEconomicAI::ScoreExplorePlot(pConsiderPlot, pUnit->getTeam(), pUnit->getUnitInfo().GetBaseSightRange(), eDomain);

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	push	eax
	mov	edi, ecx
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetBaseSightRange@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetBaseSightRange
	push	eax
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	push	esi
	call	?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z ; CvEconomicAI::ScoreExplorePlot
	add	esp, 16					; 00000010H

; 9814 : 
; 9815 : 				// Add special value for being near enemy lands
; 9816 : 				if(pConsiderPlot->isAdjacentOwned())

	mov	ecx, esi
	mov	edi, eax
	call	?isAdjacentOwned@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentOwned
	test	al, al
	je	SHORT $LN5@FindBestBa@2

; 9817 : 				{
; 9818 : 					iValue += 100;

	add	edi, 100				; 00000064H
	jmp	SHORT $LN3@FindBestBa@2
$LN5@FindBestBa@2:

; 9819 : 				}
; 9820 : 				else if(pConsiderPlot->isOwned())

	mov	ecx, esi
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	je	SHORT $LN3@FindBestBa@2

; 9821 : 				{
; 9822 : 					iValue += 200;

	add	edi, 200				; 000000c8H
$LN3@FindBestBa@2:

; 9823 : 				}
; 9824 : 
; 9825 : 				// If still have no value, score equal to distance from my current plot
; 9826 : 				if(iValue == 0)

	mov	ebp, DWORD PTR _pUnit$[esp+60]
	test	edi, edi
	jne	SHORT $LN2@FindBestBa@2

; 9827 : 				{
; 9828 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 9829 : 					iValue = hexDistance(iX, iY);
; 9830 : #else
; 9831 : 					iValue = plotDistance(pUnit->getX(), pUnit->getY(), pConsiderPlot->getX(), pConsiderPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	mov	eax, DWORD PTR [ebp+88]
	mov	ecx, DWORD PTR [ebp+76]
	push	edx
	movsx	edx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	edi, eax
$LN2@FindBestBa@2:

; 9832 : #endif
; 9833 : 				}
; 9834 : 
; 9835 : 				if(iValue > iBestValue)

	cmp	edi, DWORD PTR _iBestValue$[esp+64]
	jle	SHORT $LN12@FindBestBa@2

; 9836 : 				{
; 9837 : 					pBestMovePlot = pConsiderPlot;

	mov	DWORD PTR _pBestMovePlot$[esp+64], esi

; 9838 : 					iBestValue = iValue;

	mov	DWORD PTR _iBestValue$[esp+64], edi
	jmp	SHORT $LN12@FindBestBa@2
$LN361@FindBestBa@2:
	mov	ebp, DWORD PTR _pUnit$[esp+60]
$LN12@FindBestBa@2:

; 9781 : 		{
; 9782 : 			for(int iY = -iMovementRange; iY <= iMovementRange; iY++)

	mov	esi, DWORD PTR tv1383[esp+64]
	mov	edi, DWORD PTR tv1398[esp+64]
	mov	edx, DWORD PTR _iX$225445[esp+64]
	inc	ebx
	dec	esi
	cmp	ebx, DWORD PTR _iMovementRange$225444[esp+64]
	mov	DWORD PTR tv1383[esp+64], esi
	jle	$LL13@FindBestBa@2
	mov	ebx, DWORD PTR tv1001[esp+64]
$LN15@FindBestBa@2:

; 9770 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 9771 : 		int iMaxDX, iX;
; 9772 : 		CvPlot* pConsiderPlot;
; 9773 : 		for (int iY = -iMovementRange; iY <= iMovementRange; iY++)
; 9774 : 		{
; 9775 : 			iMaxDX = iMovementRange - MAX(0, iY);
; 9776 : 			for (iX = -iMovementRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 9777 : 			{
; 9778 : 				pConsiderPlot = plotXY(pUnit->getX(), pUnit->getY(), iX, iY);
; 9779 : #else
; 9780 : 		for(int iX = -iMovementRange; iX <= iMovementRange; iX++)

	inc	edx
	dec	edi
	cmp	edx, DWORD PTR _iMovementRange$225444[esp+64]
	mov	DWORD PTR _iX$225445[esp+64], edx
	mov	DWORD PTR tv1398[esp+64], edi
	jle	$LL16@FindBestBa@2
$LN14@FindBestBa@2:

; 9839 : 				}
; 9840 : 			}
; 9841 : 		}
; 9842 : 	}
; 9843 : 
; 9844 : 	return pBestMovePlot;

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	test	ecx, ecx
	je	SHORT $LN357@FindBestBa@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN357@FindBestBa@2:

; 9845 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	mov	eax, DWORD PTR _pBestMovePlot$[esp+64]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 48					; 00000030H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvTacticalAI::FindBestBarbarianSeaMove
PUBLIC	?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z ; CvTacticalAI::ScoreGreatGeneralPlot
EXTRN	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z:PROC ; CvArmyAI::GetCenterOfMass
EXTRN	?GetID@CvArmyAI@@QAEHXZ:PROC			; CvArmyAI::GetID
EXTRN	?getArmyID@CvUnit@@QBEHXZ:PROC			; CvUnit::getArmyID
EXTRN	?getMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::getMoves
EXTRN	?isRanged@CvUnit@@QBE_NXZ:PROC			; CvUnit::isRanged
EXTRN	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ:PROC ; CvUnit::GetBaseCombatStrengthConsideringDamage
EXTRN	?GetMaxHitPoints@CvCity@@QBEHXZ:PROC		; CvCity::GetMaxHitPoints
EXTRN	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z:PROC	; CvPlayer::GetPlotDanger
EXTRN	?hasMoved@CvUnit@@QBE_NXZ:PROC			; CvUnit::hasMoved
EXTRN	?IsCanAttack@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttack
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z$2
__ehfuncinfo$?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
_bFriendlyCity$ = -49					; size = 1
_iDangerDivisor$ = -48					; size = 4
_iFriendlyUnitFinalPower$ = -44				; size = 4
tv548 = -40						; size = 4
_this$ = -40						; size = 4
_iFriendlyCityStrength$ = -36				; size = 4
_iDistToOperationCenter$ = -32				; size = 4
_pBestDefender$ = -28					; size = 8
$T255322 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pGeneral$ = 8						; size = 8
_iDangerValue$ = 16					; size = 4
_pTarget$ = 16						; size = 4
_pArmyAI$ = 20						; size = 4
?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z PROC ; CvTacticalAI::ScoreGreatGeneralPlot, COMDAT
; _this$ = ecx

; 11269: {

	push	-1
	push	__ehhandler$?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR _this$[esp+68], ebx
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+76], esi

; 11270: 	// Returned value
; 11271: 	int iScore = 0;
; 11272: 
; 11273: 	UnitHandle pBestDefender;

	mov	DWORD PTR _pBestDefender$[esp+68], esi
	mov	BYTE PTR _pBestDefender$[esp+72], 0

; 11274: 	PlayerTypes ePlayer = m_pPlayer->GetID();

	mov	eax, DWORD PTR [ebx]

; 11275: 
; 11276: 	// Variables going into score
; 11277: 	bool bFriendlyCity = false;
; 11278: 	int iNearbyQueuedAttacks = 0;
; 11279: 	int iDangerValue = 0;
; 11280: 	int iDangerDivisor = 1;
; 11281: 	int iDistToOperationCenter = MAX_INT;
; 11282: 	int iFriendlyUnitBasePower = 0;
; 11283: 	int iFriendlyUnitFinalPower = 0;
; 11284: 	int iFriendlyCityStrength = 0;
; 11285: 
; 11286: 	// GATHER DATA
; 11287: 
; 11288: 	// Non-friendly city here?
; 11289: 	if(pTarget->isCity() && pTarget->getOwner() != ePlayer)

	mov	ebp, DWORD PTR _pTarget$[esp+64]
	mov	edi, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ebp+104]
	cmp	eax, esi
	mov	BYTE PTR __$EHRec$[esp+76], 1
	mov	BYTE PTR _bFriendlyCity$[esp+68], 0
	mov	DWORD PTR _iDangerDivisor$[esp+68], 1
	mov	DWORD PTR _iDistToOperationCenter$[esp+68], 2147483647 ; 7fffffffH
	mov	DWORD PTR _iFriendlyUnitFinalPower$[esp+68], esi
	mov	DWORD PTR _iFriendlyCityStrength$[esp+68], esi
	jl	SHORT $LN35@ScoreGreat
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN35@ScoreGreat
	mov	ecx, DWORD PTR [ebp+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN35@ScoreGreat
	movsx	edx, BYTE PTR [ebp+4]
	cmp	edx, edi
	je	SHORT $LN35@ScoreGreat

; 11290: 	{
; 11291: 		return 0;

	mov	ecx, DWORD PTR _pGeneral$[esp+64]
	mov	DWORD PTR __$EHRec$[esp+76], -1
	cmp	ecx, esi
	je	SHORT $LN62@ScoreGreat
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN62@ScoreGreat:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 11443: }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	16					; 00000010H
$LN35@ScoreGreat:

; 11292: 	}
; 11293: 
; 11294: 	// Another player's unit here?
; 11295: 	CvUnit* pUnit = pTarget->getUnitByIndex(0);

	push	esi
	mov	ecx, ebp
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	esi, eax

; 11296: 	if(pUnit && pUnit->getOwner() != ePlayer)

	test	esi, esi
	je	SHORT $LN32@ScoreGreat

; 11297: 	{
; 11298: 		return 0;

	mov	ecx, DWORD PTR _pGeneral$[esp+64]
	cmp	DWORD PTR [esi+40], edi
	je	SHORT $LN34@ScoreGreat
	mov	DWORD PTR __$EHRec$[esp+76], -1
	test	ecx, ecx
	je	SHORT $LN62@ScoreGreat
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 11443: }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	16					; 00000010H
$LN34@ScoreGreat:

; 11299: 	}
; 11300: 
; 11301: 	// Another civilian of mine that has finished its moves?
; 11302: 	else if (pUnit && pUnit->GetID() != pGeneral->GetID() && !pUnit->IsCanAttack() && pUnit->hasMoved())

	mov	eax, DWORD PTR [esi+100]
	cmp	eax, DWORD PTR [ecx+100]
	je	SHORT $LN32@ScoreGreat
	mov	ecx, esi
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	test	al, al
	jne	SHORT $LN32@ScoreGreat
	mov	ecx, esi
	call	?hasMoved@CvUnit@@QBE_NXZ		; CvUnit::hasMoved
	test	al, al
	je	SHORT $LN32@ScoreGreat

; 11303: 	{
; 11304: 		return 0;

	mov	ecx, DWORD PTR _pGeneral$[esp+64]
	mov	DWORD PTR __$EHRec$[esp+76], -1
	test	ecx, ecx
	je	$LN62@ScoreGreat
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 11443: }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	16					; 00000010H
$LN32@ScoreGreat:

; 11305: 	}
; 11306: 
; 11307: 	// Danger value
; 11308: 	iDangerValue = m_pPlayer->GetPlotDanger(*pTarget);

	mov	ecx, DWORD PTR [ebx]
	push	ebp
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger

; 11309: 	pBestDefender = pTarget->getBestDefender(m_pPlayer->GetID());

	mov	edx, DWORD PTR [ebx]
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	DWORD PTR _iDangerValue$[esp+84], eax
	mov	eax, DWORD PTR [edx+44]
	push	-1
	push	eax
	lea	eax, DWORD PTR $T255322[esp+96]
	push	eax
	mov	ecx, ebp
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	lea	ecx, DWORD PTR _pBestDefender$[esp+68]
	mov	BYTE PTR __$EHRec$[esp+76], 2
	cmp	eax, ecx
	je	SHORT $LN172@ScoreGreat
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pBestDefender$[esp+68], eax
	test	eax, eax
	je	SHORT $LN172@ScoreGreat
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN172@ScoreGreat:
	mov	ecx, DWORD PTR $T255322[esp+68]
	mov	BYTE PTR __$EHRec$[esp+76], 1
	test	ecx, ecx
	je	SHORT $LN114@ScoreGreat
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN114@ScoreGreat:

; 11310: 
; 11311: 	// Friendly city here?
; 11312: 	if(pTarget->isCity())

	mov	eax, DWORD PTR [ebp+104]
	test	eax, eax
	jl	$LN31@ScoreGreat
	cmp	eax, 64					; 00000040H
	jge	$LN31@ScoreGreat
	mov	edx, DWORD PTR [ebp+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	$LN31@ScoreGreat

; 11313: 	{
; 11314: 		bFriendlyCity = true;
; 11315: 		CvCity* pCity = pTarget->getPlotCity();

	mov	eax, DWORD PTR [ebp+104]
	mov	BYTE PTR _bFriendlyCity$[esp+68], 1
	test	eax, eax
	jl	SHORT $LN121@ScoreGreat
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN121@ScoreGreat
	mov	ecx, DWORD PTR [ebp+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax
	jmp	SHORT $LN122@ScoreGreat
$LN121@ScoreGreat:
	xor	edi, edi
$LN122@ScoreGreat:

; 11316: 
; 11317: 		iFriendlyCityStrength = pCity->getStrengthValue() * 100;

	push	0
	mov	ecx, edi
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	mov	ebx, eax

; 11318: 		iFriendlyCityStrength *= (pCity->GetMaxHitPoints() - pCity->getDamage());

	mov	ecx, edi
	imul	ebx, 100				; 00000064H
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, edi
	mov	esi, eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	sub	esi, eax

; 11319: 		iFriendlyCityStrength /= pCity->GetMaxHitPoints();

	mov	ecx, edi
	imul	esi, ebx
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx

; 11320: 
; 11321: 		if(iDangerValue > (iFriendlyCityStrength * 2))

	mov	ecx, DWORD PTR _iDangerValue$[esp+64]

; 11322: 		{
; 11323: 			iDangerDivisor = 5;

	mov	ebx, DWORD PTR _this$[esp+68]
	mov	edi, DWORD PTR _pBestDefender$[esp+68]
	mov	esi, eax
	lea	edx, DWORD PTR [esi+esi]
	cmp	ecx, edx
	jle	SHORT $LN30@ScoreGreat
	mov	DWORD PTR _iDangerDivisor$[esp+68], 5
	jmp	$LN170@ScoreGreat
$LN30@ScoreGreat:

; 11324: 		}
; 11325: 		else if(iDangerValue > iFriendlyCityStrength)

	cmp	ecx, esi
	jle	SHORT $LN28@ScoreGreat

; 11326: 		{
; 11327: 			iDangerDivisor = 3;

	mov	DWORD PTR _iDangerDivisor$[esp+68], 3
	jmp	$LN170@ScoreGreat
$LN28@ScoreGreat:

; 11328: 		}
; 11329: 		else if(iDangerValue > (iFriendlyCityStrength / 2))

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jle	$LN170@ScoreGreat

; 11330: 		{
; 11331: 			iDangerDivisor = 2;

	mov	DWORD PTR _iDangerDivisor$[esp+68], 2

; 11332: 		}
; 11333: 	}

	jmp	$LN170@ScoreGreat
$LN31@ScoreGreat:

; 11334: 
; 11335: 	// Friendly unit here?
; 11336: 	else if(pBestDefender && pBestDefender->GetID() != pGeneral->GetID())

	mov	edi, DWORD PTR _pBestDefender$[esp+68]
	test	edi, edi
	je	$LN24@ScoreGreat
	mov	eax, DWORD PTR [edi+100]
	mov	ecx, DWORD PTR _pGeneral$[esp+64]
	cmp	eax, DWORD PTR [ecx+100]
	je	$LN24@ScoreGreat

; 11337: 	{
; 11338: 		iFriendlyUnitBasePower = pBestDefender->GetBaseCombatStrengthConsideringDamage() * 250;

	mov	ecx, edi
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage

; 11339: 
; 11340: 		if(iDangerValue > (iFriendlyUnitBasePower * 2))

	mov	ecx, DWORD PTR _iDangerValue$[esp+64]
	mov	esi, eax
	imul	esi, 250				; 000000faH
	lea	edx, DWORD PTR [esi+esi]
	cmp	ecx, edx
	jle	SHORT $LN23@ScoreGreat

; 11341: 		{
; 11342: 			iDangerDivisor = 5;

	mov	DWORD PTR _iDangerDivisor$[esp+68], 5
	jmp	SHORT $LN19@ScoreGreat
$LN23@ScoreGreat:

; 11343: 		}
; 11344: 		else if(iDangerValue > iFriendlyUnitBasePower)

	cmp	ecx, esi
	jle	SHORT $LN21@ScoreGreat

; 11345: 		{
; 11346: 			iDangerDivisor = 3;

	mov	DWORD PTR _iDangerDivisor$[esp+68], 3
	jmp	SHORT $LN19@ScoreGreat
$LN21@ScoreGreat:

; 11347: 		}
; 11348: 		else if(iDangerValue > (iFriendlyUnitBasePower / 2))

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN19@ScoreGreat

; 11349: 		{
; 11350: 			iDangerDivisor = 2;

	mov	DWORD PTR _iDangerDivisor$[esp+68], 2
$LN19@ScoreGreat:

; 11351: 		}
; 11352: 
; 11353: 		iFriendlyUnitFinalPower = iFriendlyUnitBasePower;
; 11354: 
; 11355: 		// Deemphasize if hasn't finished moves yet
; 11356: 		if(IsInQueuedAttack(pBestDefender.pointer()) && !pBestDefender->isRanged())

	push	edi
	mov	ecx, ebx
	mov	DWORD PTR _iFriendlyUnitFinalPower$[esp+72], esi
	call	?IsInQueuedAttack@CvTacticalAI@@QAE_NPBVCvUnit@@@Z ; CvTacticalAI::IsInQueuedAttack
	test	al, al
	je	SHORT $LN18@ScoreGreat
	mov	ecx, edi
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	test	al, al
	jne	SHORT $LN18@ScoreGreat

; 11357: 		{
; 11358: 			// Melee unit: might take losses attacking, so reduce the desirability
; 11359: 			iFriendlyUnitFinalPower /= 3;

	mov	eax, 1431655766				; 55555556H
	imul	esi
	jmp	SHORT $LN181@ScoreGreat
$LN18@ScoreGreat:

; 11360: 		}
; 11361: 
; 11362: 		else if(pBestDefender->getMoves() > 0)

	mov	ecx, edi
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jle	SHORT $LN16@ScoreGreat

; 11363: 		{
; 11364: 			// Could move anywhere, not a good place to go
; 11365: 			iFriendlyUnitFinalPower /= 25;

	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 3
$LN181@ScoreGreat:
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iFriendlyUnitFinalPower$[esp+68], eax
$LN16@ScoreGreat:

; 11366: 		}
; 11367: 
; 11368: 		// Emphasize member of this operation
; 11369: 		if(pArmyAI && (pBestDefender->getArmyID() != -1) &&(pBestDefender->getArmyID() == pArmyAI->GetID()))

	mov	esi, DWORD PTR _pArmyAI$[esp+64]
	test	esi, esi
	je	SHORT $LN174@ScoreGreat
	mov	ecx, edi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN177@ScoreGreat
	mov	ecx, edi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	mov	ecx, esi
	mov	DWORD PTR tv548[esp+68], eax
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	ecx, DWORD PTR tv548[esp+68]
	cmp	ecx, eax
	jne	SHORT $LN177@ScoreGreat

; 11370: 		{
; 11371: 			iFriendlyUnitFinalPower *= 5;

	mov	eax, DWORD PTR _iFriendlyUnitFinalPower$[esp+68]
	lea	eax, DWORD PTR [eax+eax*4]
	mov	DWORD PTR _iFriendlyUnitFinalPower$[esp+68], eax

; 11372: 		}
; 11373: 	}
; 11374: 
; 11375: 	// No friendly city or unit
; 11376: 	else

	jmp	SHORT $LN177@ScoreGreat
$LN24@ScoreGreat:

; 11377: 	{	
; 11378: 		iDangerDivisor = 1000;

	mov	DWORD PTR _iDangerDivisor$[esp+68], 1000 ; 000003e8H
$LN177@ScoreGreat:
	mov	esi, DWORD PTR _iFriendlyCityStrength$[esp+68]
$LN170@ScoreGreat:

; 11379: 	}
; 11380: 
; 11381: 	// Distance to center of army (if still under operational AI)
; 11382: 	if(pArmyAI)

	mov	ecx, DWORD PTR _pArmyAI$[esp+64]
	test	ecx, ecx
	je	SHORT $LN171@ScoreGreat

; 11383: 	{
; 11384: 		CvPlot* pCOM = pArmyAI->GetCenterOfMass(NO_DOMAIN);

	push	-1
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass

; 11385: 		if(pCOM)

	test	eax, eax
	je	SHORT $LN171@ScoreGreat

; 11386: 		{
; 11387: 			iDistToOperationCenter = plotDistance(pTarget->getX(), pTarget->getY(), pCOM->getX(), pCOM->getY());

	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	movsx	eax, WORD PTR [ebp+2]
	push	ecx
	movsx	ecx, WORD PTR [ebp]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistToOperationCenter$[esp+68], eax
	jmp	SHORT $LN171@ScoreGreat
$LN174@ScoreGreat:
	mov	esi, DWORD PTR _iFriendlyCityStrength$[esp+68]
$LN171@ScoreGreat:

; 11388: 		}
; 11389: 	}
; 11390: 
; 11391: 	// Near an attack we already have planned?
; 11392: 	iNearbyQueuedAttacks = NearXQueuedAttacks(pTarget, 2);

	push	2
	push	ebp
	mov	ecx, ebx
	call	?NearXQueuedAttacks@CvTacticalAI@@QAEHPBVCvPlot@@H@Z ; CvTacticalAI::NearXQueuedAttacks

; 11393: 
; 11394: 	// COMPUTE SCORE
; 11395: 	//  Entering a city
; 11396: 	if(bFriendlyCity)

	mov	cl, BYTE PTR _bFriendlyCity$[esp+68]
	test	cl, cl
	je	SHORT $LN11@ScoreGreat

; 11397: 	{
; 11398: 		iScore = iFriendlyCityStrength;
; 11399: 
; 11400: 		// If part of an army moving to target, don't hide in a city
; 11401: 		if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$[esp+64], 0
	je	SHORT $LN176@ScoreGreat

; 11402: 		{
; 11403: 			iScore = 1000;

	mov	esi, 1000				; 000003e8H

; 11404: 		}
; 11405: 	}

	jmp	SHORT $LN176@ScoreGreat
$LN11@ScoreGreat:

; 11406: 	// Stacking with a unit
; 11407: 	else if(iFriendlyUnitFinalPower > 0)

	mov	esi, DWORD PTR _iFriendlyUnitFinalPower$[esp+68]
	test	esi, esi

; 11408: 	{
; 11409: 		iScore = iFriendlyUnitFinalPower;
; 11410: 	}
; 11411: 	// Moving to an empty tile
; 11412: 	else

	jg	SHORT $LN176@ScoreGreat

; 11413: 	{
; 11414: 		iScore = 10;

	mov	esi, 10					; 0000000aH
$LN176@ScoreGreat:

; 11415: 	}
; 11416: 
; 11417: 	if(iNearbyQueuedAttacks > 0)

	test	eax, eax
	jle	SHORT $LN6@ScoreGreat

; 11418: 	{
; 11419: 		iScore *= (5 * iNearbyQueuedAttacks);

	imul	eax, esi
	lea	esi, DWORD PTR [eax+eax*4]
$LN6@ScoreGreat:

; 11420: 	}
; 11421: 
; 11422: 	if(iDistToOperationCenter < 20 && (iFriendlyUnitFinalPower > 0 || bFriendlyCity || iDangerValue == 0))

	mov	eax, DWORD PTR _iDistToOperationCenter$[esp+68]
	cmp	eax, 20					; 00000014H
	jge	SHORT $LN179@ScoreGreat
	cmp	DWORD PTR _iFriendlyUnitFinalPower$[esp+68], 0
	jg	SHORT $LN178@ScoreGreat
	test	cl, cl
	jne	SHORT $LN178@ScoreGreat
	cmp	DWORD PTR _iDangerValue$[esp+64], 0
	jne	SHORT $LN182@ScoreGreat
$LN178@ScoreGreat:

; 11423: 	{
; 11424: 		// Anywhere near center is really good
; 11425: 		if(iDistToOperationCenter <= 3)

	cmp	eax, 3
	jg	SHORT $LN3@ScoreGreat

; 11426: 		{
; 11427: 			iScore += 5000000;

	add	esi, 5000000				; 004c4b40H

; 11428: 		}
; 11429: 
; 11430: 		// Sliding scale further off
; 11431: 		else

	jmp	SHORT $LN179@ScoreGreat
$LN3@ScoreGreat:

; 11432: 		{
; 11433: 			iScore += (250000 * (20 - iDistToOperationCenter));

	mov	edx, 20					; 00000014H
	sub	edx, eax
	imul	edx, 250000				; 0003d090H
	add	esi, edx
$LN179@ScoreGreat:

; 11434: 		}
; 11435: 	}
; 11436: 
; 11437: 	if(iDangerValue > 0)

	cmp	DWORD PTR _iDangerValue$[esp+64], 0
$LN182@ScoreGreat:
	jle	SHORT $LN1@ScoreGreat

; 11438: 	{
; 11439: 		iScore /= iDangerDivisor;

	mov	eax, esi
	cdq
	idiv	DWORD PTR _iDangerDivisor$[esp+68]
	mov	esi, eax
$LN1@ScoreGreat:

; 11440: 	}
; 11441: 
; 11442: 	return iScore;

	mov	BYTE PTR __$EHRec$[esp+76], 0
	test	edi, edi
	je	SHORT $LN163@ScoreGreat
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN163@ScoreGreat:
	mov	ecx, DWORD PTR _pGeneral$[esp+64]
	mov	DWORD PTR __$EHRec$[esp+76], -1
	test	ecx, ecx
	je	SHORT $LN168@ScoreGreat
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN168@ScoreGreat:

; 11443: }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _pGeneral$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z$1:
	lea	ecx, DWORD PTR _pBestDefender$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z$2:
	lea	ecx, DWORD PTR $T255322[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z ENDP ; CvTacticalAI::ScoreGreatGeneralPlot
PUBLIC	??0?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
_TEXT	ENDS
PUBLIC	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val_arg$ = 8						; size = 4
?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::list<int,std::allocator<int> >::remove, COMDAT
; _this$ = ecx

; 928  : 		/* Dinkumware makes a copy of _Val_arg in case it's removed along the way, i.e.
; 929  : 		 * when the user pass an element of the list as _Val_arg.
; 930  : 		 *
; 931  : 		 * We believe that the signature of std::list::remove should be changed
; 932  : 		 * from remove(const _Ty&) to remove(_Ty) to explicitly indicate that a copy is involved.
; 933  : 		 */
; 934  : 		const _Ty _Val = _Val_arg;	// in case it's removed along the way

	mov	eax, DWORD PTR __Val_arg$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR [eax]
	push	esi
	mov	esi, ecx

; 935  : 		iterator _Last = end();

	mov	ebx, DWORD PTR [esi+4]

; 936  : 		for (iterator _First = begin(); _First != _Last; )

	mov	eax, DWORD PTR [ebx]
	cmp	eax, ebx
	je	SHORT $LN3@remove
	push	edi
$LL4@remove:

; 937  : 			if (*_First == _Val)

	cmp	DWORD PTR [eax+8], ebp
	jne	SHORT $LN2@remove

; 938  : 				_First = erase(_First);

	mov	edi, DWORD PTR [eax]
	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN31@remove
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edi
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	push	eax
	mov	DWORD PTR [edx+4], ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	dec	DWORD PTR [esi+8]
$LN31@remove:
	mov	eax, edi

; 939  : 			else

	jmp	SHORT $LN64@remove
$LN2@remove:

; 940  : 				++_First;

	mov	eax, DWORD PTR [eax]
$LN64@remove:

; 936  : 		for (iterator _First = begin(); _First != _Last; )

	cmp	eax, ebx
	jne	SHORT $LL4@remove
	pop	edi
$LN3@remove:
	pop	esi
	pop	ebp
	pop	ebx

; 941  : 		}

	ret	4
?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::list<int,std::allocator<int> >::remove
_TEXT	ENDS
PUBLIC	??0?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??0?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::vector<CvTacticalCity,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::vector<CvTacticalCity,std::allocator<CvTacticalCity> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::vector<CvTacticalCity,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAEIABVCvTacticalMove@@@Z ; FStaticVector<CvTacticalMove,256,1,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAEIABVCvTacticalMove@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAEIABVCvTacticalMove@@@Z PROC ; FStaticVector<CvTacticalMove,256,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+2060], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalMove,256,1,297,0>::GrowSize
$LN1@push_back@2:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@2
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAEIABVCvTacticalMove@@@Z ENDP ; FStaticVector<CvTacticalMove,256,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?erase@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?erase@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::erase, COMDAT
; _this$ = ecx

; 787  : 
; 788  :  #if _HAS_ITERATOR_DEBUGGING
; 789  : 		if (_Where._Mycont != this || _Where._Ptr == _Myhead)
; 790  : 			_DEBUG_ERROR("list erase iterator outside range");
; 791  : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 792  : 		_Orphan_ptr(*this, _Pnode);
; 793  : 
; 794  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 795  : 		_Nodeptr _Pnode = (_Where++)._Mynode();

	mov	eax, DWORD PTR __Where$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Where$[esp], ecx

; 796  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 797  : 
; 798  : 		if (_Pnode != _Myhead)

	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN32@erase@2

; 799  : 			{	// not list head, safe to erase
; 800  : 			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 801  : 			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 802  : 			this->_Alnod.destroy(_Pnode);
; 803  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	eax
	mov	DWORD PTR [ecx+4], edx
	call	??3@YAXPAX@Z				; operator delete

; 804  : 			--_Mysize;
; 805  : 			}
; 806  : 		return (_Make_iter(_Where));

	mov	ecx, DWORD PTR __Where$[esp+4]
	add	esp, 4
	dec	DWORD PTR [esi+8]
$LN32@erase@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 807  : 		}

	ret	8
?erase@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::erase
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAEIABVCvTacticalTarget@@@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAEIABVCvTacticalTarget@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAEIABVCvTacticalTarget@@@Z PROC ; FStaticVector<CvTacticalTarget,256,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebx
	mov	ebx, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [ebx+8]
	push	edi
	mov	BYTE PTR [ebx+7180], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN1@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::GrowSize
$LN1@push_back@3:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edi, DWORD PTR [edx+ecx*4]
	test	edi, edi
	je	SHORT $LN4@push_back@3
	push	esi
	mov	esi, DWORD PTR _element$[esp+8]
	mov	ecx, 7
	rep movsd
	pop	esi
$LN4@push_back@3:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [ebx+4], ecx
	pop	ebx

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAEIABVCvTacticalTarget@@@Z ENDP ; FStaticVector<CvTacticalTarget,256,0,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAEIABVCvTacticalTarget@@@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAEIABVCvTacticalTarget@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAEIABVCvTacticalTarget@@@Z PROC ; FStaticVector<CvTacticalTarget,37,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebx
	mov	ebx, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [ebx+8]
	push	edi
	mov	BYTE PTR [ebx+1048], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN1@push_back@4

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::GrowSize
$LN1@push_back@4:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edi, DWORD PTR [edx+ecx*4]
	test	edi, edi
	je	SHORT $LN4@push_back@4
	push	esi
	mov	esi, DWORD PTR _element$[esp+8]
	mov	ecx, 7
	rep movsd
	pop	esi
$LN4@push_back@4:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [ebx+4], ecx
	pop	ebx

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAEIABVCvTacticalTarget@@@Z ENDP ; FStaticVector<CvTacticalTarget,37,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvTacticalPosture@@@Z ; FStaticVector<CvTacticalPosture,64,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvTacticalPosture@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvTacticalPosture@@@Z PROC ; FStaticVector<CvTacticalPosture,64,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+780], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@5

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalPosture,64,1,297,0>::GrowSize
$LN1@push_back@5:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@5
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN4@push_back@5:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvTacticalPosture@@@Z ENDP ; FStaticVector<CvTacticalPosture,64,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEIABVCvTemporaryZone@@@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEIABVCvTemporaryZone@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEIABVCvTemporaryZone@@@Z PROC ; FStaticVector<CvTemporaryZone,10,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+212], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@6

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::GrowSize
$LN1@push_back@6:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@6
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
$LN4@push_back@6:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEIABVCvTemporaryZone@@@Z ENDP ; FStaticVector<CvTemporaryZone,10,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAEIABVCvBlockingUnit@@@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAEIABVCvBlockingUnit@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAEIABVCvBlockingUnit@@@Z PROC ; FStaticVector<CvBlockingUnit,25,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+412], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@7

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
$LN1@push_back@7:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN4@push_back@7
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN4@push_back@7:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAEIABVCvBlockingUnit@@@Z ENDP ; FStaticVector<CvBlockingUnit,25,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvOperationUnit@@@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvOperationUnit@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvOperationUnit@@@Z PROC ; FStaticVector<CvOperationUnit,20,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+172], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@8

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::GrowSize
$LN1@push_back@8:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@8
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@8:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvOperationUnit@@@Z ENDP ; FStaticVector<CvOperationUnit,20,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::erase, COMDAT
; _this$ = ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	edx, DWORD PTR __Where$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [edx+4]
	sub	eax, ecx
	sar	eax, 2
	test	eax, eax
	jle	SHORT $LN9@erase@3
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove_s
	mov	edx, DWORD PTR __Where$[esp+16]
	add	esp, 16					; 00000010H
$LN9@erase@3:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);
; 1021 : 		--_Mylast;
; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	add	DWORD PTR [esi+8], -4			; fffffffcH
	mov	DWORD PTR [eax], edx
	pop	esi

; 1023 : 		}

	ret	8
?erase@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::erase
_TEXT	ENDS
PUBLIC	?push_back@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAEIABVCvTacticalTarget@@@Z ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAEIABVCvTacticalTarget@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAEIABVCvTacticalTarget@@@Z PROC ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebx
	mov	ebx, ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [ebx+8]
	push	edi
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN1@push_back@9

; 378  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEXI@Z ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::GrowSize
$LN1@push_back@9:

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edi, DWORD PTR [edx+ecx*4]
	test	edi, edi
	je	SHORT $LN4@push_back@9
	push	esi
	mov	esi, DWORD PTR _element$[esp+8]
	mov	ecx, 7
	rep movsd
	pop	esi
$LN4@push_back@9:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [ebx+4], ecx
	pop	ebx

; 381  : 	};

	ret	4
?push_back@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAEIABVCvTacticalTarget@@@Z ENDP ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ	; CvWeightedVector<CvPlot *,1,1>::CvWeightedVector<CvPlot *,1,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ PROC	; CvWeightedVector<CvPlot *,1,1>::CvWeightedVector<CvPlot *,1,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 1
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ENDP	; CvWeightedVector<CvPlot *,1,1>::CvWeightedVector<CvPlot *,1,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ	; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ PROC	; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ENDP	; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>
_TEXT	ENDS
PUBLIC	??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_List_val<int,std::allocator<int> >::~_List_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_List_val<int,std::allocator<int> >::~_List_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_List_val<int,std::allocator<int> >::~_List_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1?$_List_val@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ; std::_List_val<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~_List_val<CvQueuedAttack,std::allocator<CvQueuedAttack> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_List_val@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_val@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ PROC ; std::_List_val<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~_List_val<CvQueuedAttack,std::allocator<CvQueuedAttack> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_List_val@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~_List_val<CvQueuedAttack,std::allocator<CvQueuedAttack> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@0@Z ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@0@Z PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@4
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@4:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@4:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@2@0@Z ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z ; std::list<int,std::allocator<int> >::_Insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z PROC ; std::list<int,std::allocator<int> >::_Insert, COMDAT
; _this$ = ecx

; 711  : 
; 712  :  #if _HAS_ITERATOR_DEBUGGING
; 713  : 		if (_Where._Mycont != this)
; 714  : 			_DEBUG_ERROR("list insert iterator outside range");
; 715  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 716  : 
; 717  : 		_Nodeptr _Pnode = _Where._Mynode();
; 718  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

	mov	eax, DWORD PTR __Where$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR __Val$[esp+8]
	lea	ebx, DWORD PTR [eax+4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, edi
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ; std::list<int,std::allocator<int> >::_Buynode

; 719  : 		_Incsize(1);

	push	1
	mov	ecx, edi
	mov	esi, eax
	call	?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::list<int,std::allocator<int> >::_Incsize

; 720  : 		_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [ebx], esi

; 721  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 722  : 		}

	ret	8
?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z ENDP ; std::list<int,std::allocator<int> >::_Insert
_TEXT	ENDS
PUBLIC	??0?$_List_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ; std::_List_val<int,std::allocator<int> >::_List_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z PROC ; std::_List_val<int,std::allocator<int> >::_List_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 85   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 86   : 		}

	ret	4
??0?$_List_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ENDP ; std::_List_val<int,std::allocator<int> >::_List_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_List_val@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@V?$allocator@VCvQueuedAttack@@@1@@Z ; std::_List_val<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_List_val<CvQueuedAttack,std::allocator<CvQueuedAttack> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_val@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@V?$allocator@VCvQueuedAttack@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_val@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@V?$allocator@VCvQueuedAttack@@@1@@Z PROC ; std::_List_val<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_List_val<CvQueuedAttack,std::allocator<CvQueuedAttack> >, COMDAT
; _this$ = ecx

; 85   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 86   : 		}

	ret	4
??0?$_List_val@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@V?$allocator@VCvQueuedAttack@@@1@@Z ENDP ; std::_List_val<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_List_val<CvQueuedAttack,std::allocator<CvQueuedAttack> >
_TEXT	ENDS
PUBLIC	?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::reserve
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiResSize$ = 8						; size = 4
?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::reserve, COMDAT
; _this$ = ecx

; 658  : 		GrowSizeToFit(uiResSize);

	jmp	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit
?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::reserve
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+20], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@10

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
$LN1@push_back@10:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@10
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@10:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@0ABVCvQueuedAttack@@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Buynode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@0ABVCvQueuedAttack@@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@0ABVCvQueuedAttack@@@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Buynode, COMDAT
; _this$ = ecx

; 1190 : 		{	// allocate a node and set links and value

	push	ebp

; 1191 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	ebp, eax
	add	esp, 4

; 1192 : 		int _Linkcnt = 0;
; 1193 : 
; 1194 : 		_TRY_BEGIN
; 1195 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Next);

	test	ebp, ebp
	je	SHORT $LN27@Buynode@4
	mov	eax, DWORD PTR __Next$[esp]
	mov	DWORD PTR [ebp], eax
$LN27@Buynode@4:

; 1196 : 		++_Linkcnt;
; 1197 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);

	lea	eax, DWORD PTR [ebp+4]
	test	eax, eax
	je	SHORT $LN37@Buynode@4
	mov	ecx, DWORD PTR __Prev$[esp]
	mov	DWORD PTR [eax], ecx
$LN37@Buynode@4:

; 1198 : 		++_Linkcnt;
; 1199 : 		this->_Alval.construct(&_Myval(_Pnode), _Val);

	lea	edx, DWORD PTR [ebp+8]
	test	edx, edx
	je	SHORT $LN60@Buynode@4
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+4]
	mov	eax, DWORD PTR [ebx]
	push	esi
	push	edi
	mov	DWORD PTR [edx], eax
	lea	esi, DWORD PTR [ebx+4]
	lea	edi, DWORD PTR [edx+4]
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR [ebx+32]
	mov	DWORD PTR [edx+32], ecx
	mov	al, BYTE PTR [ebx+36]
	pop	edi
	mov	BYTE PTR [edx+36], al
	mov	cl, BYTE PTR [ebx+37]
	pop	esi
	mov	BYTE PTR [edx+37], cl
	pop	ebx
$LN60@Buynode@4:

; 1200 : 		_CATCH_ALL
; 1201 : 		if (1 < _Linkcnt)
; 1202 : 			this->_Alptr.destroy(&_Prevnode(_Pnode));
; 1203 : 		if (0 < _Linkcnt)
; 1204 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1205 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1206 : 		_RERAISE;
; 1207 : 		_CATCH_END
; 1208 : 		return (_Pnode);

	mov	eax, ebp
	pop	ebp

; 1209 : 		}

	ret	12					; 0000000cH
?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@0ABVCvQueuedAttack@@@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Buynode
_TEXT	ENDS
PUBLIC	??$?5VCvTemporaryZone@@$09$00$0BCJ@$0A@@@YAAAVFDataStream@@AAV0@AAV?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@@Z ; operator>><CvTemporaryZone,10,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5VCvTemporaryZone@@$09$00$0BCJ@$0A@@@YAAAVFDataStream@@AAV0@AAV?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_iSize$ = 8						; size = 4
_kStream$ = 8						; size = 4
_kVec$ = 12						; size = 4
??$?5VCvTemporaryZone@@$09$00$0BCJ@$0A@@@YAAAVFDataStream@@AAV0@AAV?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@@Z PROC ; operator>><CvTemporaryZone,10,1,297,0>, COMDAT

; 617  : {

	push	ebx
	push	ebp

; 618  : 	unsigned int iSize;
; 619  : 	kStream >> iSize;

	mov	ebp, DWORD PTR _kStream$[esp+4]
	push	esi
	lea	eax, DWORD PTR _iSize$[esp+8]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 620  : 	kVec.resize( iSize );

	mov	eax, DWORD PTR _iSize$[esp+8]
	mov	ebx, DWORD PTR _kVec$[esp+8]
	mov	esi, eax
	cmp	DWORD PTR [ebx+8], eax
	jae	SHORT $LN8@operator@14
	push	eax
	mov	ecx, ebx
	call	?GrowSize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::GrowSize
	mov	eax, DWORD PTR _iSize$[esp+8]
$LN8@operator@14:
	mov	DWORD PTR [ebx+4], esi

; 621  : 
; 622  : 	for( unsigned int i = 0; i < iSize; ++i )

	xor	esi, esi
	test	eax, eax
	jbe	SHORT $LN15@operator@14
	push	edi
	xor	edi, edi
	npad	6
$LL3@operator@14:

; 623  : 	{
; 624  : 		kStream >> kVec[i];

	mov	ecx, DWORD PTR [ebx]
	add	ecx, edi
	push	ecx
	push	ebp
	call	??5@YAAAVFDataStream@@AAV0@AAVCvTemporaryZone@@@Z ; operator>>
	inc	esi
	add	esp, 8
	add	edi, 20					; 00000014H
	cmp	esi, DWORD PTR _iSize$[esp+12]
	jb	SHORT $LL3@operator@14
	pop	edi
$LN15@operator@14:
	pop	esi

; 625  : 	}
; 626  : 	return kStream;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 627  : }

	ret	0
??$?5VCvTemporaryZone@@$09$00$0BCJ@$0A@@@YAAAVFDataStream@@AAV0@AAV?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@@Z ENDP ; operator>><CvTemporaryZone,10,1,297,0>
_TEXT	ENDS
PUBLIC	??$find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z ; std::find<std::list<int,std::allocator<int> >::_Iterator<0>,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z PROC ; std::find<std::list<int,std::allocator<int> >::_Iterator<0>,int>, COMDAT

; 74   : 	_ASSIGN_FROM_BASE(_First,

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN29@find
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL11@find:
	cmp	DWORD PTR [ecx+8], edx
	je	SHORT $LN29@find
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, eax
	jne	SHORT $LL11@find
$LN29@find:

; 75   : 		_Find(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val));
; 76   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 77   : 	}

	ret	0
??$find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z ENDP ; std::find<std::list<int,std::allocator<int> >::_Iterator<0>,int>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvTacticalUnit@@IV1@V?$allocator@VCvTacticalUnit@@@std@@@stdext@@YAXPAVCvTacticalUnit@@IABV1@AAV?$allocator@VCvTacticalUnit@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvTacticalUnit *,unsigned int,CvTacticalUnit,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvTacticalUnit@@IV1@V?$allocator@VCvTacticalUnit@@@std@@@stdext@@YAXPAVCvTacticalUnit@@IABV1@AAV?$allocator@VCvTacticalUnit@@@std@@@Z
_TEXT	SEGMENT
$T256941 = -4						; size = 1
__Cat$256945 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvTacticalUnit@@IV1@V?$allocator@VCvTacticalUnit@@@std@@@stdext@@YAXPAVCvTacticalUnit@@IABV1@AAV?$allocator@VCvTacticalUnit@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvTacticalUnit *,unsigned int,CvTacticalUnit,std::allocator<CvTacticalUnit> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T256941[esp+4], 0
	mov	eax, DWORD PTR $T256941[esp+4]
	mov	ecx, DWORD PTR __Cat$256945[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvTacticalUnit@@IV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@IABV1@AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvTacticalUnit *,unsigned int,CvTacticalUnit,std::allocator<CvTacticalUnit> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvTacticalUnit@@IV1@V?$allocator@VCvTacticalUnit@@@std@@@stdext@@YAXPAVCvTacticalUnit@@IABV1@AAV?$allocator@VCvTacticalUnit@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvTacticalUnit *,unsigned int,CvTacticalUnit,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvTacticalCity@@IV1@V?$allocator@VCvTacticalCity@@@std@@@stdext@@YAXPAVCvTacticalCity@@IABV1@AAV?$allocator@VCvTacticalCity@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvTacticalCity *,unsigned int,CvTacticalCity,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvTacticalCity@@IV1@V?$allocator@VCvTacticalCity@@@std@@@stdext@@YAXPAVCvTacticalCity@@IABV1@AAV?$allocator@VCvTacticalCity@@@std@@@Z
_TEXT	SEGMENT
$T256950 = -4						; size = 1
__Cat$256954 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvTacticalCity@@IV1@V?$allocator@VCvTacticalCity@@@std@@@stdext@@YAXPAVCvTacticalCity@@IABV1@AAV?$allocator@VCvTacticalCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvTacticalCity *,unsigned int,CvTacticalCity,std::allocator<CvTacticalCity> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T256950[esp+4], 0
	mov	eax, DWORD PTR $T256950[esp+4]
	mov	ecx, DWORD PTR __Cat$256954[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvTacticalCity@@IV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@IABV1@AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvTacticalCity *,unsigned int,CvTacticalCity,std::allocator<CvTacticalCity> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvTacticalCity@@IV1@V?$allocator@VCvTacticalCity@@@std@@@stdext@@YAXPAVCvTacticalCity@@IABV1@AAV?$allocator@VCvTacticalCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvTacticalCity *,unsigned int,CvTacticalCity,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@0AAV?$allocator@VCvTacticalUnit@@@0@@Z ; std::_Destroy_range<std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@0AAV?$allocator@VCvTacticalUnit@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@0AAV?$allocator@VCvTacticalUnit@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTacticalUnit> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@0AAV?$allocator@VCvTacticalUnit@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@0AAV?$allocator@VCvTacticalCity@@@0@@Z ; std::_Destroy_range<std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@0AAV?$allocator@VCvTacticalCity@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@0AAV?$allocator@VCvTacticalCity@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTacticalCity> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@0AAV?$allocator@VCvTacticalCity@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@3
	pop	esi
$LN9@Uninit_fil@3:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@4
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@4:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__Tmp$257188 = -24					; size = 8
__Tmp$257117 = -16					; size = 8
__Tmp$257143 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Median<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_
	npad	6
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$257117[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$257117[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$257143[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$257143[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_
$LN111@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$257188[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$257188[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$257188[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$257188[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T257298 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$257301 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$257301[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T257298[esp+4], 0
	mov	eax, DWORD PTR $T257298[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T257317 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$257320 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$257320[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T257317[esp+4], 0
	mov	eax, DWORD PTR $T257317[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@0@Z ; std::_Insertion_sort<CvTacticalMove *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@0@Z PROC ; std::_Insertion_sort<CvTacticalMove *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvTacticalMove@@V1@@std@@YAXPAVCvTacticalMove@@00@Z ; std::_Insertion_sort1<CvTacticalMove *,CvTacticalMove>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@0@Z ENDP ; std::_Insertion_sort<CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@0@Z ; std::_Insertion_sort<CvTacticalTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@0@Z PROC ; std::_Insertion_sort<CvTacticalTarget *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvTacticalTarget@@V1@@std@@YAXPAVCvTacticalTarget@@00@Z ; std::_Insertion_sort1<CvTacticalTarget *,CvTacticalTarget>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@0@Z ENDP ; std::_Insertion_sort<CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAVCvBlockingUnit@@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z@Z ; std::_Insertion_sort<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAVCvBlockingUnit@@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Insertion_sort@PAVCvBlockingUnit@@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z@Z PROC ; std::_Insertion_sort<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 3150 : 	std::_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@PAVCvBlockingUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),CvBlockingUnit>
	add	esp, 16					; 00000010H

; 3151 : 	}

	ret	0
??$_Insertion_sort@PAVCvBlockingUnit@@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z@Z ENDP ; std::_Insertion_sort<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@0@Z ; std::_Insertion_sort<CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@0@Z PROC ; std::_Insertion_sort<CvBlockingUnit *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvBlockingUnit@@V1@@std@@YAXPAVCvBlockingUnit@@00@Z ; std::_Insertion_sort1<CvBlockingUnit *,CvBlockingUnit>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@0@Z ENDP ; std::_Insertion_sort<CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@0V12@@Z ; stdext::unchecked_copy<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@0V12@@Z
_TEXT	SEGMENT
$T257352 = -4						; size = 1
$T257359 = -4						; size = 4
$T257355 = -4						; size = 4
__Cat$257364 = 8					; size = 1
$T257354 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@0V12@@Z PROC ; stdext::unchecked_copy<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T257359[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$257364[esp+4]
	mov	edx, DWORD PTR $T257354[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T257352[esp+12], bl
	mov	eax, DWORD PTR $T257352[esp+12]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR $T257355[esp+44], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+40]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@0@PAVCvTacticalMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@17
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@17:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@0V12@@Z ENDP ; stdext::unchecked_copy<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvTacticalMove@@PAV1@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@0000@Z ; stdext::unchecked_merge<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$unchecked_merge@PAVCvTacticalMove@@PAV1@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@0000@Z
_TEXT	SEGMENT
$T257403 = -4						; size = 1
$T257404 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$unchecked_merge@PAVCvTacticalMove@@PAV1@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@0000@Z PROC ; stdext::unchecked_merge<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Dest$[esp]
	mov	BYTE PTR $T257403[esp+4], 0
	mov	eax, DWORD PTR $T257403[esp+4]
	mov	ecx, DWORD PTR $T257404[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Merge@PAVCvTacticalMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>

; 5117 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$unchecked_merge@PAVCvTacticalMove@@PAV1@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@0000@Z ENDP ; stdext::unchecked_merge<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAVCvTacticalMove@@HV1@@std@@YAPAVCvTacticalMove@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Buffered_rotate<CvTacticalMove *,int,CvTacticalMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@PAVCvTacticalMove@@HV1@@std@@YAPAVCvTacticalMove@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z
_TEXT	SEGMENT
$T257415 = -20						; size = 20
$T257413 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T257414 = 20						; size = 4
$T257412 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvTacticalMove@@HV1@@std@@YAPAVCvTacticalMove@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z PROC ; std::_Buffered_rotate<CvTacticalMove *,int,CvTacticalMove>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Count2$[esp+20]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Count1$[esp+32]
	cmp	edi, ebx
	jg	$LN4@Buffered_r
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalMove>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Mid$[esp+32]
	mov	ebp, DWORD PTR __First$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T257412[esp+52], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T257413[esp+60]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@0V12@@Z ; stdext::unchecked_copy<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
	mov	eax, DWORD PTR $T257413[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN25@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __Last$[esp+32]
	mov	eax, ebx
	cmp	ebx, edx
	je	SHORT $LN33@Buffered_r
	mov	ecx, ebp
	sub	ecx, ebx
$LL35@Buffered_r:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx+eax], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+eax+4], edi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL35@Buffered_r
$LN33@Buffered_r:

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi]
	push	edx
	push	eax
	push	esi
	call	??$unchecked_copy_backward@PAVCvTacticalMove@@PAV1@@stdext@@YAPAVCvTacticalMove@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvTacticalMove *,CvTacticalMove *>
	add	esp, 12					; 0000000cH

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalMove>::_Maxlen
	cmp	ebx, eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebp, DWORD PTR __Last$[esp+32]
	mov	ebx, DWORD PTR __Mid$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T257414[esp+52], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T257415[esp+60]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@0V12@@Z ; stdext::unchecked_copy<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
	mov	eax, DWORD PTR $T257415[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN56@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edi, DWORD PTR __First$[esp+32]
	mov	eax, ebx
	cmp	edi, ebx
	je	SHORT $LN64@Buffered_r
	mov	ecx, ebp
	sub	ecx, ebx
	npad	5
$LL65@Buffered_r:
	mov	edx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [ecx+eax], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+eax+4], edx
	cmp	eax, edi
	jne	SHORT $LL65@Buffered_r
$LN64@Buffered_r:

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	eax, edi
	cmp	ecx, edx
	je	SHORT $LN1@Buffered_r
$LL80@Buffered_r:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL80@Buffered_r

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	esi, DWORD PTR __First$[esp+32]
	mov	eax, DWORD PTR __Mid$[esp+32]
	cmp	esi, eax
	je	SHORT $LN88@Buffered_r
	mov	ecx, DWORD PTR __Last$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN88@Buffered_r
	xor	edi, edi
	push	edi
	push	edi
	push	ecx
	push	eax
	push	esi
	call	??$_Rotate@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00PAH0@Z ; std::_Rotate<CvTacticalMove *,int,CvTacticalMove>
	add	esp, 20					; 00000014H
$LN88@Buffered_r:

; 2700 : 		std::advance(_First, _Count2);

	lea	eax, DWORD PTR [esi+ebx*8]
$LN1@Buffered_r:

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@PAVCvTacticalMove@@HV1@@std@@YAPAVCvTacticalMove@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ENDP ; std::_Buffered_rotate<CvTacticalMove *,int,CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@0V12@@Z ; stdext::unchecked_copy<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@0V12@@Z
_TEXT	SEGMENT
$T257682 = -4						; size = 1
$T257689 = -4						; size = 4
$T257685 = -4						; size = 4
__Cat$257694 = 8					; size = 1
$T257684 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@0V12@@Z PROC ; stdext::unchecked_copy<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T257689[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$257694[esp+4]
	mov	edx, DWORD PTR $T257684[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T257682[esp+12], bl
	mov	eax, DWORD PTR $T257682[esp+12]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR $T257685[esp+44], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+40]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@0@PAVCvTacticalTarget@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@18
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@18:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@0V12@@Z ENDP ; stdext::unchecked_copy<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvTacticalTarget@@PAV1@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@0000@Z ; stdext::unchecked_merge<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$unchecked_merge@PAVCvTacticalTarget@@PAV1@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@0000@Z
_TEXT	SEGMENT
$T257733 = -4						; size = 1
$T257734 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$unchecked_merge@PAVCvTacticalTarget@@PAV1@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@0000@Z PROC ; stdext::unchecked_merge<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Dest$[esp]
	mov	BYTE PTR $T257733[esp+4], 0
	mov	eax, DWORD PTR $T257733[esp+4]
	mov	ecx, DWORD PTR $T257734[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Merge@PAVCvTacticalTarget@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>

; 5117 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$unchecked_merge@PAVCvTacticalTarget@@PAV1@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@0000@Z ENDP ; stdext::unchecked_merge<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAVCvTacticalTarget@@HV1@@std@@YAPAVCvTacticalTarget@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Buffered_rotate<CvTacticalTarget *,int,CvTacticalTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@PAVCvTacticalTarget@@HV1@@std@@YAPAVCvTacticalTarget@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z
_TEXT	SEGMENT
$T257745 = -20						; size = 20
$T257743 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T257744 = 20						; size = 4
$T257742 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvTacticalTarget@@HV1@@std@@YAPAVCvTacticalTarget@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z PROC ; std::_Buffered_rotate<CvTacticalTarget *,int,CvTacticalTarget>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Tempbuf$[esp+20]
	push	ebp
	mov	ebp, DWORD PTR __Count2$[esp+24]
	push	esi
	mov	esi, DWORD PTR __Count1$[esp+28]
	cmp	esi, ebp
	push	edi
	jg	SHORT $LN4@Buffered_r@2
	mov	ecx, ebx
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalTarget>::_Maxlen
	cmp	esi, eax
	jg	SHORT $LN4@Buffered_r@2

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Mid$[esp+32]
	mov	ebp, DWORD PTR __First$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	esi, esi
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	edx, DWORD PTR [ebx+16]
	mov	DWORD PTR $T257742[esp+52], esp
	push	edi
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T257743[esp+60]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@0V12@@Z ; stdext::unchecked_copy<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
	mov	eax, DWORD PTR $T257743[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, esi
	je	SHORT $LN25@Buffered_r@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r@2:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	esi, DWORD PTR __Last$[esp+32]
	push	ebp
	push	esi
	push	edi
	call	??$unchecked_copy@PAVCvTacticalTarget@@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@00@Z ; stdext::unchecked_copy<CvTacticalTarget *,CvTacticalTarget *>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	ebx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	push	esi
	push	eax
	push	ebx
	call	??$unchecked_copy_backward@PAVCvTacticalTarget@@PAV1@@stdext@@YAPAVCvTacticalTarget@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvTacticalTarget *,CvTacticalTarget *>
	add	esp, 24					; 00000018H

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r@2:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, ebx
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalTarget>::_Maxlen
	cmp	ebp, eax
	jg	$LN2@Buffered_r@2

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebp, DWORD PTR __Last$[esp+32]
	mov	edi, DWORD PTR __Mid$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	esi, esi
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	edx, DWORD PTR [ebx+16]
	mov	DWORD PTR $T257744[esp+52], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T257745[esp+60]
	push	edi
	push	eax
	call	??$unchecked_copy@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@0V12@@Z ; stdext::unchecked_copy<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
	mov	eax, DWORD PTR $T257745[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, esi
	je	SHORT $LN45@Buffered_r@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@Buffered_r@2:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edx, DWORD PTR __First$[esp+32]
	mov	eax, edi
	cmp	edx, edi
	je	SHORT $LN53@Buffered_r@2
	sub	ebp, edi
	npad	4
$LL54@Buffered_r@2:
	sub	eax, 28					; 0000001cH
	lea	edi, DWORD PTR [eax+ebp]
	mov	ecx, 7
	mov	esi, eax
	rep movsd
	cmp	eax, edx
	jne	SHORT $LL54@Buffered_r@2
$LN53@Buffered_r@2:

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	ebx, DWORD PTR [ebx+16]
	mov	ebp, DWORD PTR [ebx+4]
	mov	eax, edx
	mov	edx, DWORD PTR [ebx]
	cmp	edx, ebp
	je	SHORT $LN1@Buffered_r@2
$LL69@Buffered_r@2:
	mov	esi, edx
	mov	edi, eax
	add	edx, 28					; 0000001cH
	mov	ecx, 7
	add	eax, 28					; 0000001cH
	rep movsd
	cmp	edx, ebp
	jne	SHORT $LL69@Buffered_r@2

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r@2:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	edi, DWORD PTR __First$[esp+32]
	mov	eax, DWORD PTR __Mid$[esp+32]
	cmp	edi, eax
	je	SHORT $LN77@Buffered_r@2
	mov	ecx, DWORD PTR __Last$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN77@Buffered_r@2
	xor	esi, esi
	push	esi
	push	esi
	push	ecx
	push	eax
	push	edi
	call	??$_Rotate@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00PAH0@Z ; std::_Rotate<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 20					; 00000014H
$LN77@Buffered_r@2:

; 2700 : 		std::advance(_First, _Count2);

	lea	ecx, DWORD PTR [ebp*8]
	sub	ecx, ebp
	lea	eax, DWORD PTR [edi+ecx*4]
$LN1@Buffered_r@2:

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@PAVCvTacticalTarget@@HV1@@std@@YAPAVCvTacticalTarget@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ENDP ; std::_Buffered_rotate<CvTacticalTarget *,int,CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAVCvTacticalUnit@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAVCvTacticalUnit@@@Z
_TEXT	SEGMENT
$T258046 = -32						; size = 1
$T257970 = -28						; size = 4
__Val$232676 = -24					; size = 24
__Cat$258050 = 8					; size = 1
$T258048 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAVCvTacticalUnit@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 32					; 00000020H
	cmp	ecx, eax
	je	$LN6@Insertion_@6
	push	esi

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	esi, DWORD PTR [ecx+24]
	cmp	esi, eax
	je	$LN81@Insertion_@6
	push	ebx
	push	ebp
	push	edi
	jmp	SHORT $LN7@Insertion_@6
$LL80@Insertion_@6:
	mov	ecx, DWORD PTR __First$[esp+44]
$LN7@Insertion_@6:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR [esi]
	mov	ebp, DWORD PTR [esi+8]
	mov	edi, DWORD PTR [esi+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	ebx, DWORD PTR [ecx+8]
	imul	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$232676[esp+48], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR __Val$232676[esp+60], edx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR __Val$232676[esp+64], edx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR __Val$232676[esp+68], edx
	mov	edx, ebp
	imul	edx, edi
	cmp	edx, ebx
	mov	eax, esi
	jle	SHORT $LN5@Insertion_@6

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	BYTE PTR $T258046[esp+48], 0
	mov	edx, DWORD PTR $T258046[esp+48]
	push	edx
	mov	edx, DWORD PTR __Cat$258050[esp+48]
	push	edx
	mov	edx, DWORD PTR $T258048[esp+52]
	push	edx
	lea	eax, DWORD PTR [esi+24]
	push	eax
	push	esi
	push	ecx
	lea	eax, DWORD PTR $T257970[esp+72]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>

; 2977 : 				*_First = _Val;

	mov	ecx, DWORD PTR __First$[esp+72]
	mov	edx, DWORD PTR __Val$232676[esp+76]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __First$[esp+72]
	mov	DWORD PTR [eax+4], edi
	mov	ecx, DWORD PTR __First$[esp+72]
	mov	eax, DWORD PTR __Val$232676[esp+88]
	mov	DWORD PTR [ecx+8], ebp
	mov	edx, DWORD PTR __First$[esp+72]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR __First$[esp+72]
	mov	edx, DWORD PTR __Val$232676[esp+92]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR __First$[esp+72]
	add	esp, 28					; 0000001cH

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN83@Insertion_@6
$LN5@Insertion_@6:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebx, DWORD PTR [esi-16]
	imul	ebx, DWORD PTR [esi-20]
	cmp	edx, ebx
	lea	ecx, DWORD PTR [esi-24]
	jle	SHORT $LN1@Insertion_@6
$LL3@Insertion_@6:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebx
	mov	ebx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ebx
	mov	ebx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ebx
	mov	ebx, DWORD PTR [ecx-16]
	imul	ebx, DWORD PTR [ecx-20]
	mov	eax, ecx
	sub	ecx, 24					; 00000018H
	cmp	edx, ebx
	jg	SHORT $LL3@Insertion_@6
$LN1@Insertion_@6:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Val$232676[esp+48]
	mov	ecx, DWORD PTR __Val$232676[esp+60]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Val$232676[esp+64]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
$LN83@Insertion_@6:
	mov	ecx, DWORD PTR __Val$232676[esp+68]
	add	esi, 24					; 00000018H
	mov	DWORD PTR [eax+20], ecx
	cmp	esi, DWORD PTR __Last$[esp+44]
	jne	$LL80@Insertion_@6
	pop	edi
	pop	ebp
	pop	ebx
$LN81@Insertion_@6:
	pop	esi
$LN6@Insertion_@6:

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAVCvTacticalUnit@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$lower_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@@Z ; std::lower_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@@Z
_TEXT	SEGMENT
$T258130 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$lower_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@@Z PROC ; std::lower_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>, COMDAT

; 2275 : 	{	// find first element not before _Val, using operator<

	push	ecx

; 2276 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T258130[esp+20]
	push	eax
	call	??$_Lower_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit,int>

; 2277 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2278 : 	return _First;

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	DWORD PTR [eax], ecx

; 2279 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$lower_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@@Z ENDP ; std::lower_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$upper_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@@Z ; std::upper_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@@Z
_TEXT	SEGMENT
$T258137 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$upper_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@@Z PROC ; std::upper_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>, COMDAT

; 2346 : 	{	// find first element that _Val is before, using operator<

	push	ecx

; 2347 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T258137[esp+20]
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit,int>

; 2348 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2349 : 	return _First;

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	DWORD PTR [eax], ecx

; 2350 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$upper_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@@Z ENDP ; std::upper_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAVCvTacticalCity@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAVCvTacticalCity@@@Z
_TEXT	SEGMENT
$T258221 = -8						; size = 1
$T258144 = -4						; size = 4
__Cat$258226 = 8					; size = 1
$T258223 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAVCvTacticalCity@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 8
	cmp	edx, eax
	je	$LN6@Insertion_@7
	push	esi

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	esi, DWORD PTR [edx+12]
	cmp	esi, eax
	je	$LN81@Insertion_@7
	push	ebx
	push	ebp
	push	edi
	jmp	SHORT $LN7@Insertion_@7
$LL80@Insertion_@7:
	mov	edx, DWORD PTR __First$[esp+20]
$LN7@Insertion_@7:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	edi, DWORD PTR [esi+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [esi]
	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, esi
	jle	SHORT $LN5@Insertion_@7

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	BYTE PTR $T258221[esp+24], 0
	mov	ecx, DWORD PTR $T258221[esp+24]
	push	ecx
	mov	ecx, DWORD PTR __Cat$258226[esp+24]
	push	ecx
	mov	ecx, DWORD PTR $T258223[esp+28]
	push	ecx
	lea	eax, DWORD PTR [esi+12]
	push	eax
	push	esi
	push	edx
	lea	edx, DWORD PTR $T258144[esp+48]
	push	edx
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[esp+48]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR __First$[esp+48]
	mov	DWORD PTR [ecx+4], edi
	mov	edx, DWORD PTR __First$[esp+48]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [edx+8], ebx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@7
$LN5@Insertion_@7:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	edi, DWORD PTR [esi-8]
	lea	eax, DWORD PTR [esi-12]
	jle	SHORT $LN1@Insertion_@7
	npad	4
$LL3@Insertion_@7:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	ecx, eax
	sub	eax, 12					; 0000000cH
	cmp	edi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_@7
$LN1@Insertion_@7:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebp
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], ebx
$LN4@Insertion_@7:
	add	esi, 12					; 0000000cH
	cmp	esi, DWORD PTR __Last$[esp+20]
	jne	$LL80@Insertion_@7
	pop	edi
	pop	ebp
	pop	ebx
$LN81@Insertion_@7:
	pop	esi
$LN6@Insertion_@7:

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 8
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAVCvTacticalCity@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$lower_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@@Z ; std::lower_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@@Z
_TEXT	SEGMENT
$T258306 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$lower_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@@Z PROC ; std::lower_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>, COMDAT

; 2275 : 	{	// find first element not before _Val, using operator<

	push	ecx

; 2276 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T258306[esp+20]
	push	eax
	call	??$_Lower_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity,int>

; 2277 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2278 : 	return _First;

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	DWORD PTR [eax], ecx

; 2279 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$lower_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@@Z ENDP ; std::lower_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$upper_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@@Z ; std::upper_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@@Z
_TEXT	SEGMENT
$T258313 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$upper_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@@Z PROC ; std::upper_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>, COMDAT

; 2346 : 	{	// find first element that _Val is before, using operator<

	push	ecx

; 2347 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T258313[esp+20]
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity,int>

; 2348 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2349 : 	return _First;

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	DWORD PTR [eax], ecx

; 2350 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$upper_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@@Z ENDP ; std::upper_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z
_TEXT	SEGMENT
$T258320 = -4						; size = 1
$T258327 = -4						; size = 4
$T258323 = -4						; size = 4
__Cat$258332 = 8					; size = 1
$T258322 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z PROC ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T258327[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$258332[esp+4]
	mov	edx, DWORD PTR $T258322[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T258320[esp+12], bl
	mov	eax, DWORD PTR $T258320[esp+12]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR $T258323[esp+44], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+40]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@19
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@19:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ENDP ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@Z@Z ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$unchecked_merge@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@Z@Z
_TEXT	SEGMENT
$T258371 = -4						; size = 1
$T258372 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 4
??$unchecked_merge@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@Z@Z PROC ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Pred$[esp]
	mov	BYTE PTR $T258371[esp+4], 0
	mov	eax, DWORD PTR $T258371[esp+4]
	mov	ecx, DWORD PTR $T258372[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+12]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+20]
	push	edx
	push	eax
	push	ecx
	call	??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),std::random_access_iterator_tag>

; 5160 : 	}

	add	esp, 36					; 00000024H
	ret	0
??$unchecked_merge@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@Z@Z ENDP ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAVCvBlockingUnit@@HV1@@std@@YAPAVCvBlockingUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Buffered_rotate<CvBlockingUnit *,int,CvBlockingUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@PAVCvBlockingUnit@@HV1@@std@@YAPAVCvBlockingUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z
_TEXT	SEGMENT
$T258383 = -20						; size = 20
$T258381 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T258382 = 20						; size = 4
$T258380 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvBlockingUnit@@HV1@@std@@YAPAVCvBlockingUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z PROC ; std::_Buffered_rotate<CvBlockingUnit *,int,CvBlockingUnit>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Count2$[esp+20]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Count1$[esp+32]
	cmp	edi, ebx
	jg	SHORT $LN4@Buffered_r@3
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvBlockingUnit>::_Maxlen
	cmp	edi, eax
	jg	SHORT $LN4@Buffered_r@3

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Mid$[esp+32]
	mov	ebp, DWORD PTR __First$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T258380[esp+52], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T258381[esp+60]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	mov	eax, DWORD PTR $T258381[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN25@Buffered_r@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r@3:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edi, DWORD PTR __Last$[esp+32]
	push	ebp
	push	edi
	push	ebx
	call	??$unchecked_copy@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z ; stdext::unchecked_copy<CvBlockingUnit *,CvBlockingUnit *>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi]
	push	edi
	push	eax
	push	esi
	call	??$unchecked_copy_backward@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvBlockingUnit *,CvBlockingUnit *>
	add	esp, 24					; 00000018H

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r@3:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvBlockingUnit>::_Maxlen
	cmp	ebx, eax
	jg	SHORT $LN2@Buffered_r@3

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Last$[esp+32]
	mov	ebp, DWORD PTR __Mid$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T258382[esp+52], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T258383[esp+60]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	mov	eax, DWORD PTR $T258383[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN45@Buffered_r@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@Buffered_r@3:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edi, DWORD PTR __First$[esp+32]
	push	ebx
	push	ebp
	push	edi
	call	??$unchecked_copy_backward@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvBlockingUnit *,CvBlockingUnit *>

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi]
	push	edi
	push	eax
	push	esi
	call	??$unchecked_copy@PAVCvBlockingUnit@@PAV1@@stdext@@YAPAVCvBlockingUnit@@PAV1@00@Z ; stdext::unchecked_copy<CvBlockingUnit *,CvBlockingUnit *>
	add	esp, 24					; 00000018H

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r@3:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	esi, DWORD PTR __First$[esp+32]
	mov	eax, DWORD PTR __Mid$[esp+32]
	cmp	esi, eax
	je	SHORT $LN56@Buffered_r@3
	mov	ecx, DWORD PTR __Last$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN56@Buffered_r@3
	xor	edi, edi
	push	edi
	push	edi
	push	ecx
	push	eax
	push	esi
	call	??$_Rotate@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00PAH0@Z ; std::_Rotate<CvBlockingUnit *,int,CvBlockingUnit>
	add	esp, 20					; 00000014H
$LN56@Buffered_r@3:

; 2700 : 		std::advance(_First, _Count2);

	mov	eax, ebx

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	shl	eax, 4
	add	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@PAVCvBlockingUnit@@HV1@@std@@YAPAVCvBlockingUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ENDP ; std::_Buffered_rotate<CvBlockingUnit *,int,CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@PAV1@H@stdext@@YAXPAVCvBlockingUnit@@00HH@Z ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@PAV1@H@stdext@@YAXPAVCvBlockingUnit@@00HH@Z
_TEXT	SEGMENT
$T258525 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@PAV1@H@stdext@@YAXPAVCvBlockingUnit@@00HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	mov	BYTE PTR $T258525[esp+4], 0
	mov	eax, DWORD PTR $T258525[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvBlockingUnit@@PAV1@H@std@@YAXPAVCvBlockingUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int>

; 5254 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@PAV1@H@stdext@@YAXPAVCvBlockingUnit@@00HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::pop_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvTacticalMove@@PAV1@H@std@@YAXPAVCvTacticalMove@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalMove *,CvTacticalMove *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvTacticalMove@@PAV1@H@std@@YAXPAVCvTacticalMove@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
$T258611 = 20						; size = 1
__Chunk$ = 20						; size = 4
$T258687 = 24						; size = 1
$T258688 = 24						; size = 1
$T258612 = 24						; size = 1
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvTacticalMove@@PAV1@H@std@@YAXPAVCvTacticalMove@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvTacticalMove *,CvTacticalMove *,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+8]
	lea	ebp, DWORD PTR [edi+edi]
	cmp	ebp, edx
	jg	SHORT $LN3@Chunked_me@2
	push	ebx
	npad	5
$LL50@Chunked_me@2:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	BYTE PTR $T258611[esp+12], 0
	mov	ebx, DWORD PTR $T258611[esp+12]
	push	ebx
	mov	ebx, DWORD PTR $T258612[esp+16]
	push	ebx
	lea	edx, DWORD PTR [ecx+edi*8]
	push	eax
	lea	esi, DWORD PTR [edx+edi*8]
	push	esi
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAVCvTacticalMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>
	mov	edx, DWORD PTR __Count$[esp+40]
	sub	edx, ebp
	add	esp, 28					; 0000001cH
	cmp	edx, ebp

; 3297 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+12], edx
	jge	SHORT $LL50@Chunked_me@2
	pop	ebx
$LN3@Chunked_me@2:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	cmp	edx, edi
	jg	SHORT $LN2@Chunked_me@2

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Last$[esp+8]
	cmp	ecx, edx
	je	SHORT $LN41@Chunked_me@2
	sub	eax, ecx
$LL32@Chunked_me@2:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+ecx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+ecx+4], esi
	add	ecx, 8
	cmp	ecx, edx
	jne	SHORT $LL32@Chunked_me@2
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	ret	0
$LN2@Chunked_me@2:

; 3302 : 	else
; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	BYTE PTR $T258687[esp+8], 0
	mov	edx, DWORD PTR $T258687[esp+8]
	push	edx
	mov	edx, DWORD PTR $T258688[esp+12]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Last$[esp+20]
	push	eax
	lea	edi, DWORD PTR [ecx+edi*8]
	push	edi
	push	edi
	push	ecx
	call	??$_Merge@PAVCvTacticalMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN41@Chunked_me@2:
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	ret	0
??$_Chunked_merge@PAVCvTacticalMove@@PAV1@H@std@@YAXPAVCvTacticalMove@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvTacticalMove *,CvTacticalMove *,int>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvTacticalTarget@@PAV1@H@std@@YAXPAVCvTacticalTarget@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalTarget *,CvTacticalTarget *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvTacticalTarget@@PAV1@H@std@@YAXPAVCvTacticalTarget@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T258749 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
$T258825 = 24						; size = 1
$T258826 = 24						; size = 1
$T258750 = 24						; size = 1
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvTacticalTarget@@PAV1@H@std@@YAXPAVCvTacticalTarget@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvTacticalTarget *,CvTacticalTarget *,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ecx

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edx, DWORD PTR __Count$[esp]
	mov	eax, DWORD PTR __Dest$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Chunk$[esp+12]
	lea	ebp, DWORD PTR [esi+esi]
	cmp	ebp, edx
	push	edi
	jg	SHORT $LN3@Chunked_me@3
	lea	edi, DWORD PTR [esi*8]
	sub	edi, esi
	add	edi, edi
	add	edi, edi
	npad	7
$LL50@Chunked_me@3:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	BYTE PTR $T258749[esp+20], 0
	mov	ebx, DWORD PTR $T258749[esp+20]
	push	ebx
	mov	ebx, DWORD PTR $T258750[esp+20]
	push	ebx
	lea	edx, DWORD PTR [edi+ecx]
	push	eax
	lea	esi, DWORD PTR [edi+edx]
	push	esi
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAVCvTacticalTarget@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>
	mov	edx, DWORD PTR __Count$[esp+44]
	sub	edx, ebp
	add	esp, 28					; 0000001cH
	cmp	edx, ebp

; 3297 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+16], edx
	jge	SHORT $LL50@Chunked_me@3

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	esi, DWORD PTR __Chunk$[esp+16]
$LN3@Chunked_me@3:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	cmp	edx, esi
	jg	SHORT $LN2@Chunked_me@3

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ebx, DWORD PTR __Last$[esp+16]
	mov	edx, ecx
	cmp	ecx, ebx
	je	SHORT $LN41@Chunked_me@3
	sub	eax, ecx
$LL32@Chunked_me@3:
	lea	edi, DWORD PTR [eax+edx]
	mov	esi, edx
	add	edx, 28					; 0000001cH
	mov	ecx, 7
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL32@Chunked_me@3
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3308 : 		}
; 3309 : 	}

	pop	ecx
	ret	0
$LN2@Chunked_me@3:

; 3302 : 	else
; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);

	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	BYTE PTR $T258825[esp+16], 0
	mov	esi, DWORD PTR $T258825[esp+16]
	push	esi
	mov	esi, DWORD PTR $T258826[esp+20]
	push	esi
	push	eax
	mov	eax, DWORD PTR __Last$[esp+28]
	push	eax
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAVCvTacticalTarget@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN41@Chunked_me@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3308 : 		}
; 3309 : 	}

	pop	ecx
	ret	0
??$_Chunked_merge@PAVCvTacticalTarget@@PAV1@H@std@@YAXPAVCvTacticalTarget@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvTacticalTarget *,CvTacticalTarget *,int>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T258952 = 12						; size = 1
$T258927 = 12						; size = 1
$T258843 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Cat$258956 = 28					; size = 1
$T258954 = 28						; size = 1
__Cat$258931 = 28					; size = 1
$T258929 = 28						; size = 1
__Dest$ = 28						; size = 4
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	push	edi
	cmp	eax, esi
	je	$LN3@Merge@9
	mov	ecx, DWORD PTR __First2$[esp+8]
	npad	5
$LL10@Merge@9:
	cmp	ecx, DWORD PTR __Last2$[esp+8]
	je	$LN3@Merge@9

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edi, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [ecx+8]
	imul	edi, DWORD PTR [eax+4]
	imul	ebx, DWORD PTR [ecx+4]
	cmp	ebx, edi
	jle	SHORT $LN2@Merge@9

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edi+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edi+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	edi, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edi+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edi+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+20], ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __First2$[esp+8], ecx

; 2516 : 		else

	jmp	SHORT $LN4@Merge@9
$LN2@Merge@9:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [ecx+20], edx
	mov	ecx, DWORD PTR __First2$[esp+8]
	add	eax, 24					; 00000018H
$LN4@Merge@9:
	mov	edx, DWORD PTR __Dest$[esp+8]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __Dest$[esp+8], edx
	cmp	eax, esi
	jne	$LL10@Merge@9
$LN3@Merge@9:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	xor	bl, bl
	mov	BYTE PTR $T258927[esp+8], bl
	mov	ecx, DWORD PTR $T258927[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Cat$258931[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T258929[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	lea	edx, DWORD PTR $T258843[esp+32]
	push	edx
	call	??$_Copy_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	mov	eax, DWORD PTR $T258843[esp+36]

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+36]
	mov	DWORD PTR __Dest$[esp+36], eax
	mov	edx, DWORD PTR __Cat$258956[esp+36]
	mov	BYTE PTR $T258952[esp+36], bl
	mov	ecx, DWORD PTR $T258952[esp+36]
	push	ecx
	mov	ecx, DWORD PTR $T258954[esp+40]
	push	edx
	mov	edx, DWORD PTR __Last2$[esp+44]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __First2$[esp+52]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@V12@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0PAVCvTacticalUnit@@10U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@V12@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0PAVCvTacticalUnit@@10U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T259012 = -4						; size = 1
$T258987 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Cat$259016 = 16					; size = 1
$T259014 = 16						; size = 1
__Cat$258991 = 16					; size = 1
$T258989 = 16						; size = 1
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
___formal$ = 32						; size = 1
??$_Merge_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@V12@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0PAVCvTacticalUnit@@10U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 2710 : 	{	// merge backwards to _Dest, using operator<

	push	ecx

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	edx, DWORD PTR __First1$[esp]
	mov	ecx, DWORD PTR __Last1$[esp]
	mov	eax, DWORD PTR __Last2$[esp]
	push	esi
	mov	esi, DWORD PTR __First2$[esp+4]
	push	edi
	cmp	edx, ecx
	je	$LN65@Merge_back@5
	npad	5
$LL8@Merge_back@5:

; 2714 : 		else if (_First2 == _Last2)

	cmp	esi, eax
	je	$LN66@Merge_back@5

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	edi, DWORD PTR [eax-16]
	imul	edi, DWORD PTR [eax-20]
	sub	ecx, 24					; 00000018H
	sub	eax, 24					; 00000018H
	mov	DWORD PTR __Last1$[esp+8], ecx
	mov	edx, DWORD PTR [ecx+8]
	imul	edx, DWORD PTR [ecx+4]
	cmp	edi, edx
	jle	SHORT $LN2@Merge_back@5

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Dest$[esp+8]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR __Dest$[esp+8], edx
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edi+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edi+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	edi, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edi+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edi+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+20], ecx

; 2718 : 		else

	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	eax, 24					; 00000018H
	jmp	SHORT $LN61@Merge_back@5
$LN2@Merge_back@5:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ecx, DWORD PTR __Dest$[esp+8]
	mov	edx, DWORD PTR [eax]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR __Dest$[esp+8], ecx
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+16], ecx
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+20], ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Last1$[esp+8], ecx
$LN61@Merge_back@5:
	mov	edx, DWORD PTR __First1$[esp+8]
	cmp	edx, ecx
	jne	$LL8@Merge_back@5
$LN65@Merge_back@5:

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Cat$258991[esp+8]
	mov	BYTE PTR $T258987[esp+12], 0
	mov	ecx, DWORD PTR $T258987[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T258989[esp+12]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	ecx
	push	edx
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+32]
	push	esi
	call	??$_Copy_backward_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2720 : 	}

	pop	ecx
	ret	0
$LN66@Merge_back@5:

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T259012[esp+12], 0
	mov	eax, DWORD PTR $T259012[esp+12]
	push	eax
	mov	eax, DWORD PTR __Cat$259016[esp+12]
	push	eax
	mov	eax, DWORD PTR $T259014[esp+16]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+20]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2720 : 	}

	pop	ecx
	ret	0
??$_Merge_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@V12@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0PAVCvTacticalUnit@@10U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T259221 = 12						; size = 1
$T259196 = 12						; size = 1
$T259111 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Cat$259226 = 28					; size = 1
$T259223 = 28						; size = 1
__Cat$259201 = 28					; size = 1
$T259198 = 28						; size = 1
__Dest$ = 28						; size = 4
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last1$[esp]
	push	edi
	cmp	eax, esi
	je	SHORT $LN3@Merge@10
	mov	ecx, DWORD PTR __First2$[esp+4]
$LL10@Merge@10:
	cmp	ecx, DWORD PTR __Last2$[esp+4]
	je	SHORT $LN3@Merge@10

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edi, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [eax+4]
	jle	SHORT $LN2@Merge@10

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR __First2$[esp+4]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __First2$[esp+4], ecx

; 2516 : 		else

	jmp	SHORT $LN4@Merge@10
$LN2@Merge@10:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [ecx+8], edx
	mov	ecx, DWORD PTR __First2$[esp+4]
	add	eax, 12					; 0000000cH
$LN4@Merge@10:
	mov	edx, DWORD PTR __Dest$[esp+4]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[esp+4], edx
	cmp	eax, esi
	jne	SHORT $LL10@Merge@10
$LN3@Merge@10:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	BYTE PTR $T259196[esp+4], 0
	mov	ecx, DWORD PTR $T259196[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Cat$259201[esp+8]
	push	ecx
	mov	ecx, DWORD PTR $T259198[esp+12]
	push	ecx
	push	edx
	push	esi
	push	eax
	lea	edx, DWORD PTR $T259111[esp+28]
	push	edx
	call	??$_Copy_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	mov	eax, DWORD PTR $T259111[esp+32]

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+32]
	mov	DWORD PTR __Dest$[esp+32], eax
	mov	edx, DWORD PTR __Cat$259226[esp+32]
	mov	BYTE PTR $T259221[esp+32], 0
	mov	ecx, DWORD PTR $T259221[esp+32]
	push	ecx
	mov	ecx, DWORD PTR $T259223[esp+36]
	push	edx
	mov	edx, DWORD PTR __Last2$[esp+40]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __First2$[esp+48]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	pop	edi
	mov	eax, esi
	pop	esi

; 2521 : 	}

	ret	0
??$_Merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@V12@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0PAVCvTacticalCity@@10U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@V12@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0PAVCvTacticalCity@@10U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T259281 = -4						; size = 1
$T259256 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Cat$259286 = 16					; size = 1
$T259283 = 16						; size = 1
__Cat$259261 = 16					; size = 1
$T259258 = 16						; size = 1
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
___formal$ = 32						; size = 1
??$_Merge_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@V12@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0PAVCvTacticalCity@@10U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 2710 : 	{	// merge backwards to _Dest, using operator<

	push	ecx

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	edx, DWORD PTR __First1$[esp]
	mov	ecx, DWORD PTR __Last1$[esp]
	mov	eax, DWORD PTR __Last2$[esp]
	push	esi
	mov	esi, DWORD PTR __First2$[esp+4]
	push	edi
	cmp	edx, ecx
	je	SHORT $LN65@Merge_back@6
$LL8@Merge_back@6:

; 2714 : 		else if (_First2 == _Last2)

	cmp	esi, eax
	je	$LN66@Merge_back@6

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	edx, DWORD PTR [eax-8]
	sub	eax, 12					; 0000000cH
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR __Last1$[esp+8], ecx
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN2@Merge_back@6

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Dest$[esp+8]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[esp+8], edx
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edi+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+8], ecx

; 2718 : 		else

	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	eax, 12					; 0000000cH
	jmp	SHORT $LN61@Merge_back@6
$LN2@Merge_back@6:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ecx, DWORD PTR __Dest$[esp+8]
	mov	edx, DWORD PTR [eax]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[esp+8], ecx
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Last1$[esp+8], ecx
$LN61@Merge_back@6:
	mov	edx, DWORD PTR __First1$[esp+8]
	cmp	edx, ecx
	jne	SHORT $LL8@Merge_back@6
$LN65@Merge_back@6:

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Cat$259261[esp+8]
	mov	BYTE PTR $T259256[esp+12], 0
	mov	ecx, DWORD PTR $T259256[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T259258[esp+12]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	ecx
	push	edx
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+32]
	push	esi
	call	??$_Copy_backward_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2720 : 	}

	pop	ecx
	ret	0
$LN66@Merge_back@6:

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T259281[esp+12], 0
	mov	eax, DWORD PTR $T259281[esp+12]
	push	eax
	mov	eax, DWORD PTR __Cat$259286[esp+12]
	push	eax
	mov	eax, DWORD PTR $T259283[esp+16]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+20]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2720 : 	}

	pop	ecx
	ret	0
??$_Merge_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@V12@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0PAVCvTacticalCity@@10U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvBlockingUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvBlockingUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T259426 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
$T259502 = 24						; size = 1
$T259503 = 24						; size = 1
$T259427 = 24						; size = 1
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 4
___formal$ = 32						; size = 1
??$_Chunked_merge@PAVCvBlockingUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ecx

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edx, DWORD PTR __Count$[esp]
	mov	eax, DWORD PTR __Dest$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Chunk$[esp+4]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp+ebp]
	cmp	edi, edx
	jg	SHORT $LN3@Chunked_me@4
	shl	ebp, 4
	push	ebx
$LL50@Chunked_me@4:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	BYTE PTR $T259426[esp+20], 0
	mov	ebx, DWORD PTR $T259426[esp+20]
	push	ebx
	mov	ebx, DWORD PTR $T259427[esp+20]
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+24]
	push	ebx
	lea	edx, DWORD PTR [ecx+ebp]
	push	eax
	lea	esi, DWORD PTR [edx+ebp]
	push	esi
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),std::random_access_iterator_tag>
	mov	edx, DWORD PTR __Count$[esp+48]
	sub	edx, edi
	add	esp, 32					; 00000020H
	cmp	edx, edi

; 3443 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+16], edx
	jge	SHORT $LL50@Chunked_me@4
	mov	ebp, DWORD PTR __Chunk$[esp+16]
	pop	ebx
$LN3@Chunked_me@4:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	edx, ebp
	jg	SHORT $LN2@Chunked_me@4

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Last$[esp+12]
	cmp	ecx, edx
	je	SHORT $LN41@Chunked_me@4
	sub	eax, ecx
	npad	6
$LL32@Chunked_me@4:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+ecx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+ecx+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+ecx+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+ecx+12], esi
	add	ecx, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL32@Chunked_me@4
	pop	edi
	pop	esi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	pop	ecx
	ret	0
$LN2@Chunked_me@4:

; 3448 : 	else
; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	BYTE PTR $T259502[esp+12], 0
	mov	edx, DWORD PTR $T259502[esp+12]
	push	edx
	mov	edx, DWORD PTR $T259503[esp+16]
	push	edx
	mov	edx, DWORD PTR __Pred$[esp+20]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Last$[esp+28]
	push	eax
	shl	ebp, 4
	add	ebp, ecx
	push	ebp
	push	ebp
	push	ecx
	call	??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
$LN41@Chunked_me@4:
	pop	edi
	pop	esi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	pop	ecx
	ret	0
??$_Chunked_merge@PAVCvBlockingUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@000V12@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@000V12@@Z
_TEXT	SEGMENT
$T259520 = -4						; size = 1
$T259526 = -4						; size = 4
$T259522 = -4						; size = 4
$T259521 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@000V12@@Z PROC ; stdext::unchecked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T259526[esp+8], ebx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T259521[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T259520[esp+12], bl
	mov	eax, DWORD PTR $T259520[esp+12]
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+36]
	mov	ecx, DWORD PTR __First2$[esp+36]
	mov	edx, DWORD PTR __Last1$[esp+36]
	mov	DWORD PTR $T259522[esp+40], esp
	push	eax
	mov	eax, DWORD PTR __First1$[esp+40]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@0@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+56]
	add	esp, 48					; 00000030H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@20
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@20:
	mov	eax, esi

; 5117 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@000V12@@Z ENDP ; stdext::unchecked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@000V12@@Z ; stdext::unchecked_merge<CvTacticalUnit *,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@000V12@@Z
_TEXT	SEGMENT
$T259566 = -4						; size = 1
$T259567 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
??$unchecked_merge@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@000V12@@Z PROC ; stdext::unchecked_merge<CvTacticalUnit *,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T259567[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T259566[esp+8], 0
	mov	eax, DWORD PTR $T259566[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalUnit *,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
	mov	eax, esi
	pop	esi

; 5117 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@000V12@@Z ENDP ; stdext::unchecked_merge<CvTacticalUnit *,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00PAHPAVCvTacticalUnit@@@Z ; std::_Rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@000V12@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@000V12@@Z
_TEXT	SEGMENT
$T259584 = -4						; size = 1
$T259590 = -4						; size = 4
$T259586 = -4						; size = 4
$T259585 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@000V12@@Z PROC ; stdext::unchecked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T259590[esp+8], ebx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T259585[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T259584[esp+12], bl
	mov	eax, DWORD PTR $T259584[esp+12]
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+36]
	mov	ecx, DWORD PTR __First2$[esp+36]
	mov	edx, DWORD PTR __Last1$[esp+36]
	mov	DWORD PTR $T259586[esp+40], esp
	push	eax
	mov	eax, DWORD PTR __First1$[esp+40]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@0@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+56]
	add	esp, 48					; 00000030H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@21
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@21:
	mov	eax, esi

; 5117 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@000V12@@Z ENDP ; stdext::unchecked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@000V12@@Z ; stdext::unchecked_merge<CvTacticalCity *,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@000V12@@Z
_TEXT	SEGMENT
$T259630 = -4						; size = 1
$T259631 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
??$unchecked_merge@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@000V12@@Z PROC ; stdext::unchecked_merge<CvTacticalCity *,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T259631[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T259630[esp+8], 0
	mov	eax, DWORD PTR $T259630[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalCity *,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
	mov	eax, esi
	pop	esi

; 5117 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@000V12@@Z ENDP ; stdext::unchecked_merge<CvTacticalCity *,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00PAHPAVCvTacticalCity@@@Z ; std::_Rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@0@PAVCvTacticalMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalMove *,CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@0@PAVCvTacticalMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T259656 = -24						; size = 4
$T259649 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
$T259650 = 12						; size = 4
$T259648 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@0@PAVCvTacticalMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvTacticalMove *,CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	sub	esp, 24					; 00000018H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ecx, DWORD PTR __First1$[esp+20]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Last1$[esp+28]
	push	esi
	mov	esi, DWORD PTR __First2$[esp+32]
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T259656[esp+40], ebx
	cmp	ecx, ebp
	je	$LN3@Merge@11
	lea	edi, DWORD PTR [ebx+8]
$LL4@Merge@11:
	cmp	esi, DWORD PTR __Last2$[esp+36]
	je	$LN3@Merge@11

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR [esi+4]

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __Dest$[esp+52]
	cmp	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	jle	SHORT $LN2@Merge@11
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN21@Merge@11
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	DWORD PTR [eax+4], edi
	add	esi, edi

; 2516 : 		else

	jmp	SHORT $LN1@Merge@11

; 2515 : 			*_Dest = *_First2, ++_First2;

$LN21@Merge@11:
	cmp	eax, ebx
	je	SHORT $LN26@Merge@11
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Dest$[esp+52]
$LN26@Merge@11:
	add	DWORD PTR [edx+4], edi
	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
	add	esi, edi

; 2516 : 		else

	jmp	SHORT $LN1@Merge@11
$LN2@Merge@11:

; 2517 : 			*_Dest = *_First1, ++_First1;

	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN33@Merge@11
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	DWORD PTR [eax+4], edi
	jmp	SHORT $LN32@Merge@11
$LN33@Merge@11:
	cmp	eax, ebx
	je	SHORT $LN38@Merge@11
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Dest$[esp+52]
$LN38@Merge@11:
	add	DWORD PTR [edx+4], edi
	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN32@Merge@11:
	add	ecx, edi
$LN1@Merge@11:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	ecx, ebp
	jne	$LL4@Merge@11
$LN3@Merge@11:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR $T259648[esp+56], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	push	ecx
	lea	eax, DWORD PTR $T259649[esp+68]
	push	eax
	call	??$unchecked_copy@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@0V12@@Z ; stdext::unchecked_copy<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T259649[esp+72]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+52], ecx
	cmp	eax, ebx
	je	SHORT $LN56@Merge@11
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Merge@11:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+56]
	mov	DWORD PTR $T259650[esp+56], esp
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+64]
	push	esi
	call	??$unchecked_copy@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@0V12@@Z ; stdext::unchecked_copy<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
	mov	eax, DWORD PTR __Dest$[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN77@Merge@11
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN77@Merge@11:

; 2521 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@0@PAVCvTacticalMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvTacticalMove *,CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@0@PAVCvTacticalTarget@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalTarget *,CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@0@PAVCvTacticalTarget@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T259806 = -24						; size = 4
$T259799 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
$T259800 = 16						; size = 4
$T259798 = 16						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@0@PAVCvTacticalTarget@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvTacticalTarget *,CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	sub	esp, 24					; 00000018H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	edx, DWORD PTR __First1$[esp+20]
	mov	ecx, DWORD PTR __Last1$[esp+20]
	push	ebx
	mov	ebx, DWORD PTR __First2$[esp+24]
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T259806[esp+40], edi
	cmp	edx, ecx
	je	$LN3@Merge@12
	lea	ebp, DWORD PTR [edi+28]
$LL4@Merge@12:
	cmp	ebx, DWORD PTR __Last2$[esp+36]
	je	$LN3@Merge@12

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, DWORD PTR [edx+20]

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	edi, DWORD PTR [eax+4]
	jle	SHORT $LN2@Merge@12
	cmp	edi, DWORD PTR [eax+8]
	jae	SHORT $LN21@Merge@12
	mov	esi, ebx
	mov	ecx, 7
	rep movsd
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	DWORD PTR [eax+4], ebp
	add	ebx, ebp

; 2516 : 		else

	jmp	SHORT $LN1@Merge@12

; 2515 : 			*_Dest = *_First2, ++_First2;

$LN21@Merge@12:
	test	edi, edi
	je	SHORT $LN26@Merge@12
	mov	ecx, 7
	mov	esi, ebx
	rep movsd
	mov	eax, DWORD PTR __Dest$[esp+52]
$LN26@Merge@12:
	add	DWORD PTR [eax+4], ebp
	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], ecx
	add	ebx, ebp

; 2516 : 		else

	jmp	SHORT $LN1@Merge@12
$LN2@Merge@12:

; 2517 : 			*_Dest = *_First1, ++_First1;

	cmp	edi, DWORD PTR [eax+8]
	jae	SHORT $LN33@Merge@12
	mov	ecx, 7
	mov	esi, edx
	rep movsd
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	DWORD PTR [eax+4], ebp
	jmp	SHORT $LN32@Merge@12
$LN33@Merge@12:
	test	edi, edi
	je	SHORT $LN38@Merge@12
	mov	ecx, 7
	mov	esi, edx
	rep movsd
	mov	eax, DWORD PTR __Dest$[esp+52]
$LN38@Merge@12:
	add	DWORD PTR [eax+4], ebp
	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], ecx
$LN32@Merge@12:
	add	edx, ebp
$LN1@Merge@12:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ecx, DWORD PTR __Last1$[esp+36]
	xor	edi, edi
	cmp	edx, ecx
	jne	$LL4@Merge@12
$LN3@Merge@12:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T259798[esp+56], esp
	push	ecx
	push	edx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	esi, DWORD PTR __Dest$[esp+80]
	lea	edx, DWORD PTR $T259799[esp+68]
	push	edx
	mov	DWORD PTR [eax+16], esi
	call	??$unchecked_copy@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@0V12@@Z ; stdext::unchecked_copy<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[esp+84], eax
	mov	eax, DWORD PTR $T259799[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN56@Merge@12
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Merge@12:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Last2$[esp+36]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+36]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T259800[esp+56], esp
	push	edx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+76]
	push	ebx
	push	esi
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@0V12@@Z ; stdext::unchecked_copy<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
	mov	eax, DWORD PTR __Dest$[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN77@Merge@12
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN77@Merge@12:

; 2521 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@0@PAVCvTacticalTarget@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvTacticalTarget *,CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T259958 = -36						; size = 4
$T259951 = -32						; size = 20
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T259950 = 12						; size = 4
__First1$ = 12						; size = 4
$T259952 = 16						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 4
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	-1
	push	__ehhandler$??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T259958[esp+52], ebx
	mov	esi, DWORD PTR __First1$[esp+48]
	mov	edi, DWORD PTR __First2$[esp+48]
	mov	DWORD PTR __$EHRec$[esp+60], ebx
	cmp	esi, DWORD PTR __Last1$[esp+48]
	je	SHORT $LN58@Merge@13
	mov	ebp, DWORD PTR __Pred$[esp+48]
$LL4@Merge@13:
	cmp	edi, DWORD PTR __Last2$[esp+48]
	je	SHORT $LN58@Merge@13

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [edi+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	ebp
	add	esp, 32					; 00000020H

; 2599 : 			*_Dest = *_First2, ++_First2;

	lea	ecx, DWORD PTR __Dest$[esp+48]
	test	al, al
	je	SHORT $LN2@Merge@13
	push	edi
	call	??4?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@ABVCvBlockingUnit@@@Z ; std::_Temp_iterator<CvBlockingUnit>::operator=
	add	edi, 16					; 00000010H

; 2600 : 		else

	jmp	SHORT $LN1@Merge@13
$LN2@Merge@13:

; 2601 : 			*_Dest = *_First1, ++_First1;

	push	esi
	call	??4?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@ABVCvBlockingUnit@@@Z ; std::_Temp_iterator<CvBlockingUnit>::operator=
	add	esi, 16					; 00000010H
$LN1@Merge@13:

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	esi, DWORD PTR __Last1$[esp+48]
	jne	SHORT $LL4@Merge@13
$LN58@Merge@13:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	edx, DWORD PTR __Last1$[esp+48]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+84]
	mov	DWORD PTR $T259950[esp+68], esp
	push	edx
	mov	DWORD PTR [eax+16], ecx
	lea	eax, DWORD PTR $T259951[esp+76]
	push	esi
	push	eax
	call	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T259951[esp+84]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+64], ecx
	cmp	eax, ebx
	je	SHORT $LN34@Merge@13
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@Merge@13:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+48]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+84]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+68]
	mov	DWORD PTR $T259952[esp+68], esp
	push	eax
	push	edi
	push	esi
	call	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	mov	eax, DWORD PTR __Dest$[esp+80]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN55@Merge@13
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN55@Merge@13:

; 2605 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvBlockingUnit>::~_Temp_iterator<CvBlockingUnit>
__ehhandler$??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),std::forward_iterator_tag>
PUBLIC	??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T260055 = -24						; size = 4
$T260048 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
$T260049 = 12						; size = 4
$T260047 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ebp, DWORD PTR __Last1$[esp+28]
	push	esi
	mov	esi, DWORD PTR __First1$[esp+32]
	xor	ebx, ebx
	push	edi
	mov	edi, DWORD PTR __First2$[esp+36]
	mov	DWORD PTR $T260055[esp+40], ebx
	cmp	esi, ebp
	je	SHORT $LN3@Merge@14
	npad	3
$LL4@Merge@14:
	cmp	edi, DWORD PTR __Last2$[esp+36]
	je	SHORT $LN3@Merge@14

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [esi+4]

; 2515 : 			*_Dest = *_First2, ++_First2;

	lea	ecx, DWORD PTR __Dest$[esp+36]
	jge	SHORT $LN2@Merge@14
	push	edi
	call	??4?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@ABVCvBlockingUnit@@@Z ; std::_Temp_iterator<CvBlockingUnit>::operator=
	add	edi, 16					; 00000010H

; 2516 : 		else

	jmp	SHORT $LN1@Merge@14
$LN2@Merge@14:

; 2517 : 			*_Dest = *_First1, ++_First1;

	push	esi
	call	??4?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEAAV01@ABVCvBlockingUnit@@@Z ; std::_Temp_iterator<CvBlockingUnit>::operator=
	add	esi, 16					; 00000010H
$LN1@Merge@14:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	esi, ebp
	jne	SHORT $LL4@Merge@14
$LN3@Merge@14:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T260047[esp+56], esp
	push	ebp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+76]
	lea	edx, DWORD PTR $T260048[esp+64]
	push	esi
	push	edx
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[esp+84], eax
	mov	eax, DWORD PTR $T260048[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN36@Merge@14
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN36@Merge@14:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Last2$[esp+36]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+36]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T260049[esp+56], esp
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+76]
	push	edi
	push	esi
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	mov	eax, DWORD PTR __Dest$[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN57@Merge@14
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Merge@14:

; 2521 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@4
	pop	esi
$LN9@Uninit_fil@4:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@5
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?Read@CvTacticalAI@@QAEXAAVFDataStream@@@Z	; CvTacticalAI::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
;	COMDAT ?Read@CvTacticalAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_phony$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvTacticalAI@@QAEXAAVFDataStream@@@Z PROC		; CvTacticalAI::Read, COMDAT
; _this$ = ecx

; 337  : {

	push	ecx
	push	esi

; 338  : 	// Version number to maintain backwards compatibility
; 339  : 	uint uiVersion;
; 340  : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+4]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 341  : 
; 342  : 	int phony = 0;
; 343  : 	kStream >> phony;

	lea	ecx, DWORD PTR _phony$[esp+8]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _phony$[esp+12], 0
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 344  : 	kStream >> m_TempZones;

	add	edi, 26380				; 0000670cH
	push	edi
	push	esi
	call	??$?5VCvTemporaryZone@@$09$00$0BCJ@$0A@@@YAAAVFDataStream@@AAV0@AAV?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@@Z ; operator>><CvTemporaryZone,10,1,297,0>
	add	esp, 8
	pop	edi
	pop	esi

; 345  : }

	pop	ecx
	ret	4
?Read@CvTacticalAI@@QAEXAAVFDataStream@@@Z ENDP		; CvTacticalAI::Read
_TEXT	ENDS
PUBLIC	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z ; CvTacticalAI::AddTemporaryZone
; Function compile flags: /Ogtpy
;	COMDAT ?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z
_TEXT	SEGMENT
_zone$ = 8						; size = 20
?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z PROC ; CvTacticalAI::AddTemporaryZone, COMDAT
; _this$ = ecx

; 467  : 	m_TempZones.push_back(zone);

	lea	eax, DWORD PTR _zone$[esp-4]
	push	eax
	add	ecx, 26380				; 0000670cH
	call	?push_back@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEIABVCvTemporaryZone@@@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::push_back

; 468  : }

	ret	20					; 00000014H
?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z ENDP ; CvTacticalAI::AddTemporaryZone
_TEXT	ENDS
PUBLIC	?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z ; CvTacticalAI::DeleteTemporaryZone
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z$0
__ehfuncinfo$?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_zonesCopy$ = -228					; size = 216
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z PROC ; CvTacticalAI::DeleteTemporaryZone, COMDAT
; _this$ = ecx

; 472  : {

	push	-1
	push	__ehhandler$?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 216				; 000000d8H
	push	ebx

; 473  : 	FStaticVector<CvTemporaryZone, SAFE_ESTIMATE_NUM_TEMP_ZONES, true, c_eCiv5GameplayDLL, 0> zonesCopy;

	xor	ebx, ebx
	lea	eax, DWORD PTR _zonesCopy$[esp+244]
	push	edi
	mov	DWORD PTR _zonesCopy$[esp+240], ebx
	mov	DWORD PTR _zonesCopy$[esp+244], 10	; 0000000aH
	mov	DWORD PTR _zonesCopy$[esp+236], eax

; 474  : 
; 475  : 	// Copy zones over
; 476  : 	zonesCopy = m_TempZones;

	lea	edi, DWORD PTR [ecx+26380]
	push	edi
	lea	ecx, DWORD PTR _zonesCopy$[esp+240]
	mov	DWORD PTR __$EHRec$[esp+248], ebx
	call	??4?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::operator=

; 477  : 
; 478  : 	m_TempZones.clear();

	mov	DWORD PTR [edi+4], ebx

; 479  : 
; 480  : 	// Copy back to original vector any whose coords don't match
; 481  : 	for(unsigned int iI = 0; iI < zonesCopy.size(); iI++)

	cmp	DWORD PTR _zonesCopy$[esp+240], ebx
	jbe	$LN64@DeleteTemp
	push	ebp
	push	esi
	xor	ebp, ebp
	npad	5
$LL5@DeleteTemp:

; 482  : 	{
; 483  : 		if(zonesCopy[iI].GetX() != pPlot->getX() ||
; 484  : 		        zonesCopy[iI].GetY() != pPlot->getY())

	mov	ecx, DWORD PTR _zonesCopy$[esp+244]
	mov	eax, DWORD PTR [ecx+ebp]
	lea	esi, DWORD PTR [ecx+ebp]
	mov	ecx, DWORD PTR _pPlot$[esp+240]
	movsx	edx, WORD PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN1@DeleteTemp
	movsx	ecx, WORD PTR [ecx+2]
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, ecx
	je	SHORT $LN4@DeleteTemp
$LN1@DeleteTemp:

; 485  : 		{
; 486  : 			m_TempZones.push_back(zonesCopy[iI]);

	mov	eax, DWORD PTR [edi+8]
	mov	BYTE PTR [edi+212], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN66@DeleteTemp
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::GrowSize
$LN66@DeleteTemp:
	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN44@DeleteTemp
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], ecx
$LN44@DeleteTemp:
	inc	DWORD PTR [edi+4]
$LN4@DeleteTemp:

; 479  : 
; 480  : 	// Copy back to original vector any whose coords don't match
; 481  : 	for(unsigned int iI = 0; iI < zonesCopy.size(); iI++)

	inc	ebx
	add	ebp, 20					; 00000014H
	cmp	ebx, DWORD PTR _zonesCopy$[esp+248]
	jb	SHORT $LL5@DeleteTemp
	pop	esi
	pop	ebp
$LN64@DeleteTemp:

; 487  : 		}
; 488  : 	}
; 489  : }

	mov	eax, DWORD PTR _zonesCopy$[esp+236]
	lea	edx, DWORD PTR _zonesCopy$[esp+248]
	pop	edi
	mov	DWORD PTR __$EHRec$[esp+240], -1
	pop	ebx
	cmp	eax, edx
	je	SHORT $LN50@DeleteTemp
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN50@DeleteTemp:
	mov	ecx, DWORD PTR __$EHRec$[esp+228]
	mov	DWORD PTR fs:0, ecx
	add	esp, 228				; 000000e4H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _zonesCopy$[ebp]
	jmp	??1?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTemporaryZone,10,1,297,0>::~FStaticVector<CvTemporaryZone,10,1,297,0>
__ehhandler$?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z ENDP ; CvTacticalAI::DeleteTemporaryZone
PUBLIC	?DropObsoleteZones@CvTacticalAI@@QAEXXZ		; CvTacticalAI::DropObsoleteZones
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DropObsoleteZones@CvTacticalAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DropObsoleteZones@CvTacticalAI@@QAEXXZ$0
__ehfuncinfo$?DropObsoleteZones@CvTacticalAI@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DropObsoleteZones@CvTacticalAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?DropObsoleteZones@CvTacticalAI@@QAEXXZ
_TEXT	SEGMENT
_zonesCopy$ = -228					; size = 216
__$EHRec$ = -12						; size = 12
?DropObsoleteZones@CvTacticalAI@@QAEXXZ PROC		; CvTacticalAI::DropObsoleteZones, COMDAT
; _this$ = ecx

; 493  : {

	push	-1
	push	__ehhandler$?DropObsoleteZones@CvTacticalAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 216				; 000000d8H
	push	ebx

; 494  : 	FStaticVector<CvTemporaryZone, SAFE_ESTIMATE_NUM_TEMP_ZONES, true, c_eCiv5GameplayDLL, 0> zonesCopy;

	xor	ebx, ebx
	lea	eax, DWORD PTR _zonesCopy$[esp+244]
	push	esi
	mov	DWORD PTR _zonesCopy$[esp+240], ebx
	mov	DWORD PTR _zonesCopy$[esp+244], 10	; 0000000aH
	mov	DWORD PTR _zonesCopy$[esp+236], eax

; 495  : 
; 496  : 	// Copy zones over
; 497  : 	zonesCopy = m_TempZones;

	lea	esi, DWORD PTR [ecx+26380]
	push	esi
	lea	ecx, DWORD PTR _zonesCopy$[esp+240]
	mov	DWORD PTR __$EHRec$[esp+248], ebx
	call	??4?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::operator=

; 498  : 
; 499  : 	m_TempZones.clear();

	mov	DWORD PTR [esi+4], ebx

; 500  : 
; 501  : 	// Copy back to original vector any that haven't expired
; 502  : 	for(unsigned int iI = 0; iI < zonesCopy.size(); iI++)

	cmp	DWORD PTR _zonesCopy$[esp+240], ebx
	jbe	SHORT $LN58@DropObsole
	push	ebp
	push	edi
	xor	ebp, ebp
	npad	9
$LL4@DropObsole:

; 503  : 	{
; 504  : 		if(zonesCopy[iI].GetLastTurn() >= GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR _zonesCopy$[esp+244]
	mov	edi, DWORD PTR [ecx+ebp+12]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	edi, eax
	jl	SHORT $LN3@DropObsole

; 505  : 		{
; 506  : 			m_TempZones.push_back(zonesCopy[iI]);

	mov	eax, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _zonesCopy$[esp+244]
	lea	edi, DWORD PTR [edx+ebp]
	mov	BYTE PTR [esi+212], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN34@DropObsole
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTemporaryZone,10,1,297,0>::GrowSize
$LN34@DropObsole:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN37@DropObsole
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edi+16]
	mov	DWORD PTR [eax+16], edx
$LN37@DropObsole:
	inc	DWORD PTR [esi+4]
$LN3@DropObsole:

; 500  : 
; 501  : 	// Copy back to original vector any that haven't expired
; 502  : 	for(unsigned int iI = 0; iI < zonesCopy.size(); iI++)

	inc	ebx
	add	ebp, 20					; 00000014H
	cmp	ebx, DWORD PTR _zonesCopy$[esp+248]
	jb	SHORT $LL4@DropObsole
	pop	edi
	pop	ebp
$LN58@DropObsole:

; 507  : 		}
; 508  : 	}
; 509  : }

	mov	eax, DWORD PTR _zonesCopy$[esp+236]
	lea	ecx, DWORD PTR _zonesCopy$[esp+248]
	pop	esi
	mov	DWORD PTR __$EHRec$[esp+240], -1
	pop	ebx
	cmp	eax, ecx
	je	SHORT $LN43@DropObsole
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN43@DropObsole:
	mov	ecx, DWORD PTR __$EHRec$[esp+228]
	mov	DWORD PTR fs:0, ecx
	add	esp, 228				; 000000e4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DropObsoleteZones@CvTacticalAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _zonesCopy$[ebp]
	jmp	??1?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTemporaryZone,10,1,297,0>::~FStaticVector<CvTemporaryZone,10,1,297,0>
__ehhandler$?DropObsoleteZones@CvTacticalAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DropObsoleteZones@CvTacticalAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DropObsoleteZones@CvTacticalAI@@QAEXXZ ENDP		; CvTacticalAI::DropObsoleteZones
PUBLIC	?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z ; CvTacticalAI::LaunchAttack
PUBLIC	?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z	; CvTacticalAI::CombatResolved
EXTRN	?isOutOfAttacks@CvUnit@@QBE_NXZ:PROC		; CvUnit::isOutOfAttacks
EXTRN	?canMoveAfterAttacking@CvUnit@@QBE_NXZ:PROC	; CvUnit::canMoveAfterAttacking
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z$2
__ehfuncinfo$?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z
_TEXT	SEGMENT
_pUnit$ = -72						; size = 8
_pAbortUnit$220577 = -64				; size = 8
$T260637 = -64						; size = 8
_kAttack$220584 = -56					; size = 40
__$EHRec$ = -12						; size = 12
_pAttacker$ = 8						; size = 4
_bVictorious$ = 12					; size = 1
$T260649 = 16						; size = 4
$T260647 = 16						; size = 4
_iSeriesID$ = 16					; size = 4
_bCityAttack$ = 16					; size = 1
?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z PROC		; CvTacticalAI::CombatResolved, COMDAT
; _this$ = ecx

; 683  : {

	push	-1
	push	__ehhandler$?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp

; 684  : 	int iSeriesID = 0;
; 685  : 	bool bFoundIt = false;
; 686  : 
; 687  : 	CvCity* pCity = NULL;
; 688  : 	UnitHandle pUnit;

	xor	eax, eax
	push	esi
	push	edi
	mov	ebp, ecx
	mov	DWORD PTR _pUnit$[esp+88], eax
	mov	BYTE PTR _pUnit$[esp+92], al

; 689  : 
; 690  : 	if(bCityAttack)

	mov	bl, BYTE PTR _bCityAttack$[esp+84]
	mov	edi, DWORD PTR _pAttacker$[esp+84]
	mov	DWORD PTR __$EHRec$[esp+96], eax
	test	bl, bl
	jne	SHORT $LN408@CombatReso

; 691  : 	{
; 692  : 		pCity = (CvCity*)pAttacker;
; 693  : 	}
; 694  : 	else
; 695  : 	{
; 696  : 		pUnit = UnitHandle((CvUnit*)pAttacker);

	mov	DWORD PTR $T260637[esp+88], edi
	mov	BYTE PTR $T260637[esp+92], al
	cmp	edi, eax
	je	SHORT $LN27@CombatReso
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN27@CombatReso:
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR _pUnit$[esp+88], edi
	test	edi, edi
	je	SHORT $LN36@CombatReso
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN36@CombatReso:
	mov	BYTE PTR __$EHRec$[esp+96], 0
	test	edi, edi
	je	SHORT $LN408@CombatReso
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN408@CombatReso:

; 697  : 	}
; 698  : 
; 699  : 	if(m_QueuedAttacks.size() > 0)

	mov	eax, DWORD PTR [ebp+2144]
	test	eax, eax
	jbe	$LN1@CombatReso

; 700  : 	{
; 701  : 		std::list<CvQueuedAttack>::iterator nextToErase, nextInList;
; 702  : 		nextToErase = m_QueuedAttacks.begin();

	mov	eax, DWORD PTR [ebp+2140]
	mov	esi, DWORD PTR [eax]

; 703  : 
; 704  : 		// Find first attack with this unit/city
; 705  : 		while(nextToErase != m_QueuedAttacks.end())

	cmp	esi, eax
	je	$LN1@CombatReso
	npad	3
$LL13@CombatReso:

; 706  : 		{
; 707  : 			if(nextToErase->GetAttacker() == pAttacker)

	cmp	DWORD PTR [esi+8], edi
	je	SHORT $LN404@CombatReso

; 710  : 				bFoundIt = true;
; 711  : 				break;
; 712  : 			}
; 713  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 714  : 			++nextToErase;
; 715  : #else
; 716  : 			nextToErase++;

	mov	esi, DWORD PTR [esi]
	cmp	esi, eax
	jne	SHORT $LL13@CombatReso

; 706  : 		{
; 707  : 			if(nextToErase->GetAttacker() == pAttacker)

	jmp	$LN1@CombatReso
$LN404@CombatReso:

; 708  : 			{
; 709  : 				iSeriesID = nextToErase->GetSeriesID();

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR _iSeriesID$[esp+84], eax

; 717  : #endif
; 718  : 		}
; 719  : 
; 720  : 		// Couldn't find it ... could have been an accidental attack moving to deploy near a target
; 721  : 		// So safe to ignore these
; 722  : 		if(!bFoundIt)
; 723  : 		{
; 724  : 			return;
; 725  : 		}
; 726  : 
; 727  : 		// If this attacker gets multiple attacks, release him to be processed again
; 728  : 		if(!bCityAttack && (pUnit->canMoveAfterAttacking() || !pUnit->isOutOfAttacks()) && pUnit->getMoves() > 0)

	test	bl, bl
	jne	SHORT $LN409@CombatReso
	mov	ecx, DWORD PTR _pUnit$[esp+88]
	call	?canMoveAfterAttacking@CvUnit@@QBE_NXZ	; CvUnit::canMoveAfterAttacking
	test	al, al
	jne	SHORT $LN8@CombatReso
	mov	ecx, DWORD PTR _pUnit$[esp+88]
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	jne	SHORT $LN409@CombatReso
$LN8@CombatReso:
	mov	ecx, DWORD PTR _pUnit$[esp+88]
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jle	SHORT $LN409@CombatReso

; 729  : 		{
; 730  : 			pUnit->SetTurnProcessed(false);

	mov	ecx, DWORD PTR _pUnit$[esp+88]
	push	0
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN409@CombatReso:

; 731  : 		}
; 732  : 
; 733  : 		// If victorious, dump follow-up attacks
; 734  : 		if(bVictorious)

	cmp	BYTE PTR _bVictorious$[esp+84], 0
	je	$LN7@CombatReso

; 735  : 		{
; 736  : 			bool bFirst = true;

	mov	al, 1

; 737  : 			while(nextToErase != m_QueuedAttacks.end() && nextToErase->GetSeriesID() == iSeriesID)

	cmp	esi, DWORD PTR [ebp+2140]
	je	$LN1@CombatReso
	mov	bl, 2
	npad	8
$LL6@CombatReso:
	mov	ecx, DWORD PTR _iSeriesID$[esp+84]
	cmp	DWORD PTR [esi+40], ecx
	jne	$LN1@CombatReso

; 738  : 			{
; 739  : 				// Only the first unit being erased is done for the turn
; 740  : 				if(!bFirst && !nextToErase->IsCityAttack())

	test	al, al
	jne	SHORT $LN411@CombatReso
	cmp	BYTE PTR [esi+45], al
	jne	SHORT $LN411@CombatReso

; 741  : 				{
; 742  : 					UnitHandle pAbortUnit((CvUnit*)nextToErase->GetAttacker());

	mov	edi, DWORD PTR [esi+8]
	mov	DWORD PTR _pAbortUnit$220577[esp+88], edi
	mov	BYTE PTR _pAbortUnit$220577[esp+92], al
	test	edi, edi
	je	SHORT $LN155@CombatReso
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN155@CombatReso:

; 743  : 					pAbortUnit->SetTurnProcessed(false);

	push	0
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+100], bl
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed

; 744  : 				}

	mov	BYTE PTR __$EHRec$[esp+96], 0
	test	edi, edi
	je	SHORT $LN411@CombatReso
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN411@CombatReso:

; 745  : 				nextToErase = m_QueuedAttacks.erase(nextToErase);

	mov	edi, DWORD PTR [esi]
	cmp	esi, DWORD PTR [ebp+2140]
	je	SHORT $LN164@CombatReso
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], edi
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	push	esi
	mov	DWORD PTR [edx+4], eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	dec	DWORD PTR [ebp+2144]
$LN164@CombatReso:

; 746  : 				bFirst = false;

	xor	al, al
	mov	esi, edi
	cmp	edi, DWORD PTR [ebp+2140]
	jne	SHORT $LL6@CombatReso

; 747  : 			}
; 748  : 		}
; 749  : 
; 750  : 		// Otherwise look for a follow-up attack
; 751  : 		else

	jmp	SHORT $LN1@CombatReso
$LN7@CombatReso:

; 752  : 		{
; 753  : 			nextInList = nextToErase;
; 754  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 755  : 			++nextInList;
; 756  : #else
; 757  : 			nextInList++;

	mov	eax, DWORD PTR [esi]

; 758  : #endif
; 759  : 
; 760  : 			// Matching IDs, we have a follow-up attack
; 761  : 			if(nextInList != m_QueuedAttacks.end() && nextInList->GetSeriesID() == nextToErase->GetSeriesID())

	cmp	eax, DWORD PTR [ebp+2140]
	je	SHORT $LN2@CombatReso
	mov	ecx, DWORD PTR [eax+40]
	cmp	ecx, DWORD PTR [esi+40]
	jne	SHORT $LN2@CombatReso

; 762  : 			{
; 763  : 				// Calling LaunchAttack can be recursive if the launched combat is resolved immediately.
; 764  : 				// We'll make a copy of the iterator's contents before erasing.  This is not technically needed because
; 765  : 				// the current queue is a std::list and iterators don't invalidate on erase, but we'll be safe, in case
; 766  : 				// the container type changes.
; 767  : 				CvQueuedAttack kAttack(*nextInList);

	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR _kAttack$220584[esp+92]
	call	??0CvQueuedAttack@@QAE@ABV0@@Z		; CvQueuedAttack::CvQueuedAttack

; 768  : 				m_QueuedAttacks.erase(nextToErase);

	push	esi
	lea	ecx, DWORD PTR $T260647[esp+88]
	push	ecx
	lea	ecx, DWORD PTR [ebp+2136]
	call	?erase@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::erase

; 769  : 				LaunchAttack(kAttack.GetAttacker(), kAttack.GetTarget(), false /*bFirst*/, kAttack.IsRanged(), kAttack.IsCityAttack());

	mov	edx, DWORD PTR _kAttack$220584[esp+125]
	mov	eax, DWORD PTR _kAttack$220584[esp+124]
	push	edx
	mov	edx, DWORD PTR _kAttack$220584[esp+92]
	push	eax
	push	0
	lea	ecx, DWORD PTR _kAttack$220584[esp+104]
	push	ecx
	push	edx
	mov	ecx, ebp
	call	?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z ; CvTacticalAI::LaunchAttack

; 770  : 			}
; 771  : 			else

	jmp	SHORT $LN1@CombatReso
$LN2@CombatReso:

; 772  : 			{
; 773  : 				m_QueuedAttacks.erase(nextToErase);

	push	esi
	lea	eax, DWORD PTR $T260649[esp+88]
	push	eax
	lea	ecx, DWORD PTR [ebp+2136]
	call	?erase@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::erase
$LN1@CombatReso:

; 774  : 			}
; 775  : 		}
; 776  : 	}
; 777  : 
; 778  : 	return;

	mov	ecx, DWORD PTR _pUnit$[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	test	ecx, ecx
	je	SHORT $LN400@CombatReso
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN400@CombatReso:

; 779  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z$1:
	lea	ecx, DWORD PTR $T260637[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z$2:
	lea	ecx, DWORD PTR _pAbortUnit$220577[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z:
	mov	eax, OFFSET __ehfuncinfo$?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z ENDP		; CvTacticalAI::CombatResolved
PUBLIC	?UpdatePostures@CvTacticalAI@@AAEXXZ		; CvTacticalAI::UpdatePostures
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?UpdatePostures@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePostures@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?UpdatePostures@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UpdatePostures@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?UpdatePostures@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_iCityID$220673 = -60					; size = 4
_iI$220668 = -56					; size = 4
$T261480 = -52						; size = 12
_szPostureMsg$220677 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?UpdatePostures@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::UpdatePostures, COMDAT
; _this$ = ecx

; 874  : {

	push	-1
	push	__ehhandler$?UpdatePostures@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebp
	mov	ebp, ecx

; 875  : 	CvTacticalDominanceZone* pZone;
; 876  : 	AITacticalPosture eLastPosture, eNewPosture;
; 877  : 
; 878  : 	m_NewPostures.clear();

	xor	eax, eax
	push	edi
	lea	edi, DWORD PTR [ebp+25592]
	mov	DWORD PTR [edi+4], eax

; 879  : 
; 880  : 	// Loop through all the zones we have this turn
; 881  : 	for(int iI = 0; iI < m_pMap->GetNumZones(); iI++)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+116], eax
	mov	DWORD PTR _iI$220668[esp+68], eax
	jle	$LN15@UpdatePost
	push	ebx
	push	esi
	npad	7
$LL17@UpdatePost:

; 882  : 	{
; 883  : 		pZone = m_pMap->GetZone(iI);

	push	eax
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
	mov	esi, eax

; 884  : 
; 885  : 		// Check to make sure we want to use this zone
; 886  : 		if(UseThisDominanceZone(pZone))

	push	esi
	mov	ecx, ebp
	call	?UseThisDominanceZone@CvTacticalAI@@AAE_NPAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::UseThisDominanceZone
	test	al, al
	je	$LN16@UpdatePost

; 887  : 		{
; 888  : 			int iCityID = -1;
; 889  : 			if(pZone->GetClosestCity() != NULL)

	mov	ecx, esi
	mov	DWORD PTR _iCityID$220673[esp+76], -1
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	test	eax, eax
	je	SHORT $LN33@UpdatePost

; 890  : 			{
; 891  : 				iCityID = pZone->GetClosestCity()->GetID();

	mov	ecx, esi
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	eax, DWORD PTR [eax+120]
	mov	DWORD PTR _iCityID$220673[esp+76], eax
$LN33@UpdatePost:

; 892  : 			}
; 893  : 
; 894  : 			eLastPosture = FindPosture(pZone);

	push	esi
	mov	ecx, ebp
	call	?FindPosture@CvTacticalAI@@AAE?AW4AITacticalPosture@@PAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::FindPosture

; 895  : 			eNewPosture = SelectPosture(pZone, eLastPosture);

	push	eax
	push	esi
	mov	ecx, ebp
	call	?SelectPosture@CvTacticalAI@@AAE?AW4AITacticalPosture@@PAVCvTacticalDominanceZone@@W42@@Z ; CvTacticalAI::SelectPosture

; 896  : 			m_NewPostures.push_back(CvTacticalPosture(pZone->GetOwner(), pZone->IsWater(), iCityID, eNewPosture));

	mov	ecx, DWORD PTR [esi+12]
	mov	ebx, eax
	mov	al, BYTE PTR [esi+68]
	movzx	edx, al
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR $T261480[esp+76], eax
	mov	eax, DWORD PTR [edi+8]
	mov	BYTE PTR [edi+780], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN43@UpdatePost
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalPosture,64,1,297,0>::GrowSize
$LN43@UpdatePost:
	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	je	SHORT $LN46@UpdatePost
	mov	ecx, DWORD PTR $T261480[esp+76]
	mov	edx, DWORD PTR _iCityID$220673[esp+76]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ebx
$LN46@UpdatePost:
	inc	DWORD PTR [edi+4]

; 897  : 
; 898  : 			if(GC.getLogging() && GC.getAILogging() && eNewPosture != AI_TACTICAL_POSTURE_NONE)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN16@UpdatePost
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN16@UpdatePost
	cmp	ebx, -1
	je	$LN16@UpdatePost

; 899  : 			{
; 900  : 				CvString szPostureMsg;

	lea	ecx, DWORD PTR _szPostureMsg$220677[esp+76]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 901  : 				szPostureMsg.Format("Zone ID: %d, ", pZone->GetDominanceZoneID());

	mov	esi, DWORD PTR [esi]
	push	esi
	lea	eax, DWORD PTR _szPostureMsg$220677[esp+80]
	push	OFFSET $SG220678
	push	eax
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 902  : 				switch(eNewPosture)

	cmp	ebx, 8
	ja	SHORT $LN10@UpdatePost
	jmp	DWORD PTR $LN72@UpdatePost[ebx*4]
$LN9@UpdatePost:

; 903  : 				{
; 904  : 				case AI_TACTICAL_POSTURE_SIT_AND_BOMBARD:
; 905  : 					szPostureMsg += "Sit and Bombard";

	push	OFFSET $SG220684

; 906  : 					break;

	jmp	SHORT $LN71@UpdatePost
$LN8@UpdatePost:

; 907  : 				case AI_TACTICAL_POSTURE_ATTRIT_FROM_RANGE:
; 908  : 					szPostureMsg += "Attrit from Range";

	push	OFFSET $SG220686

; 909  : 					break;

	jmp	SHORT $LN71@UpdatePost
$LN7@UpdatePost:

; 910  : 				case AI_TACTICAL_POSTURE_EXPLOIT_FLANKS:
; 911  : 					szPostureMsg += "Exploit Flanks";

	push	OFFSET $SG220688

; 912  : 					break;

	jmp	SHORT $LN71@UpdatePost
$LN6@UpdatePost:

; 913  : 				case AI_TACTICAL_POSTURE_STEAMROLL:
; 914  : 					szPostureMsg += "Steamroll";

	push	OFFSET $SG220690

; 915  : 					break;

	jmp	SHORT $LN71@UpdatePost
$LN5@UpdatePost:

; 916  : 				case AI_TACTICAL_POSTURE_SURGICAL_CITY_STRIKE:
; 917  : 					szPostureMsg += "Surgical City Strike";

	push	OFFSET $SG220692

; 918  : 					break;

	jmp	SHORT $LN71@UpdatePost
$LN4@UpdatePost:

; 919  : 				case AI_TACTICAL_POSTURE_HEDGEHOG:
; 920  : 					szPostureMsg += "Hedgehog";

	push	OFFSET $SG220694

; 921  : 					break;

	jmp	SHORT $LN71@UpdatePost
$LN3@UpdatePost:

; 922  : 				case AI_TACTICAL_POSTURE_COUNTERATTACK:
; 923  : 					szPostureMsg += "Counterattack";

	push	OFFSET $SG220696

; 924  : 					break;

	jmp	SHORT $LN71@UpdatePost
$LN2@UpdatePost:

; 925  : 				case AI_TACTICAL_POSTURE_WITHDRAW:
; 926  : 					szPostureMsg += "Withdraw";

	push	OFFSET $SG220698

; 927  : 					break;

	jmp	SHORT $LN71@UpdatePost
$LN1@UpdatePost:

; 928  : 				case AI_TACTICAL_POSTURE_SHORE_BOMBARDMENT:
; 929  : 					szPostureMsg += "Shore Bombardment";

	push	OFFSET $SG220700
$LN71@UpdatePost:
	lea	ecx, DWORD PTR _szPostureMsg$220677[esp+80]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN10@UpdatePost:

; 930  : 					break;
; 931  : 				}
; 932  : 				LogTacticalMessage(szPostureMsg);

	push	1
	lea	ecx, DWORD PTR _szPostureMsg$220677[esp+80]
	push	ecx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 933  : 			}

	lea	ecx, DWORD PTR _szPostureMsg$220677[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN16@UpdatePost:
	mov	eax, DWORD PTR _iI$220668[esp+76]
	mov	ecx, DWORD PTR [ebp+4]
	inc	eax
	cmp	eax, DWORD PTR [ecx+116]
	mov	DWORD PTR _iI$220668[esp+76], eax
	jl	$LL17@UpdatePost
	pop	esi
	pop	ebx
$LN15@UpdatePost:

; 934  : 		}
; 935  : 	}
; 936  : 
; 937  : 	// New postures become current ones
; 938  : 	m_Postures.clear();
; 939  : 	m_Postures = m_NewPostures;

	push	edi
	lea	ecx, DWORD PTR [ebp+24808]
	mov	DWORD PTR [ebp+24812], 0
	call	??4?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvTacticalPosture,64,1,297,0>::operator=

; 940  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 60					; 0000003cH
	ret	0
	npad	2
$LN72@UpdatePost:
	DD	$LN2@UpdatePost
	DD	$LN9@UpdatePost
	DD	$LN8@UpdatePost
	DD	$LN7@UpdatePost
	DD	$LN6@UpdatePost
	DD	$LN5@UpdatePost
	DD	$LN4@UpdatePost
	DD	$LN3@UpdatePost
	DD	$LN1@UpdatePost
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdatePostures@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _szPostureMsg$220677[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?UpdatePostures@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?UpdatePostures@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdatePostures@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::UpdatePostures
PUBLIC	?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ; CvTacticalAI::MoveWithFormation
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z$0
__ehfuncinfo$?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_ePosition$ = 16					; size = 4
?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z PROC ; CvTacticalAI::MoveWithFormation, COMDAT
; _this$ = ecx

; 4933 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 4934 : 	if(pUnit->getMoves() > 0)

	mov	ecx, DWORD PTR _pUnit$[esp+20]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jle	SHORT $LN31@MoveWithFo

; 4935 : 	{
; 4936 : 		CvOperationUnit operationUnit;
; 4937 : 		operationUnit.SetUnitID(pUnit->GetID());

	mov	eax, DWORD PTR _pUnit$[esp+20]
	mov	edi, DWORD PTR [eax+100]

; 4938 : 		operationUnit.SetPosition(ePosition);
; 4939 : 		m_OperationUnits.push_back(operationUnit);

	mov	eax, DWORD PTR [esi+28652]
	mov	ebp, DWORD PTR _ePosition$[esp+20]
	add	esi, 28644				; 00006fe4H
	mov	BYTE PTR [esi+172], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN19@MoveWithFo
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::GrowSize
$LN19@MoveWithFo:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN22@MoveWithFo
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebp
$LN22@MoveWithFo:
	inc	DWORD PTR [esi+4]
$LN31@MoveWithFo:

; 4940 : 	}
; 4941 : }

	mov	ecx, DWORD PTR _pUnit$[esp+20]
	mov	DWORD PTR __$EHRec$[esp+32], -1
	test	ecx, ecx
	je	SHORT $LN29@MoveWithFo
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN29@MoveWithFo:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ENDP ; CvTacticalAI::MoveWithFormation
PUBLIC	?ScoreDeploymentPlots@CvTacticalAI@@AAE_NPAVCvPlot@@PAVCvArmyAI@@HHH@Z ; CvTacticalAI::ScoreDeploymentPlots
EXTRN	?IsAllOceanGoing@CvArmyAI@@QAE_NXZ:PROC		; CvArmyAI::IsAllOceanGoing
EXTRN	?GetAIMapHint@CvMap@@QAEHXZ:PROC		; CvMap::GetAIMapHint
EXTRN	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z:PROC ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
EXTRN	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z:PROC ; CvPlayer::getAIOperation
; Function compile flags: /Ogtpy
;	COMDAT ?ScoreDeploymentPlots@CvTacticalAI@@AAE_NPAVCvPlot@@PAVCvArmyAI@@HHH@Z
_TEXT	SEGMENT
_bValid$222782 = -59					; size = 1
_bForcedToUseWater$ = -58				; size = 1
_bSafeForDeployment$ = -57				; size = 1
_this$ = -56						; size = 4
_iDX$ = -52						; size = 4
_iNumSafePlotsFound$ = -48				; size = 4
_iNumDeployPlotsFound$ = -44				; size = 4
_iDY$ = -40						; size = 4
tv523 = -36						; size = 4
_iPlotDistance$222778 = -36				; size = 4
tv514 = -32						; size = 4
_target$ = -28						; size = 28
_pTarget$ = 8						; size = 4
_pArmy$ = 12						; size = 4
_iNumMeleeUnits$ = 16					; size = 4
_iNumRangedUnits$ = 20					; size = 4
_iRange$ = 24						; size = 4
?ScoreDeploymentPlots@CvTacticalAI@@AAE_NPAVCvPlot@@PAVCvArmyAI@@HHH@Z PROC ; CvTacticalAI::ScoreDeploymentPlots, COMDAT
; _this$ = ecx

; 5281 : {

	sub	esp, 60					; 0000003cH

; 5282 : 	int iDX, iDY;
; 5283 : 	int iScore;
; 5284 : 	CvPlot* pPlot;
; 5285 : 	CvTacticalAnalysisCell* pCell;
; 5286 : 	bool bSafeForDeployment;
; 5287 : 	bool bForcedToUseWater;
; 5288 : 	int iNumSafePlotsFound = 0;

	xor	edx, edx

; 5289 : 	int iNumDeployPlotsFound = 0;
; 5290 : 	CvTacticalTarget target;

	or	eax, -1
	mov	DWORD PTR _target$[esp+64], eax
	mov	DWORD PTR _target$[esp+68], eax
	mov	DWORD PTR _target$[esp+72], eax
	mov	DWORD PTR _target$[esp+84], eax

; 5291 : 
; 5292 : 	// We'll store the hexes we've found here
; 5293 : 	m_TempTargets.clear();
; 5294 : 
; 5295 : 	for(iDX = -(iRange); iDX <= iRange; iDX++)

	mov	eax, DWORD PTR _iRange$[esp+56]
	mov	DWORD PTR [ecx+23708], edx
	mov	DWORD PTR _this$[esp+60], ecx
	mov	ecx, eax
	neg	ecx
	mov	DWORD PTR _iNumSafePlotsFound$[esp+60], edx
	mov	DWORD PTR _iNumDeployPlotsFound$[esp+60], edx
	mov	DWORD PTR _target$[esp+60], edx
	mov	DWORD PTR _target$[esp+76], edx
	mov	DWORD PTR _target$[esp+80], edx
	mov	edx, ecx
	cmp	edx, eax
	mov	DWORD PTR tv514[esp+60], ecx
	mov	DWORD PTR _iDX$[esp+60], ecx
	jg	$LN29@ScoreDeplo
	push	ebx
	push	ebp
	push	esi
	push	edi
$LL31@ScoreDeplo:

; 5296 : 	{
; 5297 : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	cmp	ecx, eax
	mov	DWORD PTR _iDY$[esp+76], ecx
	jg	$LN30@ScoreDeplo
$LL28@ScoreDeplo:

; 5298 : 		{
; 5299 : 			pPlot = plotXY(pTarget->getX(), pTarget->getY(), iDX, iDY);

	mov	eax, DWORD PTR _pTarget$[esp+72]
	movsx	esi, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	ecx
	push	edx
	push	esi
	push	eax
	mov	DWORD PTR tv523[esp+92], eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 5300 : 			if(pPlot != NULL)

	test	ebx, ebx
	je	$LN27@ScoreDeplo

; 5301 : 			{
; 5302 : 				bSafeForDeployment = true;
; 5303 : 				bForcedToUseWater = false;
; 5304 : 
; 5305 : 				int iPlotDistance = plotDistance(pPlot->getX(), pPlot->getY(), pTarget->getX(), pTarget->getY());

	mov	eax, DWORD PTR tv523[esp+76]
	movsx	edi, WORD PTR [ebx+2]
	movsx	ebp, WORD PTR [ebx]
	push	esi
	push	eax
	push	edi
	push	ebp
	mov	BYTE PTR _bSafeForDeployment$[esp+92], 1
	mov	BYTE PTR _bForcedToUseWater$[esp+92], 0
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 5306 : 				if(iPlotDistance <= iRange)

	cmp	eax, DWORD PTR _iRange$[esp+72]
	mov	DWORD PTR _iPlotDistance$222778[esp+76], eax
	jg	$LN27@ScoreDeplo

; 5307 : 				{
; 5308 : 					int iPlotIndex = GC.getMap().plotNum(pPlot->getX(), pPlot->getY());
; 5309 : 					pCell = m_pMap->GetCell(iPlotIndex);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [ecx+4020]
	mov	ecx, DWORD PTR _this$[esp+76]
	imul	esi, edi
	mov	edx, DWORD PTR [ecx+4]

; 5310 : 					CvAIOperation* pOperation = m_pPlayer->getAIOperation(pArmy->GetOperationID());

	mov	ecx, DWORD PTR [ecx]
	add	esi, ebp
	mov	ebp, DWORD PTR _pArmy$[esp+72]
	imul	esi, 44					; 0000002cH
	mov	eax, DWORD PTR [ebp+12]
	add	esi, DWORD PTR [edx+12]
	push	eax
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	edi, eax

; 5311 : 
; 5312 : 					bool bValid = false;
; 5313 : 					if(pOperation->IsMixedLandNavalOperation() && pCell->CanUseForOperationGatheringCheckWater(true /*bWater*/))

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+44]
	mov	ecx, edi
	mov	BYTE PTR _bValid$222782[esp+76], 0
	call	edx
	test	al, al
	je	SHORT $LN138@ScoreDeplo
	push	1
	mov	ecx, esi
	call	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
	test	al, al
	je	SHORT $LN138@ScoreDeplo

; 5314 : 					{
; 5315 : 						bValid = true;

	mov	BYTE PTR _bValid$222782[esp+76], 1
	jmp	SHORT $LN17@ScoreDeplo
$LN138@ScoreDeplo:

; 5316 : 					}
; 5317 : 
; 5318 : 					else if(pOperation->IsAllNavalOperation() && pCell->CanUseForOperationGatheringCheckWater(true /*bWater*/))

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+40]
	mov	ecx, edi
	call	edx
	test	al, al
	je	SHORT $LN21@ScoreDeplo
	push	1
	mov	ecx, esi
	call	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
	test	al, al
	je	SHORT $LN21@ScoreDeplo

; 5319 : 					{
; 5320 : 						bValid = true;

	mov	BYTE PTR _bValid$222782[esp+76], 1
	jmp	SHORT $LN17@ScoreDeplo
$LN21@ScoreDeplo:

; 5321 : 					}
; 5322 : 
; 5323 : 					else if((!pOperation->IsAllNavalOperation() && !pOperation->IsMixedLandNavalOperation()) && (pCell->CanUseForOperationGatheringCheckWater(false /*bWater*/) || GC.getMap().GetAIMapHint() & 1))

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+40]
	mov	ecx, edi
	call	edx
	test	al, al
	jne	SHORT $LN17@ScoreDeplo
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+44]
	mov	ecx, edi
	call	edx
	test	al, al
	jne	SHORT $LN17@ScoreDeplo
	push	0
	mov	ecx, esi
	call	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
	test	al, al
	jne	SHORT $LN18@ScoreDeplo
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 1
	je	SHORT $LN17@ScoreDeplo
$LN18@ScoreDeplo:

; 5324 : 					{
; 5325 : 						bValid = true;
; 5326 : 						if (pCell->IsWater())

	mov	eax, DWORD PTR [esi]
	shr	eax, 11					; 0000000bH
	mov	BYTE PTR _bValid$222782[esp+76], 1
	test	al, 1
	je	SHORT $LN17@ScoreDeplo

; 5327 : 						{
; 5328 : 							bForcedToUseWater = true;

	mov	BYTE PTR _bForcedToUseWater$[esp+76], 1
$LN17@ScoreDeplo:

; 5329 : 						}
; 5330 : 					}
; 5331 : 
; 5332 : 					if(pOperation->IsMixedLandNavalOperation() || pOperation->IsAllNavalOperation())

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, edi
	call	eax
	test	al, al
	jne	SHORT $LN15@ScoreDeplo
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, edi
	call	eax
	test	al, al
	je	SHORT $LN14@ScoreDeplo
$LN15@ScoreDeplo:

; 5333 : 					{
; 5334 : 						if(!pArmy->IsAllOceanGoing() && pCell->IsOcean())

	mov	ecx, ebp
	call	?IsAllOceanGoing@CvArmyAI@@QAE_NXZ	; CvArmyAI::IsAllOceanGoing
	test	al, al
	jne	SHORT $LN14@ScoreDeplo
	mov	ecx, DWORD PTR [esi]
	shr	ecx, 12					; 0000000cH
	test	cl, 1

; 5335 : 						{
; 5336 : 							bValid = false;
; 5337 : 						}
; 5338 : 					}
; 5339 : 
; 5340 : 					if(bValid)

	jne	$LN27@ScoreDeplo
$LN14@ScoreDeplo:
	cmp	BYTE PTR _bValid$222782[esp+76], 0
	je	$LN27@ScoreDeplo

; 5341 : 					{
; 5342 : 						// Skip this plot if friendly unit that isn't in this army
; 5343 : 						CvUnit* pFriendlyUnit;
; 5344 : 						pFriendlyUnit = pCell->GetFriendlyMilitaryUnit();

	mov	ecx, DWORD PTR [esi+20]

; 5345 : 						if(pFriendlyUnit != NULL)

	test	ecx, ecx
	je	SHORT $LN11@ScoreDeplo

; 5346 : 						{
; 5347 : 							if(pFriendlyUnit->getArmyID() != pArmy->GetID())

	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	mov	ecx, ebp
	mov	edi, eax
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	cmp	edi, eax
	jne	$LN27@ScoreDeplo
$LN11@ScoreDeplo:

; 5348 : 							{
; 5349 : 								continue;
; 5350 : 							}
; 5351 : 						}
; 5352 : 
; 5353 : 						iNumDeployPlotsFound++;
; 5354 : 						iScore = 600 - (iPlotDistance * 100);
; 5355 : 						if(pCell->IsSubjectToAttack())

	mov	eax, DWORD PTR [esi]
	mov	edi, 6
	sub	edi, DWORD PTR _iPlotDistance$222778[esp+76]
	mov	edx, eax
	mov	ebp, 1
	imul	edi, 100				; 00000064H
	add	DWORD PTR _iNumDeployPlotsFound$[esp+76], ebp
	shr	edx, 5
	test	dl, 1
	je	SHORT $LN10@ScoreDeplo

; 5356 : 						{
; 5357 : 							iScore -= 100;

	sub	edi, 100				; 00000064H

; 5358 : 							bSafeForDeployment = false;

	mov	BYTE PTR _bSafeForDeployment$[esp+76], 0

; 5359 : 						}
; 5360 : 						else

	jmp	SHORT $LN9@ScoreDeplo
$LN10@ScoreDeplo:

; 5361 : 						{
; 5362 : 							iNumSafePlotsFound++;

	add	DWORD PTR _iNumSafePlotsFound$[esp+76], ebp
$LN9@ScoreDeplo:

; 5363 : 						}
; 5364 : 						if(pCell->IsEnemyCanMovePast())

	shr	eax, 6
	test	al, 1
	je	SHORT $LN147@ScoreDeplo

; 5365 : 						{
; 5366 : 							iScore -= 100;

	sub	edi, 100				; 00000064H
$LN147@ScoreDeplo:

; 5367 : 						}
; 5368 : 						if(pPlot->isCity() && pPlot->getOwner() == m_pPlayer->GetID())

	mov	eax, DWORD PTR [ebx+104]
	test	eax, eax
	jl	SHORT $LN139@ScoreDeplo
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN139@ScoreDeplo
	mov	ecx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN139@ScoreDeplo
	movsx	edx, BYTE PTR [ebx+4]
	mov	eax, DWORD PTR _this$[esp+76]
	mov	ecx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+44]
	jne	SHORT $LN139@ScoreDeplo

; 5369 : 						{
; 5370 : 							iScore += 100;

	add	edi, 100				; 00000064H

; 5371 : 						}
; 5372 : 						else

	jmp	SHORT $LN6@ScoreDeplo
$LN139@ScoreDeplo:

; 5373 : 						{
; 5374 : 							iScore += pCell->GetDefenseModifier() * 2;

	mov	edx, DWORD PTR [esi+28]
	lea	edi, DWORD PTR [edi+edx*2]
$LN6@ScoreDeplo:

; 5375 : 						}
; 5376 : 						if (bForcedToUseWater)

	cmp	BYTE PTR _bForcedToUseWater$[esp+76], 0
	je	SHORT $LN5@ScoreDeplo

; 5377 : 						{
; 5378 : 							iScore = 10;

	mov	edi, 10					; 0000000aH
$LN5@ScoreDeplo:

; 5379 : 						}
; 5380 : 
; 5381 : 						pCell->SetSafeForDeployment(bSafeForDeployment);

	mov	al, BYTE PTR _bSafeForDeployment$[esp+76]
	test	al, al
	je	SHORT $LN108@ScoreDeplo
	or	DWORD PTR [esi], 524288			; 00080000H
	jmp	SHORT $LN107@ScoreDeplo
$LN108@ScoreDeplo:
	and	DWORD PTR [esi], -524289		; fff7ffffH
$LN107@ScoreDeplo:

; 5382 : 						pCell->SetDeploymentScore(iScore);
; 5383 : 
; 5384 : 						// Save this in our list of potential targets
; 5385 : 						target.SetTargetX(pPlot->getX());
; 5386 : 						target.SetTargetY(pPlot->getY());
; 5387 : 						target.SetAuxIntData(iScore);
; 5388 : 
; 5389 : 						// A bit of a hack -- use high priority targets to indicate safe plots for ranged units
; 5390 : 						if(bSafeForDeployment)
; 5391 : 						{
; 5392 : 							target.SetTargetType(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT);
; 5393 : 						}
; 5394 : 						else
; 5395 : 						{
; 5396 : 							target.SetTargetType(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT);
; 5397 : 						}
; 5398 : 
; 5399 : 						m_TempTargets.push_back(target);

	mov	ebp, DWORD PTR _this$[esp+76]
	mov	DWORD PTR [esi+32], edi
	movsx	ecx, WORD PTR [ebx]
	movsx	edx, WORD PTR [ebx+2]
	mov	DWORD PTR _target$[esp+80], ecx
	xor	ecx, ecx
	test	al, al
	mov	eax, DWORD PTR [ebp+23712]
	setne	cl
	add	ebp, 23704				; 00005c98H
	mov	DWORD PTR _target$[esp+84], edx
	mov	DWORD PTR _target$[esp+96], edi
	mov	BYTE PTR [ebp+1048], 0
	lea	ecx, DWORD PTR [ecx+ecx+5]
	mov	DWORD PTR _target$[esp+76], ecx
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN127@ScoreDeplo
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::GrowSize
$LN127@ScoreDeplo:
	mov	eax, DWORD PTR [ebp+4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ebp]
	lea	edi, DWORD PTR [eax+edx*4]
	test	edi, edi
	je	SHORT $LN130@ScoreDeplo
	mov	ecx, 7
	lea	esi, DWORD PTR _target$[esp+76]
	rep movsd
$LN130@ScoreDeplo:
	inc	DWORD PTR [ebp+4]
$LN27@ScoreDeplo:

; 5296 : 	{
; 5297 : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	mov	ecx, DWORD PTR _iDY$[esp+76]
	mov	eax, DWORD PTR _iRange$[esp+72]
	mov	edx, DWORD PTR _iDX$[esp+76]
	inc	ecx
	cmp	ecx, eax
	mov	DWORD PTR _iDY$[esp+76], ecx
	jle	$LL28@ScoreDeplo
	mov	ecx, DWORD PTR tv514[esp+76]
$LN30@ScoreDeplo:

; 5291 : 
; 5292 : 	// We'll store the hexes we've found here
; 5293 : 	m_TempTargets.clear();
; 5294 : 
; 5295 : 	for(iDX = -(iRange); iDX <= iRange; iDX++)

	inc	edx
	cmp	edx, eax
	mov	DWORD PTR _iDX$[esp+76], edx
	jle	$LL31@ScoreDeplo
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN29@ScoreDeplo:

; 5400 : 					}
; 5401 : 				}
; 5402 : 			}
; 5403 : 		}
; 5404 : 	}
; 5405 : 
; 5406 : 	// Make sure we found enough
; 5407 : 	if(iNumSafePlotsFound < iNumRangedUnits || iNumDeployPlotsFound < (iNumMeleeUnits + iNumRangedUnits))

	mov	eax, DWORD PTR _iNumRangedUnits$[esp+56]
	cmp	DWORD PTR _iNumSafePlotsFound$[esp+60], eax
	jl	SHORT $LN1@ScoreDeplo
	mov	ecx, DWORD PTR _iNumMeleeUnits$[esp+56]
	add	ecx, eax
	cmp	DWORD PTR _iNumDeployPlotsFound$[esp+60], ecx
	jl	SHORT $LN1@ScoreDeplo

; 5410 : 	}
; 5411 : 
; 5412 : 	return true;

	mov	al, 1

; 5413 : }

	add	esp, 60					; 0000003cH
	ret	20					; 00000014H
$LN1@ScoreDeplo:

; 5408 : 	{
; 5409 : 		return false;

	xor	al, al

; 5413 : }

	add	esp, 60					; 0000003cH
	ret	20					; 00000014H
?ScoreDeploymentPlots@CvTacticalAI@@AAE_NPAVCvPlot@@PAVCvArmyAI@@HHH@Z ENDP ; CvTacticalAI::ScoreDeploymentPlots
_TEXT	ENDS
PUBLIC	?ScoreFormationPlots@CvTacticalAI@@AAE_NPAVCvArmyAI@@PAVCvPlot@@1H@Z ; CvTacticalAI::ScoreFormationPlots
; Function compile flags: /Ogtpy
;	COMDAT ?ScoreFormationPlots@CvTacticalAI@@AAE_NPAVCvArmyAI@@PAVCvPlot@@1H@Z
_TEXT	SEGMENT
_bForcedToUseWater$ = -49				; size = 1
tv491 = -48						; size = 4
_iPlotDistance$222830 = -48				; size = 4
_this$ = -44						; size = 4
_iDX$ = -40						; size = 4
_iNumDeployPlotsFound$ = -36				; size = 4
_iDY$ = -32						; size = 4
_target$ = -28						; size = 28
_pArmy$ = 8						; size = 4
_pForwardTarget$ = 12					; size = 4
_pCurrentCOM$ = 16					; size = 4
_iNumUnits$ = 20					; size = 4
?ScoreFormationPlots@CvTacticalAI@@AAE_NPAVCvArmyAI@@PAVCvPlot@@1H@Z PROC ; CvTacticalAI::ScoreFormationPlots, COMDAT
; _this$ = ecx

; 5417 : {

	sub	esp, 52					; 00000034H

; 5418 : 	int iDX, iDY;
; 5419 : 	int iScore;
; 5420 : 	CvPlot* pPlot;
; 5421 : 	CvTacticalAnalysisCell* pCell;
; 5422 : 	int iNumDeployPlotsFound = 0;

	xor	edx, edx
	push	ebx

; 5423 : 	CvTacticalTarget target;

	or	eax, -1
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+64], ecx
	mov	DWORD PTR _iNumDeployPlotsFound$[esp+64], edx
	mov	DWORD PTR _target$[esp+64], edx
	mov	DWORD PTR _target$[esp+68], eax
	mov	DWORD PTR _target$[esp+72], eax
	mov	DWORD PTR _target$[esp+76], eax
	mov	DWORD PTR _target$[esp+88], eax
	mov	DWORD PTR _target$[esp+80], edx
	mov	DWORD PTR _target$[esp+84], edx

; 5424 : 	bool bForcedToUseWater;
; 5425 : 
; 5426 : 	// We'll store the hexes we've found here
; 5427 : 	m_TempTargets.clear();

	mov	DWORD PTR [ecx+23708], edx

; 5428 : 
; 5429 : 	int iRange = 3;
; 5430 : 	for(iDX = -(iRange); iDX <= iRange; iDX++)

	mov	DWORD PTR _iDX$[esp+64], -3		; fffffffdH
	push	edi
	npad	2
$LL152@ScoreForma:

; 5431 : 	{
; 5432 : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	mov	ecx, -3					; fffffffdH
	mov	DWORD PTR _iDY$[esp+68], ecx
	npad	7
$LL151@ScoreForma:

; 5433 : 		{
; 5434 : 			pPlot = plotXY(pForwardTarget->getX(), pForwardTarget->getY(), iDX, iDY);

	mov	eax, DWORD PTR _pForwardTarget$[esp+64]
	movsx	esi, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _iDX$[esp+72]
	push	ecx
	push	esi
	push	eax
	mov	DWORD PTR tv491[esp+84], eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	ebp, eax
	add	esp, 16					; 00000010H

; 5435 : 			if(pPlot != NULL)

	test	ebp, ebp
	je	$LN26@ScoreForma

; 5436 : 			{
; 5437 : 				bForcedToUseWater = false;
; 5438 : 
; 5439 : 				int iPlotDistance = plotDistance(pPlot->getX(), pPlot->getY(), pForwardTarget->getX(), pForwardTarget->getY());

	mov	edx, DWORD PTR tv491[esp+68]
	movsx	edi, WORD PTR [ebp+2]
	movsx	ebx, WORD PTR [ebp]
	push	esi
	push	edx
	push	edi
	push	ebx
	mov	BYTE PTR _bForcedToUseWater$[esp+84], 0
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 5440 : 				if(iPlotDistance <= iRange)

	cmp	eax, 3
	mov	DWORD PTR _iPlotDistance$222830[esp+68], eax
	jg	$LN26@ScoreForma

; 5441 : 				{
; 5442 : 					int iPlotIndex = GC.getMap().plotNum(pPlot->getX(), pPlot->getY());
; 5443 : 					pCell = m_pMap->GetCell(iPlotIndex);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [eax+4020]
	mov	ecx, DWORD PTR _this$[esp+68]
	imul	esi, edi

; 5444 : 					CvAIOperation* pOperation = m_pPlayer->getAIOperation(pArmy->GetOperationID());

	mov	eax, DWORD PTR _pArmy$[esp+64]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [ecx]
	add	esi, ebx
	imul	esi, 44					; 0000002cH
	add	esi, DWORD PTR [edx+12]
	push	eax
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	edi, eax

; 5445 : 
; 5446 : 					bool bValid = false;
; 5447 : 					if(pOperation->IsMixedLandNavalOperation() && pCell->CanUseForOperationGatheringCheckWater(true /*bWater*/))

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, edi
	xor	bl, bl
	call	eax
	test	al, al
	je	SHORT $LN141@ScoreForma
	push	1
	mov	ecx, esi
	call	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
	test	al, al
	je	SHORT $LN141@ScoreForma

; 5448 : 					{
; 5449 : 						bValid = true;

	mov	bl, 1
	jmp	SHORT $LN142@ScoreForma
$LN141@ScoreForma:

; 5450 : 					}
; 5451 : 
; 5452 : 					else if(pOperation->IsAllNavalOperation() && pCell->CanUseForOperationGatheringCheckWater(true /*bWater*/))

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, edi
	call	eax
	test	al, al
	je	SHORT $LN20@ScoreForma
	push	1
	mov	ecx, esi
	call	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
	test	al, al
	je	SHORT $LN20@ScoreForma

; 5453 : 					{
; 5454 : 						bValid = true;

	mov	bl, 1
	jmp	SHORT $LN142@ScoreForma
$LN20@ScoreForma:

; 5455 : 					}
; 5456 : 
; 5457 : 					else if((!pOperation->IsAllNavalOperation() && !pOperation->IsMixedLandNavalOperation()) && (pCell->CanUseForOperationGatheringCheckWater(false /*bWater*/) || GC.getMap().GetAIMapHint() & 1))

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, edi
	call	eax
	test	al, al
	jne	SHORT $LN142@ScoreForma
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, edi
	call	eax
	test	al, al
	jne	SHORT $LN142@ScoreForma
	push	0
	mov	ecx, esi
	call	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
	test	al, al
	jne	SHORT $LN17@ScoreForma
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 1
	je	SHORT $LN142@ScoreForma
$LN17@ScoreForma:

; 5458 : 					{
; 5459 : 						bValid = true;
; 5460 : 						if (pCell->IsWater())

	mov	ecx, DWORD PTR [esi]
	mov	bl, 1
	shr	ecx, 11					; 0000000bH
	test	cl, bl
	je	SHORT $LN142@ScoreForma

; 5461 : 						{
; 5462 : 							bForcedToUseWater = true;

	mov	BYTE PTR _bForcedToUseWater$[esp+68], bl
$LN142@ScoreForma:

; 5463 : 						}
; 5464 : 					}
; 5465 : 
; 5466 : 					if(pOperation->IsMixedLandNavalOperation() || pOperation->IsAllNavalOperation())

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, edi
	call	eax
	test	al, al
	jne	SHORT $LN14@ScoreForma
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, edi
	call	eax
	test	al, al
	je	SHORT $LN148@ScoreForma
$LN14@ScoreForma:

; 5467 : 					{
; 5468 : 						if(!pArmy->IsAllOceanGoing() && pCell->IsOcean())

	mov	ecx, DWORD PTR _pArmy$[esp+64]
	call	?IsAllOceanGoing@CvArmyAI@@QAE_NXZ	; CvArmyAI::IsAllOceanGoing
	test	al, al
	jne	SHORT $LN148@ScoreForma
	mov	ecx, DWORD PTR [esi]
	shr	ecx, 12					; 0000000cH
	test	cl, 1

; 5469 : 						{
; 5470 : 							bValid = false;
; 5471 : 						}
; 5472 : 					}
; 5473 : 
; 5474 : 					if(bValid)

	jne	$LN26@ScoreForma
$LN148@ScoreForma:
	test	bl, bl
	je	$LN26@ScoreForma

; 5475 : 					{
; 5476 : 						// Skip this plot if friendly unit that isn't in this army
; 5477 : 						CvUnit* pFriendlyUnit;
; 5478 : 						pFriendlyUnit = pCell->GetFriendlyMilitaryUnit();

	mov	ecx, DWORD PTR [esi+20]

; 5479 : 						if(pFriendlyUnit != NULL)

	test	ecx, ecx
	je	SHORT $LN10@ScoreForma

; 5480 : 						{
; 5481 : 							if(pFriendlyUnit->getArmyID() != pArmy->GetID())

	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	mov	ecx, DWORD PTR _pArmy$[esp+64]
	mov	edi, eax
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	cmp	edi, eax
	jne	$LN26@ScoreForma
$LN10@ScoreForma:

; 5482 : 							{
; 5483 : 								continue;
; 5484 : 							}
; 5485 : 						}
; 5486 : 
; 5487 : 						iNumDeployPlotsFound++;
; 5488 : 
; 5489 : 						// Score plots close to COM and turn target highest
; 5490 : 						int iPlotDistanceFromCOM;
; 5491 : 						if (pForwardTarget == pCurrentCOM)

	mov	eax, DWORD PTR _pCurrentCOM$[esp+64]
	inc	DWORD PTR _iNumDeployPlotsFound$[esp+68]
	cmp	DWORD PTR _pForwardTarget$[esp+64], eax
	jne	SHORT $LN9@ScoreForma

; 5492 : 						{
; 5493 : 							iPlotDistanceFromCOM = iPlotDistance;

	mov	ebx, DWORD PTR _iPlotDistance$222830[esp+68]

; 5494 : 						}
; 5495 : 						else

	jmp	SHORT $LN8@ScoreForma
$LN9@ScoreForma:

; 5496 : 						{
; 5497 : 							iPlotDistanceFromCOM = plotDistance(pPlot->getX(), pPlot->getY(), pCurrentCOM->getX(), pCurrentCOM->getY());

	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	movsx	ecx, WORD PTR [ebp+2]
	push	edx
	movsx	edx, WORD PTR [ebp]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	ebx, eax
$LN8@ScoreForma:

; 5498 : 						}
; 5499 : 
; 5500 : 						iScore = 800 - (iPlotDistance * 100) - (iPlotDistanceFromCOM * 100);
; 5501 : 
; 5502 : 						if(pPlot->isCity() && pPlot->getOwner() == m_pPlayer->GetID())

	mov	eax, DWORD PTR [ebp+104]
	mov	edi, 8
	sub	edi, ebx
	sub	edi, DWORD PTR _iPlotDistance$222830[esp+68]
	imul	edi, 100				; 00000064H
	test	eax, eax
	jl	SHORT $LN149@ScoreForma
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN149@ScoreForma
	mov	ecx, DWORD PTR [ebp+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN149@ScoreForma
	movsx	edx, BYTE PTR [ebp+4]
	mov	eax, DWORD PTR _this$[esp+68]
	mov	ecx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+44]
	jne	SHORT $LN149@ScoreForma

; 5503 : 						{
; 5504 : 							iScore += 100;

	add	edi, 100				; 00000064H

; 5505 : 						}
; 5506 : 						else

	jmp	SHORT $LN6@ScoreForma
$LN149@ScoreForma:

; 5507 : 						{
; 5508 : 							iScore += pCell->GetDefenseModifier() * 2;

	mov	edx, DWORD PTR [esi+28]
	lea	edi, DWORD PTR [edi+edx*2]
$LN6@ScoreForma:

; 5509 : 						}
; 5510 : 						if (bForcedToUseWater)

	cmp	BYTE PTR _bForcedToUseWater$[esp+68], 0
	je	SHORT $LN5@ScoreForma

; 5511 : 						{
; 5512 : 							iScore = 10;

	mov	edi, 10					; 0000000aH
$LN5@ScoreForma:

; 5513 : 						}
; 5514 : 
; 5515 : 						// Safe if closer to rear, or if forward target and COM are the same
; 5516 : 						bool bSafeForDeployment = iPlotDistanceFromCOM < iPlotDistance || pForwardTarget == pCurrentCOM;

	cmp	ebx, DWORD PTR _iPlotDistance$222830[esp+68]
	jl	SHORT $LN33@ScoreForma
	mov	eax, DWORD PTR _pCurrentCOM$[esp+64]
	cmp	DWORD PTR _pForwardTarget$[esp+64], eax
	je	SHORT $LN33@ScoreForma
	xor	al, al

; 5517 : 						pCell->SetSafeForDeployment(bSafeForDeployment);

	and	DWORD PTR [esi], -524289		; fff7ffffH

; 5518 : 
; 5519 : 						// Reduce score if safe for ranged (so these don't get picked first)
; 5520 : 						if (bSafeForDeployment)

	jmp	SHORT $LN4@ScoreForma
$LN33@ScoreForma:

; 5517 : 						pCell->SetSafeForDeployment(bSafeForDeployment);

	or	DWORD PTR [esi], 524288			; 00080000H
	mov	al, 1

; 5521 : 						{
; 5522 : 							iScore -= 200;

	sub	edi, 200				; 000000c8H
$LN4@ScoreForma:

; 5523 : 						}
; 5524 : 
; 5525 : 						pCell->SetDeploymentScore(iScore);

	mov	DWORD PTR [esi+32], edi

; 5526 : 
; 5527 : 						// Save this in our list of potential targets
; 5528 : 						target.SetTargetX(pPlot->getX());

	movsx	ecx, WORD PTR [ebp]

; 5529 : 						target.SetTargetY(pPlot->getY());

	movsx	edx, WORD PTR [ebp+2]

; 5530 : 						target.SetAuxIntData(iScore);
; 5531 : 						// A bit of a hack -- use high priority targets to indicate safe plots for ranged units
; 5532 : 						if(bSafeForDeployment)
; 5533 : 						{
; 5534 : 							target.SetTargetType(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT);
; 5535 : 						}
; 5536 : 						else
; 5537 : 						{
; 5538 : 							target.SetTargetType(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT);
; 5539 : 						}
; 5540 : 						m_TempTargets.push_back(target);

	mov	ebp, DWORD PTR _this$[esp+68]
	mov	DWORD PTR _target$[esp+72], ecx
	xor	ecx, ecx
	test	al, al
	mov	eax, DWORD PTR [ebp+23712]
	setne	cl
	add	ebp, 23704				; 00005c98H
	mov	DWORD PTR _target$[esp+76], edx
	mov	DWORD PTR _target$[esp+88], edi
	mov	BYTE PTR [ebp+1048], 0
	lea	ecx, DWORD PTR [ecx+ecx+5]
	mov	DWORD PTR _target$[esp+68], ecx
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN128@ScoreForma
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::GrowSize
$LN128@ScoreForma:
	mov	eax, DWORD PTR [ebp+4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ebp]
	lea	edi, DWORD PTR [eax+edx*4]
	test	edi, edi
	je	SHORT $LN131@ScoreForma
	mov	ecx, 7
	lea	esi, DWORD PTR _target$[esp+68]
	rep movsd
$LN131@ScoreForma:
	inc	DWORD PTR [ebp+4]
$LN26@ScoreForma:

; 5431 : 	{
; 5432 : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	mov	ecx, DWORD PTR _iDY$[esp+68]
	inc	ecx
	cmp	ecx, 3
	mov	DWORD PTR _iDY$[esp+68], ecx
	jle	$LL151@ScoreForma
	mov	eax, DWORD PTR _iDX$[esp+68]
	inc	eax
	cmp	eax, 3
	mov	DWORD PTR _iDX$[esp+68], eax
	jle	$LL152@ScoreForma

; 5541 : 					}
; 5542 : 				}
; 5543 : 			}
; 5544 : 		}
; 5545 : 	}
; 5546 : 
; 5547 : 	// Make sure we found enough
; 5548 : 	if(iNumDeployPlotsFound < iNumUnits)

	mov	ecx, DWORD PTR _iNumDeployPlotsFound$[esp+68]
	cmp	ecx, DWORD PTR _iNumUnits$[esp+64]
	pop	edi
	pop	esi
	pop	ebp
	setge	al
	pop	ebx

; 5549 : 	{
; 5550 : 		return false;
; 5551 : 	}
; 5552 : 
; 5553 : 	return true;
; 5554 : }

	add	esp, 52					; 00000034H
	ret	16					; 00000010H
?ScoreFormationPlots@CvTacticalAI@@AAE_NPAVCvArmyAI@@PAVCvPlot@@1H@Z ENDP ; CvTacticalAI::ScoreFormationPlots
_TEXT	ENDS
PUBLIC	?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ	; CvTacticalAI::IdentifyPriorityTargets
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ$3
__ehfuncinfo$?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_pTarget$223051 = -64					; size = 4
_this$ = -60						; size = 4
tv1199 = -56						; size = 4
_iExpectedTotalDamage$ = -56				; size = 4
_iAttackerIndex$223071 = -52				; size = 4
_iDefenderStrength$223065 = -52				; size = 4
_iAttackerStrength$223064 = -48				; size = 4
$T262071 = -48						; size = 4
_iCityLoop$ = -44					; size = 4
_pEnemyUnit$223056 = -40				; size = 8
_pEnemyUnit$223077 = -32				; size = 8
_possibleAttackers$ = -24				; size = 12
__$EHRec$ = -12						; size = 12
?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::IdentifyPriorityTargets, COMDAT
; _this$ = ecx

; 5825 : {

	push	-1
	push	__ehhandler$?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp
	push	esi

; 5826 : 	CvCity* pLoopCity;
; 5827 : 	int iCityLoop;
; 5828 : 	FFastVector<CvTacticalTarget> possibleAttackers;

	xor	esi, esi
	push	edi
	mov	DWORD PTR _this$[esp+80], ecx
	mov	DWORD PTR _possibleAttackers$[esp+84], esi
	mov	DWORD PTR _possibleAttackers$[esp+88], esi
	mov	DWORD PTR _possibleAttackers$[esp+80], esi

; 5829 : 	int iExpectedDamage;
; 5830 : 	int iExpectedTotalDamage;
; 5831 : 
; 5832 : 	// Loop through each of our cities
; 5833 : 	for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR [ecx]
	push	esi
	lea	eax, DWORD PTR _iCityLoop$[esp+84]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+96], esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	cmp	ebx, esi
	je	$LN23@IdentifyPr@3
	npad	7
$LL25@IdentifyPr@3:

; 5834 : 	{
; 5835 : 		// Compile a list of units that can attack it this turn and what their expected damage is
; 5836 : 		possibleAttackers.clear();
; 5837 : 		iExpectedTotalDamage = 0;
; 5838 : 
; 5839 : 		CvTacticalTarget* pTarget;
; 5840 : 		pTarget = GetFirstUnitTarget();

	mov	ecx, DWORD PTR _this$[esp+80]
	xor	esi, esi
	mov	DWORD PTR _possibleAttackers$[esp+84], esi
	mov	DWORD PTR _iExpectedTotalDamage$[esp+80], esi
	call	?GetFirstUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetFirstUnitTarget
	mov	DWORD PTR _pTarget$223051[esp+80], eax

; 5841 : 		while(pTarget != NULL)

	cmp	eax, esi
	je	$LN21@IdentifyPr@3
	npad	1
$LL22@IdentifyPr@3:

; 5842 : 		{
; 5843 : 			CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR _pTarget$223051[esp+80]
	mov	ebp, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+8]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN55@IdentifyPr@3
	cmp	edi, -2147483647			; 80000001H
	je	$LN55@IdentifyPr@3
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	al, al
	je	SHORT $LN65@IdentifyPr@3
	test	ebp, ebp
	jge	SHORT $LN67@IdentifyPr@3
	mov	eax, ebp
	cdq
	idiv	ecx
	mov	ebp, edx
	add	ebp, ecx
	jmp	SHORT $LN65@IdentifyPr@3
$LN67@IdentifyPr@3:
	cmp	ebp, ecx
	jl	SHORT $LN65@IdentifyPr@3
	mov	eax, ebp
	cdq
	idiv	ecx
	mov	ebp, edx
$LN65@IdentifyPr@3:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	esi, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN75@IdentifyPr@3
	test	edi, edi
	jge	SHORT $LN77@IdentifyPr@3
	mov	eax, edi
	cdq
	idiv	esi
	add	edx, esi
	jmp	SHORT $LN79@IdentifyPr@3
$LN77@IdentifyPr@3:
	cmp	edi, esi
	jl	SHORT $LN75@IdentifyPr@3
	mov	eax, edi
	cdq
	idiv	esi
	jmp	SHORT $LN79@IdentifyPr@3
$LN75@IdentifyPr@3:
	mov	edx, edi
$LN79@IdentifyPr@3:
	test	ebp, ebp
	jl	SHORT $LN55@IdentifyPr@3
	cmp	ebp, ecx
	jge	SHORT $LN55@IdentifyPr@3
	test	edx, edx
	jl	SHORT $LN55@IdentifyPr@3
	cmp	edx, esi
	jge	SHORT $LN55@IdentifyPr@3
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, ebp
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN57@IdentifyPr@3
$LN55@IdentifyPr@3:
	xor	ecx, ecx
$LN57@IdentifyPr@3:

; 5844 : 			UnitHandle pEnemyUnit = pPlot->getVisibleEnemyDefender(m_pPlayer->GetID());

	mov	eax, DWORD PTR _this$[esp+80]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	mov	ebp, eax
	mov	DWORD PTR _pEnemyUnit$223056[esp+80], ebp
	mov	BYTE PTR _pEnemyUnit$223056[esp+84], 0
	test	ebp, ebp
	je	SHORT $LN100@IdentifyPr@3
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN100@IdentifyPr@3:
	mov	BYTE PTR __$EHRec$[esp+88], 1

; 5845 : 			if(pEnemyUnit)

	test	ebp, ebp
	je	$LN182@IdentifyPr@3

; 5846 : 			{
; 5847 : 				iExpectedDamage = 0;
; 5848 : 
; 5849 : 				if(pEnemyUnit->IsCanAttackRanged() && pEnemyUnit->GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true) > pEnemyUnit->GetMaxAttackStrength(NULL, pLoopCity->plot(), NULL))

	mov	ecx, ebp
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	SHORT $LN19@IdentifyPr@3
	push	0
	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	push	0
	mov	ecx, ebp
	call	?GetMaxAttackStrength@CvUnit@@QBEHPBVCvPlot@@0PBV1@@Z ; CvUnit::GetMaxAttackStrength
	push	1
	push	1
	push	0
	push	0
	mov	ecx, ebp
	mov	esi, eax
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength
	cmp	eax, esi
	jle	SHORT $LN19@IdentifyPr@3

; 5850 : 				{
; 5851 : 					if(plotDistance(pEnemyUnit->getX(), pEnemyUnit->getY(), pLoopCity->getX(), pLoopCity->getY()) <= pEnemyUnit->GetRange())

	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	mov	edx, DWORD PTR [ebp+88]
	mov	esi, DWORD PTR [ebp+76]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	ecx, ebp
	mov	esi, eax
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	cmp	esi, eax
	jg	$LN182@IdentifyPr@3

; 5852 : 					{
; 5853 : 						if(pEnemyUnit->canEverRangeStrikeAt(pLoopCity->getX(), pLoopCity->getY()))

	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	push	eax
	push	ecx
	mov	ecx, ebp
	call	?canEverRangeStrikeAt@CvUnit@@QBE_NHH@Z	; CvUnit::canEverRangeStrikeAt
	test	al, al
	je	$LN182@IdentifyPr@3

; 5854 : 						{
; 5855 : 							iExpectedDamage = pEnemyUnit->GetRangeCombatDamage(NULL, pLoopCity, false);

	push	0
	push	0
	push	ebx
	push	0
	mov	ecx, ebp
	call	?GetRangeCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z ; CvUnit::GetRangeCombatDamage

; 5856 : 						}
; 5857 : 					}
; 5858 : 				}

	jmp	$LN15@IdentifyPr@3
$LN19@IdentifyPr@3:

; 5859 : 				else if(CanReachInXTurns(pEnemyUnit, pLoopCity->plot(), 1))

	push	0
	push	0
	push	1
	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, ebp
	mov	DWORD PTR $T262071[esp+104], esp
	mov	DWORD PTR [eax], ebp
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	test	al, al
	je	$LN182@IdentifyPr@3

; 5860 : 				{
; 5861 : 					int iAttackerStrength = pEnemyUnit->GetMaxAttackStrength(NULL, pLoopCity->plot(), NULL);

	push	0
	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	push	0
	mov	ecx, ebp
	call	?GetMaxAttackStrength@CvUnit@@QBEHPBVCvPlot@@0PBV1@@Z ; CvUnit::GetMaxAttackStrength

; 5862 : 					int iDefenderStrength = pLoopCity->getStrengthValue();

	push	0
	mov	ecx, ebx
	mov	DWORD PTR _iAttackerStrength$223064[esp+84], eax
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue

; 5863 : 					CvUnit* pFireSupportUnit = CvUnitCombat::GetFireSupportUnit(pLoopCity->getOwner(), pLoopCity->getX(), pLoopCity->getY(), pEnemyUnit->getX(), pEnemyUnit->getY());

	mov	ecx, DWORD PTR [ebp+76]
	mov	edx, DWORD PTR [ebx+108]
	mov	edi, DWORD PTR [ebx+96]
	mov	esi, DWORD PTR [ebx+84]
	mov	DWORD PTR _iDefenderStrength$223065[esp+80], eax
	mov	eax, DWORD PTR [ebp+88]
	push	eax
	push	ecx
	push	edx
	push	edi
	push	esi
	call	?GetFireSupportUnit@CvUnitCombat@@SAPAVCvUnit@@W4PlayerTypes@@HHHH@Z ; CvUnitCombat::GetFireSupportUnit
	add	esp, 20					; 00000014H

; 5864 : 					int iDefenderFireSupportCombatDamage = 0;

	xor	esi, esi

; 5865 : 					if(pFireSupportUnit != NULL)

	test	eax, eax
	je	SHORT $LN14@IdentifyPr@3

; 5866 : 					{
; 5867 : 						iDefenderFireSupportCombatDamage = pFireSupportUnit->GetRangeCombatDamage(pEnemyUnit.pointer(), NULL, false);

	push	esi
	push	esi
	push	esi
	push	ebp
	mov	ecx, eax
	call	?GetRangeCombatDamage@CvUnit@@QBEHPBV1@PAVCvCity@@_NH@Z ; CvUnit::GetRangeCombatDamage
	mov	esi, eax
$LN14@IdentifyPr@3:

; 5868 : 					}
; 5869 : 					iExpectedDamage = pEnemyUnit->getCombatDamage(iAttackerStrength, iDefenderStrength, pEnemyUnit->getDamage() + iDefenderFireSupportCombatDamage, /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ true);

	push	1
	push	0
	push	0
	mov	ecx, ebp
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, DWORD PTR _iAttackerStrength$223064[esp+92]
	add	eax, esi
	push	eax
	mov	eax, DWORD PTR _iDefenderStrength$223065[esp+96]
	push	eax
	push	ecx
	mov	ecx, ebp
	call	?getCombatDamage@CvUnit@@QBEHHHH_N00@Z	; CvUnit::getCombatDamage
$LN15@IdentifyPr@3:

; 5870 : 				}
; 5871 : 				if(iExpectedDamage > 0)

	test	eax, eax
	jle	SHORT $LN182@IdentifyPr@3

; 5872 : 				{
; 5873 : 					iExpectedTotalDamage += iExpectedDamage;

	add	DWORD PTR _iExpectedTotalDamage$[esp+80], eax

; 5874 : 					possibleAttackers.push_back(*pTarget);

	mov	eax, DWORD PTR _possibleAttackers$[esp+88]
	cmp	DWORD PTR _possibleAttackers$[esp+84], eax
	jne	SHORT $LN181@IdentifyPr@3
	push	eax
	lea	ecx, DWORD PTR _possibleAttackers$[esp+84]
	call	?GrowSize@?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@IAEXI@Z ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::GrowSize
$LN181@IdentifyPr@3:
	mov	eax, DWORD PTR _possibleAttackers$[esp+84]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _possibleAttackers$[esp+80]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN184@IdentifyPr@3
	mov	esi, DWORD PTR _pTarget$223051[esp+80]
	mov	ecx, 7
	mov	edi, eax
	rep movsd
$LN184@IdentifyPr@3:
	inc	DWORD PTR _possibleAttackers$[esp+84]
$LN182@IdentifyPr@3:

; 5875 : 				}
; 5876 : 			}
; 5877 : 			pTarget = GetNextUnitTarget();

	mov	ecx, DWORD PTR _this$[esp+80]
	call	?GetNextUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextUnitTarget
	mov	esi, eax
	mov	DWORD PTR _pTarget$223051[esp+80], esi

; 5878 : 		}

	mov	BYTE PTR __$EHRec$[esp+88], 0
	test	ebp, ebp
	je	SHORT $LN191@IdentifyPr@3
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN191@IdentifyPr@3:

; 5841 : 		while(pTarget != NULL)

	test	esi, esi
	jne	$LL22@IdentifyPr@3
$LN21@IdentifyPr@3:

; 5879 : 
; 5880 : 		// If they can take the city down and they are a melee unit, then they are a high priority target
; 5881 : 		if(iExpectedTotalDamage > (pLoopCity->GetMaxHitPoints() - pLoopCity->getDamage()))

	mov	ecx, ebx
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, ebx
	mov	esi, eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	sub	esi, eax
	cmp	DWORD PTR _iExpectedTotalDamage$[esp+80], esi
	jle	$LN12@IdentifyPr@3

; 5882 : 		{
; 5883 : 			unsigned int iAttackerIndex = 0;
; 5884 : 
; 5885 : 			// Loop until we've found all the attackers in the unit target list
; 5886 : 			pTarget = GetFirstUnitTarget();

	mov	ecx, DWORD PTR _this$[esp+80]
	mov	DWORD PTR _iAttackerIndex$223071[esp+80], 0
	call	?GetFirstUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetFirstUnitTarget

; 5887 : 			while(iAttackerIndex < possibleAttackers.size() && pTarget != NULL)

	cmp	DWORD PTR _possibleAttackers$[esp+84], 0
	mov	DWORD PTR _pTarget$223051[esp+80], eax
	jbe	$LN24@IdentifyPr@3
	mov	ecx, DWORD PTR _possibleAttackers$[esp+80]
	add	ecx, 8
	mov	DWORD PTR tv1199[esp+80], ecx
$LL11@IdentifyPr@3:
	test	eax, eax
	je	$LN24@IdentifyPr@3

; 5888 : 			{
; 5889 : 				// Match based on X, Y
; 5890 : 				if(pTarget->GetTargetX() == possibleAttackers[iAttackerIndex].GetTargetX() &&
; 5891 : 				        pTarget->GetTargetY() == possibleAttackers[iAttackerIndex].GetTargetY())

	mov	edi, DWORD PTR _pTarget$223051[esp+80]
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR tv1199[esp+80]
	cmp	eax, DWORD PTR [ecx-4]
	jne	$LN271@IdentifyPr@3
	mov	ebp, DWORD PTR [edi+8]
	cmp	ebp, DWORD PTR [ecx]
	jne	$LN271@IdentifyPr@3

; 5892 : 				{
; 5893 : 					CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	cmp	eax, -2147483647			; 80000001H
	je	$LN213@IdentifyPr@3
	cmp	ebp, -2147483647			; 80000001H
	je	$LN213@IdentifyPr@3
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [edi+4056]
	mov	ecx, DWORD PTR [edi+4020]
	test	dl, dl
	je	SHORT $LN223@IdentifyPr@3
	test	eax, eax
	jge	SHORT $LN225@IdentifyPr@3
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN227@IdentifyPr@3
$LN225@IdentifyPr@3:
	cmp	eax, ecx
	jl	SHORT $LN223@IdentifyPr@3
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN227@IdentifyPr@3
$LN223@IdentifyPr@3:
	mov	esi, eax
$LN227@IdentifyPr@3:
	mov	al, BYTE PTR [edi+4057]
	mov	ebx, DWORD PTR [edi+4024]
	test	al, al
	je	SHORT $LN233@IdentifyPr@3
	test	ebp, ebp
	jge	SHORT $LN235@IdentifyPr@3
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN237@IdentifyPr@3
$LN235@IdentifyPr@3:
	cmp	ebp, ebx
	jl	SHORT $LN233@IdentifyPr@3
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN237@IdentifyPr@3
$LN233@IdentifyPr@3:
	mov	edx, ebp
$LN237@IdentifyPr@3:
	test	esi, esi
	jl	SHORT $LN217@IdentifyPr@3
	cmp	esi, ecx
	jge	SHORT $LN217@IdentifyPr@3
	test	edx, edx
	jl	SHORT $LN217@IdentifyPr@3
	cmp	edx, ebx
	jge	SHORT $LN217@IdentifyPr@3
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edi+4068]
	mov	edi, DWORD PTR _pTarget$223051[esp+80]
	jmp	SHORT $LN215@IdentifyPr@3
$LN217@IdentifyPr@3:
	mov	edi, DWORD PTR _pTarget$223051[esp+80]
$LN213@IdentifyPr@3:
	xor	ecx, ecx
$LN215@IdentifyPr@3:

; 5894 : 					UnitHandle pEnemyUnit = pPlot->getVisibleEnemyDefender(m_pPlayer->GetID());

	mov	edx, DWORD PTR _this$[esp+80]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	mov	esi, eax
	mov	DWORD PTR _pEnemyUnit$223077[esp+80], esi
	mov	BYTE PTR _pEnemyUnit$223077[esp+84], 0
	test	esi, esi
	je	SHORT $LN258@IdentifyPr@3
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN258@IdentifyPr@3:
	mov	BYTE PTR __$EHRec$[esp+88], 2

; 5895 : 					if(pEnemyUnit && pEnemyUnit->IsCanAttackRanged())

	test	esi, esi
	je	SHORT $LN8@IdentifyPr@3
	mov	ecx, esi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	SHORT $LN8@IdentifyPr@3

; 5896 : 					{
; 5897 : 						pTarget->SetTargetType(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT);

	mov	DWORD PTR [edi], 6

; 5898 : 					}
; 5899 : 					else

	jmp	SHORT $LN266@IdentifyPr@3
$LN8@IdentifyPr@3:

; 5900 : 					{
; 5901 : 						pTarget->SetTargetType(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT);

	mov	DWORD PTR [edi], 7
$LN266@IdentifyPr@3:

; 5902 : 					}
; 5903 : 					iAttackerIndex++;

	inc	DWORD PTR _iAttackerIndex$223071[esp+80]
	add	DWORD PTR tv1199[esp+80], 28		; 0000001cH

; 5904 : 				}

	mov	BYTE PTR __$EHRec$[esp+88], 0
	test	esi, esi
	je	SHORT $LN271@IdentifyPr@3
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN271@IdentifyPr@3:

; 5905 : 				pTarget = GetNextUnitTarget();

	mov	ecx, DWORD PTR _this$[esp+80]
	call	?GetNextUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextUnitTarget
	mov	ecx, DWORD PTR _iAttackerIndex$223071[esp+80]
	mov	DWORD PTR _pTarget$223051[esp+80], eax
	cmp	ecx, DWORD PTR _possibleAttackers$[esp+84]
	jb	$LL11@IdentifyPr@3

; 5906 : 			}
; 5907 : 		}
; 5908 : 
; 5909 : 		// If they can damage a city they are a medium priority target
; 5910 : 		else if(possibleAttackers.size() > 0)

	jmp	SHORT $LN24@IdentifyPr@3
$LN12@IdentifyPr@3:
	mov	ebp, DWORD PTR _possibleAttackers$[esp+84]
	test	ebp, ebp
	jbe	SHORT $LN24@IdentifyPr@3

; 5911 : 		{
; 5912 : 			unsigned int iAttackerIndex = 0;
; 5913 : 
; 5914 : 			// Loop until we've found all the attackers in the unit target list
; 5915 : 			pTarget = GetFirstUnitTarget();

	mov	ebx, DWORD PTR _this$[esp+80]
	mov	ecx, ebx
	xor	edi, edi
	call	?GetFirstUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetFirstUnitTarget

; 5916 : 			while(iAttackerIndex < possibleAttackers.size() && pTarget != NULL)

	test	ebp, ebp
	jbe	SHORT $LN24@IdentifyPr@3
	mov	esi, DWORD PTR _possibleAttackers$[esp+80]
	add	esi, 8
$LL4@IdentifyPr@3:
	test	eax, eax
	je	SHORT $LN24@IdentifyPr@3

; 5917 : 			{
; 5918 : 				// Match based on X, Y
; 5919 : 				if(pTarget->GetTargetX() == possibleAttackers[iAttackerIndex].GetTargetX() &&
; 5920 : 				        pTarget->GetTargetY() == possibleAttackers[iAttackerIndex].GetTargetY())

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [esi-4]
	jne	SHORT $LN2@IdentifyPr@3
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN2@IdentifyPr@3

; 5921 : 				{
; 5922 : 					if(pTarget->GetTargetType() != AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)

	cmp	DWORD PTR [eax], 7
	je	SHORT $LN291@IdentifyPr@3

; 5923 : 					{
; 5924 : 						pTarget->SetTargetType(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT);

	mov	DWORD PTR [eax], 6
$LN291@IdentifyPr@3:

; 5925 : 					}
; 5926 : 					iAttackerIndex++;

	inc	edi
	add	esi, 28					; 0000001cH
$LN2@IdentifyPr@3:

; 5927 : 				}
; 5928 : 				pTarget = GetNextUnitTarget();

	mov	ecx, ebx
	call	?GetNextUnitTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextUnitTarget
	cmp	edi, ebp
	jb	SHORT $LL4@IdentifyPr@3
$LN24@IdentifyPr@3:

; 5829 : 	int iExpectedDamage;
; 5830 : 	int iExpectedTotalDamage;
; 5831 : 
; 5832 : 	// Loop through each of our cities
; 5833 : 	for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	mov	eax, DWORD PTR _this$[esp+80]
	mov	ecx, DWORD PTR [eax]
	push	0
	lea	edx, DWORD PTR _iCityLoop$[esp+84]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	$LL25@IdentifyPr@3
$LN23@IdentifyPr@3:

; 5929 : 			}
; 5930 : 		}
; 5931 : 	}
; 5932 : }

	mov	ecx, DWORD PTR _possibleAttackers$[esp+80]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 64					; 00000040H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _possibleAttackers$[ebp]
	jmp	??1?$FFastVector@VCvTacticalTarget@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvTacticalTarget@@$0A@@@@@QAE@XZ ; FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>::~FFastVector<CvTacticalTarget,0,0,0,BaseVector<CvTacticalTarget,0>::FDefaultFastVectorAllocator>
__unwindfunclet$?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pEnemyUnit$223056[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _pEnemyUnit$223077[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::IdentifyPriorityTargets
PUBLIC	?ExtractTargetsForZone@CvTacticalAI@@AAEXPAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::ExtractTargetsForZone
; Function compile flags: /Ogtpy
;	COMDAT ?ExtractTargetsForZone@CvTacticalAI@@AAEXPAVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pZone$ = 8						; size = 4
?ExtractTargetsForZone@CvTacticalAI@@AAEXPAVCvTacticalDominanceZone@@@Z PROC ; CvTacticalAI::ExtractTargetsForZone, COMDAT
; _this$ = ecx

; 6062 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 6063 : 	TacticalList::iterator it;
; 6064 : 
; 6065 : 	m_ZoneTargets.clear();

	lea	ebx, DWORD PTR [esi+9336]
	mov	DWORD PTR [ebx+4], 0

; 6066 : 	for(it = m_AllTargets.begin(); it != m_AllTargets.end(); ++it)

	mov	eax, DWORD PTR [esi+2156]
	mov	ebp, DWORD PTR [esi+2152]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	edx, ebp
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _this$[esp+16], esi
	cmp	ebp, eax
	je	$LN10@ExtractTar
	push	edi
	npad	6
$LL68@ExtractTar:

; 6067 : 	{
; 6068 : 		bool bValid = false;
; 6069 : 
; 6070 : 		if(pZone == NULL)

	mov	ecx, DWORD PTR _pZone$[esp+16]
	test	ecx, ecx
	je	SHORT $LN4@ExtractTar

; 6071 : 		{
; 6072 : 			bValid = true;
; 6073 : 		}
; 6074 : 		else
; 6075 : 		{
; 6076 : 			DomainTypes eDomain = DOMAIN_LAND;
; 6077 : 			if(pZone->IsWater())

	cmp	BYTE PTR [ecx+68], 0
	mov	eax, 2
	je	SHORT $LN7@ExtractTar

; 6078 : 			{
; 6079 : 				eDomain = DOMAIN_SEA;

	xor	eax, eax
$LN7@ExtractTar:

; 6080 : 			}
; 6081 : 			bValid = it->IsTargetValidInThisDomain(eDomain);

	mov	edx, DWORD PTR [ebp]
	dec	edx
	cmp	edx, 23					; 00000017H
	ja	$LN11@ExtractTar
	movzx	edx, BYTE PTR $LN67@ExtractTar[edx]
	jmp	DWORD PTR $LN70@ExtractTar[edx*4]
$LN31@ExtractTar:
	cmp	eax, 2
	jmp	SHORT $LN69@ExtractTar
$LN30@ExtractTar:
	test	eax, eax
$LN69@ExtractTar:
	sete	al

; 6082 : 		}
; 6083 : 		if(bValid)

	test	al, al
	je	SHORT $LN11@ExtractTar
$LN66@ExtractTar:

; 6084 : 		{
; 6085 : 			if(pZone == NULL || it->GetDominanceZone() == pZone->GetDominanceZoneID())

	mov	eax, DWORD PTR [ebp+24]
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $LN4@ExtractTar

; 6088 : 			}
; 6089 : 
; 6090 : 			// Not obviously in this zone, but if within 2 of city we want them anyway
; 6091 : 			else
; 6092 : 			{
; 6093 : 				CvCity* pCity;
; 6094 : 				pCity = pZone->GetClosestCity();

	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity

; 6095 : 				if(pCity)

	test	eax, eax
	je	SHORT $LN11@ExtractTar

; 6096 : 				{
; 6097 : 					if(plotDistance(pCity->getX(), pCity->getY(), it->GetTargetX(), it->GetTargetY()) <= 2)

	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+4]
	push	ecx
	mov	ecx, DWORD PTR [eax+108]
	push	edx
	mov	edx, DWORD PTR [eax+96]
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jg	SHORT $LN11@ExtractTar

; 6098 : 					{
; 6099 : 						m_ZoneTargets.push_back(*it);

	push	ebp
	mov	ecx, ebx
	call	?push_back@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAEIABVCvTacticalTarget@@@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::push_back
	jmp	SHORT $LN11@ExtractTar
$LN4@ExtractTar:

; 6086 : 			{
; 6087 : 				m_ZoneTargets.push_back(*it);

	mov	eax, DWORD PTR [ebx+8]
	mov	BYTE PTR [ebx+7180], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN42@ExtractTar
	push	eax
	mov	ecx, ebx
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::GrowSize
$LN42@ExtractTar:
	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edi, DWORD PTR [edx+ecx*4]
	test	edi, edi
	je	SHORT $LN45@ExtractTar
	mov	ecx, 7
	mov	esi, ebp
	rep movsd
	mov	esi, DWORD PTR _this$[esp+20]
$LN45@ExtractTar:
	inc	DWORD PTR [ebx+4]
$LN11@ExtractTar:

; 6066 : 	for(it = m_AllTargets.begin(); it != m_AllTargets.end(); ++it)

	mov	eax, DWORD PTR [esi+2156]
	mov	edx, DWORD PTR [esi+2152]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	add	ebp, 28					; 0000001cH
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	ebp, eax
	jne	$LL68@ExtractTar
	pop	edi
$LN10@ExtractTar:
	pop	esi
	pop	ebp
	pop	ebx

; 6100 : 					}
; 6101 : 				}
; 6102 : 			}
; 6103 : 		}
; 6104 : 	}
; 6105 : }

	pop	ecx
	ret	4
$LN70@ExtractTar:
	DD	$LN66@ExtractTar
	DD	$LN31@ExtractTar
	DD	$LN30@ExtractTar
$LN67@ExtractTar:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	1
	DB	2
	DB	1
	DB	1
	DB	1
?ExtractTargetsForZone@CvTacticalAI@@AAEXPAVCvTacticalDominanceZone@@@Z ENDP ; CvTacticalAI::ExtractTargetsForZone
_TEXT	ENDS
PUBLIC	?RemoveChosenUnits@CvTacticalAI@@AAEXH@Z	; CvTacticalAI::RemoveChosenUnits
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveChosenUnits@CvTacticalAI@@AAEXH@Z
_TEXT	SEGMENT
_iI$225833 = -20					; size = 4
_block$225838 = -16					; size = 16
tv448 = 8						; size = 4
_iI$225845 = 8						; size = 4
_iStartIndex$ = 8					; size = 4
?RemoveChosenUnits@CvTacticalAI@@AAEXH@Z PROC		; CvTacticalAI::RemoveChosenUnits, COMDAT
; _this$ = ecx

; 10789: {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 10790: 	m_TemporaryBlocks.clear();
; 10791: 	m_TemporaryBlocks = m_PotentialBlocks;

	lea	eax, DWORD PTR [esi+26596]
	xor	edi, edi
	lea	ecx, DWORD PTR [esi+27012]
	push	eax
	mov	DWORD PTR [esi+27016], edi
	call	??4?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::operator=

; 10792: 	m_PotentialBlocks.clear();
; 10793: 
; 10794: #ifdef AUI_ITERATORIZE
; 10795: 	for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_TemporaryBlocks.begin() + iStartIndex; it != m_TemporaryBlocks.end(); ++it)
; 10796: 	{
; 10797: 		bool bCopyIt = true;
; 10798: 
; 10799: 		CvBlockingUnit block = *it;
; 10800: 
; 10801: 		// Loop through chosen array looking for occurrences of this unit
; 10802: 		for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_NewlyChosen.begin(); it2 != m_NewlyChosen.end(); ++it2)
; 10803: 		{
; 10804: 			if (block.GetUnitID() == it2->GetUnitID())
; 10805: #else
; 10806: 	for(unsigned int iI = iStartIndex; iI < m_TemporaryBlocks.size(); iI++)

	mov	eax, DWORD PTR _iStartIndex$[esp+32]
	mov	DWORD PTR [esi+26600], edi
	mov	DWORD PTR _iI$225833[esp+36], eax
	cmp	eax, DWORD PTR [esi+27016]
	jae	$LN13@RemoveChos
	shl	eax, 4
	mov	DWORD PTR tv448[esp+32], eax
$LL83@RemoveChos:
	mov	eax, DWORD PTR [esi+27012]
	add	eax, DWORD PTR tv448[esp+32]

; 10807: 	{
; 10808: 		bool bCopyIt = true;

	mov	dl, 1

; 10809: 
; 10810: 		CvBlockingUnit block = m_TemporaryBlocks[iI];

	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR _block$225838[esp+36], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _block$225838[esp+48], eax
	mov	eax, DWORD PTR [esi+28040]
	mov	DWORD PTR _block$225838[esp+44], ecx

; 10811: 
; 10812: 		// Loop through chosen array looking for occurrences of this unit
; 10813: 		for(unsigned int jJ = 0; jJ < m_NewlyChosen.size() && bCopyIt; jJ++)

	xor	ecx, ecx
	test	eax, eax
	jbe	SHORT $LN77@RemoveChos

; 10807: 	{
; 10808: 		bool bCopyIt = true;

	xor	edi, edi
$LL78@RemoveChos:

; 10811: 
; 10812: 		// Loop through chosen array looking for occurrences of this unit
; 10813: 		for(unsigned int jJ = 0; jJ < m_NewlyChosen.size() && bCopyIt; jJ++)

	test	dl, dl
	je	SHORT $LN14@RemoveChos

; 10814: 		{
; 10815: 			if(block.GetUnitID() == m_NewlyChosen[jJ].GetUnitID())

	mov	ebp, DWORD PTR [esi+28036]
	cmp	ebx, DWORD PTR [edi+ebp+4]
	jne	SHORT $LN11@RemoveChos

; 10816: #endif
; 10817: 			{
; 10818: 				bCopyIt = false;

	xor	dl, dl
$LN11@RemoveChos:

; 10811: 
; 10812: 		// Loop through chosen array looking for occurrences of this unit
; 10813: 		for(unsigned int jJ = 0; jJ < m_NewlyChosen.size() && bCopyIt; jJ++)

	inc	ecx
	add	edi, 16					; 00000010H
	cmp	ecx, eax
	jb	SHORT $LL78@RemoveChos

; 10819: 			}
; 10820: 		}
; 10821: 
; 10822: 		if(bCopyIt)

	test	dl, dl
	je	SHORT $LN14@RemoveChos
$LN77@RemoveChos:

; 10823: 		{
; 10824: 			m_PotentialBlocks.push_back(block);

	mov	eax, DWORD PTR [esi+26604]
	lea	edi, DWORD PTR [esi+26596]
	mov	BYTE PTR [edi+412], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN46@RemoveChos
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
$LN46@RemoveChos:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN49@RemoveChos
	mov	ecx, DWORD PTR _block$225838[esp+36]
	mov	edx, DWORD PTR _block$225838[esp+44]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _block$225838[esp+48]
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], ecx
$LN49@RemoveChos:
	inc	DWORD PTR [edi+4]
$LN14@RemoveChos:

; 10792: 	m_PotentialBlocks.clear();
; 10793: 
; 10794: #ifdef AUI_ITERATORIZE
; 10795: 	for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_TemporaryBlocks.begin() + iStartIndex; it != m_TemporaryBlocks.end(); ++it)
; 10796: 	{
; 10797: 		bool bCopyIt = true;
; 10798: 
; 10799: 		CvBlockingUnit block = *it;
; 10800: 
; 10801: 		// Loop through chosen array looking for occurrences of this unit
; 10802: 		for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_NewlyChosen.begin(); it2 != m_NewlyChosen.end(); ++it2)
; 10803: 		{
; 10804: 			if (block.GetUnitID() == it2->GetUnitID())
; 10805: #else
; 10806: 	for(unsigned int iI = iStartIndex; iI < m_TemporaryBlocks.size(); iI++)

	mov	eax, DWORD PTR _iI$225833[esp+36]
	add	DWORD PTR tv448[esp+32], 16		; 00000010H
	inc	eax
	mov	DWORD PTR _iI$225833[esp+36], eax
	cmp	eax, DWORD PTR [esi+27016]
	jb	$LL83@RemoveChos
$LN13@RemoveChos:

; 10825: 		}
; 10826: 	}
; 10827: 
; 10828: 	// Rebuild number of choices
; 10829: #ifdef AUI_ITERATORIZE
; 10830: 	for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_PotentialBlocks.begin(); it != m_PotentialBlocks.end(); ++it)
; 10831: 	{
; 10832: 		int iNumFound = 0;
; 10833: 		CvPlot* pPlot = it->GetPlot();
; 10834: 
; 10835: 		for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it2 = m_PotentialBlocks.begin(); it2 != m_PotentialBlocks.end(); ++it2)
; 10836: 		{
; 10837: 			if (pPlot == it2->GetPlot())
; 10838: 			{
; 10839: 				iNumFound++;
; 10840: 			}
; 10841: 		}
; 10842: 		it->SetNumChoices(iNumFound);
; 10843: #else
; 10844: 	for(unsigned int iI = 0; iI < m_PotentialBlocks.size(); iI++)

	mov	eax, DWORD PTR [esi+26600]
	xor	edx, edx
	mov	DWORD PTR _iI$225845[esp+32], edx
	cmp	eax, edx
	jbe	SHORT $LN5@RemoveChos
$LL84@RemoveChos:

; 10847: 		CvPlot* pPlot = m_PotentialBlocks[iI].GetPlot();

	mov	ecx, DWORD PTR [esi+26596]
	mov	ebp, DWORD PTR [edx+ecx]
	xor	ebx, ebx

; 10848: 
; 10849: 		for(unsigned int jJ = 0; jJ < m_PotentialBlocks.size(); jJ++)

	test	eax, eax
	jbe	SHORT $LN2@RemoveChos

; 10845: 	{
; 10846: 		int iNumFound = 0;

	mov	edi, ecx
$LL4@RemoveChos:

; 10850: 		{
; 10851: 			if(pPlot == m_PotentialBlocks[jJ].GetPlot())

	cmp	ebp, DWORD PTR [edi]
	jne	SHORT $LN3@RemoveChos

; 10852: 			{
; 10853: 				iNumFound++;

	inc	ebx
$LN3@RemoveChos:

; 10848: 
; 10849: 		for(unsigned int jJ = 0; jJ < m_PotentialBlocks.size(); jJ++)

	add	edi, 16					; 00000010H
	sub	eax, 1
	jne	SHORT $LL4@RemoveChos
$LN2@RemoveChos:

; 10854: 			}
; 10855: 		}
; 10856: 		m_PotentialBlocks[iI].SetNumChoices(iNumFound);

	mov	DWORD PTR [edx+ecx+8], ebx
	mov	ecx, DWORD PTR _iI$225845[esp+32]
	mov	eax, DWORD PTR [esi+26600]
	inc	ecx
	add	edx, 16					; 00000010H
	mov	DWORD PTR _iI$225845[esp+32], ecx
	cmp	ecx, eax
	jb	SHORT $LL84@RemoveChos
$LN5@RemoveChos:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10857: #endif
; 10858: 	}
; 10859: }

	add	esp, 20					; 00000014H
	ret	4
?RemoveChosenUnits@CvTacticalAI@@AAEXH@Z ENDP		; CvTacticalAI::RemoveChosenUnits
_TEXT	ENDS
PUBLIC	?ChooseRemainingAssignments@CvTacticalAI@@AAE_NHH@Z ; CvTacticalAI::ChooseRemainingAssignments
; Function compile flags: /Ogtpy
;	COMDAT ?ChooseRemainingAssignments@CvTacticalAI@@AAE_NHH@Z
_TEXT	SEGMENT
_iI$225907 = -84					; size = 4
_iBestScore$ = -84					; size = 4
tv896 = -80						; size = 4
_iScore$ = -76						; size = 4
_iCurrent$ = -72					; size = 24
_iFirst$ = -48						; size = 24
_iLast$ = -24						; size = 24
_iI$225920 = 8						; size = 4
_iBlocksToCreate$ = 8					; size = 4
_iNumUnitsDesired$ = 8					; size = 4
_iNumUnitsAcceptable$ = 12				; size = 4
?ChooseRemainingAssignments@CvTacticalAI@@AAE_NHH@Z PROC ; CvTacticalAI::ChooseRemainingAssignments, COMDAT
; _this$ = ecx

; 10902: {

	sub	esp, 84					; 00000054H
	push	ebx

; 10903: 	int iBestScore = 0;
; 10904: 	int iScore;
; 10905: 	int iCurrent[NUM_DIRECTION_TYPES];
; 10906: 	int iFirst[NUM_DIRECTION_TYPES];
; 10907: 	int iLast[NUM_DIRECTION_TYPES];
; 10908: 
; 10909: 	int iBlocksToCreate = iNumUnitsDesired - (int)m_ChosenBlocks.size();

	mov	ebx, DWORD PTR _iNumUnitsDesired$[esp+84]
	push	ebp
	mov	ebp, ecx
	xor	ecx, ecx
	mov	edx, ebx
	sub	edx, DWORD PTR [ebp+27432]
	mov	DWORD PTR _iBestScore$[esp+92], ecx
	mov	DWORD PTR _iBlocksToCreate$[esp+88], edx

; 10910: 
; 10911: 	if(iBlocksToCreate == 0)

	jne	SHORT $LN27@ChooseRema
	pop	ebp

; 10912: 	{
; 10913: 		return true;

	mov	al, 1
	pop	ebx

; 11023: }

	add	esp, 84					; 00000054H
	ret	8
$LN27@ChooseRema:

; 10914: 	}
; 10915: 
; 10916: 	FAssertMsg(iBlocksToCreate <= NUM_DIRECTION_TYPES, "More than NUM_DIRECTION_TYPES hexes to block. Will cause array overflows and performance issues!");
; 10917: 
; 10918: 	if(iBlocksToCreate > 0 && iBlocksToCreate < NUM_DIRECTION_TYPES)

	lea	eax, DWORD PTR [edx-1]
	cmp	eax, 4
	ja	$LN26@ChooseRema
	push	esi

; 10919: 	{
; 10920: 		m_NewlyChosen.clear();
; 10921: 
; 10922: 		// Set up indexes pointing to the possible choices
; 10923: 		int iLevel = 0;
; 10924: 		int iCurIndex = 0;

	xor	eax, eax

; 10925: 		while(iLevel < iBlocksToCreate)

	cmp	edx, ecx
	push	edi
	mov	DWORD PTR [ebp+28040], ecx
	jle	SHORT $LN24@ChooseRema
	mov	esi, DWORD PTR [ebp+26596]
	npad	7
$LL25@ChooseRema:

; 10926: 		{
; 10927: 			iFirst[iLevel] = iCurIndex;
; 10928: 			int iNumChoices = m_PotentialBlocks[iCurIndex].GetNumChoices();

	mov	edi, eax
	shl	edi, 4

; 10929: 
; 10930: 			FAssertMsg(iNumChoices > 0, "Invalid number of tactical AI move choices. Will cause array overflows and performance issues!");
; 10931: 			FAssertMsg(iNumChoices + iCurIndex <= (int)m_PotentialBlocks.size(), "Invalid number of tactical AI move choices. Will cause array overflows and performance issues!");
; 10932: 
; 10933: 			iLast[iLevel] = iCurIndex + iNumChoices - 1;

	mov	edi, DWORD PTR [edi+esi+8]
	mov	DWORD PTR _iFirst$[esp+ecx*4+100], eax
	lea	eax, DWORD PTR [edi+eax-1]
	mov	DWORD PTR _iLast$[esp+ecx*4+100], eax

; 10934: 			iCurIndex = iLast[iLevel] + 1;
; 10935: 			iLevel++;

	inc	ecx
	inc	eax
	cmp	ecx, edx
	jl	SHORT $LL25@ChooseRema
$LN24@ChooseRema:

; 10936: 		}
; 10937: 
; 10938: 		for(int iI = 0; iI < iBlocksToCreate; iI++)

	test	edx, edx
	jle	SHORT $LN23@ChooseRema
	mov	ecx, edx
	lea	esi, DWORD PTR _iFirst$[esp+100]
	lea	edi, DWORD PTR _iCurrent$[esp+100]
	rep movsd
$LN23@ChooseRema:

; 10957: 			}
; 10958: 
; 10959: 			iScore = ScoreAssignments(iNumUnitsDesired != iNumUnitsAcceptable /*bCanLeaveOpenings*/);

	cmp	ebx, DWORD PTR _iNumUnitsAcceptable$[esp+96]
	setne	BYTE PTR tv896[esp+100]

; 10998: 				}
; 10999: 			}
; 11000: 
; 11001: 			if(!bIncrementDone)

	jmp	SHORT $LL20@ChooseRema
$LL115@ChooseRema:
	mov	edx, DWORD PTR _iBlocksToCreate$[esp+96]
	npad	6
$LL20@ChooseRema:

; 10946: 		{
; 10947: 			m_TemporaryBlocks.clear();

	xor	ebx, ebx

; 10948: 
; 10949: 			// Create this choice
; 10950: 			for(int iI = 0; iI < iBlocksToCreate; iI++)

	cmp	edx, ebx
	mov	DWORD PTR [ebp+27016], ebx
	jle	SHORT $LN16@ChooseRema
	lea	esi, DWORD PTR [ebp+27012]
$LL18@ChooseRema:

; 10951: 			{
; 10952: 				if(iI >= (int)m_PotentialBlocks.size())
; 10953: 				{
; 10954: 					FAssertMsg(false, "Invalid fast vector index - show Ed");
; 10955: 				}
; 10956: 				m_TemporaryBlocks.push_back(m_PotentialBlocks[iCurrent[iI]]);

	mov	edi, DWORD PTR _iCurrent$[esp+ebx*4+100]
	mov	eax, DWORD PTR [esi+8]
	shl	edi, 4
	add	edi, DWORD PTR [ebp+26596]
	mov	BYTE PTR [esi+412], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN56@ChooseRema
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
	mov	edx, DWORD PTR _iBlocksToCreate$[esp+96]
$LN56@ChooseRema:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN59@ChooseRema
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+12], ecx
$LN59@ChooseRema:
	inc	DWORD PTR [esi+4]
	inc	ebx
	cmp	ebx, edx
	jl	SHORT $LL18@ChooseRema
$LN16@ChooseRema:

; 10957: 			}
; 10958: 
; 10959: 			iScore = ScoreAssignments(iNumUnitsDesired != iNumUnitsAcceptable /*bCanLeaveOpenings*/);

	mov	edx, DWORD PTR tv896[esp+100]
	push	edx
	mov	ecx, ebp
	call	?ScoreAssignments@CvTacticalAI@@AAEH_N@Z ; CvTacticalAI::ScoreAssignments

; 10960: 
; 10961: 			// If best so far, save it off
; 10962: 			if(iScore > iBestScore)

	cmp	eax, DWORD PTR _iBestScore$[esp+100]
	mov	DWORD PTR _iScore$[esp+100], eax
	jle	$LN14@ChooseRema

; 10963: 			{
; 10964: 				m_NewlyChosen.clear();

	xor	ebx, ebx
	mov	DWORD PTR [ebp+28040], ebx

; 10965: #ifdef AUI_ITERATORIZE
; 10966: 				for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_TemporaryBlocks.begin(); it != m_TemporaryBlocks.end(); ++it)
; 10967: 				{
; 10968: 					if (it->GetDistanceToTarget() != MAX_INT)
; 10969: 					{
; 10970: 						m_NewlyChosen.push_back(*it);
; 10971: #else
; 10972: 				for(unsigned int iI = 0; iI < m_TemporaryBlocks.size(); iI++)

	mov	DWORD PTR _iI$225907[esp+100], ebx
	cmp	DWORD PTR [ebp+27016], ebx
	jbe	SHORT $LN11@ChooseRema
$LL13@ChooseRema:

; 10973: 				{
; 10974: 					if(m_TemporaryBlocks[iI].GetDistanceToTarget() != MAX_INT)

	mov	eax, DWORD PTR [ebp+27012]
	cmp	DWORD PTR [ebx+eax+12], 2147483647	; 7fffffffH
	lea	edi, DWORD PTR [ebx+eax]
	je	SHORT $LN12@ChooseRema

; 10975: 					{
; 10976: 						m_NewlyChosen.push_back(m_TemporaryBlocks[iI]);

	mov	eax, DWORD PTR [ebp+28044]
	lea	esi, DWORD PTR [ebp+28036]
	mov	BYTE PTR [esi+604], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN79@ChooseRema
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::GrowSize
$LN79@ChooseRema:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN82@ChooseRema
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+12], edx
$LN82@ChooseRema:
	inc	DWORD PTR [esi+4]
$LN12@ChooseRema:

; 10965: #ifdef AUI_ITERATORIZE
; 10966: 				for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_TemporaryBlocks.begin(); it != m_TemporaryBlocks.end(); ++it)
; 10967: 				{
; 10968: 					if (it->GetDistanceToTarget() != MAX_INT)
; 10969: 					{
; 10970: 						m_NewlyChosen.push_back(*it);
; 10971: #else
; 10972: 				for(unsigned int iI = 0; iI < m_TemporaryBlocks.size(); iI++)

	mov	eax, DWORD PTR _iI$225907[esp+100]
	inc	eax
	add	ebx, 16					; 00000010H
	mov	DWORD PTR _iI$225907[esp+100], eax
	cmp	eax, DWORD PTR [ebp+27016]
	jb	SHORT $LL13@ChooseRema
	mov	eax, DWORD PTR _iScore$[esp+100]
$LN11@ChooseRema:

; 10977: #endif
; 10978: 					}
; 10979: 				}
; 10980: 				iBestScore = iScore;

	mov	DWORD PTR _iBestScore$[esp+100], eax
$LN14@ChooseRema:

; 10981: 			}
; 10982: 
; 10983: 			// Increment proper index
; 10984: 			bool bIncrementDone = false;

	mov	eax, DWORD PTR _iBlocksToCreate$[esp+96]
	dec	eax
	mov	esi, eax

; 10985: 			for(int iLevelIndex = iBlocksToCreate - 1; !bIncrementDone && iLevelIndex >= 0 && iLevelIndex < NUM_DIRECTION_TYPES; iLevelIndex--)

	add	eax, eax
	xor	dl, dl
	add	eax, eax
	npad	1
$LL9@ChooseRema:
	cmp	esi, 5
	ja	SHORT $LN7@ChooseRema

; 10986: 			{
; 10987: 				// See if at end of line for this index
; 10988: 				if(iCurrent[iLevelIndex] + 1 > iLast[iLevelIndex])

	mov	ecx, DWORD PTR _iCurrent$[esp+eax+100]
	inc	ecx
	cmp	ecx, DWORD PTR _iLast$[esp+eax+100]
	jle	SHORT $LN6@ChooseRema

; 10989: 				{
; 10990: 					// Reset to first one and keep iterating
; 10991: 					iCurrent[iLevelIndex] = iFirst[iLevelIndex];

	mov	ecx, DWORD PTR _iFirst$[esp+eax+100]

; 10992: 				}
; 10993: 
; 10994: 				else

	jmp	SHORT $LN122@ChooseRema
$LN6@ChooseRema:

; 10997: 					bIncrementDone = true;

	mov	dl, 1
$LN122@ChooseRema:

; 10995: 				{
; 10996: 					iCurrent[iLevelIndex]++;

	mov	DWORD PTR _iCurrent$[esp+eax+100], ecx
	dec	esi
	sub	eax, 4
	test	dl, dl
	je	SHORT $LL9@ChooseRema

; 10998: 				}
; 10999: 			}
; 11000: 
; 11001: 			if(!bIncrementDone)

	jmp	$LL115@ChooseRema
$LN7@ChooseRema:
	test	dl, dl

; 10939: 		{
; 10940: 			iCurrent[iI] = iFirst[iI];
; 10941: 		}
; 10942: 
; 10943: 		// Loop through each possibility
; 10944: 		bool bDone = false;
; 10945: 		while(!bDone)

	jne	$LL115@ChooseRema

; 11002: 			{
; 11003: 				bDone = true;
; 11004: 			}
; 11005: 		}
; 11006: 
; 11007: 		// Copy final choices into output
; 11008: #ifdef AUI_ITERATORIZE
; 11009: 		for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_NewlyChosen.begin(); it != m_NewlyChosen.end(); ++it)
; 11010: 		{
; 11011: 			m_ChosenBlocks.push_back(*it);
; 11012: #else
; 11013: 		for(unsigned int iI = 0; iI < m_NewlyChosen.size(); iI++)

	xor	ebx, ebx
	mov	DWORD PTR _iI$225920[esp+96], ebx
	cmp	DWORD PTR [ebp+28040], ebx
	jbe	SHORT $LN1@ChooseRema
	lea	esi, DWORD PTR [ebp+27428]
$LL3@ChooseRema:
	mov	edi, DWORD PTR [ebp+28036]

; 11014: 		{
; 11015: 			m_ChosenBlocks.push_back(m_NewlyChosen[iI]);

	mov	eax, DWORD PTR [esi+8]
	add	edi, ebx
	mov	BYTE PTR [esi+604], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN90@ChooseRema
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::GrowSize
$LN90@ChooseRema:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN93@ChooseRema
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+12], ecx
$LN93@ChooseRema:
	mov	eax, DWORD PTR _iI$225920[esp+96]
	inc	DWORD PTR [esi+4]
	inc	eax
	add	ebx, 16					; 00000010H
	mov	DWORD PTR _iI$225920[esp+96], eax
	cmp	eax, DWORD PTR [ebp+28040]
	jb	SHORT $LL3@ChooseRema
$LN1@ChooseRema:

; 11016: #endif
; 11017: 		}
; 11018: 
; 11019: 		return (int)m_ChosenBlocks.size() >= iNumUnitsAcceptable;

	mov	edx, DWORD PTR _iNumUnitsAcceptable$[esp+96]
	pop	edi
	xor	eax, eax
	cmp	DWORD PTR [ebp+27432], edx
	pop	esi
	pop	ebp
	setge	al
	pop	ebx

; 11023: }

	add	esp, 84					; 00000054H
	ret	8
$LN26@ChooseRema:
	pop	ebp

; 11020: 	}
; 11021: 
; 11022: 	return false;

	xor	al, al
	pop	ebx

; 11023: }

	add	esp, 84					; 00000054H
	ret	8
?ChooseRemainingAssignments@CvTacticalAI@@AAE_NHH@Z ENDP ; CvTacticalAI::ChooseRemainingAssignments
_TEXT	ENDS
PUBLIC	?ScoreCloseOnPlots@CvTacticalAI@@AAEHPAVCvPlot@@_N@Z ; CvTacticalAI::ScoreCloseOnPlots
EXTRN	?CanUseForOperationGathering@CvTacticalAnalysisCell@@QAE_NXZ:PROC ; CvTacticalAnalysisCell::CanUseForOperationGathering
; Function compile flags: /Ogtpy
;	COMDAT ?ScoreCloseOnPlots@CvTacticalAI@@AAEHPAVCvPlot@@_N@Z
_TEXT	SEGMENT
_bCloseEnough$225970 = -51				; size = 1
_bChoiceBombardSpot$ = -50				; size = 1
_bSafeFromAttack$ = -49					; size = 1
_this$ = -48						; size = 4
_iI$225971 = -44					; size = 4
_iRtnValue$ = -40					; size = 4
_jJ$225960 = -36					; size = 4
_iPlotDistance$225965 = -32				; size = 4
_target$ = -28						; size = 28
_pTarget$ = 8						; size = 4
_bLandOnly$ = 12					; size = 1
?ScoreCloseOnPlots@CvTacticalAI@@AAEHPAVCvPlot@@_N@Z PROC ; CvTacticalAI::ScoreCloseOnPlots, COMDAT
; _this$ = ecx

; 11099: {

	sub	esp, 52					; 00000034H
	push	ebx

; 11100: 	int iScore;
; 11101: 	CvPlot* pPlot;
; 11102: 	CvTacticalAnalysisCell* pCell;
; 11103: 	bool bChoiceBombardSpot;
; 11104: 	bool bSafeFromAttack;
; 11105: 	CvTacticalTarget target;

	xor	ebx, ebx
	or	eax, -1
	push	ebp
	push	esi

; 11106: 	int iRtnValue = 0;
; 11107: 
; 11108: 	// We'll store the hexes we've found here
; 11109: 	m_TempTargets.clear();
; 11110: 
; 11111: 	for(int jJ = 0; jJ < NUM_CITY_PLOTS; jJ++)

	xor	edx, edx
	push	edi
	mov	DWORD PTR _this$[esp+68], ecx
	mov	DWORD PTR _target$[esp+68], ebx
	mov	DWORD PTR _target$[esp+72], eax
	mov	DWORD PTR _target$[esp+76], eax
	mov	DWORD PTR _target$[esp+80], eax
	mov	DWORD PTR _target$[esp+92], eax
	mov	DWORD PTR _target$[esp+84], ebx
	mov	DWORD PTR _target$[esp+88], ebx
	mov	DWORD PTR _iRtnValue$[esp+68], ebx
	mov	DWORD PTR [ecx+23708], ebx
	mov	DWORD PTR _jJ$225960[esp+68], edx
	jmp	SHORT $LN20@ScoreClose
	npad	2
$LL167@ScoreClose:
	xor	ebx, ebx
$LN20@ScoreClose:

; 11112: 	{
; 11113: 		pPlot = plotCity(pTarget->getX(), pTarget->getY(), jJ);

	mov	esi, DWORD PTR _pTarget$[esp+64]
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 11114: 
; 11115: 		if(pPlot != NULL)

	cmp	edi, ebx
	je	$LN19@ScoreClose

; 11116: 		{
; 11117: 			bChoiceBombardSpot = false;
; 11118: 			bSafeFromAttack = true;
; 11119: 
; 11120: 			int iPlotDistance = plotDistance(pPlot->getX(), pPlot->getY(), pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	movsx	ebp, WORD PTR [edi+2]
	movsx	ebx, WORD PTR [edi]
	push	eax
	push	ecx
	push	ebp
	push	ebx
	mov	BYTE PTR _bChoiceBombardSpot$[esp+84], 0
	mov	BYTE PTR _bSafeFromAttack$[esp+84], 1
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 11121: 			int iPlotIndex = GC.getMap().plotNum(pPlot->getX(), pPlot->getY());
; 11122: 			pCell = m_pMap->GetCell(iPlotIndex);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [edx+4020]
	imul	esi, ebp
	add	esi, ebx
	imul	esi, 44					; 0000002cH
	mov	DWORD PTR _iPlotDistance$225965[esp+84], eax
	mov	eax, DWORD PTR _this$[esp+84]
	mov	ecx, DWORD PTR [eax+4]
	add	esi, DWORD PTR [ecx+12]
	add	esp, 16					; 00000010H

; 11123: 
; 11124: 			if((bLandOnly && pCell->CanUseForOperationGatheringCheckWater(false /*bWater*/)) || (!bLandOnly && pCell->CanUseForOperationGathering()))

	cmp	BYTE PTR _bLandOnly$[esp+64], 0
	mov	ecx, esi
	je	SHORT $LN155@ScoreClose
	push	0
	call	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
	test	al, al
	jne	SHORT $LN15@ScoreClose
	jmp	$LN19@ScoreClose
$LN155@ScoreClose:
	call	?CanUseForOperationGathering@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::CanUseForOperationGathering
	test	al, al
	je	$LN19@ScoreClose
$LN15@ScoreClose:

; 11125: 			{
; 11126: 				bool bCloseEnough = false;
; 11127: 				for(unsigned int iI = 0; iI < m_OperationUnits.size() && !bCloseEnough; iI++)

	mov	edx, DWORD PTR _this$[esp+68]
	cmp	DWORD PTR [edx+28648], 0
	mov	BYTE PTR _bCloseEnough$225970[esp+68], 0
	mov	DWORD PTR _iI$225971[esp+68], 0
	jbe	$LN19@ScoreClose
	npad	4
$LL164@ScoreClose:
	cmp	BYTE PTR _bCloseEnough$225970[esp+68], 0
	jne	SHORT $LN154@ScoreClose

; 11128: 				{
; 11129: 					UnitHandle pUnit = m_pPlayer->getUnit(m_OperationUnits[iI].GetUnitID());

	mov	ebx, DWORD PTR _this$[esp+68]
	mov	eax, DWORD PTR [ebx+28644]
	mov	ecx, DWORD PTR _iI$225971[esp+68]
	mov	eax, DWORD PTR [eax+ecx*8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebp, eax
	test	ebp, ebp
	je	SHORT $LN12@ScoreClose
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 11130: 					if(pUnit)
; 11131: 					{
; 11132: 						if(plotDistance(pPlot->getX(), pPlot->getY(), pUnit->getX(), pUnit->getY()) <= m_iDeployRadius)

	mov	edx, DWORD PTR [ebp+88]
	mov	eax, DWORD PTR [ebp+76]
	movsx	ecx, WORD PTR [edi+2]
	push	edx
	movsx	edx, WORD PTR [edi]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR [ebx+24772]
	jg	SHORT $LN9@ScoreClose

; 11133: 						{
; 11134: 							bCloseEnough = true;

	mov	BYTE PTR _bCloseEnough$225970[esp+68], 1
$LN9@ScoreClose:

; 11135: 						}
; 11136: 					}
; 11137: 				}

	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@ScoreClose:
	mov	eax, DWORD PTR _iI$225971[esp+68]
	inc	eax
	mov	DWORD PTR _iI$225971[esp+68], eax
	cmp	eax, DWORD PTR [ebx+28648]
	jb	SHORT $LL164@ScoreClose

; 11138: 
; 11139: 				if(bCloseEnough)

	cmp	BYTE PTR _bCloseEnough$225970[esp+68], 0
	je	$LN19@ScoreClose
$LN154@ScoreClose:

; 11140: 				{
; 11141: 					iScore = 600 - (iPlotDistance * 100);
; 11142: 
; 11143: 					// Top priority is hexes to bombard from (within range but not adjacent)
; 11144: 					if(pCell->IsWithinRangeOfTarget() && iPlotDistance > 1)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _iPlotDistance$225965[esp+68]
	mov	ebp, 6
	sub	ebp, ecx
	mov	edx, eax
	imul	ebp, 100				; 00000064H
	shr	edx, 17					; 00000011H
	test	dl, 1
	je	SHORT $LN158@ScoreClose
	cmp	ecx, 1
	jle	SHORT $LN158@ScoreClose

; 11145: 					{
; 11146: 						bChoiceBombardSpot = true;
; 11147: 						iRtnValue++;

	inc	DWORD PTR _iRtnValue$[esp+68]
	mov	bl, 1
	jmp	SHORT $LN7@ScoreClose
$LN158@ScoreClose:
	mov	bl, BYTE PTR _bChoiceBombardSpot$[esp+68]
$LN7@ScoreClose:

; 11148: 					}
; 11149: 
; 11150: 					if(pCell->IsSubjectToAttack())

	mov	ecx, eax
	shr	ecx, 5
	test	cl, 1
	je	SHORT $LN159@ScoreClose

; 11151: 					{
; 11152: 						iScore -= 30;

	sub	ebp, 30					; 0000001eH

; 11153: 						bSafeFromAttack = false;

	mov	BYTE PTR _bSafeFromAttack$[esp+68], 0
$LN159@ScoreClose:

; 11154: 					}
; 11155: 
; 11156: 					if(pCell->IsEnemyCanMovePast())

	shr	eax, 6
	test	al, 1
	je	SHORT $LN5@ScoreClose

; 11157: 					{
; 11158: 						iScore -= 30;

	sub	ebp, 30					; 0000001eH
$LN5@ScoreClose:

; 11159: 					}
; 11160: 					if(pPlot->isCity() && pPlot->getOwner() == m_pPlayer->GetID())

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN165@ScoreClose
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN165@ScoreClose
	mov	edx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN165@ScoreClose
	movsx	eax, BYTE PTR [edi+4]
	mov	ecx, DWORD PTR _this$[esp+68]
	mov	edx, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+44]
	jne	SHORT $LN165@ScoreClose

; 11161: 					{
; 11162: 						iScore += 100;

	add	ebp, 100				; 00000064H

; 11163: 					}
; 11164: 					else

	jmp	SHORT $LN3@ScoreClose
$LN165@ScoreClose:

; 11165: 					{
; 11166: 						iScore += pCell->GetDefenseModifier();

	add	ebp, DWORD PTR [esi+28]
$LN3@ScoreClose:

; 11167: 					}
; 11168: 
; 11169: 					pCell->SetSafeForDeployment(bChoiceBombardSpot || bSafeFromAttack);

	test	bl, bl
	jne	SHORT $LN23@ScoreClose
	cmp	BYTE PTR _bSafeFromAttack$[esp+68], bl
	je	SHORT $LN124@ScoreClose
$LN23@ScoreClose:
	or	DWORD PTR [esi], 524288			; 00080000H
	jmp	SHORT $LN123@ScoreClose
$LN124@ScoreClose:
	and	DWORD PTR [esi], -524289		; fff7ffffH
$LN123@ScoreClose:

; 11170: 					pCell->SetDeploymentScore(iScore);
; 11171: 
; 11172: 					// Save this in our list of potential targets
; 11173: 					target.SetTargetX(pPlot->getX());
; 11174: 					target.SetTargetY(pPlot->getY());
; 11175: 					target.SetAuxIntData(iScore);
; 11176: 
; 11177: 					// A bit of a hack -- use high priority targets to indicate good plots for ranged units
; 11178: 					if(bChoiceBombardSpot)

	xor	edx, edx
	mov	DWORD PTR [esi+32], ebp
	movsx	eax, WORD PTR [edi]
	movsx	ecx, WORD PTR [edi+2]
	test	bl, bl
	setne	dl
	mov	DWORD PTR _target$[esp+88], ebp

; 11179: 					{
; 11180: 						target.SetTargetType(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT);
; 11181: 					}
; 11182: 					else
; 11183: 					{
; 11184: 						target.SetTargetType(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT);
; 11185: 					}
; 11186: 
; 11187: 					m_TempTargets.push_back(target);

	mov	ebp, DWORD PTR _this$[esp+68]
	add	ebp, 23704				; 00005c98H
	mov	DWORD PTR _target$[esp+72], eax
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR _target$[esp+76], ecx
	lea	edx, DWORD PTR [edx+edx+5]
	mov	DWORD PTR _target$[esp+68], edx
	mov	BYTE PTR [ebp+1048], 0
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN143@ScoreClose
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::GrowSize
$LN143@ScoreClose:
	mov	eax, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edi, DWORD PTR [edx+ecx*4]
	test	edi, edi
	je	SHORT $LN146@ScoreClose
	mov	ecx, 7
	lea	esi, DWORD PTR _target$[esp+68]
	rep movsd
$LN146@ScoreClose:
	inc	DWORD PTR [ebp+4]
$LN19@ScoreClose:

; 11106: 	int iRtnValue = 0;
; 11107: 
; 11108: 	// We'll store the hexes we've found here
; 11109: 	m_TempTargets.clear();
; 11110: 
; 11111: 	for(int jJ = 0; jJ < NUM_CITY_PLOTS; jJ++)

	mov	edx, DWORD PTR _jJ$225960[esp+68]
	inc	edx
	cmp	edx, 37					; 00000025H
	mov	DWORD PTR _jJ$225960[esp+68], edx
	jl	$LL167@ScoreClose

; 11188: 				}
; 11189: 			}
; 11190: 		}
; 11191: 	}
; 11192: 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[esp+68]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 11193: }

	add	esp, 52					; 00000034H
	ret	8
?ScoreCloseOnPlots@CvTacticalAI@@AAEHPAVCvPlot@@_N@Z ENDP ; CvTacticalAI::ScoreCloseOnPlots
_TEXT	ENDS
PUBLIC	?ScoreHedgehogPlots@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ScoreHedgehogPlots
; Function compile flags: /Ogtpy
;	COMDAT ?ScoreHedgehogPlots@CvTacticalAI@@AAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_bSafeFromAttack$ = -41					; size = 1
_this$ = -40						; size = 4
_jJ$225996 = -36					; size = 4
_iPlotDistance$226001 = -32				; size = 4
_target$ = -28						; size = 28
_pTarget$ = 8						; size = 4
?ScoreHedgehogPlots@CvTacticalAI@@AAEXPAVCvPlot@@@Z PROC ; CvTacticalAI::ScoreHedgehogPlots, COMDAT
; _this$ = ecx

; 11197: {

	sub	esp, 44					; 0000002cH
	push	ebx

; 11198: 	int iScore;
; 11199: 	CvPlot* pPlot;
; 11200: 	CvTacticalAnalysisCell* pCell;
; 11201: 	bool bChoiceBombardSpot;
; 11202: 	bool bSafeFromAttack;
; 11203: 	CvTacticalTarget target;

	xor	ebx, ebx
	or	eax, -1
	push	ebp
	push	esi

; 11204: 
; 11205: 	// We'll store the hexes we've found here
; 11206: 	m_TempTargets.clear();
; 11207: 
; 11208: 	for(int jJ = 0; jJ < NUM_CITY_PLOTS; jJ++)

	xor	edx, edx
	push	edi
	mov	DWORD PTR _this$[esp+60], ecx
	mov	DWORD PTR _target$[esp+60], ebx
	mov	DWORD PTR _target$[esp+64], eax
	mov	DWORD PTR _target$[esp+68], eax
	mov	DWORD PTR _target$[esp+72], eax
	mov	DWORD PTR _target$[esp+84], eax
	mov	DWORD PTR _target$[esp+76], ebx
	mov	DWORD PTR _target$[esp+80], ebx
	mov	DWORD PTR [ecx+23708], ebx
	mov	DWORD PTR _jJ$225996[esp+60], edx
	jmp	SHORT $LN11@ScoreHedge
	npad	6
$LL108@ScoreHedge:
	xor	ebx, ebx
$LN11@ScoreHedge:

; 11209: 	{
; 11210: 		pPlot = plotCity(pTarget->getX(), pTarget->getY(), jJ);

	mov	esi, DWORD PTR _pTarget$[esp+56]
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 11211: 
; 11212: 		if(pPlot != NULL)

	cmp	edi, ebx
	je	$LN10@ScoreHedge

; 11213: 		{
; 11214: 			bChoiceBombardSpot = false;
; 11215: 			bSafeFromAttack = true;
; 11216: 
; 11217: 			int iPlotDistance = plotDistance(pPlot->getX(), pPlot->getY(), pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	movsx	ebp, WORD PTR [edi+2]
	movsx	ebx, WORD PTR [edi]
	push	eax
	push	ecx
	push	ebp
	push	ebx
	mov	BYTE PTR _bSafeFromAttack$[esp+76], 1
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 11218: 			int iPlotIndex = GC.getMap().plotNum(pPlot->getX(), pPlot->getY());
; 11219: 			pCell = m_pMap->GetCell(iPlotIndex);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [edx+4020]
	imul	esi, ebp
	add	esi, ebx
	imul	esi, 44					; 0000002cH
	mov	DWORD PTR _iPlotDistance$226001[esp+76], eax
	mov	eax, DWORD PTR _this$[esp+76]
	mov	ecx, DWORD PTR [eax+4]
	add	esi, DWORD PTR [ecx+12]
	add	esp, 16					; 00000010H

; 11220: 
; 11221: 			if(pCell->CanUseForOperationGatheringCheckWater(false /*bWater*/))

	push	0
	mov	ecx, esi
	call	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
	test	al, al
	je	$LN10@ScoreHedge

; 11222: 			{
; 11223: 				iScore = 600 - (iPlotDistance * 150);
; 11224: 
; 11225: 				if(pCell->IsSubjectToAttack())

	mov	eax, DWORD PTR [esi]
	mov	ebp, 4
	sub	ebp, DWORD PTR _iPlotDistance$226001[esp+60]
	mov	edx, eax
	shr	edx, 5
	imul	ebp, 150				; 00000096H
	test	dl, 1
	je	SHORT $LN102@ScoreHedge

; 11226: 				{
; 11227: 					iScore += 100;

	add	ebp, 100				; 00000064H

; 11228: 					bSafeFromAttack = false;

	xor	bl, bl
	jmp	SHORT $LN6@ScoreHedge
$LN102@ScoreHedge:
	mov	bl, BYTE PTR _bSafeFromAttack$[esp+60]
$LN6@ScoreHedge:

; 11229: 				}
; 11230: 				if(pCell->IsEnemyCanMovePast())

	shr	eax, 6
	test	al, 1
	je	SHORT $LN5@ScoreHedge

; 11231: 				{
; 11232: 					iScore += 50;

	add	ebp, 50					; 00000032H
$LN5@ScoreHedge:

; 11233: 				}
; 11234: 				if(pPlot->isCity() && pPlot->getOwner() == m_pPlayer->GetID())

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN106@ScoreHedge
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN106@ScoreHedge
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN106@ScoreHedge
	movsx	edx, BYTE PTR [edi+4]
	mov	eax, DWORD PTR _this$[esp+60]
	mov	ecx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+44]
	jne	SHORT $LN106@ScoreHedge

; 11235: 				{
; 11236: 					iScore += 100;

	add	ebp, 100				; 00000064H

; 11237: 				}
; 11238: 				else

	jmp	SHORT $LN3@ScoreHedge
$LN106@ScoreHedge:

; 11239: 				{
; 11240: 					iScore += pCell->GetDefenseModifier() * 4;

	mov	edx, DWORD PTR [esi+28]
	lea	ebp, DWORD PTR [ebp+edx*4]
$LN3@ScoreHedge:

; 11241: 				}
; 11242: 
; 11243: 				pCell->SetSafeForDeployment(bSafeFromAttack);

	test	bl, bl
	je	SHORT $LN74@ScoreHedge
	or	DWORD PTR [esi], 524288			; 00080000H
	jmp	SHORT $LN73@ScoreHedge
$LN74@ScoreHedge:
	and	DWORD PTR [esi], -524289		; fff7ffffH
$LN73@ScoreHedge:

; 11244: 				pCell->SetDeploymentScore(iScore);
; 11245: 
; 11246: 				// Save this in our list of potential targets
; 11247: 				target.SetTargetX(pPlot->getX());
; 11248: 				target.SetTargetY(pPlot->getY());
; 11249: 				target.SetAuxIntData(iScore);
; 11250: 
; 11251: 				// A bit of a hack -- use high priority targets to indicate good plots for ranged units
; 11252: 				if(bSafeFromAttack)

	xor	edx, edx
	mov	DWORD PTR [esi+32], ebp
	movsx	eax, WORD PTR [edi]
	movsx	ecx, WORD PTR [edi+2]
	test	bl, bl
	setne	dl
	mov	DWORD PTR _target$[esp+80], ebp

; 11253: 				{
; 11254: 					target.SetTargetType(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT);
; 11255: 				}
; 11256: 				else
; 11257: 				{
; 11258: 					target.SetTargetType(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT);
; 11259: 				}
; 11260: 
; 11261: 				m_TempTargets.push_back(target);

	mov	ebp, DWORD PTR _this$[esp+60]
	add	ebp, 23704				; 00005c98H
	mov	DWORD PTR _target$[esp+64], eax
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR _target$[esp+68], ecx
	lea	edx, DWORD PTR [edx+edx+5]
	mov	DWORD PTR _target$[esp+60], edx
	mov	BYTE PTR [ebp+1048], 0
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN93@ScoreHedge
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::GrowSize
$LN93@ScoreHedge:
	mov	eax, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edi, DWORD PTR [edx+ecx*4]
	test	edi, edi
	je	SHORT $LN96@ScoreHedge
	mov	ecx, 7
	lea	esi, DWORD PTR _target$[esp+60]
	rep movsd
$LN96@ScoreHedge:
	inc	DWORD PTR [ebp+4]
$LN10@ScoreHedge:

; 11204: 
; 11205: 	// We'll store the hexes we've found here
; 11206: 	m_TempTargets.clear();
; 11207: 
; 11208: 	for(int jJ = 0; jJ < NUM_CITY_PLOTS; jJ++)

	mov	edx, DWORD PTR _jJ$225996[esp+60]
	inc	edx
	cmp	edx, 37					; 00000025H
	mov	DWORD PTR _jJ$225996[esp+60], edx
	jl	$LL108@ScoreHedge
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 11262: 			}
; 11263: 		}
; 11264: 	}
; 11265: }

	add	esp, 44					; 0000002cH
	ret	4
?ScoreHedgehogPlots@CvTacticalAI@@AAEXPAVCvPlot@@@Z ENDP ; CvTacticalAI::ScoreHedgehogPlots
_TEXT	ENDS
PUBLIC	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z		; CvTacticalAI::UnitProcessed
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?UnitProcessed@CvTacticalAI@@AAEXH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UnitProcessed@CvTacticalAI@@AAEXH_N@Z$0
__ehfuncinfo$?UnitProcessed@CvTacticalAI@@AAEXH_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UnitProcessed@CvTacticalAI@@AAEXH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?UnitProcessed@CvTacticalAI@@AAEXH_N@Z
_TEXT	SEGMENT
_pUnit$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_iID$ = 8						; size = 4
_bMarkTacticalMap$ = 12					; size = 1
?UnitProcessed@CvTacticalAI@@AAEXH_N@Z PROC		; CvTacticalAI::UnitProcessed, COMDAT
; _this$ = ecx

; 11447: {

	push	-1
	push	__ehhandler$?UnitProcessed@CvTacticalAI@@AAEXH_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx

; 11448: 	UnitHandle pUnit;

	mov	DWORD PTR _pUnit$[esp+24], 0
	mov	BYTE PTR _pUnit$[esp+28], 0

; 11449: 	int iPlotIndex;
; 11450: 	CvTacticalAnalysisCell* pCell;
; 11451: 
; 11452: 	m_CurrentTurnUnits.remove(iID);

	lea	eax, DWORD PTR _iID$[esp+20]
	push	eax
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove

; 11453: 	pUnit = m_pPlayer->getUnit(iID);

	mov	ecx, DWORD PTR _iID$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$[esp+24], esi
	test	esi, esi
	je	SHORT $LN14@UnitProces
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN14@UnitProces:

; 11454: 
; 11455: 	CvAssert(pUnit);
; 11456: 	pUnit->SetTurnProcessed(true);

	push	1
	mov	ecx, esi
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed

; 11457: 
; 11458: 	if(bMarkTacticalMap)

	cmp	BYTE PTR _bMarkTacticalMap$[esp+20], 0
	je	SHORT $LN44@UnitProces

; 11459: 	{
; 11460: 		CvTacticalAnalysisMap* pMap = GC.getGame().GetTacticalAnalysisMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap

; 11461: 		if(pMap->IsBuilt())

	cmp	BYTE PTR [eax+34], 0
	je	SHORT $LN44@UnitProces

; 11462: 		{
; 11463: 			iPlotIndex = GC.getMap().plotNum(pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [ecx+4020]
	mov	edx, DWORD PTR [esi+88]
	imul	ecx, edx
	push	edi
	mov	edi, DWORD PTR [esi+76]
	add	ecx, edi

; 11464: 			pCell = pMap->GetCell(iPlotIndex);

	imul	ecx, 44					; 0000002cH
	add	ecx, DWORD PTR [eax+12]
	pop	edi

; 11465: 			pCell->SetFriendlyTurnEndTile(true);

	or	DWORD PTR [ecx], 128			; 00000080H
$LN44@UnitProces:

; 11466: 		}
; 11467: 	}
; 11468: }

	mov	DWORD PTR __$EHRec$[esp+32], -1
	test	esi, esi
	je	SHORT $LN51@UnitProces
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN51@UnitProces:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UnitProcessed@CvTacticalAI@@AAEXH_N@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?UnitProcessed@CvTacticalAI@@AAEXH_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?UnitProcessed@CvTacticalAI@@AAEXH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?UnitProcessed@CvTacticalAI@@AAEXH_N@Z ENDP		; CvTacticalAI::UnitProcessed
PUBLIC	??1?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::~vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::~vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::~vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEXXZ ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@3
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@3
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@3:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@3:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::clear
_TEXT	ENDS
PUBLIC	??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ	; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 436  : 		{	// construct empty list

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], 0

; 437  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 521  : 		_Tidy();

	jmp	?_Tidy@?$list@HV?$allocator@H@std@@@std@@IAEXXZ ; std::list<int,std::allocator<int> >::_Tidy
??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::list<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 670  : 		_Insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ; std::list<int,std::allocator<int> >::_Buynode
	push	1
	mov	ecx, esi
	mov	ebx, eax
	call	?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::list<int,std::allocator<int> >::_Incsize
	mov	DWORD PTR [edi+4], ebx
	mov	edx, DWORD PTR [ebx+4]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], ebx
	pop	ebx

; 671  : 		}

	ret	4
?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::list<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	??0?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >, COMDAT
; _this$ = ecx

; 436  : 		{	// construct empty list

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], 0

; 437  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >
_TEXT	ENDS
PUBLIC	??1?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~list<CvQueuedAttack,std::allocator<CvQueuedAttack> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~list<CvQueuedAttack,std::allocator<CvQueuedAttack> >, COMDAT
; _this$ = ecx

; 521  : 		_Tidy();

	jmp	?_Tidy@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXXZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Tidy
??1?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~list<CvQueuedAttack,std::allocator<CvQueuedAttack> >
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEIABQAVCvPlot@@H@Z ; CvWeightedVector<CvPlot *,1,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEIABQAVCvPlot@@H@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEIABQAVCvPlot@@H@Z PROC ; CvWeightedVector<CvPlot *,1,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+20], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@11
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
$LN5@push_back@11:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@11
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@11:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEIABQAVCvPlot@@H@Z ENDP ; CvWeightedVector<CvPlot *,1,1>::push_back
_TEXT	ENDS
PUBLIC	?reserve@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXI@Z ; CvWeightedVector<CvPlot *,1,1>::reserve
; Function compile flags: /Ogtpy
;	COMDAT ?reserve@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?reserve@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXI@Z PROC ; CvWeightedVector<CvPlot *,1,1>::reserve, COMDAT
; _this$ = ecx

; 128  : 		m_pItems.reserve(uiNewSize);

	jmp	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit
?reserve@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXI@Z ENDP ; CvWeightedVector<CvPlot *,1,1>::reserve
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEPAVCvTacticalUnit@@PAV3@IABV3@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEPAVCvTacticalUnit@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T264143 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$264146 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEPAVCvTacticalUnit@@PAV3@IABV3@@Z PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$264146[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T264143[esp+12], 0
	mov	eax, DWORD PTR $T264143[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvTacticalUnit@@IV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@IABV1@AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvTacticalUnit *,unsigned int,CvTacticalUnit,std::allocator<CvTacticalUnit> >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*2]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*8]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEPAVCvTacticalUnit@@PAV3@IABV3@@Z ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEPAVCvTacticalCity@@PAV3@IABV3@@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEPAVCvTacticalCity@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T264161 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$264164 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEPAVCvTacticalCity@@PAV3@IABV3@@Z PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$264164[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T264161[esp+12], 0
	mov	eax, DWORD PTR $T264161[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvTacticalCity@@IV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@IABV1@AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvTacticalCity *,unsigned int,CvTacticalCity,std::allocator<CvTacticalCity> >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*2]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEPAVCvTacticalCity@@PAV3@IABV3@@Z ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABVCvQueuedAttack@@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Insert@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABVCvQueuedAttack@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABVCvQueuedAttack@@@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Insert, COMDAT
; _this$ = ecx

; 711  : 
; 712  :  #if _HAS_ITERATOR_DEBUGGING
; 713  : 		if (_Where._Mycont != this)
; 714  : 			_DEBUG_ERROR("list insert iterator outside range");
; 715  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 716  : 
; 717  : 		_Nodeptr _Pnode = _Where._Mynode();
; 718  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

	mov	eax, DWORD PTR __Where$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR __Val$[esp+8]
	lea	ebx, DWORD PTR [eax+4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, edi
	call	?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@0ABVCvQueuedAttack@@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Buynode

; 719  : 		_Incsize(1);

	push	1
	mov	ecx, edi
	mov	esi, eax
	call	?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Incsize

; 720  : 		_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [ebx], esi

; 721  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 722  : 		}

	ret	8
?_Insert@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABVCvQueuedAttack@@@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Insert
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXPAVCvTacticalUnit@@0@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXPAVCvTacticalUnit@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXPAVCvTacticalUnit@@0@Z PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXPAVCvTacticalUnit@@0@Z ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXPAVCvTacticalCity@@0@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXPAVCvTacticalCity@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXPAVCvTacticalCity@@0@Z PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXPAVCvTacticalCity@@0@Z ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Destroy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@22
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@22:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@22
	pop	esi
$LN13@unchecked_@22:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@stdext@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@stdext@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@std@@@Z
_TEXT	SEGMENT
$T264377 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$264381 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@stdext@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$264381[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T264377[esp+4], 0
	mov	eax, DWORD PTR $T264377[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@stdext@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@stdext@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@stdext@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@std@@@Z
_TEXT	SEGMENT
$T264414 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$264418 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@stdext@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$264418[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T264414[esp+4], 0
	mov	eax, DWORD PTR $T264414[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@stdext@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00HHAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Buffered_merge<CvTacticalMove *,int,CvTacticalMove>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00HHAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z
_TEXT	SEGMENT
__Firstn$230953 = -32					; size = 4
__Lastn$230954 = -28					; size = 4
__Midn$230973 = -24					; size = 4
$T264428 = -20						; size = 20
$T264426 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
tv368 = 20						; size = 4
$T264546 = 20						; size = 1
$T264495 = 20						; size = 1
$T264496 = 20						; size = 1
$T264427 = 20						; size = 4
$T264425 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00HHAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z PROC ; std::_Buffered_merge<CvTacticalMove *,int,CvTacticalMove>, COMDAT

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[esp-4]
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, DWORD PTR __First$[esp+32]
	push	ebp
	mov	ebp, DWORD PTR __Mid$[esp+36]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+44]
	add	eax, edi
	cmp	eax, 2
	je	$LN106@Buffered_m
	jmp	SHORT $LN101@Buffered_m
$LL113@Buffered_m:
	mov	edi, DWORD PTR __Count2$[esp+44]
$LN101@Buffered_m:

; 2764 : 		}
; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	DWORD PTR __Count1$[esp+44], edi
	mov	esi, DWORD PTR __Tempbuf$[esp+44]
	jg	SHORT $LN6@Buffered_m
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalMove>::_Maxlen
	cmp	DWORD PTR __Count1$[esp+44], eax
	jle	$LN107@Buffered_m
$LN6@Buffered_m:

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalMove>::_Maxlen
	cmp	edi, eax
	jle	$LN108@Buffered_m

; 2775 : 		}
; 2776 : 	else
; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	mov	eax, DWORD PTR __Count1$[esp+44]
	cmp	edi, eax

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2784 : 			_Firstn = _First;
; 2785 : 			std::advance(_Firstn, _Count1n);
; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	push	0
	jge	SHORT $LN2@Buffered_m
	mov	ecx, DWORD PTR __Last$[esp+48]
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	lea	eax, DWORD PTR [ebx+edi*8]
	push	eax
	push	ecx
	push	ebp
	mov	DWORD PTR __Firstn$230953[esp+64], eax
	call	??$_Lower_bound@PAVCvTacticalMove@@V1@H@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvTacticalMove *,CvTacticalMove,int>

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	esi, eax
	sub	esi, ebp
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Lastn$230954[esp+48], eax
	sar	esi, 3

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN99@Buffered_m
$LN2@Buffered_m:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1

; 2792 : 			_Lastn = _Mid;
; 2793 : 			std::advance(_Lastn, _Count2n);

	lea	eax, DWORD PTR [ebp+esi*8]

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	push	eax
	push	ebp
	push	ebx
	mov	DWORD PTR __Lastn$230954[esp+64], eax
	call	??$_Upper_bound@PAVCvTacticalMove@@V1@H@std@@YAPAVCvTacticalMove@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvTacticalMove *,CvTacticalMove,int>

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edi, eax
	sub	edi, ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Firstn$230953[esp+48], eax
	mov	eax, DWORD PTR __Lastn$230954[esp+48]
	sar	edi, 3
$LN99@Buffered_m:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[esp+44]
	mov	ecx, DWORD PTR __Count1$[esp+44]
	push	edx
	push	esi
	sub	ecx, edi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Firstn$230953[esp+64]
	push	ebp
	push	eax
	mov	DWORD PTR tv368[esp+68], ecx
	call	??$_Buffered_rotate@PAVCvTacticalMove@@HV1@@std@@YAPAVCvTacticalMove@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Buffered_rotate<CvTacticalMove *,int,CvTacticalMove>

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[esp+68]
	mov	edx, DWORD PTR __Firstn$230953[esp+72]
	push	ecx
	push	esi
	push	edi
	push	eax
	push	edx
	push	ebx
	mov	DWORD PTR __Midn$230973[esp+96], eax
	call	??$_Buffered_merge@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00HHAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Buffered_merge<CvTacticalMove *,int,CvTacticalMove>

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Count2$[esp+92]
	mov	ecx, DWORD PTR tv368[esp+92]
	mov	ebp, DWORD PTR __Lastn$230954[esp+96]
	mov	ebx, DWORD PTR __Midn$230973[esp+96]
	sub	eax, esi
	mov	DWORD PTR __Count1$[esp+92], ecx
	add	ecx, eax
	add	esp, 48					; 00000030H
	mov	DWORD PTR __Count2$[esp+44], eax
	cmp	ecx, 2
	jne	$LL113@Buffered_m
$LN106@Buffered_m:

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR [ebp+4]
	cmp	eax, DWORD PTR [ebx+4]
	jle	$LN3@Buffered_m

; 2763 : 			std::iter_swap(_First, _Mid);

	cmp	ebx, ebp
	je	$LN3@Buffered_m
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], edx
	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebx+4], edx
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], ecx

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
$LN107@Buffered_m:

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T264425[esp+64], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T264426[esp+72]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@0V12@@Z ; stdext::unchecked_copy<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
	mov	eax, DWORD PTR $T264426[esp+80]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN37@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Buffered_m:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __Last$[esp+44]
	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T264495[esp+44], 0
	mov	ecx, DWORD PTR $T264495[esp+44]
	mov	edx, DWORD PTR $T264496[esp+44]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	ebx
	push	eax
	push	ebp
	push	ecx
	push	edx
	call	??$_Merge@PAVCvTacticalMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
$LN108@Buffered_m:

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Last$[esp+44]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T264427[esp+64], esp
	push	edi
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T264428[esp+72]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@0V12@@Z ; stdext::unchecked_copy<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
	mov	eax, DWORD PTR $T264428[esp+80]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN61@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN61@Buffered_m:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR $T264546[esp+44], 0
	mov	ecx, DWORD PTR $T264546[esp+44]
	push	ecx
	push	edi
	push	edx
	push	eax
	push	ebp
	push	ebx
	call	??$_Merge_backward@PAVCvTacticalMove@@PAV1@PAV1@@std@@YAPAVCvTacticalMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvTacticalMove *,CvTacticalMove *,CvTacticalMove *>
	add	esp, 24					; 00000018H
$LN3@Buffered_m:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
??$_Buffered_merge@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00HHAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ENDP ; std::_Buffered_merge<CvTacticalMove *,int,CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00HHAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Buffered_merge<CvTacticalTarget *,int,CvTacticalTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00HHAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z
_TEXT	SEGMENT
__Firstn$231107 = -28					; size = 4
__Midn$231127 = -24					; size = 4
$T264656 = -20						; size = 20
$T264654 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
tv368 = 20						; size = 4
__Count1$ = 20						; size = 4
$T264763 = 24						; size = 1
$T264712 = 24						; size = 1
$T264713 = 24						; size = 1
$T264655 = 24						; size = 4
$T264653 = 24						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00HHAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z PROC ; std::_Buffered_merge<CvTacticalTarget *,int,CvTacticalTarget>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	sub	esp, 28					; 0000001cH
	push	ebx

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+28]
	push	ebp
	mov	ebp, DWORD PTR __Mid$[esp+32]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+40]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	je	$LN101@Buffered_m@2
	jmp	SHORT $LN96@Buffered_m@2
$LL108@Buffered_m@2:
	mov	edi, DWORD PTR __Count2$[esp+40]
	mov	ebx, DWORD PTR __Count1$[esp+40]
$LN96@Buffered_m@2:

; 2764 : 		}
; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+40]
	jg	SHORT $LN6@Buffered_m@2
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalTarget>::_Maxlen
	cmp	ebx, eax
	jle	$LN102@Buffered_m@2
$LN6@Buffered_m@2:

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalTarget>::_Maxlen
	cmp	edi, eax
	jle	$LN103@Buffered_m@2

; 2775 : 		}
; 2776 : 	else
; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2784 : 			_Firstn = _First;
; 2785 : 			std::advance(_Firstn, _Count1n);
; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	push	0
	jge	SHORT $LN2@Buffered_m@2
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+44]
	mov	edi, eax
	sar	edi, 1
	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	DWORD PTR __Firstn$231107[esp+52], eax
	mov	eax, DWORD PTR __Last$[esp+48]
	push	eax
	push	ebp
	call	??$_Lower_bound@PAVCvTacticalTarget@@V1@H@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvTacticalTarget *,CvTacticalTarget,int>
	mov	ebx, eax

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	ecx, ebx
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esp, 16					; 00000010H
	add	esi, edx

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN94@Buffered_m@2
$LN2@Buffered_m@2:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi

; 2792 : 			_Lastn = _Mid;
; 2793 : 			std::advance(_Lastn, _Count2n);
; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	edi, DWORD PTR __First$[esp+44]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	lea	ecx, DWORD PTR [esi*8]
	sub	ecx, esi
	lea	ebx, DWORD PTR [ebp+ecx*4]
	push	ebx
	push	ebp
	push	edi
	call	??$_Upper_bound@PAVCvTacticalTarget@@V1@H@std@@YAPAVCvTacticalTarget@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvTacticalTarget *,CvTacticalTarget,int>

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, eax
	sub	ecx, edi
	mov	DWORD PTR __Firstn$231107[esp+60], eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	esp, 16					; 00000010H
	add	edi, edx
$LN94@Buffered_m@2:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[esp+40]
	mov	eax, DWORD PTR __Count1$[esp+40]
	push	edx
	sub	eax, edi
	push	esi
	push	eax
	push	ebx
	mov	DWORD PTR tv368[esp+56], eax
	mov	eax, DWORD PTR __Firstn$231107[esp+60]
	push	ebp
	push	eax
	call	??$_Buffered_rotate@PAVCvTacticalTarget@@HV1@@std@@YAPAVCvTacticalTarget@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Buffered_rotate<CvTacticalTarget *,int,CvTacticalTarget>

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[esp+64]
	mov	edx, DWORD PTR __Firstn$231107[esp+68]
	push	ecx
	push	esi
	push	edi
	push	eax
	mov	DWORD PTR __Midn$231127[esp+84], eax
	mov	eax, DWORD PTR __First$[esp+80]
	push	edx
	push	eax
	call	??$_Buffered_merge@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00HHAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Buffered_merge<CvTacticalTarget *,int,CvTacticalTarget>

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Count2$[esp+88]
	mov	ecx, DWORD PTR tv368[esp+88]
	mov	edx, DWORD PTR __Midn$231127[esp+92]
	sub	eax, esi
	mov	DWORD PTR __Count1$[esp+88], ecx
	add	ecx, eax
	add	esp, 48					; 00000030H
	mov	DWORD PTR __Count2$[esp+40], eax
	mov	ebp, ebx
	mov	DWORD PTR __First$[esp+40], edx
	cmp	ecx, 2
	jne	$LL108@Buffered_m@2
$LN101@Buffered_m@2:

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	ecx, DWORD PTR [ebp+20]
	mov	eax, DWORD PTR __First$[esp+40]
	cmp	ecx, DWORD PTR [eax+20]
	jle	$LN3@Buffered_m@2

; 2763 : 			std::iter_swap(_First, _Mid);

	push	ebp
	push	eax
	call	??$iter_swap@PAVCvTacticalTarget@@PAV1@@std@@YAXPAVCvTacticalTarget@@0@Z ; std::iter_swap<CvTacticalTarget *,CvTacticalTarget *>
	add	esp, 8

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN102@Buffered_m@2:

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR __First$[esp+40]
	mov	DWORD PTR [eax+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T264653[esp+60], esp
	xor	ebx, ebx
	push	ebp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR [esi+16]
	lea	edx, DWORD PTR $T264654[esp+68]
	push	edi
	push	edx
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@0V12@@Z ; stdext::unchecked_copy<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
	mov	eax, DWORD PTR $T264654[esp+76]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN32@Buffered_m@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@Buffered_m@2:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	edx, DWORD PTR __Last$[esp+40]
	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T264712[esp+40], 0
	mov	eax, DWORD PTR $T264712[esp+40]
	mov	ecx, DWORD PTR $T264713[esp+40]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edi
	push	edx
	push	ebp
	push	eax
	push	ecx
	call	??$_Merge@PAVCvTacticalTarget@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalTarget@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN103@Buffered_m@2:

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Last$[esp+40]
	mov	DWORD PTR [eax+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T264655[esp+60], esp
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR [esi+16]
	lea	edx, DWORD PTR $T264656[esp+68]
	push	ebp
	push	edx
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@0V12@@Z ; stdext::unchecked_copy<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
	mov	eax, DWORD PTR $T264656[esp+76]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN56@Buffered_m@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Buffered_m@2:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	esi, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	mov	BYTE PTR $T264763[esp+40], 0
	mov	eax, DWORD PTR $T264763[esp+40]
	push	eax
	mov	eax, DWORD PTR __First$[esp+44]
	push	edi
	push	ecx
	push	edx
	push	ebp
	push	eax
	call	??$_Merge_backward@PAVCvTacticalTarget@@PAV1@PAV1@@std@@YAPAVCvTacticalTarget@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvTacticalTarget *,CvTacticalTarget *,CvTacticalTarget *>
	add	esp, 24					; 00000018H
$LN3@Buffered_m@2:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
??$_Buffered_merge@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00HHAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ENDP ; std::_Buffered_merge<CvTacticalTarget *,int,CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z ; std::_Insertion_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAVCvTacticalUnit@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z ; std::_Insertion_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAVCvTacticalCity@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__Midn$231613 = -24					; size = 4
$T264884 = -20						; size = 20
$T264882 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
tv336 = 20						; size = 4
__Count1$ = 20						; size = 4
$T264971 = 24						; size = 1
$T264883 = 24						; size = 4
$T264881 = 24						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 4
??$_Buffered_merge@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z PROC ; std::_Buffered_merge<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	sub	esp, 24					; 00000018H
	push	ebx

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	je	$LN101@Buffered_m@3
	jmp	SHORT $LN90@Buffered_m@3
	npad	3
$LL102@Buffered_m@3:
	mov	edi, DWORD PTR __Count2$[esp+36]
	mov	ebx, DWORD PTR __Count1$[esp+36]
$LN90@Buffered_m@3:

; 2894 : 		}
; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	SHORT $LN6@Buffered_m@3
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvBlockingUnit>::_Maxlen
	cmp	ebx, eax
	jle	$LN96@Buffered_m@3
$LN6@Buffered_m@3:

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvBlockingUnit>::_Maxlen
	cmp	edi, eax
	jle	$LN97@Buffered_m@3

; 2906 : 		}
; 2907 : 	else
; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;
; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2914 : 			_Firstn = _First;
; 2915 : 			std::advance(_Firstn, _Count1n);
; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+36]
	push	0
	push	ecx
	jge	SHORT $LN2@Buffered_m@3
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __Last$[esp+44]
	mov	edi, eax
	mov	eax, DWORD PTR __Mid$[esp+44]
	sar	edi, 1
	mov	ebp, edi
	shl	ebp, 4
	add	ebp, DWORD PTR __First$[esp+44]
	push	ebp
	push	edx
	push	eax
	call	??$_Lower_bound@PAVCvBlockingUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Lower_bound<CvBlockingUnit *,CvBlockingUnit,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
	mov	ebx, eax

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	esi, ebx
	sub	esi, DWORD PTR __Mid$[esp+56]
	add	esp, 20					; 00000014H
	sar	esi, 4

; 2918 : 			}
; 2919 : 		else

	jmp	SHORT $LN88@Buffered_m@3
$LN2@Buffered_m@3:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi
	cdq
	sub	eax, edx

; 2922 : 			_Lastn = _Mid;
; 2923 : 			std::advance(_Lastn, _Count2n);
; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	edx, DWORD PTR __First$[esp+44]
	mov	esi, eax
	mov	eax, DWORD PTR __Mid$[esp+44]
	sar	esi, 1
	mov	ebx, esi
	shl	ebx, 4
	add	ebx, eax
	push	ebx
	push	eax
	push	edx
	call	??$_Upper_bound@PAVCvBlockingUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Upper_bound<CvBlockingUnit *,CvBlockingUnit,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
	mov	ebp, eax

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edi, ebp
	sub	edi, DWORD PTR __First$[esp+56]
	add	esp, 20					; 00000014H
	sar	edi, 4
$LN88@Buffered_m@3:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	ecx
	push	esi
	sub	eax, edi
	push	eax
	push	ebx
	push	edx
	push	ebp
	mov	DWORD PTR tv336[esp+60], eax
	call	??$_Buffered_rotate@PAVCvBlockingUnit@@HV1@@std@@YAPAVCvBlockingUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Buffered_rotate<CvBlockingUnit *,int,CvBlockingUnit>

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	mov	ecx, DWORD PTR __Pred$[esp+60]
	mov	edx, DWORD PTR __Tempbuf$[esp+60]
	push	ecx
	push	edx
	push	esi
	push	edi
	push	eax
	mov	DWORD PTR __Midn$231613[esp+84], eax
	mov	eax, DWORD PTR __First$[esp+80]
	push	ebp
	push	eax
	call	??$_Buffered_merge@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	mov	eax, DWORD PTR __Count2$[esp+88]
	mov	ecx, DWORD PTR tv336[esp+88]
	mov	edx, DWORD PTR __Midn$231613[esp+92]
	sub	eax, esi
	mov	DWORD PTR __Count1$[esp+88], ecx
	add	ecx, eax
	add	esp, 52					; 00000034H
	mov	DWORD PTR __Count2$[esp+36], eax
	mov	DWORD PTR __Mid$[esp+36], ebx
	mov	DWORD PTR __First$[esp+36], edx
	cmp	ecx, 2
	jne	$LL102@Buffered_m@3
$LN101@Buffered_m@3:

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	edi, DWORD PTR __First$[esp+36]
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR __Mid$[esp+36]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [esi+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[esp+68]
	add	esp, 32					; 00000020H
	test	al, al
	je	$LN3@Buffered_m@3

; 2893 : 			std::iter_swap(_First, _Mid);

	push	esi
	push	edi
	call	??$iter_swap@PAVCvBlockingUnit@@PAV1@@std@@YAXPAVCvBlockingUnit@@0@Z ; std::iter_swap<CvBlockingUnit *,CvBlockingUnit *>
	add	esp, 8

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN96@Buffered_m@3:

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Mid$[esp+36]
	mov	ebx, DWORD PTR __First$[esp+36]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebp, ebp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T264881[esp+56], esp
	push	edi
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T264882[esp+64]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	mov	eax, DWORD PTR $T264882[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebp
	je	SHORT $LN30@Buffered_m@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN30@Buffered_m@3:

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+36]
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ebx
	push	edx
	push	edi
	push	eax
	push	ecx
	call	??$unchecked_merge@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@Z@Z ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
	add	esp, 24					; 00000018H

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN97@Buffered_m@3:

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Last$[esp+36]
	mov	edi, DWORD PTR __Mid$[esp+36]
	mov	DWORD PTR [eax+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T264883[esp+56], esp
	xor	ebp, ebp
	push	ebx
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	ecx, DWORD PTR [esi+16]
	lea	edx, DWORD PTR $T264884[esp+64]
	push	edi
	push	edx
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	mov	eax, DWORD PTR $T264884[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebp
	je	SHORT $LN50@Buffered_m@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN50@Buffered_m@3:

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	BYTE PTR $T264971[esp+36], 0
	mov	eax, DWORD PTR $T264971[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+44]
	push	ebx
	push	edx
	push	eax
	push	edi
	push	ecx
	call	??$_Merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvBlockingUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
	add	esp, 28					; 0000001cH
$LN3@Buffered_m@3:

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ENDP ; std::_Buffered_merge<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Buffered_merge<CvBlockingUnit *,int,CvBlockingUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z
_TEXT	SEGMENT
__Midn$231719 = -24					; size = 4
$T265082 = -20						; size = 20
$T265080 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
tv368 = 20						; size = 4
__Count1$ = 20						; size = 4
$T265189 = 24						; size = 1
$T265138 = 24						; size = 1
$T265139 = 24						; size = 1
$T265081 = 24						; size = 4
$T265079 = 24						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z PROC ; std::_Buffered_merge<CvBlockingUnit *,int,CvBlockingUnit>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	je	$LN107@Buffered_m@4
	jmp	SHORT $LN96@Buffered_m@4
	npad	3
$LL108@Buffered_m@4:
	mov	edi, DWORD PTR __Count2$[esp+36]
	mov	ebx, DWORD PTR __Count1$[esp+36]
$LN96@Buffered_m@4:

; 2764 : 		}
; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	SHORT $LN6@Buffered_m@4
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvBlockingUnit>::_Maxlen
	cmp	ebx, eax
	jle	$LN102@Buffered_m@4
$LN6@Buffered_m@4:

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvBlockingUnit>::_Maxlen
	cmp	edi, eax
	jle	$LN103@Buffered_m@4

; 2775 : 		}
; 2776 : 	else
; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2784 : 			_Firstn = _First;
; 2785 : 			std::advance(_Firstn, _Count1n);
; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	push	0
	jge	SHORT $LN2@Buffered_m@4
	mov	ecx, DWORD PTR __Last$[esp+40]
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __Mid$[esp+40]
	mov	edi, eax
	sar	edi, 1
	mov	ebp, edi
	shl	ebp, 4
	add	ebp, DWORD PTR __First$[esp+40]
	push	ebp
	push	ecx
	push	edx
	call	??$_Lower_bound@PAVCvBlockingUnit@@V1@H@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvBlockingUnit *,CvBlockingUnit,int>
	mov	ebx, eax

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	esi, ebx
	sub	esi, DWORD PTR __Mid$[esp+52]
	add	esp, 16					; 00000010H
	sar	esi, 4

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN94@Buffered_m@4
$LN2@Buffered_m@4:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	esi, eax

; 2792 : 			_Lastn = _Mid;
; 2793 : 			std::advance(_Lastn, _Count2n);

	mov	eax, DWORD PTR __Mid$[esp+40]
	sar	esi, 1
	mov	ebx, esi
	shl	ebx, 4
	add	ebx, eax

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	push	ebx
	push	eax
	mov	eax, DWORD PTR __First$[esp+48]
	push	eax
	call	??$_Upper_bound@PAVCvBlockingUnit@@V1@H@std@@YAPAVCvBlockingUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvBlockingUnit *,CvBlockingUnit,int>
	mov	ebp, eax

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edi, ebp
	sub	edi, DWORD PTR __First$[esp+52]
	add	esp, 16					; 00000010H
	sar	edi, 4
$LN94@Buffered_m@4:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	ecx
	push	esi
	sub	eax, edi
	push	eax
	push	ebx
	push	edx
	push	ebp
	mov	DWORD PTR tv368[esp+60], eax
	call	??$_Buffered_rotate@PAVCvBlockingUnit@@HV1@@std@@YAPAVCvBlockingUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Buffered_rotate<CvBlockingUnit *,int,CvBlockingUnit>

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[esp+60]
	mov	edx, DWORD PTR __First$[esp+60]
	push	ecx
	push	esi
	push	edi
	push	eax
	push	ebp
	push	edx
	mov	DWORD PTR __Midn$231719[esp+88], eax
	call	??$_Buffered_merge@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Buffered_merge<CvBlockingUnit *,int,CvBlockingUnit>

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Count2$[esp+84]
	mov	ecx, DWORD PTR tv368[esp+84]
	mov	edx, DWORD PTR __Midn$231719[esp+88]
	sub	eax, esi
	mov	DWORD PTR __Count1$[esp+84], ecx
	add	ecx, eax
	add	esp, 48					; 00000030H
	mov	DWORD PTR __Count2$[esp+36], eax
	mov	DWORD PTR __Mid$[esp+36], ebx
	mov	DWORD PTR __First$[esp+36], edx
	cmp	ecx, 2
	jne	$LL108@Buffered_m@4
$LN107@Buffered_m@4:

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp+36]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __First$[esp+36]
	cmp	edx, DWORD PTR [ecx+4]
	jge	$LN3@Buffered_m@4

; 2763 : 			std::iter_swap(_First, _Mid);

	push	eax
	push	ecx
	call	??$iter_swap@PAVCvBlockingUnit@@PAV1@@std@@YAXPAVCvBlockingUnit@@0@Z ; std::iter_swap<CvBlockingUnit *,CvBlockingUnit *>
	add	esp, 8

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN102@Buffered_m@4:

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Mid$[esp+36]
	mov	ebx, DWORD PTR __First$[esp+36]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebp, ebp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T265079[esp+56], esp
	push	edi
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T265080[esp+64]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	mov	eax, DWORD PTR $T265080[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebp
	je	SHORT $LN32@Buffered_m@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@Buffered_m@4:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T265138[esp+36], 0
	mov	ecx, DWORD PTR $T265138[esp+36]
	mov	edx, DWORD PTR $T265139[esp+36]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	ebx
	push	eax
	push	edi
	push	ecx
	push	edx
	call	??$_Merge@PAVCvBlockingUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvBlockingUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN103@Buffered_m@4:

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Last$[esp+36]
	mov	edi, DWORD PTR __Mid$[esp+36]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebp, ebp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T265081[esp+56], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T265082[esp+64]
	push	edi
	push	eax
	call	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	mov	eax, DWORD PTR $T265082[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebp
	je	SHORT $LN56@Buffered_m@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Buffered_m@4:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR $T265189[esp+36], 0
	mov	ecx, DWORD PTR $T265189[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+40]
	push	ebx
	push	edx
	push	eax
	push	edi
	push	ecx
	call	??$_Merge_backward@PAVCvBlockingUnit@@PAV1@PAV1@@std@@YAPAVCvBlockingUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvBlockingUnit *,CvBlockingUnit *,CvBlockingUnit *>
	add	esp, 24					; 00000018H
$LN3@Buffered_m@4:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ENDP ; std::_Buffered_merge<CvBlockingUnit *,int,CvBlockingUnit>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap
$LN24@Sort_heap:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvTacticalMove@@PAV1@H@stdext@@YAXPAVCvTacticalMove@@00HH@Z ; stdext::_Unchecked_chunked_merge<CvTacticalMove *,CvTacticalMove *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvTacticalMove@@PAV1@H@stdext@@YAXPAVCvTacticalMove@@00HH@Z
_TEXT	SEGMENT
$T265357 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
??$_Unchecked_chunked_merge@PAVCvTacticalMove@@PAV1@H@stdext@@YAXPAVCvTacticalMove@@00HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvTacticalMove *,CvTacticalMove *,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	mov	BYTE PTR $T265357[esp+4], 0
	mov	eax, DWORD PTR $T265357[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvTacticalMove@@PAV1@H@std@@YAXPAVCvTacticalMove@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalMove *,CvTacticalMove *,int>

; 5254 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_chunked_merge@PAVCvTacticalMove@@PAV1@H@stdext@@YAXPAVCvTacticalMove@@00HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvTacticalMove *,CvTacticalMove *,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvTacticalTarget@@PAV1@H@stdext@@YAXPAVCvTacticalTarget@@00HH@Z ; stdext::_Unchecked_chunked_merge<CvTacticalTarget *,CvTacticalTarget *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvTacticalTarget@@PAV1@H@stdext@@YAXPAVCvTacticalTarget@@00HH@Z
_TEXT	SEGMENT
$T265361 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
??$_Unchecked_chunked_merge@PAVCvTacticalTarget@@PAV1@H@stdext@@YAXPAVCvTacticalTarget@@00HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvTacticalTarget *,CvTacticalTarget *,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	mov	BYTE PTR $T265361[esp+4], 0
	mov	eax, DWORD PTR $T265361[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvTacticalTarget@@PAV1@H@std@@YAXPAVCvTacticalTarget@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalTarget *,CvTacticalTarget *,int>

; 5254 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_chunked_merge@PAVCvTacticalTarget@@PAV1@H@stdext@@YAXPAVCvTacticalTarget@@00HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvTacticalTarget *,CvTacticalTarget *,int>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@11@Z ; stdext::unchecked_merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@11@Z
_TEXT	SEGMENT
$T265365 = -4						; size = 1
$T265366 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
??$unchecked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@11@Z PROC ; stdext::unchecked_merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T265366[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T265365[esp+8], 0
	mov	eax, DWORD PTR $T265365[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
	mov	eax, esi
	pop	esi

; 5117 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@11@Z ENDP ; stdext::unchecked_merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@0PAVCvTacticalUnit@@10@Z ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@0PAVCvTacticalUnit@@10@Z
_TEXT	SEGMENT
$T265374 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
??$_Unchecked_merge_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@0PAVCvTacticalUnit@@10@Z PROC ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 5202 : 	{

	push	ecx

; 5203 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR __Last2$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T265374[esp+8], 0
	mov	eax, DWORD PTR $T265374[esp+8]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Merge_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@V12@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0PAVCvTacticalUnit@@10U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 5204 : 	}

	pop	ecx
	ret	0
??$_Unchecked_merge_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@0PAVCvTacticalUnit@@10@Z ENDP ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@11@Z ; stdext::unchecked_merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@11@Z
_TEXT	SEGMENT
$T265378 = -4						; size = 1
$T265379 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
??$unchecked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@11@Z PROC ; stdext::unchecked_merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T265379[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T265378[esp+8], 0
	mov	eax, DWORD PTR $T265378[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
	mov	eax, esi
	pop	esi

; 5117 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@11@Z ENDP ; stdext::unchecked_merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@0PAVCvTacticalCity@@10@Z ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@0PAVCvTacticalCity@@10@Z
_TEXT	SEGMENT
$T265387 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
??$_Unchecked_merge_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@0PAVCvTacticalCity@@10@Z PROC ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 5202 : 	{

	push	ecx

; 5203 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR __Last2$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T265387[esp+8], 0
	mov	eax, DWORD PTR $T265387[esp+8]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Merge_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@V12@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0PAVCvTacticalCity@@10U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 5204 : 	}

	pop	ecx
	ret	0
??$_Unchecked_merge_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@0PAVCvTacticalCity@@10@Z ENDP ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@PAV1@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@00HHP6A_NV1@1@Z@Z ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@PAV1@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@00HHP6A_NV1@1@Z@Z
_TEXT	SEGMENT
$T265391 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 4
??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@PAV1@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@00HHP6A_NV1@1@Z@Z PROC ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	mov	BYTE PTR $T265391[esp+4], 0
	mov	eax, DWORD PTR $T265391[esp+4]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Chunked_merge@PAVCvBlockingUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>

; 5287 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@PAV1@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@00HHP6A_NV1@1@Z@Z ENDP ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0V?$_Temp_iterator@VCvTacticalUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0V?$_Temp_iterator@VCvTacticalUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T265395 = -24						; size = 4
$T265400 = -20						; size = 20
$T265398 = -20						; size = 20
$T265396 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T265397 = 40						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0V?$_Temp_iterator@VCvTacticalUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	esi, DWORD PTR __First$[esp+32]
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+36]
	lea	ebp, DWORD PTR [edi+edi]
	xor	ebx, ebx
	cmp	ebp, DWORD PTR __Count$[esp+36]
	jg	SHORT $LN3@Chunked_me@5
	lea	edi, DWORD PTR [edi+edi*2]
	add	edi, edi
	add	edi, edi
	add	edi, edi
$LL5@Chunked_me@5:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edi+esi]
	mov	DWORD PTR $T265395[esp+60], esp
	lea	esi, DWORD PTR [edi+ecx]
	push	esi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+76]
	push	ecx
	push	ecx
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __First$[esp+68]
	push	eax
	lea	ecx, DWORD PTR $T265396[esp+76]
	push	ecx
	call	??$unchecked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@000V12@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T265396[esp+80]
	add	esp, 40					; 00000028H
	mov	DWORD PTR __Dest$[esp+52], edx
	cmp	eax, ebx
	je	SHORT $LN49@Chunked_me@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@Chunked_me@5:
	mov	eax, DWORD PTR __Count$[esp+36]
	sub	eax, ebp
	cmp	eax, ebp

; 3297 : 		_First = _Mid2;

	mov	DWORD PTR __First$[esp+36], esi
	mov	DWORD PTR __Count$[esp+36], eax
	jge	SHORT $LL5@Chunked_me@5

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edi, DWORD PTR __Chunk$[esp+36]
$LN3@Chunked_me@5:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)
; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	cmp	DWORD PTR __Count$[esp+56], edi
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR $T265397[esp+56], esp
	jg	SHORT $LN2@Chunked_me@5
	mov	ecx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+56]
	mov	eax, DWORD PTR __First$[esp+56]
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T265398[esp+68]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
	add	esp, 32					; 00000020H

; 3302 : 	else

	jmp	SHORT $LN111@Chunked_me@5
$LN2@Chunked_me@5:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);

	lea	edx, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR [esi+edx*8]

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+68]
	push	ecx
	lea	edx, DWORD PTR $T265400[esp+76]
	push	edx
	call	??$unchecked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@000V12@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
	add	esp, 40					; 00000028H
$LN111@Chunked_me@5:
	mov	eax, DWORD PTR $T265400[esp+40]
	cmp	eax, ebx
	je	SHORT $LN87@Chunked_me@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@Chunked_me@5:

; 3308 : 		}
; 3309 : 	}

	mov	eax, DWORD PTR __Dest$[esp+36]
	cmp	eax, ebx
	je	SHORT $LN97@Chunked_me@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN97@Chunked_me@5:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Chunked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0V?$_Temp_iterator@VCvTacticalUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,int>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXPAVCvTacticalUnit@@0V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXPAVCvTacticalUnit@@0V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T265676 = -8						; size = 1
$T265630 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
$T265737 = 24						; size = 1
$T265738 = 24						; size = 1
$T265700 = 24						; size = 1
__Cat$265704 = 24					; size = 1
$T265702 = 24						; size = 1
$T265677 = 24						; size = 1
$T265632 = 24						; size = 4
$T265631 = 24						; size = 4
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXPAVCvTacticalUnit@@0V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebp
	mov	ebp, DWORD PTR __Chunk$[esp+8]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp+ebp]
	cmp	edi, eax
	jg	SHORT $LN3@Chunked_me@6
	lea	ebp, DWORD PTR [ebp+ebp*2]
	add	ebp, ebp
	add	ebp, ebp
	add	ebp, ebp
	push	ebx
	npad	7
$LL43@Chunked_me@6:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	BYTE PTR $T265676[esp+24], 0
	mov	ebx, DWORD PTR $T265676[esp+24]
	push	ebx
	mov	ebx, DWORD PTR $T265677[esp+24]
	push	ebx
	lea	eax, DWORD PTR [ecx+ebp]
	push	edx
	lea	esi, DWORD PTR [eax+ebp]
	push	esi
	push	eax
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T265630[esp+52]
	push	eax
	call	??$_Merge@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalUnit *,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	mov	eax, DWORD PTR __Count$[esp+52]
	mov	edx, DWORD PTR $T265630[esp+56]
	sub	eax, edi
	add	esp, 32					; 00000020H
	cmp	eax, edi

; 3297 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+20], eax
	jge	SHORT $LL43@Chunked_me@6
	mov	ebp, DWORD PTR __Chunk$[esp+20]
	pop	ebx
$LN3@Chunked_me@6:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	cmp	eax, ebp

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	BYTE PTR $T265700[esp+16], 0
	jg	SHORT $LN2@Chunked_me@6
	mov	eax, DWORD PTR $T265700[esp+16]
	push	eax
	mov	eax, DWORD PTR __Cat$265704[esp+20]
	push	eax
	mov	eax, DWORD PTR $T265702[esp+24]
	push	eax
	push	edx
	mov	edx, DWORD PTR __Last$[esp+32]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T265631[esp+40]
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	add	esp, 8
	ret	0
$LN2@Chunked_me@6:

; 3302 : 	else
; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	esi, DWORD PTR $T265737[esp+16]
	push	esi
	mov	esi, DWORD PTR $T265738[esp+20]
	push	esi
	push	edx
	mov	edx, DWORD PTR __Last$[esp+28]
	push	edx
	lea	eax, DWORD PTR [ebp+ebp*2]
	lea	eax, DWORD PTR [ecx+eax*8]
	push	eax
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T265632[esp+44]
	push	eax
	call	??$_Merge@PAVCvTacticalUnit@@PAV1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalUnit *,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	add	esp, 8
	ret	0
??$_Chunked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXPAVCvTacticalUnit@@0V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
_TEXT	ENDS
PUBLIC	??$rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00@Z ; std::rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00@Z PROC ; std::rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN14@rotate@4
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN14@rotate@4

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00PAHPAVCvTacticalUnit@@@Z ; std::_Rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
	add	esp, 20					; 00000014H
$LN14@rotate@4:

; 1721 : 	}

	ret	0
??$rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00@Z ENDP ; std::rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0V?$_Temp_iterator@VCvTacticalCity@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0V?$_Temp_iterator@VCvTacticalCity@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T265794 = -24						; size = 4
$T265799 = -20						; size = 20
$T265797 = -20						; size = 20
$T265795 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T265796 = 40						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0V?$_Temp_iterator@VCvTacticalCity@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	esi, DWORD PTR __First$[esp+32]
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+36]
	lea	ebp, DWORD PTR [edi+edi]
	xor	ebx, ebx
	cmp	ebp, DWORD PTR __Count$[esp+36]
	jg	SHORT $LN3@Chunked_me@7
	lea	edi, DWORD PTR [edi+edi*2]
	add	edi, edi
	add	edi, edi
$LL5@Chunked_me@7:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edi+esi]
	mov	DWORD PTR $T265794[esp+60], esp
	lea	esi, DWORD PTR [edi+ecx]
	push	esi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+76]
	push	ecx
	push	ecx
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __First$[esp+68]
	push	eax
	lea	ecx, DWORD PTR $T265795[esp+76]
	push	ecx
	call	??$unchecked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@000V12@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T265795[esp+80]
	add	esp, 40					; 00000028H
	mov	DWORD PTR __Dest$[esp+52], edx
	cmp	eax, ebx
	je	SHORT $LN49@Chunked_me@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@Chunked_me@7:
	mov	eax, DWORD PTR __Count$[esp+36]
	sub	eax, ebp
	cmp	eax, ebp

; 3297 : 		_First = _Mid2;

	mov	DWORD PTR __First$[esp+36], esi
	mov	DWORD PTR __Count$[esp+36], eax
	jge	SHORT $LL5@Chunked_me@7

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edi, DWORD PTR __Chunk$[esp+36]
$LN3@Chunked_me@7:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)
; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	cmp	DWORD PTR __Count$[esp+56], edi
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR $T265796[esp+56], esp
	jg	SHORT $LN2@Chunked_me@7
	mov	ecx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+56]
	mov	eax, DWORD PTR __First$[esp+56]
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T265797[esp+68]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
	add	esp, 32					; 00000020H

; 3302 : 	else

	jmp	SHORT $LN111@Chunked_me@7
$LN2@Chunked_me@7:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);

	lea	edx, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR [esi+edx*4]

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+68]
	push	ecx
	lea	edx, DWORD PTR $T265799[esp+76]
	push	edx
	call	??$unchecked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@000V12@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
	add	esp, 40					; 00000028H
$LN111@Chunked_me@7:
	mov	eax, DWORD PTR $T265799[esp+40]
	cmp	eax, ebx
	je	SHORT $LN87@Chunked_me@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@Chunked_me@7:

; 3308 : 		}
; 3309 : 	}

	mov	eax, DWORD PTR __Dest$[esp+36]
	cmp	eax, ebx
	je	SHORT $LN97@Chunked_me@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN97@Chunked_me@7:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Chunked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0V?$_Temp_iterator@VCvTacticalCity@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,int>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXPAVCvTacticalCity@@0V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXPAVCvTacticalCity@@0V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T266075 = -8						; size = 1
$T266029 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
$T266136 = 24						; size = 1
$T266137 = 24						; size = 1
$T266099 = 24						; size = 1
__Cat$266103 = 24					; size = 1
$T266101 = 24						; size = 1
$T266076 = 24						; size = 1
$T266031 = 24						; size = 4
$T266030 = 24						; size = 4
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXPAVCvTacticalCity@@0V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebp
	mov	ebp, DWORD PTR __Chunk$[esp+8]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp+ebp]
	cmp	edi, eax
	jg	SHORT $LN3@Chunked_me@8
	lea	ebp, DWORD PTR [ebp+ebp*2]
	add	ebp, ebp
	add	ebp, ebp
	push	ebx
	npad	9
$LL43@Chunked_me@8:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	BYTE PTR $T266075[esp+24], 0
	mov	ebx, DWORD PTR $T266075[esp+24]
	push	ebx
	mov	ebx, DWORD PTR $T266076[esp+24]
	push	ebx
	lea	eax, DWORD PTR [ecx+ebp]
	push	edx
	lea	esi, DWORD PTR [eax+ebp]
	push	esi
	push	eax
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T266029[esp+52]
	push	eax
	call	??$_Merge@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalCity *,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	mov	eax, DWORD PTR __Count$[esp+52]
	mov	edx, DWORD PTR $T266029[esp+56]
	sub	eax, edi
	add	esp, 32					; 00000020H
	cmp	eax, edi

; 3297 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+20], eax
	jge	SHORT $LL43@Chunked_me@8
	mov	ebp, DWORD PTR __Chunk$[esp+20]
	pop	ebx
$LN3@Chunked_me@8:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	cmp	eax, ebp

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	BYTE PTR $T266099[esp+16], 0
	jg	SHORT $LN2@Chunked_me@8
	mov	eax, DWORD PTR $T266099[esp+16]
	push	eax
	mov	eax, DWORD PTR __Cat$266103[esp+20]
	push	eax
	mov	eax, DWORD PTR $T266101[esp+24]
	push	eax
	push	edx
	mov	edx, DWORD PTR __Last$[esp+32]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T266030[esp+40]
	push	eax
	call	??$_Copy_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	add	esp, 8
	ret	0
$LN2@Chunked_me@8:

; 3302 : 	else
; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	esi, DWORD PTR $T266136[esp+16]
	push	esi
	mov	esi, DWORD PTR $T266137[esp+20]
	push	esi
	push	edx
	mov	edx, DWORD PTR __Last$[esp+28]
	push	edx
	lea	eax, DWORD PTR [ebp+ebp*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	push	eax
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T266031[esp+44]
	push	eax
	call	??$_Merge@PAVCvTacticalCity@@PAV1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalCity *,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	add	esp, 8
	ret	0
??$_Chunked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXPAVCvTacticalCity@@0V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
_TEXT	ENDS
PUBLIC	??$rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00@Z ; std::rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00@Z PROC ; std::rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN14@rotate@5
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN14@rotate@5

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00PAHPAVCvTacticalCity@@@Z ; std::_Rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
	add	esp, 20					; 00000014H
$LN14@rotate@5:

; 1721 : 	}

	ret	0
??$rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00@Z ENDP ; std::rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@000V12@@Z ; stdext::unchecked_merge<CvTacticalMove *,CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@000V12@@Z
_TEXT	SEGMENT
$T266193 = -4						; size = 1
$T266199 = -4						; size = 4
$T266195 = -4						; size = 4
$T266194 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@000V12@@Z PROC ; stdext::unchecked_merge<CvTacticalMove *,CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T266199[esp+8], ebx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T266194[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T266193[esp+12], bl
	mov	eax, DWORD PTR $T266193[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+36]
	mov	edx, DWORD PTR __Last1$[esp+36]
	mov	DWORD PTR $T266195[esp+40], esp
	push	eax
	mov	eax, DWORD PTR __First1$[esp+40]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@0@PAVCvTacticalMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalMove *,CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+56]
	add	esp, 48					; 00000030H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@23
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@23:
	mov	eax, esi

; 5117 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@000V12@@Z ENDP ; stdext::unchecked_merge<CvTacticalMove *,CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@000V12@@Z ; stdext::unchecked_merge<CvTacticalTarget *,CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@000V12@@Z
_TEXT	SEGMENT
$T266239 = -4						; size = 1
$T266245 = -4						; size = 4
$T266241 = -4						; size = 4
$T266240 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@000V12@@Z PROC ; stdext::unchecked_merge<CvTacticalTarget *,CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T266245[esp+8], ebx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T266240[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T266239[esp+12], bl
	mov	eax, DWORD PTR $T266239[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+36]
	mov	edx, DWORD PTR __Last1$[esp+36]
	mov	DWORD PTR $T266241[esp+40], esp
	push	eax
	mov	eax, DWORD PTR __First1$[esp+40]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@0@PAVCvTacticalTarget@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalTarget *,CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+56]
	add	esp, 48					; 00000030H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@24
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@24:
	mov	eax, esi

; 5117 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@000V12@@Z ENDP ; stdext::unchecked_merge<CvTacticalTarget *,CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z$0
__ehfuncinfo$??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z
_TEXT	SEGMENT
$T266285 = -16						; size = 1
$T266291 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
$T266286 = 48						; size = 1
$T266287 = 48						; size = 4
__Pred$ = 48						; size = 4
??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z PROC ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	-1
	push	__ehhandler$??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T266291[esp+24], ebx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T266286[esp+20]
	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	BYTE PTR $T266285[esp+24], bl
	mov	eax, DWORD PTR $T266285[esp+24]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last2$[esp+32]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR $T266287[esp+52], esp
	push	edx
	mov	edx, DWORD PTR __First1$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First2$[esp+56]
	mov	ecx, DWORD PTR __Last1$[esp+56]
	push	eax
	push	ecx
	push	edx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+84], ebx
	call	??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+72]
	add	esp, 52					; 00000034H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@25
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@25:

; 5160 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvBlockingUnit>::~_Temp_iterator<CvBlockingUnit>
__ehhandler$??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z:
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z ENDP ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
PUBLIC	??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@@Z ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@@Z
_TEXT	SEGMENT
$T266337 = -4						; size = 1
$T266343 = -4						; size = 4
$T266339 = -4						; size = 4
$T266338 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@@Z PROC ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T266343[esp+8], ebx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T266338[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T266337[esp+12], bl
	mov	eax, DWORD PTR $T266337[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+36]
	mov	edx, DWORD PTR __Last1$[esp+36]
	mov	DWORD PTR $T266339[esp+40], esp
	push	eax
	mov	eax, DWORD PTR __First1$[esp+40]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@0@PAVCvBlockingUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+56]
	add	esp, 48					; 00000030H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@26
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@26:
	mov	eax, esi

; 5117 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@@Z ENDP ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@27
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@27:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@27
	pop	esi
$LN13@unchecked_@27:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??0CvTacticalMoveXMLEntries@@QAE@XZ		; CvTacticalMoveXMLEntries::CvTacticalMoveXMLEntries
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
;	COMDAT ??0CvTacticalMoveXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvTacticalMoveXMLEntries@@QAE@XZ PROC		; CvTacticalMoveXMLEntries::CvTacticalMoveXMLEntries, COMDAT
; _this$ = ecx

; 78   : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 79   : 
; 80   : }

	ret	0
??0CvTacticalMoveXMLEntries@@QAE@XZ ENDP		; CvTacticalMoveXMLEntries::CvTacticalMoveXMLEntries
_TEXT	ENDS
PUBLIC	?DeleteArray@CvTacticalMoveXMLEntries@@QAEXXZ	; CvTacticalMoveXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteArray@CvTacticalMoveXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvTacticalMoveXMLEntries@@QAEXXZ PROC	; CvTacticalMoveXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 108  : {

	push	esi
	push	edi
	mov	edi, ecx

; 109  : 	for(std::vector<CvTacticalMoveXMLEntry*>::iterator it = m_paTacticalMoveEntries.begin(); it != m_paTacticalMoveEntries.end(); ++it)

	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@DeleteArra
	npad	4
$LL14@DeleteArra:

; 110  : 	{
; 111  : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@DeleteArra
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 112  : 	}
; 113  : 
; 114  : 	m_paTacticalMoveEntries.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@DeleteArra:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@DeleteArra:
	pop	edi
	pop	esi

; 115  : }

	ret	0
?DeleteArray@CvTacticalMoveXMLEntries@@QAEXXZ ENDP	; CvTacticalMoveXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	?CommandeerUnits@CvTacticalAI@@QAEXXZ		; CvTacticalAI::CommandeerUnits
EXTRN	?canParadrop@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canParadrop
EXTRN	?setTacticalMove@CvUnit@@QAEXW4TacticalAIMoveTypes@@@Z:PROC ; CvUnit::setTacticalMove
EXTRN	?CanTacticalAIInterruptUnit@CvArmyAI@@QBE_NH@Z:PROC ; CvArmyAI::CanTacticalAIInterruptUnit
EXTRN	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z:PROC	; CvPlayer::getArmyAI
EXTRN	?IsGreatGeneral@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsGreatGeneral
EXTRN	?WillAirUnitRebase@CvMilitaryAI@@QBE_NPAVCvUnit@@@Z:PROC ; CvMilitaryAI::WillAirUnitRebase
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
EXTRN	?canMove@CvUnit@@QBE_NXZ:PROC			; CvUnit::canMove
EXTRN	?TurnProcessed@CvUnit@@QBE_NXZ:PROC		; CvUnit::TurnProcessed
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?CommandeerUnits@CvTacticalAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CommandeerUnits@CvTacticalAI@@QAEXXZ$0
__ehfuncinfo$?CommandeerUnits@CvTacticalAI@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CommandeerUnits@CvTacticalAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?CommandeerUnits@CvTacticalAI@@QAEXXZ
_TEXT	SEGMENT
$T266983 = -28						; size = 4
$T266982 = -28						; size = 4
_iLoop$ = -24						; size = 4
_pLoopUnit$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
?CommandeerUnits@CvTacticalAI@@QAEXXZ PROC		; CvTacticalAI::CommandeerUnits, COMDAT
; _this$ = ecx

; 360  : {

	push	-1
	push	__ehhandler$?CommandeerUnits@CvTacticalAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 361  : 	UnitHandle pLoopUnit;

	mov	DWORD PTR _pLoopUnit$[esp+44], 0
	mov	BYTE PTR _pLoopUnit$[esp+48], 0

; 362  : 	int iLoop;
; 363  : 
; 364  : 	m_CurrentTurnUnits.clear();

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ecx
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [ecx+4], ecx
	mov	DWORD PTR __$EHRec$[esp+52], 0
	mov	DWORD PTR [edi+16], 0
	cmp	eax, DWORD PTR [edi+12]
	je	SHORT $LN24@Commandeer
	npad	4
$LL26@Commandeer:
	mov	esi, DWORD PTR [eax]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	cmp	esi, DWORD PTR [edi+12]
	jne	SHORT $LL26@Commandeer
$LN24@Commandeer:

; 365  : 
; 366  : 	// Loop through our units
; 367  : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	mov	ecx, DWORD PTR [edi]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+48]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	mov	DWORD PTR _pLoopUnit$[esp+44], esi
	test	eax, eax
	je	$LN144@Commandeer
	mov	ecx, eax
$LN150@Commandeer:
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 368  : 	{
; 369  : 		// Never want immobile/dead units, explorers, ones that have already moved or automated human units
; 370  : 		if(pLoopUnit->TurnProcessed() || pLoopUnit->isDelayedDeath() || pLoopUnit->AI_getUnitAIType() == UNITAI_UNKNOWN ||  pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE || !pLoopUnit->canMove() || pLoopUnit->isHuman())

	mov	ecx, esi
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	$LN16@Commandeer
	mov	ecx, esi
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	$LN16@Commandeer
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	test	eax, eax
	je	$LN16@Commandeer
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	$LN16@Commandeer
	mov	ecx, esi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN16@Commandeer
	mov	ecx, esi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	jne	$LN16@Commandeer

; 371  : 		{
; 372  : 			continue;
; 373  : 		}
; 374  : 
; 375  : 		// We want ALL the barbarians and air units (that are combat ready)
; 376  : 		else if(pLoopUnit->isBarbarian() || (pLoopUnit->getDomainType() == DOMAIN_AIR && pLoopUnit->getDamage() < 50 && !m_pPlayer->GetMilitaryAI()->WillAirUnitRebase(pLoopUnit.pointer())))

	mov	ecx, esi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	$LN10@Commandeer
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN11@Commandeer
	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	cmp	eax, 50					; 00000032H
	jge	SHORT $LN11@Commandeer
	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?WillAirUnitRebase@CvMilitaryAI@@QBE_NPAVCvUnit@@@Z ; CvMilitaryAI::WillAirUnitRebase
	test	al, al
	je	$LN10@Commandeer
$LN11@Commandeer:

; 380  : 		}
; 381  : 
; 382  : 		// Now down to land and sea units ... in these groups our unit must have a base combat strength ... or be a great general
; 383  : 		else if(!pLoopUnit->IsCombatUnit() && !pLoopUnit->IsGreatGeneral())

	cmp	DWORD PTR [esi+1044], 0
	jg	SHORT $LN8@Commandeer
	mov	ecx, esi
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	test	al, al
	je	$LN16@Commandeer
$LN8@Commandeer:

; 384  : 		{
; 385  : 			continue;
; 386  : 		}
; 387  : 
; 388  : 		else
; 389  : 		{
; 390  : 			// Is this one in an operation we can't interrupt?
; 391  : 			int iArmyID = pLoopUnit->getArmyID();

	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID

; 392  : 			const CvArmyAI* army = m_pPlayer->getArmyAI(iArmyID);

	mov	ecx, DWORD PTR [edi]
	mov	ebp, eax
	push	ebp
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 393  : 			if(iArmyID != FFreeList::INVALID_INDEX && NULL != army && !army->CanTacticalAIInterruptUnit(pLoopUnit->GetID()))

	cmp	ebp, -1
	je	SHORT $LN6@Commandeer
	test	eax, eax
	je	SHORT $LN6@Commandeer
	mov	ecx, DWORD PTR [esi+100]
	push	ecx
	mov	ecx, eax
	call	?CanTacticalAIInterruptUnit@CvArmyAI@@QBE_NH@Z ; CvArmyAI::CanTacticalAIInterruptUnit
	test	al, al
	jne	SHORT $LN6@Commandeer

; 394  : 			{
; 395  : 				pLoopUnit->setTacticalMove(NO_TACTICAL_MOVE);

	push	-1
	mov	ecx, esi
	call	?setTacticalMove@CvUnit@@QAEXW4TacticalAIMoveTypes@@@Z ; CvUnit::setTacticalMove

; 396  : 			}
; 397  : 
; 398  : 			else

	jmp	$LN16@Commandeer
$LN6@Commandeer:

; 399  : 			{
; 400  : 				// Non-zero danger value, near enemy, or deploying out of an operation?
; 401  : 				int iDanger = m_pPlayer->GetPlotDanger(*(pLoopUnit->plot()));

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger

; 402  : 				if(iDanger > 0 || NearVisibleEnemy(pLoopUnit, m_iRecruitRange) ||
; 403  : 				        pLoopUnit->GetDeployFromOperationTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS() >= GC.getGame().getGameTurn())

	test	eax, eax
	jg	SHORT $LN10@Commandeer
	mov	ecx, DWORD PTR [edi+24756]
	push	ecx
	sub	esp, 8
	lea	edx, DWORD PTR _pLoopUnit$[esp+56]
	mov	ecx, esp
	mov	DWORD PTR $T266983[esp+56], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?NearVisibleEnemy@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@H@Z ; CvTacticalAI::NearVisibleEnemy
	test	al, al
	jne	SHORT $LN10@Commandeer
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, DWORD PTR [esi+124]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	ebx, ebp
	cmp	ebx, eax
	jge	SHORT $LN10@Commandeer

; 404  : 				{
; 405  : 					pLoopUnit->setTacticalMove((TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_UNASSIGNED]);
; 406  : 					m_CurrentTurnUnits.push_back(pLoopUnit->GetID());
; 407  : 				}
; 408  : 				else if (pLoopUnit->canParadrop(pLoopUnit->plot(),false))

	push	0
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?canParadrop@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canParadrop
	test	al, al
	je	SHORT $LN16@Commandeer
$LN10@Commandeer:

; 377  : 		{
; 378  : 			pLoopUnit->setTacticalMove((TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_UNASSIGNED]);

	mov	eax, DWORD PTR [edi+29172]
	push	eax
	mov	ecx, esi
	call	?setTacticalMove@CvUnit@@QAEXW4TacticalAIMoveTypes@@@Z ; CvUnit::setTacticalMove

; 379  : 			m_CurrentTurnUnits.push_back(pLoopUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]
	lea	edx, DWORD PTR $T266982[esp+44]
	mov	DWORD PTR $T266982[esp+44], ecx
	push	edx
	lea	ecx, DWORD PTR [edi+8]
	call	?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::push_back
$LN16@Commandeer:
	mov	ecx, DWORD PTR [edi]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+48]
	push	eax
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	ebp, eax
	test	esi, esi
	je	SHORT $LN51@Commandeer
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN51@Commandeer:
	mov	esi, ebp
	mov	DWORD PTR _pLoopUnit$[esp+44], esi
	test	ebp, ebp
	je	SHORT $LN144@Commandeer

; 365  : 
; 366  : 	// Loop through our units
; 367  : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	mov	ecx, ebp
	jmp	$LN150@Commandeer
$LN144@Commandeer:

; 409  : 				{
; 410  : 					pLoopUnit->setTacticalMove((TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_UNASSIGNED]);
; 411  : 					m_CurrentTurnUnits.push_back(pLoopUnit->GetID());
; 412  : 				}
; 413  : 			}
; 414  : 		}
; 415  : 	}
; 416  : }

	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	esi, esi
	je	SHORT $LN138@Commandeer
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN138@Commandeer:
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CommandeerUnits@CvTacticalAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?CommandeerUnits@CvTacticalAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?CommandeerUnits@CvTacticalAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?CommandeerUnits@CvTacticalAI@@QAEXXZ ENDP		; CvTacticalAI::CommandeerUnits
EXTRN	?isFighting@CvUnit@@QBE_NXZ:PROC		; CvUnit::isFighting
EXTRN	?getMISSION_RANGE_ATTACK@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_RANGE_ATTACK
EXTRN	?doTask@CvCity@@QAE?AW4CityTaskResult@@W4TaskTypes@@HH_N111@Z:PROC ; CvCity::doTask
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z
_TEXT	SEGMENT
_pCity$ = -120						; size = 4
_this$ = -116						; size = 4
_pUnit$ = -112						; size = 8
$T267243 = -104						; size = 8
_strTemp$220413 = -96					; size = 28
_strMsg$220412 = -68					; size = 28
$T267244 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pAttacker$ = 8						; size = 4
_pTarget$ = 12						; size = 4
_bFirstAttack$ = 16					; size = 1
_bRanged$ = 20						; size = 1
_bCityAttack$ = 24					; size = 1
?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z PROC ; CvTacticalAI::LaunchAttack, COMDAT
; _this$ = ecx

; 587  : {

	push	-1
	push	__ehhandler$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 108				; 0000006cH
	push	ebp
	push	esi
	push	edi

; 588  : 	CvCity* pCity = NULL;

	xor	ebp, ebp

; 589  : 	UnitHandle pUnit;

	xor	edi, edi
	mov	DWORD PTR _this$[esp+132], ecx
	mov	DWORD PTR _pCity$[esp+132], ebp
	mov	DWORD PTR _pUnit$[esp+132], edi
	mov	BYTE PTR _pUnit$[esp+136], 0

; 590  : 
; 591  : 	if(bCityAttack)

	cmp	BYTE PTR _bCityAttack$[esp+128], 0
	mov	DWORD PTR __$EHRec$[esp+140], ebp
	je	SHORT $LN18@LaunchAtta

; 592  : 	{
; 593  : 		pCity = (CvCity*)pAttacker;

	mov	eax, DWORD PTR _pAttacker$[esp+128]
	mov	DWORD PTR _pCity$[esp+132], eax

; 594  : 	}
; 595  : 	else

	mov	ebp, eax
	jmp	SHORT $LN153@LaunchAtta
$LN18@LaunchAtta:

; 596  : 	{
; 597  : 		pUnit = UnitHandle((CvUnit*)pAttacker);

	mov	edi, DWORD PTR _pAttacker$[esp+128]
	mov	DWORD PTR $T267243[esp+132], edi
	mov	BYTE PTR $T267243[esp+136], 0
	cmp	edi, ebp
	je	SHORT $LN33@LaunchAtta
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN33@LaunchAtta:
	mov	BYTE PTR __$EHRec$[esp+140], 1
	mov	DWORD PTR _pUnit$[esp+132], edi
	cmp	edi, ebp
	je	SHORT $LN42@LaunchAtta
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN42@LaunchAtta:
	mov	BYTE PTR __$EHRec$[esp+140], 0
	cmp	edi, ebp
	je	SHORT $LN153@LaunchAtta
	mov	ecx, DWORD PTR _pAttacker$[esp+128]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN153@LaunchAtta:

; 598  : 	}
; 599  : 
; 600  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	mov	esi, DWORD PTR _pTarget$[esp+128]
	test	al, al
	je	$LN154@LaunchAtta
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN154@LaunchAtta

; 601  : 	{
; 602  : 		CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$220412[esp+132]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 603  : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$220413[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 604  : 		int iX, iY;
; 605  : 
; 606  : 		if(bCityAttack)

	cmp	BYTE PTR _bCityAttack$[esp+128], 0
	mov	BYTE PTR __$EHRec$[esp+140], 3
	je	SHORT $LN15@LaunchAtta

; 607  : 		{
; 608  : 			strTemp = pCity->getName();

	lea	ecx, DWORD PTR $T267244[esp+132]
	push	ecx
	mov	ecx, ebp
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _strTemp$220413[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267244[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 609  : 			iX = pCity->getX();

	mov	eax, DWORD PTR [ebp+96]

; 610  : 			iY = pCity->getY();

	mov	ecx, DWORD PTR [ebp+108]

; 611  : 		}
; 612  : 		else

	jmp	SHORT $LN84@LaunchAtta
$LN15@LaunchAtta:

; 613  : 		{
; 614  : 			strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, edi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$220413[esp+132]
	test	eax, eax
	je	SHORT $LN73@LaunchAtta
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN72@LaunchAtta
$LN73@LaunchAtta:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN72@LaunchAtta:

; 615  : 			iX = pUnit->getX();

	mov	eax, DWORD PTR [edi+76]

; 616  : 			iY = pUnit->getY();

	mov	ecx, DWORD PTR [edi+88]
$LN84@LaunchAtta:

; 622  : 			{
; 623  : 				strMsg.Format("Made initial ranged attack with %s, at X: %d, Y: %d, vs. target at X: %d, Y: %d", strTemp.GetCString(), iX, iY, pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	edx, DWORD PTR [esi+8]
	mov	ebp, DWORD PTR [esi+4]
	push	edx
	push	ebp
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _strTemp$220413[esp+148]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	cmp	BYTE PTR _bRanged$[esp+144], 0
	push	eax
	je	SHORT $LN13@LaunchAtta

; 617  : 		}
; 618  : 
; 619  : 		if(bRanged)
; 620  : 		{
; 621  : 			if(bFirstAttack)

	cmp	BYTE PTR _bFirstAttack$[esp+148], 0
	je	SHORT $LN12@LaunchAtta

; 622  : 			{
; 623  : 				strMsg.Format("Made initial ranged attack with %s, at X: %d, Y: %d, vs. target at X: %d, Y: %d", strTemp.GetCString(), iX, iY, pTarget->GetTargetX(), pTarget->GetTargetY());

	push	OFFSET $SG220421

; 624  : 			}
; 625  : 			else

	jmp	SHORT $LN157@LaunchAtta
$LN12@LaunchAtta:

; 626  : 			{
; 627  : 				strMsg.Format("Made follow-on ranged attack with %s, at X: %d, Y: %d, vs. target at X: %d, Y: %d", strTemp.GetCString(), iX, iY, pTarget->GetTargetX(), pTarget->GetTargetY());

	push	OFFSET $SG220423
	lea	eax, DWORD PTR _strMsg$220412[esp+156]
	push	eax

; 628  : 			}
; 629  : 		}
; 630  : 		else

	jmp	SHORT $LN158@LaunchAtta
$LN13@LaunchAtta:

; 631  : 		{
; 632  : 			if(bFirstAttack)

	cmp	BYTE PTR _bFirstAttack$[esp+148], 0
	je	SHORT $LN9@LaunchAtta

; 633  : 			{
; 634  : 				strMsg.Format("Made initial attack with %s, at X: %d, Y: %d, vs. target at X: %d, Y: %d", strTemp.GetCString(), iX, iY, pTarget->GetTargetX(), pTarget->GetTargetY());

	push	OFFSET $SG220426
	lea	ecx, DWORD PTR _strMsg$220412[esp+156]
	push	ecx

; 635  : 			}
; 636  : 			else

	jmp	SHORT $LN158@LaunchAtta
$LN9@LaunchAtta:

; 637  : 			{
; 638  : 				strMsg.Format("Made follow-on attack with %s, at X: %d, Y: %d, vs. target at X: %d, Y: %d", strTemp.GetCString(), iX, iY, pTarget->GetTargetX(), pTarget->GetTargetY());

	push	OFFSET $SG220428
$LN157@LaunchAtta:
	lea	edx, DWORD PTR _strMsg$220412[esp+156]
	push	edx
$LN158@LaunchAtta:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 639  : 			}
; 640  : 		}
; 641  : 
; 642  : 		LogTacticalMessage(strMsg);

	mov	ecx, DWORD PTR _this$[esp+160]
	add	esp, 28					; 0000001cH
	push	1
	lea	eax, DWORD PTR _strMsg$220412[esp+136]
	push	eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 643  : 	}

	lea	ecx, DWORD PTR _strTemp$220413[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strMsg$220412[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebp, DWORD PTR _pCity$[esp+132]
$LN154@LaunchAtta:

; 644  : 
; 645  : 	// Attack AFTER logging since our attacker could die
; 646  : 	if(bCityAttack)

	cmp	BYTE PTR _bCityAttack$[esp+128], 0
	je	SHORT $LN7@LaunchAtta

; 647  : 	{
; 648  : 		pCity->doTask(TASK_RANGED_ATTACK, pTarget->GetTargetX(), pTarget->GetTargetY(), 0);

	mov	eax, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	esi
	push	18					; 00000012H
	mov	ecx, ebp
	call	?doTask@CvCity@@QAE?AW4CityTaskResult@@W4TaskTypes@@HH_N111@Z ; CvCity::doTask

; 649  : 	}
; 650  : 	else

	jmp	$LN2@LaunchAtta
$LN7@LaunchAtta:

; 651  : 	{
; 652  : 		CvAssertMsg(pUnit->getMoves() > 0, "Tactical AI is going to push a mission on the queue to attack, but the unit is out of moves.");
; 653  : 		CvAssertMsg(!pUnit->isOutOfAttacks(), "Tactical AI is going to push a mission on the queue to attack, but the unit is out of attacks.");
; 654  : 
; 655  : 		bool bSendAttack = pUnit->getMoves() > 0 && !pUnit->isOutOfAttacks();

	mov	ecx, edi
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jle	SHORT $LN155@LaunchAtta
	mov	ecx, edi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al

; 656  : 		if(bSendAttack)

	jne	SHORT $LN155@LaunchAtta

; 657  : 		{
; 658  : 			if(bRanged && pUnit->getDomainType() != DOMAIN_AIR)	// Air attack is ranged, but it goes through the 'move to' mission.

	cmp	BYTE PTR _bRanged$[esp+128], al
	je	SHORT $LN4@LaunchAtta
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN4@LaunchAtta

; 659  : 			{
; 660  : 				pUnit->PushMission(CvTypes::getMISSION_RANGE_ATTACK(), pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	esi
	call	?getMISSION_RANGE_ATTACK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_RANGE_ATTACK

; 661  : 			}
; 662  : 			//else if (pUnit->canNuke(NULL)) // NUKE tactical attack (ouch)
; 663  : 			//{
; 664  : 			//	pUnit->PushMission(CvTypes::getMISSION_NUKE(), pTarget->GetTargetX(), pTarget->GetTargetY());
; 665  : 			//}
; 666  : 			else

	jmp	SHORT $LN159@LaunchAtta
$LN4@LaunchAtta:

; 667  : 			{
; 668  : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	esi
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
$LN159@LaunchAtta:
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 669  : 			}
; 670  : 		}
; 671  : 
; 672  : 		// Make sure we did make an attack, if not we should take out this unit from the queue
; 673  : 		if(!bSendAttack || (!pUnit->isOutOfAttacks() && !pUnit->isFighting()))

	mov	ecx, edi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	jne	SHORT $LN2@LaunchAtta
	mov	ecx, edi
	call	?isFighting@CvUnit@@QBE_NXZ		; CvUnit::isFighting
	test	al, al
	jne	SHORT $LN2@LaunchAtta
$LN155@LaunchAtta:

; 674  : 		{
; 675  : 			pUnit->SetTurnProcessed(false);

	push	0
	mov	ecx, edi
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed

; 676  : 			CombatResolved(pAttacker, false, bCityAttack);

	mov	ecx, DWORD PTR _pAttacker$[esp+128]
	push	0
	push	0
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+144]
	call	?CombatResolved@CvTacticalAI@@QAEXPAX_N1@Z ; CvTacticalAI::CombatResolved
$LN2@LaunchAtta:

; 677  : 		}
; 678  : 	}
; 679  : }

	mov	DWORD PTR __$EHRec$[esp+140], -1
	test	edi, edi
	je	SHORT $LN149@LaunchAtta
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN149@LaunchAtta:
	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 120				; 00000078H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z$1:
	lea	ecx, DWORD PTR $T267243[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z$2:
	lea	ecx, DWORD PTR _strMsg$220412[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z$3:
	lea	ecx, DWORD PTR _strTemp$220413[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z$4:
	lea	ecx, DWORD PTR $T267244[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z:
	mov	eax, OFFSET __ehfuncinfo$?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z ENDP ; CvTacticalAI::LaunchAttack
PUBLIC	?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z ; CvTacticalAI::PlotPlunderTradePlotMoves
EXTRN	?finishMoves@CvUnit@@QAEXXZ:PROC		; CvUnit::finishMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z$0
__ehfuncinfo$?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z
_TEXT	SEGMENT
tv530 = -48						; size = 4
_pTarget$221622 = -44					; size = 4
_eTargetType$ = -40					; size = 4
_this$ = -36						; size = 4
_pChosenTarget$221621 = -32				; size = 4
_ui$221612 = -28					; size = 4
_iDistance$221627 = -24					; size = 4
_pUnit$221616 = -20					; size = 8
__$EHRec$ = -12						; size = 12
_eDomain$ = 8						; size = 4
?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z PROC ; CvTacticalAI::PlotPlunderTradePlotMoves, COMDAT
; _this$ = ecx

; 2681 : {

	push	-1
	push	__ehhandler$?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx

; 2682 : 	AITacticalTargetType eTargetType = AI_TACTICAL_TARGET_NONE;
; 2683 : 	bool bNavalOnly = false;
; 2684 : 	if (eDomain == DOMAIN_LAND)

	mov	ebx, DWORD PTR _eDomain$[esp+48]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+56], esi
	cmp	ebx, 2
	jne	SHORT $LN14@PlotPlunde

; 2685 : 	{
; 2686 : 		eTargetType = AI_TACTICAL_TARGET_TRADE_UNIT_LAND_PLOT;

	mov	DWORD PTR _eTargetType$[esp+56], 22	; 00000016H
	jmp	SHORT $LN128@PlotPlunde
$LN14@PlotPlunde:

; 2687 : 	}
; 2688 : 	else if (eDomain == DOMAIN_SEA)

	test	ebx, ebx
	jne	$LN8@PlotPlunde

; 2689 : 	{
; 2690 : 		eTargetType = AI_TACTICAL_TARGET_TRADE_UNIT_SEA_PLOT;

	mov	DWORD PTR _eTargetType$[esp+56], 21	; 00000015H
$LN128@PlotPlunde:

; 2691 : 		bNavalOnly = true;
; 2692 : 	}
; 2693 : 
; 2694 : 	CvAssertMsg(eTargetType != AI_TACTICAL_TARGET_NONE, "Undefined domain type for target");
; 2695 : 	if (eTargetType == AI_TACTICAL_TARGET_NONE)
; 2696 : 	{
; 2697 : 		return;
; 2698 : 	}
; 2699 : 
; 2700 : 	for (uint ui = 0; ui < m_CurrentMoveUnits.size(); ui++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	push	ebp
	xor	ebp, ebp
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _ui$221612[esp+60], ebp
	je	$LN137@PlotPlunde
	push	edi
	mov	DWORD PTR tv530[esp+64], ebp
	jmp	SHORT $LN10@PlotPlunde
	npad	2
$LL135@PlotPlunde:
	xor	ebp, ebp
$LN10@PlotPlunde:

; 2701 : 	{
; 2702 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[ui].GetID());

	mov	eax, DWORD PTR [esi+24]
	add	eax, DWORD PTR tv530[esp+64]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$221616[esp+64], edi
	mov	BYTE PTR _pUnit$221616[esp+68], 0
	cmp	edi, ebp
	je	SHORT $LN27@PlotPlunde
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN27@PlotPlunde:
	mov	DWORD PTR __$EHRec$[esp+72], ebp

; 2703 : 		if (!pUnit)

	cmp	edi, ebp
	jne	SHORT $LN7@PlotPlunde

; 2704 : 		{
; 2705 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+72], -1
	jmp	$LN9@PlotPlunde
$LN7@PlotPlunde:

; 2706 : 		}
; 2707 : 
; 2708 : 		if (pUnit->getDomainType() != eDomain)

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, ebx
	je	SHORT $LN6@PlotPlunde

; 2709 : 		{
; 2710 : 			continue;

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	$LN9@PlotPlunde
$LN6@PlotPlunde:

; 2711 : 		}
; 2712 : 
; 2713 : 		int iClosestTarget = MAX_INT;
; 2714 : 		CvPlot* pClosestPlot = NULL;
; 2715 : 		CvTacticalTarget* pChosenTarget = NULL;
; 2716 : 		CvTacticalTarget* pTarget = GetFirstZoneTarget(eTargetType);

	mov	ecx, DWORD PTR _eTargetType$[esp+64]
	push	ecx
	mov	ecx, esi
	mov	ebx, 2147483647				; 7fffffffH
	mov	DWORD PTR _pChosenTarget$221621[esp+68], 0
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	DWORD PTR _pTarget$221622[esp+64], eax

; 2717 : 		while(pTarget != NULL)

	test	eax, eax
	je	$LN133@PlotPlunde
	jmp	SHORT $LN5@PlotPlunde
	npad	12
$LL130@PlotPlunde:
	mov	eax, DWORD PTR _pTarget$221622[esp+64]
$LN5@PlotPlunde:

; 2718 : 		{
; 2719 : 			if (pTarget->GetAuxIntData() == 0)

	cmp	DWORD PTR [eax+20], 0
	jne	$LN2@PlotPlunde

; 2720 : 			{
; 2721 : 				int iDistance = plotDistance(pUnit->getX(), pUnit->getY(), pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	edi, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _pUnit$221616[esp+64]
	mov	eax, DWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [ecx+76]
	push	edi
	push	esi
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 2722 : 				if(iDistance < iClosestTarget)

	cmp	eax, ebx
	mov	DWORD PTR _iDistance$221627[esp+64], eax
	jge	$LN132@PlotPlunde

; 2723 : 				{
; 2724 : 					pClosestPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	cmp	esi, -2147483647			; 80000001H
	je	$LN67@PlotPlunde
	cmp	edi, -2147483647			; 80000001H
	je	SHORT $LN67@PlotPlunde
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	al, al
	je	SHORT $LN131@PlotPlunde
	test	esi, esi
	jge	SHORT $LN79@PlotPlunde
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN131@PlotPlunde
$LN79@PlotPlunde:
	cmp	esi, ecx
	jl	SHORT $LN131@PlotPlunde
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN131@PlotPlunde:
	mov	al, BYTE PTR [ebp+4057]
	mov	ebx, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN134@PlotPlunde
	test	edi, edi
	jge	SHORT $LN89@PlotPlunde
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN91@PlotPlunde
$LN89@PlotPlunde:
	cmp	edi, ebx
	jl	SHORT $LN134@PlotPlunde
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN91@PlotPlunde
$LN134@PlotPlunde:
	mov	edx, edi
$LN91@PlotPlunde:
	test	esi, esi
	jl	SHORT $LN67@PlotPlunde
	cmp	esi, ecx
	jge	SHORT $LN67@PlotPlunde
	test	edx, edx
	jl	SHORT $LN67@PlotPlunde
	cmp	edx, ebx
	jge	SHORT $LN67@PlotPlunde
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	ebp, ecx
	jmp	SHORT $LN69@PlotPlunde
$LN67@PlotPlunde:
	xor	ebp, ebp
$LN69@PlotPlunde:

; 2725 : 					iClosestTarget = iDistance;
; 2726 : 					pChosenTarget = pTarget;

	mov	edx, DWORD PTR _pTarget$221622[esp+64]
	mov	ebx, DWORD PTR _iDistance$221627[esp+64]
	mov	DWORD PTR _pChosenTarget$221621[esp+64], edx
$LN132@PlotPlunde:
	mov	edi, DWORD PTR _pUnit$221616[esp+64]
	mov	esi, DWORD PTR _this$[esp+64]
$LN2@PlotPlunde:

; 2727 : 				}
; 2728 : 			}
; 2729 : 
; 2730 : 			pTarget = GetNextZoneTarget();

	mov	ecx, esi
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	DWORD PTR _pTarget$221622[esp+64], eax
	test	eax, eax
	jne	$LL130@PlotPlunde

; 2731 : 		}
; 2732 : 
; 2733 : 		if (pClosestPlot)

	test	ebp, ebp
	je	SHORT $LN133@PlotPlunde

; 2734 : 		{
; 2735 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pClosestPlot->getX(), pClosestPlot->getY());

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2736 : 			pUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 2737 : 			
; 2738 : 			// Delete this unit from those we have to move
; 2739 : 			UnitProcessed(m_CurrentMoveUnits[ui].GetID());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR tv530[esp+64]
	mov	eax, DWORD PTR [ecx+eax]
	push	1
	push	eax
	mov	ecx, esi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 2740 : 
; 2741 : 			// flag target as used
; 2742 : 			pChosenTarget->SetAuxIntData(1);

	mov	edx, DWORD PTR _pChosenTarget$221621[esp+64]
	mov	DWORD PTR [edx+20], 1
$LN133@PlotPlunde:

; 2743 : 		}
; 2744 : 	}

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ebx, DWORD PTR _eDomain$[esp+60]
$LN9@PlotPlunde:
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	edi, DWORD PTR _ui$221612[esp+64]
	add	DWORD PTR tv530[esp+64], 24		; 00000018H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	edi
	add	eax, edx
	mov	DWORD PTR _ui$221612[esp+64], edi
	cmp	edi, eax
	jb	$LL135@PlotPlunde
	pop	edi
$LN137@PlotPlunde:
	pop	ebp
$LN8@PlotPlunde:

; 2745 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$221616[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z ENDP ; CvTacticalAI::PlotPlunderTradePlotMoves
PUBLIC	?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteBarbarianCampMove
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0
__ehfuncinfo$?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pUnit$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pTargetPlot$ = 8					; size = 4
?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z PROC ; CvTacticalAI::ExecuteBarbarianCampMove, COMDAT
; _this$ = ecx

; 6184 : {

	push	-1
	push	__ehhandler$?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 6185 : 	// Move first one to target
; 6186 : 	UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$[esp+28], esi
	mov	BYTE PTR _pUnit$[esp+32], 0
	test	esi, esi
	je	SHORT $LN12@ExecuteBar
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@ExecuteBar:
	mov	DWORD PTR __$EHRec$[esp+36], 0

; 6187 : 	if(pUnit)

	test	esi, esi
	je	SHORT $LN1@ExecuteBar

; 6188 : 	{
; 6189 : 		pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTargetPlot->getX(), pTargetPlot->getY());

	mov	eax, DWORD PTR _pTargetPlot$[esp+24]
	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6190 : 		pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6191 : 
; 6192 : 		// Delete this unit from those we have to move
; 6193 : 		UnitProcessed(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	push	1
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed
$LN1@ExecuteBar:

; 6194 : 	}
; 6195 : }

	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	esi, esi
	je	SHORT $LN31@ExecuteBar
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN31@ExecuteBar:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z ENDP ; CvTacticalAI::ExecuteBarbarianCampMove
PUBLIC	?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteCivilianCapture
EXTRN	?SetTacticalAIPlot@CvUnit@@QAEXPAVCvPlot@@@Z:PROC ; CvUnit::SetTacticalAIPlot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0
__ehfuncinfo$?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pUnit$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pTargetPlot$ = 8					; size = 4
?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z PROC ; CvTacticalAI::ExecuteCivilianCapture, COMDAT
; _this$ = ecx

; 6199 : {

	push	-1
	push	__ehhandler$?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 6200 : 	// Move first one to target
; 6201 : 	UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$[esp+28], esi
	mov	BYTE PTR _pUnit$[esp+32], 0
	test	esi, esi
	je	SHORT $LN12@ExecuteCiv
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@ExecuteCiv:
	mov	DWORD PTR __$EHRec$[esp+36], 0

; 6202 : 	if(pUnit)

	test	esi, esi
	je	SHORT $LN1@ExecuteCiv

; 6203 : 	{
; 6204 : 		pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTargetPlot->getX(), pTargetPlot->getY());

	mov	eax, DWORD PTR _pTargetPlot$[esp+24]
	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6205 : 		pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6206 : 
; 6207 : 		// Delete this unit from those we have to move
; 6208 : 		UnitProcessed(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	push	1
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 6209 : 
; 6210 : 		pUnit->SetTacticalAIPlot(NULL);

	push	0
	mov	ecx, esi
	call	?SetTacticalAIPlot@CvUnit@@QAEXPAVCvPlot@@@Z ; CvUnit::SetTacticalAIPlot
$LN1@ExecuteCiv:

; 6211 : 	}
; 6212 : }

	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	esi, esi
	je	SHORT $LN33@ExecuteCiv
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN33@ExecuteCiv:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z ENDP ; CvTacticalAI::ExecuteCivilianCapture
PUBLIC	?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z	; CvTacticalAI::ExecutePillage
EXTRN	?getMISSION_PILLAGE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_PILLAGE
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0
__ehfuncinfo$?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pUnit$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pTargetPlot$ = 8					; size = 4
?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z PROC	; CvTacticalAI::ExecutePillage, COMDAT
; _this$ = ecx

; 6216 : {

	push	-1
	push	__ehhandler$?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 6217 : 	// Move first one to target
; 6218 : 	UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$[esp+28], esi
	mov	BYTE PTR _pUnit$[esp+32], 0
	test	esi, esi
	je	SHORT $LN12@ExecutePil
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@ExecutePil:
	mov	DWORD PTR __$EHRec$[esp+36], 0

; 6219 : 	if(pUnit)

	test	esi, esi
	je	SHORT $LN1@ExecutePil

; 6220 : 	{
; 6221 : 		pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTargetPlot->getX(), pTargetPlot->getY());

	mov	eax, DWORD PTR _pTargetPlot$[esp+24]
	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6222 : 		pUnit->PushMission(CvTypes::getMISSION_PILLAGE());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_PILLAGE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PILLAGE
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6223 : 		pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6224 : 
; 6225 : 		// Delete this unit from those we have to move
; 6226 : 		UnitProcessed(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	push	1
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed
$LN1@ExecutePil:

; 6227 : 	}
; 6228 : }

	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	esi, esi
	je	SHORT $LN33@ExecutePil
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN33@ExecutePil:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z ENDP	; CvTacticalAI::ExecutePillage
PUBLIC	?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecutePlunderTradeUnit
EXTRN	?getMISSION_PLUNDER_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_PLUNDER_TRADE_ROUTE
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0
__ehfuncinfo$?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pUnit$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pTargetPlot$ = 8					; size = 4
?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z PROC ; CvTacticalAI::ExecutePlunderTradeUnit, COMDAT
; _this$ = ecx

; 6232 : {

	push	-1
	push	__ehhandler$?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 6233 : 	// Move first one to target
; 6234 : 	UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$[esp+28], esi
	mov	BYTE PTR _pUnit$[esp+32], 0
	test	esi, esi
	je	SHORT $LN12@ExecutePlu
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@ExecutePlu:
	mov	DWORD PTR __$EHRec$[esp+36], 0

; 6235 : 	if(pUnit)

	test	esi, esi
	je	SHORT $LN1@ExecutePlu

; 6236 : 	{
; 6237 : 		pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTargetPlot->getX(), pTargetPlot->getY());

	mov	eax, DWORD PTR _pTargetPlot$[esp+24]
	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6238 : 		pUnit->PushMission(CvTypes::getMISSION_PLUNDER_TRADE_ROUTE());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_PLUNDER_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PLUNDER_TRADE_ROUTE
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6239 : 		pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6240 : 
; 6241 : 		// Delete this unit from those we have to move
; 6242 : 		UnitProcessed(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	push	1
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed
$LN1@ExecutePlu:

; 6243 : 	}
; 6244 : }

	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	esi, esi
	je	SHORT $LN33@ExecutePlu
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN33@ExecutePlu:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z ENDP ; CvTacticalAI::ExecutePlunderTradeUnit
PUBLIC	?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteParadropPillage
EXTRN	?getMISSION_PARADROP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_PARADROP
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0
__ehfuncinfo$?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pUnit$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pTargetPlot$ = 8					; size = 4
?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z PROC ; CvTacticalAI::ExecuteParadropPillage, COMDAT
; _this$ = ecx

; 6248 : {

	push	-1
	push	__ehhandler$?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 6249 : 	// Move first one to target
; 6250 : 	UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$[esp+28], esi
	mov	BYTE PTR _pUnit$[esp+32], 0
	test	esi, esi
	je	SHORT $LN12@ExecutePar
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@ExecutePar:
	mov	DWORD PTR __$EHRec$[esp+36], 0

; 6251 : 	if(pUnit)

	test	esi, esi
	je	SHORT $LN1@ExecutePar

; 6252 : 	{
; 6253 : 		pUnit->PushMission(CvTypes::getMISSION_PARADROP(), pTargetPlot->getX(), pTargetPlot->getY());

	mov	eax, DWORD PTR _pTargetPlot$[esp+24]
	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	call	?getMISSION_PARADROP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PARADROP
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6254 : 		pUnit->PushMission(CvTypes::getMISSION_PILLAGE());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_PILLAGE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PILLAGE
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6255 : 		pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6256 : 
; 6257 : 		// Delete this unit from those we have to move
; 6258 : 		UnitProcessed(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	push	1
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed
$LN1@ExecutePar:

; 6259 : 	}
; 6260 : }

	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	esi, esi
	je	SHORT $LN33@ExecutePar
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN33@ExecutePar:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z ENDP ; CvTacticalAI::ExecuteParadropPillage
PUBLIC	?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::ExecuteRepositionMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ$4
__ehfuncinfo$?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_iI$223508 = -84					; size = 4
$T268071 = -80						; size = 4
$T268070 = -80						; size = 4
_pUnit$223512 = -76					; size = 8
_strTemp$ = -68						; size = 28
_strLogString$223520 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::ExecuteRepositionMoves, COMDAT
; _this$ = ecx

; 6516 : {

	push	-1
	push	__ehhandler$?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 6517 : 	CvPlot* pBestPlot = NULL;
; 6518 : 	CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$[esp+100]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6519 : 
; 6520 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __$EHRec$[esp+108], 0
	mov	DWORD PTR _iI$223508[esp+100], 0
	je	$LN6@ExecuteRep

; 6517 : 	CvPlot* pBestPlot = NULL;
; 6518 : 	CvString strTemp;

	xor	ebx, ebx
$LL8@ExecuteRep:

; 6521 : 	{
; 6522 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$223512[esp+100], esi
	mov	BYTE PTR _pUnit$223512[esp+104], 0
	test	esi, esi
	je	SHORT $LN28@ExecuteRep
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN28@ExecuteRep:
	mov	BYTE PTR __$EHRec$[esp+108], 1

; 6523 : 		if(pUnit)

	test	esi, esi
	je	$LN1@ExecuteRep

; 6524 : 		{
; 6525 : 			strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$[esp+100]
	test	eax, eax
	je	SHORT $LN37@ExecuteRep
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN36@ExecuteRep
$LN37@ExecuteRep:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN36@ExecuteRep:

; 6526 : 
; 6527 : 			// LAND MOVES
; 6528 : 			if(pUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	$LN1@ExecuteRep

; 6529 : 			{
; 6530 : 				pBestPlot = FindNearbyTarget(pUnit, m_iRepositionRange);

	mov	ecx, DWORD PTR [edi+24768]
	push	0
	push	0
	push	ecx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T268070[esp+120], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z ; CvTacticalAI::FindNearbyTarget
	mov	ebp, eax

; 6531 : 
; 6532 : 				if(pBestPlot)

	test	ebp, ebp
	je	$LN1@ExecuteRep

; 6533 : 				{
; 6534 : 					if(MoveToEmptySpaceNearTarget(pUnit, pBestPlot, (pUnit->getDomainType()==DOMAIN_LAND)))

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	sete	dl
	movzx	eax, dl
	push	eax
	push	ebp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T268071[esp+116], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::MoveToEmptySpaceNearTarget
	test	al, al
	je	$LN1@ExecuteRep

; 6535 : 					{
; 6536 : 						pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6537 : 						UnitProcessed(m_CurrentMoveUnits[iI].GetID(), pUnit->IsCombatUnit());

	cmp	DWORD PTR [esi+1044], 0
	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ebx+ecx]
	setg	dl
	movzx	ecx, dl
	push	ecx
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 6538 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteRep
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteRep

; 6539 : 						{
; 6540 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223520[esp+100]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6541 : 							strLogString.Format("%s moved to empty space near target, X: %d, Y: %d, Current X: %d, Current Y: %d", strTemp.GetCString(),
; 6542 : 							                    pBestPlot->getX(), pBestPlot->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	movsx	edx, WORD PTR [ebp+2]
	movsx	ebp, WORD PTR [ebp]
	push	eax
	push	ecx
	push	edx
	push	ebp
	lea	ecx, DWORD PTR _strTemp$[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$223520[esp+120]
	push	OFFSET $SG223521
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 6543 : 							LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$223520[esp+104]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 6544 : 						}

	lea	ecx, DWORD PTR _strLogString$223520[esp+100]
	mov	BYTE PTR __$EHRec$[esp+108], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteRep:

; 6545 : 					}
; 6546 : 				}
; 6547 : 			}
; 6548 : 		}
; 6549 : 	}

	mov	BYTE PTR __$EHRec$[esp+108], 0
	test	esi, esi
	je	SHORT $LN7@ExecuteRep
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN7@ExecuteRep:
	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	esi, DWORD PTR _iI$223508[esp+100]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	inc	esi
	add	ecx, edx
	add	ebx, 24					; 00000018H
	mov	DWORD PTR _iI$223508[esp+100], esi
	cmp	esi, ecx
	jb	$LL8@ExecuteRep
$LN6@ExecuteRep:

; 6550 : }

	lea	ecx, DWORD PTR _strTemp$[esp+100]
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 84					; 00000054H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$223512[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$223520[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::ExecuteRepositionMoves
PUBLIC	?ExecuteHeals@CvTacticalAI@@AAEXXZ		; CvTacticalAI::ExecuteHeals
EXTRN	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z:PROC	; CvUnit::SetFortifiedThisTurn
EXTRN	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FORTIFY
EXTRN	?isFortifyable@CvUnit@@QBE_N_N@Z:PROC		; CvUnit::isFortifyable
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteHeals@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteHeals@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?ExecuteHeals@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteHeals@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteHeals@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_pUnit$223830 = -20					; size = 8
__$EHRec$ = -12						; size = 12
?ExecuteHeals@CvTacticalAI@@AAEXXZ PROC			; CvTacticalAI::ExecuteHeals, COMDAT
; _this$ = ecx

; 6815 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ExecuteHeals@CvTacticalAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 6816 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	ebx, ebx
	add	eax, edx
	je	$LN4@ExecuteHea
	push	ebp
	push	edi
	xor	ebp, ebp
	npad	1
$LL6@ExecuteHea:

; 6817 : 	{
; 6818 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebp
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$223830[esp+36], edi
	mov	BYTE PTR _pUnit$223830[esp+40], 0
	test	edi, edi
	je	SHORT $LN19@ExecuteHea
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN19@ExecuteHea:
	mov	DWORD PTR __$EHRec$[esp+44], 0

; 6819 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN3@ExecuteHea

; 6820 : 		{
; 6821 : 			if(pUnit->isFortifyable())

	push	0
	mov	ecx, edi
	call	?isFortifyable@CvUnit@@QBE_N_N@Z	; CvUnit::isFortifyable

; 6822 : 			{
; 6823 : 				pUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	test	al, al
	je	SHORT $LN2@ExecuteHea
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6824 : 				pUnit->SetFortifiedThisTurn(true);

	push	1
	mov	ecx, edi
	call	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z	; CvUnit::SetFortifiedThisTurn

; 6825 : 			}
; 6826 : 			else

	jmp	SHORT $LN1@ExecuteHea
$LN2@ExecuteHea:

; 6827 : 			{
; 6828 : 				pUnit->PushMission(CvTypes::getMISSION_SKIP());

	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission
$LN1@ExecuteHea:

; 6829 : 			}
; 6830 : 			UnitProcessed(m_CurrentMoveUnits[iI].GetID());

	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+ebp]
	push	1
	push	eax
	mov	ecx, esi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed
$LN3@ExecuteHea:

; 6831 : 		}
; 6832 : 	}

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	edi, edi
	je	SHORT $LN5@ExecuteHea
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@ExecuteHea:
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	add	ebp, 24					; 00000018H
	cmp	ebx, eax
	jb	$LL6@ExecuteHea
	pop	edi
	pop	ebp
$LN4@ExecuteHea:

; 6833 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteHeals@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$223830[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteHeals@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteHeals@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteHeals@CvTacticalAI@@AAEXXZ ENDP			; CvTacticalAI::ExecuteHeals
PUBLIC	?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z	; CvTacticalAI::ExecuteBarbarianMoves
EXTRN	?GetTacticalAIPlot@CvUnit@@QBEPAVCvPlot@@XZ:PROC ; CvUnit::GetTacticalAIPlot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z$10
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z$11
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z
_TEXT	SEGMENT
_iI$223841 = -112					; size = 4
$T268312 = -108						; size = 4
$T268311 = -108						; size = 4
$T268310 = -108						; size = 4
$T268308 = -108						; size = 4
_pUnit$223845 = -104					; size = 8
_strTemp$ = -96						; size = 28
_strLogString$223875 = -68				; size = 28
_strLogString$223861 = -68				; size = 28
_strLogString$223857 = -68				; size = 28
_strLogString$223879 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_bAggressive$ = 8					; size = 1
?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z PROC	; CvTacticalAI::ExecuteBarbarianMoves, COMDAT
; _this$ = ecx

; 6837 : {

	push	-1
	push	__ehhandler$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 6838 : 	CvPlot* pBestPlot = NULL;
; 6839 : 	CvPlot* pCurrentDestination;
; 6840 : 	CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6841 : 
; 6842 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __$EHRec$[esp+136], 0
	mov	DWORD PTR _iI$223841[esp+128], 0
	je	$LN20@ExecuteBar@2

; 6838 : 	CvPlot* pBestPlot = NULL;
; 6839 : 	CvPlot* pCurrentDestination;
; 6840 : 	CvString strTemp;

	xor	ebx, ebx
$LL22@ExecuteBar@2:

; 6843 : 	{
; 6844 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$223845[esp+128], esi
	mov	BYTE PTR _pUnit$223845[esp+132], 0
	test	esi, esi
	je	SHORT $LN49@ExecuteBar@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN49@ExecuteBar@2:
	mov	BYTE PTR __$EHRec$[esp+136], 1

; 6845 : 		if(pUnit)

	test	esi, esi
	je	$LN1@ExecuteBar@2

; 6846 : 		{
; 6847 : 			if(pUnit->isBarbarian())

	mov	ecx, esi
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	je	$LN1@ExecuteBar@2

; 6848 : 			{
; 6849 : 				strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$[esp+128]
	test	eax, eax
	je	SHORT $LN60@ExecuteBar@2
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN59@ExecuteBar@2
$LN60@ExecuteBar@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN59@ExecuteBar@2:

; 6850 : 
; 6851 : 				// LAND MOVES
; 6852 : 				if(pUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 6853 : 				{
; 6854 : 					AI_PERF_FORMAT("AI-perf-tact.csv", ("Barb Land Move, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 6855 : 
; 6856 : 					if(bAggressive)
; 6857 : 					{
; 6858 : 						pBestPlot = FindBestBarbarianLandMove(pUnit);

	mov	ecx, esi
	cmp	eax, 2
	jne	$LN17@ExecuteBar@2
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T268308[esp+136], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	cmp	BYTE PTR _bAggressive$[esp+132], 0
	mov	ecx, edi
	je	SHORT $LN16@ExecuteBar@2
	call	?FindBestBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::FindBestBarbarianLandMove

; 6859 : 					}
; 6860 : 					else

	jmp	SHORT $LN235@ExecuteBar@2
$LN16@ExecuteBar@2:

; 6861 : 					{
; 6862 : 						pBestPlot = FindPassiveBarbarianLandMove(pUnit);

	call	?FindPassiveBarbarianLandMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::FindPassiveBarbarianLandMove
$LN235@ExecuteBar@2:
	mov	ebp, eax

; 6863 : 					}
; 6864 : 
; 6865 : 					if(pBestPlot && MoveToEmptySpaceNearTarget(pUnit, pBestPlot))

	test	ebp, ebp
	je	$LN14@ExecuteBar@2
	push	1
	push	ebp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T268310[esp+144], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::MoveToEmptySpaceNearTarget
	test	al, al
	je	$LN14@ExecuteBar@2

; 6866 : 					{
; 6867 : 						pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6868 : 						UnitProcessed(m_CurrentMoveUnits[iI].GetID());

	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ebx+ecx]
	push	1
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 6869 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteBar@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteBar@2

; 6870 : 						{
; 6871 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223857[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6872 : 							strLogString.Format("%s moved to empty space near target, X: %d, Y: %d, Current X: %d, Current Y: %d", strTemp.GetCString(),
; 6873 : 							                    pBestPlot->getX(), pBestPlot->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	movsx	edx, WORD PTR [ebp+2]
	movsx	ebp, WORD PTR [ebp]
	push	eax
	push	ecx
	push	edx
	push	ebp
	lea	ecx, DWORD PTR _strTemp$[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG223858
$LN238@ExecuteBar@2:
	lea	edx, DWORD PTR _strLogString$223857[esp+152]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH
$LN237@ExecuteBar@2:

; 6874 : 							LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$223857[esp+132]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 6875 : 						}

	lea	ecx, DWORD PTR _strLogString$223857[esp+128]

; 6876 : 					}
; 6877 : 					else

	jmp	$LN236@ExecuteBar@2
$LN14@ExecuteBar@2:

; 6878 : 					{
; 6879 : 						pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6880 : 						UnitProcessed(m_CurrentMoveUnits[iI].GetID());

	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ebx+ecx]
	push	1
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 6881 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteBar@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteBar@2

; 6882 : 						{
; 6883 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223861[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6884 : 							strLogString.Format("No target for %s at position, Current X: %d, Current Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$223861[esp+140]
	push	OFFSET $SG223862
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 6885 : 							LogTacticalMessage(strLogString);
; 6886 : 						}
; 6887 : 					}
; 6888 : 				}
; 6889 : 
; 6890 : 				// NAVAL MOVES
; 6891 : 				else

	jmp	$LN237@ExecuteBar@2
$LN17@ExecuteBar@2:

; 6892 : 				{
; 6893 : 
; 6894 : 					AI_PERF_FORMAT("AI-perf-tact.csv", ("Barb Naval Move, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 6895 : 
; 6896 : 					// Do I still have a destination from a previous turn?
; 6897 : 					pCurrentDestination = pUnit->GetTacticalAIPlot();

	call	?GetTacticalAIPlot@CvUnit@@QBEPAVCvPlot@@XZ ; CvUnit::GetTacticalAIPlot
	mov	ebp, eax

; 6898 : 
; 6899 : 					// Compute a new destination if I don't have one or am already there
; 6900 : 					if(pCurrentDestination == NULL ||
; 6901 : 					        pCurrentDestination == pUnit->plot())

	test	ebp, ebp
	je	SHORT $LN8@ExecuteBar@2
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	ebp, eax
	je	SHORT $LN8@ExecuteBar@2

; 6904 : 					}
; 6905 : 
; 6906 : 					// Otherwise just keep moving there (assuming a path is available)
; 6907 : 					else
; 6908 : 					{
; 6909 : 						if(TurnsToReachTarget(pUnit, pCurrentDestination, true /*bReusePaths*/) != MAX_INT)

	push	0
	push	0
	push	1
	push	ebp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T268312[esp+152], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	cmp	eax, 2147483647				; 7fffffffH

; 6910 : 						{
; 6911 : 							pBestPlot = pCurrentDestination;
; 6912 : 						}
; 6913 : 						else

	jne	SHORT $LN5@ExecuteBar@2
$LN8@ExecuteBar@2:

; 6902 : 					{
; 6903 : 						pBestPlot = FindBestBarbarianSeaMove(pUnit);

	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	ecx, esi
	mov	DWORD PTR $T268311[esp+136], esp
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?FindBestBarbarianSeaMove@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::FindBestBarbarianSeaMove
	mov	ebp, eax
$LN5@ExecuteBar@2:

; 6914 : 						{
; 6915 : 							pBestPlot = FindBestBarbarianSeaMove(pUnit);
; 6916 : 						}
; 6917 : 					}
; 6918 : 
; 6919 : 					if(pBestPlot != NULL)
; 6920 : 					{
; 6921 : 						pUnit->SetTacticalAIPlot(pBestPlot);

	mov	ecx, esi
	test	ebp, ebp
	je	$LN4@ExecuteBar@2
	push	ebp
	call	?SetTacticalAIPlot@CvUnit@@QAEXPAVCvPlot@@@Z ; CvUnit::SetTacticalAIPlot

; 6922 : 						pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestPlot->getX(), pBestPlot->getY());

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6923 : 						pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6924 : 						UnitProcessed(m_CurrentMoveUnits[iI].GetID());

	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ebx+ecx]
	push	1
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 6925 : 
; 6926 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteBar@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteBar@2

; 6927 : 						{
; 6928 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223875[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6929 : 							strLogString.Format("Moving %s to new position, X: %d, Y: %d, Current X: %d, Current Y: %d", strTemp.GetCString(),
; 6930 : 							                    pBestPlot->getX(), pBestPlot->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	movsx	edx, WORD PTR [ebp+2]
	movsx	ebp, WORD PTR [ebp]
	push	eax
	push	ecx
	push	edx
	push	ebp
	lea	ecx, DWORD PTR _strTemp$[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG223876

; 6931 : 							LogTacticalMessage(strLogString);
; 6932 : 						}
; 6933 : 					}
; 6934 : 					else

	jmp	$LN238@ExecuteBar@2
$LN4@ExecuteBar@2:

; 6935 : 					{
; 6936 : 						pUnit->SetTacticalAIPlot(NULL);

	push	0
	call	?SetTacticalAIPlot@CvUnit@@QAEXPAVCvPlot@@@Z ; CvUnit::SetTacticalAIPlot

; 6937 : 						pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6938 : 						UnitProcessed(m_CurrentMoveUnits[iI].GetID());

	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ebx+ecx]
	push	1
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 6939 : 
; 6940 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteBar@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteBar@2

; 6941 : 						{
; 6942 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223879[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6943 : 							strLogString.Format("No target for %s at position, Current X: %d, Current Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$223879[esp+140]
	push	OFFSET $SG223880
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 6944 : 							LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$223879[esp+132]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 6945 : 						}

	lea	ecx, DWORD PTR _strLogString$223879[esp+128]
$LN236@ExecuteBar@2:
	mov	BYTE PTR __$EHRec$[esp+136], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteBar@2:

; 6946 : 					}
; 6947 : 				}
; 6948 : 			}
; 6949 : 		}
; 6950 : 	}

	mov	BYTE PTR __$EHRec$[esp+136], 0
	test	esi, esi
	je	SHORT $LN21@ExecuteBar@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN21@ExecuteBar@2:
	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	esi, DWORD PTR _iI$223841[esp+128]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	inc	esi
	add	ecx, edx
	add	ebx, 24					; 00000018H
	mov	DWORD PTR _iI$223841[esp+128], esi
	cmp	esi, ecx
	jb	$LL22@ExecuteBar@2
$LN20@ExecuteBar@2:

; 6951 : }

	lea	ecx, DWORD PTR _strTemp$[esp+128]
	mov	DWORD PTR __$EHRec$[esp+136], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+128]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 112				; 00000070H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z$0:
	lea	ecx, DWORD PTR _strTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z$1:
	lea	ecx, DWORD PTR _pUnit$223845[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z$5:
	lea	ecx, DWORD PTR _strLogString$223857[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z$6:
	lea	ecx, DWORD PTR _strLogString$223861[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z$10:
	lea	ecx, DWORD PTR _strLogString$223875[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z$11:
	lea	ecx, DWORD PTR _strLogString$223879[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z ENDP	; CvTacticalAI::ExecuteBarbarianMoves
PUBLIC	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot
EXTRN	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canFortify
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z$0
__ehfuncinfo$?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_pTarget$ = 16						; size = 4
_bSaveMoves$ = 20					; size = 1
?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z PROC ; CvTacticalAI::ExecuteMoveToPlot, COMDAT
; _this$ = ecx

; 7222 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	push	edi
	mov	edi, ecx

; 7223 : 	// Unit already at target plot?
; 7224 : 	if(pTarget == pUnit->plot())

	mov	ecx, DWORD PTR _pUnit$[esp+16]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR _pTarget$[esp+16]
	cmp	ecx, eax
	jne	SHORT $LN6@ExecuteMov

; 7225 : 	{
; 7226 : 		// Fortify if possible
; 7227 : 		if(pUnit->canFortify(pUnit->plot()))

	mov	ecx, DWORD PTR _pUnit$[esp+16]
	mov	esi, ecx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canFortify

; 7228 : 		{
; 7229 : 			pUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	mov	esi, DWORD PTR _pUnit$[esp+16]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	test	al, al
	je	SHORT $LN5@ExecuteMov
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 7230 : 			pUnit->SetFortifiedThisTurn(true);

	mov	ecx, DWORD PTR _pUnit$[esp+16]
	push	1
	call	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z	; CvUnit::SetFortifiedThisTurn

; 7231 : 		}
; 7232 : 		else

	jmp	SHORT $LN1@ExecuteMov
$LN5@ExecuteMov:

; 7233 : 		{
; 7234 : 			pUnit->PushMission(CvTypes::getMISSION_SKIP());

	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP

; 7235 : 			if(!bSaveMoves)
; 7236 : 			{
; 7237 : 				pUnit->finishMoves();
; 7238 : 			}
; 7239 : 		}
; 7240 : 	}
; 7241 : 
; 7242 : 	else

	jmp	SHORT $LN51@ExecuteMov
$LN6@ExecuteMov:

; 7243 : 	{
; 7244 : 		pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY(), MOVE_UNITS_IGNORE_DANGER);

	movsx	eax, WORD PTR [ecx+2]
	movsx	ecx, WORD PTR [ecx]
	mov	esi, DWORD PTR _pUnit$[esp+16]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	8
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
$LN51@ExecuteMov:
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 7245 : 		if(!bSaveMoves)

	cmp	BYTE PTR _bSaveMoves$[esp+16], 0
	jne	SHORT $LN1@ExecuteMov

; 7246 : 		{
; 7247 : 			pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$[esp+16]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN1@ExecuteMov:

; 7248 : 		}
; 7249 : 	}
; 7250 : 
; 7251 : 	UnitProcessed(pUnit->GetID(), pUnit->IsCombatUnit());

	mov	eax, DWORD PTR _pUnit$[esp+16]
	mov	ecx, DWORD PTR [eax+100]
	cmp	DWORD PTR [eax+1044], 0
	setg	al
	movzx	edx, al
	push	edx
	push	ecx
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 7252 : }

	mov	ecx, DWORD PTR _pUnit$[esp+16]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	test	ecx, ecx
	je	SHORT $LN47@ExecuteMov
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN47@ExecuteMov:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ENDP ; CvTacticalAI::ExecuteMoveToPlot
PUBLIC	?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::ExecuteMoveOfBlockingUnit
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$3
__ehfuncinfo$?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
$T268784 = -72						; size = 4
_this$ = -72						; size = 4
_strLogString$224036 = -68				; size = 28
_strTemp$224035 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_pBlockingUnit$ = 8					; size = 8
?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvTacticalAI::ExecuteMoveOfBlockingUnit, COMDAT
; _this$ = ecx

; 7256 : {

	push	-1
	push	__ehhandler$?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+88], edi

; 7257 : 	if(!pBlockingUnit->canMove() || IsInQueuedAttack(pBlockingUnit.pointer()))

	mov	ecx, DWORD PTR _pBlockingUnit$[esp+84]
	xor	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+96], ebp
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	mov	esi, DWORD PTR _pBlockingUnit$[esp+84]
	test	al, al
	je	$LN8@ExecuteMov@2
	push	esi
	mov	ecx, edi
	call	?IsInQueuedAttack@CvTacticalAI@@QAE_NPBVCvUnit@@@Z ; CvTacticalAI::IsInQueuedAttack
	test	al, al
	jne	$LN8@ExecuteMov@2

; 7260 : 	}
; 7261 : 
; 7262 : 	CvPlot* pOldPlot = pBlockingUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 7263 : 
; 7264 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	edi, DWORD PTR _pBlockingUnit$[esp+84]
	mov	ebx, eax
	npad	6
$LL7@ExecuteMov@2:

; 7265 : 	{
; 7266 : 		CvPlot* pPlot = plotDirection(pBlockingUnit->getX(), pBlockingUnit->getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	ebp
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 7267 : 		if(pPlot != NULL)

	test	esi, esi
	je	SHORT $LN6@ExecuteMov@2

; 7268 : 		{
; 7269 : 			// Don't embark for one of these moves
; 7270 : 			if (!pOldPlot->isWater() && pPlot->isWater() && pBlockingUnit->getDomainType() == DOMAIN_LAND)

	cmp	BYTE PTR [ebx+5], 3
	je	SHORT $LN3@ExecuteMov@2
	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN3@ExecuteMov@2
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	je	SHORT $LN105@ExecuteMov@2
$LN3@ExecuteMov@2:

; 7271 : 			{
; 7272 : 				continue;
; 7273 : 			}
; 7274 : 
; 7275 : 			// Has to be somewhere we can move and be empty of other units/enemy cities
; 7276 : 			if(!pPlot->getVisibleEnemyDefender(m_pPlayer->GetID()) && !pPlot->isEnemyCity(*pBlockingUnit.pointer()) && pBlockingUnit->GeneratePath(pPlot))

	mov	edi, DWORD PTR _this$[esp+88]
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, esi
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	test	eax, eax
	jne	SHORT $LN105@ExecuteMov@2
	mov	ecx, DWORD PTR _pBlockingUnit$[esp+84]
	push	ecx
	mov	ecx, esi
	call	?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z	; CvPlot::isEnemyCity
	test	al, al
	jne	SHORT $LN105@ExecuteMov@2
	mov	ecx, DWORD PTR _pBlockingUnit$[esp+84]
	push	0
	push	0
	push	0
	push	esi
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	jne	SHORT $LN103@ExecuteMov@2
$LN105@ExecuteMov@2:
	mov	edi, DWORD PTR _pBlockingUnit$[esp+84]
$LN6@ExecuteMov@2:

; 7263 : 
; 7264 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL7@ExecuteMov@2

; 7287 : 			}
; 7288 : 		}
; 7289 : 	}
; 7290 : 	return false;

	mov	DWORD PTR __$EHRec$[esp+96], -1
	test	edi, edi
	je	$LN23@ExecuteMov@2
	mov	ecx, edi
	jmp	$LN107@ExecuteMov@2
$LN103@ExecuteMov@2:

; 7277 : 			{
; 7278 : 				ExecuteMoveToPlot(pBlockingUnit, pPlot);

	mov	edx, DWORD PTR _pBlockingUnit$[esp+84]
	push	0
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	cl, BYTE PTR _pBlockingUnit$[esp+104]
	mov	BYTE PTR [eax+4], cl
	mov	eax, edx
	mov	DWORD PTR $T268784[esp+104], esp
	test	eax, eax
	je	SHORT $LN56@ExecuteMov@2
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN56@ExecuteMov@2:
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 7279 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteMov@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteMov@2

; 7280 : 				{
; 7281 : 					CvString strTemp, strLogString;

	lea	ecx, DWORD PTR _strTemp$224035[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$224036[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7282 : 					strTemp = pBlockingUnit->getUnitInfo().GetDescription();

	mov	ecx, DWORD PTR _pBlockingUnit$[esp+84]
	mov	BYTE PTR __$EHRec$[esp+96], 2
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$224035[esp+92]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 7283 : 					strLogString.Format("Moving blocking %s out of way, Leaving X: %d, Y: %d, Now At X: %d, Y: %d", strTemp.GetCString(), pOldPlot->getX(), pOldPlot->getY(), pBlockingUnit->getX(), pBlockingUnit->getY());

	mov	eax, DWORD PTR _pBlockingUnit$[esp+84]
	mov	ecx, DWORD PTR [eax+88]
	mov	eax, DWORD PTR [eax+76]
	movsx	edx, WORD PTR [ebx+2]
	movsx	esi, WORD PTR [ebx]
	push	ecx
	push	eax
	push	edx
	push	esi
	lea	ecx, DWORD PTR _strTemp$224035[esp+104]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$224036[esp+108]
	push	OFFSET $SG224037
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 7284 : 					LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$224036[esp+92]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7285 : 				}

	lea	ecx, DWORD PTR _strLogString$224036[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$224035[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteMov@2:

; 7286 : 				return true;

	mov	ecx, DWORD PTR _pBlockingUnit$[esp+84]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	test	ecx, ecx
	je	SHORT $LN95@ExecuteMov@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN95@ExecuteMov@2:
	mov	al, 1

; 7291 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 72					; 00000048H
	ret	8
$LN8@ExecuteMov@2:

; 7258 : 	{
; 7259 : 		return false;

	mov	DWORD PTR __$EHRec$[esp+96], -1
	cmp	esi, ebp
	je	SHORT $LN23@ExecuteMov@2
	mov	ecx, esi
$LN107@ExecuteMov@2:
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@ExecuteMov@2:

; 7291 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 72					; 00000048H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pBlockingUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$224035[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$3:
	lea	ecx, DWORD PTR _strLogString$224036[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvTacticalAI::ExecuteMoveOfBlockingUnit
PUBLIC	?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteNavalBlockadeMove
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0
__ehfuncinfo$?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pUnit$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z PROC ; CvTacticalAI::ExecuteNavalBlockadeMove, COMDAT
; _this$ = ecx

; 7295 : {

	push	-1
	push	__ehhandler$?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 7296 : 	// Move first one to target
; 7297 : 	UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$[esp+28], esi
	mov	BYTE PTR _pUnit$[esp+32], 0
	test	esi, esi
	je	SHORT $LN12@ExecuteNav
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@ExecuteNav:
	mov	DWORD PTR __$EHRec$[esp+36], 0

; 7298 : 	if(pUnit)

	test	esi, esi
	je	SHORT $LN1@ExecuteNav

; 7299 : 	{
; 7300 : 		pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	mov	eax, DWORD PTR _pTarget$[esp+24]
	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 7301 : 		pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 7302 : 		UnitProcessed(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	push	1
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 7303 : 		pUnit->SetTacticalAIPlot(NULL);

	push	0
	mov	ecx, esi
	call	?SetTacticalAIPlot@CvUnit@@QAEXPAVCvPlot@@@Z ; CvUnit::SetTacticalAIPlot
$LN1@ExecuteNav:

; 7304 : 	}
; 7305 : }

	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	esi, esi
	je	SHORT $LN33@ExecuteNav
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN33@ExecuteNav:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z ENDP ; CvTacticalAI::ExecuteNavalBlockadeMove
PUBLIC	?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteMoveToTarget
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z$1
__ehfuncinfo$?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pUnit$224218 = -20					; size = 8
_pUnit$224207 = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z PROC ; CvTacticalAI::ExecuteMoveToTarget, COMDAT
; _this$ = ecx

; 7309 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 7310 : 	std::vector<CvTacticalUnit>::iterator it;
; 7311 : 
; 7312 : 	// Start with high priority list
; 7313 : 	for(it = m_CurrentMoveHighPriorityUnits.begin(); it != m_CurrentMoveHighPriorityUnits.end(); ++it)

	mov	ebx, DWORD PTR _pTarget$[esp+20]
	push	ebp
	push	esi
	mov	esi, ecx
	mov	ebp, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+44]
	push	edi
	cmp	ebp, eax
	je	$LN11@ExecuteMov@3
$LL30@ExecuteMov@3:

; 7314 : 	{
; 7315 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$224207[esp+36], edi
	mov	BYTE PTR _pUnit$224207[esp+40], 0
	test	edi, edi
	je	SHORT $LN53@ExecuteMov@3
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@ExecuteMov@3:

; 7316 : 
; 7317 : 		// Don't move high priority unit if regular priority unit is closer
; 7318 : 		if(m_CurrentMoveUnits.size() > 0 && m_CurrentMoveUnits.begin()->GetMovesToTarget() < it->GetMovesToTarget())

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __$EHRec$[esp+44], 0
	je	SHORT $LN10@ExecuteMov@3
	mov	eax, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+12]
	cmp	eax, DWORD PTR [ebp+12]
	jl	$LN237@ExecuteMov@3
$LN10@ExecuteMov@3:

; 7321 : 		}
; 7322 : 
; 7323 : 		if(pUnit->plot() == pTarget && pUnit->canFortify(pUnit->plot()))

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	jne	SHORT $LN9@ExecuteMov@3
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canFortify
	test	al, al
	jne	$LN238@ExecuteMov@3
$LN9@ExecuteMov@3:

; 7329 : 		}
; 7330 : 
; 7331 : 		else if(pUnit && it->GetMovesToTarget() < MAX_INT)

	test	edi, edi
	je	SHORT $LN7@ExecuteMov@3
	cmp	DWORD PTR [ebp+12], 2147483647		; 7fffffffH
	jl	$LN241@ExecuteMov@3
$LN7@ExecuteMov@3:

; 7332 : 		{
; 7333 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());
; 7334 : 			pUnit->finishMoves();
; 7335 : 			UnitProcessed(it->GetID());
; 7336 : 			return;
; 7337 : 		}
; 7338 : 	}

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	edi, edi
	je	SHORT $LN12@ExecuteMov@3
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@ExecuteMov@3:
	add	ebp, 24					; 00000018H
	cmp	ebp, DWORD PTR [esi+44]
	jne	$LL30@ExecuteMov@3
$LN11@ExecuteMov@3:

; 7339 : 
; 7340 : 	// Then regular priority
; 7341 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	ebp, DWORD PTR [esi+24]
	cmp	ebp, DWORD PTR [esi+28]
	je	$LN228@ExecuteMov@3
	npad	1
$LL151@ExecuteMov@3:

; 7342 : 	{
; 7343 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$224218[esp+36], edi
	mov	BYTE PTR _pUnit$224218[esp+40], 0
	test	edi, edi
	je	SHORT $LN174@ExecuteMov@3
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN174@ExecuteMov@3:

; 7344 : 
; 7345 : 		if(pUnit->plot() == pTarget && pUnit->canFortify(pUnit->plot()))

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+44], 1
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	jne	SHORT $LN3@ExecuteMov@3
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canFortify
	test	al, al
	jne	SHORT $LN238@ExecuteMov@3
$LN3@ExecuteMov@3:

; 7346 : 		{
; 7347 : 			pUnit->PushMission(CvTypes::getMISSION_FORTIFY());
; 7348 : 			pUnit->SetFortifiedThisTurn(true);
; 7349 : 			UnitProcessed(it->GetID());
; 7350 : 			return;
; 7351 : 		}
; 7352 : 
; 7353 : 		else if(pUnit && it->GetMovesToTarget() < MAX_INT)

	test	edi, edi
	je	SHORT $LN1@ExecuteMov@3
	cmp	DWORD PTR [ebp+12], 2147483647		; 7fffffffH
	jl	$LN241@ExecuteMov@3
$LN1@ExecuteMov@3:

; 7359 : 		}
; 7360 : 	}

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	edi, edi
	je	SHORT $LN5@ExecuteMov@3
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@ExecuteMov@3:
	add	ebp, 24					; 00000018H
	cmp	ebp, DWORD PTR [esi+28]
	jne	SHORT $LL151@ExecuteMov@3
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7361 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
$LN237@ExecuteMov@3:

; 7319 : 		{
; 7320 : 			break;

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	edi, edi
	je	$LN11@ExecuteMov@3
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	$LN11@ExecuteMov@3
$LN238@ExecuteMov@3:

; 7324 : 		{
; 7325 : 			pUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 7326 : 			pUnit->SetFortifiedThisTurn(true);

	push	1
	mov	ecx, edi
	call	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z	; CvUnit::SetFortifiedThisTurn

; 7327 : 			UnitProcessed(it->GetID());

	mov	ebp, DWORD PTR [ebp]
	push	1
	push	ebp
	mov	ecx, esi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 7328 : 			return;

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	edi, edi
	je	SHORT $LN228@ExecuteMov@3
	jmp	SHORT $LN245@ExecuteMov@3
$LN241@ExecuteMov@3:

; 7354 : 		{
; 7355 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 7356 : 			pUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 7357 : 			UnitProcessed(it->GetID());

	mov	ebp, DWORD PTR [ebp]
	push	1
	push	ebp
	mov	ecx, esi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 7358 : 			return;

	mov	DWORD PTR __$EHRec$[esp+44], -1
$LN245@ExecuteMov@3:
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN228@ExecuteMov@3:

; 7361 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$224207[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR _pUnit$224218[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z ENDP ; CvTacticalAI::ExecuteMoveToTarget
PUBLIC	?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::ExecuteAirInterceptMoves
EXTRN	?getMISSION_AIRPATROL@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_AIRPATROL
EXTRN	?canAirPatrol@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canAirPatrol
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ$1
__ehfuncinfo$?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_iI$224225 = -36					; size = 4
$T269718 = -32						; size = 4
_pUnit$269712 = -28					; size = 8
_pUnit$224229 = -20					; size = 8
__$EHRec$ = -12						; size = 12
?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::ExecuteAirInterceptMoves, COMDAT
; _this$ = ecx

; 7365 : {

	push	-1
	push	__ehhandler$?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	esi, ecx

; 7366 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	xor	ebx, ebx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iI$224225[esp+44], ebx
	je	$LN3@ExecuteAir
	push	ebp
	push	edi
$LL90@ExecuteAir:

; 7367 : 	{
; 7368 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebp, eax
	mov	DWORD PTR _pUnit$224229[esp+52], ebp
	mov	BYTE PTR _pUnit$224229[esp+56], 0
	test	ebp, ebp
	je	SHORT $LN18@ExecuteAir
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN18@ExecuteAir:
	mov	DWORD PTR __$EHRec$[esp+60], 0

; 7369 : 		if(pUnit)

	test	ebp, ebp
	je	$LN89@ExecuteAir

; 7370 : 		{
; 7371 : 			if(pUnit->canAirPatrol(NULL))

	push	0
	mov	ecx, ebp
	call	?canAirPatrol@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canAirPatrol
	test	al, al
	je	SHORT $LN89@ExecuteAir

; 7372 : 			{
; 7373 : 				pUnit->PushMission(CvTypes::getMISSION_AIRPATROL());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_AIRPATROL@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_AIRPATROL
	push	eax
	mov	ecx, ebp
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 7374 : 				UnitProcessed(m_CurrentMoveUnits[iI].GetID(), false /*bMarkTacticalMap*/);

	mov	ecx, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [ebx+ecx]
	mov	DWORD PTR $T269718[esp+52], edi
	mov	DWORD PTR _pUnit$269712[esp+52], 0
	mov	BYTE PTR _pUnit$269712[esp+56], 0
	lea	edx, DWORD PTR $T269718[esp+52]
	push	edx
	lea	ecx, DWORD PTR [esi+8]
	mov	BYTE PTR __$EHRec$[esp+64], 1
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$269712[esp+52], edi
	test	edi, edi
	je	SHORT $LN43@ExecuteAir
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN43@ExecuteAir:
	push	1
	mov	ecx, edi
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
	mov	BYTE PTR __$EHRec$[esp+60], 0
	test	edi, edi
	je	SHORT $LN89@ExecuteAir
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN89@ExecuteAir:

; 7375 : 			}
; 7376 : 		}
; 7377 : 	}

	mov	DWORD PTR __$EHRec$[esp+60], -1
	test	ebp, ebp
	je	SHORT $LN4@ExecuteAir
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@ExecuteAir:
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	edi, DWORD PTR _iI$224225[esp+52]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	edi
	add	eax, edx
	add	ebx, 24					; 00000018H
	mov	DWORD PTR _iI$224225[esp+52], edi
	cmp	edi, eax
	jb	$LL90@ExecuteAir
	pop	edi
	pop	ebp
$LN3@ExecuteAir:

; 7378 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 36					; 00000024H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$224229[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$269712[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::ExecuteAirInterceptMoves
PUBLIC	?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::ExecuteAirSweepMoves
EXTRN	?getMISSION_AIR_SWEEP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_AIR_SWEEP
EXTRN	?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z:PROC ; CvMilitaryAI::GetBestAirSweepTarget
EXTRN	?canAirSweep@CvUnit@@QBE_NXZ:PROC		; CvUnit::canAirSweep
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_pUnit$224239 = -20					; size = 8
__$EHRec$ = -12						; size = 12
?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::ExecuteAirSweepMoves, COMDAT
; _this$ = ecx

; 7382 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 7383 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	ebx, ebx
	add	eax, edx
	je	$LN4@ExecuteAir@2
	push	ebp
	push	edi
	xor	ebp, ebp
	npad	1
$LL6@ExecuteAir@2:

; 7384 : 	{
; 7385 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebp
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$224239[esp+36], edi
	mov	BYTE PTR _pUnit$224239[esp+40], 0
	test	edi, edi
	je	SHORT $LN19@ExecuteAir@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN19@ExecuteAir@2:
	mov	DWORD PTR __$EHRec$[esp+44], 0

; 7386 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN44@ExecuteAir@2

; 7387 : 		{
; 7388 : 			if(pUnit->canAirSweep())

	mov	ecx, edi
	call	?canAirSweep@CvUnit@@QBE_NXZ		; CvUnit::canAirSweep
	test	al, al
	je	SHORT $LN44@ExecuteAir@2

; 7389 : 			{
; 7390 : 				CvPlot *pTarget = m_pPlayer->GetMilitaryAI()->GetBestAirSweepTarget(pUnit.pointer());

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z ; CvMilitaryAI::GetBestAirSweepTarget

; 7391 : 				if (pTarget)

	test	eax, eax
	je	SHORT $LN44@ExecuteAir@2

; 7392 : 				{
; 7393 : 					pUnit->PushMission(CvTypes::getMISSION_AIR_SWEEP(), pTarget->getX(), pTarget->getY());

	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	call	?getMISSION_AIR_SWEEP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_AIR_SWEEP
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 7394 : 					UnitProcessed(m_CurrentMoveUnits[iI].GetID(), false /*bMarkTacticalMap*/);

	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+ebp]
	push	0
	push	eax
	mov	ecx, esi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed
$LN44@ExecuteAir@2:

; 7395 : 				}
; 7396 : 			}
; 7397 : 		}
; 7398 : 	}

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	edi, edi
	je	SHORT $LN5@ExecuteAir@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@ExecuteAir@2:
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	add	ebp, 24					; 00000018H
	cmp	ebx, eax
	jb	$LL6@ExecuteAir@2
	pop	edi
	pop	ebp
$LN4@ExecuteAir@2:

; 7399 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$224239[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::ExecuteAirSweepMoves
PUBLIC	?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::ExecuteEscortEmbarkedMoves
EXTRN	?getName@CvUnit@@QBE?BVCvString@@XZ:PROC	; CvUnit::getName
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ$5
__ehfuncinfo$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
tv549 = -112						; size = 4
_iHighestDanger$224755 = -108				; size = 4
_pBestTarget$224754 = -104				; size = 4
_iI$224748 = -100					; size = 4
_iMovementRate$224756 = -96				; size = 4
_iLoop$224758 = -92					; size = 4
$T269816 = -88						; size = 4
$T269815 = -88						; size = 4
_pLoopUnit$224757 = -84					; size = 8
_pUnit$224752 = -76					; size = 8
_strLogString$224779 = -68				; size = 28
$T269817 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::ExecuteEscortEmbarkedMoves, COMDAT
; _this$ = ecx

; 8634 : {

	push	-1
	push	__ehhandler$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	ebp
	mov	ebp, ecx

; 8635 : #ifdef AUI_ITERATORIZE
; 8636 : 	for (std::vector<CvTacticalUnit>::iterator it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)
; 8637 : 	{
; 8638 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());
; 8639 : #else
; 8640 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	xor	ebx, ebx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	esi
	push	edi
	mov	DWORD PTR _iI$224748[esp+128], ebx
	je	$LN18@ExecuteEsc
	mov	DWORD PTR tv549[esp+128], ebx
$LL20@ExecuteEsc:

; 8641 : 	{
; 8642 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [ebp+24]
	add	eax, DWORD PTR tv549[esp+128]
	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$224752[esp+128], esi
	mov	BYTE PTR _pUnit$224752[esp+132], 0
	cmp	esi, ebx
	je	SHORT $LN38@ExecuteEsc
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN38@ExecuteEsc:
	mov	DWORD PTR __$EHRec$[esp+136], ebx

; 8643 : #endif
; 8644 : 		if(pUnit)

	cmp	esi, ebx
	je	$LN146@ExecuteEsc

; 8645 : 		{
; 8646 : 			CvPlot *pBestTarget = NULL;
; 8647 : 			int iHighestDanger = -1;
; 8648 : 			int iMovementRate = pUnit->getMoves() / GC.getMOVE_DENOMINATOR();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	ecx, esi
	mov	DWORD PTR _pBestTarget$224754[esp+128], ebx
	mov	DWORD PTR _iHighestDanger$224755[esp+128], -1
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	cdq
	idiv	edi

; 8649 : 
; 8650 : 			// Loop through all my embarked units that are: alone, have already moved this turn, within range
; 8651 : 			UnitHandle pLoopUnit;

	mov	DWORD PTR _pLoopUnit$224757[esp+128], ebx
	mov	BYTE PTR _pLoopUnit$224757[esp+132], 0
	mov	DWORD PTR _iMovementRate$224756[esp+128], eax

; 8652 : 			int iLoop;
; 8653 : 			for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	push	ebx
	lea	ecx, DWORD PTR _iLoop$224758[esp+132]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	mov	BYTE PTR __$EHRec$[esp+144], 1
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	edi, eax
	mov	DWORD PTR _pLoopUnit$224757[esp+128], edi
	cmp	eax, ebx
	je	$LN1@ExecuteEsc
	mov	ecx, eax
$LN167@ExecuteEsc:
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 8654 : 			{
; 8655 : 				if (pLoopUnit->getDomainType() != DOMAIN_LAND)

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	$LN15@ExecuteEsc

; 8656 : 				{
; 8657 : 					continue;
; 8658 : 				}
; 8659 : 				else if (!pLoopUnit->isEmbarked())

	cmp	BYTE PTR [edi+1652], 0
	je	$LN15@ExecuteEsc

; 8660 : 				{
; 8661 : 					continue;
; 8662 : 				}
; 8663 : 				else if (pLoopUnit->plot()->getNumUnits() > 1)

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	eax, 1
	jg	SHORT $LN15@ExecuteEsc

; 8664 : 				{
; 8665 : 					continue;
; 8666 : 				}
; 8667 : 				else if (pLoopUnit->canMove())

	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	jne	SHORT $LN15@ExecuteEsc

; 8668 : 				{
; 8669 : 					continue;
; 8670 : 				}
; 8671 : 				else if (plotDistance(pUnit->getX(), pUnit->getY(), pLoopUnit->getX(), pLoopUnit->getY()) > iMovementRate)

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	mov	edx, DWORD PTR [esi+88]
	mov	ebx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	push	edx
	push	ebx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iMovementRate$224756[esp+128]
	jg	SHORT $LN15@ExecuteEsc

; 8672 : 				{
; 8673 : 					continue;
; 8674 : 				}
; 8675 : 
; 8676 : 				// Can this unit get to the embarked unit in one move?
; 8677 : 				CvPlot *pTarget = pLoopUnit->plot();

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 8678 : 				if (TurnsToReachTarget(pUnit, pTarget) <= 1)

	push	0
	push	0
	mov	ebx, eax
	push	0
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T269815[esp+152], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jg	SHORT $LN15@ExecuteEsc

; 8679 : 				{
; 8680 : 					int iDanger = m_pPlayer->GetPlotDanger(*pTarget);

	mov	ecx, DWORD PTR [ebp]
	push	ebx
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger

; 8681 : 					if (iDanger > iHighestDanger)

	cmp	eax, DWORD PTR _iHighestDanger$224755[esp+128]
	jle	SHORT $LN15@ExecuteEsc

; 8682 : 					{
; 8683 : 						iHighestDanger = iDanger;

	mov	DWORD PTR _iHighestDanger$224755[esp+128], eax

; 8684 : 						pBestTarget = pTarget;

	mov	DWORD PTR _pBestTarget$224754[esp+128], ebx
$LN15@ExecuteEsc:
	mov	ecx, DWORD PTR [ebp]
	push	0
	lea	edx, DWORD PTR _iLoop$224758[esp+132]
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	ebx, eax
	test	edi, edi
	je	SHORT $LN60@ExecuteEsc
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN60@ExecuteEsc:
	mov	edi, ebx
	mov	DWORD PTR _pLoopUnit$224757[esp+128], edi
	test	ebx, ebx
	je	SHORT $LN157@ExecuteEsc

; 8652 : 			int iLoop;
; 8653 : 			for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	mov	ecx, ebx
	jmp	$LN167@ExecuteEsc
$LN157@ExecuteEsc:

; 8685 : 					}
; 8686 : 				}
; 8687 : 			}
; 8688 : 
; 8689 : 			if (pBestTarget)

	mov	eax, DWORD PTR _pBestTarget$224754[esp+128]
	test	eax, eax
	je	$LN1@ExecuteEsc

; 8690 : 			{
; 8691 : 				ExecuteMoveToPlot(pUnit, pBestTarget);

	push	0
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T269816[esp+144], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, ebp
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 8692 : #ifdef AUI_ITERATORIZE
; 8693 : 				UnitProcessed(it->GetID());
; 8694 : #else
; 8695 : 				UnitProcessed(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR tv549[esp+128]
	mov	eax, DWORD PTR [ecx+eax]
	push	1
	push	eax
	mov	ecx, ebp
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 8696 : #endif
; 8697 : 
; 8698 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteEsc
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteEsc

; 8699 : 				{
; 8700 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$224779[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 8701 : 					strLogString.Format("%s escorted embarked unit at, Current X: %d, Current Y: %d", pUnit->getName().GetCString(), pUnit->getX(), pUnit->getY());

	lea	edx, DWORD PTR $T269817[esp+128]
	push	edx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+140], 2
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+88]
	mov	edx, DWORD PTR [esi+76]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+144], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$224779[esp+140]
	push	OFFSET $SG224781
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T269817[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 8702 : 					LogTacticalMessage(strLogString, false);

	push	0
	lea	ecx, DWORD PTR _strLogString$224779[esp+132]
	push	ecx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 8703 : 				}

	lea	ecx, DWORD PTR _strLogString$224779[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteEsc:

; 8704 : 			}
; 8705 : 		}

	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+136], 0
	cmp	edi, ebx
	je	SHORT $LN146@ExecuteEsc
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN146@ExecuteEsc:

; 8706 : 	}

	mov	DWORD PTR __$EHRec$[esp+136], -1
	cmp	esi, ebx
	je	SHORT $LN19@ExecuteEsc
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN19@ExecuteEsc:
	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	esi, DWORD PTR _iI$224748[esp+128]
	add	DWORD PTR tv549[esp+128], 24		; 00000018H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	esi
	add	eax, edx
	mov	DWORD PTR _iI$224748[esp+128], esi
	cmp	esi, eax
	jb	$LL20@ExecuteEsc
$LN18@ExecuteEsc:

; 8707 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+128]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 112				; 00000070H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$224752[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pLoopUnit$224757[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$224779[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR $T269817[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::ExecuteEscortEmbarkedMoves
PUBLIC	?AssignFlankingUnits@CvTacticalAI@@AAE_NH@Z	; CvTacticalAI::AssignFlankingUnits
; Function compile flags: /Ogtpy
;	COMDAT ?AssignFlankingUnits@CvTacticalAI@@AAE_NH@Z
_TEXT	SEGMENT
_iNumUnitsRequiredToFlank$ = 8				; size = 4
?AssignFlankingUnits@CvTacticalAI@@AAE_NH@Z PROC	; CvTacticalAI::AssignFlankingUnits, COMDAT
; _this$ = ecx

; 10268: 	m_TemporaryBlocks.clear();

	xor	eax, eax
	mov	DWORD PTR [ecx+27016], eax

; 10269: 	m_ChosenBlocks.clear();

	mov	DWORD PTR [ecx+27432], eax

; 10270: 
; 10271: 	return ChooseRemainingAssignments(iNumUnitsRequiredToFlank, 2/*iNumUnitsAcceptable*/);

	mov	eax, DWORD PTR _iNumUnitsRequiredToFlank$[esp-4]
	push	2
	push	eax
	call	?ChooseRemainingAssignments@CvTacticalAI@@AAE_NHH@Z ; CvTacticalAI::ChooseRemainingAssignments

; 10272: }

	ret	4
?AssignFlankingUnits@CvTacticalAI@@AAE_NH@Z ENDP	; CvTacticalAI::AssignFlankingUnits
_TEXT	ENDS
PUBLIC	?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ; CvTacticalAI::MoveGreatGeneral
EXTRN	?maxMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::maxMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$5
__ehfuncinfo$?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_this$ = -116						; size = 4
tv638 = -112						; size = 4
tv623 = -108						; size = 4
_iRange$ = -104						; size = 4
_iBestScore$225781 = -100				; size = 4
_pBestPlot$225780 = -96					; size = 4
_iI$225776 = -92					; size = 4
tv442 = -88						; size = 4
tv648 = -84						; size = 4
$T270128 = -80						; size = 4
$T270127 = -80						; size = 4
$T270126 = -80						; size = 4
_pGeneral$ = -76					; size = 8
_strMsg$225805 = -68					; size = 28
$T270129 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pArmyAI$ = 8						; size = 4
?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z PROC ; CvTacticalAI::MoveGreatGeneral, COMDAT
; _this$ = ecx

; 10656: {

	push	-1
	push	__ehhandler$?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx
	push	edi

; 10657: 	UnitHandle pGeneral;

	xor	ecx, ecx
	xor	edi, edi
	mov	DWORD PTR _this$[esp+132], ebp
	mov	DWORD PTR _pGeneral$[esp+132], edi
	mov	BYTE PTR _pGeneral$[esp+136], cl

; 10658: 	int iRange;
; 10659: 
; 10660: #ifdef AUI_ITERATORIZE
; 10661: 	for (FStaticVector<CvOperationUnit, SAFE_ESTIMATE_NUM_MULTIUNITFORMATION_ENTRIES, true, c_eCiv5GameplayDLL, 0>::iterator it = m_GeneralsToMove.begin(); it != m_GeneralsToMove.end(); ++it)
; 10662: 	{
; 10663: 		CvPlot* pBestPlot = NULL;
; 10664: 		int iBestScore = -1;
; 10665: 		pGeneral = m_pPlayer->getUnit(it->GetUnitID());
; 10666: #else
; 10667: 	for (unsigned int iI = 0; iI < m_GeneralsToMove.size(); iI++)

	mov	eax, DWORD PTR [ebp+28824]
	mov	DWORD PTR __$EHRec$[esp+140], ecx
	mov	DWORD PTR _iI$225776[esp+132], ecx
	cmp	eax, ecx
	jbe	$LN15@MoveGreatG
	npad	9
$LL17@MoveGreatG:
	mov	eax, DWORD PTR [ebp+28820]
	lea	eax, DWORD PTR [eax+ecx*8]

; 10668: 	{
; 10669: 		CvPlot* pBestPlot = NULL;
; 10670: 		int iBestScore = -1;
; 10671: 		pGeneral = m_pPlayer->getUnit(m_GeneralsToMove[iI].GetUnitID());

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	mov	DWORD PTR _pBestPlot$225780[esp+136], 0
	mov	DWORD PTR _iBestScore$225781[esp+136], -1
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	test	edi, edi
	je	SHORT $LN38@MoveGreatG
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN38@MoveGreatG:
	mov	DWORD PTR _pGeneral$[esp+132], esi
	test	esi, esi
	je	$LN16@MoveGreatG
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 10672: #endif
; 10673: 
; 10674: 		if(pGeneral)
; 10675: 		{
; 10676: 			iRange = (pGeneral->maxMoves() * 3) / GC.getMOVE_DENOMINATOR();  // Enough to make a decent road move

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	ecx, esi
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	lea	eax, DWORD PTR [eax+eax*2]
	cdq
	idiv	edi

; 10677: #ifdef AUI_HEXSPACE_DX_LOOPS
; 10678: 			int iMaxDX, iX;
; 10679: 			CvPlot* pEvalPlot;
; 10680: 			for (int iY = -iRange; iY <= iRange; iY++)
; 10681: 			{
; 10682: 				iMaxDX = iRange - MAX(0, iY);
; 10683: 				for (iX = -iRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 10684: 				{
; 10685: 					pEvalPlot = plotXY(pGeneral->getX(), pGeneral->getY(), iX, iY);
; 10686: #else
; 10687: 			for(int iX = -iRange; iX <= iRange; iX++)

	mov	ecx, eax
	neg	ecx
	mov	ebx, ecx
	cmp	ebx, eax
	mov	DWORD PTR _iRange$[esp+132], eax
	mov	DWORD PTR tv648[esp+132], ecx
	jg	$LN16@MoveGreatG
	mov	edx, ebx
	neg	edx
	mov	DWORD PTR tv638[esp+132], edx
$LL13@MoveGreatG:

; 10688: 			{
; 10689: 				for(int iY = -iRange; iY <= iRange; iY++)

	mov	ebp, ecx
	cmp	ebp, eax
	jg	$LN12@MoveGreatG

; 10690: 				{
; 10691: 					CvPlot* pEvalPlot = NULL;
; 10692: 					pEvalPlot = plotXYWithRangeCheck(pGeneral->getX(), pGeneral->getY(), iX, iY, iRange);

	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	mov	edx, ebp
	neg	edx
	mov	DWORD PTR tv623[esp+132], edx
	mov	DWORD PTR tv442[esp+132], ecx
$LN10@MoveGreatG:
	mov	edi, DWORD PTR [esi+88]
	xor	eax, eax
	test	ebp, ebp
	setge	al
	mov	ecx, ebx
	cmp	DWORD PTR tv442[esp+132], eax
	jne	SHORT $LN62@MoveGreatG
	test	ebx, ebx
	jge	SHORT $LN66@MoveGreatG
	mov	ecx, DWORD PTR tv638[esp+132]
$LN66@MoveGreatG:
	mov	eax, ebp
	test	ebp, ebp
	jge	SHORT $LN68@MoveGreatG
	mov	eax, edx
$LN68@MoveGreatG:
	add	eax, ecx
	jmp	SHORT $LN73@MoveGreatG
$LN62@MoveGreatG:
	test	ebx, ebx
	jge	SHORT $LN70@MoveGreatG
	mov	ecx, DWORD PTR tv638[esp+132]
$LN70@MoveGreatG:
	mov	eax, ebp
	test	ebp, ebp
	jge	SHORT $LN72@MoveGreatG
	mov	eax, edx
$LN72@MoveGreatG:
	cmp	ecx, eax
	jl	SHORT $LN73@MoveGreatG
	mov	eax, ecx
$LN73@MoveGreatG:
	cmp	eax, DWORD PTR _iRange$[esp+132]
	jg	SHORT $LN9@MoveGreatG
	mov	eax, DWORD PTR [esi+76]
	push	ebp
	push	ebx
	push	edi
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	edi, eax
	add	esp, 16					; 00000010H

; 10693: #endif
; 10694: 					if(!pEvalPlot)

	test	edi, edi
	je	SHORT $LN139@MoveGreatG

; 10695: 					{
; 10696: 						continue;
; 10697: 					}
; 10698: 
; 10699: 					if(CanReachInXTurns(pGeneral, pEvalPlot, 1))

	push	0
	push	0
	push	1
	push	edi
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T270126[esp+156], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	test	al, al
	je	SHORT $LN139@MoveGreatG

; 10700: 					{
; 10701: 						int iScore = ScoreGreatGeneralPlot(pGeneral, pEvalPlot, pArmyAI);

	mov	ecx, DWORD PTR _pArmyAI$[esp+128]
	push	ecx
	push	edi
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T270127[esp+148], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, DWORD PTR _this$[esp+148]
	call	?ScoreGreatGeneralPlot@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@PAVCvArmyAI@@@Z ; CvTacticalAI::ScoreGreatGeneralPlot

; 10702: 
; 10703: 						if(iScore > iBestScore && iScore > 0)

	cmp	eax, DWORD PTR _iBestScore$225781[esp+132]
	jle	SHORT $LN139@MoveGreatG
	test	eax, eax
	jle	SHORT $LN139@MoveGreatG

; 10704: 						{
; 10705: 							iBestScore = iScore;

	mov	DWORD PTR _iBestScore$225781[esp+132], eax

; 10706: 							pBestPlot = pEvalPlot;

	mov	DWORD PTR _pBestPlot$225780[esp+132], edi
$LN139@MoveGreatG:
	mov	edx, DWORD PTR tv623[esp+132]
$LN9@MoveGreatG:

; 10688: 			{
; 10689: 				for(int iY = -iRange; iY <= iRange; iY++)

	inc	ebp
	dec	edx
	cmp	ebp, DWORD PTR _iRange$[esp+132]
	mov	DWORD PTR tv623[esp+132], edx
	jle	$LN10@MoveGreatG
	mov	ecx, DWORD PTR tv648[esp+132]
	mov	eax, DWORD PTR _iRange$[esp+132]
$LN12@MoveGreatG:
	dec	DWORD PTR tv638[esp+132]
	inc	ebx
	cmp	ebx, eax
	jle	$LL13@MoveGreatG

; 10707: 						}
; 10708: 					}
; 10709: 
; 10710: 				}
; 10711: 			}
; 10712: 
; 10713: 			if(pBestPlot != NULL)

	mov	edi, DWORD PTR _pBestPlot$225780[esp+132]
	test	edi, edi
	je	$LN140@MoveGreatG

; 10714: 			{
; 10715: 				ExecuteMoveToPlot(pGeneral, pBestPlot);

	push	0
	push	edi
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T270128[esp+148], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, DWORD PTR _this$[esp+148]
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 10716: 
; 10717: 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN140@MoveGreatG
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN140@MoveGreatG

; 10718: 				{
; 10719: 					int iDistToOperationCenter = -1;
; 10720: 
; 10721: 					if(pArmyAI)

	mov	ecx, DWORD PTR _pArmyAI$[esp+128]
	or	ebp, -1
	test	ecx, ecx
	je	SHORT $LN1@MoveGreatG

; 10722: 					{
; 10723: 						CvPlot* pCOM = pArmyAI->GetCenterOfMass(NO_DOMAIN);

	push	ebp
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass

; 10724: 						if(pCOM)

	test	eax, eax
	je	SHORT $LN1@MoveGreatG

; 10725: 						{
; 10726: 							iDistToOperationCenter = plotDistance(pBestPlot->getX(), pBestPlot->getY(), pCOM->getX(), pCOM->getY());

	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	movsx	ecx, WORD PTR [edi+2]
	push	edx
	movsx	edx, WORD PTR [edi]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	ebp, eax
$LN1@MoveGreatG:

; 10727: 						}
; 10728: 					}
; 10729: 
; 10730: 					CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$225805[esp+132]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10731: 					strMsg.Format("Deploying %s, To X: %d, To Y: %d, At X: %d, At Y: %d, Plot Score: %d, Dist from COM: %d",
; 10732: 					              pGeneral->getName().GetCString(), pBestPlot->getX(), pBestPlot->getY(),
; 10733: 					              pGeneral->getX(), pGeneral->getY(), iBestScore, iDistToOperationCenter);

	lea	eax, DWORD PTR $T270129[esp+132]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+144], 1
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+88]
	mov	ebx, DWORD PTR _iBestScore$225781[esp+132]
	movsx	edx, WORD PTR [edi+2]
	mov	esi, DWORD PTR [esi+76]
	movsx	edi, WORD PTR [edi]
	push	ebp
	push	ebx
	push	ecx
	push	esi
	push	edx
	push	edi
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+164], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMsg$225805[esp+160]
	push	OFFSET $SG225807
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 36					; 00000024H
	lea	ecx, DWORD PTR $T270129[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10734: 					LogTacticalMessage(strMsg);

	mov	ecx, DWORD PTR _this$[esp+132]
	push	1
	lea	edx, DWORD PTR _strMsg$225805[esp+136]
	push	edx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 10735: 				}

	lea	ecx, DWORD PTR _strMsg$225805[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN140@MoveGreatG:
	mov	ebp, DWORD PTR _this$[esp+132]
$LN16@MoveGreatG:

; 10658: 	int iRange;
; 10659: 
; 10660: #ifdef AUI_ITERATORIZE
; 10661: 	for (FStaticVector<CvOperationUnit, SAFE_ESTIMATE_NUM_MULTIUNITFORMATION_ENTRIES, true, c_eCiv5GameplayDLL, 0>::iterator it = m_GeneralsToMove.begin(); it != m_GeneralsToMove.end(); ++it)
; 10662: 	{
; 10663: 		CvPlot* pBestPlot = NULL;
; 10664: 		int iBestScore = -1;
; 10665: 		pGeneral = m_pPlayer->getUnit(it->GetUnitID());
; 10666: #else
; 10667: 	for (unsigned int iI = 0; iI < m_GeneralsToMove.size(); iI++)

	mov	ecx, DWORD PTR _iI$225776[esp+132]
	mov	edi, DWORD PTR _pGeneral$[esp+132]
	inc	ecx
	mov	DWORD PTR _iI$225776[esp+132], ecx
	cmp	ecx, DWORD PTR [ebp+28824]
	jb	$LL17@MoveGreatG
$LN15@MoveGreatG:

; 10736: 			}
; 10737: 		}
; 10738: 	}
; 10739: 
; 10740: 	return;

	mov	DWORD PTR __$EHRec$[esp+140], -1
	test	edi, edi
	je	SHORT $LN130@MoveGreatG
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN130@MoveGreatG:

; 10741: }

	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 116				; 00000074H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _pGeneral$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$4:
	lea	ecx, DWORD PTR _strMsg$225805[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$5:
	lea	ecx, DWORD PTR $T270129[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ENDP ; CvTacticalAI::MoveGreatGeneral
PUBLIC	?push_back@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEXABVCvQueuedAttack@@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?push_back@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEXABVCvQueuedAttack@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEXABVCvQueuedAttack@@@Z PROC ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::push_back, COMDAT
; _this$ = ecx

; 670  : 		_Insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@0ABVCvQueuedAttack@@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Buynode
	push	1
	mov	ecx, esi
	mov	ebx, eax
	call	?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Incsize
	mov	DWORD PTR [edi+4], ebx
	mov	edx, DWORD PTR [ebx+4]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], ebx
	pop	ebx

; 671  : 		}

	ret	4
?push_back@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAEXABVCvQueuedAttack@@@Z ENDP ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0@Z
_TEXT	SEGMENT
$T270464 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Cat$270469 = 12					; size = 1
$T270466 = 12						; size = 1
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0@Z PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[esp-4]

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [edi], eax
	cmp	eax, edx
	je	SHORT $LN26@erase@5

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [esi+8]
	push	ebx
	mov	BYTE PTR $T270464[esp+8], 0
	mov	ebx, DWORD PTR $T270464[esp+8]
	push	ebx
	mov	ebx, DWORD PTR __Cat$270469[esp+12]
	push	ebx
	mov	ebx, DWORD PTR $T270466[esp+16]
	push	ebx
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+8], eax
	pop	ebx
$LN26@erase@5:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, edi
	pop	edi
	pop	esi

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0@Z ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXXZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXXZ PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@6

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@6:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0@Z PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@6
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@6
	push	ebx
	npad	4
$LL28@erase@6:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], ebx
	add	edx, 12					; 0000000cH
	add	esi, 12					; 0000000cH
	cmp	edx, edi
	jne	SHORT $LL28@erase@6
	pop	ebx
$LN26@erase@6:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@6:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0@Z ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXXZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXXZ PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$227904 = 16					; size = 4
__Tmp$227894 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$227894[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$227894[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$227894[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ; std::fill<CvPlot * *,CvPlot *>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$227904[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ; std::fill<CvPlot * *,CvPlot *>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n
_TEXT	ENDS
PUBLIC	??$_Umove@PAVCvTacticalUnit@@@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEPAVCvTacticalUnit@@PAV2@00@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Umove<CvTacticalUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAVCvTacticalUnit@@@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEPAVCvTacticalUnit@@PAV2@00@Z
_TEXT	SEGMENT
$T270817 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$270820 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvTacticalUnit@@@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEPAVCvTacticalUnit@@PAV2@00@Z PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Umove<CvTacticalUnit *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$270820[esp]
	mov	BYTE PTR $T270817[esp+4], 0
	mov	eax, DWORD PTR $T270817[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvTacticalUnit@@@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEPAVCvTacticalUnit@@PAV2@00@Z ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Umove<CvTacticalUnit *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAVCvTacticalCity@@@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEPAVCvTacticalCity@@PAV2@00@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Umove<CvTacticalCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAVCvTacticalCity@@@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEPAVCvTacticalCity@@PAV2@00@Z
_TEXT	SEGMENT
$T270872 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$270875 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvTacticalCity@@@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEPAVCvTacticalCity@@PAV2@00@Z PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Umove<CvTacticalCity *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$270875[esp]
	mov	BYTE PTR $T270872[esp+4], 0
	mov	eax, DWORD PTR $T270872[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvTacticalCity@@@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEPAVCvTacticalCity@@PAV2@00@Z ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Umove<CvTacticalCity *>
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@0V?$_Temp_iterator@VCvTacticalUnit@@@2@HH@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@0V?$_Temp_iterator@VCvTacticalUnit@@@2@HH@Z
_TEXT	SEGMENT
$T270885 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T270886 = 40						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@0V?$_Temp_iterator@VCvTacticalUnit@@@2@HH@Z PROC ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T270885[esp+8], bl
	mov	eax, DWORD PTR $T270885[esp+8]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	eax, DWORD PTR __First$[esp+36]
	mov	DWORD PTR $T270886[esp+36], esp
	push	edx
	push	eax
	call	??$_Chunked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0V?$_Temp_iterator@VCvTacticalUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,int>

; 5254 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	add	esp, 40					; 00000028H
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@6:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@0V?$_Temp_iterator@VCvTacticalUnit@@@2@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@stdext@@YAXPAVCvTacticalUnit@@0V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@stdext@@YAXPAVCvTacticalUnit@@0V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HH@Z
_TEXT	SEGMENT
$T270922 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
??$_Unchecked_chunked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@stdext@@YAXPAVCvTacticalUnit@@0V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	mov	BYTE PTR $T270922[esp+4], 0
	mov	eax, DWORD PTR $T270922[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXPAVCvTacticalUnit@@0V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>

; 5254 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_chunked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@stdext@@YAXPAVCvTacticalUnit@@0V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z
_TEXT	SEGMENT
$T270930 = -20						; size = 20
$T270927 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$ = 16						; size = 4
__Last$ = 20						; size = 4
$T271103 = 24						; size = 1
__Cat$271107 = 24					; size = 1
$T271105 = 24						; size = 1
$T271069 = 24						; size = 1
__Cat$271073 = 24					; size = 1
$T271071 = 24						; size = 1
$T271014 = 24						; size = 1
__Cat$271018 = 24					; size = 1
$T271016 = 24						; size = 1
$T270981 = 24						; size = 1
__Cat$270985 = 24					; size = 1
$T270983 = 24						; size = 1
$T270931 = 24						; size = 4
$T270929 = 24						; size = 4
$T270928 = 24						; size = 4
$T270926 = 24						; size = 4
__Count1$ = 24						; size = 4
__Count2$ = 28						; size = 4
__Tempbuf$ = 32						; size = 4
??$_Buffered_rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z PROC ; std::_Buffered_rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Count1$[esp+20]
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+24]
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+28]
	cmp	ebx, edi
	jg	$LN4@Buffered_r@4
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalUnit>::_Maxlen
	cmp	ebx, eax
	jg	$LN4@Buffered_r@4

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+48]
	mov	ecx, DWORD PTR __First$[esp+48]
	mov	DWORD PTR $T270926[esp+48], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T270927[esp+60]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
	mov	eax, DWORD PTR $T270927[esp+64]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN25@Buffered_r@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r@4:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	BYTE PTR $T270981[esp+28], bl
	mov	eax, DWORD PTR $T270981[esp+28]
	mov	ecx, DWORD PTR __Cat$270985[esp+28]
	mov	edx, DWORD PTR $T270983[esp+28]
	push	eax
	mov	eax, DWORD PTR __First$[esp+32]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+36]
	push	edx
	mov	edx, DWORD PTR __Mid$[esp+40]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T270928[esp+52]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T271014[esp+56], bl
	mov	ecx, DWORD PTR $T271014[esp+56]
	mov	edx, DWORD PTR __Cat$271018[esp+56]
	mov	eax, DWORD PTR $T271016[esp+56]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+60]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+68]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_backward_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r@4:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalUnit>::_Maxlen
	cmp	edi, eax
	jg	$LN2@Buffered_r@4

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+48]
	mov	ecx, DWORD PTR __Mid$[esp+48]
	mov	DWORD PTR $T270929[esp+48], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T270930[esp+60]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
	mov	eax, DWORD PTR $T270930[esp+64]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN57@Buffered_r@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Buffered_r@4:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	BYTE PTR $T271069[esp+28], bl
	mov	eax, DWORD PTR $T271069[esp+28]
	mov	ecx, DWORD PTR __Cat$271073[esp+28]
	mov	edx, DWORD PTR $T271071[esp+28]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+32]
	push	ecx
	mov	ecx, DWORD PTR __Mid$[esp+36]
	push	edx
	mov	edx, DWORD PTR __First$[esp+40]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T270931[esp+52]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T271103[esp+56], bl
	mov	ecx, DWORD PTR $T271103[esp+56]
	mov	edx, DWORD PTR __Cat$271107[esp+56]
	mov	eax, DWORD PTR $T271105[esp+56]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+60]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+68]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@PAVCvTacticalUnit@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r@4:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	eax, DWORD PTR __First$[esp+28]
	mov	ecx, DWORD PTR __Mid$[esp+28]
	cmp	eax, ecx
	je	SHORT $LN88@Buffered_r@4
	mov	edx, DWORD PTR __Last$[esp+28]
	cmp	ecx, edx
	je	SHORT $LN88@Buffered_r@4
	xor	ebx, ebx
	push	ebx
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00PAHPAVCvTacticalUnit@@@Z ; std::_Rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
	mov	eax, DWORD PTR __First$[esp+48]
	add	esp, 20					; 00000014H
$LN88@Buffered_r@4:

; 2700 : 		std::advance(_First, _Count2);

	lea	ecx, DWORD PTR [edi+edi*2]

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ENDP ; std::_Buffered_rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@0V?$_Temp_iterator@VCvTacticalCity@@@2@HH@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@0V?$_Temp_iterator@VCvTacticalCity@@@2@HH@Z
_TEXT	SEGMENT
$T271217 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T271218 = 40						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@0V?$_Temp_iterator@VCvTacticalCity@@@2@HH@Z PROC ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T271217[esp+8], bl
	mov	eax, DWORD PTR $T271217[esp+8]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	eax, DWORD PTR __First$[esp+36]
	mov	DWORD PTR $T271218[esp+36], esp
	push	edx
	push	eax
	call	??$_Chunked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0V?$_Temp_iterator@VCvTacticalCity@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,int>

; 5254 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	add	esp, 40					; 00000028H
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@7:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@0V?$_Temp_iterator@VCvTacticalCity@@@2@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@stdext@@YAXPAVCvTacticalCity@@0V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@stdext@@YAXPAVCvTacticalCity@@0V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HH@Z
_TEXT	SEGMENT
$T271254 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
??$_Unchecked_chunked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@stdext@@YAXPAVCvTacticalCity@@0V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	mov	BYTE PTR $T271254[esp+4], 0
	mov	eax, DWORD PTR $T271254[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXPAVCvTacticalCity@@0V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>

; 5254 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_chunked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@stdext@@YAXPAVCvTacticalCity@@0V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z
_TEXT	SEGMENT
$T271262 = -20						; size = 20
$T271259 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$ = 16						; size = 4
__Last$ = 20						; size = 4
$T271434 = 24						; size = 1
__Cat$271439 = 24					; size = 1
$T271436 = 24						; size = 1
$T271401 = 24						; size = 1
__Cat$271406 = 24					; size = 1
$T271403 = 24						; size = 1
$T271346 = 24						; size = 1
__Cat$271350 = 24					; size = 1
$T271348 = 24						; size = 1
$T271313 = 24						; size = 1
__Cat$271317 = 24					; size = 1
$T271315 = 24						; size = 1
$T271263 = 24						; size = 4
$T271261 = 24						; size = 4
$T271260 = 24						; size = 4
$T271258 = 24						; size = 4
__Count1$ = 24						; size = 4
__Count2$ = 28						; size = 4
__Tempbuf$ = 32						; size = 4
??$_Buffered_rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z PROC ; std::_Buffered_rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Count1$[esp+20]
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+24]
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+28]
	cmp	ebx, edi
	jg	$LN4@Buffered_r@5
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalCity>::_Maxlen
	cmp	ebx, eax
	jg	$LN4@Buffered_r@5

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+48]
	mov	ecx, DWORD PTR __First$[esp+48]
	mov	DWORD PTR $T271258[esp+48], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T271259[esp+60]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
	mov	eax, DWORD PTR $T271259[esp+64]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN25@Buffered_r@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r@5:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	BYTE PTR $T271313[esp+28], bl
	mov	eax, DWORD PTR $T271313[esp+28]
	mov	ecx, DWORD PTR __Cat$271317[esp+28]
	mov	edx, DWORD PTR $T271315[esp+28]
	push	eax
	mov	eax, DWORD PTR __First$[esp+32]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+36]
	push	edx
	mov	edx, DWORD PTR __Mid$[esp+40]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T271260[esp+52]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T271346[esp+56], bl
	mov	ecx, DWORD PTR $T271346[esp+56]
	mov	edx, DWORD PTR __Cat$271350[esp+56]
	mov	eax, DWORD PTR $T271348[esp+56]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+60]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+68]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_backward_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r@5:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalCity>::_Maxlen
	cmp	edi, eax
	jg	$LN2@Buffered_r@5

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+48]
	mov	ecx, DWORD PTR __Mid$[esp+48]
	mov	DWORD PTR $T271261[esp+48], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T271262[esp+60]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
	mov	eax, DWORD PTR $T271262[esp+64]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN57@Buffered_r@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Buffered_r@5:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	BYTE PTR $T271401[esp+28], bl
	mov	eax, DWORD PTR $T271401[esp+28]
	mov	ecx, DWORD PTR __Cat$271406[esp+28]
	mov	edx, DWORD PTR $T271403[esp+28]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+32]
	push	ecx
	mov	ecx, DWORD PTR __Mid$[esp+36]
	push	edx
	mov	edx, DWORD PTR __First$[esp+40]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T271263[esp+52]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T271434[esp+56], bl
	mov	ecx, DWORD PTR $T271434[esp+56]
	mov	edx, DWORD PTR __Cat$271439[esp+56]
	mov	eax, DWORD PTR $T271436[esp+56]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+60]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+68]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@PAVCvTacticalCity@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r@5:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	eax, DWORD PTR __First$[esp+28]
	mov	ecx, DWORD PTR __Mid$[esp+28]
	cmp	eax, ecx
	je	SHORT $LN88@Buffered_r@5
	mov	edx, DWORD PTR __Last$[esp+28]
	cmp	ecx, edx
	je	SHORT $LN88@Buffered_r@5
	xor	ebx, ebx
	push	ebx
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00PAHPAVCvTacticalCity@@@Z ; std::_Rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
	mov	eax, DWORD PTR __First$[esp+48]
	add	esp, 20					; 00000014H
$LN88@Buffered_r@5:

; 2700 : 		std::advance(_First, _Count2);

	lea	ecx, DWORD PTR [edi+edi*2]

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ENDP ; std::_Buffered_rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@H@std@@YAXPAVCvTacticalMove@@0V?$_Temp_iterator@VCvTacticalMove@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@H@std@@YAXPAVCvTacticalMove@@0V?$_Temp_iterator@VCvTacticalMove@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T271554 = -20						; size = 20
$T271552 = -20						; size = 20
$T271550 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
$T271549 = 36						; size = 4
__Chunk$ = 36						; size = 4
$T271551 = 40						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@H@std@@YAXPAVCvTacticalMove@@0V?$_Temp_iterator@VCvTacticalMove@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+32]
	lea	eax, DWORD PTR [edi+edi]
	xor	ebx, ebx
	cmp	eax, ecx
	jg	SHORT $LN3@Chunked_me@9
	npad	4
$LL5@Chunked_me@9:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edx+edi*8]
	mov	DWORD PTR $T271549[esp+52], esp
	lea	esi, DWORD PTR [ecx+edi*8]
	push	esi
	push	ecx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ebp, DWORD PTR __Dest$[esp+76]
	push	ecx
	mov	DWORD PTR [eax+16], ebp
	push	edx
	lea	eax, DWORD PTR $T271550[esp+72]
	push	eax
	call	??$unchecked_merge@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@000V12@@Z ; stdext::unchecked_merge<CvTacticalMove *,CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T271550[esp+76]
	add	esp, 40					; 00000028H
	mov	DWORD PTR __Dest$[esp+48], ecx
	cmp	eax, ebx
	je	SHORT $LN41@Chunked_me@9
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Chunked_me@9:
	mov	ecx, DWORD PTR __Count$[esp+32]
	lea	eax, DWORD PTR [edi+edi]
	sub	ecx, eax
	cmp	ecx, eax

; 3297 : 		_First = _Mid2;

	mov	edx, esi
	mov	DWORD PTR __Count$[esp+32], ecx
	jge	SHORT $LL5@Chunked_me@9
$LN3@Chunked_me@9:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)
; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	cmp	ecx, edi
	mov	eax, esp
	mov	DWORD PTR $T271551[esp+52], esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	jg	SHORT $LN2@Chunked_me@9
	mov	ecx, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+52]
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T271552[esp+64]
	push	ecx
	call	??$unchecked_copy@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@0V12@@Z ; stdext::unchecked_copy<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
	add	esp, 32					; 00000020H

; 3302 : 	else

	jmp	SHORT $LN99@Chunked_me@9
$LN2@Chunked_me@9:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	esi, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR __Last$[esp+52]
	push	eax
	lea	ecx, DWORD PTR [edx+edi*8]
	push	ecx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T271554[esp+72]
	push	ecx
	call	??$unchecked_merge@PAVCvTacticalMove@@PAV1@V?$_Temp_iterator@VCvTacticalMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalMove@@@std@@PAVCvTacticalMove@@000V12@@Z ; stdext::unchecked_merge<CvTacticalMove *,CvTacticalMove *,std::_Temp_iterator<CvTacticalMove> >
	add	esp, 40					; 00000028H
$LN99@Chunked_me@9:
	mov	eax, DWORD PTR $T271554[esp+36]
	cmp	eax, ebx
	je	SHORT $LN75@Chunked_me@9
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN75@Chunked_me@9:

; 3308 : 		}
; 3309 : 	}

	mov	eax, DWORD PTR __Dest$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN85@Chunked_me@9
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN85@Chunked_me@9:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Chunked_merge@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@H@std@@YAXPAVCvTacticalMove@@0V?$_Temp_iterator@VCvTacticalMove@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,int>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@H@std@@YAXPAVCvTacticalTarget@@0V?$_Temp_iterator@VCvTacticalTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@H@std@@YAXPAVCvTacticalTarget@@0V?$_Temp_iterator@VCvTacticalTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T271736 = -24						; size = 4
$T271741 = -20						; size = 20
$T271739 = -20						; size = 20
$T271737 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T271738 = 40						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@H@std@@YAXPAVCvTacticalTarget@@0V?$_Temp_iterator@VCvTacticalTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Count$[esp+32]
	lea	ecx, DWORD PTR [eax+eax]
	xor	ebx, ebx
	cmp	ecx, esi
	push	edi
	jg	SHORT $LN3@Chunked_me@10
	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	add	edi, edi
	add	edi, edi
	npad	7
$LL5@Chunked_me@10:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR $T271736[esp+60], esp
	lea	esi, DWORD PTR [edi+ecx]
	push	esi
	push	ecx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ebp, DWORD PTR __Dest$[esp+80]
	push	ecx
	mov	DWORD PTR [eax+16], ebp
	push	edx
	lea	eax, DWORD PTR $T271737[esp+76]
	push	eax
	call	??$unchecked_merge@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@000V12@@Z ; stdext::unchecked_merge<CvTacticalTarget *,CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T271737[esp+80]
	add	esp, 40					; 00000028H
	mov	DWORD PTR __Dest$[esp+52], ecx
	cmp	eax, ebx
	je	SHORT $LN41@Chunked_me@10
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Chunked_me@10:
	mov	eax, DWORD PTR __Chunk$[esp+36]

; 3297 : 		_First = _Mid2;

	mov	edx, esi
	mov	esi, DWORD PTR __Count$[esp+36]
	lea	ecx, DWORD PTR [eax+eax]
	sub	esi, ecx
	cmp	esi, ecx
	mov	DWORD PTR __Count$[esp+36], esi
	jge	SHORT $LL5@Chunked_me@10
$LN3@Chunked_me@10:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)
; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	cmp	esi, eax
	mov	DWORD PTR $T271738[esp+56], esp
	jg	SHORT $LN2@Chunked_me@10
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T271739[esp+68]
	push	ecx
	call	??$unchecked_copy@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@0V12@@Z ; stdext::unchecked_copy<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
	add	esp, 32					; 00000020H

; 3302 : 	else

	jmp	SHORT $LN99@Chunked_me@10
$LN2@Chunked_me@10:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	esi, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	lea	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T271741[esp+76]
	push	ecx
	call	??$unchecked_merge@PAVCvTacticalTarget@@PAV1@V?$_Temp_iterator@VCvTacticalTarget@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalTarget@@@std@@PAVCvTacticalTarget@@000V12@@Z ; stdext::unchecked_merge<CvTacticalTarget *,CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget> >
	add	esp, 40					; 00000028H
$LN99@Chunked_me@10:
	mov	eax, DWORD PTR $T271741[esp+40]
	cmp	eax, ebx
	je	SHORT $LN75@Chunked_me@10
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN75@Chunked_me@10:

; 3308 : 		}
; 3309 : 	}

	mov	eax, DWORD PTR __Dest$[esp+36]
	cmp	eax, ebx
	je	SHORT $LN85@Chunked_me@10
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN85@Chunked_me@10:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Chunked_merge@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@H@std@@YAXPAVCvTacticalTarget@@0V?$_Temp_iterator@VCvTacticalTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,int>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T271923 = -36						; size = 4
$T271928 = -32						; size = 20
$T271926 = -32						; size = 20
$T271924 = -32						; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T271927 = 40						; size = 4
$T271925 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 4
___formal$ = 48						; size = 1
??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	-1
	push	__ehhandler$??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[esp+48]
	mov	esi, DWORD PTR __Count$[esp+48]
	mov	edx, DWORD PTR __First$[esp+48]
	xor	edi, edi
	lea	ecx, DWORD PTR [eax+eax]
	cmp	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+60], edi
	jg	SHORT $LN3@Chunked_me@11
	mov	ebx, eax
	shl	ebx, 4
$LN5@Chunked_me@11:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+48]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [ebx+edx]
	mov	DWORD PTR $T271923[esp+76], esp
	lea	esi, DWORD PTR [ebx+ecx]
	push	esi
	push	ecx
	push	ecx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ebp, DWORD PTR __Dest$[esp+100]
	push	edx
	lea	ecx, DWORD PTR $T271924[esp+92]
	push	ecx
	mov	DWORD PTR [eax+16], ebp
	call	??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T271924[esp+96]
	add	esp, 44					; 0000002cH
	mov	DWORD PTR __Dest$[esp+64], edx
	cmp	eax, edi
	je	SHORT $LN41@Chunked_me@11
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Chunked_me@11:
	mov	eax, DWORD PTR __Chunk$[esp+48]

; 3443 : 		_First = _Mid2;

	mov	edx, esi
	mov	esi, DWORD PTR __Count$[esp+48]
	lea	ecx, DWORD PTR [eax+eax]
	sub	esi, ecx
	cmp	esi, ecx
	mov	DWORD PTR __Count$[esp+48], esi
	jge	SHORT $LN5@Chunked_me@11
$LN3@Chunked_me@11:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	esi, eax
	jg	SHORT $LN2@Chunked_me@11

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+84]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+68]
	mov	DWORD PTR $T271925[esp+68], esp
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T271926[esp+80]
	push	ecx
	call	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	add	esp, 32					; 00000020H

; 3448 : 	else

	jmp	SHORT $LN101@Chunked_me@11
$LN2@Chunked_me@11:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);

	shl	eax, 4
	add	eax, edx
	mov	ecx, eax

; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+48]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	esi, DWORD PTR __Dest$[esp+88]
	mov	DWORD PTR $T271927[esp+72], esp
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR __Last$[esp+72]
	push	eax
	push	ecx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T271928[esp+92]
	push	ecx
	call	??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@P6A_NV3@2@Z@Z ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
	add	esp, 44					; 0000002cH
$LN101@Chunked_me@11:
	mov	eax, DWORD PTR $T271928[esp+52]
	cmp	eax, edi
	je	SHORT $LN75@Chunked_me@11
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN75@Chunked_me@11:

; 3454 : 		}
; 3455 : 	}

	mov	eax, DWORD PTR __Dest$[esp+48]
	cmp	eax, edi
	je	SHORT $LN85@Chunked_me@11
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN85@Chunked_me@11:
	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvBlockingUnit>::~_Temp_iterator<CvBlockingUnit>
__ehhandler$??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
PUBLIC	??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@H@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@H@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T272117 = -24						; size = 4
$T272122 = -20						; size = 20
$T272120 = -20						; size = 20
$T272118 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T272119 = 40						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@H@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Count$[esp+32]
	lea	ecx, DWORD PTR [eax+eax]
	xor	ebx, ebx
	cmp	ecx, esi
	push	edi
	jg	SHORT $LN3@Chunked_me@12
	mov	edi, eax
	shl	edi, 4
$LL5@Chunked_me@12:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR $T272117[esp+60], esp
	lea	esi, DWORD PTR [edi+ecx]
	push	esi
	push	ecx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ebp, DWORD PTR __Dest$[esp+80]
	push	ecx
	mov	DWORD PTR [eax+16], ebp
	push	edx
	lea	eax, DWORD PTR $T272118[esp+76]
	push	eax
	call	??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@@Z ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T272118[esp+80]
	add	esp, 40					; 00000028H
	mov	DWORD PTR __Dest$[esp+52], ecx
	cmp	eax, ebx
	je	SHORT $LN41@Chunked_me@12
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Chunked_me@12:
	mov	eax, DWORD PTR __Chunk$[esp+36]

; 3297 : 		_First = _Mid2;

	mov	edx, esi
	mov	esi, DWORD PTR __Count$[esp+36]
	lea	ecx, DWORD PTR [eax+eax]
	sub	esi, ecx
	cmp	esi, ecx
	mov	DWORD PTR __Count$[esp+36], esi
	jge	SHORT $LL5@Chunked_me@12
$LN3@Chunked_me@12:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)
; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	cmp	esi, eax
	mov	DWORD PTR $T272119[esp+56], esp
	jg	SHORT $LN2@Chunked_me@12
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T272120[esp+68]
	push	ecx
	call	??$unchecked_copy@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@0V12@@Z ; stdext::unchecked_copy<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	add	esp, 32					; 00000020H

; 3302 : 	else

	jmp	SHORT $LN99@Chunked_me@12
$LN2@Chunked_me@12:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);

	shl	eax, 4
	add	eax, edx
	mov	ecx, eax

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	esi, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	ecx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T272122[esp+76]
	push	ecx
	call	??$unchecked_merge@PAVCvBlockingUnit@@PAV1@V?$_Temp_iterator@VCvBlockingUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvBlockingUnit@@@std@@PAVCvBlockingUnit@@000V12@@Z ; stdext::unchecked_merge<CvBlockingUnit *,CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit> >
	add	esp, 40					; 00000028H
$LN99@Chunked_me@12:
	mov	eax, DWORD PTR $T272122[esp+40]
	cmp	eax, ebx
	je	SHORT $LN75@Chunked_me@12
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN75@Chunked_me@12:

; 3308 : 		}
; 3309 : 	}

	mov	eax, DWORD PTR __Dest$[esp+36]
	cmp	eax, ebx
	je	SHORT $LN85@Chunked_me@12
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN85@Chunked_me@12:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@H@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill@2
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill@2:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill@2
	pop	ebx
$LN22@Ufill@2:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$214846 = 16					; size = 4
__Tmp$214836 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n@2
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$214836[esp+16], edx
	jae	SHORT $LN3@Insert_n@2
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214836[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214836[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$214846[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n@2:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n@2:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	??1CvTacticalMoveXMLEntries@@QAE@XZ		; CvTacticalMoveXMLEntries::~CvTacticalMoveXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvTacticalMoveXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTacticalMoveXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvTacticalMoveXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvTacticalMoveXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ??1CvTacticalMoveXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTacticalMoveXMLEntries@@QAE@XZ PROC		; CvTacticalMoveXMLEntries::~CvTacticalMoveXMLEntries, COMDAT
; _this$ = ecx

; 84   : {

	push	-1
	push	__ehhandler$??1CvTacticalMoveXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 85   : 	DeleteArray();

	call	?DeleteArray@CvTacticalMoveXMLEntries@@QAEXXZ ; CvTacticalMoveXMLEntries::DeleteArray

; 86   : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvTactical
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvTactical:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTacticalMoveXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::~vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >
__ehhandler$??1CvTacticalMoveXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvTacticalMoveXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTacticalMoveXMLEntries@@QAE@XZ ENDP		; CvTacticalMoveXMLEntries::~CvTacticalMoveXMLEntries
PUBLIC	?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z ; CvTacticalAI::QueueAttack
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z$2
__ehfuncinfo$?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z
_TEXT	SEGMENT
_bRtnValue$ = -141					; size = 1
_this$ = -140						; size = 4
_strTemp$220386 = -136					; size = 28
_attack$ = -108						; size = 40
_strMsg$220385 = -68					; size = 28
$T272522 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pAttacker$ = 8						; size = 4
_pTarget$ = 12						; size = 4
_bRanged$ = 16						; size = 1
_bCityAttack$ = 20					; size = 1
?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z PROC ; CvTacticalAI::QueueAttack, COMDAT
; _this$ = ecx

; 535  : {

	push	-1
	push	__ehhandler$?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 132				; 00000084H

; 536  : 	bool bRtnValue = true;
; 537  : 	CvQueuedAttack attack;
; 538  : 	int iSeriesID;
; 539  : 	CvPlot* pTargetPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR _pTarget$[esp+140]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+160], edi
	mov	BYTE PTR _bRtnValue$[esp+160], 1
	cmp	eax, -2147483647			; 80000001H
	je	$LN23@QueueAttac
	cmp	esi, -2147483647			; 80000001H
	je	$LN23@QueueAttac
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	dl, dl
	je	SHORT $LN127@QueueAttac
	test	eax, eax
	jge	SHORT $LN35@QueueAttac
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN37@QueueAttac
$LN35@QueueAttac:
	cmp	eax, ecx
	jl	SHORT $LN127@QueueAttac
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN37@QueueAttac
$LN127@QueueAttac:
	mov	edi, eax
$LN37@QueueAttac:
	mov	al, BYTE PTR [ebp+4057]
	mov	ebx, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN128@QueueAttac
	test	esi, esi
	jge	SHORT $LN45@QueueAttac
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN47@QueueAttac
$LN45@QueueAttac:
	cmp	esi, ebx
	jl	SHORT $LN128@QueueAttac
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN47@QueueAttac
$LN128@QueueAttac:
	mov	edx, esi
$LN47@QueueAttac:
	test	edi, edi
	jl	SHORT $LN27@QueueAttac
	cmp	edi, ecx
	jge	SHORT $LN27@QueueAttac
	test	edx, edx
	jl	SHORT $LN27@QueueAttac
	cmp	edx, ebx
	jge	SHORT $LN27@QueueAttac
	imul	ecx, edx
	add	ecx, edi
	mov	edi, DWORD PTR _this$[esp+160]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	jmp	SHORT $LN25@QueueAttac
$LN27@QueueAttac:
	mov	edi, DWORD PTR _this$[esp+160]
$LN23@QueueAttac:
	xor	ecx, ecx
$LN25@QueueAttac:

; 540  : 	CvPlot* pFromPlot;
; 541  : 
; 542  : 	// Can we find this target in the queue, if so what is its series ID
; 543  : 	int iTempSeriesID = PlotAlreadyTargeted(pTargetPlot);

	push	ecx
	mov	ecx, edi
	call	?PlotAlreadyTargeted@CvTacticalAI@@QAEHPAVCvPlot@@@Z ; CvTacticalAI::PlotAlreadyTargeted

; 544  : 
; 545  : 	if(iTempSeriesID == -1)

	cmp	eax, -1
	jne	SHORT $LN5@QueueAttac

; 546  : 	{
; 547  : 		m_iCurrentSeriesID++;

	inc	DWORD PTR [edi+2148]
	mov	eax, DWORD PTR [edi+2148]

; 548  : 		iSeriesID = m_iCurrentSeriesID;
; 549  : 	}
; 550  : 	else

	jmp	SHORT $LN4@QueueAttac
$LN5@QueueAttac:

; 551  : 	{
; 552  : 		iSeriesID = iTempSeriesID;
; 553  : 		bRtnValue = false;

	mov	BYTE PTR _bRtnValue$[esp+160], 0
$LN4@QueueAttac:

; 554  : 	}
; 555  : 
; 556  : 	attack.SetAttacker(pAttacker);

	mov	ebx, DWORD PTR _pAttacker$[esp+156]

; 557  : 	attack.SetTarget(pTarget);

	mov	esi, DWORD PTR _pTarget$[esp+156]
	mov	DWORD PTR _attack$[esp+160], ebx
	mov	ecx, 7
	lea	edi, DWORD PTR _attack$[esp+164]
	rep movsd

; 558  : 	attack.SetSeriesID(iSeriesID);
; 559  : 	attack.SetRanged(bRanged);
; 560  : 	attack.SetCityAttack(bCityAttack);
; 561  : 	m_QueuedAttacks.push_back(attack);

	mov	esi, DWORD PTR _this$[esp+160]
	mov	edi, DWORD PTR [esi+2140]
	mov	cl, BYTE PTR _bCityAttack$[esp+156]
	mov	DWORD PTR _attack$[esp+192], eax
	mov	al, BYTE PTR _bRanged$[esp+156]
	add	esi, 2136				; 00000858H
	lea	edx, DWORD PTR _attack$[esp+160]
	mov	BYTE PTR _attack$[esp+196], al
	mov	eax, DWORD PTR [edi+4]
	push	edx
	push	eax
	mov	BYTE PTR _attack$[esp+205], cl
	push	edi
	mov	ecx, esi
	call	?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@PAU342@0ABVCvQueuedAttack@@@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Buynode
	push	1
	mov	ecx, esi
	mov	ebp, eax
	call	?_Incsize@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXI@Z ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Incsize
	mov	DWORD PTR [edi+4], ebp
	mov	eax, DWORD PTR [ebp+4]

; 562  : 
; 563  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [eax], ebp
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN126@QueueAttac
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN126@QueueAttac

; 564  : 	{
; 565  : 		CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$220385[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 566  : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$220386[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 567  : 		if(bCityAttack)

	cmp	BYTE PTR _bCityAttack$[esp+156], 0
	mov	BYTE PTR __$EHRec$[esp+168], 1
	je	SHORT $LN2@QueueAttac

; 568  : 		{
; 569  : 			strTemp = ((CvCity*)pAttacker)->getName();

	lea	ecx, DWORD PTR $T272522[esp+160]
	push	ecx
	mov	ecx, ebx
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _strTemp$220386[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 2
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T272522[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 570  : 			pFromPlot = ((CvCity*)pAttacker)->plot();

	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 571  : 		}
; 572  : 		else

	jmp	SHORT $LN1@QueueAttac
$LN2@QueueAttac:

; 573  : 		{
; 574  : 			CvUnit* pkAttackingUnit = static_cast<CvUnit*>(pAttacker);
; 575  : 			strTemp = pkAttackingUnit->getUnitInfo().GetDescription();

	mov	ecx, ebx
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$220386[esp+160]
	test	eax, eax
	je	SHORT $LN105@QueueAttac
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN104@QueueAttac
$LN105@QueueAttac:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN104@QueueAttac:

; 576  : 			pFromPlot = ((CvUnit*)pAttacker)->plot();

	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
$LN1@QueueAttac:

; 577  : 		}
; 578  : 		strMsg.Format("Queued attack with %s, To X: %d, To Y: %d, From X: %d, From Y: %d", strTemp.GetCString(), pTarget->GetTargetX(), pTarget->GetTargetY(), pFromPlot->getX(), pFromPlot->getY());

	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	mov	esi, DWORD PTR _pTarget$[esp+156]
	mov	edx, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	push	ecx
	push	eax
	push	edx
	push	esi
	lea	ecx, DWORD PTR _strTemp$220386[esp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strMsg$220385[esp+180]
	push	OFFSET $SG220395
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 579  : 		LogTacticalMessage(strMsg);

	mov	ecx, DWORD PTR _this$[esp+188]
	add	esp, 28					; 0000001cH
	push	1
	lea	eax, DWORD PTR _strMsg$220385[esp+164]
	push	eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 580  : 	}

	lea	ecx, DWORD PTR _strTemp$220386[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strMsg$220385[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN126@QueueAttac:

; 581  : 
; 582  : 	return bRtnValue;
; 583  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+160]
	mov	al, BYTE PTR _bRtnValue$[esp+160]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 144				; 00000090H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z$0:
	lea	ecx, DWORD PTR _strMsg$220385[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z$1:
	lea	ecx, DWORD PTR _strTemp$220386[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z$2:
	lea	ecx, DWORD PTR $T272522[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z:
	mov	eax, OFFSET __ehfuncinfo$?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z ENDP ; CvTacticalAI::QueueAttack
PUBLIC	?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z ; CvTacticalAI::PlotSingleHexOperationMoves
EXTRN	?canEnterTerritory@CvUnit@@QBE_NW4TeamTypes@@_N11@Z:PROC ; CvUnit::canEnterTerritory
EXTRN	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC ; CvUnit::canEnterTerrain
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?GetNextUnitID@CvArmyAI@@QAEHXZ:PROC		; CvArmyAI::GetNextUnitID
EXTRN	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z:PROC ; CvAIEscortedOperation::RetargetCivilian
EXTRN	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ:PROC	; CvArmyAI::GetNumSlotsFilled
EXTRN	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ:PROC ; CvAIOperation::GetTargetPlot
EXTRN	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ:PROC ; CvArmyAI::GetArmyAIState
EXTRN	?GetFirstUnitID@CvArmyAI@@QAEHXZ:PROC		; CvArmyAI::GetFirstUnitID
EXTRN	?GetFirstArmyID@CvAIOperation@@QAEHXZ:PROC	; CvAIOperation::GetFirstArmyID
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z DD 019930522H
	DD	015H
	DD	FLAT:__unwindtable$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$9
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$10
	DD	06H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$11
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$12
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$14
	DD	09H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$15
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$19
	DD	0bH
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$20
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$21
	DD	0dH
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$22
	DD	0dH
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$26
	DD	0fH
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$27
	DD	0dH
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$28
	DD	0dH
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$32
	DD	012H
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$33
	DD	0dH
	DD	FLAT:__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$34
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z
_TEXT	SEGMENT
_pThisArmy$ = -104					; size = 4
_pCivilianMove$ = -100					; size = 4
_iI$222183 = -100					; size = 4
$T273422 = -96						; size = 4
$T272825 = -96						; size = 4
$T272824 = -96						; size = 4
$T272822 = -96						; size = 4
$T272821 = -96						; size = 4
$T272818 = -96						; size = 4
_pEscort$ = -92						; size = 8
_pCivilian$ = -84					; size = 8
_pBlockingUnit$222232 = -76				; size = 8
_strLogString$222260 = -68				; size = 28
_strLogString$222246 = -68				; size = 28
_strTemp$222227 = -68					; size = 28
_strLogString$222217 = -68				; size = 28
_strTemp$222201 = -68					; size = 28
_strTemp$222196 = -68					; size = 28
_strTemp$222179 = -68					; size = 28
_strLogString$222266 = -40				; size = 28
_strTemp$222261 = -40					; size = 28
_strLogString$222252 = -40				; size = 28
_strTemp$222247 = -40					; size = 28
_strLogString$222238 = -40				; size = 28
_strLogString$222226 = -40				; size = 28
_strTemp$222218 = -40					; size = 28
_strLogString$222211 = -40				; size = 28
_strLogString$222202 = -40				; size = 28
_strLogString$222197 = -40				; size = 28
_strLogString$222180 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_bSaveMoves$ = 8					; size = 1
$T273033 = 8						; size = 4
$T272826 = 8						; size = 4
$T272823 = 8						; size = 4
$T272820 = 8						; size = 4
$T272819 = 8						; size = 4
$T272817 = 8						; size = 4
_iFlags$222206 = 8					; size = 4
$T272816 = 8						; size = 4
$T272815 = 8						; size = 4
$T272814 = 8						; size = 4
$T272813 = 8						; size = 4
_pOperation$ = 8					; size = 4
?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z PROC ; CvTacticalAI::PlotSingleHexOperationMoves, COMDAT
; _this$ = ecx

; 3898 : {

	push	-1
	push	__ehhandler$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	ebp
	push	esi

; 3899 : 	int iUnitID;
; 3900 : 	UnitHandle pCivilian;

	xor	esi, esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _pCivilian$[esp+120], esi
	mov	BYTE PTR _pCivilian$[esp+124], 0
	mov	DWORD PTR __$EHRec$[esp+128], esi

; 3901 : 	UnitHandle pEscort;

	mov	DWORD PTR _pEscort$[esp+120], esi
	mov	BYTE PTR _pEscort$[esp+124], 0

; 3902 : 	CvPlot* pCivilianMove;
; 3903 : 	CvPlot* pEscortMove;
; 3904 : 	bool bSaveMoves = false;
; 3905 : 
; 3906 : 	// Simplification - assume only 1 army per operation now
; 3907 : 	if(pOperation->GetFirstArmyID() == -1)

	mov	ebp, DWORD PTR _pOperation$[esp+116]
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+128], 1
	call	?GetFirstArmyID@CvAIOperation@@QAEHXZ	; CvAIOperation::GetFirstArmyID
	cmp	eax, -1

; 3908 : 	{
; 3909 : 		return;

	je	$LN140@PlotSingle

; 3910 : 	}
; 3911 : 	CvArmyAI* pThisArmy = m_pPlayer->getArmyAI(pOperation->GetFirstArmyID());

	mov	ecx, ebp
	call	?GetFirstArmyID@CvAIOperation@@QAEHXZ	; CvAIOperation::GetFirstArmyID
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	ebx, eax

; 3912 : 	iUnitID = pThisArmy->GetFirstUnitID();

	mov	ecx, ebx
	mov	DWORD PTR _pThisArmy$[esp+120], ebx
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 3913 : 	if(iUnitID != -1)

	cmp	eax, -1
	je	$LN564@PlotSingle

; 3914 : 	{
; 3915 : 		pCivilian = m_pPlayer->getUnit(iUnitID);

	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pCivilian$[esp+120], esi
	test	esi, esi
	je	$LN564@PlotSingle
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 3921 : 	}
; 3922 : 
; 3923 : 	// ESCORT AND CIVILIAN MEETING UP
; 3924 : 	if(pThisArmy->GetArmyAIState() == ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE ||
; 3925 : 	        pThisArmy->GetArmyAIState() == ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP)

	mov	ecx, ebx
	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState
	test	eax, eax
	je	$LN44@PlotSingle
	mov	ecx, ebx
	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState
	cmp	eax, 1
	je	$LN44@PlotSingle

; 4018 : 		}
; 4019 : 	}
; 4020 : 
; 4021 : 	// MOVING TO TARGET
; 4022 : 	else
; 4023 : 	{
; 4024 : 		// If we're not there yet, we have work to do (otherwise CheckOnTarget() will finish operation for us)
; 4025 : 		if(pCivilian->plot() != pOperation->GetTargetPlot())

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, ebp
	mov	ebx, eax
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	ebx, eax
	je	$LN28@PlotSingle

; 4026 : 		{
; 4027 : 			// Look at where we'd move this turn taking units into consideration
; 4028 : 			int iFlags = 0;
; 4029 : 			if(pThisArmy->GetNumSlotsFilled() > 1)

	mov	ebx, DWORD PTR _pThisArmy$[esp+120]
	mov	ecx, ebx
	mov	DWORD PTR _iFlags$222206[esp+116], 0
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1

; 4030 : 			{
; 4031 : 				iFlags = MOVE_UNITS_IGNORE_DANGER;

	mov	eax, 8
	jg	SHORT $LN25@PlotSingle
	mov	eax, DWORD PTR _iFlags$222206[esp+116]
$LN25@PlotSingle:

; 4032 : 			}
; 4033 : 
; 4034 : 			// Handle case of no path found at all for civilian
; 4035 : 			if(!pCivilian->GeneratePath(pOperation->GetTargetPlot(), iFlags, false /*bReuse*/))

	push	0
	push	0
	push	eax
	mov	ecx, ebp
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, esi
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	jne	$LN24@PlotSingle

; 4036 : 			{
; 4037 : 				pOperation->RetargetCivilian(pCivilian.pointer(), pThisArmy);

	push	ebx
	push	esi
	mov	ecx, ebp
	call	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian

; 4038 : 				pCivilian->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4039 : 				pEscort = m_pPlayer->getUnit(pThisArmy->GetNextUnitID());

	mov	ecx, ebx
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	push	eax
	lea	ecx, DWORD PTR _pEscort$[esp+124]
	call	??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=

; 4040 : 				if(pEscort)

	mov	ecx, DWORD PTR _pEscort$[esp+120]
	test	ecx, ecx
	je	SHORT $LN23@PlotSingle

; 4041 : 				{
; 4042 : 					pEscort->finishMoves();

	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN23@PlotSingle:

; 4043 : 				}
; 4044 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN28@PlotSingle
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN28@PlotSingle

; 4045 : 				{
; 4046 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222211[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4047 : 					strLogString.Format("Retargeting civilian escort operation (path lost to target), X: %d, Y: %d", pOperation->GetTargetPlot()->getX(), pOperation->GetTargetPlot()->getY());

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+128], 8
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	ebx, WORD PTR [eax+2]
	mov	ecx, ebp
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	eax, WORD PTR [eax]
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _strLogString$222211[esp+128]
	push	OFFSET $SG222212
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4048 : 					LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$222211[esp+124]
	push	edx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4049 : 				}

	lea	ecx, DWORD PTR _strLogString$222211[esp+120]

; 4050 : 			}
; 4051 : 
; 4052 : 			else

	jmp	$LN585@PlotSingle
$LN564@PlotSingle:

; 3916 : 	}
; 3917 : 
; 3918 : 	if(!pCivilian)
; 3919 : 	{
; 3920 : 		return;

	mov	DWORD PTR __$EHRec$[esp+128], -1
	test	esi, esi
	je	$LN140@PlotSingle
	jmp	$LN584@PlotSingle
$LN24@PlotSingle:

; 4053 : 			{
; 4054 : 				pCivilianMove = pCivilian->GetPathEndTurnPlot();

	mov	ecx, esi
	call	?GetPathEndTurnPlot@CvUnit@@QBEPAVCvPlot@@XZ ; CvUnit::GetPathEndTurnPlot
	mov	ebx, eax

; 4055 : 				bSaveMoves = (pCivilianMove == pOperation->GetTargetPlot());

	mov	ecx, ebp
	mov	DWORD PTR _pCivilianMove$[esp+120], ebx
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot

; 4056 : 				if(pThisArmy->GetNumSlotsFilled() == 1)

	mov	ecx, DWORD PTR _pThisArmy$[esp+120]
	cmp	ebx, eax
	sete	al
	mov	BYTE PTR _bSaveMoves$[esp+116], al
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jne	$LN20@PlotSingle

; 4057 : 				{
; 4058 : 					ExecuteMoveToPlot(pCivilian, pCivilianMove, bSaveMoves);

	mov	ecx, DWORD PTR _bSaveMoves$[esp+116]
	push	ecx
	push	ebx
	sub	esp, 8
	lea	edx, DWORD PTR _pCivilian$[esp+136]
	mov	ecx, esp
	mov	DWORD PTR $T272817[esp+132], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 4059 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN28@PlotSingle
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN28@PlotSingle

; 4060 : 					{
; 4061 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222217[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	bl, 9

; 4062 : 						CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222218[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4063 : 						strTemp = pCivilian->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+128], 10		; 0000000aH
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222218[esp+124]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 4064 : 						strLogString.Format("Moving %s without escort to target, X: %d, Y: %d", strTemp.GetCString(), pCivilian->plot()->getX(), pCivilian->plot()->getY());

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	ebp, WORD PTR [eax+2]
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	eax, WORD PTR [eax]
	push	ebp
	push	eax
	lea	ecx, DWORD PTR _strTemp$222218[esp+128]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$222217[esp+132]
	push	OFFSET $SG222219
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4065 : 						LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222217[esp+124]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4066 : 					}

	mov	BYTE PTR __$EHRec$[esp+128], bl

; 4067 : 				}
; 4068 : 
; 4069 : 				else

	jmp	$LN586@PlotSingle
$LN20@PlotSingle:

; 4070 : 				{
; 4071 : 					pEscort = m_pPlayer->getUnit(pThisArmy->GetNextUnitID());

	mov	ecx, DWORD PTR _pThisArmy$[esp+120]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	push	eax
	lea	ecx, DWORD PTR _pEscort$[esp+124]
	call	??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=

; 4072 : 
; 4073 : 					// See if escort can move to the same location in one turn
; 4074 : 					if(TurnsToReachTarget(pEscort, pCivilianMove) <= 1)

	push	0
	push	0
	push	0
	push	ebx
	sub	esp, 8
	lea	edx, DWORD PTR _pEscort$[esp+144]
	mov	ecx, esp
	mov	DWORD PTR $T272818[esp+144], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jg	$LN17@PlotSingle

; 4075 : 					{
; 4076 : 						ExecuteMoveToPlot(pCivilian, pCivilianMove, bSaveMoves);

	mov	eax, DWORD PTR _bSaveMoves$[esp+116]
	push	eax
	push	ebx
	sub	esp, 8
	lea	edx, DWORD PTR _pCivilian$[esp+136]
	mov	ecx, esp
	mov	DWORD PTR $T272819[esp+132], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 4077 : 						ExecuteMoveToPlot(pEscort, pCivilianMove);

	push	0
	push	ebx
	sub	esp, 8
	lea	eax, DWORD PTR _pEscort$[esp+136]
	mov	ecx, esp
	mov	DWORD PTR $T272820[esp+132], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 4078 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN28@PlotSingle
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN28@PlotSingle

; 4079 : 						{
; 4080 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222226[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	bl, 11					; 0000000bH

; 4081 : 							CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222227[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4082 : 							strTemp = pCivilian->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+128], 12		; 0000000cH
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222227[esp+124]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 4083 : 							strLogString.Format("Moving %s to target, X: %d, Y: %d", strTemp.GetCString(), pCivilian->getX(), pCivilian->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$222227[esp+128]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$222226[esp+132]
	push	OFFSET $SG222228
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4084 : 							LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$222226[esp+124]
	push	edx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4085 : 							strTemp = pEscort->getUnitInfo().GetDescription();

	mov	ebp, DWORD PTR _pEscort$[esp+120]
	mov	ecx, ebp
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222227[esp+124]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 4086 : 							strLogString.Format("Moving escorting %s to target, X: %d, Y: %d", strTemp.GetCString(), pEscort->getX(), pEscort->getY());

	mov	eax, DWORD PTR [ebp+88]
	mov	ebp, DWORD PTR [ebp+76]
	push	eax
	push	ebp
	lea	ecx, DWORD PTR _strTemp$222227[esp+128]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$222226[esp+132]
	push	OFFSET $SG222229
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4087 : 							LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222226[esp+124]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4088 : 						}

	lea	ecx, DWORD PTR _strTemp$222227[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$222226[esp+120]

; 4089 : 					}
; 4090 : 
; 4091 : 					else

	jmp	$LN585@PlotSingle
$LN17@PlotSingle:

; 4092 : 					{
; 4093 : 						CvTacticalAnalysisCell* pCell = GC.getGame().GetTacticalAnalysisMap()->GetCell(pCivilianMove->GetPlotIndex());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ecx, ebx
	mov	DWORD PTR $T273422[esp+120], edx
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	ecx, DWORD PTR $T273422[esp+120]
	mov	ebx, eax
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	imul	ebx, 44					; 0000002cH
	add	ebx, DWORD PTR [eax+12]

; 4094 : 						UnitHandle pBlockingUnit = pCivilianMove->getBestDefender(m_pPlayer->GetID());

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	eax
	lea	ecx, DWORD PTR _pBlockingUnit$222232[esp+148]
	push	ecx
	mov	ecx, DWORD PTR _pCivilianMove$[esp+152]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender

; 4095 : 
; 4096 : 						// See if friendly blocking unit is ending the turn there, or if no blocking unit (which indicates this is somewhere civilian
; 4097 : 						// can move that escort can't -- like minor civ territory), then find a new path based on moving the escort
; 4098 : 						if(pCell->IsFriendlyTurnEndTile() || !pBlockingUnit)

	mov	edx, DWORD PTR [ebx]
	shr	edx, 7
	mov	BYTE PTR __$EHRec$[esp+128], 13		; 0000000dH
	test	dl, 1
	jne	$LN13@PlotSingle
	cmp	DWORD PTR _pBlockingUnit$222232[esp+120], 0
	je	$LN13@PlotSingle

; 4146 : 								}
; 4147 : 							}
; 4148 : 						}
; 4149 : 
; 4150 : 						// Looks like we should be able to move the blocking unit out of the way
; 4151 : 						else
; 4152 : 						{
; 4153 : 							if(ExecuteMoveOfBlockingUnit(pBlockingUnit))

	sub	esp, 8
	lea	eax, DWORD PTR _pBlockingUnit$222232[esp+128]
	mov	ecx, esp
	mov	DWORD PTR $T272824[esp+128], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::ExecuteMoveOfBlockingUnit
	test	al, al
	je	$LN4@PlotSingle

; 4154 : 							{
; 4155 : 								ExecuteMoveToPlot(pEscort, pCivilianMove);

	mov	ebx, DWORD PTR _pCivilianMove$[esp+120]
	push	0
	push	ebx
	sub	esp, 8
	lea	edx, DWORD PTR _pEscort$[esp+136]
	mov	ecx, esp
	mov	DWORD PTR $T272825[esp+136], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 4156 : 								ExecuteMoveToPlot(pCivilian, pCivilianMove, bSaveMoves);

	mov	eax, DWORD PTR _bSaveMoves$[esp+116]
	push	eax
	push	ebx
	sub	esp, 8
	lea	edx, DWORD PTR _pCivilian$[esp+136]
	mov	ecx, esp
	mov	DWORD PTR $T272826[esp+132], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 4157 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@PlotSingle
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@PlotSingle

; 4158 : 								{
; 4159 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222260[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	bl, 18					; 00000012H

; 4160 : 									CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222261[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4161 : 									strTemp = pEscort->getUnitInfo().GetDescription();

	mov	ebp, DWORD PTR _pEscort$[esp+120]
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+128], 19		; 00000013H
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222261[esp+124]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 4162 : 									strLogString.Format("Moving escorting %s to target, X: %d, Y: %d", strTemp.GetCString(), pEscort->getX(), pEscort->getY());

	mov	eax, DWORD PTR [ebp+88]
	mov	ebp, DWORD PTR [ebp+76]
	push	eax
	push	ebp
	lea	ecx, DWORD PTR _strTemp$222261[esp+128]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$222260[esp+132]
	push	OFFSET $SG222262
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4163 : 									LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222260[esp+124]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4164 : 									strTemp = pCivilian->getUnitInfo().GetDescription();

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222261[esp+124]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 4165 : 									strLogString.Format("Moving %s to target, X: %d, Y: %d", strTemp.GetCString(), pCivilian->getX(), pCivilian->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$222261[esp+128]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$222260[esp+132]
	push	OFFSET $SG222263
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4166 : 									LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$222260[esp+124]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4167 : 								}

	lea	ecx, DWORD PTR _strTemp$222261[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$222260[esp+120]

; 4168 : 							}
; 4169 : 							else

	jmp	$LN587@PlotSingle
$LN4@PlotSingle:

; 4170 : 							{
; 4171 : 
; 4172 : 								// Didn't find an alternative, try retargeting operation
; 4173 : 								pOperation->RetargetCivilian(pCivilian.pointer(), pThisArmy);

	mov	ecx, DWORD PTR _pThisArmy$[esp+120]
	push	ecx
	push	esi
	mov	ecx, ebp
	call	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian

; 4174 : 								pCivilian->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4175 : 								pEscort->finishMoves();

	mov	ecx, DWORD PTR _pEscort$[esp+120]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4176 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@PlotSingle
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@PlotSingle

; 4177 : 								{
; 4178 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222266[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+128], 20		; 00000014H

; 4179 : 									strLogString.Format("Retargeting civilian escort operation. Could not move blocking unit.");

	push	OFFSET $SG222267

; 4180 : 									LogTacticalMessage(strLogString);
; 4181 : 								}

	jmp	$LN588@PlotSingle
$LN13@PlotSingle:

; 4099 : 						{
; 4100 : 							if(!pEscort->GeneratePath(pOperation->GetTargetPlot(), 0, false /*bReuse*/))

	push	0
	push	0
	push	0
	mov	ecx, ebp
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	ebx, DWORD PTR _pEscort$[esp+132]
	push	eax
	mov	ecx, ebx
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	jne	$LN12@PlotSingle

; 4101 : 							{
; 4102 : 								pOperation->RetargetCivilian(pCivilian.pointer(), pThisArmy);

	mov	ecx, DWORD PTR _pThisArmy$[esp+120]
	push	ecx
	push	esi
	mov	ecx, ebp
	call	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian

; 4103 : 								pCivilian->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4104 : 								pEscort->finishMoves();

	mov	ecx, ebx
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4105 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@PlotSingle
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@PlotSingle

; 4106 : 								{
; 4107 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222238[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4108 : 									strLogString.Format("Retargeting civilian escort operation (path lost to target), X: %d, Y: %d", pOperation->GetTargetPlot()->getX(), pOperation->GetTargetPlot()->getY());

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+128], 14		; 0000000eH
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	ebx, WORD PTR [eax+2]
	mov	ecx, ebp
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	edx, WORD PTR [eax]
	push	ebx
	push	edx
	lea	eax, DWORD PTR _strLogString$222238[esp+128]
	push	OFFSET $SG222239
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4109 : 									LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222238[esp+124]
	push	ecx

; 4110 : 								}
; 4111 : 							}
; 4112 : 							else

	jmp	$LN589@PlotSingle
$LN12@PlotSingle:

; 4113 : 							{
; 4114 : 								pEscortMove = pCivilian->GetPathEndTurnPlot();

	mov	ecx, esi
	call	?GetPathEndTurnPlot@CvUnit@@QBEPAVCvPlot@@XZ ; CvUnit::GetPathEndTurnPlot

; 4115 : 								bSaveMoves = (pEscortMove == pOperation->GetTargetPlot());

	mov	ecx, ebp
	mov	ebx, eax
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot

; 4116 : 
; 4117 : 								// See if civilian can move to the same location in one turn
; 4118 : 								if(TurnsToReachTarget(pCivilian, pEscortMove) <= 1)

	push	0
	push	0
	push	0
	cmp	ebx, eax
	push	ebx
	sete	dl
	sub	esp, 8
	lea	eax, DWORD PTR _pCivilian$[esp+144]
	mov	ecx, esp
	mov	DWORD PTR $T272821[esp+144], esp
	push	eax
	mov	BYTE PTR _bSaveMoves$[esp+144], dl
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jg	$LN9@PlotSingle

; 4119 : 								{
; 4120 : 									ExecuteMoveToPlot(pEscort, pEscortMove);

	push	0
	push	ebx
	sub	esp, 8
	lea	edx, DWORD PTR _pEscort$[esp+136]
	mov	ecx, esp
	mov	DWORD PTR $T272822[esp+136], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 4121 : 									ExecuteMoveToPlot(pCivilian, pEscortMove, bSaveMoves);

	mov	eax, DWORD PTR _bSaveMoves$[esp+116]
	push	eax
	push	ebx
	sub	esp, 8
	lea	edx, DWORD PTR _pCivilian$[esp+136]
	mov	ecx, esp
	mov	DWORD PTR $T272823[esp+132], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 4122 : 									if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@PlotSingle
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@PlotSingle

; 4123 : 									{
; 4124 : 										CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222246[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	bl, 15					; 0000000fH

; 4125 : 										CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222247[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4126 : 										strTemp = pEscort->getUnitInfo().GetDescription();

	mov	ebp, DWORD PTR _pEscort$[esp+120]
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+128], 16		; 00000010H
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222247[esp+124]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 4127 : 										strLogString.Format("Moving escorting %s to target, X: %d, Y: %d", strTemp.GetCString(), pEscort->getX(), pEscort->getY());

	mov	eax, DWORD PTR [ebp+88]
	mov	ebp, DWORD PTR [ebp+76]
	push	eax
	push	ebp
	lea	ecx, DWORD PTR _strTemp$222247[esp+128]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$222246[esp+132]
	push	OFFSET $SG222248
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4128 : 										LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222246[esp+124]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4129 : 										strTemp = pCivilian->getUnitInfo().GetDescription();

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222247[esp+124]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 4130 : 										strLogString.Format("Moving %s to target, X: %d, Y: %d", strTemp.GetCString(), pCivilian->getX(), pCivilian->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$222247[esp+128]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$222246[esp+132]
	push	OFFSET $SG222249
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4131 : 										LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$222246[esp+124]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4132 : 									}

	lea	ecx, DWORD PTR _strTemp$222247[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$222246[esp+120]

; 4133 : 								}
; 4134 : 								else

	jmp	SHORT $LN587@PlotSingle
$LN9@PlotSingle:

; 4135 : 								{
; 4136 : 									// Didn't find an alternative, retarget operation
; 4137 : 									pOperation->RetargetCivilian(pCivilian.pointer(), pThisArmy);

	mov	ecx, DWORD PTR _pThisArmy$[esp+120]
	push	ecx
	push	esi
	mov	ecx, ebp
	call	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian

; 4138 : 									pCivilian->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4139 : 									pEscort->finishMoves();

	mov	ecx, DWORD PTR _pEscort$[esp+120]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4140 : 									if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN6@PlotSingle
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN6@PlotSingle

; 4141 : 									{
; 4142 : 										CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222252[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+128], 17		; 00000011H

; 4143 : 										strLogString.Format("Retargeting civilian escort operation. Too many blocking units.");

	push	OFFSET $SG222253
$LN588@PlotSingle:
	lea	edx, DWORD PTR _strLogString$222252[esp+124]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4144 : 										LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$222252[esp+124]
	push	eax
$LN589@PlotSingle:
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4145 : 									}

	lea	ecx, DWORD PTR _strLogString$222252[esp+120]
$LN587@PlotSingle:
	mov	BYTE PTR __$EHRec$[esp+128], 13		; 0000000dH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@PlotSingle:

; 4182 : 							}
; 4183 : 						}
; 4184 : 					}

	mov	ecx, DWORD PTR _pBlockingUnit$222232[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 1
	test	ecx, ecx
	je	$LN28@PlotSingle
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	$LN28@PlotSingle
$LN44@PlotSingle:

; 3926 : 	{
; 3927 : 		pEscort = m_pPlayer->getUnit(pThisArmy->GetNextUnitID());

	mov	ecx, ebx
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebx, eax
	mov	DWORD PTR _pEscort$[esp+120], ebx
	test	ebx, ebx
	je	$LN42@PlotSingle
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 3928 : 		if(!pEscort || pEscort->TurnProcessed())

	mov	ecx, ebx
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	$LN42@PlotSingle

; 3932 : 		}
; 3933 : 
; 3934 : 		// Check to make sure escort can get to civilian
; 3935 : 		if(pEscort->GeneratePath(pCivilian->plot()))

	push	0
	push	0
	push	0
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, ebx
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	je	$LN41@PlotSingle

; 3936 : 		{
; 3937 : 			// He can, so have civilian remain in place
; 3938 : 			ExecuteMoveToPlot(pCivilian, pCivilian->plot());

	push	0
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pCivilian$[esp+136]
	mov	ecx, esp
	mov	DWORD PTR $T272813[esp+132], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 3939 : 
; 3940 : 			if(pThisArmy->GetNumSlotsFilled() > 1)

	mov	ecx, DWORD PTR _pThisArmy$[esp+120]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jle	$LN28@PlotSingle

; 3941 : 			{
; 3942 : 				if(pEscort)
; 3943 : 				{
; 3944 : 					// Move escort over
; 3945 : 					ExecuteMoveToPlot(pEscort, pCivilian->plot());

	push	0
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	sub	esp, 8
	lea	eax, DWORD PTR _pEscort$[esp+136]
	mov	ecx, esp
	mov	DWORD PTR $T272814[esp+132], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 3946 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN28@PlotSingle
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN28@PlotSingle

; 3947 : 					{
; 3948 : 						CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222179[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3949 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222180[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3950 : 						strTemp = GC.getUnitInfo(pEscort->getUnitType())->GetDescription();

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+128], 3
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222179[esp+124]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 3951 : 						strLogString.Format("Moving escorting %s to civilian for operation, Civilian X: %d, Civilian Y: %d, X: %d, Y: %d", strTemp.GetCString(), pCivilian->plot()->getX(), pCivilian->plot()->getY(), pEscort->getX(), pEscort->getY());

	mov	ebp, DWORD PTR [ebx+88]
	mov	ebx, DWORD PTR [ebx+76]
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T273033[esp+116], ecx
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	eax, WORD PTR [eax]
	mov	edx, DWORD PTR $T273033[esp+116]
	push	ebp
	push	ebx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strTemp$222179[esp+136]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$222180[esp+140]
	push	OFFSET $SG222181
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 3952 : 						LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222180[esp+124]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 3953 : 					}

	mov	BYTE PTR __$EHRec$[esp+128], 2

; 3954 : 				}
; 3955 : 			}
; 3956 : 		}
; 3957 : 
; 3958 : 		// Find a new place to meet up, look at all hexes adjacent to civilian
; 3959 : 		else

	jmp	$LN586@PlotSingle
$LN41@PlotSingle:

; 3960 : 		{
; 3961 : 			for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$222183[esp+120], 0
$LN36@PlotSingle:

; 3962 : 			{
; 3963 : 				CvPlot* pPlot = plotDirection(pCivilian->getX(), pCivilian->getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _iI$222183[esp+120]
	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	edx
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	ebp, eax
	add	esp, 12					; 0000000cH

; 3964 : 				if(pPlot != NULL)

	test	ebp, ebp
	je	SHORT $LN35@PlotSingle

; 3965 : 				{
; 3966 : 					// Has to be somewhere we can move and be empty of other units
; 3967 : 					if(pEscort->canEnterTerrain(*pPlot) && pEscort->canEnterTerritory(pPlot->getTeam()))

	push	0
	push	ebp
	mov	ecx, ebx
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	test	al, al
	je	SHORT $LN35@PlotSingle
	push	0
	push	0
	push	0
	mov	ecx, ebp
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	push	eax
	mov	ecx, ebx
	call	?canEnterTerritory@CvUnit@@QBE_NW4TeamTypes@@_N11@Z ; CvUnit::canEnterTerritory
	test	al, al
	je	SHORT $LN35@PlotSingle

; 3968 : 					{
; 3969 : 						if(pPlot->getNumUnits() == 0)

	mov	ecx, ebp
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jne	SHORT $LN35@PlotSingle

; 3970 : 						{
; 3971 : 							if(pEscort->GeneratePath(pPlot) && pCivilian->GeneratePath(pPlot))

	push	eax
	push	eax
	push	eax
	push	ebp
	mov	ecx, ebx
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	je	SHORT $LN35@PlotSingle
	push	0
	push	0
	push	0
	push	ebp
	mov	ecx, esi
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	jne	$LN562@PlotSingle
$LN35@PlotSingle:

; 3960 : 		{
; 3961 : 			for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	eax, DWORD PTR _iI$222183[esp+120]
	inc	eax
	cmp	eax, 6
	mov	DWORD PTR _iI$222183[esp+120], eax
	jl	SHORT $LN36@PlotSingle

; 4001 : 							}
; 4002 : 						}
; 4003 : 					}
; 4004 : 				}
; 4005 : 			}
; 4006 : 
; 4007 : 			// Didn't find an alternative, must abort operation
; 4008 : 			pOperation->RetargetCivilian(pCivilian.pointer(), pThisArmy);

	mov	ecx, DWORD PTR _pThisArmy$[esp+120]
	push	ecx
	mov	ecx, DWORD PTR _pOperation$[esp+120]
	push	esi
	call	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian

; 4009 : 			pCivilian->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4010 : 			pEscort->finishMoves();

	mov	ecx, ebx
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4011 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN28@PlotSingle
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN28@PlotSingle

; 4012 : 			{
; 4013 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222201[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4014 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222202[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 6
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4015 : 				strLogString.Format("Retargeting civilian escort operation. No empty tile adjacent to civilian to meet.");

	lea	edx, DWORD PTR _strLogString$222202[esp+120]
	push	OFFSET $SG222203
	push	edx
	mov	BYTE PTR __$EHRec$[esp+136], 7
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4016 : 				LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$222202[esp+124]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4017 : 			}

	mov	BYTE PTR __$EHRec$[esp+128], 6
$LN586@PlotSingle:
	lea	ecx, DWORD PTR _strLogString$222202[esp+120]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$222201[esp+120]
$LN585@PlotSingle:
	mov	BYTE PTR __$EHRec$[esp+128], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN28@PlotSingle:

; 4185 : 				}
; 4186 : 			}
; 4187 : 		}
; 4188 : 	}
; 4189 : }

	mov	ecx, DWORD PTR _pEscort$[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 0
	test	ecx, ecx
	je	$LN135@PlotSingle
	jmp	$LN591@PlotSingle
$LN562@PlotSingle:

; 3972 : 							{
; 3973 : 								ExecuteMoveToPlot(pEscort, pPlot);

	push	0
	push	ebp
	sub	esp, 8
	lea	eax, DWORD PTR _pEscort$[esp+136]
	mov	ecx, esp
	mov	DWORD PTR $T272815[esp+132], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 3974 : 								ExecuteMoveToPlot(pCivilian, pPlot);

	push	0
	push	ebp
	sub	esp, 8
	lea	edx, DWORD PTR _pCivilian$[esp+136]
	mov	ecx, esp
	mov	DWORD PTR $T272816[esp+132], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 3975 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN29@PlotSingle
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN29@PlotSingle

; 3976 : 								{
; 3977 : #ifdef AUI_WARNING_FIXES
; 3978 : 									CvString strTemp = "";
; 3979 : 									CvString strLogString;
; 3980 : 									CvUnitEntry* pTempUnitInfo = GC.getUnitInfo(pEscort->getUnitType());
; 3981 : 									if (pTempUnitInfo)
; 3982 : 										strTemp = pTempUnitInfo->GetDescription();
; 3983 : #else
; 3984 : 									CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222196[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3985 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222197[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3986 : 									strTemp = GC.getUnitInfo(pEscort->getUnitType())->GetDescription();

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+128], 5
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222196[esp+124]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 3987 : #endif
; 3988 : 									strLogString.Format("Moving escorting %s to open hex, Open hex X: %d, Open hex Y: %d, X: %d, Y: %d", strTemp.GetCString(), pPlot->getX(), pPlot->getY(), pEscort->getX(), pEscort->getY());

	mov	eax, DWORD PTR [ebx+88]
	mov	ecx, DWORD PTR [ebx+76]
	movsx	edx, WORD PTR [ebp]
	push	eax
	movsx	eax, WORD PTR [ebp+2]
	push	ecx
	push	eax
	push	edx
	lea	ecx, DWORD PTR _strTemp$222196[esp+136]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$222197[esp+140]
	push	OFFSET $SG222198
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 3989 : 									LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222197[esp+124]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 3990 : #ifdef AUI_WARNING_FIXES
; 3991 : 									pTempUnitInfo = GC.getUnitInfo(pCivilian->getUnitType());
; 3992 : 									if (pTempUnitInfo)
; 3993 : 										strTemp = pTempUnitInfo->GetDescription();
; 3994 : #else
; 3995 : 									strTemp = GC.getUnitInfo(pCivilian->getUnitType())->GetDescription();

	mov	ecx, esi
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222196[esp+124]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 3996 : #endif
; 3997 : 									strLogString.Format("Moving %s to open hex, Open hex X: %d, Open hex Y: %d, X: %d, Y: %d", strTemp.GetCString(), pPlot->getX(), pPlot->getY(), pCivilian->getX(), pCivilian->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	movsx	edx, WORD PTR [ebp+2]
	movsx	ebp, WORD PTR [ebp]
	push	eax
	push	ecx
	push	edx
	push	ebp
	lea	ecx, DWORD PTR _strTemp$222196[esp+136]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$222197[esp+140]
	push	OFFSET $SG222199
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 3998 : 									LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$222197[esp+124]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 3999 : 								}

	lea	ecx, DWORD PTR _strLogString$222197[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$222196[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN29@PlotSingle:

; 4000 : 								return;

	mov	BYTE PTR __$EHRec$[esp+128], 0
	jmp	SHORT $LN590@PlotSingle
$LN42@PlotSingle:

; 3929 : 		{
; 3930 : 			// Escort died or was poached for other tactical action, operation will clean itself up when call CheckOnTarget()
; 3931 : 			return;

	mov	BYTE PTR __$EHRec$[esp+128], 0
	test	ebx, ebx
	je	SHORT $LN135@PlotSingle
$LN590@PlotSingle:
	mov	ecx, ebx
$LN591@PlotSingle:
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN135@PlotSingle:
	mov	DWORD PTR __$EHRec$[esp+128], -1
$LN584@PlotSingle:
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN140@PlotSingle:

; 4185 : 				}
; 4186 : 			}
; 4187 : 		}
; 4188 : 	}
; 4189 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+120]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 104				; 00000068H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$0:
	lea	ecx, DWORD PTR _pCivilian$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$1:
	lea	ecx, DWORD PTR _pEscort$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$12:
	lea	ecx, DWORD PTR _strLogString$222211[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$14:
	lea	ecx, DWORD PTR _strLogString$222217[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$15:
	lea	ecx, DWORD PTR _strTemp$222218[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$19:
	lea	ecx, DWORD PTR _strLogString$222226[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$20:
	lea	ecx, DWORD PTR _strTemp$222227[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$21:
	lea	ecx, DWORD PTR _pBlockingUnit$222232[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$32:
	lea	ecx, DWORD PTR _strLogString$222260[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$33:
	lea	ecx, DWORD PTR _strTemp$222261[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$34:
	lea	ecx, DWORD PTR _strLogString$222266[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$22:
	lea	ecx, DWORD PTR _strLogString$222238[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$26:
	lea	ecx, DWORD PTR _strLogString$222246[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$27:
	lea	ecx, DWORD PTR _strTemp$222247[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$28:
	lea	ecx, DWORD PTR _strLogString$222252[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$4:
	lea	ecx, DWORD PTR _strTemp$222179[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$5:
	lea	ecx, DWORD PTR _strLogString$222180[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$10:
	lea	ecx, DWORD PTR _strTemp$222201[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$11:
	lea	ecx, DWORD PTR _strLogString$222202[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$8:
	lea	ecx, DWORD PTR _strTemp$222196[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z$9:
	lea	ecx, DWORD PTR _strLogString$222197[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z ENDP ; CvTacticalAI::PlotSingleHexOperationMoves
PUBLIC	?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ ; CvTacticalAI::ExecuteBarbarianCivilianEscortMove
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	017H
	DD	FLAT:__unwindtable$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$4
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$9
	DD	05H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$10
	DD	04H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$12
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$13
	DD	04H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$15
	DD	09H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$16
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$18
	DD	0bH
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$19
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$23
	DD	0dH
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$24
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$25
	DD	0fH
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$26
	DD	0fH
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$30
	DD	011H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$31
	DD	0fH
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$32
	DD	0fH
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$36
	DD	014H
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$37
	DD	0fH
	DD	FLAT:__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$38
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
$T273778 = -160						; size = 4
$T273777 = -160						; size = 4
$T273776 = -160						; size = 4
$T273775 = -160						; size = 4
$T273774 = -160						; size = 4
$T273773 = -160						; size = 4
$T273772 = -160						; size = 4
$T273771 = -160						; size = 4
$T273770 = -160						; size = 4
$T273769 = -160						; size = 4
$T273768 = -160						; size = 4
$T273767 = -160						; size = 4
$T273766 = -160						; size = 4
$T273765 = -160						; size = 4
$T273764 = -160						; size = 4
_pCivilianMove$ = -160					; size = 4
_pCurrent$ = -160					; size = 4
$T273762 = -160						; size = 4
_strLogString$223989 = -156				; size = 28
_strLogString$223980 = -156				; size = 28
_strLogString$223975 = -156				; size = 28
_strLogString$223966 = -156				; size = 28
_strLogString$223956 = -156				; size = 28
_strLogString$223947 = -156				; size = 28
_strLogString$223940 = -156				; size = 28
_strLogString$223934 = -156				; size = 28
_strTemp$223926 = -156					; size = 28
_strLogString$223912 = -156				; size = 28
tv2155 = -128						; size = 4
_iJ$223901 = -128					; size = 4
_strTemp$223988 = -124					; size = 28
_strTemp$223974 = -124					; size = 28
_strTemp$223955 = -124					; size = 28
_strTemp$223946 = -124					; size = 28
_strTemp$223939 = -124					; size = 28
_strTemp$223933 = -124					; size = 28
_strLogString$223927 = -124				; size = 28
_pTarget$ = -96						; size = 4
tv2301 = -92						; size = 4
_pCivilian$ = -88					; size = 8
_iI$223891 = -80					; size = 4
_pCampDefender$223916 = -76				; size = 8
_pEscort$ = -68						; size = 8
_pBlockingUnit$223960 = -60				; size = 8
$T273763 = -52						; size = 8
_strLogString$223994 = -44				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ PROC ; CvTacticalAI::ExecuteBarbarianCivilianEscortMove, COMDAT
; _this$ = ecx

; 6955 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	ebp
	push	esi

; 6956 : 	UnitHandle pCivilian;

	xor	ebx, ebx
	push	edi
	mov	edi, ecx
	xor	esi, esi
	mov	DWORD PTR _pCivilian$[esp+176], ebx
	mov	BYTE PTR _pCivilian$[esp+180], bl

; 6957 : 	UnitHandle pEscort;

	xor	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+184], esi
	mov	DWORD PTR _pEscort$[esp+176], ebp
	mov	BYTE PTR _pEscort$[esp+180], 0

; 6958 : 	CvPlot* pTarget;
; 6959 : 	CvPlot* pCurrent;
; 6960 : 	CvPlot* pCivilianMove;
; 6961 : 	CvPlot* pEscortMove;
; 6962 : 	CvUnit* pLoopUnit;
; 6963 : 
; 6964 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	BYTE PTR __$EHRec$[esp+184], 1
	mov	DWORD PTR _iI$223891[esp+176], esi
	je	$LN46@ExecuteBar@3

; 6956 : 	UnitHandle pCivilian;

	mov	DWORD PTR tv2301[esp+176], esi
$LL48@ExecuteBar@3:

; 6965 : 	{
; 6966 : 		pCivilian = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [edi+24]
	add	eax, DWORD PTR tv2301[esp+176]
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	test	ebx, ebx
	je	SHORT $LN104@ExecuteBar@3
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN104@ExecuteBar@3:
	mov	DWORD PTR _pCivilian$[esp+176], esi
	test	esi, esi
	je	$LN47@ExecuteBar@3
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 6967 : 		if(pCivilian)
; 6968 : 		{
; 6969 : 			pTarget = FindNearbyTarget(pCivilian, MAX_INT, AI_TACTICAL_TARGET_BARBARIAN_CAMP, pCivilian.pointer());

	push	esi
	push	2
	push	2147483647				; 7fffffffH
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T273762[esp+196], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?FindNearbyTarget@CvTacticalAI@@AAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@HW4AITacticalTargetType@@PAVCvUnit@@@Z ; CvTacticalAI::FindNearbyTarget
	mov	DWORD PTR _pTarget$[esp+176], eax

; 6970 : 			if(pTarget)

	test	eax, eax
	je	$LN47@ExecuteBar@3

; 6971 : 			{
; 6972 : 				// If we're not there yet, we have work to do
; 6973 : 				pCurrent = pCivilian->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebx, eax
	mov	DWORD PTR _pCurrent$[esp+176], ebx

; 6974 : 				if(pCurrent == pTarget)

	cmp	ebx, DWORD PTR _pTarget$[esp+176]
	jne	SHORT $LN43@ExecuteBar@3

; 6975 : 				{
; 6976 : 					pCivilian->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6977 : 					UnitProcessed(pCivilian->GetID());

	mov	esi, DWORD PTR [esi+100]
	push	1
	push	esi
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 6978 : 				}
; 6979 : #ifdef AUI_WARNING_FIXES
; 6980 : 				else if (pCurrent)
; 6981 : #else
; 6982 : 				else

	jmp	$LN47@ExecuteBar@3
$LN43@ExecuteBar@3:

; 6983 : #endif
; 6984 : 				{
; 6985 : 					if(pCurrent->getNumUnits() > 1)

	mov	ecx, ebx
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	eax, 1
	jle	$LN164@ExecuteBar@3

; 6986 : 					{
; 6987 : #ifdef AUI_WARNING_FIXES
; 6988 : 						for (uint iJ = 0; iJ < pCurrent->getNumUnits(); iJ++)
; 6989 : #else
; 6990 : 						for(int iJ = 0; iJ < pCurrent->getNumUnits(); iJ++)

	mov	ecx, ebx
	mov	DWORD PTR _iJ$223901[esp+176], 0
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	$LN164@ExecuteBar@3
	jmp	SHORT $LN40@ExecuteBar@3
	npad	7
$LL608@ExecuteBar@3:
	mov	ebx, DWORD PTR _pCurrent$[esp+176]
$LN40@ExecuteBar@3:

; 6991 : #endif
; 6992 : 						{
; 6993 : 							pLoopUnit = pCurrent->getUnitByIndex(iJ);

	mov	ecx, DWORD PTR _iJ$223901[esp+176]
	push	ecx
	mov	ecx, ebx
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	ebx, eax

; 6994 : 							if(pLoopUnit->GetID() != pCivilian->GetID() &&
; 6995 : 							        pLoopUnit->getOwner() == pCivilian->getOwner())

	mov	eax, DWORD PTR [ebx+100]
	cmp	eax, DWORD PTR [esi+100]
	je	SHORT $LN39@ExecuteBar@3
	mov	eax, DWORD PTR [ebx+40]
	cmp	eax, DWORD PTR [esi+40]
	je	SHORT $LN597@ExecuteBar@3
$LN39@ExecuteBar@3:

; 6986 : 					{
; 6987 : #ifdef AUI_WARNING_FIXES
; 6988 : 						for (uint iJ = 0; iJ < pCurrent->getNumUnits(); iJ++)
; 6989 : #else
; 6990 : 						for(int iJ = 0; iJ < pCurrent->getNumUnits(); iJ++)

	mov	ebx, DWORD PTR _iJ$223901[esp+176]
	mov	ecx, DWORD PTR _pCurrent$[esp+176]
	inc	ebx
	mov	DWORD PTR _iJ$223901[esp+176], ebx
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	ebx, eax
	jl	SHORT $LL608@ExecuteBar@3

; 6994 : 							if(pLoopUnit->GetID() != pCivilian->GetID() &&
; 6995 : 							        pLoopUnit->getOwner() == pCivilian->getOwner())

	jmp	SHORT $LN164@ExecuteBar@3
$LN597@ExecuteBar@3:

; 6996 : 							{
; 6997 : 								pEscort = UnitHandle(pLoopUnit);

	mov	ecx, ebx
	mov	DWORD PTR $T273763[esp+176], ebx
	mov	BYTE PTR $T273763[esp+180], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	BYTE PTR __$EHRec$[esp+184], 2
	test	ebp, ebp
	je	SHORT $LN157@ExecuteBar@3
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN157@ExecuteBar@3:
	mov	ebp, ebx
	mov	ecx, ebx
	mov	DWORD PTR _pEscort$[esp+176], ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+184], 1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN164@ExecuteBar@3:

; 6998 : 								break;
; 6999 : 							}
; 7000 : 						}
; 7001 : 					}
; 7002 : 
; 7003 : 					// Look at where we'd move this turn taking units into consideration
; 7004 : 					int iFlags = 0;

	xor	eax, eax

; 7005 : 					if(pEscort)

	test	ebp, ebp
	je	SHORT $LN36@ExecuteBar@3

; 7006 : 					{
; 7007 : 						iFlags = MOVE_UNITS_IGNORE_DANGER;

	mov	eax, 8
$LN36@ExecuteBar@3:

; 7008 : 					}
; 7009 : 
; 7010 : 					// Handle case of no path found at all for civilian
; 7011 : 					if(!pCivilian->GeneratePath(pTarget, iFlags, false /*bReuse*/))

	mov	ebx, DWORD PTR _pTarget$[esp+176]
	push	0
	push	0
	push	eax
	push	ebx
	mov	ecx, esi
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath

; 7012 : 					{
; 7013 : 						pCivilian->finishMoves();

	mov	ecx, esi
	test	al, al
	jne	$LN35@ExecuteBar@3
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 7014 : 						if(pEscort)

	test	ebp, ebp
	je	SHORT $LN34@ExecuteBar@3

; 7015 : 						{
; 7016 : 							pEscort->finishMoves();

	mov	ecx, ebp
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN34@ExecuteBar@3:

; 7017 : 						}
; 7018 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN47@ExecuteBar@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN47@ExecuteBar@3

; 7019 : 						{
; 7020 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223912[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7021 : 							strLogString.Format("Retargeting civilian escort operation (path lost to target), X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	movsx	edx, WORD PTR [ebx+2]
	movsx	eax, WORD PTR [ebx]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strLogString$223912[esp+184]
	push	OFFSET $SG223913
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+200], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 7022 : 							LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$223912[esp+180]
	push	edx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7023 : 						}

	lea	ecx, DWORD PTR _strLogString$223912[esp+176]

; 7112 : 								}

	mov	BYTE PTR __$EHRec$[esp+184], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7113 : 							}
; 7114 : 
; 7115 : 							else

	jmp	$LN47@ExecuteBar@3
$LN35@ExecuteBar@3:

; 7024 : 					}
; 7025 : 
; 7026 : 					else
; 7027 : 					{
; 7028 : 						pCivilianMove = pCivilian->GetPathEndTurnPlot();

	call	?GetPathEndTurnPlot@CvUnit@@QBEPAVCvPlot@@XZ ; CvUnit::GetPathEndTurnPlot
	mov	ebx, eax
	mov	DWORD PTR _pCivilianMove$[esp+176], ebx

; 7029 : 
; 7030 : 						// Can we reach our target this turn?
; 7031 : 						if(pCivilianMove == pTarget)
; 7032 : 						{
; 7033 : 							// See which defender is stronger
; 7034 : 							UnitHandle pCampDefender = pCivilianMove->getBestDefender(m_pPlayer->GetID());

	push	0
	cmp	ebx, DWORD PTR _pTarget$[esp+180]
	jne	$LN31@ExecuteBar@3
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	eax
	lea	ecx, DWORD PTR _pCampDefender$223916[esp+204]
	push	ecx
	mov	ecx, ebx
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender

; 7035 : 							if(!pCampDefender || (pEscort && pEscort->GetPower() > pCampDefender->GetPower()))

	mov	ecx, DWORD PTR _pCampDefender$223916[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 4
	test	ecx, ecx
	je	$LN29@ExecuteBar@3
	test	ebp, ebp
	je	SHORT $LN30@ExecuteBar@3
	mov	ebx, ecx
	mov	ecx, ebp
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	mov	ecx, ebx
	mov	DWORD PTR tv2155[esp+176], eax
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	mov	ecx, DWORD PTR tv2155[esp+176]
	cmp	ecx, eax
	mov	ebx, DWORD PTR _pCivilianMove$[esp+176]
	jg	$LN600@ExecuteBar@3
$LN30@ExecuteBar@3:

; 7064 : 								}
; 7065 : 							}
; 7066 : 							else
; 7067 : 							{
; 7068 : 								ExecuteMoveToPlot(pCivilian, pCivilianMove);

	push	0
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T273768[esp+192], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 7069 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN24@ExecuteBar@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN24@ExecuteBar@3

; 7070 : 								{
; 7071 : 									CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223939[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7072 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223940[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 9
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7073 : 									strTemp = pCivilian->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+184], 10		; 0000000aH
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$223939[esp+180]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 7074 : 									strLogString.Format("Moving %s to camp, X: %d, Y: %d", strTemp.GetCString(), pCivilian->getX(), pCivilian->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	eax
	push	esi
	lea	ecx, DWORD PTR _strTemp$223939[esp+184]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$223940[esp+188]
	push	OFFSET $SG223941
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 7075 : 									LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$223940[esp+180]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7076 : 								}

	mov	BYTE PTR __$EHRec$[esp+184], 9
	jmp	$LN611@ExecuteBar@3
$LN600@ExecuteBar@3:
	mov	ecx, DWORD PTR _pCampDefender$223916[esp+176]
$LN29@ExecuteBar@3:

; 7036 : 							{
; 7037 : 								if(pEscort && (!pCampDefender || ExecuteMoveOfBlockingUnit(pCampDefender)))

	test	ebp, ebp
	je	$LN28@ExecuteBar@3
	test	ecx, ecx
	je	SHORT $LN27@ExecuteBar@3
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	cl, BYTE PTR _pCampDefender$223916[esp+188]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T273764[esp+184], esp
	test	eax, eax
	je	SHORT $LN207@ExecuteBar@3
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN207@ExecuteBar@3:
	mov	ecx, edi
	call	?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::ExecuteMoveOfBlockingUnit
	test	al, al
	je	$LN28@ExecuteBar@3
$LN27@ExecuteBar@3:

; 7038 : 								{
; 7039 : 									ExecuteMoveToPlot(pEscort, pCivilianMove);

	push	0
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, ebp
	mov	DWORD PTR $T273765[esp+192], esp
	mov	DWORD PTR [eax], ebp
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 7040 : 									ExecuteMoveToPlot(pCivilian, pCivilianMove);

	push	0
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T273766[esp+192], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 7041 : 									if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN24@ExecuteBar@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN24@ExecuteBar@3

; 7042 : 									{
; 7043 : 										CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223926[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7044 : 										CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223927[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 5
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7045 : 										strTemp = pEscort->getUnitInfo().GetDescription();

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+184], 6
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$223926[esp+180]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 7046 : 										strLogString.Format("Moving escorting %s to take over camp defense, X: %d, Y: %d", strTemp.GetCString(), pEscort->getX(), pEscort->getY());

	mov	eax, DWORD PTR [ebp+88]
	mov	ecx, DWORD PTR [ebp+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$223926[esp+184]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$223927[esp+188]
	push	OFFSET $SG223928
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 7047 : 										LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$223927[esp+180]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7048 : 										strTemp = pCivilian->getUnitInfo().GetDescription();

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$223926[esp+180]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 7049 : 										strLogString.Format("Moving %s to camp, X: %d, Y: %d", strTemp.GetCString(), pCivilian->getX(), pCivilian->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	eax
	push	esi
	lea	ecx, DWORD PTR _strTemp$223926[esp+184]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$223927[esp+188]
	push	OFFSET $SG223929
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 7050 : 										LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$223927[esp+180]
	push	edx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7051 : 									}

	lea	ecx, DWORD PTR _strLogString$223927[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$223926[esp+176]

; 7063 : 									}

	mov	BYTE PTR __$EHRec$[esp+184], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7077 : 							}
; 7078 : 						}

	mov	ecx, DWORD PTR _pCampDefender$223916[esp+176]
	jmp	$LN614@ExecuteBar@3
$LN28@ExecuteBar@3:

; 7052 : 								}
; 7053 : 								else
; 7054 : 								{
; 7055 : 									ExecuteMoveToPlot(pCivilian, pCivilianMove);

	push	0
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T273767[esp+192], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 7056 : 									if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN24@ExecuteBar@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN24@ExecuteBar@3

; 7057 : 									{
; 7058 : 										CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223933[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7059 : 										CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223934[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 7
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7060 : 										strTemp = pCivilian->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+184], 8
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$223933[esp+180]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 7061 : 										strLogString.Format("Moving %s to camp, X: %d, Y: %d", strTemp.GetCString(), pCivilian->getX(), pCivilian->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	eax
	push	esi
	lea	ecx, DWORD PTR _strTemp$223933[esp+184]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$223934[esp+188]
	push	OFFSET $SG223935
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 7062 : 										LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$223934[esp+180]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7063 : 									}

	mov	BYTE PTR __$EHRec$[esp+184], 7
$LN611@ExecuteBar@3:
	lea	ecx, DWORD PTR _strLogString$223934[esp+176]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$223933[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN24@ExecuteBar@3:

; 7077 : 							}
; 7078 : 						}

	mov	ecx, DWORD PTR _pCampDefender$223916[esp+176]
	jmp	$LN614@ExecuteBar@3
$LN31@ExecuteBar@3:

; 7079 : 
; 7080 : 						// Can't reach target and don't have escort...
; 7081 : 						else if(!pEscort)

	test	ebp, ebp
	jne	$LN20@ExecuteBar@3

; 7082 : 						{
; 7083 : 							ExecuteMoveToPlot(pCivilian, pCivilianMove);

	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T273769[esp+192], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 7084 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN47@ExecuteBar@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN47@ExecuteBar@3

; 7085 : 							{
; 7086 : 								CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223946[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7087 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223947[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 11		; 0000000bH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7088 : 								strTemp = pCivilian->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+184], 12		; 0000000cH
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$223946[esp+180]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 7089 : 								strLogString.Format("Moving %s without escort to target, X: %d, Y: %d", strTemp.GetCString(), pCivilian->plot()->getX(), pCivilian->plot()->getY());

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	ebx, WORD PTR [eax+2]
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	eax, WORD PTR [eax]
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _strTemp$223946[esp+184]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$223947[esp+188]
	push	OFFSET $SG223948
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 7090 : 								LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$223947[esp+180]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7091 : 							}

	mov	BYTE PTR __$EHRec$[esp+184], 11		; 0000000bH

; 7092 : 						}
; 7093 : 
; 7094 : 						// Can't reach target and DO have escort...
; 7095 : 						else

	jmp	$LN617@ExecuteBar@3
$LN20@ExecuteBar@3:

; 7096 : 						{
; 7097 : 							// See if escort can move to the same location in one turn
; 7098 : 							if(TurnsToReachTarget(pEscort, pCivilianMove) <= 1)

	push	0
	push	0
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, ebp
	mov	DWORD PTR $T273770[esp+200], esp
	mov	DWORD PTR [eax], ebp
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	cmp	eax, 1

; 7099 : 							{
; 7100 : 								ExecuteMoveToPlot(pEscort, pCivilianMove);

	push	0
	jg	$LN17@ExecuteBar@3
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, ebp
	mov	DWORD PTR $T273771[esp+192], esp
	mov	DWORD PTR [eax], ebp
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 7101 : 								ExecuteMoveToPlot(pCivilian, pCivilianMove);

	push	0
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T273772[esp+192], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 7102 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN47@ExecuteBar@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN47@ExecuteBar@3

; 7103 : 								{
; 7104 : 									CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223955[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7105 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223956[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 13		; 0000000dH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7106 : 									strTemp = pEscort->getUnitInfo().GetDescription();

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+184], 14		; 0000000eH
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$223955[esp+180]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 7107 : 									strLogString.Format("Moving escorting %s to target, X: %d, Y: %d", strTemp.GetCString(), pEscort->getX(), pEscort->getY());

	mov	eax, DWORD PTR [ebp+88]
	mov	ecx, DWORD PTR [ebp+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$223955[esp+184]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$223956[esp+188]
	push	OFFSET $SG223957
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 7108 : 									LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$223956[esp+180]
	push	edx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7109 : 									strTemp = pCivilian->getUnitInfo().GetDescription();

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$223955[esp+180]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 7110 : 									strLogString.Format("Moving %s to target, X: %d, Y: %d", strTemp.GetCString(), pCivilian->getX(), pCivilian->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	eax
	push	esi
	lea	ecx, DWORD PTR _strTemp$223955[esp+184]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$223956[esp+188]
	push	OFFSET $SG223958
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 7111 : 									LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$223956[esp+180]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7112 : 								}

	mov	BYTE PTR __$EHRec$[esp+184], 13		; 0000000dH
$LN617@ExecuteBar@3:
	lea	ecx, DWORD PTR _strLogString$223956[esp+176]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$223955[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7113 : 							}
; 7114 : 
; 7115 : 							else

	jmp	$LN47@ExecuteBar@3
$LN17@ExecuteBar@3:

; 7116 : 							{
; 7117 : 								UnitHandle pBlockingUnit = pCivilianMove->getBestDefender(m_pPlayer->GetID());

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+44]
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	eax
	lea	eax, DWORD PTR _pBlockingUnit$223960[esp+204]
	push	eax
	mov	ecx, ebx
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender

; 7118 : 
; 7119 : 								// See if friendly blocking unit is ending the turn there, or if no blocking unit (which indicates this is somewhere civilian
; 7120 : 								// can move that escort can't), then find a new path based on moving the escort
; 7121 : 								if(!pBlockingUnit || pBlockingUnit->getMoves() == 0)

	mov	ecx, DWORD PTR _pBlockingUnit$223960[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 15		; 0000000fH
	test	ecx, ecx
	je	$LN13@ExecuteBar@3
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	je	$LN13@ExecuteBar@3

; 7165 : 										}
; 7166 : 									}
; 7167 : 								}
; 7168 : 
; 7169 : 								// Looks like we should be able to move the blocking unit out of the way
; 7170 : 								else
; 7171 : 								{
; 7172 : 									if(ExecuteMoveOfBlockingUnit(pBlockingUnit))

	sub	esp, 8
	lea	edx, DWORD PTR _pBlockingUnit$223960[esp+184]
	mov	ecx, esp
	mov	DWORD PTR $T273776[esp+184], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::ExecuteMoveOfBlockingUnit
	test	al, al
	je	$LN4@ExecuteBar@3

; 7173 : 									{
; 7174 : 										ExecuteMoveToPlot(pEscort, pCivilianMove);

	push	0
	push	ebx
	sub	esp, 8
	lea	eax, DWORD PTR _pEscort$[esp+192]
	mov	ecx, esp
	mov	DWORD PTR $T273777[esp+192], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 7175 : 										ExecuteMoveToPlot(pCivilian, pCivilianMove);

	push	0
	push	ebx
	sub	esp, 8
	lea	edx, DWORD PTR _pCivilian$[esp+192]
	mov	ecx, esp
	mov	DWORD PTR $T273778[esp+192], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 7176 : 										if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@ExecuteBar@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@ExecuteBar@3

; 7177 : 										{
; 7178 : 											CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223988[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7179 : 											CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223989[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 20		; 00000014H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7180 : 											strTemp = pEscort->getUnitInfo().GetDescription();

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+184], 21		; 00000015H
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$223988[esp+180]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 7181 : 											strLogString.Format("Moving escorting %s to target, X: %d, Y: %d", strTemp.GetCString(), pEscort->getX(), pEscort->getY());

	mov	eax, DWORD PTR [ebp+88]
	mov	ecx, DWORD PTR [ebp+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$223988[esp+184]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$223989[esp+188]
	push	OFFSET $SG223990
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 7182 : 											LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$223989[esp+180]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7183 : 											strTemp = pCivilian->getUnitInfo().GetDescription();

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$223988[esp+180]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 7184 : 											strLogString.Format("Moving %s to target, X: %d, Y: %d", strTemp.GetCString(), pCivilian->getX(), pCivilian->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	eax
	push	esi
	lea	ecx, DWORD PTR _strTemp$223988[esp+184]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$223989[esp+188]
	push	OFFSET $SG223991
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 7185 : 											LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$223989[esp+180]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7186 : 										}

	lea	ecx, DWORD PTR _strLogString$223989[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 20		; 00000014H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$223988[esp+176]

; 7187 : 									}
; 7188 : 									else

	jmp	$LN615@ExecuteBar@3
$LN4@ExecuteBar@3:

; 7189 : 									{
; 7190 : 										pCivilian->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 7191 : 										pEscort->finishMoves();

	mov	ecx, ebp
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 7192 : 										if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@ExecuteBar@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@ExecuteBar@3

; 7193 : 										{
; 7194 : 											CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223994[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7195 : 											strLogString.Format("Retargeting civilian escort operation. Could not move blocking unit.");

	lea	ecx, DWORD PTR _strLogString$223994[esp+176]
	push	OFFSET $SG223995
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+192], 22		; 00000016H
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 7196 : 											LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$223994[esp+180]
	push	edx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7197 : 										}

	lea	ecx, DWORD PTR _strLogString$223994[esp+176]
	jmp	$LN615@ExecuteBar@3
$LN13@ExecuteBar@3:

; 7122 : 								{
; 7123 : 									if(!pEscort->GeneratePath(pTarget, 0, false /*bReuse*/))

	mov	ebx, DWORD PTR _pTarget$[esp+176]
	push	0
	push	0
	push	0
	push	ebx
	mov	ecx, ebp
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath

; 7124 : 									{
; 7125 : 										pCivilian->finishMoves();

	mov	ecx, esi
	test	al, al
	jne	SHORT $LN12@ExecuteBar@3
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 7126 : 										pEscort->finishMoves();

	mov	ecx, ebp
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 7127 : 										if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@ExecuteBar@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@ExecuteBar@3

; 7128 : 										{
; 7129 : 											CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223966[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7130 : 											strLogString.Format("Retargeting civilian escort operation (path lost to target), X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$223966[esp+184]
	push	OFFSET $SG223967
	push	edx
	mov	BYTE PTR __$EHRec$[esp+200], 16		; 00000010H
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 7131 : 											LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$223966[esp+180]
	push	eax

; 7132 : 										}
; 7133 : 									}
; 7134 : 									else

	jmp	$LN616@ExecuteBar@3
$LN12@ExecuteBar@3:

; 7135 : 									{
; 7136 : 										pEscortMove = pCivilian->GetPathEndTurnPlot();

	call	?GetPathEndTurnPlot@CvUnit@@QBEPAVCvPlot@@XZ ; CvUnit::GetPathEndTurnPlot

; 7137 : 
; 7138 : 										// See if civilian can move to the same location in one turn
; 7139 : 										if(TurnsToReachTarget(pCivilian, pEscortMove) <= 1)

	push	0
	push	0
	push	0
	mov	ebx, eax
	push	ebx
	sub	esp, 8
	lea	edx, DWORD PTR _pCivilian$[esp+200]
	mov	ecx, esp
	mov	DWORD PTR $T273773[esp+200], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jg	$LN9@ExecuteBar@3

; 7140 : 										{
; 7141 : 											ExecuteMoveToPlot(pEscort, pEscortMove);

	push	0
	push	ebx
	sub	esp, 8
	lea	eax, DWORD PTR _pEscort$[esp+192]
	mov	ecx, esp
	mov	DWORD PTR $T273774[esp+192], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 7142 : 											ExecuteMoveToPlot(pCivilian, pEscortMove);

	push	0
	push	ebx
	sub	esp, 8
	lea	edx, DWORD PTR _pCivilian$[esp+192]
	mov	ecx, esp
	mov	DWORD PTR $T273775[esp+192], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 7143 : 											if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@ExecuteBar@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@ExecuteBar@3

; 7144 : 											{
; 7145 : 												CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223974[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7146 : 												CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223975[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 17		; 00000011H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7147 : 												strTemp = pEscort->getUnitInfo().GetDescription();

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+184], 18		; 00000012H
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$223974[esp+180]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 7148 : 												strLogString.Format("Moving escorting %s to target, X: %d, Y: %d", strTemp.GetCString(), pEscort->getX(), pEscort->getY());

	mov	eax, DWORD PTR [ebp+88]
	mov	ecx, DWORD PTR [ebp+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$223974[esp+184]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$223975[esp+188]
	push	OFFSET $SG223976
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 7149 : 												LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$223975[esp+180]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7150 : 												strTemp = pCivilian->getUnitInfo().GetDescription();

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$223974[esp+180]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 7151 : 												strLogString.Format("Moving %s to target, X: %d, Y: %d", strTemp.GetCString(), pCivilian->getX(), pCivilian->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	eax
	push	esi
	lea	ecx, DWORD PTR _strTemp$223974[esp+184]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$223975[esp+188]
	push	OFFSET $SG223977
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 7152 : 												LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$223975[esp+180]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7153 : 											}

	lea	ecx, DWORD PTR _strLogString$223975[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 17		; 00000011H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$223974[esp+176]

; 7154 : 										}
; 7155 : 										else

	jmp	SHORT $LN615@ExecuteBar@3
$LN9@ExecuteBar@3:

; 7156 : 										{
; 7157 : 											pCivilian->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 7158 : 											pEscort->finishMoves();

	mov	ecx, ebp
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 7159 : 											if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN6@ExecuteBar@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN6@ExecuteBar@3

; 7160 : 											{
; 7161 : 												CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223980[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7162 : 												strLogString.Format("Retargeting civilian escort operation. Too many blocking units.");

	lea	ecx, DWORD PTR _strLogString$223980[esp+176]
	push	OFFSET $SG223981
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+192], 19		; 00000013H
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 7163 : 												LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$223980[esp+180]
	push	edx
$LN616@ExecuteBar@3:
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7164 : 											}

	lea	ecx, DWORD PTR _strLogString$223980[esp+176]
$LN615@ExecuteBar@3:
	mov	BYTE PTR __$EHRec$[esp+184], 15		; 0000000fH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@ExecuteBar@3:

; 7198 : 									}
; 7199 : 								}
; 7200 : 							}

	mov	ecx, DWORD PTR _pBlockingUnit$223960[esp+176]
$LN614@ExecuteBar@3:
	mov	BYTE PTR __$EHRec$[esp+184], 1
	test	ecx, ecx
	je	SHORT $LN47@ExecuteBar@3
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN47@ExecuteBar@3:

; 6958 : 	CvPlot* pTarget;
; 6959 : 	CvPlot* pCurrent;
; 6960 : 	CvPlot* pCivilianMove;
; 6961 : 	CvPlot* pEscortMove;
; 6962 : 	CvUnit* pLoopUnit;
; 6963 : 
; 6964 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	esi, DWORD PTR _iI$223891[esp+176]
	add	DWORD PTR tv2301[esp+176], 24		; 00000018H
	mov	ebx, DWORD PTR _pCivilian$[esp+176]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	esi
	add	eax, edx
	mov	DWORD PTR _iI$223891[esp+176], esi
	cmp	esi, eax
	jb	$LL48@ExecuteBar@3
	xor	esi, esi
$LN46@ExecuteBar@3:

; 7201 : 						}
; 7202 : 					}
; 7203 : 				}
; 7204 : 			}
; 7205 : 		}
; 7206 : 	}
; 7207 : }

	mov	BYTE PTR __$EHRec$[esp+184], 0
	cmp	ebp, esi
	je	SHORT $LN588@ExecuteBar@3
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN588@ExecuteBar@3:
	mov	DWORD PTR __$EHRec$[esp+184], -1
	cmp	ebx, esi
	je	SHORT $LN593@ExecuteBar@3
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN593@ExecuteBar@3:
	mov	ecx, DWORD PTR __$EHRec$[esp+176]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pCivilian$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pEscort$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR $T273763[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$223912[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _pCampDefender$223916[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$15:
	lea	ecx, DWORD PTR _strTemp$223939[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$16:
	lea	ecx, DWORD PTR _strLogString$223940[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR _strTemp$223926[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$10:
	lea	ecx, DWORD PTR _strLogString$223927[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$12:
	lea	ecx, DWORD PTR _strTemp$223933[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$13:
	lea	ecx, DWORD PTR _strLogString$223934[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$18:
	lea	ecx, DWORD PTR _strTemp$223946[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$19:
	lea	ecx, DWORD PTR _strLogString$223947[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$23:
	lea	ecx, DWORD PTR _strTemp$223955[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$24:
	lea	ecx, DWORD PTR _strLogString$223956[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$25:
	lea	ecx, DWORD PTR _pBlockingUnit$223960[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$36:
	lea	ecx, DWORD PTR _strTemp$223988[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$37:
	lea	ecx, DWORD PTR _strLogString$223989[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$38:
	lea	ecx, DWORD PTR _strLogString$223994[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$26:
	lea	ecx, DWORD PTR _strLogString$223966[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$30:
	lea	ecx, DWORD PTR _strTemp$223974[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$31:
	lea	ecx, DWORD PTR _strLogString$223975[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$32:
	lea	ecx, DWORD PTR _strLogString$223980[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ ENDP ; CvTacticalAI::ExecuteBarbarianCivilianEscortMove
PUBLIC	?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z$0
__ehfuncinfo$?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z
_TEXT	SEGMENT
_pUnit$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
_bSaveMoves$ = 12					; size = 1
$T274771 = 12						; size = 4
?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z PROC ; CvTacticalAI::ExecuteMoveToPlot, COMDAT
; _this$ = ecx

; 7211 : {

	push	-1
	push	__ehhandler$?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 7212 : 	// Move first one to target
; 7213 : 	UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$[esp+28], esi
	mov	BYTE PTR _pUnit$[esp+32], 0
	test	esi, esi
	je	SHORT $LN13@ExecuteMov@4
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN13@ExecuteMov@4:
	mov	DWORD PTR __$EHRec$[esp+36], 0

; 7214 : 	if(pUnit)

	test	esi, esi
	je	SHORT $LN1@ExecuteMov@4

; 7215 : 	{
; 7216 : 		ExecuteMoveToPlot(pUnit, pTarget, bSaveMoves);

	mov	eax, DWORD PTR _bSaveMoves$[esp+24]
	mov	ecx, DWORD PTR _pTarget$[esp+24]
	push	eax
	push	ecx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T274771[esp+40], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot
$LN1@ExecuteMov@4:

; 7217 : 	}
; 7218 : }

	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	esi, esi
	je	SHORT $LN25@ExecuteMov@4
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN25@ExecuteMov@4:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z ENDP ; CvTacticalAI::ExecuteMoveToPlot
PUBLIC	??1?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::~vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::~vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@4:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::~vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXXZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T274958 = -4						; size = 1
$T274960 = -4						; size = 1
__Cat$274962 = -4					; size = 1
?clear@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXXZ PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx
	push	esi
	mov	esi, ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN15@clear@4
	mov	BYTE PTR $T274958[esp+8], 0
	mov	edx, DWORD PTR $T274958[esp+8]
	push	edx
	mov	edx, DWORD PTR __Cat$274962[esp+12]
	push	edx
	mov	edx, DWORD PTR $T274960[esp+16]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
$LN15@clear@4:
	pop	esi

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::~vector<CvTacticalCity,std::allocator<CvTacticalCity> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::~vector<CvTacticalCity,std::allocator<CvTacticalCity> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@5:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::~vector<CvTacticalCity,std::allocator<CvTacticalCity> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEXXZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T274993 = -4						; size = 4
?clear@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEXXZ PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T274993[esp+12]
	push	eax
	call	?erase@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::clear
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z
_TEXT	SEGMENT
__Tmp$227717 = -44					; size = 24
__Tmp$227707 = -44					; size = 24
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$275295 = 8					; size = 1
__Cat$275223 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$227692 = 12					; size = 4
__Count$ = 12						; size = 4
tv525 = 16						; size = 4
tv515 = 16						; size = 4
$T275292 = 16						; size = 1
$T275220 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	eax, eax
	jne	SHORT $LN29@Insert_n@3
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@3
$LN29@Insert_n@3:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
$LN30@Insert_n@3:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN85@Insert_n@3

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	edx, ebx
	sub	edx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, 178956970				; 0aaaaaaaH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@KAXXZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Xlen
$LN91@Insert_n@3:
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 178956970				; 0aaaaaaaH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@3:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvTacticalUnit@@@std@@YAPAVCvTacticalUnit@@IPAV1@@Z ; std::_Allocate<CvTacticalUnit>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[ebp]
	sar	edx, 2
	mov	ebx, edx
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	push	eax
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	edi
	mov	DWORD PTR __Newvec$227692[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEPAVCvTacticalUnit@@PAV3@IABV3@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$275223[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T275220[ebp], 0
	mov	ecx, DWORD PTR $T275220[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$227692[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Newvec$227692[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	ecx, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	BYTE PTR $T275292[ebp], 0
	mov	edx, DWORD PTR $T275292[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$275295[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCvTacticalUnit@@PAV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalUnit *,CvTacticalUnit *,std::allocator<CvTacticalUnit> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN81@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Newvec$227692[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$227692[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN92@Insert_n@3:
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, ebx
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	$LN3@Insert_n@3
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$227707[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$227707[ebp+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$227707[ebp+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$227707[ebp+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$227707[ebp+20], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227707[ebp+16], edx
	call	??$_Umove@PAVCvTacticalUnit@@@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEPAVCvTacticalUnit@@PAV2@00@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Umove<CvTacticalUnit *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ebx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR __Tmp$227707[ebp]
	push	ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEPAVCvTacticalUnit@@PAV3@IABV3@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$227707[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$_Fill@PAVCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@0ABV1@@Z ; std::_Fill<CvTacticalUnit *,CvTacticalUnit>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@3:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$227717[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*2]
	mov	DWORD PTR __Tmp$227717[ebp+4], edx
	mov	edx, DWORD PTR [eax+12]
	add	edi, edi
	mov	DWORD PTR __Tmp$227717[ebp+8], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$227717[ebp+12], edx
	mov	edx, DWORD PTR [eax+20]
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	mov	DWORD PTR __Tmp$227717[ebp+16], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227717[ebp+20], edx
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAVCvTacticalUnit@@@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEPAVCvTacticalUnit@@PAV2@00@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Umove<CvTacticalUnit *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR tv525[ebp]
	push	ebx
	push	eax
	push	ecx
	call	??$_Unchecked_move_backward@PAVCvTacticalUnit@@PAV1@@stdext@@YAPAVCvTacticalUnit@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvTacticalUnit *,CvTacticalUnit *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$227717[ebp]
	push	edx
	add	edi, eax
	push	edi
	push	eax
	call	??$_Fill@PAVCvTacticalUnit@@V1@@std@@YAXPAVCvTacticalUnit@@0ABV1@@Z ; std::_Fill<CvTacticalUnit *,CvTacticalUnit>
	add	esp, 24					; 00000018H
$LN85@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN90@Insert_n@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z
_TEXT	SEGMENT
__Tmp$227792 = -32					; size = 12
__Tmp$227782 = -32					; size = 12
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$275534 = 8					; size = 1
__Cat$275465 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$227767 = 12					; size = 4
__Count$ = 12						; size = 4
tv525 = 16						; size = 4
tv515 = 16						; size = 4
$T275530 = 16						; size = 1
$T275462 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	eax, eax
	jne	SHORT $LN29@Insert_n@4
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@4
$LN29@Insert_n@4:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
$LN30@Insert_n@4:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@4

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	edx, ebx
	sub	edx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, 357913941				; 15555555H
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@KAXXZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Xlen
$LN87@Insert_n@4:
$LN12@Insert_n@4:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 357913941				; 15555555H
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@4:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@4:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvTacticalCity@@@std@@YAPAVCvTacticalCity@@IPAV1@@Z ; std::_Allocate<CvTacticalCity>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[ebp]
	sar	edx, 1
	mov	ebx, edx
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	push	eax
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	edi
	mov	DWORD PTR __Newvec$227767[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEPAVCvTacticalCity@@PAV3@IABV3@@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$275465[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T275462[ebp], 0
	mov	ecx, DWORD PTR $T275462[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$227767[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Newvec$227767[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	ecx, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	BYTE PTR $T275530[ebp], 0
	mov	edx, DWORD PTR $T275530[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$275534[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCvTacticalCity@@PAV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAPAVCvTacticalCity@@PAV1@00AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvTacticalCity *,CvTacticalCity *,std::allocator<CvTacticalCity> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN81@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Newvec$227767[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$227767[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@4:
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, ebx
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	$LN3@Insert_n@4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$227782[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$227782[ebp+8], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227782[ebp+4], edx
	call	??$_Umove@PAVCvTacticalCity@@@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEPAVCvTacticalCity@@PAV2@00@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Umove<CvTacticalCity *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ebx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR __Tmp$227782[ebp]
	push	ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEPAVCvTacticalCity@@PAV3@IABV3@@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$227782[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$fill@PAVCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@0ABV1@@Z ; std::fill<CvTacticalCity *,CvTacticalCity>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@4:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*2]
	mov	DWORD PTR __Tmp$227792[ebp+8], eax
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	mov	DWORD PTR __Tmp$227792[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227792[ebp+4], edx
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAVCvTacticalCity@@@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEPAVCvTacticalCity@@PAV2@00@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Umove<CvTacticalCity *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAVCvTacticalCity@@PAV1@@stdext@@YAPAVCvTacticalCity@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvTacticalCity *,CvTacticalCity *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$227792[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	edi, eax
	push	edi
	push	eax
	call	??$fill@PAVCvTacticalCity@@V1@@std@@YAXPAVCvTacticalCity@@0ABV1@@Z ; std::fill<CvTacticalCity *,CvTacticalCity>
	add	esp, 24					; 00000018H
$LN1@Insert_n@4:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Insert_n
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z
_TEXT	SEGMENT
__Mid$229567 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$229567[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$229567[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$229567[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$229567[esp+36]
$LN26@Sort:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN25@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z
_TEXT	SEGMENT
$T275725 = -8						; size = 1
$T275696 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T275695 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z PROC ; std::_Buffered_merge_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>, COMDAT

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@5
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@5:

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;
; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	lea	esi, DWORD PTR [eax+768]

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAVCvTacticalUnit@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>
	add	esp, 12					; 0000000cH
	sub	ebp, 1

; 3363 : 		_Mid = _Midend;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@5
$LN4@Buffered_m@5:

; 3364 : 		}
; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAVCvTacticalUnit@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@5
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
$LL3@Buffered_m@5:

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+16]
	mov	BYTE PTR $T275695[esp+20], bl
	mov	eax, DWORD PTR $T275695[esp+20]
	push	eax
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	edx, DWORD PTR __First$[esp+52]
	mov	DWORD PTR $T275696[esp+56], esp
	push	ecx
	push	edx
	call	??$_Chunked_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@H@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0V?$_Temp_iterator@VCvTacticalUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit>,int>

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	BYTE PTR $T275725[esp+64], bl
	mov	ecx, DWORD PTR $T275725[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@H@std@@YAXPAVCvTacticalUnit@@0V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int>
	add	esi, esi
	add	esp, 64					; 00000040H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@5
$LN1@Buffered_m@5:

; 3373 : 		}
; 3374 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ENDP ; std::_Buffered_merge_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z
_TEXT	SEGMENT
tv523 = -24						; size = 4
$T276045 = -24						; size = 4
$T275956 = -24						; size = 4
$T275740 = -20						; size = 20
$T275737 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T275887 = 20						; size = 1
__Midn$231285 = 20					; size = 4
$T275741 = 20						; size = 4
$T275739 = 20						; size = 4
$T275738 = 20						; size = 4
$T275736 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z PROC ; std::_Buffered_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@6

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __First$[esp+36]
	mov	ecx, DWORD PTR __Mid$[esp+36]
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+8]
	imul	edx, DWORD PTR [eax+4]
	imul	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	jle	$LN3@Buffered_m@6

; 2763 : 			std::iter_swap(_First, _Mid);

	push	ecx
	push	eax
	call	??$swap@VCvTacticalUnit@@@std@@YAXAAVCvTacticalUnit@@0@Z ; std::swap<CvTacticalUnit>
	add	esp, 8

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN9@Buffered_m@6:

; 2764 : 		}
; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	$LN6@Buffered_m@6
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalUnit>::_Maxlen
	cmp	ebx, eax
	jg	SHORT $LN6@Buffered_m@6

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T275736[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T275737[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
	mov	eax, DWORD PTR $T275737[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN54@Buffered_m@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN54@Buffered_m@6:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __First$[esp+36]
	mov	ecx, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T275738[esp+56]
	push	edx
	call	??$unchecked_merge@PAVCvTacticalUnit@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@0V12@11@Z ; stdext::unchecked_merge<CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
	add	esp, 24					; 00000018H

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN6@Buffered_m@6:

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalUnit>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_m@6

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __Mid$[esp+56]
	mov	DWORD PTR $T275739[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T275740[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@V?$_Temp_iterator@VCvTacticalUnit@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalUnit@@@std@@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,std::_Temp_iterator<CvTacticalUnit> >
	mov	eax, DWORD PTR $T275740[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN74@Buffered_m@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN74@Buffered_m@6:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	esi, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR __Last$[esp+36]
	mov	edx, DWORD PTR [esi+4]
	mov	BYTE PTR $T275887[esp+36], bl
	mov	eax, DWORD PTR $T275887[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR __Mid$[esp+44]
	push	edx
	mov	edx, DWORD PTR __First$[esp+48]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T275741[esp+60]
	push	eax
	call	??$_Merge_backward@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@PAVCvTacticalUnit@@V12@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0PAVCvTacticalUnit@@10U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit *,std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
	add	esp, 28					; 0000001cH

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN4@Buffered_m@6:

; 2775 : 		}
; 2776 : 	else
; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2784 : 			_Firstn = _First;
; 2785 : 			std::advance(_Firstn, _Count1n);
; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	push	0
	jge	SHORT $LN2@Buffered_m@6
	mov	esi, DWORD PTR __Mid$[esp+40]
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+40]
	mov	edi, eax
	mov	eax, DWORD PTR __Last$[esp+40]
	sar	edi, 1
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	ebp, DWORD PTR [edx+ecx*8]
	push	ebp
	push	eax
	lea	ecx, DWORD PTR $T275956[esp+52]
	push	esi
	push	ecx
	call	??$_Lower_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit,int>
	mov	ebx, DWORD PTR [eax]

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esp, 20					; 00000014H
	add	esi, edx

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN140@Buffered_m@6
$LN2@Buffered_m@6:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi

; 2792 : 			_Lastn = _Mid;
; 2793 : 			std::advance(_Lastn, _Count2n);
; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	edi, DWORD PTR __First$[esp+40]
	cdq
	sub	eax, edx
	mov	esi, eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	sar	esi, 1
	lea	edx, DWORD PTR [esi+esi*2]
	lea	ebx, DWORD PTR [eax+edx*8]
	push	ebx
	push	eax
	lea	eax, DWORD PTR $T276045[esp+52]
	push	edi
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@0ABVCvTacticalUnit@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit,int>
	mov	ebp, DWORD PTR [eax]

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, ebp
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	esp, 20					; 00000014H
	add	edi, edx
$LN140@Buffered_m@6:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	ecx
	push	esi
	sub	eax, edi
	push	eax
	push	ebx
	push	edx
	mov	DWORD PTR tv523[esp+60], eax
	lea	eax, DWORD PTR __Midn$231285[esp+56]
	push	ebp
	push	eax
	call	??$_Buffered_rotate@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YA?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[esp+64]
	mov	edx, DWORD PTR __First$[esp+64]
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Midn$231285[esp+76]
	push	edi
	push	ebp
	push	edx
	call	??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[esp+88]
	mov	ecx, DWORD PTR tv523[esp+92]
	mov	edx, DWORD PTR __Last$[esp+88]
	push	eax
	mov	eax, DWORD PTR __Count2$[esp+92]
	sub	eax, esi
	push	eax
	push	ecx
	push	edx
	push	ebx
	push	edi
	call	??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
	add	esp, 76					; 0000004cH
$LN3@Buffered_m@6:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ENDP ; std::_Buffered_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z
_TEXT	SEGMENT
$T276221 = -8						; size = 1
$T276192 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T276191 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z PROC ; std::_Buffered_merge_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>, COMDAT

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@7
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@7:

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;
; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	lea	esi, DWORD PTR [eax+384]

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAVCvTacticalCity@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>
	add	esp, 12					; 0000000cH
	sub	ebp, 1

; 3363 : 		_Mid = _Midend;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@7
$LN4@Buffered_m@7:

; 3364 : 		}
; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAVCvTacticalCity@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@7
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
$LL3@Buffered_m@7:

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+16]
	mov	BYTE PTR $T276191[esp+20], bl
	mov	eax, DWORD PTR $T276191[esp+20]
	push	eax
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	edx, DWORD PTR __First$[esp+52]
	mov	DWORD PTR $T276192[esp+56], esp
	push	ecx
	push	edx
	call	??$_Chunked_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@H@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0V?$_Temp_iterator@VCvTacticalCity@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity>,int>

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	BYTE PTR $T276221[esp+64], bl
	mov	ecx, DWORD PTR $T276221[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@H@std@@YAXPAVCvTacticalCity@@0V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int>
	add	esi, esi
	add	esp, 64					; 00000040H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@7
$LN1@Buffered_m@7:

; 3373 : 		}
; 3374 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ENDP ; std::_Buffered_merge_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z
_TEXT	SEGMENT
tv518 = -24						; size = 4
$T276552 = -24						; size = 4
$T276464 = -24						; size = 4
$T276235 = -20						; size = 20
$T276232 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T276396 = 20						; size = 1
__Midn$231444 = 20					; size = 4
$T276236 = 20						; size = 4
$T276234 = 20						; size = 4
$T276233 = 20						; size = 4
$T276231 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z PROC ; std::_Buffered_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@8

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp+36]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __First$[esp+36]
	cmp	edx, DWORD PTR [ecx+4]
	jle	$LN3@Buffered_m@8

; 2763 : 			std::iter_swap(_First, _Mid);

	mov	edx, ecx
	cmp	ecx, eax
	je	$LN3@Buffered_m@8
	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], ecx

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN9@Buffered_m@8:

; 2764 : 		}
; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	$LN6@Buffered_m@8
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalCity>::_Maxlen
	cmp	ebx, eax
	jg	SHORT $LN6@Buffered_m@8

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T276231[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T276232[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
	mov	eax, DWORD PTR $T276232[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN57@Buffered_m@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Buffered_m@8:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __First$[esp+36]
	mov	ecx, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T276233[esp+56]
	push	edx
	call	??$unchecked_merge@PAVCvTacticalCity@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@0V12@11@Z ; stdext::unchecked_merge<CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
	add	esp, 24					; 00000018H

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN6@Buffered_m@8:

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalCity>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_m@8

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __Mid$[esp+56]
	mov	DWORD PTR $T276234[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T276235[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@V?$_Temp_iterator@VCvTacticalCity@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalCity@@@std@@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,std::_Temp_iterator<CvTacticalCity> >
	mov	eax, DWORD PTR $T276235[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN77@Buffered_m@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN77@Buffered_m@8:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	esi, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR __Last$[esp+36]
	mov	edx, DWORD PTR [esi+4]
	mov	BYTE PTR $T276396[esp+36], bl
	mov	eax, DWORD PTR $T276396[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR __Mid$[esp+44]
	push	edx
	mov	edx, DWORD PTR __First$[esp+48]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T276236[esp+60]
	push	eax
	call	??$_Merge_backward@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@PAVCvTacticalCity@@V12@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0PAVCvTacticalCity@@10U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity *,std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
	add	esp, 28					; 0000001cH

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN4@Buffered_m@8:

; 2775 : 		}
; 2776 : 	else
; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2784 : 			_Firstn = _First;
; 2785 : 			std::advance(_Firstn, _Count1n);
; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	push	0
	jge	SHORT $LN2@Buffered_m@8
	mov	esi, DWORD PTR __Mid$[esp+40]
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+40]
	mov	edi, eax
	mov	eax, DWORD PTR __Last$[esp+40]
	sar	edi, 1
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	ebp, DWORD PTR [edx+ecx*4]
	push	ebp
	push	eax
	lea	ecx, DWORD PTR $T276464[esp+52]
	push	esi
	push	ecx
	call	??$_Lower_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity,int>
	mov	ebx, DWORD PTR [eax]

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esp, 20					; 00000014H
	add	esi, edx

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN143@Buffered_m@8
$LN2@Buffered_m@8:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi

; 2792 : 			_Lastn = _Mid;
; 2793 : 			std::advance(_Lastn, _Count2n);
; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	edi, DWORD PTR __First$[esp+40]
	cdq
	sub	eax, edx
	mov	esi, eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	sar	esi, 1
	lea	edx, DWORD PTR [esi+esi*2]
	lea	ebx, DWORD PTR [eax+edx*4]
	push	ebx
	push	eax
	lea	eax, DWORD PTR $T276552[esp+52]
	push	edi
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@H@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@0ABVCvTacticalCity@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity,int>
	mov	ebp, DWORD PTR [eax]

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, ebp
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	esp, 20					; 00000014H
	add	edi, edx
$LN143@Buffered_m@8:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	ecx
	push	esi
	sub	eax, edi
	push	eax
	push	ebx
	push	edx
	mov	DWORD PTR tv518[esp+60], eax
	lea	eax, DWORD PTR __Midn$231444[esp+56]
	push	ebp
	push	eax
	call	??$_Buffered_rotate@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YA?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[esp+64]
	mov	edx, DWORD PTR __First$[esp+64]
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Midn$231444[esp+76]
	push	edi
	push	ebp
	push	edx
	call	??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[esp+88]
	mov	ecx, DWORD PTR tv518[esp+92]
	mov	edx, DWORD PTR __Last$[esp+88]
	push	eax
	mov	eax, DWORD PTR __Count2$[esp+92]
	sub	eax, esi
	push	eax
	push	ecx
	push	edx
	push	ebx
	push	edi
	call	??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
	add	esp, 76					; 0000004cH
$LN3@Buffered_m@8:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ENDP ; std::_Buffered_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@H@stdext@@YAXPAVCvTacticalMove@@0V?$_Temp_iterator@VCvTacticalMove@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@H@stdext@@YAXPAVCvTacticalMove@@0V?$_Temp_iterator@VCvTacticalMove@@@std@@HH@Z
_TEXT	SEGMENT
$T276602 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T276603 = 40						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@H@stdext@@YAXPAVCvTacticalMove@@0V?$_Temp_iterator@VCvTacticalMove@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T276602[esp+8], bl
	mov	eax, DWORD PTR $T276602[esp+8]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR $T276603[esp+36], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+36]
	push	edx
	push	eax
	call	??$_Chunked_merge@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@H@std@@YAXPAVCvTacticalMove@@0V?$_Temp_iterator@VCvTacticalMove@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,int>

; 5254 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	add	esp, 40					; 00000028H
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@8:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@H@stdext@@YAXPAVCvTacticalMove@@0V?$_Temp_iterator@VCvTacticalMove@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@H@stdext@@YAXPAVCvTacticalTarget@@0V?$_Temp_iterator@VCvTacticalTarget@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@H@stdext@@YAXPAVCvTacticalTarget@@0V?$_Temp_iterator@VCvTacticalTarget@@@std@@HH@Z
_TEXT	SEGMENT
$T276639 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T276640 = 40						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@H@stdext@@YAXPAVCvTacticalTarget@@0V?$_Temp_iterator@VCvTacticalTarget@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T276639[esp+8], bl
	mov	eax, DWORD PTR $T276639[esp+8]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR $T276640[esp+36], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+36]
	push	edx
	push	eax
	call	??$_Chunked_merge@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@H@std@@YAXPAVCvTacticalTarget@@0V?$_Temp_iterator@VCvTacticalTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,int>

; 5254 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	add	esp, 40					; 00000028H
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@9
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@9:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@H@stdext@@YAXPAVCvTacticalTarget@@0V?$_Temp_iterator@VCvTacticalTarget@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z
_TEXT	SEGMENT
$T276676 = -16						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
$T276677 = 44						; size = 4
__Pred$ = 44						; size = 4
??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z PROC ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 5285 : 	{

	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp+16]
	mov	edx, DWORD PTR __Count$[esp+16]
	xor	ebx, ebx
	mov	BYTE PTR $T276676[esp+20], bl
	mov	eax, DWORD PTR $T276676[esp+20]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+20]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+28]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR $T276677[esp+52], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+52]
	push	edx
	push	eax
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	call	??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>

; 5287 : 	}

	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@10
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@10:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvBlockingUnit>::~_Temp_iterator<CvBlockingUnit>
__ehhandler$??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z ENDP ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
PUBLIC	??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@H@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@H@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HH@Z
_TEXT	SEGMENT
$T276719 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T276720 = 40						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@H@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T276719[esp+8], bl
	mov	eax, DWORD PTR $T276719[esp+8]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR $T276720[esp+36], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+36]
	push	edx
	push	eax
	call	??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@H@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int>

; 5254 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	add	esp, 40					; 00000028H
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@11
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@11:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@H@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int>
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??0CvTacticalAI@@QAE@XZ				; CvTacticalAI::CvTacticalAI
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$??0CvTacticalAI@@QAE@XZ DD 019930522H
	DD	013H
	DD	FLAT:__unwindtable$??0CvTacticalAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvTacticalAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$15
	DD	0fH
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$16
	DD	010H
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$??0CvTacticalAI@@QAE@XZ$18
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ??0CvTacticalAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTacticalAI@@QAE@XZ PROC				; CvTacticalAI::CvTacticalAI, COMDAT
; _this$ = ecx

; 235  : {

	push	-1
	push	__ehhandler$??0CvTacticalAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	lea	ebx, DWORD PTR [esi+8]
	push	edi
	mov	ecx, ebx
	mov	DWORD PTR _this$[esp+32], esi
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Buynode
	xor	edi, edi
	mov	DWORD PTR [ebx+4], eax
	mov	DWORD PTR [ebx+8], edi
	mov	DWORD PTR __$EHRec$[esp+40], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+48], edi
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	lea	eax, DWORD PTR [esi+80]
	mov	ebp, 256				; 00000100H
	mov	DWORD PTR [esi+72], edi
	mov	DWORD PTR [esi+76], ebp
	mov	DWORD PTR [esi+68], eax
	lea	ebx, DWORD PTR [esi+2136]
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+40], 4
	call	?_Buynode@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEPAU_Node@?$_List_nod@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@2@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Buynode
	mov	DWORD PTR [ebx+4], eax
	mov	DWORD PTR [ebx+8], edi
	lea	eax, DWORD PTR [esi+2164]
	mov	DWORD PTR [esi+2156], edi
	mov	DWORD PTR [esi+2160], ebp
	mov	DWORD PTR [esi+2152], eax
	lea	eax, DWORD PTR [esi+9348]
	mov	DWORD PTR [esi+9340], edi
	mov	DWORD PTR [esi+9344], ebp
	mov	DWORD PTR [esi+9336], eax
	lea	eax, DWORD PTR [esi+16532]
	mov	DWORD PTR [esi+16524], edi
	mov	DWORD PTR [esi+16528], ebp
	mov	DWORD PTR [esi+16520], eax
	lea	eax, DWORD PTR [esi+23716]
	mov	ecx, 37					; 00000025H
	mov	DWORD PTR [esi+23708], edi
	mov	DWORD PTR [esi+23712], ecx
	mov	DWORD PTR [esi+23704], eax
	lea	eax, DWORD PTR [esi+24820]
	mov	edx, 64					; 00000040H
	mov	DWORD PTR [esi+24812], edi
	mov	DWORD PTR [esi+24816], edx
	mov	DWORD PTR [esi+24808], eax
	lea	eax, DWORD PTR [esi+25604]
	mov	DWORD PTR [esi+25596], edi
	mov	DWORD PTR [esi+25600], edx
	mov	DWORD PTR [esi+25592], eax
	lea	eax, DWORD PTR [esi+26392]
	mov	DWORD PTR [esi+26384], edi
	mov	DWORD PTR [esi+26388], 10		; 0000000aH
	mov	DWORD PTR [esi+26380], eax
	lea	eax, DWORD PTR [esi+26608]
	mov	edx, 25					; 00000019H
	mov	DWORD PTR [esi+26600], edi
	mov	DWORD PTR [esi+26604], edx
	mov	DWORD PTR [esi+26596], eax
	lea	eax, DWORD PTR [esi+27024]
	mov	DWORD PTR [esi+27016], edi
	mov	DWORD PTR [esi+27020], edx
	mov	DWORD PTR [esi+27012], eax
	lea	eax, DWORD PTR [esi+27440]
	mov	DWORD PTR [esi+27432], edi
	mov	DWORD PTR [esi+27436], ecx
	mov	DWORD PTR [esi+27428], eax
	lea	eax, DWORD PTR [esi+28048]
	mov	DWORD PTR [esi+28040], edi
	mov	DWORD PTR [esi+28044], ecx
	mov	DWORD PTR [esi+28036], eax
	lea	eax, DWORD PTR [esi+28656]
	mov	ecx, 20					; 00000014H
	mov	DWORD PTR [esi+28648], edi
	mov	DWORD PTR [esi+28652], ecx
	mov	DWORD PTR [esi+28644], eax
	lea	eax, DWORD PTR [esi+28832]
	mov	DWORD PTR [esi+28824], edi
	mov	DWORD PTR [esi+28828], ecx
	mov	DWORD PTR [esi+28820], eax
	mov	DWORD PTR [esi+29000], edi
	lea	eax, DWORD PTR [esi+29008]
	mov	DWORD PTR [esi+29004], ecx

; 236  : 	m_iCurrentZoneIndex = -1;
; 237  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR [esi+28996], eax
	pop	edi
	mov	DWORD PTR [esi+24792], -1
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::~vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::~vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::~vector<CvTacticalCity,std::allocator<CvTacticalCity> >
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	jmp	??1?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalMove,256,1,297,0>::~FStaticVector<CvTacticalMove,256,1,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2136				; 00000858H
	jmp	??1?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~list<CvQueuedAttack,std::allocator<CvQueuedAttack> >
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2152				; 00000868H
	jmp	??1?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,256,0,297,0>::~FStaticVector<CvTacticalTarget,256,0,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 9336				; 00002478H
	jmp	??1?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,256,0,297,0>::~FStaticVector<CvTacticalTarget,256,0,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16520				; 00004088H
	jmp	??1?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,256,0,297,0>::~FStaticVector<CvTacticalTarget,256,0,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 23704				; 00005c98H
	jmp	??1?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,37,1,297,0>::~FStaticVector<CvTacticalTarget,37,1,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24808				; 000060e8H
	jmp	??1?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalPosture,64,1,297,0>::~FStaticVector<CvTacticalPosture,64,1,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25592				; 000063f8H
	jmp	??1?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalPosture,64,1,297,0>::~FStaticVector<CvTacticalPosture,64,1,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$12:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 26380				; 0000670cH
	jmp	??1?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTemporaryZone,10,1,297,0>::~FStaticVector<CvTemporaryZone,10,1,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$13:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 26596				; 000067e4H
	jmp	??1?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvBlockingUnit,25,1,297,0>::~FStaticVector<CvBlockingUnit,25,1,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$14:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 27012				; 00006984H
	jmp	??1?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvBlockingUnit,25,1,297,0>::~FStaticVector<CvBlockingUnit,25,1,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$15:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 27428				; 00006b24H
	jmp	??1?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvBlockingUnit,37,1,297,0>::~FStaticVector<CvBlockingUnit,37,1,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$16:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28036				; 00006d84H
	jmp	??1?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvBlockingUnit,37,1,297,0>::~FStaticVector<CvBlockingUnit,37,1,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$17:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28644				; 00006fe4H
	jmp	??1?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationUnit,20,1,297,0>::~FStaticVector<CvOperationUnit,20,1,297,0>
__unwindfunclet$??0CvTacticalAI@@QAE@XZ$18:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28820				; 00007094H
	jmp	??1?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationUnit,20,1,297,0>::~FStaticVector<CvOperationUnit,20,1,297,0>
__ehhandler$??0CvTacticalAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvTacticalAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTacticalAI@@QAE@XZ ENDP				; CvTacticalAI::CvTacticalAI
PUBLIC	??1CvTacticalAI@@QAE@XZ				; CvTacticalAI::~CvTacticalAI
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
xdata$x	SEGMENT
__ehfuncinfo$??1CvTacticalAI@@QAE@XZ DD 019930522H
	DD	013H
	DD	FLAT:__unwindtable$??1CvTacticalAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvTacticalAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$15
	DD	0fH
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$16
	DD	010H
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$??1CvTacticalAI@@QAE@XZ$18
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ??1CvTacticalAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTacticalAI@@QAE@XZ PROC				; CvTacticalAI::~CvTacticalAI, COMDAT
; _this$ = ecx

; 241  : {

	push	-1
	push	__ehhandler$??1CvTacticalAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi

; 242  : 	Uninit();
; 243  : }

	mov	eax, DWORD PTR [esi+28996]
	lea	ecx, DWORD PTR [esi+29008]
	mov	DWORD PTR __$EHRec$[esp+32], 18		; 00000012H
	cmp	eax, ecx
	je	SHORT $LN27@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN27@CvTactical@2:
	mov	eax, DWORD PTR [esi+28820]
	lea	edx, DWORD PTR [esi+28832]
	mov	BYTE PTR __$EHRec$[esp+32], 17		; 00000011H
	cmp	eax, edx
	je	SHORT $LN41@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN41@CvTactical@2:
	mov	eax, DWORD PTR [esi+28644]
	lea	ecx, DWORD PTR [esi+28656]
	mov	BYTE PTR __$EHRec$[esp+32], 16		; 00000010H
	cmp	eax, ecx
	je	SHORT $LN55@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN55@CvTactical@2:
	mov	eax, DWORD PTR [esi+28036]
	lea	edx, DWORD PTR [esi+28048]
	mov	BYTE PTR __$EHRec$[esp+32], 15		; 0000000fH
	cmp	eax, edx
	je	SHORT $LN69@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN69@CvTactical@2:
	mov	eax, DWORD PTR [esi+27428]
	lea	ecx, DWORD PTR [esi+27440]
	mov	BYTE PTR __$EHRec$[esp+32], 14		; 0000000eH
	cmp	eax, ecx
	je	SHORT $LN83@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN83@CvTactical@2:
	mov	eax, DWORD PTR [esi+27012]
	lea	edx, DWORD PTR [esi+27024]
	mov	BYTE PTR __$EHRec$[esp+32], 13		; 0000000dH
	cmp	eax, edx
	je	SHORT $LN97@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN97@CvTactical@2:
	mov	eax, DWORD PTR [esi+26596]
	lea	ecx, DWORD PTR [esi+26608]
	mov	BYTE PTR __$EHRec$[esp+32], 12		; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN111@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN111@CvTactical@2:
	mov	eax, DWORD PTR [esi+26380]
	lea	edx, DWORD PTR [esi+26392]
	mov	BYTE PTR __$EHRec$[esp+32], 11		; 0000000bH
	cmp	eax, edx
	je	SHORT $LN125@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN125@CvTactical@2:
	mov	eax, DWORD PTR [esi+25592]
	lea	ecx, DWORD PTR [esi+25604]
	mov	BYTE PTR __$EHRec$[esp+32], 10		; 0000000aH
	cmp	eax, ecx
	je	SHORT $LN139@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN139@CvTactical@2:
	mov	eax, DWORD PTR [esi+24808]
	lea	edx, DWORD PTR [esi+24820]
	mov	BYTE PTR __$EHRec$[esp+32], 9
	cmp	eax, edx
	je	SHORT $LN153@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN153@CvTactical@2:
	mov	eax, DWORD PTR [esi+23704]
	lea	ecx, DWORD PTR [esi+23716]
	mov	BYTE PTR __$EHRec$[esp+32], 8
	cmp	eax, ecx
	je	SHORT $LN167@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN167@CvTactical@2:
	mov	eax, DWORD PTR [esi+16520]
	lea	edx, DWORD PTR [esi+16532]
	mov	BYTE PTR __$EHRec$[esp+32], 7
	cmp	eax, edx
	je	SHORT $LN181@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN181@CvTactical@2:
	mov	eax, DWORD PTR [esi+9336]
	lea	ecx, DWORD PTR [esi+9348]
	mov	BYTE PTR __$EHRec$[esp+32], 6
	cmp	eax, ecx
	je	SHORT $LN195@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN195@CvTactical@2:
	mov	eax, DWORD PTR [esi+2152]
	lea	edx, DWORD PTR [esi+2164]
	mov	BYTE PTR __$EHRec$[esp+32], 5
	cmp	eax, edx
	je	SHORT $LN209@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN209@CvTactical@2:
	lea	ecx, DWORD PTR [esi+2136]
	call	?_Tidy@?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@IAEXXZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::_Tidy
	mov	eax, DWORD PTR [esi+68]
	lea	ecx, DWORD PTR [esi+80]
	mov	BYTE PTR __$EHRec$[esp+32], 3
	cmp	eax, ecx
	je	SHORT $LN225@CvTactical@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN225@CvTactical@2:
	mov	eax, DWORD PTR [esi+56]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN242@CvTactical@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN242@CvTactical@2:
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	mov	eax, DWORD PTR [esi+40]
	cmp	eax, edi
	je	SHORT $LN249@CvTactical@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN249@CvTactical@2:
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+48], edi
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	je	SHORT $LN256@CvTactical@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN256@CvTactical@2:
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+32], edi
	call	?_Tidy@?$list@HV?$allocator@H@std@@@std@@IAEXXZ ; std::list<int,std::allocator<int> >::_Tidy
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::~vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::~vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE@XZ ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::~vector<CvTacticalCity,std::allocator<CvTacticalCity> >
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	jmp	??1?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalMove,256,1,297,0>::~FStaticVector<CvTacticalMove,256,1,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2136				; 00000858H
	jmp	??1?$list@VCvQueuedAttack@@V?$allocator@VCvQueuedAttack@@@std@@@std@@QAE@XZ ; std::list<CvQueuedAttack,std::allocator<CvQueuedAttack> >::~list<CvQueuedAttack,std::allocator<CvQueuedAttack> >
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2152				; 00000868H
	jmp	??1?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,256,0,297,0>::~FStaticVector<CvTacticalTarget,256,0,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 9336				; 00002478H
	jmp	??1?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,256,0,297,0>::~FStaticVector<CvTacticalTarget,256,0,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16520				; 00004088H
	jmp	??1?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,256,0,297,0>::~FStaticVector<CvTacticalTarget,256,0,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 23704				; 00005c98H
	jmp	??1?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,37,1,297,0>::~FStaticVector<CvTacticalTarget,37,1,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24808				; 000060e8H
	jmp	??1?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalPosture,64,1,297,0>::~FStaticVector<CvTacticalPosture,64,1,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25592				; 000063f8H
	jmp	??1?$FStaticVector@VCvTacticalPosture@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalPosture,64,1,297,0>::~FStaticVector<CvTacticalPosture,64,1,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$12:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 26380				; 0000670cH
	jmp	??1?$FStaticVector@VCvTemporaryZone@@$09$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTemporaryZone,10,1,297,0>::~FStaticVector<CvTemporaryZone,10,1,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$13:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 26596				; 000067e4H
	jmp	??1?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvBlockingUnit,25,1,297,0>::~FStaticVector<CvBlockingUnit,25,1,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$14:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 27012				; 00006984H
	jmp	??1?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvBlockingUnit,25,1,297,0>::~FStaticVector<CvBlockingUnit,25,1,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$15:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 27428				; 00006b24H
	jmp	??1?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvBlockingUnit,37,1,297,0>::~FStaticVector<CvBlockingUnit,37,1,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$16:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28036				; 00006d84H
	jmp	??1?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvBlockingUnit,37,1,297,0>::~FStaticVector<CvBlockingUnit,37,1,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$17:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28644				; 00006fe4H
	jmp	??1?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationUnit,20,1,297,0>::~FStaticVector<CvOperationUnit,20,1,297,0>
__unwindfunclet$??1CvTacticalAI@@QAE@XZ$18:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28820				; 00007094H
	jmp	??1?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationUnit,20,1,297,0>::~FStaticVector<CvOperationUnit,20,1,297,0>
__ehhandler$??1CvTacticalAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvTacticalAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTacticalAI@@QAE@XZ ENDP				; CvTacticalAI::~CvTacticalAI
PUBLIC	?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@12
	xor	eax, eax
	jmp	SHORT $LN10@push_back@12
$LN9@push_back@12:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@12:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@12
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@12:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@ABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@ABVCvTacticalUnit@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@ABVCvTacticalUnit@@@Z PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@3
	xor	esi, esi
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@3:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@IABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*2]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@ABVCvTacticalUnit@@@Z ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@ABVCvTacticalCity@@@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@ABVCvTacticalCity@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@ABVCvTacticalCity@@@Z PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@4
	xor	esi, esi
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@4:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@IABVCvTacticalCity@@@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*2]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@ABVCvTacticalCity@@@Z ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::insert
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	edi

; 3382 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@VCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAVCvTacticalUnit@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,CvTacticalUnit>
	add	esp, 12					; 0000000cH
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
$LN4@Stable_sor:
	push	ebx

; 3384 : 	else
; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3387 : 		_BidIt _Mid = _First;
; 3388 : 		std::advance(_Mid, _Count2);
; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR __First$[esp+12]
	sar	esi, 1
	lea	edx, DWORD PTR [esi+esi*2]
	mov	ecx, ebp
	lea	ebx, DWORD PTR [eax+edx*8]
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalUnit>::_Maxlen
	cmp	esi, eax

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	push	ebp
	push	esi
	push	ebx
	jg	SHORT $LN2@Stable_sor
	mov	ecx, DWORD PTR __First$[esp+24]
	push	ecx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	edx
	push	ebx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN21@Stable_sor
$LN2@Stable_sor:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __First$[esp+24]
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
$LN21@Stable_sor:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	edx, DWORD PTR __Last$[esp+44]
	mov	eax, DWORD PTR __First$[esp+44]
	add	esp, 32					; 00000020H
	push	ebp
	push	edi
	push	esi
	push	edx
	push	ebx
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	edi

; 3382 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor@2

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@VCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAVCvTacticalCity@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,CvTacticalCity>
	add	esp, 12					; 0000000cH
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
$LN4@Stable_sor@2:
	push	ebx

; 3384 : 	else
; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3387 : 		_BidIt _Mid = _First;
; 3388 : 		std::advance(_Mid, _Count2);
; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR __First$[esp+12]
	sar	esi, 1
	lea	edx, DWORD PTR [esi+esi*2]
	mov	ecx, ebp
	lea	ebx, DWORD PTR [eax+edx*4]
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalCity@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalCity>::_Maxlen
	cmp	esi, eax

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	push	ebp
	push	esi
	push	ebx
	jg	SHORT $LN2@Stable_sor@2
	mov	ecx, DWORD PTR __First$[esp+24]
	push	ecx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	edx
	push	ebx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN21@Stable_sor@2
$LN2@Stable_sor@2:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __First$[esp+24]
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
$LN21@Stable_sor@2:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	edx, DWORD PTR __Last$[esp+44]
	mov	eax, DWORD PTR __First$[esp+44]
	add	esp, 32					; 00000020H
	push	ebp
	push	edi
	push	esi
	push	edx
	push	ebx
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@00HHAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Buffered_merge_sort<CvTacticalMove *,int,CvTacticalMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z
_TEXT	SEGMENT
$T279120 = -8						; size = 1
$T279091 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T279090 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z PROC ; std::_Buffered_merge_sort<CvTacticalMove *,int,CvTacticalMove>, COMDAT

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@9
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@9:

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;
; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	lea	esi, DWORD PTR [eax+256]

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@PAVCvTacticalMove@@V1@@std@@YAXPAVCvTacticalMove@@00@Z ; std::_Insertion_sort1<CvTacticalMove *,CvTacticalMove>
	add	esp, 12					; 0000000cH
	sub	ebp, 1

; 3363 : 		_Mid = _Midend;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@9
$LN4@Buffered_m@9:

; 3364 : 		}
; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@PAVCvTacticalMove@@V1@@std@@YAXPAVCvTacticalMove@@00@Z ; std::_Insertion_sort1<CvTacticalMove *,CvTacticalMove>

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@9
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
$LL3@Buffered_m@9:

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+20]
	mov	BYTE PTR $T279090[esp+20], bl
	mov	eax, DWORD PTR $T279090[esp+20]
	push	eax
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	DWORD PTR $T279091[esp+56], esp
	push	ecx
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	call	??$_Chunked_merge@PAVCvTacticalMove@@V?$_Temp_iterator@VCvTacticalMove@@@std@@H@std@@YAXPAVCvTacticalMove@@0V?$_Temp_iterator@VCvTacticalMove@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalMove *,std::_Temp_iterator<CvTacticalMove>,int>

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	BYTE PTR $T279120[esp+64], bl
	mov	ecx, DWORD PTR $T279120[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvTacticalMove@@PAV1@H@std@@YAXPAVCvTacticalMove@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalMove *,CvTacticalMove *,int>
	add	esi, esi
	add	esp, 64					; 00000040H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@9
$LN1@Buffered_m@9:

; 3373 : 		}
; 3374 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvTacticalMove *,int,CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Buffered_merge_sort<CvTacticalTarget *,int,CvTacticalTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z
_TEXT	SEGMENT
$T279241 = -8						; size = 1
$T279212 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T279211 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z PROC ; std::_Buffered_merge_sort<CvTacticalTarget *,int,CvTacticalTarget>, COMDAT

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@10
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@10:

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;
; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	lea	esi, DWORD PTR [eax+896]

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@PAVCvTacticalTarget@@V1@@std@@YAXPAVCvTacticalTarget@@00@Z ; std::_Insertion_sort1<CvTacticalTarget *,CvTacticalTarget>
	add	esp, 12					; 0000000cH
	sub	ebp, 1

; 3363 : 		_Mid = _Midend;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@10
$LN4@Buffered_m@10:

; 3364 : 		}
; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@PAVCvTacticalTarget@@V1@@std@@YAXPAVCvTacticalTarget@@00@Z ; std::_Insertion_sort1<CvTacticalTarget *,CvTacticalTarget>

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@10
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
$LL3@Buffered_m@10:

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+20]
	mov	BYTE PTR $T279211[esp+20], bl
	mov	eax, DWORD PTR $T279211[esp+20]
	push	eax
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	DWORD PTR $T279212[esp+56], esp
	push	ecx
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	call	??$_Chunked_merge@PAVCvTacticalTarget@@V?$_Temp_iterator@VCvTacticalTarget@@@std@@H@std@@YAXPAVCvTacticalTarget@@0V?$_Temp_iterator@VCvTacticalTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalTarget *,std::_Temp_iterator<CvTacticalTarget>,int>

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	BYTE PTR $T279241[esp+64], bl
	mov	ecx, DWORD PTR $T279241[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvTacticalTarget@@PAV1@H@std@@YAXPAVCvTacticalTarget@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalTarget *,CvTacticalTarget *,int>
	add	esi, esi
	add	esp, 64					; 00000040H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@10
$LN1@Buffered_m@10:

; 3373 : 		}
; 3374 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvTacticalTarget *,int,CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
$T279252 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T279311 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Buffered_merge_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z PROC ; std::_Buffered_merge_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 3502 : 	{	// sort using temp buffer for merges, using _Pred

	push	ecx

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp]
	push	ebx

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ebx, DWORD PTR __Pred$[esp+4]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count$[esp+16]
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@11
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@11:

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;
; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);
; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	push	0
	lea	esi, DWORD PTR [eax+512]
	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@PAVCvBlockingUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),CvBlockingUnit>
	add	esp, 16					; 00000010H
	sub	ebp, 1

; 3510 : 		_Mid = _Midn;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@11
$LN4@Buffered_m@11:

; 3511 : 		}
; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+16]
	push	0
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@PAVCvBlockingUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),CvBlockingUnit>

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 16					; 00000010H
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@11
	mov	ebp, DWORD PTR __Tempbuf$[esp+16]
$LL3@Buffered_m@11:

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Last$[esp+20]
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [ebp+16]
	mov	DWORD PTR $T279252[esp+52], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+48]
	push	edx
	push	eax
	call	??$_Unchecked_chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@std@@HHP6A_NV1@2@Z@Z ; stdext::_Unchecked_chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+56]
	mov	BYTE PTR $T279311[esp+56], 0
	mov	ecx, DWORD PTR $T279311[esp+56]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	ebx
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvBlockingUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
	add	esi, esi
	add	esp, 68					; 00000044H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@11
$LN1@Buffered_m@11:

; 3520 : 		}
; 3521 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
??$_Buffered_merge_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ENDP ; std::_Buffered_merge_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Buffered_merge_sort<CvBlockingUnit *,int,CvBlockingUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z
_TEXT	SEGMENT
$T279431 = -8						; size = 1
$T279402 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T279401 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z PROC ; std::_Buffered_merge_sort<CvBlockingUnit *,int,CvBlockingUnit>, COMDAT

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@12
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@12:

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;
; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	lea	esi, DWORD PTR [eax+512]

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@PAVCvBlockingUnit@@V1@@std@@YAXPAVCvBlockingUnit@@00@Z ; std::_Insertion_sort1<CvBlockingUnit *,CvBlockingUnit>
	add	esp, 12					; 0000000cH
	sub	ebp, 1

; 3363 : 		_Mid = _Midend;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@12
$LN4@Buffered_m@12:

; 3364 : 		}
; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@PAVCvBlockingUnit@@V1@@std@@YAXPAVCvBlockingUnit@@00@Z ; std::_Insertion_sort1<CvBlockingUnit *,CvBlockingUnit>

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@12
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
$LL3@Buffered_m@12:

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+20]
	mov	BYTE PTR $T279401[esp+20], bl
	mov	eax, DWORD PTR $T279401[esp+20]
	push	eax
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	DWORD PTR $T279402[esp+56], esp
	push	ecx
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	call	??$_Chunked_merge@PAVCvBlockingUnit@@V?$_Temp_iterator@VCvBlockingUnit@@@std@@H@std@@YAXPAVCvBlockingUnit@@0V?$_Temp_iterator@VCvBlockingUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvBlockingUnit *,std::_Temp_iterator<CvBlockingUnit>,int>

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	BYTE PTR $T279431[esp+64], bl
	mov	ecx, DWORD PTR $T279431[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvBlockingUnit@@PAV1@H@std@@YAXPAVCvBlockingUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvBlockingUnit *,CvBlockingUnit *,int>
	add	esi, esi
	add	esp, 64					; 00000040H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@12
$LN1@Buffered_m@12:

; 3373 : 		}
; 3374 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvBlockingUnit *,int,CvBlockingUnit>
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@13
	xor	eax, eax
	jmp	SHORT $LN10@push_back@13
$LN9@push_back@13:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@13:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@13
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@13:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotDefensiveAirlifts
EXTRN	?airlift@CvUnit@@QAE_NHH@Z:PROC			; CvUnit::airlift
EXTRN	?canAirliftAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z:PROC	; CvUnit::canAirliftAt
EXTRN	?CanAirlift@CvCity@@QBE_NXZ:PROC		; CvCity::CanAirlift
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -136						; size = 4
_it$ = -132						; size = 4
$T280086 = -128						; size = 4
$T279693 = -128						; size = 4
_pCity$ = -124						; size = 4
_pUnit$221914 = -120					; size = 8
_aProcessedUnits$ = -112				; size = 16
_strLogString$221926 = -96				; size = 28
$T279695 = -68						; size = 28
$T279694 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotDefensiveAirlifts, COMDAT
; _this$ = ecx

; 3294 : {

	push	-1
	push	__ehhandler$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 124				; 0000007cH
	push	ebp

; 3295 : 	vector<int> aProcessedUnits;

	xor	ebp, ebp
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+144], edi
	mov	DWORD PTR _aProcessedUnits$[esp+148], ebp
	mov	DWORD PTR _aProcessedUnits$[esp+152], ebp
	mov	DWORD PTR _aProcessedUnits$[esp+156], ebp

; 3296 : 	list<int>::iterator it;
; 3297 : 	CvTacticalUnit unit;
; 3298 : 	CvCity* pCity;
; 3299 : 
; 3300 : 	if(m_pPlayer->isMinorCiv())

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR __$EHRec$[esp+152], ebp
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN218@PlotDefens

; 3301 : 	{
; 3302 : 		return;
; 3303 : 	}
; 3304 : 
; 3305 : 	// Is this a dominance zone where we're defending a city and that city has an airport?
; 3306 : 	CvTacticalDominanceZone* pZone = GC.getGame().GetTacticalAnalysisMap()->GetZone(m_iCurrentZoneIndex);

	mov	eax, DWORD PTR [edi+24792]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	push	esi
	push	eax
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	ecx, eax
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
	mov	esi, eax

; 3307 : 	pCity = pZone->GetClosestCity();

	mov	ecx, esi
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ebx, eax
	mov	DWORD PTR _pCity$[esp+152], ebx

; 3308 : 	if(pCity && pCity->getOwner() == m_pPlayer->GetID() && pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY && pCity->CanAirlift()&& pZone->GetEnemyUnitCount() > 0)

	test	ebx, ebx
	je	$LN229@PlotDefens
	mov	eax, DWORD PTR [ebx+84]
	mov	ecx, DWORD PTR [edi]
	cmp	eax, DWORD PTR [ecx+44]
	jne	$LN229@PlotDefens
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 2
	jne	$LN229@PlotDefens
	mov	ecx, ebx
	call	?CanAirlift@CvCity@@QBE_NXZ		; CvCity::CanAirlift
	test	al, al
	je	$LN229@PlotDefens
	cmp	DWORD PTR [esi+44], ebp
	jle	$LN229@PlotDefens

; 3309 : 	{
; 3310 : 		// Loop through all recruited units
; 3311 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 3312 : 		for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 3313 : #else
; 3314 : 		for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _it$[esp+152], ecx
	cmp	ecx, eax
	je	$LN229@PlotDefens
	jmp	SHORT $LN99@PlotDefens
	npad	5
$LL227@PlotDefens:
	mov	ecx, DWORD PTR _it$[esp+152]
$LN99@PlotDefens:

; 3315 : #endif
; 3316 : 		{
; 3317 : 			UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [edi]
	push	edx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$221914[esp+152], esi
	mov	BYTE PTR _pUnit$221914[esp+156], 0
	test	esi, esi
	je	SHORT $LN122@PlotDefens
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN122@PlotDefens:
	mov	BYTE PTR __$EHRec$[esp+160], 1

; 3318 : 			if(pUnit)

	test	esi, esi
	je	$LN4@PlotDefens

; 3319 : 			{
; 3320 : 				// If there a hex adjacent to city they can airlift to?
; 3321 : 				for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	xor	ebp, ebp
$LL9@PlotDefens:

; 3322 : 				{
; 3323 : 					CvPlot *pLoopPlot = plotDirection(pCity->getX(), pCity->getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	push	ebp
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 3324 : 					if (pLoopPlot != NULL)

	test	edi, edi
	je	SHORT $LN8@PlotDefens

; 3325 : 					{
; 3326 : 						if (pUnit->canAirliftAt(pUnit->plot(), pLoopPlot->getX(), pLoopPlot->getY()))

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?canAirliftAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canAirliftAt
	test	al, al
	jne	SHORT $LN223@PlotDefens
$LN8@PlotDefens:

; 3319 : 			{
; 3320 : 				// If there a hex adjacent to city they can airlift to?
; 3321 : 				for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL9@PlotDefens

; 3325 : 					{
; 3326 : 						if (pUnit->canAirliftAt(pUnit->plot(), pLoopPlot->getX(), pLoopPlot->getY()))

	jmp	$LN228@PlotDefens
$LN223@PlotDefens:

; 3327 : 						{
; 3328 : 							pUnit->airlift(pLoopPlot->getX(), pLoopPlot->getY());

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?airlift@CvUnit@@QAE_NHH@Z		; CvUnit::airlift

; 3329 : 
; 3330 : 							aProcessedUnits.push_back(pUnit->GetID());

	mov	edx, DWORD PTR [esi+100]
	lea	eax, DWORD PTR $T279693[esp+152]
	push	eax
	lea	ecx, DWORD PTR _aProcessedUnits$[esp+156]
	mov	DWORD PTR $T279693[esp+156], edx
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 3331 : 
; 3332 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN228@PlotDefens
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN228@PlotDefens

; 3333 : 							{
; 3334 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221926[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3335 : 								strLogString.Format("Airlifting %s to city of %s, Current X: %d, Current Y: %d", pUnit->getName().GetCString(), pCity->getName().GetCString(), pUnit->getX(), pUnit->getY());

	lea	ecx, DWORD PTR $T279694[esp+152]
	push	ecx
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+164], 2
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	edi, eax
	lea	edx, DWORD PTR $T279695[esp+152]
	push	edx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+164], 3
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ebp, eax
	mov	eax, DWORD PTR [esi+76]
	mov	ebx, DWORD PTR [esi+88]
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+160], 4
	mov	DWORD PTR $T280086[esp+152], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR $T280086[esp+152]
	push	ebx
	push	ecx
	push	eax
	mov	ecx, ebp
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$221926[esp+168]
	push	OFFSET $SG221929
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR $T279695[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T279694[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3336 : 								LogTacticalMessage(strLogString, false);

	mov	ecx, DWORD PTR _this$[esp+152]
	push	0
	lea	eax, DWORD PTR _strLogString$221926[esp+156]
	push	eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 3337 : 							}

	lea	ecx, DWORD PTR _strLogString$221926[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebx, DWORD PTR _pCity$[esp+152]
$LN228@PlotDefens:
	mov	edi, DWORD PTR _this$[esp+152]
$LN4@PlotDefens:

; 3338 : 
; 3339 : 							break;
; 3340 : 						}
; 3341 : 					}
; 3342 : 				}
; 3343 : 			}
; 3344 : 		}

	mov	BYTE PTR __$EHRec$[esp+160], 0
	test	esi, esi
	je	SHORT $LN12@PlotDefens
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@PlotDefens:
	mov	ecx, DWORD PTR _it$[esp+152]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _it$[esp+152], eax
	cmp	eax, DWORD PTR [edi+12]
	jne	$LL227@PlotDefens

; 3309 : 	{
; 3310 : 		// Loop through all recruited units
; 3311 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 3312 : 		for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 3313 : #else
; 3314 : 		for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	ebp, DWORD PTR _aProcessedUnits$[esp+160]
$LN229@PlotDefens:

; 3345 : 	}
; 3346 : 
; 3347 : 	// Mark units processed
; 3348 : 	vector<int>::const_iterator unitIt;
; 3349 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 3350 : 	for (unitIt = aProcessedUnits.begin(); unitIt != aProcessedUnits.end(); ++unitIt)
; 3351 : #else
; 3352 : 	for (unitIt = aProcessedUnits.begin(); unitIt != aProcessedUnits.end(); unitIt++)

	mov	ebx, DWORD PTR _aProcessedUnits$[esp+156]
	mov	esi, ebx
	cmp	ebx, ebp
	je	SHORT $LN1@PlotDefens
$LL199@PlotDefens:

; 3353 : #endif
; 3354 : 	{
; 3355 : 		UnitProcessed(*unitIt);

	mov	edx, DWORD PTR [esi]
	push	1
	push	edx
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed
	add	esi, 4
	cmp	esi, ebp
	jne	SHORT $LL199@PlotDefens
$LN1@PlotDefens:

; 3356 : 	}
; 3357 : }

	test	ebx, ebx
	je	SHORT $LN231@PlotDefens
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN231@PlotDefens:
	pop	esi
	pop	ebx
$LN218@PlotDefens:
	mov	ecx, DWORD PTR __$EHRec$[esp+144]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 136				; 00000088H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _aProcessedUnits$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$221914[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$221926[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR $T279694[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR $T279695[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotDefensiveAirlifts
PUBLIC	?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z ; CvTacticalAI::ExecuteAttack
EXTRN	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z:PROC	; CvUnit::canRangeStrikeAt
EXTRN	?setSetUpForRangedAttack@CvUnit@@QAEX_N@Z:PROC	; CvUnit::setSetUpForRangedAttack
EXTRN	?canSetUpForRangedAttack@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::canSetUpForRangedAttack
EXTRN	?GetMaxHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetMaxHitPoints
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$9
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$11
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$28
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$12
	DD	0bH
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$13
	DD	06H
	DD	FLAT:__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$14
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z
_TEXT	SEGMENT
_iDamageRemaining$ = -136				; size = 4
tv2130 = -132						; size = 4
$T281549 = -132						; size = 4
$T280222 = -132						; size = 4
$T280219 = -132						; size = 4
_pFirstAttacker$ = -128					; size = 4
_bFirstAttackRanged$ = -124				; size = 1
_iI$223304 = -120					; size = 4
_pAdjacentPlot$223298 = -120				; size = 4
_iI$223255 = -120					; size = 4
_bFirstAttackCity$ = -116				; size = 1
_pUnit$281495 = -112					; size = 8
_pUnit$223261 = -112					; size = 8
_pUnit$223310 = -104					; size = 8
_plotList$ = -96					; size = 16
_strMsg$223286 = -96					; size = 28
_strMsg$223281 = -96					; size = 28
_strMsg$223272 = -96					; size = 28
_strMsg$223500 = -68					; size = 28
_strMsg$223495 = -68					; size = 28
_strMsg$223487 = -68					; size = 28
_strMsg$223482 = -68					; size = 28
$T280215 = -68						; size = 28
_strTemp$223271 = -68					; size = 28
$T280223 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
_pTargetPlot$ = 12					; size = 4
_bInflictWhatWeTake$ = 16				; size = 1
_bMustSurviveAttack$ = 20				; size = 1
?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z PROC ; CvTacticalAI::ExecuteAttack, COMDAT
; _this$ = ecx

; 6264 : {

	push	-1
	push	__ehhandler$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 124				; 0000007cH

; 6265 : 	void* pFirstAttacker = NULL;
; 6266 : 	bool bFirstAttackRanged = false;
; 6267 : 	bool bFirstAttackCity = false;
; 6268 : 
; 6269 : 	if(PlotAlreadyTargeted(pTargetPlot) != -1)

	mov	eax, DWORD PTR _pTargetPlot$[esp+132]
	push	ebx
	push	ebp
	push	esi
	push	edi
	xor	ebx, ebx
	push	eax
	mov	esi, ecx
	mov	DWORD PTR _pFirstAttacker$[esp+156], ebx
	mov	BYTE PTR _bFirstAttackRanged$[esp+156], bl
	mov	BYTE PTR _bFirstAttackCity$[esp+156], bl
	call	?PlotAlreadyTargeted@CvTacticalAI@@QAEHPAVCvPlot@@@Z ; CvTacticalAI::PlotAlreadyTargeted
	cmp	eax, -1
	jne	$LN617@ExecuteAtt

; 6270 : 	{
; 6271 : 		return;
; 6272 : 	}
; 6273 : 
; 6274 : 	// How much damage do we still need to inflict?
; 6275 : 	int iDamageRemaining = (pTarget->GetAuxIntData() * (100 + GC.getAI_TACTICAL_OVERKILL_PERCENT())) / 100;

	mov	ecx, DWORD PTR _pTarget$[esp+148]
	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2468
	add	ecx, 100				; 00000064H
	imul	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 6276 : 
; 6277 : 	// Start by applying damage from city bombards
; 6278 : 	for(unsigned int iI = 0; iI < m_CurrentMoveCities.size() && iDamageRemaining > 0; iI++)

	mov	ecx, DWORD PTR [esi+60]
	sub	ecx, DWORD PTR [esi+56]
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iDamageRemaining$[esp+152], edi
	je	SHORT $LN56@ExecuteAtt

; 6270 : 	{
; 6271 : 		return;
; 6272 : 	}
; 6273 : 
; 6274 : 	// How much damage do we still need to inflict?
; 6275 : 	int iDamageRemaining = (pTarget->GetAuxIntData() * (100 + GC.getAI_TACTICAL_OVERKILL_PERCENT())) / 100;

	xor	ebp, ebp
$LL58@ExecuteAtt:

; 6276 : 
; 6277 : 	// Start by applying damage from city bombards
; 6278 : 	for(unsigned int iI = 0; iI < m_CurrentMoveCities.size() && iDamageRemaining > 0; iI++)

	test	edi, edi
	jle	SHORT $LN56@ExecuteAtt

; 6279 : 	{
; 6280 : #ifdef DEL_RANGED_COUNTERATTACKS
; 6281 : 		if (!bInflictWhatWeTake || m_CurrentMoveCities[iI].GetExpectedTargetDamage() >= m_CurrentMoveCities[iI].GetExpectedSelfDamage())
; 6282 : 		{
; 6283 : #endif
; 6284 : 		CvCity* pCity = m_pPlayer->getCity(m_CurrentMoveCities[iI].GetID());

	mov	eax, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebp
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax

; 6285 : 		if(pCity != NULL)

	test	edi, edi
	je	SHORT $LN57@ExecuteAtt

; 6286 : 		{
; 6287 : 			if(QueueAttack(pCity, pTarget, true /*bRanged*/, true /*bCity*/))

	mov	ecx, DWORD PTR _pTarget$[esp+148]
	push	1
	push	1
	push	ecx
	push	edi
	mov	ecx, esi
	call	?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z ; CvTacticalAI::QueueAttack
	test	al, al
	je	SHORT $LN54@ExecuteAtt

; 6288 : 			{
; 6289 : 				pFirstAttacker = (void*)pCity;

	mov	DWORD PTR _pFirstAttacker$[esp+152], edi

; 6290 : 				bFirstAttackRanged = true;

	mov	BYTE PTR _bFirstAttackRanged$[esp+152], 1

; 6291 : 				bFirstAttackCity = true;

	mov	BYTE PTR _bFirstAttackCity$[esp+152], 1
$LN54@ExecuteAtt:

; 6292 : 			}
; 6293 : 
; 6294 : 			// Subtract off expected damage
; 6295 : 			iDamageRemaining -= m_CurrentMoveCities[iI].GetExpectedTargetDamage();

	mov	edx, DWORD PTR [esi+56]
	mov	eax, DWORD PTR [edx+ebp+8]
	sub	DWORD PTR _iDamageRemaining$[esp+152], eax
$LN57@ExecuteAtt:
	mov	ecx, DWORD PTR [esi+60]
	sub	ecx, DWORD PTR [esi+56]
	mov	edi, DWORD PTR _iDamageRemaining$[esp+152]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	inc	ebx
	add	ecx, edx
	add	ebp, 12					; 0000000cH
	cmp	ebx, ecx
	jb	SHORT $LL58@ExecuteAtt
$LN56@ExecuteAtt:

; 6296 : 		}
; 6297 : #ifdef DEL_RANGED_COUNTERATTACKS
; 6298 : 		}
; 6299 : #endif
; 6300 : 	}
; 6301 : 
; 6302 : 	// First loop is ranged units only
; 6303 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size() && iDamageRemaining > 0; iI++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iI$223255[esp+152], 0
	je	$LN51@ExecuteAtt
	xor	ebx, ebx
	mov	DWORD PTR tv2130[esp+152], ebx
	npad	2
$LL53@ExecuteAtt:
	test	edi, edi
	jle	$LN51@ExecuteAtt

; 6304 : 	{
; 6305 : 		if(!bInflictWhatWeTake || m_CurrentMoveUnits[iI].GetExpectedTargetDamage() >= m_CurrentMoveUnits[iI].GetExpectedSelfDamage())

	cmp	BYTE PTR _bInflictWhatWeTake$[esp+148], 0
	je	$LN49@ExecuteAtt
	mov	ecx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [eax+20]
	jge	SHORT $LN49@ExecuteAtt

; 6373 : 		else
; 6374 : 		{
; 6375 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN52@ExecuteAtt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN52@ExecuteAtt

; 6376 : 			{
; 6377 : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223286[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6378 : 				strMsg.Format("Not attacking with unit. Can't generate a good damage ratio.");

	lea	edx, DWORD PTR _strMsg$223286[esp+152]
	push	OFFSET $SG223287
	push	edx
	mov	DWORD PTR __$EHRec$[esp+168], 5
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 6379 : 				LogTacticalMessage(strMsg);

	push	1
	lea	eax, DWORD PTR _strMsg$223286[esp+156]
	push	eax
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 6380 : 			}

	lea	ecx, DWORD PTR _strMsg$223286[esp+152]
	mov	DWORD PTR __$EHRec$[esp+160], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN52@ExecuteAtt
$LN49@ExecuteAtt:

; 6306 : 		{
; 6307 : 			UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$223261[esp+152], edi
	mov	BYTE PTR _pUnit$223261[esp+156], 0
	test	edi, edi
	je	SHORT $LN108@ExecuteAtt
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN108@ExecuteAtt:
	mov	DWORD PTR __$EHRec$[esp+160], 0

; 6308 : 			if(pUnit)

	test	edi, edi
	je	$LN38@ExecuteAtt

; 6309 : 			{
; 6310 : 				if(pUnit->getMoves() > 0)

	mov	ecx, edi
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jle	$LN38@ExecuteAtt

; 6311 : 				{
; 6312 : 					if(!bMustSurviveAttack || ((m_CurrentMoveUnits[iI].GetExpectedSelfDamage() + pUnit->getDamage()) < pUnit->GetMaxHitPoints()))

	cmp	BYTE PTR _bMustSurviveAttack$[esp+148], 0
	je	$LN45@ExecuteAtt
	mov	eax, DWORD PTR [esi+24]
	mov	ebp, DWORD PTR [eax+ebx+20]
	add	eax, ebx
	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, edi
	add	ebp, eax
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	cmp	ebp, eax
	jl	$LN45@ExecuteAtt

; 6356 : 									}
; 6357 : 								}
; 6358 : 							}
; 6359 : 						}
; 6360 : 					}
; 6361 : 					else
; 6362 : 					{
; 6363 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN38@ExecuteAtt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN38@ExecuteAtt

; 6364 : 						{
; 6365 : 							CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223281[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6366 : 							strMsg.Format("Not attacking with unit. We'll destroy ourself, %s, X: %d, Y: %d", pUnit->getName().GetCString(), pUnit->getX(), pUnit->getY());

	lea	ecx, DWORD PTR $T280215[esp+152]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+164], 3
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [edi+88]
	mov	edx, DWORD PTR [edi+76]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+168], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strMsg$223281[esp+164]
	push	OFFSET $SG223283
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T280215[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6367 : 							LogTacticalMessage(strMsg);

	push	1
	lea	eax, DWORD PTR _strMsg$223281[esp+156]
	push	eax
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 6368 : 						}

	lea	ecx, DWORD PTR _strMsg$223281[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN38@ExecuteAtt
$LN45@ExecuteAtt:

; 6313 : 					{
; 6314 : 						// Are we a ranged unit
; 6315 : 						if(pUnit->IsCanAttackRanged())

	mov	ecx, edi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	$LN38@ExecuteAtt

; 6316 : 						{
; 6317 : 							// Are we in range?
; 6318 : 							if(plotDistance(pUnit->getX(), pUnit->getY(), pTargetPlot->getX(), pTargetPlot->getY()) <= pUnit->GetRange())

	mov	ebp, DWORD PTR _pTargetPlot$[esp+148]
	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	mov	edx, DWORD PTR [edi+88]
	mov	ebx, DWORD PTR [edi+76]
	push	eax
	push	ecx
	push	edx
	push	ebx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	ecx, edi
	mov	ebx, eax
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	cmp	ebx, eax
	jg	$LN641@ExecuteAtt

; 6319 : 							{
; 6320 : 								// Do we have LOS to the target?
; 6321 : 								if(pUnit->canEverRangeStrikeAt(pTargetPlot->getX(), pTargetPlot->getY()))

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?canEverRangeStrikeAt@CvUnit@@QBE_NHH@Z	; CvUnit::canEverRangeStrikeAt
	test	al, al
	je	$LN641@ExecuteAtt

; 6322 : 								{
; 6323 : 									// Do we need to set up to make a ranged attack?
; 6324 : 									if(pUnit->canSetUpForRangedAttack(NULL))

	push	0
	mov	ecx, edi
	call	?canSetUpForRangedAttack@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canSetUpForRangedAttack
	test	al, al
	je	$LN39@ExecuteAtt

; 6325 : 									{
; 6326 : 										pUnit->setSetUpForRangedAttack(true);

	push	1
	mov	ecx, edi
	call	?setSetUpForRangedAttack@CvUnit@@QAEX_N@Z ; CvUnit::setSetUpForRangedAttack

; 6327 : 										if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN40@ExecuteAtt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN40@ExecuteAtt

; 6328 : 										{
; 6329 : 											CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223271[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6330 : 											CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223272[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6331 : 											strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+160], 2
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$223271[esp+156]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 6332 : 											strMsg.Format("Set up %s for ranged attack", strTemp.GetCString());

	lea	ecx, DWORD PTR _strTemp$223271[esp+152]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMsg$223272[esp+156]
	push	OFFSET $SG223273
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 6333 : 											LogTacticalMessage(strMsg);

	push	1
	lea	edx, DWORD PTR _strMsg$223272[esp+156]
	push	edx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 6334 : 										}

	lea	ecx, DWORD PTR _strMsg$223272[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$223271[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN40@ExecuteAtt:

; 6335 : 										if(!pUnit->canMove())

	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	jne	SHORT $LN39@ExecuteAtt

; 6336 : 										{
; 6337 : 											pUnit->SetTacticalAIPlot(NULL);

	push	0
	mov	ecx, edi
	call	?SetTacticalAIPlot@CvUnit@@QAEXPAVCvPlot@@@Z ; CvUnit::SetTacticalAIPlot

; 6338 : 											UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR [edi+100]
	push	1
	push	eax
	mov	ecx, esi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed
$LN39@ExecuteAtt:

; 6339 : 										}
; 6340 : 									}
; 6341 : 
; 6342 : 									// Can we hit it with a ranged attack?  If so, that gets first priority
; 6343 : 									if(pUnit->canMove() && pUnit->canRangeStrikeAt(pTargetPlot->getX(), pTargetPlot->getY()))

	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	SHORT $LN641@ExecuteAtt
	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	1
	push	1
	push	eax
	push	ecx
	mov	ecx, edi
	call	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z	; CvUnit::canRangeStrikeAt
	test	al, al
	je	SHORT $LN641@ExecuteAtt

; 6344 : 									{
; 6345 : 										// Queue up this attack
; 6346 : 										if(QueueAttack((void*)pUnit.pointer(), pTarget, true /*bRanged*/, false /*bCity*/))

	mov	eax, DWORD PTR _pTarget$[esp+148]
	push	0
	push	1
	push	eax
	push	edi
	mov	ecx, esi
	call	?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z ; CvTacticalAI::QueueAttack
	test	al, al
	je	SHORT $LN37@ExecuteAtt

; 6347 : 										{
; 6348 : 											pFirstAttacker = (void*)pUnit.pointer();

	mov	DWORD PTR _pFirstAttacker$[esp+152], edi

; 6349 : 											bFirstAttackRanged = true;

	mov	BYTE PTR _bFirstAttackRanged$[esp+152], 1
$LN37@ExecuteAtt:

; 6350 : 										}
; 6351 : 										pUnit->SetTacticalAIPlot(NULL);

	push	0
	mov	ecx, edi
	call	?SetTacticalAIPlot@CvUnit@@QAEXPAVCvPlot@@@Z ; CvUnit::SetTacticalAIPlot

; 6352 : 										UnitProcessed(m_CurrentMoveUnits[iI].GetID());

	mov	ecx, DWORD PTR [esi+24]
	mov	ebx, DWORD PTR tv2130[esp+152]
	mov	eax, DWORD PTR [ebx+ecx]
	push	1
	push	eax
	mov	ecx, esi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 6353 : 
; 6354 : 										// Subtract off expected damage
; 6355 : 										iDamageRemaining -= m_CurrentMoveUnits[iI].GetExpectedTargetDamage();

	mov	edx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [edx+ebx+16]
	sub	DWORD PTR _iDamageRemaining$[esp+152], eax
	jmp	SHORT $LN38@ExecuteAtt
$LN641@ExecuteAtt:
	mov	ebx, DWORD PTR tv2130[esp+152]
$LN38@ExecuteAtt:

; 6369 : 					}
; 6370 : 				}
; 6371 : 			}
; 6372 : 		}

	mov	DWORD PTR __$EHRec$[esp+160], -1
	test	edi, edi
	je	SHORT $LN52@ExecuteAtt
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN52@ExecuteAtt:
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	edi, DWORD PTR _iI$223255[esp+152]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	inc	edi
	add	ebx, 24					; 00000018H
	add	ecx, edx
	mov	DWORD PTR _iI$223255[esp+152], edi
	cmp	edi, ecx
	mov	edi, DWORD PTR _iDamageRemaining$[esp+152]
	mov	DWORD PTR tv2130[esp+152], ebx
	jb	$LL53@ExecuteAtt
$LN51@ExecuteAtt:

; 6381 : 		}
; 6382 : 	}
; 6383 : 
; 6384 : 	// If target is city, want to get in one melee attack, so set damage remaining to 1
; 6385 : 	if(pTarget->GetTargetType() == AI_TACTICAL_TARGET_CITY && iDamageRemaining < 1)

	mov	edx, DWORD PTR _pTarget$[esp+148]
	cmp	DWORD PTR [edx], 1
	jne	SHORT $LN32@ExecuteAtt
	cmp	edi, 1
	jge	SHORT $LN32@ExecuteAtt

; 6386 : 	{
; 6387 : 		iDamageRemaining = 1;

	mov	DWORD PTR _iDamageRemaining$[esp+152], 1
$LN32@ExecuteAtt:

; 6388 : 	}
; 6389 : 
; 6390 : 	// Make a list of adjacent plots
; 6391 : 	std::vector<CvPlot *> plotList;

	xor	ebx, ebx
	mov	DWORD PTR _plotList$[esp+156], ebx
	mov	DWORD PTR _plotList$[esp+160], ebx
	mov	DWORD PTR _plotList$[esp+164], ebx
	mov	DWORD PTR __$EHRec$[esp+160], 6
$LL31@ExecuteAtt:

; 6392 : 	for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)
; 6393 : 	{
; 6394 : 		CvPlot* pAdjacentPlot = plotDirection(pTargetPlot->getX(), pTargetPlot->getY(), ((DirectionTypes)iDirectionLoop));

	mov	eax, DWORD PTR _pTargetPlot$[esp+148]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ebx
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$223298[esp+152], edi

; 6395 : 		if (pAdjacentPlot)

	test	edi, edi
	je	$LN30@ExecuteAtt

; 6396 : 		{
; 6397 : 			int iPlotIndex = GC.getMap().plotNum(pAdjacentPlot->getX(), pAdjacentPlot->getY());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [eax+4020]
	movsx	eax, WORD PTR [edi+2]

; 6398 : 			CvTacticalAnalysisCell *pCell = m_pMap->GetCell(iPlotIndex);

	mov	edx, DWORD PTR [esi+4]
	imul	eax, ecx
	movsx	ecx, WORD PTR [edi]
	add	eax, ecx
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [edx+12]

; 6399 : 			if(pAdjacentPlot != NULL && pAdjacentPlot->getNumDefenders(pTarget->GetTargetPlayer()) == 0 && !pCell->IsEnemyCity())

	mov	ecx, edi
	mov	ebp, eax
	mov	eax, DWORD PTR _pTarget$[esp+148]
	mov	eax, DWORD PTR [eax+12]
	push	eax
	call	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	test	eax, eax
	jne	SHORT $LN30@ExecuteAtt
	mov	ecx, DWORD PTR [ebp]
	shr	ecx, 9
	test	cl, 1
	jne	SHORT $LN30@ExecuteAtt

; 6400 : 			{
; 6401 : 				plotList.push_back(pAdjacentPlot);

	mov	edx, DWORD PTR _plotList$[esp+156]
	test	edx, edx
	je	SHORT $LN308@ExecuteAtt
$LN307@ExecuteAtt:
	mov	eax, DWORD PTR _plotList$[esp+164]
	sub	eax, edx
	sar	eax, 2
$LN308@ExecuteAtt:
	mov	ecx, DWORD PTR _plotList$[esp+160]
	mov	ebp, ecx
	sub	ebp, edx
	sar	ebp, 2
	cmp	ebp, eax
	jae	SHORT $LN300@ExecuteAtt
	mov	DWORD PTR [ecx], edi
	add	ecx, 4
	mov	DWORD PTR _plotList$[esp+160], ecx
	jmp	SHORT $LN30@ExecuteAtt
$LN300@ExecuteAtt:
	mov	eax, DWORD PTR _plotList$[esp+160]
	lea	edx, DWORD PTR _pAdjacentPlot$223298[esp+152]
	push	edx
	push	1
	push	eax
	lea	ecx, DWORD PTR _plotList$[esp+164]
	call	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n
$LN30@ExecuteAtt:
	inc	ebx
	cmp	ebx, 6
	jl	$LL31@ExecuteAtt

; 6402 : 			}
; 6403 : 		}
; 6404 : 	}
; 6405 : 
; 6406 : 	// Second loop are only melee units
; 6407 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size() && iDamageRemaining > 0; iI++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _iI$223304[esp+152], 0
	je	$LN24@ExecuteAtt
	xor	ebx, ebx
	npad	5
$LL26@ExecuteAtt:
	cmp	DWORD PTR _iDamageRemaining$[esp+152], 0
	jle	$LN24@ExecuteAtt

; 6408 : 	{
; 6409 : 		if(!bInflictWhatWeTake || m_CurrentMoveUnits[iI].GetExpectedTargetDamage() >= m_CurrentMoveUnits[iI].GetExpectedSelfDamage())

	cmp	BYTE PTR _bInflictWhatWeTake$[esp+148], 0
	je	$LN22@ExecuteAtt
	mov	edx, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edx+ebx+16]
	cmp	ecx, DWORD PTR [edx+ebx+20]
	lea	eax, DWORD PTR [edx+ebx]
	jge	SHORT $LN22@ExecuteAtt

; 6496 : 		else
; 6497 : 		{
; 6498 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN25@ExecuteAtt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN25@ExecuteAtt

; 6499 : 			{
; 6500 : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223500[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6501 : 				strMsg.Format("Not attacking with unit. Can't generate a good damage ratio.");

	lea	eax, DWORD PTR _strMsg$223500[esp+152]
	push	OFFSET $SG223501
	push	eax
	mov	BYTE PTR __$EHRec$[esp+168], 13		; 0000000dH
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 6502 : 				LogTacticalMessage(strMsg);

	push	1
	lea	ecx, DWORD PTR _strMsg$223500[esp+156]
	push	ecx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 6503 : 			}

	lea	ecx, DWORD PTR _strMsg$223500[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN25@ExecuteAtt
$LN22@ExecuteAtt:

; 6410 : 		{
; 6411 : 			UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$223310[esp+152], edi
	mov	BYTE PTR _pUnit$223310[esp+156], 0
	test	edi, edi
	je	SHORT $LN377@ExecuteAtt
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN377@ExecuteAtt:
	mov	BYTE PTR __$EHRec$[esp+160], 7

; 6412 : 			if(pUnit)

	test	edi, edi
	je	$LN4@ExecuteAtt

; 6413 : 			{
; 6414 : 				if(pUnit->getMoves() > 0 && (!bMustSurviveAttack || ((m_CurrentMoveUnits[iI].GetExpectedSelfDamage() + pUnit->getDamage()) < pUnit->GetMaxHitPoints())))

	mov	ecx, edi
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jle	$LN20@ExecuteAtt
	cmp	BYTE PTR _bMustSurviveAttack$[esp+148], 0
	je	SHORT $LN19@ExecuteAtt
	mov	eax, DWORD PTR [esi+24]
	mov	ebp, DWORD PTR [eax+ebx+20]
	add	eax, ebx
	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, edi
	add	ebp, eax
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	cmp	ebp, eax
	jge	$LN20@ExecuteAtt
$LN19@ExecuteAtt:

; 6415 : 				{
; 6416 : 					// Are we a melee unit
; 6417 : 					if(!pUnit->IsCanAttackRanged())

	mov	ecx, edi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	jne	$LN4@ExecuteAtt

; 6418 : 					{
; 6419 : 						bool bQueueAttackNow = false;
; 6420 : 						
; 6421 : 						// Already adjacent?
; 6422 : 						if (plotDistance(pUnit->getX(), pUnit->getY(), pTargetPlot->getX(), pTargetPlot->getY()) <= 1)

	mov	edx, DWORD PTR _pTargetPlot$[esp+148]
	movsx	ebp, WORD PTR [edx+2]
	movsx	edx, WORD PTR [edx]
	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	ebp
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jle	$LN632@ExecuteAtt

; 6423 : 						{
; 6424 : 							bQueueAttackNow = true;
; 6425 : 						}
; 6426 : 						else
; 6427 : 						{
; 6428 : 							// Find spaces adjacent to target we can move into with MP left
; 6429 : 							std::vector<CvPlot *>::iterator it;
; 6430 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 6431 : 							for (it = plotList.begin(); it != plotList.end(); ++it)
; 6432 : #else
; 6433 : 							for (it = plotList.begin(); it != plotList.end(); it++)

	mov	ebp, DWORD PTR _plotList$[esp+156]
	cmp	ebp, DWORD PTR _plotList$[esp+160]
	je	SHORT $LN633@ExecuteAtt
$LL423@ExecuteAtt:

; 6434 : #endif
; 6435 : 							{
; 6436 : 								if (TurnsToReachTarget(pUnit, *it, false /*bReusePaths*/, false /*bIgnoreUnits*/, true /*bIgnoreStacking*/) == 0)

	mov	eax, DWORD PTR [ebp]
	push	1
	push	0
	push	0
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T280219[esp+176], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	test	eax, eax
	je	$LN625@ExecuteAtt
	add	ebp, 4
	cmp	ebp, DWORD PTR _plotList$[esp+160]
	jne	SHORT $LL423@ExecuteAtt
$LN633@ExecuteAtt:

; 6443 : 									break;
; 6444 : 								}
; 6445 : 							}
; 6446 : 
; 6447 : 							// Didn't find an open hex
; 6448 : 							if (!bQueueAttackNow)
; 6449 : 							{
; 6450 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN645@ExecuteAtt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN645@ExecuteAtt

; 6451 : 								{
; 6452 : 									CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223482[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6453 : 									strMsg.Format("Not enough free hexes next for all melee units to attack, Target X: %d, Y: %d", pTargetPlot->getX(), pTargetPlot->getY());

	mov	ebp, DWORD PTR _pTargetPlot$[esp+148]
	movsx	ecx, WORD PTR [ebp+2]
	movsx	edx, WORD PTR [ebp]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strMsg$223482[esp+160]
	push	OFFSET $SG223483
	push	eax
	mov	BYTE PTR __$EHRec$[esp+176], 8
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 6454 : 									LogTacticalMessage(strMsg);

	push	1
	lea	ecx, DWORD PTR _strMsg$223482[esp+156]
	push	ecx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 6455 : 								}

	lea	ecx, DWORD PTR _strMsg$223482[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN10@ExecuteAtt
$LN625@ExecuteAtt:

; 6437 : 								{
; 6438 : 									// Move up there
; 6439 : 									pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), (*it)->getX(), (*it)->getY());

	mov	eax, DWORD PTR [ebp]
	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6440 : 									bQueueAttackNow = true;
; 6441 : 
; 6442 : 									plotList.erase(it);

	mov	eax, DWORD PTR _plotList$[esp+160]
	lea	ecx, DWORD PTR [ebp+4]
	sub	eax, ecx
	sar	eax, 2
	test	eax, eax
	jle	SHORT $LN466@ExecuteAtt
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	ebp
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN466@ExecuteAtt:
	sub	DWORD PTR _plotList$[esp+160], 4
$LN632@ExecuteAtt:

; 6471 : 						{
; 6472 : 							// Queue up this attack
; 6473 : 							if(QueueAttack((void*)pUnit.pointer(), pTarget, false /*bRanged*/, false /*bCity*/))

	mov	eax, DWORD PTR _pTarget$[esp+148]
	push	0
	push	0
	push	eax
	push	edi
	mov	ecx, esi
	call	?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z ; CvTacticalAI::QueueAttack
	test	al, al
	je	SHORT $LN6@ExecuteAtt

; 6474 : 							{
; 6475 : 								pFirstAttacker = (void*)pUnit.pointer();

	mov	DWORD PTR _pFirstAttacker$[esp+152], edi
$LN6@ExecuteAtt:

; 6476 : 							}
; 6477 : 							pUnit->SetTacticalAIPlot(NULL);

	push	0
	mov	ecx, edi
	call	?SetTacticalAIPlot@CvUnit@@QAEXPAVCvPlot@@@Z ; CvUnit::SetTacticalAIPlot

; 6478 : 							UnitProcessed(m_CurrentMoveUnits[iI].GetID(), false /*bMarkTacticalMap*/);

	mov	ecx, DWORD PTR [esi+24]
	mov	ebp, DWORD PTR [ebx+ecx]
	mov	DWORD PTR $T281549[esp+152], ebp
	mov	DWORD PTR _pUnit$281495[esp+152], 0
	mov	BYTE PTR _pUnit$281495[esp+156], 0
	lea	edx, DWORD PTR $T281549[esp+152]
	push	edx
	lea	ecx, DWORD PTR [esi+8]
	mov	BYTE PTR __$EHRec$[esp+164], 10		; 0000000aH
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [esi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebp, eax
	mov	DWORD PTR _pUnit$281495[esp+152], ebp
	test	ebp, ebp
	je	SHORT $LN533@ExecuteAtt
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN533@ExecuteAtt:
	push	1
	mov	ecx, ebp
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
	mov	BYTE PTR __$EHRec$[esp+160], 7
	test	ebp, ebp
	je	SHORT $LN570@ExecuteAtt
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN570@ExecuteAtt:

; 6479 : 
; 6480 : 							// Subtract off expected damage
; 6481 : 							iDamageRemaining -= m_CurrentMoveUnits[iI].GetExpectedTargetDamage();

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax+ebx+16]
	sub	DWORD PTR _iDamageRemaining$[esp+152], ecx

; 6482 : 						}
; 6483 : 					}
; 6484 : 				}
; 6485 : 				else

	jmp	$LN4@ExecuteAtt
$LN645@ExecuteAtt:

; 6455 : 								}

	mov	ebp, DWORD PTR _pTargetPlot$[esp+148]
$LN10@ExecuteAtt:

; 6456 : 								
; 6457 : 								// Move up if we can
; 6458 : 								if (MoveToEmptySpaceNearTarget(pUnit, pTargetPlot, (pUnit->getDomainType() == DOMAIN_LAND)))

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	sete	dl
	movzx	eax, dl
	push	eax
	push	ebp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T280222[esp+168], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, esi
	call	?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::MoveToEmptySpaceNearTarget
	test	al, al
	je	$LN4@ExecuteAtt

; 6459 : 								{
; 6460 : 									if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN4@ExecuteAtt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN4@ExecuteAtt

; 6461 : 									{
; 6462 : 										CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223487[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6463 : 										strMsg.Format("Moving adjacent for attack next turn, Now at X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strMsg$223487[esp+160]
	push	OFFSET $SG223488
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+176], 9
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 6464 : 										LogTacticalMessage(strMsg);

	push	1
	lea	edx, DWORD PTR _strMsg$223487[esp+156]
	push	edx

; 6465 : 									}
; 6466 : 								}
; 6467 : 							}
; 6468 : 						}
; 6469 : 
; 6470 : 						if (bQueueAttackNow)

	jmp	$LN649@ExecuteAtt
$LN20@ExecuteAtt:

; 6486 : 				{
; 6487 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN4@ExecuteAtt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN4@ExecuteAtt

; 6488 : 					{
; 6489 : 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223495[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6490 : 						strMsg.Format("Not attacking with unit. We'll destroy ourself, %s, X: %d, Y: %d", pUnit->getName().GetCString(), pUnit->getX(), pUnit->getY());

	lea	edx, DWORD PTR $T280223[esp+152]
	push	edx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+164], 11		; 0000000bH
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [edi+88]
	mov	edx, DWORD PTR [edi+76]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+168], 12		; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strMsg$223495[esp+164]
	push	OFFSET $SG223497
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T280223[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 11		; 0000000bH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6491 : 						LogTacticalMessage(strMsg);

	push	1
	lea	ecx, DWORD PTR _strMsg$223495[esp+156]
	push	ecx
$LN649@ExecuteAtt:
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 6492 : 					}

	lea	ecx, DWORD PTR _strMsg$223495[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@ExecuteAtt:

; 6493 : 				}
; 6494 : 			}
; 6495 : 		}

	mov	BYTE PTR __$EHRec$[esp+160], 6
	test	edi, edi
	je	SHORT $LN25@ExecuteAtt
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN25@ExecuteAtt:
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	edi, DWORD PTR _iI$223304[esp+152]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	edi
	add	eax, edx
	add	ebx, 24					; 00000018H
	mov	DWORD PTR _iI$223304[esp+152], edi
	cmp	edi, eax
	jb	$LL26@ExecuteAtt
$LN24@ExecuteAtt:

; 6504 : 		}
; 6505 : 	}
; 6506 : 
; 6507 : 	// Start up first attack
; 6508 : 	if(pFirstAttacker)

	mov	eax, DWORD PTR _pFirstAttacker$[esp+152]
	test	eax, eax
	je	SHORT $LN1@ExecuteAtt

; 6509 : 	{
; 6510 : 		LaunchAttack(pFirstAttacker, pTarget, true /*bFirst*/, bFirstAttackRanged, bFirstAttackCity);

	mov	ecx, DWORD PTR _bFirstAttackCity$[esp+152]
	mov	edx, DWORD PTR _bFirstAttackRanged$[esp+152]
	push	ecx
	mov	ecx, DWORD PTR _pTarget$[esp+152]
	push	edx
	push	1
	push	ecx
	push	eax
	mov	ecx, esi
	call	?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z ; CvTacticalAI::LaunchAttack
$LN1@ExecuteAtt:

; 6511 : 	}
; 6512 : }

	mov	eax, DWORD PTR _plotList$[esp+156]
	test	eax, eax
	je	SHORT $LN617@ExecuteAtt
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN617@ExecuteAtt:
	mov	ecx, DWORD PTR __$EHRec$[esp+152]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 136				; 00000088H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$5:
	lea	ecx, DWORD PTR _strMsg$223286[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$0:
	lea	ecx, DWORD PTR _pUnit$223261[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$3:
	lea	ecx, DWORD PTR _strMsg$223281[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$4:
	lea	ecx, DWORD PTR $T280215[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$1:
	lea	ecx, DWORD PTR _strTemp$223271[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$2:
	lea	ecx, DWORD PTR _strMsg$223272[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$6:
	lea	ecx, DWORD PTR _plotList$[ebp]
	jmp	??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$14:
	lea	ecx, DWORD PTR _strMsg$223500[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$7:
	lea	ecx, DWORD PTR _pUnit$223310[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$9:
	lea	ecx, DWORD PTR _strMsg$223482[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$28:
	lea	ecx, DWORD PTR _pUnit$281495[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$11:
	lea	ecx, DWORD PTR _strMsg$223487[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$12:
	lea	ecx, DWORD PTR _strMsg$223495[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z$13:
	lea	ecx, DWORD PTR $T280223[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z ENDP ; CvTacticalAI::ExecuteAttack
PUBLIC	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z
_TEXT	SEGMENT
$T281709 = -4						; size = 1
__Cat$281713 = 8					; size = 1
$T281680 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z PROC ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@14
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@14
$LN9@push_back@14:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@14:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@14

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$281713[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T281709[esp+16], 0
	mov	ecx, DWORD PTR $T281709[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAVCvTacticalUnit@@IV1@V?$allocator@VCvTacticalUnit@@@std@@@std@@YAXPAVCvTacticalUnit@@IABV1@AAV?$allocator@VCvTacticalUnit@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvTacticalUnit *,unsigned int,CvTacticalUnit,std::allocator<CvTacticalUnit> >
	add	esp, 24					; 00000018H
	add	edi, 24					; 00000018H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@14:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T281680[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@2@ABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ENDP ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEXABVCvTacticalCity@@@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEXABVCvTacticalCity@@@Z
_TEXT	SEGMENT
$T281767 = -4						; size = 1
__Cat$281771 = 8					; size = 1
$T281738 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEXABVCvTacticalCity@@@Z PROC ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@15
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@15
$LN9@push_back@15:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@15:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@15

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$281771[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T281767[esp+16], 0
	mov	ecx, DWORD PTR $T281767[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAVCvTacticalCity@@IV1@V?$allocator@VCvTacticalCity@@@std@@@std@@YAXPAVCvTacticalCity@@IABV1@AAV?$allocator@VCvTacticalCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvTacticalCity *,unsigned int,CvTacticalCity,std::allocator<CvTacticalCity> >
	add	esp, 24					; 00000018H
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@15:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T281738[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@ABVCvTacticalCity@@@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEXABVCvTacticalCity@@@Z ENDP ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::push_back
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXXZ ; CvWeightedVector<CvPlot *,1,1>::SortItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXXZ PROC ; CvWeightedVector<CvPlot *,1,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXXZ ENDP ; CvWeightedVector<CvPlot *,1,1>::SortItems
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z$0
__ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	-1
	push	__ehhandler$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3411 : 	_Diff _Count = 0;
; 3412 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	mov	edx, eax
	push	edx
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalUnit@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>

; 3415 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+60]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN24@Stable_sor@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Stable_sor@3:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvTacticalUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalUnit>::~_Temp_iterator<CvTacticalUnit>
__ehhandler$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z$0
__ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	-1
	push	__ehhandler$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3411 : 	_Diff _Count = 0;
; 3412 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	mov	edx, eax
	push	edx
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0HAAV?$_Temp_iterator@VCvTacticalCity@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>

; 3415 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+60]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN24@Stable_sor@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Stable_sor@4:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvTacticalCity@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalCity>::~_Temp_iterator<CvTacticalCity>
__ehhandler$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
PUBLIC	??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Stable_sort<CvTacticalMove *,int,CvTacticalMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z PROC ; std::_Stable_sort<CvTacticalMove *,int,CvTacticalMove>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	edi

; 3382 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor@5

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvTacticalMove@@V1@@std@@YAXPAVCvTacticalMove@@00@Z ; std::_Insertion_sort1<CvTacticalMove *,CvTacticalMove>
	add	esp, 12					; 0000000cH
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
$LN4@Stable_sor@5:
	push	ebx

; 3384 : 	else
; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3387 : 		_BidIt _Mid = _First;
; 3388 : 		std::advance(_Mid, _Count2);
; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	esi
	mov	esi, eax
	sar	esi, 1
	mov	ecx, ebp
	lea	ebx, DWORD PTR [edx+esi*8]
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalMove>::_Maxlen
	cmp	esi, eax

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	push	ebp
	push	esi
	push	ebx
	jg	SHORT $LN2@Stable_sor@5
	mov	eax, DWORD PTR __First$[esp+24]
	push	eax
	call	??$_Buffered_merge_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Buffered_merge_sort<CvTacticalMove *,int,CvTacticalMove>

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Buffered_merge_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Buffered_merge_sort<CvTacticalMove *,int,CvTacticalMove>

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN17@Stable_sor@5
$LN2@Stable_sor@5:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	edx, DWORD PTR __First$[esp+24]
	push	edx
	call	??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Stable_sort<CvTacticalMove *,int,CvTacticalMove>

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	eax
	push	ebx
	call	??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Stable_sort<CvTacticalMove *,int,CvTacticalMove>
$LN17@Stable_sor@5:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	ecx, DWORD PTR __Last$[esp+44]
	mov	edx, DWORD PTR __First$[esp+44]
	add	esp, 32					; 00000020H
	push	ebp
	push	edi
	push	esi
	push	ecx
	push	ebx
	push	edx
	call	??$_Buffered_merge@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@00HHAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Buffered_merge<CvTacticalMove *,int,CvTacticalMove>
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ENDP ; std::_Stable_sort<CvTacticalMove *,int,CvTacticalMove>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z PROC ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	edi

; 3382 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor@6

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvTacticalTarget@@V1@@std@@YAXPAVCvTacticalTarget@@00@Z ; std::_Insertion_sort1<CvTacticalTarget *,CvTacticalTarget>
	add	esp, 12					; 0000000cH
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
$LN4@Stable_sor@6:
	push	ebx

; 3384 : 	else
; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	sub	eax, edx
	push	ebp

; 3387 : 		_BidIt _Mid = _First;
; 3388 : 		std::advance(_Mid, _Count2);
; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR __First$[esp+12]
	sar	esi, 1
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi
	mov	ecx, ebp
	lea	ebx, DWORD PTR [eax+edx*4]
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalTarget>::_Maxlen
	cmp	esi, eax

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	push	ebp
	push	esi
	push	ebx
	jg	SHORT $LN2@Stable_sor@6
	mov	ecx, DWORD PTR __First$[esp+24]
	push	ecx
	call	??$_Buffered_merge_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Buffered_merge_sort<CvTacticalTarget *,int,CvTacticalTarget>

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	edx
	push	ebx
	call	??$_Buffered_merge_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Buffered_merge_sort<CvTacticalTarget *,int,CvTacticalTarget>

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN17@Stable_sor@6
$LN2@Stable_sor@6:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __First$[esp+24]
	push	eax
	call	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
$LN17@Stable_sor@6:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	edx, DWORD PTR __Last$[esp+44]
	mov	eax, DWORD PTR __First$[esp+44]
	add	esp, 32					; 00000020H
	push	ebp
	push	edi
	push	esi
	push	edx
	push	ebx
	push	eax
	call	??$_Buffered_merge@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@00HHAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Buffered_merge<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ENDP ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z PROC ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebx

; 3530 : 	if (_Count <= _ISORT_MAX)

	mov	ebx, DWORD PTR __Count$[esp]
	cmp	ebx, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor@7

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@PAVCvBlockingUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit),CvBlockingUnit>
	add	esp, 16					; 00000010H
	pop	ebx

; 3552 : 		}
; 3553 : 	}

	ret	0
$LN4@Stable_sor@7:

; 3532 : 	else
; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [ebx+1]
	push	ebp

; 3535 : 		_BidIt _Mid = _First;
; 3536 : 		std::advance(_Mid, _Count2);
; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+4]
	cdq
	push	esi
	sub	eax, edx
	mov	esi, eax
	push	edi
	sar	esi, 1
	mov	edi, esi
	shl	edi, 4
	add	edi, DWORD PTR __First$[esp+12]
	mov	ecx, ebp
	call	?_Maxlen@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvBlockingUnit>::_Maxlen
	cmp	esi, eax
	jg	SHORT $LN2@Stable_sor@7

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+12]
	mov	ecx, DWORD PTR __First$[esp+12]
	push	eax
	push	ebp
	push	esi
	push	edi
	push	ecx
	call	??$_Buffered_merge_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+32]
	mov	eax, DWORD PTR __Last$[esp+32]
	push	edx
	push	ebp
	sub	ebx, esi
	push	ebx
	push	eax
	push	edi
	call	??$_Buffered_merge_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN17@Stable_sor@7
$LN2@Stable_sor@7:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+12]
	mov	edx, DWORD PTR __First$[esp+12]
	push	ecx
	push	ebp
	push	esi
	push	edi
	push	edx
	call	??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	mov	ecx, DWORD PTR __Last$[esp+32]
	push	eax
	push	ebp
	sub	ebx, esi
	push	ebx
	push	ecx
	push	edi
	call	??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
$LN17@Stable_sor@7:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	mov	edx, DWORD PTR __Pred$[esp+52]
	mov	eax, DWORD PTR __Last$[esp+52]
	mov	ecx, DWORD PTR __First$[esp+52]
	add	esp, 40					; 00000028H
	push	edx
	push	ebp
	push	ebx
	push	esi
	push	eax
	push	edi
	push	ecx
	call	??$_Buffered_merge@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3552 : 		}
; 3553 : 	}

	ret	0
??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ENDP ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z PROC ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	ebx

; 3382 : 	if (_Count <= _ISORT_MAX)

	mov	ebx, DWORD PTR __Count$[esp]
	cmp	ebx, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor@8

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvBlockingUnit@@V1@@std@@YAXPAVCvBlockingUnit@@00@Z ; std::_Insertion_sort1<CvBlockingUnit *,CvBlockingUnit>
	add	esp, 12					; 0000000cH
	pop	ebx

; 3403 : 		}
; 3404 : 	}

	ret	0
$LN4@Stable_sor@8:

; 3384 : 	else
; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [ebx+1]
	push	ebp

; 3387 : 		_BidIt _Mid = _First;
; 3388 : 		std::advance(_Mid, _Count2);
; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+4]
	cdq
	push	esi
	sub	eax, edx
	mov	esi, eax
	push	edi
	sar	esi, 1
	mov	edi, esi
	shl	edi, 4
	add	edi, DWORD PTR __First$[esp+12]
	mov	ecx, ebp
	call	?_Maxlen@?$_Temp_iterator@VCvBlockingUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvBlockingUnit>::_Maxlen
	cmp	esi, eax

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	push	ebp
	push	esi
	push	edi
	jg	SHORT $LN2@Stable_sor@8
	mov	edx, DWORD PTR __First$[esp+24]
	push	edx
	call	??$_Buffered_merge_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Buffered_merge_sort<CvBlockingUnit *,int,CvBlockingUnit>

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	ebx, esi
	push	ebx
	push	eax
	push	edi
	call	??$_Buffered_merge_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Buffered_merge_sort<CvBlockingUnit *,int,CvBlockingUnit>

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN17@Stable_sor@8
$LN2@Stable_sor@8:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __First$[esp+24]
	push	ecx
	call	??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit>

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	ebx, esi
	push	ebx
	push	edx
	push	edi
	call	??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit>
$LN17@Stable_sor@8:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	eax, DWORD PTR __Last$[esp+44]
	mov	ecx, DWORD PTR __First$[esp+44]
	add	esp, 32					; 00000020H
	push	ebp
	push	ebx
	push	esi
	push	eax
	push	edi
	push	ecx
	call	??$_Buffered_merge@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@00HHAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Buffered_merge<CvBlockingUnit *,int,CvBlockingUnit>
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3403 : 		}
; 3404 : 	}

	ret	0
??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ENDP ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit>
_TEXT	ENDS
PUBLIC	?PlotRepositionMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotRepositionMoves
EXTRN	?IsGreatAdmiral@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsGreatAdmiral
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?PlotRepositionMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotRepositionMoves@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?PlotRepositionMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotRepositionMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotRepositionMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T282260 = -44						; size = 1
__Cat$282264 = -44					; size = 1
$T282262 = -44						; size = 1
_pUnit$221471 = -44					; size = 8
_unit$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
?PlotRepositionMoves@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::PlotRepositionMoves, COMDAT
; _this$ = ecx

; 2402 : {

	push	-1
	push	__ehhandler$?PlotRepositionMoves@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2403 : 	list<int>::iterator it;
; 2404 : 	CvTacticalUnit unit;
; 2405 : 
; 2406 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+24]
	xor	ebx, ebx
	lea	ebp, DWORD PTR [esi+20]
	push	edi
	mov	DWORD PTR _this$[esp+64], esi
	mov	DWORD PTR _unit$[esp+64], ebx
	mov	DWORD PTR _unit$[esp+68], ebx
	mov	DWORD PTR _unit$[esp+72], ebx
	mov	DWORD PTR _unit$[esp+76], ebx
	mov	DWORD PTR _unit$[esp+80], ebx
	mov	DWORD PTR _unit$[esp+84], ebx
	cmp	ecx, eax
	je	SHORT $LN31@PlotReposi
	mov	BYTE PTR $T282260[esp+64], bl
	mov	edx, DWORD PTR $T282260[esp+64]
	push	edx
	mov	edx, DWORD PTR __Cat$282264[esp+68]
	push	edx
	mov	edx, DWORD PTR $T282262[esp+72]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebp+8], eax
$LN31@PlotReposi:

; 2407 : 
; 2408 : 	// Loop through all recruited units
; 2409 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 2410 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 2411 : #else
; 2412 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [eax]
	cmp	edi, eax
	je	SHORT $LN5@PlotReposi
$LL68@PlotReposi:

; 2413 : #endif
; 2414 : 	{
; 2415 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$221471[esp+64], esi
	mov	BYTE PTR _pUnit$221471[esp+68], bl
	cmp	esi, ebx
	je	SHORT $LN91@PlotReposi
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN91@PlotReposi:
	mov	DWORD PTR __$EHRec$[esp+72], ebx

; 2416 : 		if(pUnit)

	cmp	esi, ebx
	je	SHORT $LN4@PlotReposi

; 2417 : 		{
; 2418 : 			// Never use this (default) move for Great Admirals or Generals
; 2419 : 			if (pUnit->IsGreatGeneral() || pUnit->IsGreatAdmiral())

	mov	ecx, esi
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	test	al, al
	jne	SHORT $LN2@PlotReposi
	mov	ecx, esi
	call	?IsGreatAdmiral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatAdmiral
	test	al, al
	jne	SHORT $LN2@PlotReposi

; 2422 : 			}
; 2423 : 
; 2424 : 			unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]

; 2425 : 			m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$[esp+64]
	mov	DWORD PTR _unit$[esp+64], ecx
	push	edx
	mov	ecx, ebp
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back
$LN4@PlotReposi:

; 2426 : 		}
; 2427 : 	}

	mov	DWORD PTR __$EHRec$[esp+72], -1
	cmp	esi, ebx
	je	SHORT $LN6@PlotReposi
$LN123@PlotReposi:
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@PlotReposi:
	mov	eax, DWORD PTR _this$[esp+64]
	mov	edi, DWORD PTR [edi]
	mov	esi, eax
	cmp	edi, DWORD PTR [eax+12]
	jne	SHORT $LL68@PlotReposi
$LN5@PlotReposi:

; 2428 : 
; 2429 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [ebp+8]
	sub	ecx, DWORD PTR [ebp+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	je	SHORT $LN1@PlotReposi

; 2430 : 	{
; 2431 : 		ExecuteRepositionMoves();

	mov	ecx, esi
	call	?ExecuteRepositionMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::ExecuteRepositionMoves
$LN1@PlotReposi:

; 2432 : 	}
; 2433 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	0
$LN2@PlotReposi:

; 2420 : 			{
; 2421 : 				continue;

	mov	DWORD PTR __$EHRec$[esp+72], -1
	jmp	SHORT $LN123@PlotReposi
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotRepositionMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$221471[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotRepositionMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotRepositionMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotRepositionMoves@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::PlotRepositionMoves
PUBLIC	?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z	; CvTacticalAI::PlotBarbarianMove
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z$0
__ehfuncinfo$?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z
_TEXT	SEGMENT
$T282622 = -44						; size = 1
_pUnit$221493 = -44					; size = 8
_unit$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
_bAggressive$ = 8					; size = 1
__Cat$282626 = 8					; size = 1
$T282624 = 8						; size = 1
?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z PROC		; CvTacticalAI::PlotBarbarianMove, COMDAT
; _this$ = ecx

; 2437 : {

	push	-1
	push	__ehhandler$?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H

; 2438 : 	list<int>::iterator it;
; 2439 : 	CvTacticalUnit unit;

	xor	eax, eax
	push	ebx
	mov	ebx, ecx

; 2440 : 
; 2441 : 	if(m_pPlayer->isBarbarian())

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR _unit$[esp+48], eax
	mov	DWORD PTR _unit$[esp+52], eax
	mov	DWORD PTR _unit$[esp+56], eax
	mov	DWORD PTR _unit$[esp+60], eax
	mov	DWORD PTR _unit$[esp+64], eax
	mov	DWORD PTR _unit$[esp+68], eax
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	je	$LN1@PlotBarbar

; 2442 : 	{
; 2443 : 		m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [ebx+28]
	mov	ecx, DWORD PTR [ebx+24]
	push	ebp
	lea	ebp, DWORD PTR [ebx+20]
	push	edi
	cmp	ecx, eax
	je	SHORT $LN30@PlotBarbar
	mov	BYTE PTR $T282622[esp+56], 0
	mov	edx, DWORD PTR $T282622[esp+56]
	push	edx
	mov	edx, DWORD PTR __Cat$282626[esp+56]
	push	edx
	mov	edx, DWORD PTR $T282624[esp+60]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebp+8], eax
$LN30@PlotBarbar:

; 2444 : 
; 2445 : 		// Loop through all recruited units
; 2446 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 2447 : 		for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 2448 : #else
; 2449 : 		for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [ebx+12]
	mov	edi, DWORD PTR [eax]
	cmp	edi, eax
	je	SHORT $LN3@PlotBarbar
	push	esi
	npad	1
$LL67@PlotBarbar:

; 2450 : #endif
; 2451 : 		{
; 2452 : 			UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$221493[esp+60], esi
	mov	BYTE PTR _pUnit$221493[esp+64], 0
	test	esi, esi
	je	SHORT $LN90@PlotBarbar
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN90@PlotBarbar:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 2453 : 			if(pUnit)

	test	esi, esi
	je	SHORT $LN2@PlotBarbar

; 2454 : 			{
; 2455 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]

; 2456 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$[esp+60]
	mov	DWORD PTR _unit$[esp+60], ecx
	push	edx
	mov	ecx, ebp
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back
$LN2@PlotBarbar:

; 2457 : 			}
; 2458 : 		}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	esi, esi
	je	SHORT $LN4@PlotBarbar
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@PlotBarbar:
	mov	edi, DWORD PTR [edi]
	cmp	edi, DWORD PTR [ebx+12]
	jne	SHORT $LL67@PlotBarbar
	pop	esi
$LN3@PlotBarbar:

; 2459 : 
; 2460 : 		if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [ebp+8]
	sub	ecx, DWORD PTR [ebp+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	edi
	pop	ebp
	je	SHORT $LN1@PlotBarbar

; 2461 : 		{
; 2462 : 			ExecuteBarbarianMoves(bAggressive);

	mov	ecx, DWORD PTR _bAggressive$[esp+44]
	push	ecx
	mov	ecx, ebx
	call	?ExecuteBarbarianMoves@CvTacticalAI@@AAEX_N@Z ; CvTacticalAI::ExecuteBarbarianMoves
$LN1@PlotBarbar:

; 2463 : 		}
; 2464 : 	}
; 2465 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z$0:
	lea	ecx, DWORD PTR _pUnit$221493[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z ENDP		; CvTacticalAI::PlotBarbarianMove
PUBLIC	?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotBarbarianCivilianEscortMove
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
$T282960 = -44						; size = 1
__Cat$282965 = -44					; size = 1
$T282962 = -44						; size = 1
_pUnit$221512 = -44					; size = 8
_unit$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ PROC ; CvTacticalAI::PlotBarbarianCivilianEscortMove, COMDAT
; _this$ = ecx

; 2469 : {

	push	-1
	push	__ehhandler$?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H

; 2470 : 	list<int>::iterator it;
; 2471 : 	CvTacticalUnit unit;

	xor	eax, eax
	push	ebx
	mov	ebx, ecx

; 2472 : 
; 2473 : 	if(m_pPlayer->isBarbarian())

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR _unit$[esp+48], eax
	mov	DWORD PTR _unit$[esp+52], eax
	mov	DWORD PTR _unit$[esp+56], eax
	mov	DWORD PTR _unit$[esp+60], eax
	mov	DWORD PTR _unit$[esp+64], eax
	mov	DWORD PTR _unit$[esp+68], eax
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	je	$LN1@PlotBarbar@2

; 2474 : 	{
; 2475 : 		m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [ebx+28]
	mov	ecx, DWORD PTR [ebx+24]
	push	ebp
	lea	ebp, DWORD PTR [ebx+20]
	push	edi
	cmp	ecx, eax
	je	SHORT $LN30@PlotBarbar@2
	mov	BYTE PTR $T282960[esp+56], 0
	mov	edx, DWORD PTR $T282960[esp+56]
	push	edx
	mov	edx, DWORD PTR __Cat$282965[esp+60]
	push	edx
	mov	edx, DWORD PTR $T282962[esp+64]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebp+8], eax
$LN30@PlotBarbar@2:

; 2476 : 
; 2477 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 2478 : 		for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 2479 : #else
; 2480 : 		for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [ebx+12]
	mov	edi, DWORD PTR [eax]
	cmp	edi, eax
	je	SHORT $LN3@PlotBarbar@2
	push	esi
	npad	1
$LL67@PlotBarbar@2:

; 2481 : #endif
; 2482 : 		{
; 2483 : 			UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$221512[esp+60], esi
	mov	BYTE PTR _pUnit$221512[esp+64], 0
	test	esi, esi
	je	SHORT $LN90@PlotBarbar@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN90@PlotBarbar@2:

; 2484 : 
; 2485 : 			// Find any civilians we may have "acquired" from the civs
; 2486 : 			if(!pUnit->IsCanAttack())

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+68], 0
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	test	al, al
	jne	SHORT $LN2@PlotBarbar@2

; 2487 : 			{
; 2488 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]

; 2489 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$[esp+60]
	mov	DWORD PTR _unit$[esp+60], ecx
	push	edx
	mov	ecx, ebp
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back
$LN2@PlotBarbar@2:

; 2490 : 			}
; 2491 : 		}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	esi, esi
	je	SHORT $LN4@PlotBarbar@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@PlotBarbar@2:
	mov	edi, DWORD PTR [edi]
	cmp	edi, DWORD PTR [ebx+12]
	jne	SHORT $LL67@PlotBarbar@2
	pop	esi
$LN3@PlotBarbar@2:

; 2492 : 
; 2493 : 		if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [ebp+8]
	sub	ecx, DWORD PTR [ebp+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	edi
	pop	ebp
	je	SHORT $LN1@PlotBarbar@2

; 2494 : 		{
; 2495 : 			ExecuteBarbarianCivilianEscortMove();

	mov	ecx, ebx
	call	?ExecuteBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ ; CvTacticalAI::ExecuteBarbarianCivilianEscortMove
$LN1@PlotBarbar@2:

; 2496 : 		}
; 2497 : 	}
; 2498 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$221512[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ ENDP ; CvTacticalAI::PlotBarbarianCivilianEscortMove
PUBLIC	?PlotHealMoves@CvTacticalAI@@AAEXXZ		; CvTacticalAI::PlotHealMoves
EXTRN	?IsUnderEnemyRangedAttack@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsUnderEnemyRangedAttack
EXTRN	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsFriendlyTerritory
EXTRN	?GetCurrHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetCurrHitPoints
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?PlotHealMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotHealMoves@CvTacticalAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotHealMoves@CvTacticalAI@@AAEXXZ$1
__ehfuncinfo$?PlotHealMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?PlotHealMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotHealMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
$T283307 = -76						; size = 1
__Cat$283311 = -76					; size = 1
$T283309 = -76						; size = 1
_it$ = -76						; size = 4
_pUnit$221720 = -72					; size = 8
_unit$ = -64						; size = 24
_strLogString$221727 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotHealMoves@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::PlotHealMoves, COMDAT
; _this$ = ecx

; 2912 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?PlotHealMoves@CvTacticalAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	ebp
	push	edi
	mov	edi, ecx

; 2913 : 	list<int>::iterator it;
; 2914 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [edi+24]
	xor	ebx, ebx
	cmp	ecx, eax
	je	SHORT $LN33@PlotHealMo
	mov	BYTE PTR $T283307[esp+88], bl
	mov	edx, DWORD PTR $T283307[esp+88]
	push	edx
	mov	edx, DWORD PTR __Cat$283311[esp+92]
	push	edx
	mov	edx, DWORD PTR $T283309[esp+96]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+28], eax
$LN33@PlotHealMo:

; 2915 : 	CvTacticalUnit unit;
; 2916 : 
; 2917 : 	// Loop through all recruited units
; 2918 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 2919 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 2920 : #else
; 2921 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [edi+12]
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _unit$[esp+88], ebx
	mov	DWORD PTR _unit$[esp+92], ebx
	mov	DWORD PTR _unit$[esp+96], ebx
	mov	DWORD PTR _unit$[esp+100], ebx
	mov	DWORD PTR _unit$[esp+104], ebx
	mov	DWORD PTR _unit$[esp+108], ebx
	mov	DWORD PTR _it$[esp+88], ebp
	cmp	ebp, eax
	je	$LN8@PlotHealMo
	push	esi
$LL72@PlotHealMo:

; 2922 : #endif
; 2923 : 	{
; 2924 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$221720[esp+92], esi
	mov	BYTE PTR _pUnit$221720[esp+96], bl
	cmp	esi, ebx
	je	SHORT $LN95@PlotHealMo
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN95@PlotHealMo:
	mov	DWORD PTR __$EHRec$[esp+100], ebx

; 2925 : 		if(pUnit)

	cmp	esi, ebx
	je	$LN2@PlotHealMo

; 2926 : 		{
; 2927 : 			// Am I under 100% health and not embarked or already in a city?
; 2928 : 			if(pUnit->GetCurrHitPoints() < pUnit->GetMaxHitPoints() && !pUnit->isEmbarked() && !pUnit->plot()->isCity())

	mov	ecx, esi
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	mov	ecx, esi
	mov	ebp, eax
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	cmp	ebp, eax
	jge	$LN162@PlotHealMo
	cmp	BYTE PTR [esi+1652], bl
	jne	$LN162@PlotHealMo
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR [eax+104]
	cmp	ecx, ebx
	jl	SHORT $LN161@PlotHealMo
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN161@PlotHealMo
	mov	edx, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	cmp	al, bl
	jne	$LN162@PlotHealMo
$LN161@PlotHealMo:

; 2929 : 			{
; 2930 : 				// If I'm a naval unit I need to be in friendly territory
; 2931 : 				if(pUnit->getDomainType() != DOMAIN_SEA || pUnit->plot()->IsFriendlyTerritory(m_pPlayer->GetID()))

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN4@PlotHealMo
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	test	al, al
	je	$LN162@PlotHealMo
$LN4@PlotHealMo:

; 2932 : 				{
; 2933 : 					if (!pUnit->IsUnderEnemyRangedAttack())

	mov	ecx, esi
	call	?IsUnderEnemyRangedAttack@CvUnit@@QBE_NXZ ; CvUnit::IsUnderEnemyRangedAttack
	test	al, al
	jne	SHORT $LN162@PlotHealMo

; 2934 : 					{
; 2935 : 						unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]

; 2936 : 						m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$[esp+92]
	mov	DWORD PTR _unit$[esp+92], ecx
	push	edx
	lea	ecx, DWORD PTR [edi+20]
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back

; 2937 : 
; 2938 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN162@PlotHealMo
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN162@PlotHealMo

; 2939 : 						{
; 2940 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221727[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2941 : 							strLogString.Format("Healing at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	eax, DWORD PTR _strLogString$221727[esp+100]
	push	OFFSET $SG221728
	push	eax
	mov	BYTE PTR __$EHRec$[esp+116], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2942 : 							LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$221727[esp+96]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2943 : 						}

	lea	ecx, DWORD PTR _strLogString$221727[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN162@PlotHealMo:
	mov	ebp, DWORD PTR _it$[esp+92]
$LN2@PlotHealMo:

; 2944 : 					}
; 2945 : 				}
; 2946 : 			}
; 2947 : 		}
; 2948 : 	}

	mov	DWORD PTR __$EHRec$[esp+100], -1
	cmp	esi, ebx
	je	SHORT $LN9@PlotHealMo
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@PlotHealMo:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$[esp+92], ebp
	cmp	ebp, DWORD PTR [edi+12]
	jne	$LL72@PlotHealMo
	pop	esi
$LN8@PlotHealMo:

; 2949 : 
; 2950 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	SHORT $LN1@PlotHealMo

; 2951 : 	{
; 2952 : 		ExecuteHeals();

	mov	ecx, edi
	call	?ExecuteHeals@CvTacticalAI@@AAEXXZ	; CvTacticalAI::ExecuteHeals
$LN1@PlotHealMo:

; 2953 : 	}
; 2954 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotHealMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$221720[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotHealMoves@CvTacticalAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$221727[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotHealMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotHealMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotHealMoves@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::PlotHealMoves
PUBLIC	?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotAirInterceptMoves
EXTRN	?GetNumEnemyAirUnitsInRange@CvMilitaryAI@@QBEHPAVCvPlot@@H_N1@Z:PROC ; CvMilitaryAI::GetNumEnemyAirUnitsInRange
EXTRN	?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z:PROC ; CvTacticalAnalysisMap::GetZoneByCity
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ$1
__ehfuncinfo$?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_it$ = -80						; size = 4
$T283704 = -76						; size = 1
__Cat$283708 = -76					; size = 1
$T283706 = -76						; size = 1
_pZone$ = -76						; size = 4
_pUnit$221819 = -72					; size = 8
_unit$ = -64						; size = 24
_strLogString$221830 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotAirInterceptMoves, COMDAT
; _this$ = ecx

; 3092 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	ebp
	mov	ebp, ecx

; 3093 : 	list<int>::iterator it;
; 3094 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR [ebp+24]
	cmp	ecx, eax
	je	SHORT $LN34@PlotAirInt
	mov	BYTE PTR $T283704[esp+84], 0
	mov	edx, DWORD PTR $T283704[esp+84]
	push	edx
	mov	edx, DWORD PTR __Cat$283708[esp+88]
	push	edx
	mov	edx, DWORD PTR $T283706[esp+92]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebp+28], eax
$LN34@PlotAirInt:

; 3095 : 	CvTacticalUnit unit;
; 3096 : 	CvTacticalDominanceZone *pZone;
; 3097 : 
; 3098 : 	// Loop through all recruited units
; 3099 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 3100 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 3101 : #else
; 3102 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [eax]
	push	edi
	xor	edi, edi
	mov	DWORD PTR _unit$[esp+88], edi
	mov	DWORD PTR _unit$[esp+92], edi
	mov	DWORD PTR _unit$[esp+96], edi
	mov	DWORD PTR _unit$[esp+100], edi
	mov	DWORD PTR _unit$[esp+104], edi
	mov	DWORD PTR _unit$[esp+108], edi
	mov	DWORD PTR _it$[esp+88], ecx
	cmp	ecx, eax
	je	$LN9@PlotAirInt
	push	ebx
	push	esi
$LL148@PlotAirInt:

; 3103 : #endif
; 3104 : 	{
; 3105 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR _it$[esp+96]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$221819[esp+96], esi
	mov	BYTE PTR _pUnit$221819[esp+100], 0
	cmp	esi, edi
	je	SHORT $LN96@PlotAirInt
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN96@PlotAirInt:
	mov	DWORD PTR __$EHRec$[esp+104], edi

; 3106 : 		if(pUnit)

	cmp	esi, edi
	je	$LN2@PlotAirInt

; 3107 : 		{
; 3108 : 			// Am I eligible to intercept?
; 3109 : 			if(pUnit->canAirPatrol(NULL) && !m_pPlayer->GetMilitaryAI()->WillAirUnitRebase(pUnit.pointer()))

	push	edi
	mov	ecx, esi
	call	?canAirPatrol@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canAirPatrol
	test	al, al
	je	$LN2@PlotAirInt
	mov	ecx, DWORD PTR [ebp]
	push	esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?WillAirUnitRebase@CvMilitaryAI@@QBE_NPAVCvUnit@@@Z ; CvMilitaryAI::WillAirUnitRebase
	test	al, al
	jne	$LN2@PlotAirInt

; 3110 : 			{
; 3111 : 				CvPlot* pUnitPlot = pUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebx, eax

; 3112 : 				CvCity* pCity = pUnitPlot->getPlotCity();

	mov	eax, DWORD PTR [ebx+104]
	cmp	eax, edi
	jl	SHORT $LN106@PlotAirInt
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN106@PlotAirInt
	mov	edx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax
$LN106@PlotAirInt:

; 3113 : 				pZone = NULL;

	mov	DWORD PTR _pZone$[esp+96], 0

; 3114 : 
; 3115 : 				if (pCity)

	test	edi, edi
	je	SHORT $LN6@PlotAirInt

; 3116 : 				{
; 3117 : 					pZone = m_pMap->GetZoneByCity(pCity, false);

	mov	ecx, DWORD PTR [ebp+4]
	push	0
	push	edi
	call	?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z ; CvTacticalAnalysisMap::GetZoneByCity
	mov	DWORD PTR _pZone$[esp+96], eax
$LN6@PlotAirInt:

; 3118 : 				}
; 3119 : 				int iNumNearbyBombers = m_pPlayer->GetMilitaryAI()->GetNumEnemyAirUnitsInRange(pUnitPlot, m_iRecruitRange, false/*bCountFighters*/, true/*bCountBombers*/);

	mov	eax, DWORD PTR [ebp+24756]
	mov	ecx, DWORD PTR [ebp]
	push	1
	push	0
	push	eax
	push	ebx
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetNumEnemyAirUnitsInRange@CvMilitaryAI@@QBEHPAVCvPlot@@H_N1@Z ; CvMilitaryAI::GetNumEnemyAirUnitsInRange

; 3120 : 
; 3121 : 				// On a carrier or in a city where we are not dominant and near some enemy bombers?
; 3122 : 				if (!pCity || !pZone || pZone->GetDominanceFlag() != TACTICAL_DOMINANCE_FRIENDLY)

	test	edi, edi
	je	SHORT $LN149@PlotAirInt
	mov	ecx, DWORD PTR _pZone$[esp+96]
	test	ecx, ecx
	je	SHORT $LN149@PlotAirInt
	cmp	DWORD PTR [ecx+8], 1
	je	SHORT $LN151@PlotAirInt
$LN149@PlotAirInt:

; 3123 : 				{
; 3124 : 					if (iNumNearbyBombers > 0)

	test	eax, eax
	jle	SHORT $LN151@PlotAirInt

; 3125 : 					{
; 3126 : 						unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]

; 3127 : 						m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$[esp+96]
	mov	DWORD PTR _unit$[esp+96], ecx
	push	edx
	lea	ecx, DWORD PTR [ebp+20]
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back

; 3128 : 
; 3129 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN151@PlotAirInt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN151@PlotAirInt

; 3130 : 						{
; 3131 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221830[esp+96]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3132 : 							strLogString.Format("Ready to intercept enemy air units at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	eax, DWORD PTR _strLogString$221830[esp+104]
	push	OFFSET $SG221831
	push	eax
	mov	BYTE PTR __$EHRec$[esp+120], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3133 : 							LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$221830[esp+100]
	push	ecx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 3134 : 						}

	lea	ecx, DWORD PTR _strLogString$221830[esp+96]
	mov	BYTE PTR __$EHRec$[esp+104], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN151@PlotAirInt:
	xor	edi, edi
$LN2@PlotAirInt:

; 3135 : 					}
; 3136 : 				}
; 3137 : 			}
; 3138 : 		}
; 3139 : 	}

	mov	DWORD PTR __$EHRec$[esp+104], -1
	cmp	esi, edi
	je	SHORT $LN10@PlotAirInt
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN10@PlotAirInt:
	mov	edx, DWORD PTR _it$[esp+96]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$[esp+96], eax
	cmp	eax, DWORD PTR [ebp+12]
	jne	$LL148@PlotAirInt
	pop	esi
	pop	ebx
$LN9@PlotAirInt:

; 3140 : 
; 3141 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	edi
	je	SHORT $LN1@PlotAirInt

; 3142 : 	{
; 3143 : 		ExecuteAirInterceptMoves();

	mov	ecx, ebp
	call	?ExecuteAirInterceptMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::ExecuteAirInterceptMoves
$LN1@PlotAirInt:

; 3144 : 	}
; 3145 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$221819[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$221830[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotAirInterceptMoves
PUBLIC	?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ		; CvTacticalAI::PlotAirSweepMoves
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ$1
__ehfuncinfo$?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
$T284143 = -76						; size = 1
__Cat$284147 = -76					; size = 1
$T284145 = -76						; size = 1
_it$ = -76						; size = 4
_pUnit$221849 = -72					; size = 8
_unit$ = -64						; size = 24
_strLogString$221858 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::PlotAirSweepMoves, COMDAT
; _this$ = ecx

; 3149 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	edi
	mov	edi, ecx

; 3150 : 	list<int>::iterator it;
; 3151 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [edi+24]
	xor	ebx, ebx
	cmp	ecx, eax
	je	SHORT $LN33@PlotAirSwe
	mov	BYTE PTR $T284143[esp+84], bl
	mov	edx, DWORD PTR $T284143[esp+84]
	push	edx
	mov	edx, DWORD PTR __Cat$284147[esp+88]
	push	edx
	mov	edx, DWORD PTR $T284145[esp+92]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+28], eax
$LN33@PlotAirSwe:

; 3152 : 	CvTacticalUnit unit;
; 3153 : 	CvTacticalDominanceZone *pZone;
; 3154 : 
; 3155 : 	// Loop through all recruited units
; 3156 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 3157 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 3158 : #else
; 3159 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _unit$[esp+84], ebx
	mov	DWORD PTR _unit$[esp+88], ebx
	mov	DWORD PTR _unit$[esp+92], ebx
	mov	DWORD PTR _unit$[esp+96], ebx
	mov	DWORD PTR _unit$[esp+100], ebx
	mov	DWORD PTR _unit$[esp+104], ebx
	mov	DWORD PTR _it$[esp+84], ecx
	cmp	ecx, eax
	je	$LN8@PlotAirSwe
	push	ebp
	push	esi
$LL153@PlotAirSwe:

; 3160 : #endif
; 3161 : 	{
; 3162 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR _it$[esp+92]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$221849[esp+92], esi
	mov	BYTE PTR _pUnit$221849[esp+96], bl
	cmp	esi, ebx
	je	SHORT $LN95@PlotAirSwe
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN95@PlotAirSwe:
	mov	DWORD PTR __$EHRec$[esp+100], ebx

; 3163 : 		if(pUnit && (pUnit->getDamage() * 2) < GC.getMAX_HIT_POINTS())

	cmp	esi, ebx
	je	$LN155@PlotAirSwe
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, eax
	cmp	eax, ebp
	jge	$LN155@PlotAirSwe

; 3164 : 		{
; 3165 : 			// Am I eligible to air sweep and have a target?
; 3166 : 			if(pUnit->canAirSweep() && !m_pPlayer->GetMilitaryAI()->WillAirUnitRebase(pUnit.pointer()) && m_pPlayer->GetMilitaryAI()->GetBestAirSweepTarget(pUnit.pointer()) != NULL)

	mov	ecx, esi
	call	?canAirSweep@CvUnit@@QBE_NXZ		; CvUnit::canAirSweep
	test	al, al
	je	$LN155@PlotAirSwe
	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?WillAirUnitRebase@CvMilitaryAI@@QBE_NPAVCvUnit@@@Z ; CvMilitaryAI::WillAirUnitRebase
	test	al, al
	jne	$LN155@PlotAirSwe
	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z ; CvMilitaryAI::GetBestAirSweepTarget
	test	eax, eax
	je	$LN155@PlotAirSwe

; 3167 : 			{
; 3168 : 				CvPlot* pUnitPlot = pUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 3169 : 				CvCity* pCity = pUnitPlot->getPlotCity();

	mov	ecx, DWORD PTR [eax+104]
	cmp	ecx, ebx
	jl	SHORT $LN154@PlotAirSwe
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN154@PlotAirSwe
	mov	edx, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 3170 : 				pZone = NULL;
; 3171 : 
; 3172 : 				// On a carrier or in a city where we are dominant?
; 3173 : 				if (pCity)

	cmp	eax, ebx
	je	SHORT $LN154@PlotAirSwe

; 3174 : 				{
; 3175 : 					pZone = m_pMap->GetZoneByCity(pCity, false);

	mov	ecx, DWORD PTR [edi+4]
	push	ebx
	push	eax
	call	?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z ; CvTacticalAnalysisMap::GetZoneByCity

; 3176 : 				}
; 3177 : 				if (!pCity || !pZone || pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_FRIENDLY)

	cmp	eax, ebx
	je	SHORT $LN154@PlotAirSwe
	cmp	DWORD PTR [eax+8], 1
	jne	SHORT $LN155@PlotAirSwe
$LN154@PlotAirSwe:

; 3178 : 				{
; 3179 : 					unit.SetID(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]

; 3180 : 					m_CurrentMoveUnits.push_back(unit);

	lea	ecx, DWORD PTR _unit$[esp+92]
	push	ecx
	lea	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR _unit$[esp+96], eax
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back

; 3181 : 
; 3182 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN155@PlotAirSwe
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN155@PlotAirSwe

; 3183 : 					{
; 3184 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221858[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3185 : 						strLogString.Format("Ready to air sweep enemy air units at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$221858[esp+100]
	push	OFFSET $SG221859
	push	edx
	mov	BYTE PTR __$EHRec$[esp+116], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3186 : 						LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$221858[esp+96]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 3187 : 					}

	lea	ecx, DWORD PTR _strLogString$221858[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN155@PlotAirSwe:

; 3188 : 				}
; 3189 : 			}
; 3190 : 		}
; 3191 : 	}

	mov	DWORD PTR __$EHRec$[esp+100], -1
	cmp	esi, ebx
	je	SHORT $LN9@PlotAirSwe
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@PlotAirSwe:
	mov	ecx, DWORD PTR _it$[esp+92]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _it$[esp+92], eax
	cmp	eax, DWORD PTR [edi+12]
	jne	$LL153@PlotAirSwe
	pop	esi
	pop	ebp
$LN8@PlotAirSwe:

; 3192 : 
; 3193 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	SHORT $LN1@PlotAirSwe

; 3194 : 	{
; 3195 : 		ExecuteAirSweepMoves();

	mov	ecx, edi
	call	?ExecuteAirSweepMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::ExecuteAirSweepMoves
$LN1@PlotAirSwe:

; 3196 : 	}
; 3197 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$221849[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$221858[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::PlotAirSweepMoves
PUBLIC	?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotEscortEmbarkedMoves
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
$T284564 = -44						; size = 1
__Cat$284568 = -44					; size = 1
$T284566 = -44						; size = 1
_pUnit$221956 = -44					; size = 8
_unit$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotEscortEmbarkedMoves, COMDAT
; _this$ = ecx

; 3361 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	mov	ebp, ecx

; 3362 : 	list<int>::iterator it;
; 3363 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR [ebp+24]
	xor	ebx, ebx
	push	edi
	cmp	ecx, eax
	je	SHORT $LN28@PlotEscort
	mov	BYTE PTR $T284564[esp+56], bl
	mov	edx, DWORD PTR $T284564[esp+56]
	push	edx
	mov	edx, DWORD PTR __Cat$284568[esp+60]
	push	edx
	mov	edx, DWORD PTR $T284566[esp+64]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebp+28], eax
$LN28@PlotEscort:

; 3364 : 	CvTacticalUnit unit;
; 3365 : 
; 3366 : 	// Loop through all recruited units
; 3367 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 3368 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 3369 : #else
; 3370 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [ebp+12]
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR _unit$[esp+56], ebx
	mov	DWORD PTR _unit$[esp+60], ebx
	mov	DWORD PTR _unit$[esp+64], ebx
	mov	DWORD PTR _unit$[esp+68], ebx
	mov	DWORD PTR _unit$[esp+72], ebx
	mov	DWORD PTR _unit$[esp+76], ebx
	cmp	edi, eax
	je	SHORT $LN4@PlotEscort
	push	esi
	npad	4
$LL67@PlotEscort:

; 3371 : #endif
; 3372 : 	{
; 3373 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$221956[esp+60], esi
	mov	BYTE PTR _pUnit$221956[esp+64], bl
	cmp	esi, ebx
	je	SHORT $LN90@PlotEscort
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN90@PlotEscort:
	mov	DWORD PTR __$EHRec$[esp+68], ebx

; 3374 : 		if(pUnit)

	cmp	esi, ebx
	je	SHORT $LN2@PlotEscort

; 3375 : 		{
; 3376 : 			// Am I a naval combat unit?
; 3377 : 			if(pUnit->getDomainType() == DOMAIN_SEA && pUnit->IsCombatUnit())

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN2@PlotEscort
	cmp	DWORD PTR [esi+1044], ebx
	jle	SHORT $LN2@PlotEscort

; 3378 : 			{
; 3379 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]

; 3380 : 				m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$[esp+60]
	mov	DWORD PTR _unit$[esp+60], ecx
	push	edx
	lea	ecx, DWORD PTR [ebp+20]
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back
$LN2@PlotEscort:

; 3381 : 			}
; 3382 : 		}
; 3383 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	cmp	esi, ebx
	je	SHORT $LN5@PlotEscort
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotEscort:
	mov	edi, DWORD PTR [edi]
	cmp	edi, DWORD PTR [ebp+12]
	jne	SHORT $LL67@PlotEscort
	pop	esi
$LN4@PlotEscort:

; 3384 : 
; 3385 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	SHORT $LN1@PlotEscort

; 3386 : 	{
; 3387 : 		ExecuteEscortEmbarkedMoves();

	mov	ecx, ebp
	call	?ExecuteEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::ExecuteEscortEmbarkedMoves
$LN1@PlotEscort:

; 3388 : 	}
; 3389 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$221956[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotEscortEmbarkedMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z$0
__ehfuncinfo$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z
_TEXT	SEGMENT
$T284731 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_iTurns$ = 16						; size = 4
?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z PROC ; GetReachablePlot, COMDAT
; _aPlots$ = ebx

; 6559 : {

	push	-1
	push	__ehhandler$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebp
	mov	ebp, DWORD PTR _iTurns$[esp+16]
	push	esi
	push	edi

; 6560 : 	uint uiListSize;
; 6561 : 	if ((uiListSize = aPlots.size()) > 0)

	mov	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	test	esi, esi
	jbe	SHORT $LN42@GetReachab

; 6562 : 	{
; 6563 : 		aPlots.SortItems();

	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH
$LL3@GetReachab:

; 6565 : 		{
; 6566 : 			CvPlot* pPlot = aPlots.GetElement(i);

	mov	eax, DWORD PTR [ebx]
	mov	edi, DWORD PTR [eax+esi*8-8]

; 6567 : 			if(CanReachInXTurns(pUnit, pPlot, iTurns))

	mov	ecx, DWORD PTR _pUnit$[esp+24]
	push	0
	push	0
	dec	esi
	push	ebp
	push	edi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _pUnit$[esp+52]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T284731[esp+52], esp
	test	eax, eax
	je	SHORT $LN28@GetReachab
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN28@GetReachab:
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	test	al, al
	jne	SHORT $LN41@GetReachab

; 6564 : 		for (uint i = uiListSize; i--; )		// Go backward, the CvWeightedVector sorts highest to lowest and we want the least dangerous location

	test	esi, esi
	jne	SHORT $LL3@GetReachab
$LN42@GetReachab:

; 6570 : 			}
; 6571 : 		}
; 6572 : 	}
; 6573 : 	return NULL;

	mov	ecx, DWORD PTR _pUnit$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	ecx, ecx
	je	SHORT $LN38@GetReachab
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN38@GetReachab:
	xor	eax, eax

; 6574 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	add	esp, 16					; 00000010H
	ret	0
$LN41@GetReachab:

; 6568 : 			{
; 6569 : 				return pPlot;

	mov	ecx, DWORD PTR _pUnit$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	ecx, ecx
	je	SHORT $LN33@GetReachab
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN33@GetReachab:

; 6574 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebp
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z ENDP ; GetReachablePlot
PUBLIC	?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ	; CvTacticalAI::ExecuteMovesToSafestPlot
EXTRN	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::IsCanDefend
EXTRN	?AreUnitsOfSameType@CvUnit@@QBE_NABV1@_N@Z:PROC	; CvUnit::AreUnitsOfSameType
EXTRN	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z:PROC	; getUnit
EXTRN	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ:PROC	; CvPlot::headUnitNode
EXTRN	?GetMoves@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$9
	DD	05H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$10
	DD	04H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$11
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$12
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_bIsSeaUnit$223776 = -286				; size = 1
_bIsZeroDanger$223796 = -285				; size = 1
tv2550 = -284						; size = 4
_this$ = -280						; size = 4
$T284818 = -276						; size = 4
$T284817 = -276						; size = 4
$T284816 = -276						; size = 4
$T284815 = -276						; size = 4
_iUnitY$223774 = -276					; size = 4
_iX$223777 = -272					; size = 4
$T285883 = -268						; size = 4
_kMap$223772 = -264					; size = 4
_iRange$223771 = -260					; size = 4
tv2579 = -256						; size = 4
_aDangerList$ = -252					; size = 24
_aCoverList$ = -228					; size = 24
_aCityList$ = -204					; size = 24
_aZeroDangerList$ = -180				; size = 24
_iI$223764 = -156					; size = 4
tv170 = -152						; size = 4
$T285586 = -148						; size = 4
tv2577 = -144						; size = 4
_iUnitX$223773 = -140					; size = 4
tv1984 = -136						; size = 4
_pUnit$223768 = -132					; size = 8
_strTemp$223816 = -124					; size = 28
_strTemp$223821 = -96					; size = 28
_strLogString$223815 = -68				; size = 28
_strLogString$223820 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::ExecuteMovesToSafestPlot, COMDAT
; _this$ = ecx

; 6579 : {

	push	-1
	push	__ehhandler$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 6580 : 	int iDanger;
; 6581 : 
; 6582 : #if defined(PATH_PLAN_LAST)
; 6583 : 	// Maybe make these part of the class and just reuse?
; 6584 : 	WeightedPlotVector aCityList;

	xor	ebx, ebx
	lea	eax, DWORD PTR _aCityList$[esp+312]
	push	edi
	mov	DWORD PTR _this$[esp+304], ebp
	mov	DWORD PTR _aCityList$[esp+308], ebx
	mov	DWORD PTR _aCityList$[esp+304], eax

; 6585 : 	aCityList.reserve(10);

	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	push	4
	mov	edi, 10					; 0000000aH
	push	80					; 00000050H
	mov	DWORD PTR __$EHRec$[esp+328], ebx
	mov	DWORD PTR _aCityList$[esp+328], edi
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ecx, DWORD PTR _aCityList$[esp+324]
	mov	esi, eax
	mov	eax, DWORD PTR _aCityList$[esp+320]
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	push	eax
	push	esi
	mov	DWORD PTR _aCityList$[esp+340], edi
	call	_memcpy
	mov	eax, DWORD PTR _aCityList$[esp+332]
	lea	ecx, DWORD PTR _aCityList$[esp+344]
	add	esp, 28					; 0000001cH
	cmp	eax, ecx
	je	SHORT $LN83@ExecuteMov@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN83@ExecuteMov@5:

; 6586 : 	WeightedPlotVector aZeroDangerList;

	lea	edx, DWORD PTR _aZeroDangerList$[esp+316]
	mov	DWORD PTR _aCityList$[esp+304], esi
	mov	BYTE PTR _aCityList$[esp+324], 1
	mov	DWORD PTR _aZeroDangerList$[esp+308], ebx
	mov	DWORD PTR _aZeroDangerList$[esp+304], edx

; 6587 : 	aZeroDangerList.reserve(100);

	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	push	4
	mov	edi, 100				; 00000064H
	push	800					; 00000320H
	mov	BYTE PTR __$EHRec$[esp+328], 1
	mov	DWORD PTR _aZeroDangerList$[esp+328], edi
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	edx, DWORD PTR _aZeroDangerList$[esp+320]
	mov	esi, eax
	mov	eax, DWORD PTR _aZeroDangerList$[esp+324]
	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	push	edx
	push	esi
	mov	DWORD PTR _aZeroDangerList$[esp+340], edi
	call	_memcpy
	mov	eax, DWORD PTR _aZeroDangerList$[esp+332]
	lea	ecx, DWORD PTR _aZeroDangerList$[esp+344]
	add	esp, 28					; 0000001cH
	cmp	eax, ecx
	je	SHORT $LN127@ExecuteMov@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN127@ExecuteMov@5:

; 6588 : 	WeightedPlotVector aCoverList;

	lea	edx, DWORD PTR _aCoverList$[esp+316]
	mov	DWORD PTR _aZeroDangerList$[esp+304], esi
	mov	BYTE PTR _aZeroDangerList$[esp+324], 1
	mov	DWORD PTR _aCoverList$[esp+308], ebx
	mov	DWORD PTR _aCoverList$[esp+304], edx

; 6589 : 	aCoverList.reserve(100);

	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	push	4
	push	800					; 00000320H
	mov	BYTE PTR __$EHRec$[esp+328], 2
	mov	DWORD PTR _aCoverList$[esp+328], edi
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	edx, DWORD PTR _aCoverList$[esp+320]
	mov	esi, eax
	mov	eax, DWORD PTR _aCoverList$[esp+324]
	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	push	edx
	push	esi
	mov	DWORD PTR _aCoverList$[esp+340], edi
	call	_memcpy
	mov	eax, DWORD PTR _aCoverList$[esp+332]
	lea	ecx, DWORD PTR _aCoverList$[esp+344]
	add	esp, 28					; 0000001cH
	cmp	eax, ecx
	je	SHORT $LN171@ExecuteMov@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN171@ExecuteMov@5:

; 6590 : 	WeightedPlotVector aDangerList;

	lea	edx, DWORD PTR _aDangerList$[esp+316]
	mov	DWORD PTR _aCoverList$[esp+304], esi
	mov	BYTE PTR _aCoverList$[esp+324], 1
	mov	DWORD PTR _aDangerList$[esp+308], ebx
	mov	DWORD PTR _aDangerList$[esp+304], edx

; 6591 : 	aDangerList.reserve(100);

	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	push	4
	push	800					; 00000320H
	mov	BYTE PTR __$EHRec$[esp+328], 3
	mov	DWORD PTR _aDangerList$[esp+328], edi
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	edx, DWORD PTR _aDangerList$[esp+320]
	mov	esi, eax
	mov	eax, DWORD PTR _aDangerList$[esp+324]
	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	push	edx
	push	esi
	mov	DWORD PTR _aDangerList$[esp+340], edi
	call	_memcpy
	mov	eax, DWORD PTR _aDangerList$[esp+332]
	lea	ecx, DWORD PTR _aDangerList$[esp+344]
	add	esp, 28					; 0000001cH
	cmp	eax, ecx
	je	SHORT $LN215@ExecuteMov@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN215@ExecuteMov@5:

; 6592 : #endif
; 6593 : 
; 6594 : 	TeamTypes ePlayerTeam = m_pPlayer->getTeam();

	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR _aDangerList$[esp+304], esi
	mov	BYTE PTR _aDangerList$[esp+324], 1
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR tv1984[esp+304], eax
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN229@ExecuteMov@5
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T285586[esp+304], eax
	jmp	SHORT $LN230@ExecuteMov@5
$LN229@ExecuteMov@5:
	mov	DWORD PTR $T285586[esp+304], -1
$LN230@ExecuteMov@5:

; 6596 : 
; 6597 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _iI$223764[esp+304], ebx
	je	$LN29@ExecuteMov@5

; 6595 : 	PlayerTypes ePlayerID = m_pPlayer->GetID();

	mov	DWORD PTR tv2579[esp+304], 0
	npad	1
$LL31@ExecuteMov@5:

; 6598 : 	{
; 6599 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	ecx, DWORD PTR _this$[esp+304]
	mov	eax, DWORD PTR [ecx+24]
	add	eax, DWORD PTR tv2579[esp+304]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebp, eax
	mov	DWORD PTR _pUnit$223768[esp+304], ebp
	mov	BYTE PTR _pUnit$223768[esp+308], 0
	test	ebp, ebp
	je	SHORT $LN247@ExecuteMov@5
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN247@ExecuteMov@5:
	mov	BYTE PTR __$EHRec$[esp+312], 4

; 6600 : 		if(pUnit)

	test	ebp, ebp
	je	$LN1@ExecuteMov@5

; 6601 : 		{
; 6602 : #if defined(PATH_PLAN_LAST)
; 6603 : 			aCityList.clear();

	xor	edi, edi

; 6604 : 			aZeroDangerList.clear();
; 6605 : 			aCoverList.clear();
; 6606 : 			aDangerList.clear();
; 6607 : #endif
; 6608 : 			CvPlot* pBestPlot = NULL;
; 6609 : 
; 6610 : 			int iRange = pUnit->getUnitInfo().GetMoves();

	mov	ecx, ebp
	mov	DWORD PTR _aCityList$[esp+308], edi
	mov	DWORD PTR _aZeroDangerList$[esp+308], edi
	mov	DWORD PTR _aCoverList$[esp+308], edi
	mov	DWORD PTR _aDangerList$[esp+308], edi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetMoves@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetMoves

; 6611 : #if !defined(PATH_PLAN_LAST)
; 6612 : 			int iLowestDanger = MAX_INT;
; 6613 : 			bool bResultHasZeroDangerMove = false;
; 6614 : 			bool bResultInTerritory = false;
; 6615 : 			bool bResultInCity = false;
; 6616 : 			bool bResultInCover = false;
; 6617 : #endif
; 6618 : 
; 6619 : 			CvMap& kMap = GC.getMap();
; 6620 : 			int iUnitX = pUnit->getX();
; 6621 : 			int iUnitY = pUnit->getY();

	mov	ecx, DWORD PTR [ebp+88]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, eax
	mov	eax, DWORD PTR [ebp+76]
	mov	DWORD PTR _iUnitY$223774[esp+304], ecx

; 6622 : 			DomainTypes eUnitDomain = pUnit->getDomainType();

	mov	ecx, ebp
	mov	DWORD PTR _iRange$223771[esp+304], esi
	mov	DWORD PTR _kMap$223772[esp+304], edx
	mov	DWORD PTR _iUnitX$223773[esp+304], eax
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 6623 : 			bool bIsSeaUnit = eUnitDomain == DOMAIN_SEA;

	cmp	eax, edi
	sete	BYTE PTR _bIsSeaUnit$223776[esp+304]

; 6624 : 
; 6625 : 			// For each plot within movement range of the fleeing unit
; 6626 : 			for(int iX = -iRange; iX <= iRange; iX++)

	mov	eax, esi
	neg	eax
	cmp	eax, esi
	mov	DWORD PTR tv2577[esp+304], eax
	mov	DWORD PTR _iX$223777[esp+304], eax
	jg	$LN25@ExecuteMov@5
	jmp	SHORT $LN27@ExecuteMov@5
	npad	4
$LL630@ExecuteMov@5:
	mov	eax, DWORD PTR tv2577[esp+304]
	mov	esi, DWORD PTR _iRange$223771[esp+304]
$LN27@ExecuteMov@5:

; 6627 : 			{
; 6628 : 				for(int iY = -iRange; iY <= iRange; iY++)

	cmp	eax, esi
	jg	$LN26@ExecuteMov@5
	mov	eax, DWORD PTR _iUnitX$223773[esp+304]
	mov	edx, DWORD PTR _iX$223777[esp+304]
	mov	ecx, DWORD PTR tv2577[esp+304]
	add	edx, eax
	mov	eax, DWORD PTR _iRange$223771[esp+304]
	mov	DWORD PTR $T285883[esp+304], edx
	mov	edx, DWORD PTR _iUnitY$223774[esp+304]
	sub	eax, ecx
	lea	ebx, DWORD PTR [ecx+edx]
	inc	eax
	mov	DWORD PTR tv2550[esp+304], ebx
	mov	DWORD PTR tv170[esp+304], eax
	npad	12
$LL24@ExecuteMov@5:

; 6629 : 				{
; 6630 : 					CvPlot* pPlot = kMap.plot(iUnitX + iX, iUnitY + iY);

	cmp	DWORD PTR $T285883[esp+304], -2147483647 ; 80000001H
	je	$LN23@ExecuteMov@5
	cmp	ebx, -2147483647			; 80000001H
	je	$LN23@ExecuteMov@5
	mov	ecx, DWORD PTR _kMap$223772[esp+304]
	mov	al, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	al, al
	mov	eax, DWORD PTR $T285883[esp+304]
	je	SHORT $LN319@ExecuteMov@5
	test	eax, eax
	jge	SHORT $LN321@ExecuteMov@5
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN323@ExecuteMov@5
$LN321@ExecuteMov@5:
	cmp	eax, ecx
	jl	SHORT $LN319@ExecuteMov@5
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN323@ExecuteMov@5
$LN319@ExecuteMov@5:
	mov	esi, eax
$LN323@ExecuteMov@5:
	mov	edx, DWORD PTR _kMap$223772[esp+304]
	mov	al, BYTE PTR [edx+4057]
	mov	edi, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN329@ExecuteMov@5
	test	ebx, ebx
	jge	SHORT $LN331@ExecuteMov@5
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN333@ExecuteMov@5
$LN331@ExecuteMov@5:
	cmp	ebx, edi
	jl	SHORT $LN329@ExecuteMov@5
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN333@ExecuteMov@5
$LN329@ExecuteMov@5:
	mov	edx, ebx
$LN333@ExecuteMov@5:
	test	esi, esi
	jl	$LN23@ExecuteMov@5
	cmp	esi, ecx
	jge	$LN23@ExecuteMov@5
	test	edx, edx
	jl	$LN23@ExecuteMov@5
	cmp	edx, edi
	jge	$LN23@ExecuteMov@5
	mov	eax, DWORD PTR _kMap$223772[esp+304]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	esi, ecx

; 6631 : 					if(pPlot == NULL)

	je	$LN23@ExecuteMov@5

; 6632 : 					{
; 6633 : 						continue;
; 6634 : 					}
; 6635 : 
; 6636 : 					// Can't be a plot with another player's unit in it or another of our unit of same type
; 6637 : 					if(pPlot->getNumUnits() > 0)

	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	SHORT $LN15@ExecuteMov@5

; 6638 : 					{
; 6639 : 						IDInfo* pUnitNode = pPlot->headUnitNode();

	mov	ecx, esi
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode

; 6640 : 						if(pUnitNode)

	test	eax, eax
	je	SHORT $LN15@ExecuteMov@5

; 6641 : 						{
; 6642 : 							CvUnit* pFirstUnit = ::getUnit(*pUnitNode);

	push	eax
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit
	add	esp, 4

; 6643 : 							if(pFirstUnit)

	test	eax, eax
	je	SHORT $LN15@ExecuteMov@5

; 6644 : 							{
; 6645 : 								if(pFirstUnit->getOwner() != pUnit->getOwner())

	mov	ecx, DWORD PTR [eax+40]
	cmp	ecx, DWORD PTR [ebp+40]
	jne	$LN23@ExecuteMov@5

; 6646 : 								{
; 6647 : 									continue;
; 6648 : 								}
; 6649 : 
; 6650 : 								else if(pUnit->AreUnitsOfSameType(*pFirstUnit))

	push	0
	push	eax
	mov	ecx, ebp
	call	?AreUnitsOfSameType@CvUnit@@QBE_NABV1@_N@Z ; CvUnit::AreUnitsOfSameType
	test	al, al
	jne	$LN23@ExecuteMov@5
$LN15@ExecuteMov@5:

; 6651 : 								{
; 6652 : 									continue;
; 6653 : 								}
; 6654 : 							}
; 6655 : 						}
; 6656 : 					}
; 6657 : 
; 6658 : 					// Also filter out sea units targeting land plots
; 6659 : 					if (bIsSeaUnit && !pPlot->isWater())

	cmp	BYTE PTR _bIsSeaUnit$223776[esp+304], 0
	je	SHORT $LN14@ExecuteMov@5
	cmp	BYTE PTR [esi+5], 3
	jne	$LN23@ExecuteMov@5
$LN14@ExecuteMov@5:

; 6660 : 					{
; 6661 : 						continue;
; 6662 : 					}
; 6663 : 
; 6664 : #if !defined(PATH_PLAN_LAST)
; 6665 : 					if(!CanReachInXTurns(pUnit, pPlot, 1))
; 6666 : 					{
; 6667 : 						continue;
; 6668 : 					}
; 6669 : #endif
; 6670 : 					//   prefer being in a city with the lowest danger value
; 6671 : 					//   prefer being in a plot with no danger value
; 6672 : 					//   prefer being under a unit with the lowest danger value
; 6673 : 					//   prefer being in your own territory with the lowest danger value
; 6674 : 					//   prefer the lowest danger value
; 6675 : 
; 6676 : 					iDanger = m_pPlayer->GetPlotDanger(*pPlot);

	mov	ecx, DWORD PTR _this$[esp+304]
	mov	ecx, DWORD PTR [ecx]
	push	esi
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	edi, eax

; 6677 : 					bool bIsZeroDanger = (iDanger <= 0);
; 6678 : 					bool bIsInCity = pPlot->isFriendlyCity(*pUnit, false);

	push	0
	test	edi, edi
	push	ebp
	mov	ecx, esi
	setle	BYTE PTR _bIsZeroDanger$223796[esp+312]
	call	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z ; CvPlot::isFriendlyCity

; 6679 : 					bool bIsInCover = (pPlot->getNumDefenders(ePlayerID) > 0) && !pUnit->IsCanDefend(pPlot); // only move to cover if I'm defenseless here

	mov	edx, DWORD PTR tv1984[esp+304]
	push	edx
	mov	ecx, esi
	mov	bl, al
	call	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	test	eax, eax
	jle	SHORT $LN34@ExecuteMov@5
	push	esi
	mov	ecx, ebp
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	jne	SHORT $LN34@ExecuteMov@5
	mov	cl, 1
	jmp	SHORT $LN35@ExecuteMov@5
$LN34@ExecuteMov@5:
	xor	cl, cl
$LN35@ExecuteMov@5:

; 6680 : 					bool bIsInTerritory = (pPlot->getTeam() == ePlayerTeam);

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN366@ExecuteMov@5
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN366@ExecuteMov@5
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN365@ExecuteMov@5
$LN366@ExecuteMov@5:
	or	eax, -1
$LN365@ExecuteMov@5:
	cmp	eax, DWORD PTR $T285586[esp+304]
	sete	al

; 6681 : 
; 6682 : #if defined(PATH_PLAN_LAST)
; 6683 : 					if(bIsInCity)

	test	bl, bl
	je	SHORT $LN13@ExecuteMov@5

; 6684 : 					{
; 6685 : 						aCityList.push_back(pPlot, iDanger);

	mov	eax, DWORD PTR _aCityList$[esp+312]
	mov	BYTE PTR _aCityList$[esp+324], 0
	cmp	DWORD PTR _aCityList$[esp+308], eax
	jne	SHORT $LN382@ExecuteMov@5
	push	eax
	lea	ecx, DWORD PTR _aCityList$[esp+308]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
$LN382@ExecuteMov@5:
	mov	eax, DWORD PTR _aCityList$[esp+304]
	mov	ecx, DWORD PTR _aCityList$[esp+308]
	lea	eax, DWORD PTR [eax+ecx*8]
	test	eax, eax
	je	SHORT $LN385@ExecuteMov@5
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
$LN385@ExecuteMov@5:
	inc	DWORD PTR _aCityList$[esp+308]

; 6686 : 					}
; 6687 : 					else

	jmp	$LN633@ExecuteMov@5
$LN13@ExecuteMov@5:

; 6688 : 					if(bIsZeroDanger)

	cmp	BYTE PTR _bIsZeroDanger$223796[esp+304], 0
	je	SHORT $LN11@ExecuteMov@5

; 6689 : 					{
; 6690 : 						aZeroDangerList.push_back(pPlot, (bIsInTerritory)?0:1);

	xor	edx, edx
	test	al, al
	mov	eax, DWORD PTR _aZeroDangerList$[esp+312]
	sete	dl
	mov	BYTE PTR _aZeroDangerList$[esp+324], 0
	mov	edi, edx
	cmp	DWORD PTR _aZeroDangerList$[esp+308], eax
	jne	SHORT $LN396@ExecuteMov@5
	push	eax
	lea	ecx, DWORD PTR _aZeroDangerList$[esp+308]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
$LN396@ExecuteMov@5:
	mov	eax, DWORD PTR _aZeroDangerList$[esp+304]
	mov	ecx, DWORD PTR _aZeroDangerList$[esp+308]
	lea	eax, DWORD PTR [eax+ecx*8]
	test	eax, eax
	je	SHORT $LN399@ExecuteMov@5
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
$LN399@ExecuteMov@5:
	inc	DWORD PTR _aZeroDangerList$[esp+308]

; 6691 : 					}
; 6692 : 					else

	jmp	SHORT $LN633@ExecuteMov@5
$LN11@ExecuteMov@5:

; 6693 : 					if(bIsInCover)

	test	cl, cl
	je	SHORT $LN9@ExecuteMov@5

; 6694 : 					{
; 6695 : 						aCoverList.push_back(pPlot, iDanger);

	mov	eax, DWORD PTR _aCoverList$[esp+312]
	mov	BYTE PTR _aCoverList$[esp+324], 0
	cmp	DWORD PTR _aCoverList$[esp+308], eax
	jne	SHORT $LN410@ExecuteMov@5
	push	eax
	lea	ecx, DWORD PTR _aCoverList$[esp+308]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
$LN410@ExecuteMov@5:
	mov	edx, DWORD PTR _aCoverList$[esp+304]
	mov	eax, DWORD PTR _aCoverList$[esp+308]
	lea	eax, DWORD PTR [edx+eax*8]
	test	eax, eax
	je	SHORT $LN413@ExecuteMov@5
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
$LN413@ExecuteMov@5:
	inc	DWORD PTR _aCoverList$[esp+308]

; 6696 : 					}
; 6697 : 					else

	jmp	SHORT $LN633@ExecuteMov@5
$LN9@ExecuteMov@5:

; 6698 : 					{
; 6699 : 						aDangerList.push_back(pPlot, iDanger);

	mov	eax, DWORD PTR _aDangerList$[esp+312]
	mov	BYTE PTR _aDangerList$[esp+324], 0
	cmp	DWORD PTR _aDangerList$[esp+308], eax
	jne	SHORT $LN424@ExecuteMov@5
	push	eax
	lea	ecx, DWORD PTR _aDangerList$[esp+308]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
$LN424@ExecuteMov@5:
	mov	ecx, DWORD PTR _aDangerList$[esp+304]
	mov	edx, DWORD PTR _aDangerList$[esp+308]
	lea	eax, DWORD PTR [ecx+edx*8]
	test	eax, eax
	je	SHORT $LN427@ExecuteMov@5
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
$LN427@ExecuteMov@5:
	inc	DWORD PTR _aDangerList$[esp+308]
$LN633@ExecuteMov@5:
	mov	ebx, DWORD PTR tv2550[esp+304]
$LN23@ExecuteMov@5:

; 6627 : 			{
; 6628 : 				for(int iY = -iRange; iY <= iRange; iY++)

	inc	ebx
	sub	DWORD PTR tv170[esp+304], 1
	mov	DWORD PTR tv2550[esp+304], ebx
	jne	$LL24@ExecuteMov@5
$LN26@ExecuteMov@5:

; 6624 : 
; 6625 : 			// For each plot within movement range of the fleeing unit
; 6626 : 			for(int iX = -iRange; iX <= iRange; iX++)

	mov	eax, DWORD PTR _iX$223777[esp+304]
	inc	eax
	cmp	eax, DWORD PTR _iRange$223771[esp+304]
	mov	DWORD PTR _iX$223777[esp+304], eax
	jle	$LL630@ExecuteMov@5
$LN25@ExecuteMov@5:

; 6700 : 					}
; 6701 : #endif
; 6702 : 
; 6703 : #if !defined(PATH_PLAN_LAST)
; 6704 : 					bool bUpdateBestValue = false;
; 6705 : 
; 6706 : 					if(bIsInCity)
; 6707 : 					{
; 6708 : 						if(!bResultInCity || iDanger < iLowestDanger)
; 6709 : 						{
; 6710 : 							bUpdateBestValue = true;
; 6711 : 						}
; 6712 : 					}
; 6713 : 					else if(bIsZeroDanger)
; 6714 : 					{
; 6715 : 						if(!bResultInCity)
; 6716 : 						{
; 6717 : 							if(bResultHasZeroDangerMove)
; 6718 : 							{
; 6719 : 								if(bIsInTerritory && !bResultInTerritory)
; 6720 : 								{
; 6721 : 									bUpdateBestValue = true;
; 6722 : 								}
; 6723 : 							}
; 6724 : 							else
; 6725 : 							{
; 6726 : 								bUpdateBestValue = true;
; 6727 : 							}
; 6728 : 						}
; 6729 : 					}
; 6730 : 					else if(bIsInCover)
; 6731 : 					{
; 6732 : 						if(!bResultInCity && !bResultHasZeroDangerMove)
; 6733 : 						{
; 6734 : 							if(!bResultInCover || iDanger < iLowestDanger)
; 6735 : 							{
; 6736 : 								bUpdateBestValue = true;
; 6737 : 							}
; 6738 : 						}
; 6739 : 					}
; 6740 : 					else if(bIsInTerritory)
; 6741 : 					{
; 6742 : 						if(!bResultInCity && !bResultInCover && !bResultHasZeroDangerMove)
; 6743 : 						{
; 6744 : 							if(!bResultInTerritory || iDanger < iLowestDanger)
; 6745 : 							{
; 6746 : 								bUpdateBestValue = true;
; 6747 : 							}
; 6748 : 						}
; 6749 : 					}
; 6750 : 					// if we have no good home, head to the lowest danger value
; 6751 : 					else if(!bResultInCity && !bResultInCover && !bResultInTerritory && !bResultHasZeroDangerMove)
; 6752 : 					{
; 6753 : 						if(iDanger < iLowestDanger)
; 6754 : 						{
; 6755 : 							bUpdateBestValue = true;
; 6756 : 						}
; 6757 : 					}
; 6758 : 
; 6759 : 					if(bUpdateBestValue)
; 6760 : 					{
; 6761 : 						pBestPlot = pPlot;
; 6762 : 						iLowestDanger = iDanger;
; 6763 : 
; 6764 : 						bResultInTerritory = bIsInTerritory;
; 6765 : 						bResultInCity      = bIsInCity;
; 6766 : 						bResultInCover     = bIsInCover;
; 6767 : 						bResultHasZeroDangerMove = bIsZeroDanger;
; 6768 : 					}
; 6769 : #endif
; 6770 : 				}
; 6771 : 			}
; 6772 : 
; 6773 : #if defined(PATH_PLAN_LAST)
; 6774 : 			// Now that we've gathered up our lists of destinations, go through them in order and pick the first one we can reach.
; 6775 : 			// This minimizes accessing the pathfinder.
; 6776 : 			if ((pBestPlot = GetReachablePlot(pUnit, aCityList, 1)) == NULL)

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, ebp
	lea	ebx, DWORD PTR _aCityList$[esp+316]
	mov	DWORD PTR $T284815[esp+316], esp
	mov	DWORD PTR [eax], ebp
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z ; GetReachablePlot
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	$LN625@ExecuteMov@5

; 6777 : 				if ((pBestPlot = GetReachablePlot(pUnit, aZeroDangerList, 1)) == NULL)

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, ebp
	lea	ebx, DWORD PTR _aZeroDangerList$[esp+316]
	mov	DWORD PTR $T284816[esp+316], esp
	mov	DWORD PTR [eax], ebp
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z ; GetReachablePlot
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LN625@ExecuteMov@5

; 6778 : 					if ((pBestPlot = GetReachablePlot(pUnit, aCoverList, 1)) == NULL)

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, ebp
	lea	ebx, DWORD PTR _aCoverList$[esp+316]
	mov	DWORD PTR $T284817[esp+316], esp
	mov	DWORD PTR [eax], ebp
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z ; GetReachablePlot
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LN625@ExecuteMov@5

; 6779 : 						pBestPlot = GetReachablePlot(pUnit, aDangerList, 1);

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, ebp
	lea	ebx, DWORD PTR _aDangerList$[esp+316]
	mov	DWORD PTR $T284818[esp+316], esp
	mov	DWORD PTR [eax], ebp
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@H@Z ; GetReachablePlot
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 6780 : #endif
; 6781 : 
; 6782 : 			if(pBestPlot != NULL)

	test	esi, esi
	je	$LN4@ExecuteMov@5
$LN625@ExecuteMov@5:

; 6783 : 			{
; 6784 : 				// Move to the lowest danger value found
; 6785 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestPlot->getX(), pBestPlot->getY(), MOVE_UNITS_IGNORE_DANGER);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	8
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, ebp
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6786 : 				pUnit->finishMoves();

	mov	ecx, ebp
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6787 : 				UnitProcessed(pUnit->GetID(), pUnit->IsCombatUnit());

	cmp	DWORD PTR [ebp+1044], 0
	mov	eax, DWORD PTR [ebp+100]
	mov	edi, DWORD PTR _this$[esp+304]
	setg	cl
	movzx	edx, cl
	push	edx
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 6788 : 
; 6789 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteMov@5
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteMov@5

; 6790 : 				{
; 6791 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223815[esp+304]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	bl, 5

; 6792 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223816[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6793 : 					strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+312], 6
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$223816[esp+304]
	test	eax, eax
	je	SHORT $LN485@ExecuteMov@5
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN484@ExecuteMov@5
$LN485@ExecuteMov@5:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN484@ExecuteMov@5:

; 6794 : 					strLogString.Format("Moving %s to safety, To X: %d, Y: %d, From X: %d, Y: %d", strTemp.GetCString(), pBestPlot->getX(), pBestPlot->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [ebp+88]
	mov	ecx, DWORD PTR [ebp+76]
	movsx	edx, WORD PTR [esi+2]
	movsx	esi, WORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	push	esi
	lea	ecx, DWORD PTR _strTemp$223816[esp+320]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$223815[esp+324]
	push	OFFSET $SG223817
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 6795 : 					LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$223815[esp+308]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 6796 : 				}

	lea	ecx, DWORD PTR _strTemp$223816[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$223815[esp+304]

; 6797 : 			}
; 6798 : 			else

	jmp	$LN634@ExecuteMov@5
$LN4@ExecuteMov@5:

; 6799 : 			{
; 6800 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteMov@5
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteMov@5

; 6801 : 				{
; 6802 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$223820[esp+304]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	bl, 7

; 6803 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223821[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6804 : 					strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+312], 8
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$223821[esp+304]
	test	eax, eax
	je	SHORT $LN523@ExecuteMov@5
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN522@ExecuteMov@5
$LN523@ExecuteMov@5:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN522@ExecuteMov@5:

; 6805 : 					strLogString.Format("Failed to find destination moving %s to safety from, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [ebp+88]
	mov	ecx, DWORD PTR [ebp+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$223821[esp+312]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$223820[esp+316]
	push	OFFSET $SG223822
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 6806 : 					LogTacticalMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+324]
	add	esp, 20					; 00000014H
	push	1
	lea	eax, DWORD PTR _strLogString$223820[esp+308]
	push	eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 6807 : 				}

	lea	ecx, DWORD PTR _strTemp$223821[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$223820[esp+304]
$LN634@ExecuteMov@5:
	mov	BYTE PTR __$EHRec$[esp+312], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteMov@5:

; 6808 : 			}
; 6809 : 		}
; 6810 : 	}

	mov	BYTE PTR __$EHRec$[esp+312], 3
	test	ebp, ebp
	je	SHORT $LN30@ExecuteMov@5
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@ExecuteMov@5:
	mov	eax, DWORD PTR _this$[esp+304]
	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, DWORD PTR [eax+24]
	mov	esi, DWORD PTR _iI$223764[esp+304]
	add	DWORD PTR tv2579[esp+304], 24		; 00000018H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	inc	esi
	add	ecx, edx
	mov	DWORD PTR _iI$223764[esp+304], esi
	cmp	esi, ecx
	jb	$LL31@ExecuteMov@5

; 6596 : 
; 6597 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	esi, DWORD PTR _aDangerList$[esp+304]
$LN29@ExecuteMov@5:

; 6811 : }

	lea	edx, DWORD PTR _aDangerList$[esp+316]
	mov	BYTE PTR __$EHRec$[esp+312], 2
	cmp	esi, edx
	je	SHORT $LN556@ExecuteMov@5
	push	esi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN556@ExecuteMov@5:
	mov	eax, DWORD PTR _aCoverList$[esp+304]
	lea	ecx, DWORD PTR _aCoverList$[esp+316]
	mov	BYTE PTR __$EHRec$[esp+312], 1
	cmp	eax, ecx
	je	SHORT $LN573@ExecuteMov@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN573@ExecuteMov@5:
	mov	eax, DWORD PTR _aZeroDangerList$[esp+304]
	lea	edx, DWORD PTR _aZeroDangerList$[esp+316]
	mov	BYTE PTR __$EHRec$[esp+312], 0
	cmp	eax, edx
	je	SHORT $LN590@ExecuteMov@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN590@ExecuteMov@5:
	mov	eax, DWORD PTR _aCityList$[esp+304]
	lea	ecx, DWORD PTR _aCityList$[esp+316]
	mov	DWORD PTR __$EHRec$[esp+312], -1
	cmp	eax, ecx
	je	SHORT $LN607@ExecuteMov@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN607@ExecuteMov@5:
	mov	ecx, DWORD PTR __$EHRec$[esp+304]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 288				; 00000120H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _aCityList$[ebp]
	jmp	??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>
__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _aZeroDangerList$[ebp]
	jmp	??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>
__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _aCoverList$[ebp]
	jmp	??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>
__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _aDangerList$[ebp]
	jmp	??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>
__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _pUnit$223768[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR _strLogString$223815[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$10:
	lea	ecx, DWORD PTR _strTemp$223816[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$11:
	lea	ecx, DWORD PTR _strLogString$223820[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ$12:
	lea	ecx, DWORD PTR _strTemp$223821[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::ExecuteMovesToSafestPlot
PUBLIC	?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z ; CvTacticalAI::FindUnitsForThisMove
EXTRN	?getAttackModifier@CvUnit@@QBEHXZ:PROC		; CvUnit::getAttackModifier
EXTRN	?getExtraCombatPercent@CvUnit@@QBEHXZ:PROC	; CvUnit::getExtraCombatPercent
EXTRN	?getDefenseModifier@CvUnit@@QBEHXZ:PROC		; CvUnit::getDefenseModifier
EXTRN	?noDefensiveBonus@CvUnit@@QBE_NXZ:PROC		; CvUnit::noDefensiveBonus
EXTRN	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetUnitAIType
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z$0
__ehfuncinfo$?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z
_TEXT	SEGMENT
_bHighPriority$224817 = -58				; size = 1
_rtnValue$ = -57					; size = 1
_this$ = -56						; size = 4
$T286989 = -52						; size = 1
$T286792 = -52						; size = 1
_it$ = -52						; size = 4
$T286611 = -48						; size = 4
_pLoopUnit$ = -44					; size = 8
_unit$224854 = -36					; size = 24
__$EHRec$ = -12						; size = 12
_eMove$ = 8						; size = 4
_pTarget$ = 12						; size = 4
_iNumTurnsAway$ = 16					; size = 4
__Cat$286994 = 20					; size = 1
$T286991 = 20						; size = 1
__Cat$286763 = 20					; size = 1
$T286794 = 20						; size = 1
_bRangedOnly$ = 20					; size = 1
?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z PROC ; CvTacticalAI::FindUnitsForThisMove, COMDAT
; _this$ = ecx

; 8730 : {

	push	-1
	push	__ehhandler$?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 8731 : 	UnitHandle pLoopUnit;

	xor	ebx, ebx
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+76], edi
	mov	DWORD PTR _pLoopUnit$[esp+76], ebx
	mov	BYTE PTR _pLoopUnit$[esp+80], bl

; 8732 : 	bool rtnValue = false;
; 8733 : 
; 8734 : 	list<int>::iterator it;
; 8735 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [edi+24]
	mov	DWORD PTR __$EHRec$[esp+84], ebx
	mov	BYTE PTR _rtnValue$[esp+76], bl
	cmp	ecx, eax
	je	SHORT $LN58@FindUnitsF
	mov	BYTE PTR $T286792[esp+76], bl
	mov	edx, DWORD PTR $T286792[esp+76]
	push	edx
	mov	edx, DWORD PTR __Cat$286763[esp+76]
	push	edx
	mov	edx, DWORD PTR $T286794[esp+80]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+28], eax
$LN58@FindUnitsF:

; 8736 : 	m_CurrentMoveHighPriorityUnits.clear();

	mov	eax, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [edi+40]
	cmp	ecx, eax
	je	SHORT $LN97@FindUnitsF
	mov	BYTE PTR $T286989[esp+76], 0
	mov	edx, DWORD PTR $T286989[esp+76]
	push	edx
	mov	edx, DWORD PTR __Cat$286994[esp+76]
	push	edx
	mov	edx, DWORD PTR $T286991[esp+80]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+44], eax
$LN97@FindUnitsF:

; 8737 : 
; 8738 : 	// Loop through all units available to tactical AI this turn
; 8739 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 8740 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 8741 : #else
; 8742 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _it$[esp+76], ecx
	cmp	ecx, eax
	je	$LN31@FindUnitsF
	npad	4
$LL134@FindUnitsF:

; 8743 : #endif
; 8744 : 	{
; 8745 : 		pLoopUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR _it$[esp+76]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	test	ebx, ebx
	je	SHORT $LN158@FindUnitsF
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN158@FindUnitsF:
	mov	DWORD PTR _pLoopUnit$[esp+76], esi
	test	esi, esi
	je	$LN32@FindUnitsF
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 8746 : 		if(pLoopUnit && pLoopUnit->getDomainType() != DOMAIN_AIR && pLoopUnit->IsCombatUnit())

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	$LN32@FindUnitsF
	cmp	DWORD PTR [esi+1044], 0
	jle	$LN32@FindUnitsF

; 8747 : 		{
; 8748 : 			// Make sure domain matches
; 8749 : 			if(pLoopUnit->getDomainType() == DOMAIN_SEA && !pTarget->isWater() ||
; 8750 : 			        pLoopUnit->getDomainType() == DOMAIN_LAND && pTarget->isWater())

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	ebp, DWORD PTR _pTarget$[esp+72]
	test	eax, eax
	jne	SHORT $LN27@FindUnitsF
	cmp	BYTE PTR [ebp+5], 3
	jne	$LN32@FindUnitsF
$LN27@FindUnitsF:
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN29@FindUnitsF
	cmp	BYTE PTR [ebp+5], 3

; 8751 : 			{
; 8752 : 				continue;

	je	$LN32@FindUnitsF
$LN29@FindUnitsF:

; 8753 : 			}
; 8754 : 
; 8755 : 			bool bSuitableUnit = false;
; 8756 : 			bool bHighPriority = false;
; 8757 : 
; 8758 : 			if(eMove == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_GARRISON_ALREADY_THERE] ||
; 8759 : 			        eMove == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_GARRISON_1_TURN])

	mov	eax, DWORD PTR _eMove$[esp+72]
	xor	bl, bl
	mov	BYTE PTR _bHighPriority$224817[esp+76], bl
	cmp	eax, DWORD PTR [edi+29284]
	je	$LN25@FindUnitsF
	cmp	eax, DWORD PTR [edi+29296]
	je	$LN25@FindUnitsF

; 8777 : 				{
; 8778 : 					bSuitableUnit = true;
; 8779 : 				}
; 8780 : 			}
; 8781 : 
; 8782 : 			else if(eMove == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_GUARD_IMPROVEMENT_ALREADY_THERE] ||
; 8783 : 			        eMove == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_GUARD_IMPROVEMENT_1_TURN] ||
; 8784 : 			        eMove == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_BASTION_ALREADY_THERE] ||
; 8785 : 			        eMove == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_BASTION_1_TURN])

	cmp	eax, DWORD PTR [edi+29292]
	je	SHORT $LN18@FindUnitsF
	cmp	eax, DWORD PTR [edi+29304]
	je	SHORT $LN18@FindUnitsF
	cmp	eax, DWORD PTR [edi+29288]
	je	SHORT $LN18@FindUnitsF
	cmp	eax, DWORD PTR [edi+29300]
	je	SHORT $LN18@FindUnitsF

; 8799 : 
; 8800 : 			else if(eMove == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_ANCIENT_RUINS])

	cmp	eax, DWORD PTR [edi+29276]
	jne	$LN32@FindUnitsF

; 8801 : 			{
; 8802 : 				// Fast movers are top priority
; 8803 : 				if(pLoopUnit->getUnitInfo().GetUnitAIType(UNITAI_FAST_ATTACK))

	push	5
	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	test	al, al
	je	SHORT $LN12@FindUnitsF

; 8804 : 				{
; 8805 : 					bSuitableUnit = true;
; 8806 : 					bHighPriority = true;

	mov	BYTE PTR _bHighPriority$224817[esp+76], 1
	jmp	$LN249@FindUnitsF
$LN12@FindUnitsF:

; 8807 : 				}
; 8808 : 				else if(pLoopUnit->IsCanAttack())

	mov	ecx, esi
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	test	al, al

; 8809 : 				{
; 8810 : 					bSuitableUnit = true;

	jmp	SHORT $LN261@FindUnitsF
$LN18@FindUnitsF:

; 8786 : 			{
; 8787 : 				// No ranged units or units without defensive bonuses as plot defenders
; 8788 : 				if(!pLoopUnit->isRanged() && !pLoopUnit->noDefensiveBonus())

	mov	ecx, esi
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	test	al, al
	jne	$LN32@FindUnitsF
	mov	ecx, esi
	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	test	al, al
	jne	$LN32@FindUnitsF

; 8789 : 				{
; 8790 : 					bSuitableUnit = true;
; 8791 : 
; 8792 : 					// Units with defensive promotions are especially valuable
; 8793 : 					if(pLoopUnit->getDefenseModifier() > 0 || pLoopUnit->getExtraCombatPercent() > 0)

	mov	ecx, esi
	call	?getDefenseModifier@CvUnit@@QBEHXZ	; CvUnit::getDefenseModifier
	test	eax, eax
	jg	SHORT $LN15@FindUnitsF
	mov	ecx, esi
	call	?getExtraCombatPercent@CvUnit@@QBEHXZ	; CvUnit::getExtraCombatPercent
	test	eax, eax
	jle	SHORT $LN249@FindUnitsF
$LN15@FindUnitsF:

; 8794 : 					{
; 8795 : 						bHighPriority = true;

	mov	BYTE PTR _bHighPriority$224817[esp+76], 1

; 8796 : 					}
; 8797 : 				}
; 8798 : 			}

	jmp	SHORT $LN249@FindUnitsF
$LN25@FindUnitsF:

; 8760 : 			{
; 8761 : 				// Want to put ranged units in cities to give them a ranged attack
; 8762 : 				if(pLoopUnit->isRanged())

	mov	ecx, esi
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	test	al, al
	je	SHORT $LN24@FindUnitsF

; 8763 : 				{
; 8764 : 					bSuitableUnit = true;

	mov	bl, 1

; 8765 : 					bHighPriority = true;

	mov	BYTE PTR _bHighPriority$224817[esp+76], bl
	jmp	SHORT $LN22@FindUnitsF
$LN24@FindUnitsF:

; 8766 : 				}
; 8767 : 
; 8768 : 				else if(bRangedOnly)

	cmp	BYTE PTR _bRangedOnly$[esp+72], 0
	jne	$LN32@FindUnitsF
$LN22@FindUnitsF:

; 8769 : 				{
; 8770 : 					continue;
; 8771 : 				}
; 8772 : 
; 8773 : 				// Don't put units with a combat strength boosted from promotions in cities, these boosts are ignored
; 8774 : 				if(pLoopUnit->getDefenseModifier() == 0 &&
; 8775 : 				        pLoopUnit->getAttackModifier() == 0 &&
; 8776 : 				        pLoopUnit->getExtraCombatPercent() == 0)

	mov	ecx, esi
	call	?getDefenseModifier@CvUnit@@QBEHXZ	; CvUnit::getDefenseModifier
	test	eax, eax
	jne	SHORT $LN21@FindUnitsF
	mov	ecx, esi
	call	?getAttackModifier@CvUnit@@QBEHXZ	; CvUnit::getAttackModifier
	test	eax, eax
	jne	SHORT $LN21@FindUnitsF
	mov	ecx, esi
	call	?getExtraCombatPercent@CvUnit@@QBEHXZ	; CvUnit::getExtraCombatPercent
	test	eax, eax

; 8811 : 				}
; 8812 : 			}
; 8813 : 
; 8814 : 			if(bSuitableUnit)

	je	SHORT $LN249@FindUnitsF
$LN21@FindUnitsF:
	test	bl, bl
$LN261@FindUnitsF:
	je	$LN32@FindUnitsF
$LN249@FindUnitsF:

; 8815 : 			{
; 8816 : 				// Is it even possible for the unit to reach in the number of requested turns (ignoring roads and RR)
; 8817 : 				int iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pTarget->getX(), pTarget->getY());

	movsx	edx, WORD PTR [ebp+2]
	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	edx
	movsx	edx, WORD PTR [ebp]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 8818 : 				if(pLoopUnit->maxMoves() > 0)

	mov	ecx, esi
	mov	ebp, eax
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	test	eax, eax
	jle	$LN32@FindUnitsF

; 8819 : 				{
; 8820 : 					int iMovesPerTurn = pLoopUnit->maxMoves() / GC.getMOVE_DENOMINATOR();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	ecx, esi
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	cdq
	idiv	edi

; 8821 : 					int iLeastTurns = (iDistance + iMovesPerTurn - 1) / iMovesPerTurn;
; 8822 : 					if(iNumTurnsAway == -1 || iLeastTurns <= iNumTurnsAway)

	mov	ebx, DWORD PTR _iNumTurnsAway$[esp+72]
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx+ebp-1]
	cdq
	idiv	ecx
	cmp	ebx, -1
	je	SHORT $LN6@FindUnitsF
	cmp	eax, ebx
	jg	$LN256@FindUnitsF
$LN6@FindUnitsF:

; 8823 : 					{
; 8824 : 						// If unit was suitable, and close enough, add it to the proper list
; 8825 : 						int iMoves = TurnsToReachTarget(pLoopUnit, pTarget);

	mov	eax, DWORD PTR _pTarget$[esp+72]
	push	0
	push	0
	push	0
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pLoopUnit$[esp+100]
	mov	ecx, esp
	mov	DWORD PTR $T286611[esp+100], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	mov	edi, eax
	add	esp, 24					; 00000018H

; 8826 : 						if(iMoves != MAX_INT && (iNumTurnsAway == -1 ||
; 8827 : 						                         (iNumTurnsAway == 0 && pLoopUnit->plot() == pTarget) || iMoves <= iNumTurnsAway))

	cmp	edi, 2147483647				; 7fffffffH
	je	SHORT $LN256@FindUnitsF
	cmp	ebx, -1
	je	SHORT $LN254@FindUnitsF
	xor	ebp, ebp
	cmp	ebx, ebp
	jne	SHORT $LN3@FindUnitsF
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pTarget$[esp+72]
	je	SHORT $LN4@FindUnitsF
$LN3@FindUnitsF:
	cmp	edi, ebx
	jg	SHORT $LN256@FindUnitsF
$LN254@FindUnitsF:
	xor	ebp, ebp
$LN4@FindUnitsF:

; 8828 : 						{
; 8829 : 							CvTacticalUnit unit;
; 8830 : 							unit.SetID(pLoopUnit->GetID());

	mov	eax, DWORD PTR [esi+100]

; 8831 : 							unit.SetHealthPercent(pLoopUnit->GetCurrHitPoints(), pLoopUnit->GetMaxHitPoints());

	mov	ecx, esi
	mov	DWORD PTR _unit$224854[esp+80], ebp
	mov	DWORD PTR _unit$224854[esp+92], ebp
	mov	DWORD PTR _unit$224854[esp+96], ebp
	mov	DWORD PTR _unit$224854[esp+76], eax
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	mov	ecx, esi
	mov	ebp, eax
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	imul	eax, 100				; 00000064H
	cdq
	idiv	ebp

; 8832 : 							unit.SetMovesToTarget(iMoves);
; 8833 : 
; 8834 : 							if(bHighPriority)

	cmp	BYTE PTR _bHighPriority$224817[esp+76], 0
	mov	DWORD PTR _unit$224854[esp+88], edi
	mov	DWORD PTR _unit$224854[esp+84], eax
	je	SHORT $LN2@FindUnitsF

; 8835 : 							{
; 8836 : 								m_CurrentMoveHighPriorityUnits.push_back(unit);

	lea	ecx, DWORD PTR _unit$224854[esp+76]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+80]
	add	ecx, 36					; 00000024H

; 8837 : 							}
; 8838 : 							else

	jmp	SHORT $LN262@FindUnitsF
$LN2@FindUnitsF:

; 8839 : 							{
; 8840 : 								m_CurrentMoveUnits.push_back(unit);

	mov	ecx, DWORD PTR _this$[esp+76]
	lea	edx, DWORD PTR _unit$224854[esp+76]
	push	edx
	add	ecx, 20					; 00000014H
$LN262@FindUnitsF:
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back

; 8841 : 							}
; 8842 : 							rtnValue = true;

	mov	BYTE PTR _rtnValue$[esp+76], 1
$LN256@FindUnitsF:
	mov	edi, DWORD PTR _this$[esp+76]
$LN32@FindUnitsF:

; 8737 : 
; 8738 : 	// Loop through all units available to tactical AI this turn
; 8739 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 8740 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 8741 : #else
; 8742 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR _it$[esp+76]
	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR _pLoopUnit$[esp+76]
	mov	DWORD PTR _it$[esp+76], eax
	cmp	eax, DWORD PTR [edi+12]
	jne	$LL134@FindUnitsF
$LN31@FindUnitsF:

; 8843 : 						}
; 8844 : 					}
; 8845 : 				}
; 8846 : 			}
; 8847 : 		}
; 8848 : 	}
; 8849 : 
; 8850 : 	return rtnValue;

	mov	DWORD PTR __$EHRec$[esp+84], -1
	test	ebx, ebx
	je	SHORT $LN250@FindUnitsF
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN250@FindUnitsF:

; 8851 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	mov	al, BYTE PTR _rtnValue$[esp+76]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 60					; 0000003cH
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z ENDP ; CvTacticalAI::FindUnitsForThisMove
PUBLIC	??$stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z ; std::stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z PROC ; std::stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >, COMDAT

; 3420 : 	_DEBUG_RANGE(_First, _Last);
; 3421 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor

; 3422 : 		{
; 3423 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
	add	esp, 16					; 00000010H
$LN1@stable_sor:

; 3424 : 		}
; 3425 : 	}

	ret	0
??$stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0@Z ENDP ; std::stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> > >
_TEXT	ENDS
PUBLIC	??$stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z ; std::stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z PROC ; std::stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >, COMDAT

; 3420 : 	_DEBUG_RANGE(_First, _Last);
; 3421 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor@2

; 3422 : 		{
; 3423 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
	add	esp, 16					; 00000010H
$LN1@stable_sor@2:

; 3424 : 		}
; 3425 : 	}

	ret	0
??$stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0@Z ENDP ; std::stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> > >
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z ; std::_Stable_sort<CvTacticalMove *,int,CvTacticalMove>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z PROC ; std::_Stable_sort<CvTacticalMove *,int,CvTacticalMove>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3411 : 	_Diff _Count = 0;
; 3412 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 3

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	mov	edx, eax
	push	edx
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0HAAV?$_Temp_iterator@VCvTacticalMove@@@0@@Z ; std::_Stable_sort<CvTacticalMove *,int,CvTacticalMove>

; 3415 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+60]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN20@Stable_sor@9
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@Stable_sor@9:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvTacticalMove@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalMove>::~_Temp_iterator<CvTacticalMove>
__ehhandler$??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z ENDP ; std::_Stable_sort<CvTacticalMove *,int,CvTacticalMove>
PUBLIC	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z PROC ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3411 : 	_Diff _Count = 0;
; 3412 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	mov	edx, eax
	push	edx
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0HAAV?$_Temp_iterator@VCvTacticalTarget@@@0@@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>

; 3415 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+60]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN20@Stable_sor@10
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@Stable_sor@10:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvTacticalTarget@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalTarget>::~_Temp_iterator<CvTacticalTarget>
__ehhandler$??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z ENDP ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
PUBLIC	??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z PROC ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3561 : 	_Diff _Count = 0;
; 3562 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 4

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+40]
	push	edx
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	call	??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@P6A_NV1@2@Z@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>

; 3565 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+64]
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN20@Stable_sor@11
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@Stable_sor@11:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvBlockingUnit>::~_Temp_iterator<CvBlockingUnit>
__ehhandler$??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z ENDP ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
PUBLIC	??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z PROC ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3411 : 	_Diff _Count = 0;
; 3412 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 4

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	mov	edx, eax
	push	edx
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0HAAV?$_Temp_iterator@VCvBlockingUnit@@@0@@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit>

; 3415 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+60]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN20@Stable_sor@12
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@Stable_sor@12:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvBlockingUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvBlockingUnit>::~_Temp_iterator<CvBlockingUnit>
__ehhandler$??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z ENDP ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit>
PUBLIC	?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z	; CvTacticalAI::PlotMovesToSafety
EXTRN	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z:PROC	; CvUnit::GetBaseCombatStrength
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z$0
__ehfuncinfo$?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T287729 = -48						; size = 1
_it$ = -48						; size = 4
_pUnit$221435 = -44					; size = 8
_unit$221454 = -36					; size = 24
__$EHRec$ = -12						; size = 12
__Cat$287733 = 8					; size = 1
$T287731 = 8						; size = 1
_bCombatUnits$ = 8					; size = 1
?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z PROC		; CvTacticalAI::PlotMovesToSafety, COMDAT
; _this$ = ecx

; 2319 : {

	push	-1
	push	__ehhandler$?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	mov	ebp, ecx

; 2320 : 	int iDangerLevel;
; 2321 : 
; 2322 : 	list<int>::iterator it;
; 2323 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR [ebp+24]
	xor	ebx, ebx
	mov	DWORD PTR _this$[esp+60], ebp
	cmp	ecx, eax
	je	SHORT $LN41@PlotMovesT
	mov	BYTE PTR $T287729[esp+60], bl
	mov	edx, DWORD PTR $T287729[esp+60]
	push	edx
	mov	edx, DWORD PTR __Cat$287733[esp+60]
	push	edx
	mov	edx, DWORD PTR $T287731[esp+64]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebp+28], eax
$LN41@PlotMovesT:

; 2324 : 
; 2325 : 	// Loop through all recruited units
; 2326 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 2327 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 2328 : #else
; 2329 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _it$[esp+60], ecx
	cmp	ecx, eax
	je	$LN17@PlotMovesT
	push	esi
	push	edi
$LL149@PlotMovesT:

; 2330 : #endif
; 2331 : 	{
; 2332 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR _it$[esp+68]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$221435[esp+68], esi
	mov	BYTE PTR _pUnit$221435[esp+72], bl
	cmp	esi, ebx
	je	SHORT $LN101@PlotMovesT
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN101@PlotMovesT:
	mov	DWORD PTR __$EHRec$[esp+76], ebx

; 2333 : 		if(pUnit)

	cmp	esi, ebx
	je	$LN150@PlotMovesT

; 2334 : 		{
; 2335 : 			// Danger value of plot must be greater than 0
; 2336 : 			CvPlot* pPlot = pUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 2337 : 
; 2338 : 			iDangerLevel = m_pPlayer->GetPlotDanger(*pPlot);

	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	edi, eax

; 2339 : 			if(iDangerLevel > 0)

	cmp	edi, ebx
	jle	$LN150@PlotMovesT

; 2340 : 			{
; 2341 : 				bool bAddUnit = false;
; 2342 : 				if(bCombatUnits)
; 2343 : 				{
; 2344 : 					// If under 100% health, might flee to safety
; 2345 : 					if(pUnit->GetCurrHitPoints() < pUnit->GetMaxHitPoints())

	mov	ecx, esi
	cmp	BYTE PTR _bCombatUnits$[esp+64], bl
	je	$LN14@PlotMovesT
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	mov	ecx, esi
	mov	ebp, eax
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	cmp	ebp, eax

; 2346 : 					{
; 2347 : 						if(pUnit->isBarbarian())

	mov	ecx, esi
	jge	$LN13@PlotMovesT
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian

; 2348 : 						{
; 2349 : 							// Barbarian combat units - only naval units flee (but they flee if have taken ANY damage)
; 2350 : 							if(pUnit->getDomainType() == DOMAIN_SEA)

	mov	ecx, esi
	test	al, al
	je	SHORT $LN12@PlotMovesT
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN148@PlotMovesT
$LN147@PlotMovesT:

; 2369 : 						{
; 2370 : 							bAddUnit = true;
; 2371 : 						}
; 2372 : 					}
; 2373 : 				}
; 2374 : 				else

	mov	ebp, DWORD PTR _this$[esp+68]
$LN146@PlotMovesT:

; 2378 : 					{
; 2379 : 						bAddUnit = true;
; 2380 : 					}
; 2381 : 				}
; 2382 : 
; 2383 : 				if(bAddUnit)
; 2384 : 				{
; 2385 : 					// Just one unit involved in this move to execute
; 2386 : 					CvTacticalUnit unit;
; 2387 : 					unit.SetID(pUnit->GetID());

	mov	edx, DWORD PTR [esi+100]

; 2388 : 					m_CurrentMoveUnits.push_back(unit);

	lea	eax, DWORD PTR _unit$221454[esp+68]
	push	eax
	lea	ecx, DWORD PTR [ebp+20]
	mov	DWORD PTR _unit$221454[esp+76], ebx
	mov	DWORD PTR _unit$221454[esp+80], ebx
	mov	DWORD PTR _unit$221454[esp+84], ebx
	mov	DWORD PTR _unit$221454[esp+88], ebx
	mov	DWORD PTR _unit$221454[esp+92], ebx
	mov	DWORD PTR _unit$221454[esp+72], edx
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back
	jmp	SHORT $LN150@PlotMovesT
$LN12@PlotMovesT:

; 2351 : 							{
; 2352 : 								bAddUnit = true;
; 2353 : 							}
; 2354 : 						}
; 2355 : 
; 2356 : 						// Everyone else flees if under enemy fire or if at less than or equal to 50% combat strength
; 2357 : 						else if (pUnit->IsUnderEnemyRangedAttack() || pUnit->GetBaseCombatStrengthConsideringDamage() * 2 <= pUnit->GetBaseCombatStrength())

	call	?IsUnderEnemyRangedAttack@CvUnit@@QBE_NXZ ; CvUnit::IsUnderEnemyRangedAttack
	test	al, al
	jne	SHORT $LN147@PlotMovesT
	push	ebx
	mov	ecx, esi
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	mov	ecx, esi
	mov	edi, eax
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage
	add	eax, eax
	cmp	eax, edi
	jle	SHORT $LN147@PlotMovesT
$LN148@PlotMovesT:

; 2388 : 					m_CurrentMoveUnits.push_back(unit);

	mov	ebp, DWORD PTR _this$[esp+68]
$LN150@PlotMovesT:

; 2389 : 				}
; 2390 : 			}
; 2391 : 		}
; 2392 : 	}

	mov	DWORD PTR __$EHRec$[esp+76], -1
	cmp	esi, ebx
	je	SHORT $LN18@PlotMovesT
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN18@PlotMovesT:
	mov	ecx, DWORD PTR _it$[esp+68]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _it$[esp+68], eax
	cmp	eax, DWORD PTR [ebp+12]
	jne	$LL149@PlotMovesT
	pop	edi
	pop	esi
$LN17@PlotMovesT:

; 2393 : 
; 2394 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	SHORT $LN1@PlotMovesT

; 2395 : 	{
; 2396 : 		ExecuteMovesToSafestPlot();

	mov	ecx, ebp
	call	?ExecuteMovesToSafestPlot@CvTacticalAI@@AAEXXZ ; CvTacticalAI::ExecuteMovesToSafestPlot
$LN1@PlotMovesT:

; 2397 : 	}
; 2398 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	4
$LN13@PlotMovesT:

; 2358 : 						{
; 2359 : 							bAddUnit = true;
; 2360 : 						}
; 2361 : 					}
; 2362 : 
; 2363 : 					// Also flee if danger is really high in current plot (but not if we're barbarian)
; 2364 : 					else if(!pUnit->isBarbarian())

	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	SHORT $LN148@PlotMovesT

; 2365 : 					{
; 2366 : 						int iAcceptableDanger;
; 2367 : 						iAcceptableDanger = pUnit->GetBaseCombatStrengthConsideringDamage() * 100;

	mov	ecx, esi
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage
	imul	eax, 100				; 00000064H

; 2368 : 						if(iDangerLevel > iAcceptableDanger)

	cmp	edi, eax
	jle	SHORT $LN148@PlotMovesT

; 2369 : 						{
; 2370 : 							bAddUnit = true;
; 2371 : 						}
; 2372 : 					}
; 2373 : 				}
; 2374 : 				else

	jmp	$LN147@PlotMovesT
$LN14@PlotMovesT:

; 2375 : 				{
; 2376 : 					// Civilian (or embarked) units always flee from danger
; 2377 : 					if(!pUnit->IsCanDefend())

	push	ebx
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	jne	$LN150@PlotMovesT
	jmp	$LN146@PlotMovesT
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z$0:
	lea	ecx, DWORD PTR _pUnit$221435[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z ENDP		; CvTacticalAI::PlotMovesToSafety
PUBLIC	?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::PlotGarrisonMoves
EXTRN	?SetLastTurnGarrisonAssigned@CvCity@@QAEXH@Z:PROC ; CvCity::SetLastTurnGarrisonAssigned
EXTRN	?GetLastTurnGarrisonAssigned@CvCity@@QBEHXZ:PROC ; CvCity::GetLastTurnGarrisonAssigned
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z$0
__ehfuncinfo$?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z
_TEXT	SEGMENT
tv409 = -48						; size = 4
tv407 = -48						; size = 4
_pTarget$ = -48						; size = 4
_pCity$221752 = -44					; size = 4
_strLogString$221757 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_iNumTurnsAway$ = 8					; size = 4
_bMustAllowRangedAttack$ = 12				; size = 1
?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z PROC		; CvTacticalAI::PlotGarrisonMoves, COMDAT
; _this$ = ecx

; 2981 : {

	push	-1
	push	__ehhandler$?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebp
	push	edi

; 2982 : 	CvTacticalTarget* pTarget;
; 2983 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_CITY_TO_DEFEND);

	push	8
	mov	edi, ecx
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	ebp, eax
	mov	DWORD PTR _pTarget$[esp+56], ebp

; 2984 : 	while(pTarget != NULL)

	test	ebp, ebp
	je	$LN5@PlotGarris
	push	ebx
	push	esi
	jmp	SHORT $LN6@PlotGarris
$LL82@PlotGarris:
	mov	ebp, DWORD PTR _pTarget$[esp+64]
$LN6@PlotGarris:

; 2985 : 	{
; 2986 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [ebp+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN16@PlotGarris
	cmp	ebx, -2147483647			; 80000001H
	je	$LN16@PlotGarris
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	dl, dl
	je	SHORT $LN26@PlotGarris
	test	eax, eax
	jge	SHORT $LN28@PlotGarris
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN30@PlotGarris
$LN28@PlotGarris:
	cmp	eax, ecx
	jl	SHORT $LN26@PlotGarris
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN30@PlotGarris
$LN26@PlotGarris:
	mov	esi, eax
$LN30@PlotGarris:
	mov	al, BYTE PTR [ebp+4057]
	mov	ebp, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN83@PlotGarris
	test	ebx, ebx
	jge	SHORT $LN38@PlotGarris
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN40@PlotGarris
$LN38@PlotGarris:
	cmp	ebx, ebp
	jl	SHORT $LN83@PlotGarris
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN40@PlotGarris
$LN83@PlotGarris:
	mov	edx, ebx
$LN40@PlotGarris:
	test	esi, esi
	jl	SHORT $LN20@PlotGarris
	cmp	esi, ecx
	jge	SHORT $LN20@PlotGarris
	test	edx, edx
	jl	SHORT $LN20@PlotGarris
	cmp	edx, ebp
	jge	SHORT $LN20@PlotGarris
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	mov	ebp, DWORD PTR _pTarget$[esp+64]
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	esi, ecx
	jmp	SHORT $LN18@PlotGarris
$LN20@PlotGarris:
	mov	ebp, DWORD PTR _pTarget$[esp+64]
$LN16@PlotGarris:
	xor	esi, esi
$LN18@PlotGarris:

; 2987 : 		CvCity* pCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	$LN3@PlotGarris
	cmp	eax, 64					; 00000040H
	jge	$LN3@PlotGarris
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebx, eax
	mov	DWORD PTR _pCity$221752[esp+64], ebx

; 2988 : 
; 2989 : 		if(pCity && pCity->GetLastTurnGarrisonAssigned() < GC.getGame().getGameTurn())

	test	ebx, ebx
	je	$LN3@PlotGarris
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, ebx
	mov	DWORD PTR tv409[esp+64], eax
	call	?GetLastTurnGarrisonAssigned@CvCity@@QBEHXZ ; CvCity::GetLastTurnGarrisonAssigned
	mov	ecx, DWORD PTR tv409[esp+64]
	cmp	eax, ecx
	jge	$LN3@PlotGarris

; 2990 : 		{
; 2991 : 			// Grab units that make sense for this move type
; 2992 : 			FindUnitsForThisMove((TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_GARRISON_ALREADY_THERE], pPlot, iNumTurnsAway, bMustAllowRangedAttack);

	mov	edx, DWORD PTR _bMustAllowRangedAttack$[esp+60]
	mov	ebx, DWORD PTR _iNumTurnsAway$[esp+60]
	mov	eax, DWORD PTR [edi+29284]
	push	edx
	push	ebx
	push	esi
	push	eax
	mov	ecx, edi
	call	?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z ; CvTacticalAI::FindUnitsForThisMove

; 2993 : 
; 2994 : 			if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR [edi+44]
	sub	ecx, DWORD PTR [edi+40]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR tv407[esp+64], eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	eax, DWORD PTR tv407[esp+64]
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	eax, edx
	add	ecx, eax
	je	$LN3@PlotGarris

; 2995 : 			{
; 2996 : 				ExecuteMoveToTarget(pPlot);

	push	esi
	mov	ecx, edi
	call	?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteMoveToTarget

; 2997 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN2@PlotGarris
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN2@PlotGarris

; 2998 : 				{
; 2999 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221757[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3000 : 					strLogString.Format("Garrison, X: %d, Y: %d, Priority: %d, Turns Away: %d", pTarget->GetTargetX(), pTarget->GetTargetY(), pTarget->GetAuxIntData(), iNumTurnsAway);

	mov	eax, DWORD PTR [ebp+20]
	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+4]
	push	ebx
	push	eax
	push	ecx
	push	edx
	lea	edx, DWORD PTR _strLogString$221757[esp+80]
	push	OFFSET $SG221758
	push	edx
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 3001 : 					if(bMustAllowRangedAttack)

	cmp	BYTE PTR _bMustAllowRangedAttack$[esp+60], 0
	je	SHORT $LN1@PlotGarris

; 3002 : 					{
; 3003 : 						strLogString += ", Allows bombard";

	push	OFFSET $SG221760
	lea	ecx, DWORD PTR _strLogString$221757[esp+68]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@PlotGarris:

; 3004 : 					}
; 3005 : 					LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$221757[esp+68]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 3006 : 				}

	lea	ecx, DWORD PTR _strLogString$221757[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@PlotGarris:

; 3007 : 				pCity->SetLastTurnGarrisonAssigned(GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR _pCity$221752[esp+64]
	push	eax
	call	?SetLastTurnGarrisonAssigned@CvCity@@QAEXH@Z ; CvCity::SetLastTurnGarrisonAssigned
$LN3@PlotGarris:

; 3008 : 			}
; 3009 : 		}
; 3010 : 		pTarget = GetNextZoneTarget();

	mov	ecx, edi
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	DWORD PTR _pTarget$[esp+64], eax
	test	eax, eax
	jne	$LL82@PlotGarris
	pop	esi
	pop	ebx
$LN5@PlotGarris:

; 3011 : 	}
; 3012 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z$0:
	lea	ecx, DWORD PTR _strLogString$221757[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z ENDP		; CvTacticalAI::PlotGarrisonMoves
PUBLIC	?PlotBastionMoves@CvTacticalAI@@AAEXH@Z		; CvTacticalAI::PlotBastionMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotBastionMoves@CvTacticalAI@@AAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotBastionMoves@CvTacticalAI@@AAEXH@Z$0
__ehfuncinfo$?PlotBastionMoves@CvTacticalAI@@AAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotBastionMoves@CvTacticalAI@@AAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotBastionMoves@CvTacticalAI@@AAEXH@Z
_TEXT	SEGMENT
tv361 = -44						; size = 4
$T288108 = -44						; size = 4
_strLogString$221773 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_iNumTurnsAway$ = 8					; size = 4
?PlotBastionMoves@CvTacticalAI@@AAEXH@Z PROC		; CvTacticalAI::PlotBastionMoves, COMDAT
; _this$ = ecx

; 3016 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?PlotBastionMoves@CvTacticalAI@@AAEXH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebp
	push	esi

; 3017 : 	CvTacticalTarget* pTarget;
; 3018 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_DEFENSIVE_BASTION);

	push	10					; 0000000aH
	mov	esi, ecx
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	ebp, eax

; 3019 : 	while(pTarget != NULL)

	test	ebp, ebp
	je	$LN3@PlotBastio
	push	ebx
	push	edi
	npad	1
$LL4@PlotBastio:

; 3020 : 	{
; 3021 : 		// Grab units that make sense for this move type
; 3022 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR $T288108[esp+60], edx
	cmp	eax, -2147483647			; 80000001H
	je	$LN14@PlotBastio
	cmp	edx, -2147483647			; 80000001H
	je	$LN14@PlotBastio
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	bl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	bl, bl
	je	SHORT $LN24@PlotBastio
	test	eax, eax
	jge	SHORT $LN26@PlotBastio
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR $T288108[esp+60]
	add	edi, ecx
	jmp	SHORT $LN28@PlotBastio
$LN26@PlotBastio:
	cmp	eax, ecx
	jl	SHORT $LN24@PlotBastio
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR $T288108[esp+60]
	jmp	SHORT $LN28@PlotBastio
$LN24@PlotBastio:
	mov	edi, eax
$LN28@PlotBastio:
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebx+4057]
	mov	ebx, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN71@PlotBastio
	test	edx, edx
	jge	SHORT $LN36@PlotBastio
	mov	eax, edx
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN71@PlotBastio
$LN36@PlotBastio:
	cmp	edx, ebx
	jl	SHORT $LN71@PlotBastio
	mov	eax, edx
	cdq
	idiv	ebx
$LN71@PlotBastio:
	test	edi, edi
	jl	SHORT $LN14@PlotBastio
	cmp	edi, ecx
	jge	SHORT $LN14@PlotBastio
	test	edx, edx
	jl	SHORT $LN14@PlotBastio
	cmp	edx, ebx
	jge	SHORT $LN14@PlotBastio
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	edi, ecx
	jmp	SHORT $LN16@PlotBastio
$LN14@PlotBastio:
	xor	edi, edi
$LN16@PlotBastio:

; 3023 : 		FindUnitsForThisMove((TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_BASTION_ALREADY_THERE], pPlot, iNumTurnsAway);

	mov	ebx, DWORD PTR _iNumTurnsAway$[esp+56]
	mov	ecx, DWORD PTR [esi+29288]
	push	0
	push	ebx
	push	edi
	push	ecx
	mov	ecx, esi
	call	?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z ; CvTacticalAI::FindUnitsForThisMove

; 3024 : 
; 3025 : 		if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR [esi+44]
	sub	ecx, DWORD PTR [esi+40]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR tv361[esp+60], eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR tv361[esp+60]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	ecx, edx
	add	eax, ecx
	je	SHORT $LN73@PlotBastio

; 3026 : 		{
; 3027 : 			ExecuteMoveToTarget(pPlot);

	push	edi
	mov	ecx, esi
	call	?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteMoveToTarget

; 3028 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN73@PlotBastio
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN73@PlotBastio

; 3029 : 			{
; 3030 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221773[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3031 : 				strLogString.Format("Bastion, X: %d, Y: %d, Priority: %d, Turns Away: %d", pTarget->GetTargetX(), pTarget->GetTargetY(), pTarget->GetAuxIntData(), iNumTurnsAway);

	mov	eax, DWORD PTR [ebp+20]
	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+4]
	push	ebx
	push	eax
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _strLogString$221773[esp+76]
	push	OFFSET $SG221774
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 3032 : 				LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$221773[esp+64]
	push	edx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 3033 : 			}

	lea	ecx, DWORD PTR _strLogString$221773[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN73@PlotBastio:

; 3034 : 		}
; 3035 : 		pTarget = GetNextZoneTarget();

	mov	ecx, esi
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL4@PlotBastio
	pop	edi
	pop	ebx
$LN3@PlotBastio:

; 3036 : 	}
; 3037 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotBastionMoves@CvTacticalAI@@AAEXH@Z$0:
	lea	ecx, DWORD PTR _strLogString$221773[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotBastionMoves@CvTacticalAI@@AAEXH@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotBastionMoves@CvTacticalAI@@AAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotBastionMoves@CvTacticalAI@@AAEXH@Z ENDP		; CvTacticalAI::PlotBastionMoves
PUBLIC	?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::PlotGuardImprovementMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z$0
__ehfuncinfo$?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z
_TEXT	SEGMENT
tv357 = -44						; size = 4
_pTarget$ = -44						; size = 4
_strLogString$221787 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_iNumTurnsAway$ = 8					; size = 4
?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z PROC	; CvTacticalAI::PlotGuardImprovementMoves, COMDAT
; _this$ = ecx

; 3041 : {

	push	-1
	push	__ehhandler$?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebp
	push	esi

; 3042 : 	CvTacticalTarget* pTarget;
; 3043 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_IMPROVEMENT_TO_DEFEND);

	push	9
	mov	esi, ecx
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	ebp, eax
	mov	DWORD PTR _pTarget$[esp+52], ebp

; 3044 : 	while(pTarget != NULL)

	test	ebp, ebp
	je	$LN3@PlotGuardI
	push	ebx
	push	edi
	jmp	SHORT $LN4@PlotGuardI
$LL69@PlotGuardI:
	mov	ebp, DWORD PTR _pTarget$[esp+60]
$LN4@PlotGuardI:

; 3045 : 	{
; 3046 : 		// Grab units that make sense for this move type
; 3047 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [ebp+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN14@PlotGuardI
	cmp	ebx, -2147483647			; 80000001H
	je	$LN14@PlotGuardI
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	dl, dl
	je	SHORT $LN24@PlotGuardI
	test	eax, eax
	jge	SHORT $LN26@PlotGuardI
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN28@PlotGuardI
$LN26@PlotGuardI:
	cmp	eax, ecx
	jl	SHORT $LN24@PlotGuardI
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN28@PlotGuardI
$LN24@PlotGuardI:
	mov	edi, eax
$LN28@PlotGuardI:
	mov	al, BYTE PTR [ebp+4057]
	mov	ebp, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN70@PlotGuardI
	test	ebx, ebx
	jge	SHORT $LN36@PlotGuardI
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN38@PlotGuardI
$LN36@PlotGuardI:
	cmp	ebx, ebp
	jl	SHORT $LN70@PlotGuardI
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN38@PlotGuardI
$LN70@PlotGuardI:
	mov	edx, ebx
$LN38@PlotGuardI:
	test	edi, edi
	jl	SHORT $LN18@PlotGuardI
	cmp	edi, ecx
	jge	SHORT $LN18@PlotGuardI
	test	edx, edx
	jl	SHORT $LN18@PlotGuardI
	cmp	edx, ebp
	jge	SHORT $LN18@PlotGuardI
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	mov	ebp, DWORD PTR _pTarget$[esp+60]
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	edi, ecx
	jmp	SHORT $LN16@PlotGuardI
$LN18@PlotGuardI:
	mov	ebp, DWORD PTR _pTarget$[esp+60]
$LN14@PlotGuardI:
	xor	edi, edi
$LN16@PlotGuardI:

; 3048 : 		FindUnitsForThisMove((TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_BASTION_ALREADY_THERE], pPlot, iNumTurnsAway);

	mov	ebx, DWORD PTR _iNumTurnsAway$[esp+56]
	mov	ecx, DWORD PTR [esi+29288]
	push	0
	push	ebx
	push	edi
	push	ecx
	mov	ecx, esi
	call	?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z ; CvTacticalAI::FindUnitsForThisMove

; 3049 : 
; 3050 : 		if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR [esi+44]
	sub	ecx, DWORD PTR [esi+40]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR tv357[esp+60], eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR tv357[esp+60]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	ecx, edx
	add	eax, ecx
	je	SHORT $LN71@PlotGuardI

; 3051 : 		{
; 3052 : 			ExecuteMoveToTarget(pPlot);

	push	edi
	mov	ecx, esi
	call	?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteMoveToTarget

; 3053 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN71@PlotGuardI
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN71@PlotGuardI

; 3054 : 			{
; 3055 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221787[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3056 : 				strLogString.Format("Guard Improvement, X: %d, Y: %d, Turns Away: %d", pTarget->GetTargetX(), pTarget->GetTargetY(), iNumTurnsAway);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebp+4]
	push	ebx
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strLogString$221787[esp+72]
	push	OFFSET $SG221788
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 3057 : 				LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$221787[esp+64]
	push	edx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 3058 : 			}

	lea	ecx, DWORD PTR _strLogString$221787[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN71@PlotGuardI:

; 3059 : 		}
; 3060 : 		pTarget = GetNextZoneTarget();

	mov	ecx, esi
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	DWORD PTR _pTarget$[esp+60], eax
	test	eax, eax
	jne	$LL69@PlotGuardI
	pop	edi
	pop	ebx
$LN3@PlotGuardI:

; 3061 : 	}
; 3062 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z$0:
	lea	ecx, DWORD PTR _strLogString$221787[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z ENDP	; CvTacticalAI::PlotGuardImprovementMoves
PUBLIC	?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z	; CvTacticalAI::PlotAncientRuinMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z$0
__ehfuncinfo$?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z
_TEXT	SEGMENT
tv357 = -44						; size = 4
_pTarget$ = -44						; size = 4
_strLogString$221801 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_iNumTurnsAway$ = 8					; size = 4
?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z PROC	; CvTacticalAI::PlotAncientRuinMoves, COMDAT
; _this$ = ecx

; 3066 : {

	push	-1
	push	__ehhandler$?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebp
	push	esi

; 3067 : 	CvTacticalTarget* pTarget;
; 3068 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_ANCIENT_RUINS);

	push	11					; 0000000bH
	mov	esi, ecx
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	ebp, eax
	mov	DWORD PTR _pTarget$[esp+52], ebp

; 3069 : 	while(pTarget != NULL)

	test	ebp, ebp
	je	$LN3@PlotAncien
	push	ebx
	push	edi
	jmp	SHORT $LN4@PlotAncien
$LL69@PlotAncien:
	mov	ebp, DWORD PTR _pTarget$[esp+60]
$LN4@PlotAncien:

; 3070 : 	{
; 3071 : 		// Grab units that make sense for this move type
; 3072 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [ebp+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN14@PlotAncien
	cmp	ebx, -2147483647			; 80000001H
	je	$LN14@PlotAncien
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	dl, dl
	je	SHORT $LN24@PlotAncien
	test	eax, eax
	jge	SHORT $LN26@PlotAncien
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN28@PlotAncien
$LN26@PlotAncien:
	cmp	eax, ecx
	jl	SHORT $LN24@PlotAncien
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN28@PlotAncien
$LN24@PlotAncien:
	mov	edi, eax
$LN28@PlotAncien:
	mov	al, BYTE PTR [ebp+4057]
	mov	ebp, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN70@PlotAncien
	test	ebx, ebx
	jge	SHORT $LN36@PlotAncien
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN38@PlotAncien
$LN36@PlotAncien:
	cmp	ebx, ebp
	jl	SHORT $LN70@PlotAncien
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN38@PlotAncien
$LN70@PlotAncien:
	mov	edx, ebx
$LN38@PlotAncien:
	test	edi, edi
	jl	SHORT $LN18@PlotAncien
	cmp	edi, ecx
	jge	SHORT $LN18@PlotAncien
	test	edx, edx
	jl	SHORT $LN18@PlotAncien
	cmp	edx, ebp
	jge	SHORT $LN18@PlotAncien
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	mov	ebp, DWORD PTR _pTarget$[esp+60]
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	edi, ecx
	jmp	SHORT $LN16@PlotAncien
$LN18@PlotAncien:
	mov	ebp, DWORD PTR _pTarget$[esp+60]
$LN14@PlotAncien:
	xor	edi, edi
$LN16@PlotAncien:

; 3073 : 		FindUnitsForThisMove((TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_ANCIENT_RUINS], pPlot, iNumTurnsAway);

	mov	ebx, DWORD PTR _iNumTurnsAway$[esp+56]
	mov	ecx, DWORD PTR [esi+29276]
	push	0
	push	ebx
	push	edi
	push	ecx
	mov	ecx, esi
	call	?FindUnitsForThisMove@CvTacticalAI@@AAE_NW4TacticalAIMoveTypes@@PAVCvPlot@@H_N@Z ; CvTacticalAI::FindUnitsForThisMove

; 3074 : 
; 3075 : 		if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR [esi+44]
	sub	ecx, DWORD PTR [esi+40]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR tv357[esp+60], eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	ecx, DWORD PTR tv357[esp+60]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	ecx, edx
	add	eax, ecx
	je	SHORT $LN71@PlotAncien

; 3076 : 		{
; 3077 : 			ExecuteMoveToTarget(pPlot);

	push	edi
	mov	ecx, esi
	call	?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteMoveToTarget

; 3078 : 
; 3079 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN71@PlotAncien
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN71@PlotAncien

; 3080 : 			{
; 3081 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221801[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3082 : 				strLogString.Format("Moving to goody hut, X: %d, Y: %d, Turns Away: %d", pTarget->GetTargetX(), pTarget->GetTargetY(), iNumTurnsAway);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebp+4]
	push	ebx
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strLogString$221801[esp+72]
	push	OFFSET $SG221802
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 3083 : 				LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$221801[esp+64]
	push	edx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 3084 : 			}

	lea	ecx, DWORD PTR _strLogString$221801[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN71@PlotAncien:

; 3085 : 		}
; 3086 : 		pTarget = GetNextZoneTarget();

	mov	ecx, esi
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	DWORD PTR _pTarget$[esp+60], eax
	test	eax, eax
	jne	$LL69@PlotAncien
	pop	edi
	pop	ebx
$LN3@PlotAncien:

; 3087 : 	}
; 3088 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z$0:
	lea	ecx, DWORD PTR _strLogString$221801[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z ENDP	; CvTacticalAI::PlotAncientRuinMoves
PUBLIC	?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::ExecuteWithdrawMoves
EXTRN	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z:PROC ; CvMap::findCity
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_iI$224732 = -124					; size = 4
tv742 = -120						; size = 4
$T288859 = -116						; size = 4
_pUnit$224721 = -116					; size = 8
$T288872 = -108						; size = 4
$T288570 = -108						; size = 4
$T288567 = -108						; size = 4
_pUnit$224736 = -104					; size = 8
_strLogString$224741 = -96				; size = 28
$T288572 = -68						; size = 28
$T288571 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::ExecuteWithdrawMoves, COMDAT
; _this$ = ecx

; 8555 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 8556 : 	CvCity* pNearestCity;
; 8557 : 	int iTurnsToReachTarget;
; 8558 : 
; 8559 : #ifdef AUI_ITERATORIZE
; 8560 : 	for (std::vector<CvTacticalUnit>::iterator it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)
; 8561 : 	{
; 8562 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());
; 8563 : 		if (pUnit)
; 8564 : 		{
; 8565 : 			// Compute moves to nearest city and use as sort criteria
; 8566 : 			pNearestCity = GC.getMap().findCity(pUnit->getX(), pUnit->getY(), m_pPlayer->GetID(), NO_TEAM, true /* bSameArea */);
; 8567 : 			if (pNearestCity != NULL)
; 8568 : 			{
; 8569 : 				iTurnsToReachTarget = TurnsToReachTarget(pUnit, pNearestCity->plot());
; 8570 : 				it->SetMovesToTarget(iTurnsToReachTarget);
; 8571 : 				it->SetAttackStrength(1000 - iTurnsToReachTarget);
; 8572 : 				it->SetHealthPercent(10, 10);
; 8573 : #else
; 8574 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	ebx, ebx
	add	eax, edx
	push	edi
	je	$LN9@ExecuteWit
	xor	ebp, ebp
	npad	1
$LL11@ExecuteWit:

; 8575 : 	{
; 8576 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebp
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$224721[esp+140], edi
	mov	BYTE PTR _pUnit$224721[esp+144], 0
	test	edi, edi
	je	SHORT $LN30@ExecuteWit
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@ExecuteWit:
	mov	DWORD PTR __$EHRec$[esp+148], 0

; 8577 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN67@ExecuteWit

; 8578 : 		{
; 8579 : 			// Compute moves to nearest city and use as sort criteria
; 8580 : 			pNearestCity = GC.getMap().findCity(pUnit->getX(), pUnit->getY(), m_pPlayer->GetID(), NO_TEAM, true /* bSameArea */);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR [edi+88]
	mov	edx, DWORD PTR [edi+76]
	push	0
	push	-1
	push	-1
	push	0
	push	1
	push	-1
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edx
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity

; 8581 : 			if(pNearestCity != NULL)

	test	eax, eax
	je	SHORT $LN67@ExecuteWit

; 8582 : 			{
; 8583 : 				iTurnsToReachTarget = TurnsToReachTarget(pUnit, pNearestCity->plot());

	push	0
	push	0
	push	0
	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T288567[esp+164], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget

; 8584 : 				m_CurrentMoveUnits[iI].SetMovesToTarget(iTurnsToReachTarget);

	mov	ecx, DWORD PTR [esi+24]
	add	ecx, ebp
	mov	DWORD PTR [ecx+12], eax

; 8585 : 				m_CurrentMoveUnits[iI].SetAttackStrength(1000-iTurnsToReachTarget);

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, 1000				; 000003e8H
	sub	edx, eax
	add	ecx, ebp
	mov	DWORD PTR [ecx+4], edx

; 8586 : 				m_CurrentMoveUnits[iI].SetHealthPercent(10,10);

	mov	eax, DWORD PTR [esi+24]
	add	esp, 24					; 00000018H
	add	eax, ebp
	mov	DWORD PTR [eax+8], 100			; 00000064H
$LN67@ExecuteWit:

; 8587 : #endif
; 8588 : 			}
; 8589 : 		}
; 8590 : 	}

	mov	DWORD PTR __$EHRec$[esp+148], -1
	test	edi, edi
	je	SHORT $LN10@ExecuteWit
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN10@ExecuteWit:
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	add	ebp, 24					; 00000018H
	cmp	ebx, eax
	jb	$LL11@ExecuteWit
$LN9@ExecuteWit:

; 8591 : 
; 8592 : 	// Sort units by distance to city so closest ones move first
; 8593 : 	std::stable_sort(m_CurrentMoveUnits.begin(), m_CurrentMoveUnits.end());

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, eax
	je	SHORT $LN86@ExecuteWit
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
	add	esp, 16					; 00000010H
$LN86@ExecuteWit:

; 8594 : 
; 8595 : 	// Execute the moves
; 8596 : #ifdef AUI_ITERATORIZE
; 8597 : 	for (std::vector<CvTacticalUnit>::iterator it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)
; 8598 : 	{
; 8599 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());
; 8600 : #else
; 8601 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	xor	ebx, ebx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _iI$224732[esp+140], ebx
	je	$LN4@ExecuteWit
	mov	DWORD PTR tv742[esp+140], ebx
$LL6@ExecuteWit:

; 8602 : 	{
; 8603 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$224736[esp+140], edi
	mov	BYTE PTR _pUnit$224736[esp+144], 0
	test	edi, edi
	je	SHORT $LN106@ExecuteWit
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN106@ExecuteWit:
	mov	DWORD PTR __$EHRec$[esp+148], 1

; 8604 : #endif
; 8605 : 		if(pUnit)

	test	edi, edi
	je	$LN1@ExecuteWit

; 8606 : 		{
; 8607 : 			// Compute moves to nearest city and use as sort criteria
; 8608 : 			pNearestCity = GC.getMap().findCity(pUnit->getX(), pUnit->getY(), m_pPlayer->GetID(), NO_TEAM, true /* bSameArea */);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [edi+88]
	mov	edx, DWORD PTR [edi+76]
	push	0
	push	-1
	push	-1
	push	0
	push	1
	push	-1
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edx
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	ebp, eax

; 8609 : 			if(pNearestCity != NULL)

	test	ebp, ebp
	je	$LN1@ExecuteWit

; 8610 : 			{
; 8611 : 				MoveToEmptySpaceNearTarget(pUnit, pNearestCity->plot(), (pUnit->getDomainType()==DOMAIN_LAND));

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	sete	al
	movzx	ecx, al
	push	ecx
	mov	ecx, ebp
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T288570[esp+156], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, esi
	call	?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::MoveToEmptySpaceNearTarget

; 8612 : 
; 8613 : 				pUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 8614 : #ifdef AUI_ITERATORIZE
; 8615 : 				UnitProcessed(it->GetID(), pUnit->IsCombatUnit());
; 8616 : #else
; 8617 : 				UnitProcessed(m_CurrentMoveUnits[iI].GetID(), pUnit->IsCombatUnit());

	cmp	DWORD PTR [edi+1044], 0
	mov	edx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ebx+edx]
	setg	cl
	movzx	edx, cl
	push	edx
	push	eax
	mov	ecx, esi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 8618 : #endif
; 8619 : 
; 8620 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteWit
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteWit

; 8621 : 				{
; 8622 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$224741[esp+140]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 8623 : 					strLogString.Format("%s withdrew toward %s, Current X: %d, Current Y: %d", pUnit->getName().GetCString(), pNearestCity->getName().GetCString(),
; 8624 : 					                    pUnit->getX(), pUnit->getY());

	lea	eax, DWORD PTR $T288571[esp+140]
	push	eax
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+152], 2
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	ebp, eax
	lea	ecx, DWORD PTR $T288572[esp+140]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+152], 3
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ebx, eax
	mov	edx, DWORD PTR [edi+88]
	mov	eax, DWORD PTR [edi+76]
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+148], 4
	mov	DWORD PTR $T288859[esp+140], edx
	mov	DWORD PTR $T288872[esp+140], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR $T288859[esp+140]
	mov	edx, DWORD PTR $T288872[esp+140]
	push	ecx
	push	edx
	push	eax
	mov	ecx, ebx
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$224741[esp+156]
	push	OFFSET $SG224744
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR $T288572[esp+140]
	mov	BYTE PTR __$EHRec$[esp+148], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T288571[esp+140]
	mov	BYTE PTR __$EHRec$[esp+148], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 8625 : 					LogTacticalMessage(strLogString, false);

	push	0
	lea	ecx, DWORD PTR _strLogString$224741[esp+144]
	push	ecx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 8626 : 				}

	lea	ecx, DWORD PTR _strLogString$224741[esp+140]
	mov	BYTE PTR __$EHRec$[esp+148], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebx, DWORD PTR tv742[esp+140]
$LN1@ExecuteWit:

; 8627 : 			}
; 8628 : 		}
; 8629 : 	}

	mov	DWORD PTR __$EHRec$[esp+148], -1
	test	edi, edi
	je	SHORT $LN5@ExecuteWit
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@ExecuteWit:
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	edi, DWORD PTR _iI$224732[esp+140]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	edi
	add	ebx, 24					; 00000018H
	add	eax, edx
	mov	DWORD PTR _iI$224732[esp+140], edi
	mov	DWORD PTR tv742[esp+140], ebx
	cmp	edi, eax
	jb	$LL6@ExecuteWit
$LN4@ExecuteWit:

; 8630 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+140]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 124				; 0000007cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$224721[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _pUnit$224736[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$224741[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR $T288571[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T288572[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::ExecuteWithdrawMoves
PUBLIC	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
EXTRN	?canPillage@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canPillage
EXTRN	?IsCityAttackOnly@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCityAttackOnly
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z$0
__ehfuncinfo$?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z
_TEXT	SEGMENT
_rtnValue$ = -62					; size = 1
_bIsCityTarget$ = -61					; size = 1
_iTurnsCalculated$224895 = -60				; size = 4
_this$ = -56						; size = 4
$T289127 = -52						; size = 1
_it$ = -52						; size = 4
$T288932 = -48						; size = 4
$T288931 = -48						; size = 4
$T288930 = -48						; size = 4
$T288929 = -48						; size = 4
$T288928 = -48						; size = 4
_pLoopUnit$ = -44					; size = 8
_unit$224922 = -36					; size = 24
_unit$224918 = -36					; size = 24
_unit$224912 = -36					; size = 24
_unit$224907 = -36					; size = 24
_unit$224898 = -36					; size = 24
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
_iNumTurnsAway$ = 12					; size = 4
_iPreferredDamageLevel$ = 16				; size = 4
_bNoRangedUnits$ = 20					; size = 1
_bNavalOnly$ = 24					; size = 1
_bMustMoveThrough$ = 28					; size = 1
_bIncludeBlockedUnits$ = 32				; size = 1
__Cat$289131 = 36					; size = 1
$T289129 = 36						; size = 1
_bWillPillage$ = 36					; size = 1
_bTargetUndefended$ = 40				; size = 1
?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z PROC ; CvTacticalAI::FindUnitsWithinStrikingDistance, COMDAT
; _this$ = ecx

; 8855 : {

	push	-1
	push	__ehhandler$?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 8856 : 	list<int>::iterator it;
; 8857 : 	UnitHandle pLoopUnit;

	xor	ebx, ebx
	xor	edi, edi
	mov	DWORD PTR _this$[esp+80], esi
	mov	DWORD PTR _pLoopUnit$[esp+80], edi
	mov	BYTE PTR _pLoopUnit$[esp+84], bl

; 8858 : 
; 8859 : 	bool rtnValue = false;
; 8860 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+24]
	lea	ebp, DWORD PTR [esi+20]
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	mov	BYTE PTR _rtnValue$[esp+80], bl
	cmp	ecx, eax
	je	SHORT $LN58@FindUnitsW
	mov	BYTE PTR $T289127[esp+80], bl
	mov	edx, DWORD PTR $T289127[esp+80]
	push	edx
	mov	edx, DWORD PTR __Cat$289131[esp+80]
	push	edx
	mov	edx, DWORD PTR $T289129[esp+84]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebp+8], eax
$LN58@FindUnitsW:

; 8861 : 
; 8862 : 	bool bIsCityTarget = pTarget->getPlotCity() != NULL;

	mov	ecx, DWORD PTR _pTarget$[esp+76]
	mov	eax, DWORD PTR [ecx+104]
	cmp	eax, ebx
	jl	SHORT $LN83@FindUnitsW
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN83@FindUnitsW
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN84@FindUnitsW
$LN83@FindUnitsW:
	xor	eax, eax
$LN84@FindUnitsW:
	cmp	eax, ebx

; 8863 : 
; 8864 : 	// Loop through all units available to tactical AI this turn
; 8865 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 8866 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 8867 : #else
; 8868 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax]
	setne	BYTE PTR _bIsCityTarget$[esp+80]
	mov	DWORD PTR _it$[esp+80], ecx
	cmp	ecx, eax
	je	$LN27@FindUnitsW
	jmp	SHORT $LN100@FindUnitsW
	npad	7
$LL305@FindUnitsW:
	mov	ecx, DWORD PTR _it$[esp+80]
	mov	esi, DWORD PTR _this$[esp+80]
$LN100@FindUnitsW:

; 8869 : #endif
; 8870 : 	{
; 8871 : 		pLoopUnit = m_pPlayer->getUnit(*it);

	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	cmp	edi, ebx
	je	SHORT $LN124@FindUnitsW
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN124@FindUnitsW:
	mov	DWORD PTR _pLoopUnit$[esp+80], esi
	cmp	esi, ebx
	je	$LN28@FindUnitsW
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 8872 : 		if(pLoopUnit)
; 8873 : 		{
; 8874 : 			if(!bNavalOnly || pLoopUnit->getDomainType() == DOMAIN_SEA)

	cmp	BYTE PTR _bNavalOnly$[esp+76], bl
	je	SHORT $LN24@FindUnitsW
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	$LN28@FindUnitsW
$LN24@FindUnitsW:

; 8875 : 			{
; 8876 : 				// don't use non-combat units
; 8877 : 				if(!pLoopUnit->IsCanAttack())

	mov	ecx, esi
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	test	al, al
	je	$LN28@FindUnitsW

; 8878 : 				{
; 8879 : 					continue;
; 8880 : 				}
; 8881 : 
; 8882 : 				if(pLoopUnit->isOutOfAttacks())

	mov	ecx, esi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	jne	$LN28@FindUnitsW

; 8883 : 				{
; 8884 : 					continue;
; 8885 : 				}
; 8886 : 
; 8887 : 				if (!bIsCityTarget && pLoopUnit->IsCityAttackOnly())

	cmp	BYTE PTR _bIsCityTarget$[esp+80], bl
	jne	SHORT $LN21@FindUnitsW
	mov	ecx, esi
	call	?IsCityAttackOnly@CvUnit@@QBE_NXZ	; CvUnit::IsCityAttackOnly
	test	al, al
	jne	$LN28@FindUnitsW
$LN21@FindUnitsW:

; 8888 : 				{
; 8889 : 					continue;
; 8890 : 				}
; 8891 : 
; 8892 : 				if (bWillPillage && !pLoopUnit->canPillage(pTarget))

	cmp	BYTE PTR _bWillPillage$[esp+76], bl
	je	SHORT $LN20@FindUnitsW
	mov	eax, DWORD PTR _pTarget$[esp+76]
	push	eax
	mov	ecx, esi
	call	?canPillage@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canPillage
	test	al, al
	je	$LN28@FindUnitsW
$LN20@FindUnitsW:

; 8893 : 				{
; 8894 : 					continue;
; 8895 : 				}
; 8896 : 
; 8897 : 				int iAttackStrength = pLoopUnit->GetMaxAttackStrength(NULL, NULL, NULL);

	push	ebx
	push	ebx
	push	ebx
	mov	ecx, esi
	call	?GetMaxAttackStrength@CvUnit@@QBEHPBVCvPlot@@0PBV1@@Z ; CvUnit::GetMaxAttackStrength

; 8898 : 
; 8899 : 				// Looking for damaged units?  If so, recalculate attack strength
; 8900 : 				if (iPreferredDamageLevel > 0)

	cmp	DWORD PTR _iPreferredDamageLevel$[esp+76], ebx
	mov	edi, eax
	jle	SHORT $LN18@FindUnitsW

; 8901 : 				{
; 8902 : 					int iDamage = pLoopUnit->getDamage();

	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage

; 8903 : 					if (iDamage > iPreferredDamageLevel)

	cmp	eax, DWORD PTR _iPreferredDamageLevel$[esp+76]
	jle	SHORT $LN18@FindUnitsW

; 8904 : 					{
; 8905 : 						iAttackStrength *= 3;

	lea	edi, DWORD PTR [edi+edi*2]
$LN18@FindUnitsW:

; 8906 : 					}
; 8907 : 				}
; 8908 : 
; 8909 : 				int iTurnsCalculated = -1;	// If CanReachInXTurns does an actual pathfind, save the result so we don't just do the same one again.

	or	eax, -1
	mov	DWORD PTR _iTurnsCalculated$224895[esp+80], eax

; 8910 : 				if (bTargetUndefended && CanReachInXTurns(pLoopUnit, pTarget, iNumTurnsAway, false /*bIgnoreUnits*/, &iTurnsCalculated))

	cmp	BYTE PTR _bTargetUndefended$[esp+76], bl
	je	SHORT $LN17@FindUnitsW
	mov	edx, DWORD PTR _iNumTurnsAway$[esp+76]
	mov	eax, DWORD PTR _pTarget$[esp+76]
	lea	ecx, DWORD PTR _iTurnsCalculated$224895[esp+80]
	push	ecx
	push	ebx
	push	edx
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T288928[esp+104], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], bl
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	cmp	al, bl
	je	SHORT $LN302@FindUnitsW

; 8911 : 				{
; 8912 : 					CvTacticalUnit unit;
; 8913 : 					unit.SetID(pLoopUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]

; 8914 : 					unit.SetAttackStrength(iAttackStrength / 2);

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	DWORD PTR _unit$224898[esp+80], ecx
	sar	eax, 1

; 8915 : 					unit.SetHealthPercent(pLoopUnit->GetCurrHitPoints(), pLoopUnit->GetMaxHitPoints());

	mov	ecx, esi
	mov	DWORD PTR _unit$224898[esp+92], ebx
	mov	DWORD PTR _unit$224898[esp+96], ebx
	mov	DWORD PTR _unit$224898[esp+100], ebx
	mov	DWORD PTR _unit$224898[esp+84], eax
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	mov	ecx, esi
	mov	edi, eax
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	imul	eax, 100				; 00000064H
	cdq
	idiv	edi

; 8916 : 					m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$224898[esp+80]
	push	edx

; 8917 : 					rtnValue = true;

	jmp	$LN310@FindUnitsW
$LN302@FindUnitsW:
	mov	eax, DWORD PTR _iTurnsCalculated$224895[esp+80]
$LN17@FindUnitsW:

; 8918 : 				}
; 8919 : 
; 8920 : 				else if(!bNoRangedUnits && !bWillPillage && pLoopUnit->IsCanAttackRanged())

	cmp	BYTE PTR _bNoRangedUnits$[esp+76], bl
	jne	$LN15@FindUnitsW
	cmp	BYTE PTR _bWillPillage$[esp+76], bl
	jne	$LN15@FindUnitsW
	mov	ecx, esi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	$LN303@FindUnitsW

; 8921 : 				{
; 8922 : 					// Don't use air units for air strikes if at or below half health
; 8923 : 					if (pLoopUnit->getDomainType() != DOMAIN_AIR || (pLoopUnit->getDamage() * 2) < GC.getMAX_HIT_POINTS())

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN13@FindUnitsW
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, eax
	cmp	eax, edi
	jge	$LN28@FindUnitsW
$LN13@FindUnitsW:

; 8924 : 					{
; 8925 : 						// Are we in range?
; 8926 : 						if(plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pTarget->getX(), pTarget->getY()) <= pLoopUnit->GetRange())

	mov	ecx, DWORD PTR _pTarget$[esp+76]
	movsx	eax, WORD PTR [ecx+2]
	movsx	ecx, WORD PTR [ecx]
	mov	edx, DWORD PTR [esi+88]
	mov	edi, DWORD PTR [esi+76]
	push	eax
	push	ecx
	push	edx
	push	edi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	ecx, esi
	mov	edi, eax
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	cmp	edi, eax
	jg	$LN28@FindUnitsW

; 8927 : 						{
; 8928 : 							// Do we have LOS to the target?
; 8929 : 							if(pLoopUnit->canEverRangeStrikeAt(pTarget->getX(), pTarget->getY()))

	mov	ecx, DWORD PTR _pTarget$[esp+76]
	movsx	eax, WORD PTR [ecx+2]
	movsx	ecx, WORD PTR [ecx]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?canEverRangeStrikeAt@CvUnit@@QBE_NHH@Z	; CvUnit::canEverRangeStrikeAt
	test	al, al
	je	$LN28@FindUnitsW

; 8930 : 							{
; 8931 : 								// Will we do any damage
; 8932 : 								if(IsExpectedToDamageWithRangedAttack(pLoopUnit, pTarget))

	mov	eax, DWORD PTR _pTarget$[esp+76]
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pLoopUnit$[esp+92]
	mov	ecx, esp
	mov	DWORD PTR $T288929[esp+92], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, DWORD PTR _this$[esp+92]
	call	?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z ; CvTacticalAI::IsExpectedToDamageWithRangedAttack
	cmp	al, bl
	je	$LN28@FindUnitsW

; 8933 : 								{
; 8934 : 									CvTacticalUnit unit;
; 8935 : 									unit.SetID(pLoopUnit->GetID());

	mov	eax, DWORD PTR [esi+100]

; 8936 : 
; 8937 : 									// Want ranged units to attack first, so inflate this
; 8938 : 									unit.SetAttackStrength(100 * pLoopUnit->GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true));

	push	1
	push	1
	push	ebx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR _unit$224907[esp+108], ebx
	mov	DWORD PTR _unit$224907[esp+112], ebx
	mov	DWORD PTR _unit$224907[esp+116], ebx
	mov	DWORD PTR _unit$224907[esp+96], eax
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength
	imul	eax, 100				; 00000064H

; 8939 : 									unit.SetHealthPercent(100, 100);  // Don't take damage from bombarding, so show as fully healthy
; 8940 : 									m_CurrentMoveUnits.push_back(unit);

	lea	ecx, DWORD PTR _unit$224907[esp+80]
	mov	DWORD PTR _unit$224907[esp+84], eax
	mov	DWORD PTR _unit$224907[esp+88], 100	; 00000064H
	push	ecx

; 8941 : 									rtnValue = true;
; 8942 : 								}
; 8943 : 							}
; 8944 : 						}
; 8945 : 					}
; 8946 : 				}
; 8947 : 				else

	jmp	$LN311@FindUnitsW
$LN303@FindUnitsW:
	mov	eax, DWORD PTR _iTurnsCalculated$224895[esp+80]
$LN15@FindUnitsW:

; 8948 : 				{
; 8949 : 					if (bMustMoveThrough && (iTurnsCalculated == 0 || (iTurnsCalculated == -1 && CanReachInXTurns(pLoopUnit, pTarget, 0, false /*bIgnoreUnits*/, &iTurnsCalculated))))

	cmp	BYTE PTR _bMustMoveThrough$[esp+76], bl
	je	SHORT $LN8@FindUnitsW
	cmp	eax, ebx
	je	SHORT $LN7@FindUnitsW
	cmp	eax, -1
	jne	SHORT $LN300@FindUnitsW
	mov	eax, DWORD PTR _pTarget$[esp+76]
	lea	edx, DWORD PTR _iTurnsCalculated$224895[esp+80]
	push	edx
	push	ebx
	push	ebx
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pLoopUnit$[esp+104]
	mov	ecx, esp
	mov	DWORD PTR $T288930[esp+104], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	cmp	al, bl
	je	SHORT $LN304@FindUnitsW
$LN7@FindUnitsW:

; 8950 : 					{
; 8951 : 						CvTacticalUnit unit;
; 8952 : 						unit.SetID(pLoopUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR _unit$224912[esp+80], eax

; 8953 : 						unit.SetAttackStrength(iAttackStrength);

	mov	DWORD PTR _unit$224912[esp+84], edi

; 8954 : 						unit.SetHealthPercent(pLoopUnit->GetCurrHitPoints(), pLoopUnit->GetMaxHitPoints());
; 8955 : 						m_CurrentMoveUnits.push_back(unit);
; 8956 : 						rtnValue = true;

	jmp	$LN312@FindUnitsW
$LN304@FindUnitsW:
	mov	eax, DWORD PTR _iTurnsCalculated$224895[esp+80]
$LN8@FindUnitsW:

; 8957 : 					}
; 8958 : 
; 8959 : 					else if ( (iTurnsCalculated != -1 && iTurnsCalculated <= iNumTurnsAway) || (iTurnsCalculated == -1 && CanReachInXTurns(pLoopUnit, pTarget, iNumTurnsAway, false /*bIgnoreUnits*/)) )

	cmp	eax, -1
	je	SHORT $LN299@FindUnitsW
$LN300@FindUnitsW:
	cmp	eax, DWORD PTR _iNumTurnsAway$[esp+76]
	jle	SHORT $LN4@FindUnitsW
	cmp	eax, -1
	jne	SHORT $LN5@FindUnitsW
$LN299@FindUnitsW:
	mov	edx, DWORD PTR _iNumTurnsAway$[esp+76]
	mov	eax, DWORD PTR _pTarget$[esp+76]
	push	ebx
	push	ebx
	push	edx
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pLoopUnit$[esp+104]
	mov	ecx, esp
	mov	DWORD PTR $T288931[esp+104], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	cmp	al, bl
	je	SHORT $LN5@FindUnitsW
$LN4@FindUnitsW:

; 8960 : 					{
; 8961 : 						CvTacticalUnit unit;
; 8962 : 						unit.SetID(pLoopUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR _unit$224918[esp+80], eax

; 8963 : 						unit.SetAttackStrength(iAttackStrength);

	mov	DWORD PTR _unit$224918[esp+84], edi

; 8964 : 						unit.SetHealthPercent(pLoopUnit->GetCurrHitPoints(), pLoopUnit->GetMaxHitPoints());
; 8965 : 						m_CurrentMoveUnits.push_back(unit);
; 8966 : 						rtnValue = true;

	jmp	SHORT $LN312@FindUnitsW
$LN5@FindUnitsW:

; 8967 : 					}
; 8968 : 
; 8969 : 					// Units that can make it when others get out of the way are also potentially useful, but give them half priority so they bring up the rear
; 8970 : 					else if (bIncludeBlockedUnits && CanReachInXTurns(pLoopUnit, pTarget, iNumTurnsAway, true /*bIgnoreUnits*/))

	cmp	BYTE PTR _bIncludeBlockedUnits$[esp+76], bl
	je	SHORT $LN28@FindUnitsW
	mov	edx, DWORD PTR _iNumTurnsAway$[esp+76]
	mov	eax, DWORD PTR _pTarget$[esp+76]
	push	ebx
	push	1
	push	edx
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pLoopUnit$[esp+104]
	mov	ecx, esp
	mov	DWORD PTR $T288932[esp+104], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	cmp	al, bl
	je	SHORT $LN28@FindUnitsW

; 8971 : 					{
; 8972 : 						CvTacticalUnit unit;
; 8973 : 						unit.SetID(pLoopUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR _unit$224922[esp+80], eax

; 8974 : 						unit.SetAttackStrength(iAttackStrength / 2);

	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _unit$224922[esp+84], eax
$LN312@FindUnitsW:

; 8975 : 						unit.SetHealthPercent(pLoopUnit->GetCurrHitPoints(), pLoopUnit->GetMaxHitPoints());

	mov	ecx, esi
	mov	DWORD PTR _unit$224922[esp+92], ebx
	mov	DWORD PTR _unit$224922[esp+96], ebx
	mov	DWORD PTR _unit$224922[esp+100], ebx
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	mov	ecx, esi
	mov	edi, eax
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	imul	eax, 100				; 00000064H
	cdq

; 8976 : 						m_CurrentMoveUnits.push_back(unit);

	lea	ecx, DWORD PTR _unit$224922[esp+80]
	idiv	edi
	push	ecx
$LN310@FindUnitsW:

; 8975 : 						unit.SetHealthPercent(pLoopUnit->GetCurrHitPoints(), pLoopUnit->GetMaxHitPoints());

	mov	DWORD PTR _unit$224922[esp+92], eax
$LN311@FindUnitsW:

; 8976 : 						m_CurrentMoveUnits.push_back(unit);

	mov	ecx, ebp
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back

; 8977 : 						rtnValue = true;

	mov	BYTE PTR _rtnValue$[esp+80], 1
$LN28@FindUnitsW:
	mov	edx, DWORD PTR _it$[esp+80]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[esp+80]
	mov	edi, DWORD PTR _pLoopUnit$[esp+80]
	mov	DWORD PTR _it$[esp+80], eax
	cmp	eax, DWORD PTR [ecx+12]
	jne	$LL305@FindUnitsW

; 8863 : 
; 8864 : 	// Loop through all units available to tactical AI this turn
; 8865 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 8866 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 8867 : #else
; 8868 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	esi, ecx
$LN27@FindUnitsW:

; 8978 : 					}
; 8979 : 				}
; 8980 : 			}
; 8981 : 		}
; 8982 : 	}
; 8983 : 
; 8984 : 	// Now sort them in the order we'd like them to attack
; 8985 : 	std::stable_sort(m_CurrentMoveUnits.begin(), m_CurrentMoveUnits.end());

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, eax
	je	SHORT $LN281@FindUnitsW
	push	ebx
	push	ebx
	push	eax
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
	add	esp, 16					; 00000010H
$LN281@FindUnitsW:

; 8986 : 
; 8987 : 	return rtnValue;

	mov	DWORD PTR __$EHRec$[esp+88], -1
	cmp	edi, ebx
	je	SHORT $LN301@FindUnitsW
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN301@FindUnitsW:

; 8988 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	al, BYTE PTR _rtnValue$[esp+80]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 64					; 00000040H
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ENDP ; CvTacticalAI::FindUnitsWithinStrikingDistance
PUBLIC	?FindCitiesWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z ; CvTacticalAI::FindCitiesWithinStrikingDistance
EXTRN	?canRangeStrikeAt@CvCity@@QBE_NHH@Z:PROC	; CvCity::canRangeStrikeAt
; Function compile flags: /Ogtpy
;	COMDAT ?FindCitiesWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_iLoop$ = -20						; size = 4
$T289675 = -16						; size = 4
_city$224942 = -12					; size = 12
_pTargetPlot$ = 8					; size = 4
?FindCitiesWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z PROC ; CvTacticalAI::FindCitiesWithinStrikingDistance, COMDAT
; _this$ = ecx

; 8992 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 8993 : #ifndef AUI_WARNING_FIXES
; 8994 : 	list<int>::iterator it;
; 8995 : #endif
; 8996 : 	CvCity* pLoopCity;
; 8997 : 	int iLoop;
; 8998 : 
; 8999 : 	bool rtnValue = false;
; 9000 : 	m_CurrentMoveCities.clear();

	mov	eax, DWORD PTR [edi+60]
	mov	ecx, DWORD PTR [edi+56]
	lea	ebp, DWORD PTR [edi+52]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T289675[esp+44]
	push	eax
	mov	ecx, ebp
	xor	bl, bl
	call	?erase@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::erase

; 9001 : 
; 9002 : 	// Loop through all of our cities
; 9003 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN2@FindCities
	npad	10
$LL4@FindCities:

; 9004 : 	{
; 9005 : 		if(pLoopCity->canRangeStrikeAt(pTargetPlot->getX(), pTargetPlot->getY()) && !IsCityInQueuedAttack(pLoopCity))

	mov	ecx, DWORD PTR _pTargetPlot$[esp+32]
	movsx	eax, WORD PTR [ecx+2]
	movsx	ecx, WORD PTR [ecx]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?canRangeStrikeAt@CvCity@@QBE_NHH@Z	; CvCity::canRangeStrikeAt
	test	al, al
	je	SHORT $LN3@FindCities
	xor	edx, edx
	cmp	DWORD PTR [edi+2144], edx
	jbe	SHORT $LN30@FindCities
	mov	ecx, DWORD PTR [edi+2140]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, ecx
	je	SHORT $LN30@FindCities
	npad	2
$LL54@FindCities:
	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LN31@FindCities
	cmp	DWORD PTR [eax+8], esi
	je	SHORT $LN3@FindCities
$LN31@FindCities:
	mov	eax, DWORD PTR [eax]
	cmp	eax, ecx
	jne	SHORT $LL54@FindCities
$LN30@FindCities:

; 9006 : 		{
; 9007 : 			CvTacticalCity city;

	mov	DWORD PTR _city$224942[esp+40], edx
	mov	DWORD PTR _city$224942[esp+44], edx

; 9008 : 			city.SetID(pLoopCity->GetID());

	mov	edx, DWORD PTR [esi+120]

; 9009 : 			m_CurrentMoveCities.push_back(city);

	lea	eax, DWORD PTR _city$224942[esp+36]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR _city$224942[esp+40], edx
	call	?push_back@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAEXABVCvTacticalCity@@@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::push_back

; 9010 : 			rtnValue = true;

	mov	bl, 1
$LN3@FindCities:
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL4@FindCities
$LN2@FindCities:

; 9011 : 		}
; 9012 : 	}
; 9013 : 
; 9014 : 	// Now sort them in the order we'd like them to attack
; 9015 : 	std::stable_sort(m_CurrentMoveCities.begin(), m_CurrentMoveCities.end());

	mov	eax, DWORD PTR [edi+60]
	mov	edi, DWORD PTR [edi+56]
	cmp	edi, eax
	je	SHORT $LN125@FindCities
	push	0
	push	0
	push	eax
	push	edi
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@HVCvTacticalCity@@@std@@YAXV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@0@0PAHPAVCvTacticalCity@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalCity,std::allocator<CvTacticalCity> >,int,CvTacticalCity>
	add	esp, 16					; 00000010H
$LN125@FindCities:
	pop	edi
	pop	esi
	pop	ebp

; 9016 : 
; 9017 : 	return rtnValue;

	mov	al, bl
	pop	ebx

; 9018 : }

	add	esp, 20					; 00000014H
	ret	4
?FindCitiesWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z ENDP ; CvTacticalAI::FindCitiesWithinStrikingDistance
_TEXT	ENDS
PUBLIC	?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z ; CvTacticalAI::FindParatroopersWithinStrikingDistance
EXTRN	?canParadropAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z:PROC ; CvUnit::canParadropAt
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z$0
__ehfuncinfo$?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_rtnValue$ = -49					; size = 1
$T290184 = -48						; size = 1
_it$ = -48						; size = 4
_pLoopUnit$ = -44					; size = 8
_unit$225115 = -36					; size = 24
__$EHRec$ = -12						; size = 12
__Cat$290188 = 8					; size = 1
$T290186 = 8						; size = 1
_pTarget$ = 8						; size = 4
?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z PROC ; CvTacticalAI::FindParatroopersWithinStrikingDistance, COMDAT
; _this$ = ecx

; 9023 : {

	push	-1
	push	__ehhandler$?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	push	edi

; 9024 : 	list<int>::iterator it;
; 9025 : 	UnitHandle pLoopUnit;

	xor	edi, edi
	mov	ebp, ecx
	mov	DWORD PTR _pLoopUnit$[esp+64], edi
	mov	BYTE PTR _pLoopUnit$[esp+68], 0

; 9026 : 
; 9027 : 	bool rtnValue = false;
; 9028 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR [ebp+24]
	lea	ebx, DWORD PTR [ebp+20]
	mov	DWORD PTR __$EHRec$[esp+72], edi
	mov	BYTE PTR _rtnValue$[esp+64], 0
	cmp	ecx, eax
	je	SHORT $LN28@FindParatr
	mov	BYTE PTR $T290184[esp+64], 0
	mov	edx, DWORD PTR $T290184[esp+64]
	push	edx
	mov	edx, DWORD PTR __Cat$290188[esp+64]
	push	edx
	mov	edx, DWORD PTR $T290186[esp+68]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebx+8], eax
$LN28@FindParatr:

; 9029 : 
; 9030 : 	// Loop through all units available to tactical AI this turn
; 9031 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 9032 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 9033 : #else
; 9034 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	ecx, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _it$[esp+64], eax
	cmp	eax, ecx
	je	$LN2@FindParatr
	push	esi
	jmp	SHORT $LN65@FindParatr
$LL154@FindParatr:
	mov	eax, DWORD PTR _it$[esp+68]
$LN65@FindParatr:

; 9035 : #endif
; 9036 : 	{
; 9037 : 		pLoopUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	test	edi, edi
	je	SHORT $LN89@FindParatr
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN89@FindParatr:
	mov	DWORD PTR _pLoopUnit$[esp+68], esi
	test	esi, esi
	je	SHORT $LN3@FindParatr
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 9038 : 		if(pLoopUnit && pLoopUnit->canParadropAt(pLoopUnit->plot(), pTarget->getX(), pTarget->getY()))

	mov	ecx, DWORD PTR _pTarget$[esp+64]
	movsx	eax, WORD PTR [ecx+2]
	movsx	ecx, WORD PTR [ecx]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?canParadropAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canParadropAt
	test	al, al
	je	SHORT $LN3@FindParatr

; 9039 : 		{
; 9040 : 			CvTacticalUnit unit;
; 9041 : 			unit.SetID(pLoopUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]
	xor	eax, eax

; 9042 : 			unit.SetAttackStrength(pLoopUnit->GetMaxAttackStrength(NULL, NULL, NULL));

	push	eax
	push	eax
	mov	DWORD PTR _unit$225115[esp+76], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _unit$225115[esp+92], eax
	mov	DWORD PTR _unit$225115[esp+96], eax
	mov	DWORD PTR _unit$225115[esp+100], eax
	call	?GetMaxAttackStrength@CvUnit@@QBEHPBVCvPlot@@0PBV1@@Z ; CvUnit::GetMaxAttackStrength

; 9043 : 			unit.SetHealthPercent(pLoopUnit->GetCurrHitPoints(), pLoopUnit->GetMaxHitPoints());

	mov	ecx, esi
	mov	DWORD PTR _unit$225115[esp+72], eax
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	mov	ecx, esi
	mov	edi, eax
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	imul	eax, 100				; 00000064H
	cdq
	idiv	edi

; 9044 : 			m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225115[esp+68]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR _unit$225115[esp+80], eax
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back

; 9045 : 			rtnValue = true;

	mov	BYTE PTR _rtnValue$[esp+68], 1
$LN3@FindParatr:
	mov	eax, DWORD PTR _it$[esp+68]
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR _pLoopUnit$[esp+68]
	mov	DWORD PTR _it$[esp+68], eax
	cmp	eax, DWORD PTR [ebp+12]
	jne	$LL154@FindParatr
	pop	esi
$LN2@FindParatr:

; 9046 : 		}
; 9047 : 	}
; 9048 : 
; 9049 : 	// Now sort them in the order we'd like them to attack
; 9050 : 	std::stable_sort(m_CurrentMoveUnits.begin(), m_CurrentMoveUnits.end());

	mov	eax, DWORD PTR [ebp+28]
	mov	ebp, DWORD PTR [ebp+24]
	cmp	ebp, eax
	je	SHORT $LN155@FindParatr
	push	0
	push	0
	push	eax
	push	ebp
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
	add	esp, 16					; 00000010H
$LN155@FindParatr:

; 9051 : 
; 9052 : 	return rtnValue;

	mov	DWORD PTR __$EHRec$[esp+72], -1
	test	edi, edi
	je	SHORT $LN153@FindParatr
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN153@FindParatr:

; 9053 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	mov	al, BYTE PTR _rtnValue$[esp+64]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z ENDP ; CvTacticalAI::FindParatroopersWithinStrikingDistance
PUBLIC	?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z ; CvTacticalAI::FindClosestUnit
EXTRN	?IsRangeAttackIgnoreLOS@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsRangeAttackIgnoreLOS
EXTRN	?GetCombat@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetCombat
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z$0
__ehfuncinfo$?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z
_TEXT	SEGMENT
_rtnValue$ = -57					; size = 1
_this$ = -56						; size = 4
$T290644 = -52						; size = 1
_it$ = -52						; size = 4
$T290446 = -48						; size = 4
_pLoopUnit$ = -44					; size = 8
_unit$225176 = -36					; size = 24
__$EHRec$ = -12						; size = 12
$T290447 = 8						; size = 4
_bValidUnit$225145 = 8					; size = 1
_pTarget$ = 8						; size = 4
_iNumTurnsAway$ = 12					; size = 4
_bMustHaveHalfHP$ = 16					; size = 1
__Cat$290648 = 20					; size = 1
$T290646 = 20						; size = 1
_bMustBeRangedUnit$ = 20				; size = 1
_iRangeRequired$ = 24					; size = 4
_bNeedsIgnoreLOS$ = 28					; size = 1
_bMustBeMeleeUnit$ = 32					; size = 1
_bIgnoreUnits$ = 36					; size = 1
_pRangedAttackTarget$ = 40				; size = 4
?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z PROC ; CvTacticalAI::FindClosestUnit, COMDAT
; _this$ = ecx

; 9058 : {

	push	-1
	push	__ehhandler$?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 9059 : 	list<int>::iterator it;
; 9060 : 	UnitHandle pLoopUnit;

	xor	ebx, ebx
	xor	esi, esi
	push	edi
	mov	DWORD PTR _this$[esp+76], ebp
	mov	DWORD PTR _pLoopUnit$[esp+76], esi
	mov	BYTE PTR _pLoopUnit$[esp+80], bl

; 9061 : 
; 9062 : 	bool rtnValue = false;
; 9063 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR __$EHRec$[esp+84], ebx
	mov	BYTE PTR _rtnValue$[esp+76], bl
	cmp	ecx, eax
	je	SHORT $LN56@FindCloses
	mov	BYTE PTR $T290644[esp+76], bl
	mov	edx, DWORD PTR $T290644[esp+76]
	push	edx
	mov	edx, DWORD PTR __Cat$290648[esp+76]
	push	edx
	mov	edx, DWORD PTR $T290646[esp+80]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebp+28], eax
$LN56@FindCloses:

; 9064 : 
; 9065 : 	// Loop through all units available to tactical AI this turn
; 9066 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 9067 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 9068 : #else
; 9069 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _it$[esp+76], ecx
	cmp	ecx, eax
	je	$LN28@FindCloses
	mov	edi, DWORD PTR _pTarget$[esp+72]
	jmp	SHORT $LN93@FindCloses
	npad	8
$LL243@FindCloses:
	mov	ecx, DWORD PTR _it$[esp+76]
$LN93@FindCloses:

; 9070 : #endif
; 9071 : 	{
; 9072 : 		pLoopUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ecx, DWORD PTR _pLoopUnit$[esp+76]
	mov	esi, eax
	cmp	ecx, ebx
	je	SHORT $LN117@FindCloses
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN117@FindCloses:
	mov	DWORD PTR _pLoopUnit$[esp+76], esi
	cmp	esi, ebx
	je	$LN29@FindCloses
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 9073 : 		if(pLoopUnit)
; 9074 : 		{
; 9075 : 			bool bValidUnit = true;
; 9076 : 
; 9077 : 			// don't use non-combat units (but consider embarked for now)
; 9078 : 			if(pLoopUnit->getUnitInfo().GetCombat() == 0)

	mov	ecx, esi
	mov	BYTE PTR _bValidUnit$225145[esp+72], 1
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetCombat@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetCombat
	test	eax, eax

; 9079 : 			{
; 9080 : 				bValidUnit = false;

	je	$LN249@FindCloses

; 9081 : 			}
; 9082 : 
; 9083 : 			else if (bMustHaveHalfHP && (pLoopUnit->getDamage() * 2 > GC.getMAX_HIT_POINTS()))

	cmp	BYTE PTR _bMustHaveHalfHP$[esp+72], bl
	je	SHORT $LN24@FindCloses
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	add	eax, eax
	cmp	eax, ebp

; 9084 : 			{
; 9085 : 				bValidUnit = false;
; 9086 : 			}
; 9087 : 
; 9088 : 			else if(bMustBeRangedUnit && ((pTarget->isWater() && pLoopUnit->getDomainType() == DOMAIN_LAND) ||

	jg	$LN249@FindCloses
$LN24@FindCloses:

; 9089 : 			                              (!pTarget->isWater() && !pTarget->isCity() && pLoopUnit->getDomainType() == DOMAIN_SEA)))

	cmp	BYTE PTR _bMustBeRangedUnit$[esp+72], bl
	je	$LN246@FindCloses
	cmp	BYTE PTR [edi+5], 3
	jne	SHORT $LN251@FindCloses
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	je	$LN249@FindCloses
	cmp	BYTE PTR [edi+5], 3
	je	SHORT $LN22@FindCloses
$LN251@FindCloses:
	mov	eax, DWORD PTR [edi+104]
	cmp	eax, ebx
	jl	SHORT $LN241@FindCloses
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN241@FindCloses
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	cmp	al, bl
	jne	SHORT $LN22@FindCloses
$LN241@FindCloses:
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax

; 9090 : 			{
; 9091 : 				bValidUnit = false;

	je	$LN249@FindCloses
$LN22@FindCloses:

; 9092 : 			}
; 9093 : 
; 9094 : 			else if(bMustBeRangedUnit && !pLoopUnit->IsCanAttackRanged())

	mov	ecx, esi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al

; 9095 : 			{
; 9096 : 				bValidUnit = false;

	je	$LN249@FindCloses

; 9097 : 			}
; 9098 : 
; 9099 : 			else if(bMustBeRangedUnit && pLoopUnit->GetRange() < iRangeRequired)

	mov	ecx, esi
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	cmp	eax, DWORD PTR _iRangeRequired$[esp+72]

; 9100 : 			{
; 9101 : 				bValidUnit = false;

	jl	SHORT $LN249@FindCloses

; 9102 : 			}
; 9103 : 
; 9104 : 			else if(bMustBeRangedUnit && !pLoopUnit->canEverRangeStrikeAt(pRangedAttackTarget->getX(), pRangedAttackTarget->getY()))

	mov	ebp, DWORD PTR _pRangedAttackTarget$[esp+72]
	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?canEverRangeStrikeAt@CvUnit@@QBE_NHH@Z	; CvUnit::canEverRangeStrikeAt
	test	al, al

; 9105 : 			{
; 9106 : 				bValidUnit = false;

	je	SHORT $LN249@FindCloses

; 9107 : 			}
; 9108 : 
; 9109 : 			else if(bMustBeRangedUnit && pLoopUnit->isOutOfAttacks())

	mov	ecx, esi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	je	SHORT $LN12@FindCloses

; 9110 : 			{
; 9111 : 				bValidUnit = false;

	jmp	SHORT $LN249@FindCloses
$LN246@FindCloses:
	mov	ebp, DWORD PTR _pRangedAttackTarget$[esp+72]
$LN12@FindCloses:

; 9112 : 			}
; 9113 : 
; 9114 : 			else if(pRangedAttackTarget != NULL && bMustBeRangedUnit && !IsExpectedToDamageWithRangedAttack(pLoopUnit, pRangedAttackTarget))

	cmp	ebp, ebx
	je	SHORT $LN10@FindCloses
	cmp	BYTE PTR _bMustBeRangedUnit$[esp+72], bl
	je	SHORT $LN10@FindCloses
	push	ebp
	sub	esp, 8
	lea	edx, DWORD PTR _pLoopUnit$[esp+88]
	mov	ecx, esp
	mov	DWORD PTR $T290446[esp+88], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, DWORD PTR _this$[esp+88]
	call	?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z ; CvTacticalAI::IsExpectedToDamageWithRangedAttack
	cmp	al, bl

; 9115 : 			{
; 9116 : 				bValidUnit = false;

	je	SHORT $LN249@FindCloses
$LN10@FindCloses:

; 9117 : 			}
; 9118 : 
; 9119 : 			else if(bNeedsIgnoreLOS && !pLoopUnit->IsRangeAttackIgnoreLOS())

	cmp	BYTE PTR _bNeedsIgnoreLOS$[esp+72], bl
	je	SHORT $LN8@FindCloses
	mov	ecx, esi
	call	?IsRangeAttackIgnoreLOS@CvUnit@@QBE_NXZ	; CvUnit::IsRangeAttackIgnoreLOS
	test	al, al

; 9120 : 			{
; 9121 : 				bValidUnit = false;

	je	SHORT $LN249@FindCloses
$LN8@FindCloses:

; 9122 : 			}
; 9123 : 
; 9124 : 			else if(bMustBeMeleeUnit && pLoopUnit->IsCanAttackRanged())

	cmp	BYTE PTR _bMustBeMeleeUnit$[esp+72], bl
	je	SHORT $LN6@FindCloses
	mov	ecx, esi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	SHORT $LN6@FindCloses
$LN249@FindCloses:

; 9125 : 			{
; 9126 : 				bValidUnit = false;

	mov	BYTE PTR _bValidUnit$225145[esp+72], bl
$LN6@FindCloses:

; 9127 : 			}
; 9128 : 
; 9129 : 			int iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pTarget->getX(), pTarget->getY());

	movsx	edx, WORD PTR [edi+2]
	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	edx
	movsx	edx, WORD PTR [edi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 9130 : 			if(iNumTurnsAway == 0 && iDistance > (m_iRecruitRange / 2) || iNumTurnsAway == 1 && iDistance > m_iRecruitRange)

	mov	ebp, DWORD PTR _iNumTurnsAway$[esp+88]
	add	esp, 16					; 00000010H
	mov	ecx, eax
	cmp	ebp, ebx
	jne	SHORT $LN3@FindCloses
	mov	eax, DWORD PTR _this$[esp+76]
	mov	eax, DWORD PTR [eax+24756]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jmp	SHORT $LN252@FindCloses
$LN3@FindCloses:
	cmp	ebp, 1
	jne	SHORT $LN5@FindCloses
	mov	edx, DWORD PTR _this$[esp+76]
	cmp	ecx, DWORD PTR [edx+24756]
$LN252@FindCloses:

; 9131 : 			{
; 9132 : 				bValidUnit = false;
; 9133 : 			}
; 9134 : 
; 9135 : 			if(bValidUnit)

	jg	$LN247@FindCloses
$LN5@FindCloses:
	cmp	BYTE PTR _bValidUnit$225145[esp+72], bl
	je	$LN247@FindCloses

; 9136 : 			{
; 9137 : 				int iTurns = TurnsToReachTarget(pLoopUnit, pTarget, false /*bReusePaths*/, bIgnoreUnits, (iNumTurnsAway==0));

	mov	edx, DWORD PTR _bIgnoreUnits$[esp+72]
	cmp	ebp, ebx
	sete	al
	movzx	ecx, al
	push	ecx
	push	edx
	push	ebx
	push	edi
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T290447[esp+96], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], bl
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 9138 : 				if(iTurns <= iNumTurnsAway)

	cmp	eax, ebp
	jg	SHORT $LN247@FindCloses

; 9139 : 				{
; 9140 : 					CvTacticalUnit unit;
; 9141 : 					unit.SetID(pLoopUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]

; 9142 : 					unit.SetAttackStrength(1000-iTurns);

	mov	edx, 1000				; 000003e8H
	sub	edx, eax

; 9143 : 					unit.SetHealthPercent(10,10);
; 9144 : 					unit.SetMovesToTarget(plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pTarget->getX(), pTarget->getY()));

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	mov	DWORD PTR _unit$225176[esp+76], ecx
	movsx	ecx, WORD PTR [edi+2]
	mov	DWORD PTR _unit$225176[esp+80], edx
	movsx	edx, WORD PTR [edi]
	push	ecx
	push	edx
	push	eax
	push	esi
	mov	DWORD PTR _unit$225176[esp+108], ebx
	mov	DWORD PTR _unit$225176[esp+112], ebx
	mov	DWORD PTR _unit$225176[esp+100], 100	; 00000064H
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 9145 : 					m_CurrentMoveUnits.push_back(unit);

	mov	ecx, DWORD PTR _this$[esp+92]
	mov	DWORD PTR _unit$225176[esp+104], eax
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _unit$225176[esp+76]
	push	eax
	add	ecx, 20					; 00000014H
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back

; 9146 : 					rtnValue = true;

	mov	BYTE PTR _rtnValue$[esp+76], 1
$LN247@FindCloses:
	mov	ebp, DWORD PTR _this$[esp+76]
$LN29@FindCloses:

; 9064 : 
; 9065 : 	// Loop through all units available to tactical AI this turn
; 9066 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 9067 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 9068 : #else
; 9069 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	ecx, DWORD PTR _it$[esp+76]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _it$[esp+76], eax
	cmp	eax, DWORD PTR [ebp+12]
	jne	$LL243@FindCloses
	mov	esi, DWORD PTR _pLoopUnit$[esp+76]
$LN28@FindCloses:

; 9147 : 				}
; 9148 : 			}
; 9149 : 		}
; 9150 : 	}
; 9151 : 
; 9152 : 	// Now sort them by turns to reach
; 9153 : 	std::stable_sort(m_CurrentMoveUnits.begin(), m_CurrentMoveUnits.end());

	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR [ebp+24]
	cmp	ecx, eax
	je	SHORT $LN223@FindCloses
	push	ebx
	push	ebx
	push	eax
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
	add	esp, 16					; 00000010H
$LN223@FindCloses:

; 9154 : 
; 9155 : 	return rtnValue;

	mov	DWORD PTR __$EHRec$[esp+84], -1
	cmp	esi, ebx
	je	SHORT $LN242@FindCloses
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN242@FindCloses:

; 9156 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	mov	al, BYTE PTR _rtnValue$[esp+76]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 60					; 0000003cH
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z ENDP ; CvTacticalAI::FindClosestUnit
PUBLIC	?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z ; CvTacticalAI::FindClosestOperationUnit
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z$0
__ehfuncinfo$?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z
_TEXT	SEGMENT
_rtnValue$ = -49					; size = 1
$T291201 = -48						; size = 1
_it$ = -48						; size = 4
_pLoopUnit$ = -44					; size = 8
_unit$225204 = -36					; size = 24
__$EHRec$ = -12						; size = 12
$T291018 = 8						; size = 4
_pTarget$ = 8						; size = 4
__Cat$291205 = 12					; size = 1
$T291203 = 12						; size = 1
_bSafeForRanged$ = 12					; size = 1
_bMustBeRangedUnit$ = 16				; size = 1
?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z PROC ; CvTacticalAI::FindClosestOperationUnit, COMDAT
; _this$ = ecx

; 9160 : {

	push	-1
	push	__ehhandler$?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	push	esi

; 9161 : 	FStaticVector<CvOperationUnit, SAFE_ESTIMATE_NUM_MULTIUNITFORMATION_ENTRIES, true, c_eCiv5GameplayDLL, 0>::iterator it;
; 9162 : 	UnitHandle pLoopUnit;

	xor	ebx, ebx
	xor	esi, esi
	push	edi
	mov	ebp, ecx
	mov	DWORD PTR _pLoopUnit$[esp+68], esi
	mov	BYTE PTR _pLoopUnit$[esp+72], bl

; 9163 : 
; 9164 : 	bool rtnValue = false;
; 9165 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR __$EHRec$[esp+76], ebx
	mov	BYTE PTR _rtnValue$[esp+68], bl
	cmp	ecx, eax
	je	SHORT $LN32@FindCloses@2
	mov	BYTE PTR $T291201[esp+68], bl
	mov	edx, DWORD PTR $T291201[esp+68]
	push	edx
	mov	edx, DWORD PTR __Cat$291205[esp+68]
	push	edx
	mov	edx, DWORD PTR $T291203[esp+72]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebp+28], eax
$LN32@FindCloses@2:

; 9166 : 
; 9167 : 	// Loop through all units available to operation
; 9168 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 9169 : 	for (it = m_OperationUnits.begin(); it != m_OperationUnits.end(); ++it)
; 9170 : #else
; 9171 : 	for(it = m_OperationUnits.begin(); it != m_OperationUnits.end(); it++)

	mov	eax, DWORD PTR [ebp+28644]
	mov	ecx, DWORD PTR [ebp+28648]
	mov	edx, eax
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _it$[esp+68], eax
	cmp	eax, ecx
	je	$LN9@FindCloses@2
	mov	edi, DWORD PTR _pTarget$[esp+64]
	jmp	SHORT $LN11@FindCloses@2
$LL148@FindCloses@2:
	mov	eax, DWORD PTR _it$[esp+68]
$LN11@FindCloses@2:

; 9172 : #endif
; 9173 : 	{
; 9174 : 		pLoopUnit = m_pPlayer->getUnit(it->GetUnitID());

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ecx, DWORD PTR _pLoopUnit$[esp+68]
	mov	esi, eax
	cmp	ecx, ebx
	je	SHORT $LN67@FindCloses@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN67@FindCloses@2:
	mov	DWORD PTR _pLoopUnit$[esp+68], esi
	cmp	esi, ebx
	je	$LN10@FindCloses@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 9175 : 		if(pLoopUnit)
; 9176 : 		{
; 9177 : 			bool bValidUnit = true;
; 9178 : 
; 9179 : 			if (pLoopUnit->hasMoved())

	mov	ecx, esi
	call	?hasMoved@CvUnit@@QBE_NXZ		; CvUnit::hasMoved
	test	al, al

; 9180 : 			{
; 9181 : 				bValidUnit = false;

	jne	$LN10@FindCloses@2

; 9182 : 			}
; 9183 : 
; 9184 : 			else if(!bSafeForRanged && pLoopUnit->IsCanAttackRanged())

	cmp	BYTE PTR _bSafeForRanged$[esp+64], bl
	jne	SHORT $LN5@FindCloses@2
	mov	ecx, esi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al

; 9185 : 			{
; 9186 : 				bValidUnit = false;

	jne	$LN10@FindCloses@2
$LN5@FindCloses@2:

; 9187 : 			}
; 9188 : 
; 9189 : 			else if (bMustBeRangedUnit && !pLoopUnit->IsCanAttackRanged())

	cmp	BYTE PTR _bMustBeRangedUnit$[esp+64], bl
	je	SHORT $LN146@FindCloses@2
	mov	ecx, esi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al

; 9190 : 			{
; 9191 : 				bValidUnit = false;
; 9192 : 			}
; 9193 : 
; 9194 : 			if(bValidUnit)

	je	SHORT $LN10@FindCloses@2
$LN146@FindCloses@2:

; 9195 : 			{
; 9196 : 				int iTurns = TurnsToReachTarget(pLoopUnit, pTarget, false /*bReusePaths*/, false /*bIgnoreUnits*/);

	push	ebx
	push	ebx
	push	ebx
	push	edi
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T291018[esp+88], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], bl
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 9197 : 
; 9198 : 				if(iTurns != MAX_INT)

	cmp	eax, 2147483647				; 7fffffffH
	je	SHORT $LN10@FindCloses@2

; 9199 : 				{
; 9200 : 					CvTacticalUnit unit;
; 9201 : 					unit.SetID(pLoopUnit->GetID());

	mov	edx, DWORD PTR [esi+100]

; 9202 : 					unit.SetAttackStrength(1000-iTurns);

	mov	ecx, 1000				; 000003e8H
	sub	ecx, eax

; 9203 : 					unit.SetHealthPercent(10,10);
; 9204 : 					unit.SetMovesToTarget(plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pTarget->getX(), pTarget->getY()));

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	mov	DWORD PTR _unit$225204[esp+68], edx
	movsx	edx, WORD PTR [edi+2]
	mov	DWORD PTR _unit$225204[esp+72], ecx
	movsx	ecx, WORD PTR [edi]
	push	edx
	push	ecx
	push	eax
	push	esi
	mov	DWORD PTR _unit$225204[esp+100], ebx
	mov	DWORD PTR _unit$225204[esp+104], ebx
	mov	DWORD PTR _unit$225204[esp+92], 100	; 00000064H
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 9205 : 					m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225204[esp+68]
	push	edx
	lea	ecx, DWORD PTR [ebp+20]
	mov	DWORD PTR _unit$225204[esp+84], eax
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back

; 9206 : 					rtnValue = true;

	mov	BYTE PTR _rtnValue$[esp+68], 1
$LN10@FindCloses@2:
	mov	eax, DWORD PTR _it$[esp+68]
	mov	ecx, DWORD PTR [ebp+28648]
	mov	edx, DWORD PTR [ebp+28644]
	add	eax, 8
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _it$[esp+68], eax
	cmp	eax, ecx
	jne	$LL148@FindCloses@2

; 9166 : 
; 9167 : 	// Loop through all units available to operation
; 9168 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 9169 : 	for (it = m_OperationUnits.begin(); it != m_OperationUnits.end(); ++it)
; 9170 : #else
; 9171 : 	for(it = m_OperationUnits.begin(); it != m_OperationUnits.end(); it++)

	mov	esi, DWORD PTR _pLoopUnit$[esp+68]
$LN9@FindCloses@2:

; 9207 : 				}
; 9208 : 			}
; 9209 : 		}
; 9210 : 	}
; 9211 : 
; 9212 : 	// Now sort them by turns to reach
; 9213 : 	std::stable_sort(m_CurrentMoveUnits.begin(), m_CurrentMoveUnits.end());

	mov	eax, DWORD PTR [ebp+28]
	mov	ebp, DWORD PTR [ebp+24]
	cmp	ebp, eax
	je	SHORT $LN128@FindCloses@2
	push	ebx
	push	ebx
	push	eax
	push	ebp
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
	add	esp, 16					; 00000010H
$LN128@FindCloses@2:

; 9214 : 
; 9215 : 	return rtnValue;

	mov	DWORD PTR __$EHRec$[esp+76], -1
	cmp	esi, ebx
	je	SHORT $LN147@FindCloses@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN147@FindCloses@2:

; 9216 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	al, BYTE PTR _rtnValue$[esp+68]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 52					; 00000034H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z ENDP ; CvTacticalAI::FindClosestOperationUnit
PUBLIC	?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z ; CvTacticalAI::FindClosestNavalOperationUnit
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z$0
__ehfuncinfo$?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z
_TEXT	SEGMENT
_rtnValue$ = -49					; size = 1
$T291597 = -48						; size = 1
_it$ = -48						; size = 4
_pLoopUnit$ = -44					; size = 8
_unit$225229 = -36					; size = 24
__$EHRec$ = -12						; size = 12
$T291409 = 8						; size = 4
_pTarget$ = 8						; size = 4
__Cat$291601 = 12					; size = 1
$T291599 = 12						; size = 1
_bEscortedUnits$ = 12					; size = 1
?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z PROC ; CvTacticalAI::FindClosestNavalOperationUnit, COMDAT
; _this$ = ecx

; 9220 : {

	push	-1
	push	__ehhandler$?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	push	esi

; 9221 : 	FStaticVector<CvOperationUnit, SAFE_ESTIMATE_NUM_MULTIUNITFORMATION_ENTRIES, true, c_eCiv5GameplayDLL, 0>::iterator it;
; 9222 : 	UnitHandle pLoopUnit;

	xor	ebx, ebx
	xor	esi, esi
	push	edi
	mov	ebp, ecx
	mov	DWORD PTR _pLoopUnit$[esp+68], esi
	mov	BYTE PTR _pLoopUnit$[esp+72], bl

; 9223 : 
; 9224 : 	bool rtnValue = false;
; 9225 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR __$EHRec$[esp+76], ebx
	mov	BYTE PTR _rtnValue$[esp+68], bl
	cmp	ecx, eax
	je	SHORT $LN30@FindCloses@3
	mov	BYTE PTR $T291597[esp+68], bl
	mov	edx, DWORD PTR $T291597[esp+68]
	push	edx
	mov	edx, DWORD PTR __Cat$291601[esp+68]
	push	edx
	mov	edx, DWORD PTR $T291599[esp+72]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebp+28], eax
$LN30@FindCloses@3:

; 9226 : 
; 9227 : 	// Loop through all units available to operation
; 9228 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 9229 : 	for (it = m_OperationUnits.begin(); it != m_OperationUnits.end(); ++it)
; 9230 : #else
; 9231 : 	for(it = m_OperationUnits.begin(); it != m_OperationUnits.end(); it++)

	mov	eax, DWORD PTR [ebp+28644]
	mov	ecx, DWORD PTR [ebp+28648]
	mov	edx, eax
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _it$[esp+68], eax
	cmp	eax, ecx
	je	$LN7@FindCloses@3
	mov	edi, DWORD PTR _pTarget$[esp+64]
	jmp	SHORT $LN9@FindCloses@3
$LL149@FindCloses@3:
	mov	eax, DWORD PTR _it$[esp+68]
$LN9@FindCloses@3:

; 9232 : #endif
; 9233 : 	{
; 9234 : 		pLoopUnit = m_pPlayer->getUnit(it->GetUnitID());

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ecx, DWORD PTR _pLoopUnit$[esp+68]
	mov	esi, eax
	cmp	ecx, ebx
	je	SHORT $LN65@FindCloses@3
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN65@FindCloses@3:
	mov	DWORD PTR _pLoopUnit$[esp+68], esi
	cmp	esi, ebx
	je	$LN8@FindCloses@3
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 9235 : 		if(pLoopUnit)
; 9236 : 		{
; 9237 : 			bool bValidUnit = true;
; 9238 : 
; 9239 : 			if(bEscortedUnits && (!pLoopUnit->IsGreatAdmiral() && pLoopUnit->getDomainType() != DOMAIN_LAND))

	mov	ecx, esi
	cmp	BYTE PTR _bEscortedUnits$[esp+64], bl
	je	SHORT $LN146@FindCloses@3
	call	?IsGreatAdmiral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatAdmiral
	test	al, al
	jne	SHORT $LN147@FindCloses@3
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	je	SHORT $LN147@FindCloses@3

; 9240 : 			{
; 9241 : 				bValidUnit = false;
; 9242 : 			}
; 9243 : 
; 9244 : 			if(!bEscortedUnits && (pLoopUnit->getDomainType() != DOMAIN_SEA || pLoopUnit->IsGreatAdmiral()))

	jmp	$LN8@FindCloses@3
$LN146@FindCloses@3:
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	$LN8@FindCloses@3
	mov	ecx, esi
	call	?IsGreatAdmiral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatAdmiral
	test	al, al

; 9245 : 			{
; 9246 : 				bValidUnit = false;
; 9247 : 			}
; 9248 : 
; 9249 : 			if(bValidUnit)

	jne	SHORT $LN8@FindCloses@3
$LN147@FindCloses@3:

; 9250 : 			{
; 9251 : 				int iTurns = TurnsToReachTarget(pLoopUnit, pTarget, false /*bReusePaths*/, true /*bIgnoreUnits*/);

	push	ebx
	push	1
	push	ebx
	push	edi
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T291409[esp+88], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], bl
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 9252 : 
; 9253 : 				if(iTurns != MAX_INT)

	cmp	eax, 2147483647				; 7fffffffH
	je	SHORT $LN8@FindCloses@3

; 9254 : 				{
; 9255 : 					CvTacticalUnit unit;
; 9256 : 					unit.SetID(pLoopUnit->GetID());

	mov	edx, DWORD PTR [esi+100]

; 9257 : 					unit.SetAttackStrength(1000-iTurns);

	mov	ecx, 1000				; 000003e8H
	sub	ecx, eax

; 9258 : 					unit.SetHealthPercent(10,10);
; 9259 : 					unit.SetMovesToTarget(plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pTarget->getX(), pTarget->getY()));

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	mov	DWORD PTR _unit$225229[esp+68], edx
	movsx	edx, WORD PTR [edi+2]
	mov	DWORD PTR _unit$225229[esp+72], ecx
	movsx	ecx, WORD PTR [edi]
	push	edx
	push	ecx
	push	eax
	push	esi
	mov	DWORD PTR _unit$225229[esp+100], ebx
	mov	DWORD PTR _unit$225229[esp+104], ebx
	mov	DWORD PTR _unit$225229[esp+92], 100	; 00000064H
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 9260 : 					m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225229[esp+68]
	push	edx
	lea	ecx, DWORD PTR [ebp+20]
	mov	DWORD PTR _unit$225229[esp+84], eax
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back

; 9261 : 					rtnValue = true;

	mov	BYTE PTR _rtnValue$[esp+68], 1
$LN8@FindCloses@3:
	mov	eax, DWORD PTR _it$[esp+68]
	mov	ecx, DWORD PTR [ebp+28648]
	mov	edx, DWORD PTR [ebp+28644]
	add	eax, 8
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _it$[esp+68], eax
	cmp	eax, ecx
	jne	$LL149@FindCloses@3

; 9226 : 
; 9227 : 	// Loop through all units available to operation
; 9228 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 9229 : 	for (it = m_OperationUnits.begin(); it != m_OperationUnits.end(); ++it)
; 9230 : #else
; 9231 : 	for(it = m_OperationUnits.begin(); it != m_OperationUnits.end(); it++)

	mov	esi, DWORD PTR _pLoopUnit$[esp+68]
$LN7@FindCloses@3:

; 9262 : 				}
; 9263 : 			}
; 9264 : 		}
; 9265 : 	}
; 9266 : 
; 9267 : 	// Now sort them by turns to reach
; 9268 : 	std::stable_sort(m_CurrentMoveUnits.begin(), m_CurrentMoveUnits.end());

	mov	eax, DWORD PTR [ebp+28]
	mov	ebp, DWORD PTR [ebp+24]
	cmp	ebp, eax
	je	SHORT $LN128@FindCloses@3
	push	ebx
	push	ebx
	push	eax
	push	ebp
	call	??$_Stable_sort@V?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@HVCvTacticalUnit@@@std@@YAXV?$_Vector_iterator@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@0@0PAHPAVCvTacticalUnit@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvTacticalUnit,std::allocator<CvTacticalUnit> >,int,CvTacticalUnit>
	add	esp, 16					; 00000010H
$LN128@FindCloses@3:

; 9269 : 
; 9270 : 	return rtnValue;

	mov	DWORD PTR __$EHRec$[esp+76], -1
	cmp	esi, ebx
	je	SHORT $LN148@FindCloses@3
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN148@FindCloses@3:

; 9271 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	al, BYTE PTR _rtnValue$[esp+68]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 52					; 00000034H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z ENDP ; CvTacticalAI::FindClosestNavalOperationUnit
PUBLIC	??$stable_sort@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@0@Z ; std::stable_sort<CvTacticalMove *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$stable_sort@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$stable_sort@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@0@Z PROC ; std::stable_sort<CvTacticalMove *>, COMDAT

; 3420 : 	_DEBUG_RANGE(_First, _Last);
; 3421 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor@3

; 3422 : 		{
; 3423 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z ; std::_Stable_sort<CvTacticalMove *,int,CvTacticalMove>
	add	esp, 16					; 00000010H
$LN1@stable_sor@3:

; 3424 : 		}
; 3425 : 	}

	ret	0
??$stable_sort@PAVCvTacticalMove@@@std@@YAXPAVCvTacticalMove@@0@Z ENDP ; std::stable_sort<CvTacticalMove *>
_TEXT	ENDS
PUBLIC	??$stable_sort@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@0@Z ; std::stable_sort<CvTacticalTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$stable_sort@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$stable_sort@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@0@Z PROC ; std::stable_sort<CvTacticalTarget *>, COMDAT

; 3420 : 	_DEBUG_RANGE(_First, _Last);
; 3421 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor@4

; 3422 : 		{
; 3423 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 16					; 00000010H
$LN1@stable_sor@4:

; 3424 : 		}
; 3425 : 	}

	ret	0
??$stable_sort@PAVCvTacticalTarget@@@std@@YAXPAVCvTacticalTarget@@0@Z ENDP ; std::stable_sort<CvTacticalTarget *>
_TEXT	ENDS
PUBLIC	??$stable_sort@PAVCvBlockingUnit@@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z@Z ; std::stable_sort<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$stable_sort@PAVCvBlockingUnit@@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$stable_sort@PAVCvBlockingUnit@@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z@Z PROC ; std::stable_sort<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>, COMDAT

; 3571 : 	_DEBUG_RANGE(_First, _Last);
; 3572 : 	_DEBUG_POINTER(_Pred);
; 3573 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor@5

; 3574 : 		{
; 3575 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 3576 : 			_Dist_type(_First), _Val_type(_First), _Pred);

	mov	edx, DWORD PTR __Pred$[esp-4]
	push	edx
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
	add	esp, 20					; 00000014H
$LN1@stable_sor@5:

; 3577 : 		}
; 3578 : 	}

	ret	0
??$stable_sort@PAVCvBlockingUnit@@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0P6A_NV1@1@Z@Z ENDP ; std::stable_sort<CvBlockingUnit *,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
_TEXT	ENDS
PUBLIC	??$stable_sort@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@0@Z ; std::stable_sort<CvBlockingUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$stable_sort@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$stable_sort@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@0@Z PROC ; std::stable_sort<CvBlockingUnit *>, COMDAT

; 3420 : 	_DEBUG_RANGE(_First, _Last);
; 3421 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor@6

; 3422 : 		{
; 3423 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit>
	add	esp, 16					; 00000010H
$LN1@stable_sor@6:

; 3424 : 		}
; 3425 : 	}

	ret	0
??$stable_sort@PAVCvBlockingUnit@@@std@@YAXPAVCvBlockingUnit@@0@Z ENDP ; std::stable_sort<CvBlockingUnit *>
_TEXT	ENDS
PUBLIC	?EstablishTacticalPriorities@CvTacticalAI@@AAEXXZ ; CvTacticalAI::EstablishTacticalPriorities
EXTRN	?getTacticalMoveInfo@CvGlobals@@QAEPAVCvTacticalMoveXMLEntry@@W4TacticalAIMoveTypes@@@Z:PROC ; CvGlobals::getTacticalMoveInfo
EXTRN	?getNumTacticalMoveInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTacticalMoveInfos
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
;	COMDAT ?EstablishTacticalPriorities@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_move$ = -8						; size = 8
?EstablishTacticalPriorities@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::EstablishTacticalPriorities, COMDAT
; _this$ = ecx

; 1204 : {

	sub	esp, 8
	push	ebx
	push	edi
	mov	ebx, ecx

; 1205 : 	CvTacticalMove move;

	xor	edi, edi

; 1206 : 
; 1207 : 	m_MovePriorityList.clear();
; 1208 : 
; 1209 : 	// Loop through each possible tactical move
; 1210 : #ifdef AUI_WARNING_FIXES
; 1211 : 	for (uint iI = 0; iI < GC.getNumTacticalMoveInfos(); iI++)
; 1212 : #else
; 1213 : 	for(int iI = 0; iI < GC.getNumTacticalMoveInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _move$[esp+16], -1
	mov	DWORD PTR _move$[esp+20], edi
	mov	DWORD PTR [ebx+72], edi
	call	?getNumTacticalMoveInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumTacticalMoveInfos
	test	eax, eax
	jle	SHORT $LN3@EstablishT
	push	ebp
	push	esi
	npad	8
$LL41@EstablishT:

; 1214 : #endif
; 1215 : 	{
; 1216 : 		const TacticalAIMoveTypes eTacticalAIMove = static_cast<TacticalAIMoveTypes>(iI);
; 1217 : 		CvTacticalMoveXMLEntry* pkTacticalMoveInfo = GC.getTacticalMoveInfo(eTacticalAIMove);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTacticalMoveInfo@CvGlobals@@QAEPAVCvTacticalMoveXMLEntry@@W4TacticalAIMoveTypes@@@Z ; CvGlobals::getTacticalMoveInfo

; 1218 : 		if(pkTacticalMoveInfo)

	test	eax, eax
	je	SHORT $LN4@EstablishT

; 1219 : 		{
; 1220 : 			move.m_eMoveType = eTacticalAIMove;
; 1221 : 			move.m_iPriority = pkTacticalMoveInfo->GetPriority();

	mov	ebp, DWORD PTR [eax+264]

; 1222 : 
; 1223 : 			if(move.m_iPriority >= 0)

	test	ebp, ebp
	jl	SHORT $LN4@EstablishT

; 1224 : 			{
; 1225 : 				m_MovePriorityList.push_back(move);

	mov	eax, DWORD PTR [ebx+76]
	lea	esi, DWORD PTR [ebx+68]
	mov	BYTE PTR [esi+2060], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN20@EstablishT
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalMove,256,1,297,0>::GrowSize
$LN20@EstablishT:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN23@EstablishT
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebp
$LN23@EstablishT:
	inc	DWORD PTR [esi+4]
$LN4@EstablishT:

; 1206 : 
; 1207 : 	m_MovePriorityList.clear();
; 1208 : 
; 1209 : 	// Loop through each possible tactical move
; 1210 : #ifdef AUI_WARNING_FIXES
; 1211 : 	for (uint iI = 0; iI < GC.getNumTacticalMoveInfos(); iI++)
; 1212 : #else
; 1213 : 	for(int iI = 0; iI < GC.getNumTacticalMoveInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumTacticalMoveInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumTacticalMoveInfos
	cmp	edi, eax
	jl	SHORT $LL41@EstablishT
	pop	esi
	pop	ebp
$LN3@EstablishT:

; 1226 : 			}
; 1227 : 		}
; 1228 : 	}
; 1229 : 
; 1230 : 	// Now sort the moves in priority order
; 1231 : 	std::stable_sort(m_MovePriorityList.begin(), m_MovePriorityList.end());

	mov	eax, DWORD PTR [ebx+68]
	mov	edx, DWORD PTR [ebx+72]
	mov	ecx, eax
	lea	ecx, DWORD PTR [ecx+edx*8]
	pop	edi
	pop	ebx
	cmp	eax, ecx
	je	SHORT $LN31@EstablishT
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z ; std::_Stable_sort<CvTacticalMove *,int,CvTacticalMove>
	add	esp, 16					; 00000010H
$LN31@EstablishT:

; 1232 : }

	add	esp, 8
	ret	0
?EstablishTacticalPriorities@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::EstablishTacticalPriorities
_TEXT	ENDS
PUBLIC	?EstablishBarbarianPriorities@CvTacticalAI@@AAEXXZ ; CvTacticalAI::EstablishBarbarianPriorities
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
; Function compile flags: /Ogtpy
;	COMDAT ?EstablishBarbarianPriorities@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_iI$220813 = -4						; size = 4
?EstablishBarbarianPriorities@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::EstablishBarbarianPriorities, COMDAT
; _this$ = ecx

; 1237 : {

	push	ecx
	push	ebx
	mov	ebx, ecx

; 1238 : 	int iPriority = 0;
; 1239 : 
; 1240 : 	// Only establish priorities once per turn
; 1241 : 	if(GC.getGame().getGameTurn() <= m_MovePriorityTurn)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	xor	edi, edi
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, DWORD PTR [ebx+2132]
	jle	$LN99@EstablishB

; 1242 : 	{
; 1243 : 		return;
; 1244 : 	}
; 1245 : 
; 1246 : 	m_MovePriorityList.clear();

	mov	DWORD PTR [ebx+72], edi

; 1247 : 	m_MovePriorityTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR [ebx+2132], eax

; 1248 : 
; 1249 : 	// Loop through each possible tactical move (other than "none" or "unassigned")
; 1250 : 	for(int iI = 0; iI < NUM_AI_BARBARIAN_MOVES; iI++)

	xor	eax, eax
	mov	DWORD PTR _iI$220813[esp+12], eax
	push	esi
	npad	7
$LL108@EstablishB:

; 1251 : 	{
; 1252 : 		// Set base value
; 1253 : 		switch((AIBarbarianTacticalMove)iI)

	cmp	eax, 19					; 00000013H
	ja	$LN22@EstablishB
	jmp	DWORD PTR $LN109@EstablishB[eax*4]
$LN21@EstablishB:

; 1254 : 		{
; 1255 : 		case AI_TACTICAL_BARBARIAN_CAPTURE_CITY:
; 1256 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_CAPTURE_CITY();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2480

; 1257 : 			break;

	jmp	$LN22@EstablishB
$LN20@EstablishB:

; 1258 : 		case AI_TACTICAL_BARBARIAN_DAMAGE_CITY:
; 1259 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_DAMAGE_CITY();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2484

; 1260 : 			break;

	jmp	$LN22@EstablishB
$LN19@EstablishB:

; 1261 : 		case AI_TACTICAL_BARBARIAN_DESTROY_HIGH_PRIORITY_UNIT:
; 1262 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_HIGH_UNIT();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2488

; 1263 : 			break;

	jmp	$LN22@EstablishB
$LN18@EstablishB:

; 1264 : 		case AI_TACTICAL_BARBARIAN_DESTROY_MEDIUM_PRIORITY_UNIT:
; 1265 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_MEDIUM_UNIT();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2492

; 1266 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN17@EstablishB:

; 1267 : 		case AI_TACTICAL_BARBARIAN_DESTROY_LOW_PRIORITY_UNIT:
; 1268 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_LOW_UNIT();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2496

; 1269 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN16@EstablishB:

; 1270 : 		case AI_TACTICAL_BARBARIAN_MOVE_TO_SAFETY:
; 1271 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_TO_SAFETY();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2500

; 1272 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN15@EstablishB:

; 1273 : 		case AI_TACTICAL_BARBARIAN_ATTRIT_HIGH_PRIORITY_UNIT:
; 1274 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_HIGH_UNIT();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2504

; 1275 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN14@EstablishB:

; 1276 : 		case AI_TACTICAL_BARBARIAN_ATTRIT_MEDIUM_PRIORITY_UNIT:
; 1277 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_MEDIUM_UNIT();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2508

; 1278 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN13@EstablishB:

; 1279 : 		case AI_TACTICAL_BARBARIAN_ATTRIT_LOW_PRIORITY_UNIT:
; 1280 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_LOW_UNIT();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2512

; 1281 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN12@EstablishB:

; 1282 : 		case AI_TACTICAL_BARBARIAN_PILLAGE:
; 1283 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2520

; 1284 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN11@EstablishB:

; 1285 : 		case AI_TACTICAL_BARBARIAN_PILLAGE_CITADEL:
; 1286 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_CITADEL();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2524

; 1287 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN10@EstablishB:

; 1288 : 		case AI_TACTICAL_BARBARIAN_PILLAGE_NEXT_TURN:
; 1289 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_NEXT_TURN();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2528

; 1290 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN9@EstablishB:

; 1291 : 		case AI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE:
; 1292 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2532

; 1293 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN8@EstablishB:

; 1294 : 		case AI_TACTICAL_BARBARIAN_CIVILIAN_ATTACK:
; 1295 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_CIVILIAN_ATTACK();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2536

; 1296 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN7@EstablishB:

; 1297 : 		case AI_TACTICAL_BARBARIAN_AGGRESSIVE_MOVE:
; 1298 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_AGGRESSIVE_MOVE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2544

; 1299 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN6@EstablishB:

; 1300 : 		case AI_TACTICAL_BARBARIAN_PASSIVE_MOVE:
; 1301 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_PASSIVE_MOVE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2540

; 1302 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN5@EstablishB:

; 1303 : 		case AI_TACTICAL_BARBARIAN_CAMP_DEFENSE:
; 1304 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_CAMP_DEFENSE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2548

; 1305 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN4@EstablishB:

; 1306 : 		case AI_TACTICAL_BARBARIAN_DESPERATE_ATTACK:
; 1307 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_DESPERATE_ATTACK();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2516

; 1308 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN3@EstablishB:

; 1309 : 		case AI_TACTICAL_BARBARIAN_ESCORT_CIVILIAN:
; 1310 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_ESCORT_CIVILIAN();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2552

; 1311 : 			break;

	jmp	SHORT $LN22@EstablishB
$LN2@EstablishB:

; 1312 : 		case AI_TACTICAL_BARBARIAN_PLUNDER_TRADE_UNIT:
; 1313 : 			iPriority = GC.getAI_TACTICAL_BARBARIAN_PRIORITY_PLUNDER_TRADE_UNIT();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2556
$LN22@EstablishB:

; 1314 : 			break;
; 1315 : 		}
; 1316 : 
; 1317 : 		// Make sure base priority is not negative
; 1318 : 		if(iPriority >= 0)

	test	edi, edi
	jl	SHORT $LN25@EstablishB

; 1319 : 		{
; 1320 : 			// Finally, add a random die roll to each priority
; 1321 : 			iPriority += GC.getGame().getJonRandNum(GC.getAI_TACTICAL_MOVE_PRIORITY_RANDOMNESS(), "Tactical AI Move Priority");

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2476
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG220843
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 1322 : 
; 1323 : 			// Store off this move and priority
; 1324 : 			CvTacticalMove move;
; 1325 : 			move.m_eMoveType = (TacticalAIMoveTypes)iI;
; 1326 : 			move.m_iPriority = iPriority;
; 1327 : 			m_MovePriorityList.push_back(move);

	lea	esi, DWORD PTR [ebx+68]
	add	edi, eax
	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+2060], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN88@EstablishB
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvTacticalMove@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalMove,256,1,297,0>::GrowSize
$LN88@EstablishB:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN91@EstablishB
	mov	ecx, DWORD PTR _iI$220813[esp+16]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edi
$LN91@EstablishB:
	inc	DWORD PTR [esi+4]
	mov	eax, DWORD PTR _iI$220813[esp+16]
$LN25@EstablishB:
	inc	eax
	cmp	eax, 20					; 00000014H
	mov	DWORD PTR _iI$220813[esp+16], eax
	jl	$LL108@EstablishB

; 1328 : 		}
; 1329 : 	}
; 1330 : 
; 1331 : 	// Now sort the moves in priority order
; 1332 : 	std::stable_sort(m_MovePriorityList.begin(), m_MovePriorityList.end());

	mov	eax, DWORD PTR [ebx+68]
	mov	edx, DWORD PTR [ebx+72]
	mov	ecx, eax
	lea	ecx, DWORD PTR [ecx+edx*8]
	pop	esi
	cmp	eax, ecx
	je	SHORT $LN99@EstablishB
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvTacticalMove@@HV1@@std@@YAXPAVCvTacticalMove@@0PAH0@Z ; std::_Stable_sort<CvTacticalMove *,int,CvTacticalMove>
	add	esp, 16					; 00000010H
$LN99@EstablishB:
	pop	edi
	pop	ebx

; 1333 : }

	pop	ecx
	ret	0
	npad	3
$LN109@EstablishB:
	DD	$LN21@EstablishB
	DD	$LN20@EstablishB
	DD	$LN19@EstablishB
	DD	$LN18@EstablishB
	DD	$LN17@EstablishB
	DD	$LN16@EstablishB
	DD	$LN15@EstablishB
	DD	$LN14@EstablishB
	DD	$LN13@EstablishB
	DD	$LN12@EstablishB
	DD	$LN9@EstablishB
	DD	$LN8@EstablishB
	DD	$LN7@EstablishB
	DD	$LN6@EstablishB
	DD	$LN5@EstablishB
	DD	$LN4@EstablishB
	DD	$LN3@EstablishB
	DD	$LN2@EstablishB
	DD	$LN11@EstablishB
	DD	$LN10@EstablishB
?EstablishBarbarianPriorities@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::EstablishBarbarianPriorities
_TEXT	ENDS
PUBLIC	?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ	; CvTacticalAI::PlotCaptureCityMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fautovariable.h
xdata$x	SEGMENT
__ehfuncinfo$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ$5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ
_TEXT	SEGMENT
_bAttackMade$ = -158					; size = 1
_bLog$ = -157						; size = 1
_pTarget$ = -156					; size = 4
_strLogString$221217 = -152				; size = 28
_strPlayerName$221215 = -124				; size = 28
_strTemp$221218 = -96					; size = 28
_strCityName$221216 = -68				; size = 28
$T292060 = -40						; size = 28
$T292059 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ PROC	; CvTacticalAI::PlotCaptureCityMoves, COMDAT
; _this$ = ecx

; 2064 : {

	push	-1
	push	__ehhandler$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 148				; 00000094H
	push	ebx
	mov	ebx, ecx

; 2065 : 	int iRequiredDamage;
; 2066 : 	bool bAttackMade = false;
; 2067 : 	bool bLog = GC.getLogging() && GC.getAILogging();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR _bAttackMade$[esp+164], 0
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN11@PlotCaptur
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	mov	BYTE PTR _bLog$[esp+164], 1
	test	al, al
	jne	SHORT $LN12@PlotCaptur
$LN11@PlotCaptur:
	mov	BYTE PTR _bLog$[esp+164], 0
$LN12@PlotCaptur:

; 2068 : 
; 2069 : 	// See how many moves of this type we can execute
; 2070 : 	CvTacticalTarget* pTarget;
; 2071 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_CITY);

	push	1
	mov	ecx, ebx
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	DWORD PTR _pTarget$[esp+164], eax

; 2072 : 	while(pTarget != NULL)

	test	eax, eax
	je	$LN172@PlotCaptur
	push	ebp
	push	esi
	push	edi
	jmp	SHORT $LN8@PlotCaptur
$LL173@PlotCaptur:
	mov	eax, DWORD PTR _pTarget$[esp+176]
$LN8@PlotCaptur:

; 2073 : 	{
; 2074 : 		// See what units we have who can reach target this turn
; 2075 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	ebp, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN176@PlotCaptur
	cmp	ebp, -2147483647			; 80000001H
	je	$LN176@PlotCaptur
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [edi+4056]
	mov	ecx, DWORD PTR [edi+4020]
	test	dl, dl
	je	SHORT $LN35@PlotCaptur
	test	eax, eax
	jge	SHORT $LN37@PlotCaptur
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN39@PlotCaptur
$LN37@PlotCaptur:
	cmp	eax, ecx
	jl	SHORT $LN35@PlotCaptur
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN39@PlotCaptur
$LN35@PlotCaptur:
	mov	esi, eax
$LN39@PlotCaptur:
	mov	al, BYTE PTR [edi+4057]
	mov	edi, DWORD PTR [edi+4024]
	test	al, al
	je	SHORT $LN174@PlotCaptur
	test	ebp, ebp
	jge	SHORT $LN47@PlotCaptur
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN49@PlotCaptur
$LN47@PlotCaptur:
	cmp	ebp, edi
	jl	SHORT $LN174@PlotCaptur
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN49@PlotCaptur
$LN174@PlotCaptur:
	mov	edx, ebp
$LN49@PlotCaptur:
	test	esi, esi
	jl	$LN176@PlotCaptur
	cmp	esi, ecx
	jge	$LN176@PlotCaptur
	test	edx, edx
	jl	$LN176@PlotCaptur
	cmp	edx, edi
	jge	$LN176@PlotCaptur
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	ebp, ecx

; 2076 : 		if(pPlot != NULL)

	je	$LN176@PlotCaptur

; 2077 : 		{
; 2078 : 			m_CurrentMoveCities.clear();

	mov	edx, DWORD PTR [ebx+60]
	mov	ecx, DWORD PTR [ebx+56]
	cmp	ecx, edx
	je	SHORT $LN77@PlotCaptur
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN102@PlotCaptur
	npad	4
$LL104@PlotCaptur:
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], esi
	add	eax, 12					; 0000000cH
	add	ecx, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL104@PlotCaptur
$LN102@PlotCaptur:
	mov	DWORD PTR [ebx+60], ecx
$LN77@PlotCaptur:

; 2079 : 			if(FindUnitsWithinStrikingDistance(pPlot, 1, 0, false /*bNoRangedUnits*/, false /*bNavalOnly*/, false /*bMustMoveThrough*/, true /*bIncludeBlockedUnits*/))

	push	0
	push	0
	push	1
	push	0
	push	0
	push	0
	push	0
	push	1
	push	ebp
	mov	ecx, ebx
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
	test	al, al
	je	$LN176@PlotCaptur

; 2080 : 			{
; 2081 : 				// Do we have enough firepower to destroy it?
; 2082 : 				CvCity* pCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [ebp+104]
	test	eax, eax
	jl	$LN176@PlotCaptur
	cmp	eax, 64					; 00000040H
	jge	$LN176@PlotCaptur
	mov	ecx, DWORD PTR [ebp+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 2083 : 				if(pCity != NULL)

	test	esi, esi
	je	$LN176@PlotCaptur

; 2084 : 				{
; 2085 : 					iRequiredDamage = pCity->GetMaxHitPoints() - pCity->getDamage();

	mov	ecx, esi
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, esi
	mov	edi, eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	sub	edi, eax

; 2086 : 					pTarget->SetAuxIntData(iRequiredDamage);

	mov	eax, DWORD PTR _pTarget$[esp+176]

; 2087 : 					if(ComputeTotalExpectedDamage(pTarget, pPlot) >= (iRequiredDamage / 2)) // risky

	push	ebp
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR [eax+20], edi
	call	?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z ; CvTacticalAI::ComputeTotalExpectedDamage
	mov	ecx, eax
	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jl	$LN176@PlotCaptur

; 2088 : 					{
; 2089 : 						// Log result
; 2090 : 						if(bLog)

	cmp	BYTE PTR _bLog$[esp+176], 0
	je	$LN175@PlotCaptur

; 2091 : 						{
; 2092 : 							CvString strPlayerName, strCityName, strLogString, strTemp;

	lea	ecx, DWORD PTR _strPlayerName$221215[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strCityName$221216[esp+176]
	mov	DWORD PTR __$EHRec$[esp+184], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$221217[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$221218[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2093 : 							strPlayerName = GET_PLAYER(pCity->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [esi+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+184], 3
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$221215[esp+176]
	test	eax, eax
	je	SHORT $LN133@PlotCaptur
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN132@PlotCaptur
$LN133@PlotCaptur:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN132@PlotCaptur:

; 2094 : 							strCityName = pCity->getName();

	lea	edx, DWORD PTR $T292059[esp+176]
	push	edx
	mov	ecx, esi
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _strCityName$221216[esp+180]
	mov	BYTE PTR __$EHRec$[esp+188], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T292059[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2095 : 							strLogString.Format("Attacking city of ");

	lea	eax, DWORD PTR _strLogString$221217[esp+176]
	push	OFFSET $SG221220
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 2096 : 							strLogString += strCityName;

	lea	ecx, DWORD PTR _strCityName$221216[esp+176]
	push	ecx
	lea	ecx, DWORD PTR _strLogString$221217[esp+180]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2097 : 							strTemp.Format(" to capture, X: %d, Y: %d,", pCity->getX(), pCity->getY());

	mov	eax, DWORD PTR [esi+108]
	mov	esi, DWORD PTR [esi+96]
	push	eax
	push	esi
	lea	edx, DWORD PTR _strTemp$221218[esp+184]
	push	OFFSET $SG221221
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2098 : 							strLogString += strTemp + strPlayerName;

	lea	eax, DWORD PTR _strPlayerName$221215[esp+192]
	push	eax
	lea	ecx, DWORD PTR _strTemp$221218[esp+196]
	push	ecx
	lea	edx, DWORD PTR $T292060[esp+200]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR _strLogString$221217[esp+180]
	mov	BYTE PTR __$EHRec$[esp+188], 5
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T292060[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2099 : 							LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$221217[esp+180]
	push	eax
	mov	ecx, ebx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2100 : 						}

	lea	ecx, DWORD PTR _strTemp$221218[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$221217[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strCityName$221216[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$221215[esp+176]
	mov	DWORD PTR __$EHRec$[esp+184], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN175@PlotCaptur:

; 2101 : 
; 2102 : 						// If so, execute enough moves to take it
; 2103 : 						ExecuteAttack(pTarget, pPlot, false, false);

	mov	ecx, DWORD PTR _pTarget$[esp+176]
	push	0
	push	0
	push	ebp
	push	ecx
	mov	ecx, ebx
	call	?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z ; CvTacticalAI::ExecuteAttack

; 2104 : 						bAttackMade = true;
; 2105 : 
; 2106 : 						// Did it work?  If so, don't need a temporary dominance zone if had one here
; 2107 : 						if(pPlot->getOwner() == m_pPlayer->GetID())

	movsx	edx, BYTE PTR [ebp+4]
	mov	eax, DWORD PTR [ebx]
	mov	BYTE PTR _bAttackMade$[esp+176], 1
	cmp	edx, DWORD PTR [eax+44]
	jne	SHORT $LN176@PlotCaptur

; 2108 : 						{
; 2109 : 							DeleteTemporaryZone(pPlot);

	push	ebp
	mov	ecx, ebx
	call	?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z ; CvTacticalAI::DeleteTemporaryZone
$LN176@PlotCaptur:

; 2110 : 						}
; 2111 : 					}
; 2112 : 				}
; 2113 : 			}
; 2114 : 		}
; 2115 : 		pTarget = GetNextZoneTarget();

	mov	ecx, ebx
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	DWORD PTR _pTarget$[esp+176], eax
	test	eax, eax
	jne	$LL173@PlotCaptur
	pop	edi
	pop	esi
	pop	ebp
$LN172@PlotCaptur:

; 2116 : 	}
; 2117 : 	return bAttackMade;
; 2118 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+164]
	mov	al, BYTE PTR _bAttackMade$[esp+164]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 160				; 000000a0H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ$0:
	lea	ecx, DWORD PTR _strPlayerName$221215[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ$1:
	lea	ecx, DWORD PTR _strCityName$221216[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ$2:
	lea	ecx, DWORD PTR _strLogString$221217[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ$3:
	lea	ecx, DWORD PTR _strTemp$221218[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ$4:
	lea	ecx, DWORD PTR $T292059[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ$5:
	lea	ecx, DWORD PTR $T292060[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ ENDP	; CvTacticalAI::PlotCaptureCityMoves
PUBLIC	?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ	; CvTacticalAI::PlotDamageCityMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ$5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ
_TEXT	SEGMENT
_bAttackMade$ = -162					; size = 1
_bLog$ = -161						; size = 1
_this$ = -160						; size = 4
_pTarget$ = -156					; size = 4
_strLogString$221243 = -152				; size = 28
_strPlayerName$221241 = -124				; size = 28
_strTemp$221244 = -96					; size = 28
_strCityName$221242 = -68				; size = 28
$T292518 = -40						; size = 28
$T292517 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ PROC		; CvTacticalAI::PlotDamageCityMoves, COMDAT
; _this$ = ecx

; 2122 : {

	push	-1
	push	__ehhandler$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	mov	esi, ecx

; 2123 : 	int iRequiredDamage;
; 2124 : 	bool bAttackMade = false;

	xor	bl, bl

; 2125 : 	bool bLog = GC.getLogging() && GC.getAILogging();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+172], esi
	mov	BYTE PTR _bAttackMade$[esp+172], bl
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN10@PlotDamage
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	mov	BYTE PTR _bLog$[esp+172], 1
	test	al, al
	jne	SHORT $LN11@PlotDamage
$LN10@PlotDamage:
	mov	BYTE PTR _bLog$[esp+172], 0
$LN11@PlotDamage:

; 2126 : 
; 2127 : 	// See how many moves of this type we can execute
; 2128 : 	CvTacticalTarget* pTarget;
; 2129 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_CITY);

	push	1
	mov	ecx, esi
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	DWORD PTR _pTarget$[esp+172], eax

; 2130 : 	while(pTarget != NULL)

	test	eax, eax
	je	$LN165@PlotDamage
	push	ebp
	push	edi
	jmp	SHORT $LN7@PlotDamage
	npad	8
$LL166@PlotDamage:
	mov	eax, DWORD PTR _pTarget$[esp+180]
$LN7@PlotDamage:

; 2131 : 	{
; 2132 : 		// See what units we have who can reach target this turn
; 2133 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	ebp, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN169@PlotDamage
	cmp	ebp, -2147483647			; 80000001H
	je	$LN169@PlotDamage
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN34@PlotDamage
	test	eax, eax
	jge	SHORT $LN36@PlotDamage
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN38@PlotDamage
$LN36@PlotDamage:
	cmp	eax, ecx
	jl	SHORT $LN34@PlotDamage
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN38@PlotDamage
$LN34@PlotDamage:
	mov	esi, eax
$LN38@PlotDamage:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN167@PlotDamage
	test	ebp, ebp
	jge	SHORT $LN46@PlotDamage
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN48@PlotDamage
$LN46@PlotDamage:
	cmp	ebp, edi
	jl	SHORT $LN167@PlotDamage
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN48@PlotDamage
$LN167@PlotDamage:
	mov	edx, ebp
$LN48@PlotDamage:
	test	esi, esi
	jl	$LN169@PlotDamage
	cmp	esi, ecx
	jge	$LN169@PlotDamage
	test	edx, edx
	jl	$LN169@PlotDamage
	cmp	edx, edi
	jge	$LN169@PlotDamage
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	ebp, ecx

; 2134 : 		if(pPlot != NULL)

	je	$LN169@PlotDamage

; 2135 : 		{
; 2136 : 			m_CurrentMoveCities.clear();

	mov	esi, DWORD PTR _this$[esp+180]
	mov	edx, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR [esi+56]
	cmp	ecx, edx
	je	SHORT $LN76@PlotDamage
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN101@PlotDamage
$LL103@PlotDamage:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edi
	add	eax, 12					; 0000000cH
	add	ecx, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL103@PlotDamage
$LN101@PlotDamage:
	mov	DWORD PTR [esi+60], ecx
$LN76@PlotDamage:

; 2137 : 			if(FindUnitsWithinStrikingDistance(pPlot, 1, 0, false /*bNoRangedUnits*/, false /*bNavalOnly*/, false /*bMustMoveThrough*/, true /*bIncludeBlockedUnits*/))

	push	0
	push	0
	push	1
	push	0
	push	0
	push	0
	push	0
	push	1
	push	ebp
	mov	ecx, esi
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
	test	al, al
	je	$LN169@PlotDamage

; 2138 : 			{
; 2139 : 				CvCity* pCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [ebp+104]
	test	eax, eax
	jl	$LN169@PlotDamage
	cmp	eax, 64					; 00000040H
	jge	$LN169@PlotDamage
	mov	ecx, DWORD PTR [ebp+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 2140 : 				if(pCity != NULL)

	test	esi, esi
	je	$LN169@PlotDamage

; 2141 : 				{
; 2142 : 					iRequiredDamage = pCity->GetMaxHitPoints() - pCity->getDamage();

	mov	ecx, esi
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, esi
	mov	edi, eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage

; 2143 : 					pTarget->SetAuxIntData(iRequiredDamage);

	mov	ebx, DWORD PTR _pTarget$[esp+180]

; 2144 : 
; 2145 : 					// Don't want to hammer away to try and take down a city for more than 8 turns
; 2146 : 					if(ComputeTotalExpectedDamage(pTarget, pPlot) > (iRequiredDamage / 8))

	mov	ecx, DWORD PTR _this$[esp+180]
	push	ebp
	sub	edi, eax
	push	ebx
	mov	DWORD PTR [ebx+20], edi
	call	?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z ; CvTacticalAI::ComputeTotalExpectedDamage
	mov	ecx, eax
	mov	eax, edi
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	cmp	ecx, eax
	jle	$LN169@PlotDamage

; 2147 : 					{
; 2148 : 						// Log result
; 2149 : 						if(bLog)

	cmp	BYTE PTR _bLog$[esp+180], 0
	je	$LN168@PlotDamage

; 2150 : 						{
; 2151 : 							CvString strPlayerName, strCityName, strLogString, strTemp;

	lea	ecx, DWORD PTR _strPlayerName$221241[esp+180]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strCityName$221242[esp+180]
	mov	DWORD PTR __$EHRec$[esp+188], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$221243[esp+180]
	mov	BYTE PTR __$EHRec$[esp+188], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$221244[esp+180]
	mov	BYTE PTR __$EHRec$[esp+188], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2152 : 							strPlayerName = GET_PLAYER(pCity->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [esi+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+188], 3
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$221241[esp+180]
	test	eax, eax
	je	SHORT $LN132@PlotDamage
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN131@PlotDamage
$LN132@PlotDamage:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN131@PlotDamage:

; 2153 : 							strCityName = pCity->getName();

	lea	edx, DWORD PTR $T292517[esp+180]
	push	edx
	mov	ecx, esi
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _strCityName$221242[esp+184]
	mov	BYTE PTR __$EHRec$[esp+192], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T292517[esp+180]
	mov	BYTE PTR __$EHRec$[esp+188], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2154 : 							strLogString.Format("Attacking city of ");

	lea	eax, DWORD PTR _strLogString$221243[esp+180]
	push	OFFSET $SG221246
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 2155 : 							strLogString += strCityName;

	lea	ecx, DWORD PTR _strCityName$221242[esp+180]
	push	ecx
	lea	ecx, DWORD PTR _strLogString$221243[esp+184]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2156 : 							strTemp.Format(" to damage, X: %d, Y: %d,", pCity->getX(), pCity->getY());

	mov	eax, DWORD PTR [esi+108]
	mov	esi, DWORD PTR [esi+96]
	push	eax
	push	esi
	lea	edx, DWORD PTR _strTemp$221244[esp+188]
	push	OFFSET $SG221247
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2157 : 							strLogString += strTemp + strPlayerName;

	lea	eax, DWORD PTR _strPlayerName$221241[esp+196]
	push	eax
	lea	ecx, DWORD PTR _strTemp$221244[esp+200]
	push	ecx
	lea	edx, DWORD PTR $T292518[esp+204]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR _strLogString$221243[esp+184]
	mov	BYTE PTR __$EHRec$[esp+192], 5
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T292518[esp+180]
	mov	BYTE PTR __$EHRec$[esp+188], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2158 : 							LogTacticalMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+180]
	push	1
	lea	eax, DWORD PTR _strLogString$221243[esp+184]
	push	eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2159 : 						}

	lea	ecx, DWORD PTR _strTemp$221244[esp+180]
	mov	BYTE PTR __$EHRec$[esp+188], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$221243[esp+180]
	mov	BYTE PTR __$EHRec$[esp+188], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strCityName$221242[esp+180]
	mov	BYTE PTR __$EHRec$[esp+188], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$221241[esp+180]
	mov	DWORD PTR __$EHRec$[esp+188], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN168@PlotDamage:

; 2160 : 
; 2161 : 						// If so, execute enough moves to take it
; 2162 : 						ExecuteAttack(pTarget, pPlot, false, true);

	mov	ecx, DWORD PTR _this$[esp+180]
	push	1
	push	0
	push	ebp
	push	ebx
	call	?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z ; CvTacticalAI::ExecuteAttack

; 2163 : 						bAttackMade = true;

	mov	BYTE PTR _bAttackMade$[esp+180], 1
$LN169@PlotDamage:

; 2164 : 					}
; 2165 : 				}
; 2166 : 			}
; 2167 : 		}
; 2168 : 		pTarget = GetNextZoneTarget();

	mov	ecx, DWORD PTR _this$[esp+180]
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	DWORD PTR _pTarget$[esp+180], eax
	test	eax, eax
	jne	$LL166@PlotDamage

; 2169 : 	}
; 2170 : 	return bAttackMade;

	mov	al, BYTE PTR _bAttackMade$[esp+180]
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 2171 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+164]
	mov	DWORD PTR fs:0, ecx
	add	esp, 164				; 000000a4H
	ret	0
$LN165@PlotDamage:
	mov	ecx, DWORD PTR __$EHRec$[esp+172]
	pop	esi
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 164				; 000000a4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ$0:
	lea	ecx, DWORD PTR _strPlayerName$221241[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ$1:
	lea	ecx, DWORD PTR _strCityName$221242[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ$2:
	lea	ecx, DWORD PTR _strLogString$221243[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ$3:
	lea	ecx, DWORD PTR _strTemp$221244[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ$4:
	lea	ecx, DWORD PTR $T292517[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ$5:
	lea	ecx, DWORD PTR $T292518[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ ENDP		; CvTacticalAI::PlotDamageCityMoves
PUBLIC	?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotBarbarianCampMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_bLog$ = -45						; size = 1
_this$ = -44						; size = 4
_strLogString$221260 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotBarbarianCampMoves, COMDAT
; _this$ = ecx

; 2175 : {

	push	-1
	push	__ehhandler$?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	edi
	mov	edi, ecx

; 2176 : 	bool bLog = GC.getLogging() && GC.getAILogging();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+52], edi
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN7@PlotBarbar@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	mov	BYTE PTR _bLog$[esp+52], 1
	test	al, al
	jne	SHORT $LN8@PlotBarbar@3
$LN7@PlotBarbar@3:
	mov	BYTE PTR _bLog$[esp+52], 0
$LN8@PlotBarbar@3:

; 2177 : 	CvTacticalTarget* pTarget;
; 2178 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_BARBARIAN_CAMP);

	push	2
	mov	ecx, edi
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget

; 2179 : 	while(pTarget != NULL)

	test	eax, eax
	je	$LN3@PlotBarbar@3
	push	ebx
	push	ebp
	push	esi
	npad	7
$LL4@PlotBarbar@3:

; 2180 : 	{
; 2181 : 		// See what units we have who can reach target this turn
; 2182 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	ebp, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN16@PlotBarbar@3
	cmp	ebp, -2147483647			; 80000001H
	je	$LN16@PlotBarbar@3
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN26@PlotBarbar@3
	test	eax, eax
	jge	SHORT $LN28@PlotBarbar@3
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN30@PlotBarbar@3
$LN28@PlotBarbar@3:
	cmp	eax, ecx
	jl	SHORT $LN26@PlotBarbar@3
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN30@PlotBarbar@3
$LN26@PlotBarbar@3:
	mov	esi, eax
$LN30@PlotBarbar@3:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN67@PlotBarbar@3
	test	ebp, ebp
	jge	SHORT $LN38@PlotBarbar@3
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN40@PlotBarbar@3
$LN38@PlotBarbar@3:
	cmp	ebp, edi
	jl	SHORT $LN67@PlotBarbar@3
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN40@PlotBarbar@3
$LN67@PlotBarbar@3:
	mov	edx, ebp
$LN40@PlotBarbar@3:
	test	esi, esi
	jl	SHORT $LN20@PlotBarbar@3
	cmp	esi, ecx
	jge	SHORT $LN20@PlotBarbar@3
	test	edx, edx
	jl	SHORT $LN20@PlotBarbar@3
	cmp	edx, edi
	jge	SHORT $LN20@PlotBarbar@3
	mov	edi, DWORD PTR _this$[esp+64]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	esi, ecx
	jmp	SHORT $LN18@PlotBarbar@3
$LN20@PlotBarbar@3:
	mov	edi, DWORD PTR _this$[esp+64]
$LN16@PlotBarbar@3:
	xor	esi, esi
$LN18@PlotBarbar@3:

; 2183 : 		if(FindUnitsWithinStrikingDistance(pPlot, 1, 0, false /* bNoRangedUnits */, false /*bNavalOnly*/, false /*bMustMoveThrough*/, false /*bIncludeBlockedUnits*/, false /*bWillPillage*/, true /*bTargetUndefended*/))

	push	1
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	1
	push	esi
	mov	ecx, edi
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
	test	al, al
	je	SHORT $LN2@PlotBarbar@3

; 2184 : 		{
; 2185 : 			// Queue best one up to capture it
; 2186 : 			ExecuteBarbarianCampMove(pPlot);

	push	esi
	mov	ecx, edi
	call	?ExecuteBarbarianCampMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteBarbarianCampMove

; 2187 : 			if(bLog)

	cmp	BYTE PTR _bLog$[esp+64], 0
	je	SHORT $LN1@PlotBarbar@3

; 2188 : 			{
; 2189 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221260[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2190 : 				strLogString.Format("Removing barbarian camp, X: %d, Y: %d", pPlot->getX(), pPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$221260[esp+72]
	push	OFFSET $SG221261
	push	edx
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2191 : 				LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$221260[esp+68]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2192 : 			}

	lea	ecx, DWORD PTR _strLogString$221260[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@PlotBarbar@3:

; 2193 : 			DeleteTemporaryZone(pPlot);

	push	esi
	mov	ecx, edi
	call	?DeleteTemporaryZone@CvTacticalAI@@QAEXPAVCvPlot@@@Z ; CvTacticalAI::DeleteTemporaryZone
$LN2@PlotBarbar@3:

; 2194 : 		}
; 2195 : 		pTarget = GetNextZoneTarget();

	mov	ecx, edi
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	test	eax, eax
	jne	$LL4@PlotBarbar@3
	pop	esi
	pop	ebp
	pop	ebx
$LN3@PlotBarbar@3:

; 2196 : 	}
; 2197 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$221260[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotBarbarianCampMoves
PUBLIC	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z
_TEXT	SEGMENT
_this$ = -208						; size = 4
_pTarget$ = -204					; size = 4
_pPlot$221276 = -200					; size = 4
_bMustInflictWhatWeTake$221301 = -196			; size = 1
_pDefender$221277 = -192				; size = 8
_strLogString$221306 = -184				; size = 28
$T293104 = -156						; size = 4
_strTemp$221307 = -152					; size = 28
_strLogString$221284 = -124				; size = 28
_strTemp$221287 = -96					; size = 28
_strPlayerName$221308 = -68				; size = 28
_strPlayerName$221285 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_targetType$ = 8					; size = 4
_bMustBeAbleToKill$ = 12				; size = 1
_bAttackAtPoorOdds$ = 16				; size = 1
?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z PROC ; CvTacticalAI::PlotDestroyUnitMoves, COMDAT
; _this$ = ecx

; 2201 : {

	push	-1
	push	__ehhandler$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H

; 2202 : 	int iRequiredDamage;
; 2203 : 	int iExpectedDamage;
; 2204 : 
; 2205 : 	// See how many moves of this type we can execute
; 2206 : 	CvTacticalTarget* pTarget = GetFirstZoneTarget(targetType);

	mov	eax, DWORD PTR _targetType$[esp+204]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	push	eax
	mov	DWORD PTR _this$[esp+228], edi
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	ebp, eax
	mov	DWORD PTR _pTarget$[esp+224], ebp

; 2207 : 	while(pTarget != NULL)

	test	ebp, ebp
	je	$LN22@PlotDestro
	jmp	SHORT $LN23@PlotDestro
$LL264@PlotDestro:
	mov	ebp, DWORD PTR _pTarget$[esp+224]
$LN23@PlotDestro:

; 2208 : 	{
; 2209 : 		bool bUnitCanAttack = false;
; 2210 : 		bool bCityCanAttack = false;
; 2211 : 
; 2212 : 		// See what units we have who can reach targets this turn
; 2213 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [ebp+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN42@PlotDestro
	cmp	ebx, -2147483647			; 80000001H
	je	$LN42@PlotDestro
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	dl, dl
	je	SHORT $LN52@PlotDestro
	test	eax, eax
	jge	SHORT $LN54@PlotDestro
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN56@PlotDestro
$LN54@PlotDestro:
	cmp	eax, ecx
	jl	SHORT $LN52@PlotDestro
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN56@PlotDestro
$LN52@PlotDestro:
	mov	esi, eax
$LN56@PlotDestro:
	mov	al, BYTE PTR [ebp+4057]
	mov	edi, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN265@PlotDestro
	test	ebx, ebx
	jge	SHORT $LN64@PlotDestro
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN66@PlotDestro
$LN64@PlotDestro:
	cmp	ebx, edi
	jl	SHORT $LN265@PlotDestro
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN66@PlotDestro
$LN265@PlotDestro:
	mov	edx, ebx
$LN66@PlotDestro:
	test	esi, esi
	jl	SHORT $LN46@PlotDestro
	cmp	esi, ecx
	jge	SHORT $LN46@PlotDestro
	test	edx, edx
	jl	SHORT $LN46@PlotDestro
	cmp	edx, edi
	jge	SHORT $LN46@PlotDestro
	mov	edi, DWORD PTR _this$[esp+224]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	ebp, DWORD PTR _pTarget$[esp+224]
	mov	DWORD PTR _pPlot$221276[esp+224], ecx
	jmp	SHORT $LN44@PlotDestro
$LN46@PlotDestro:
	mov	ebp, DWORD PTR _pTarget$[esp+224]
	mov	edi, DWORD PTR _this$[esp+224]
$LN42@PlotDestro:
	mov	DWORD PTR _pPlot$221276[esp+224], 0
$LN44@PlotDestro:

; 2214 : 		UnitHandle pDefender = pPlot->getVisibleEnemyDefender(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+44]
	mov	ebx, DWORD PTR _pPlot$221276[esp+224]
	push	eax
	mov	ecx, ebx
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	mov	esi, eax
	mov	DWORD PTR _pDefender$221277[esp+224], esi
	mov	BYTE PTR _pDefender$221277[esp+228], 0
	test	esi, esi
	je	SHORT $LN87@PlotDestro
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN87@PlotDestro:
	mov	DWORD PTR __$EHRec$[esp+232], 0

; 2215 : 		if(pDefender)

	test	esi, esi
	je	$LN269@PlotDestro

; 2216 : 		{
; 2217 : 			bUnitCanAttack = FindUnitsWithinStrikingDistance(pPlot, 1, 0, false /* bNoRangedUnits */);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	1
	push	ebx
	mov	ecx, edi
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance

; 2218 : 			bCityCanAttack = FindCitiesWithinStrikingDistance(pPlot);

	mov	edx, DWORD PTR _pPlot$221276[esp+224]
	push	edx
	mov	ecx, edi
	mov	bl, al
	call	?FindCitiesWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z ; CvTacticalAI::FindCitiesWithinStrikingDistance

; 2219 : 			if(bUnitCanAttack || bCityCanAttack)

	test	bl, bl
	jne	SHORT $LN19@PlotDestro
	test	al, al
	je	$LN269@PlotDestro
$LN19@PlotDestro:

; 2220 : 			{
; 2221 : 				iExpectedDamage = ComputeTotalExpectedDamage(pTarget, pPlot);

	mov	ebx, DWORD PTR _pPlot$221276[esp+224]
	push	ebx
	push	ebp
	mov	ecx, edi
	call	?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z ; CvTacticalAI::ComputeTotalExpectedDamage

; 2222 : 				iExpectedDamage += ComputeTotalExpectedBombardDamage(pDefender);

	sub	esp, 8
	mov	ebp, eax
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T293104[esp+232], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::ComputeTotalExpectedBombardDamage

; 2223 : 				iRequiredDamage = pDefender->GetCurrHitPoints();

	mov	ecx, esi
	add	ebp, eax
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints

; 2224 : 				pTarget->SetAuxIntData(iRequiredDamage);
; 2225 : 
; 2226 : 				if(!bMustBeAbleToKill)

	cmp	BYTE PTR _bMustBeAbleToKill$[esp+220], 0
	mov	edi, eax
	mov	eax, DWORD PTR _pTarget$[esp+224]
	mov	DWORD PTR [eax+20], edi
	jne	$LN18@PlotDestro

; 2227 : 				{
; 2228 : 					// Put in any attacks where we'll inflict at least equal damage
; 2229 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN266@PlotDestro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN266@PlotDestro

; 2230 : 					{
; 2231 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221284[esp+224]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2232 : 
; 2233 : 						CvString strPlayerName = GET_PLAYER(pDefender->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [esi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+232], 1
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	test	eax, eax
	jne	SHORT $LN114@PlotDestro
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN114@PlotDestro:
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$221285[esp+228]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2234 : 
; 2235 : 						CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pDefender->getUnitType());

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+232], 2
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 2236 : 						CvString strTemp = (pkUnitInfo != NULL)? pkUnitInfo->GetDescription() : "Unknown Unit Type";

	test	eax, eax
	je	SHORT $LN26@PlotDestro
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	jne	SHORT $LN123@PlotDestro
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN123@PlotDestro:
	push	eax
	lea	ecx, DWORD PTR _strTemp$221287[esp+228]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2237 : 
; 2238 : 						switch(targetType)

	mov	eax, DWORD PTR _targetType$[esp+220]
	sub	eax, 5
	mov	BYTE PTR __$EHRec$[esp+232], 3
	je	SHORT $LN12@PlotDestro
	sub	eax, 1
	je	SHORT $LN13@PlotDestro
	sub	eax, 1
	jne	SHORT $LN15@PlotDestro

; 2239 : 						{
; 2240 : 						case AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT:
; 2241 : 							strLogString.Format("Looking at damaging high priority %s, X: %d, Y: %d,", strTemp.GetCString(),
; 2242 : 							                    pDefender->getX(), pDefender->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$221287[esp+232]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG221294
	lea	ecx, DWORD PTR _strLogString$221284[esp+240]
	push	ecx

; 2243 : 							break;

	jmp	SHORT $LN271@PlotDestro
$LN26@PlotDestro:

; 2236 : 						CvString strTemp = (pkUnitInfo != NULL)? pkUnitInfo->GetDescription() : "Unknown Unit Type";

	mov	eax, OFFSET $SG221288
	jmp	SHORT $LN123@PlotDestro
$LN13@PlotDestro:

; 2244 : 						case AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT:
; 2245 : 							strLogString.Format("Looking at damaging medium priority %s, X: %d, Y: %d,", strTemp.GetCString(),
; 2246 : 							                    pDefender->getX(), pDefender->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$221287[esp+232]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG221296
	lea	edx, DWORD PTR _strLogString$221284[esp+240]
	push	edx

; 2247 : 							break;

	jmp	SHORT $LN271@PlotDestro
$LN12@PlotDestro:

; 2248 : 						case AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT:
; 2249 : 							strLogString.Format("Looking at damaging low priority %s, X: %d, Y: %d,", strTemp.GetCString(),
; 2250 : 							                    pDefender->getX(), pDefender->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$221287[esp+232]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG221298
	lea	eax, DWORD PTR _strLogString$221284[esp+240]
	push	eax
$LN271@PlotDestro:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
$LN15@PlotDestro:

; 2251 : 							break;
; 2252 : 						}
; 2253 : 						strLogString += strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$221285[esp+224]
	push	ecx
	lea	ecx, DWORD PTR _strLogString$221284[esp+228]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2254 : 						LogTacticalMessage(strLogString);

	mov	ebx, DWORD PTR _this$[esp+224]
	push	1
	lea	edx, DWORD PTR _strLogString$221284[esp+228]
	push	edx
	mov	ecx, ebx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2255 : 					}

	lea	ecx, DWORD PTR _strTemp$221287[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$221285[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$221284[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	SHORT $LN17@PlotDestro
$LN266@PlotDestro:
	mov	ebx, DWORD PTR _this$[esp+224]
$LN17@PlotDestro:

; 2256 : 
; 2257 : 					// Attack no matter what
; 2258 : 					if(bAttackAtPoorOdds)

	cmp	BYTE PTR _bAttackAtPoorOdds$[esp+220], 0
	je	SHORT $LN11@PlotDestro

; 2259 : 					{
; 2260 : 						ExecuteAttack(pTarget, pPlot, false, false);

	mov	eax, DWORD PTR _pPlot$221276[esp+224]
	mov	ecx, DWORD PTR _pTarget$[esp+224]
	push	0
	push	0
	push	eax
	push	ecx
	mov	ecx, ebx

; 2261 : 					}
; 2262 : 					// If we can at least knock the defender to 40% strength with our combined efforts, go ahead even if each individual attack isn't favorable
; 2263 : 					else

	jmp	$LN273@PlotDestro
$LN11@PlotDestro:

; 2264 : 					{
; 2265 : 						bool bMustInflictWhatWeTake = true;
; 2266 : 						if (iExpectedDamage >= (iRequiredDamage * 40) / 100)

	lea	ecx, DWORD PTR [edi+edi*4]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	mov	BYTE PTR _bMustInflictWhatWeTake$221301[esp+224], 1
	jl	SHORT $LN9@PlotDestro

; 2267 : 						{
; 2268 : 							bMustInflictWhatWeTake = false;

	mov	BYTE PTR _bMustInflictWhatWeTake$221301[esp+224], 0
$LN9@PlotDestro:

; 2269 : 						}
; 2270 : 						ExecuteAttack(pTarget, pPlot, bMustInflictWhatWeTake, true);

	mov	ecx, DWORD PTR _bMustInflictWhatWeTake$221301[esp+224]
	mov	edx, DWORD PTR _pPlot$221276[esp+224]
	mov	eax, DWORD PTR _pTarget$[esp+224]
	push	1
	push	ecx
	push	edx
	push	eax
	mov	ecx, ebx

; 2271 : 					}
; 2272 : 				}
; 2273 : 
; 2274 : 				// Do we have enough firepower to destroy it?
; 2275 : 				else

	jmp	$LN273@PlotDestro
$LN18@PlotDestro:

; 2276 : 				{
; 2277 : 					if(iExpectedDamage > iRequiredDamage)

	cmp	ebp, edi
	jle	$LN268@PlotDestro

; 2278 : 					{
; 2279 : 						// If so, execute enough moves to destroy it
; 2280 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN267@PlotDestro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN267@PlotDestro

; 2281 : 						{
; 2282 : 							CvString strLogString, strTemp, strPlayerName;

	lea	ecx, DWORD PTR _strLogString$221306[esp+224]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$221307[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$221308[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 5
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2283 : 							strPlayerName = GET_PLAYER(pDefender->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [esi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+232], 6
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$221308[esp+224]
	test	eax, eax
	je	SHORT $LN194@PlotDestro
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN193@PlotDestro
$LN194@PlotDestro:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN193@PlotDestro:

; 2284 : #ifdef AUI_WARNING_FIXES
; 2285 : 							CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pDefender->getUnitType());
; 2286 : 							strTemp = (pkUnitInfo != NULL) ? pkUnitInfo->GetDescription() : "Unknown Unit Type";
; 2287 : #else
; 2288 : 							strTemp = GC.getUnitInfo(pDefender->getUnitType())->GetDescription();

	mov	ecx, esi
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$221307[esp+224]
	test	eax, eax
	je	SHORT $LN202@PlotDestro
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN201@PlotDestro
$LN202@PlotDestro:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN201@PlotDestro:

; 2289 : #endif
; 2290 : 							switch(targetType)

	mov	eax, DWORD PTR _targetType$[esp+220]
	sub	eax, 5
	je	SHORT $LN1@PlotDestro
	sub	eax, 1
	je	SHORT $LN2@PlotDestro
	sub	eax, 1
	jne	SHORT $LN4@PlotDestro

; 2291 : 							{
; 2292 : 							case AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT:
; 2293 : 								strLogString.Format("Looking at killing high priority %s, X: %d, Y: %d,", strTemp.GetCString(),
; 2294 : 								                    pDefender->getX(), pDefender->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$221307[esp+232]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG221314
	lea	ecx, DWORD PTR _strLogString$221306[esp+240]
	push	ecx

; 2295 : 								break;

	jmp	SHORT $LN272@PlotDestro
$LN2@PlotDestro:

; 2296 : 							case AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT:
; 2297 : 								strLogString.Format("Looking at killing medium priority %s, X: %d, Y: %d,", strTemp.GetCString(),
; 2298 : 								                    pDefender->getX(), pDefender->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$221307[esp+232]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG221316
	lea	edx, DWORD PTR _strLogString$221306[esp+240]
	push	edx

; 2299 : 								break;

	jmp	SHORT $LN272@PlotDestro
$LN1@PlotDestro:

; 2300 : 							case AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT:
; 2301 : 								strLogString.Format("Looking at killing low priority %s, X: %d, Y: %d,", strTemp.GetCString(),
; 2302 : 								                    pDefender->getX(), pDefender->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$221307[esp+232]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG221318
	lea	eax, DWORD PTR _strLogString$221306[esp+240]
	push	eax
$LN272@PlotDestro:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
$LN4@PlotDestro:

; 2303 : 								break;
; 2304 : 							}
; 2305 : 							strLogString += strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$221308[esp+224]
	push	ecx
	lea	ecx, DWORD PTR _strLogString$221306[esp+228]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2306 : 							LogTacticalMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+224]
	push	1
	lea	edx, DWORD PTR _strLogString$221306[esp+228]
	push	edx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2307 : 						}

	lea	ecx, DWORD PTR _strPlayerName$221308[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$221307[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$221306[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN267@PlotDestro:

; 2308 : 						ExecuteAttack(pTarget, pPlot, false, (targetType != AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT));

	cmp	DWORD PTR _targetType$[esp+220], 7
	mov	edx, DWORD PTR _pTarget$[esp+224]
	setne	al
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+228]
	push	0
	push	ebx
	push	edx
$LN273@PlotDestro:
	call	?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z ; CvTacticalAI::ExecuteAttack
$LN268@PlotDestro:
	mov	edi, DWORD PTR _this$[esp+224]
$LN269@PlotDestro:

; 2309 : 					}
; 2310 : 				}
; 2311 : 			}
; 2312 : 		}
; 2313 : 		pTarget = GetNextZoneTarget();

	mov	ecx, edi
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	ebx, eax
	mov	DWORD PTR _pTarget$[esp+224], ebx

; 2314 : 	}

	mov	DWORD PTR __$EHRec$[esp+232], -1
	test	esi, esi
	je	SHORT $LN259@PlotDestro
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN259@PlotDestro:

; 2207 : 	while(pTarget != NULL)

	test	ebx, ebx
	jne	$LL264@PlotDestro
$LN22@PlotDestro:

; 2315 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+224]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 208				; 000000d0H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$0:
	lea	ecx, DWORD PTR _pDefender$221277[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$2:
	lea	ecx, DWORD PTR _strLogString$221284[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$3:
	lea	ecx, DWORD PTR _strPlayerName$221285[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$4:
	lea	ecx, DWORD PTR _strTemp$221287[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$5:
	lea	ecx, DWORD PTR _strLogString$221306[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$6:
	lea	ecx, DWORD PTR _strTemp$221307[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z$7:
	lea	ecx, DWORD PTR _strPlayerName$221308[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ENDP ; CvTacticalAI::PlotDestroyUnitMoves
PUBLIC	?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z ; CvTacticalAI::PlotBarbarianPlunderTradeUnitMove
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z$0
__ehfuncinfo$?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
_bNavalOnly$ = -44					; size = 1
_strLogString$221532 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
_eDomain$ = 8						; size = 4
?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z PROC ; CvTacticalAI::PlotBarbarianPlunderTradeUnitMove, COMDAT
; _this$ = ecx

; 2502 : {

	push	-1
	push	__ehhandler$?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H

; 2503 : 	AITacticalTargetType eTargetType = AI_TACTICAL_TARGET_NONE;
; 2504 : 	bool bNavalOnly = false;
; 2505 : 	if (eDomain == DOMAIN_LAND)

	mov	eax, DWORD PTR _eDomain$[esp+44]
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+52], ebx
	mov	BYTE PTR _bNavalOnly$[esp+52], 0
	cmp	eax, 2
	jne	SHORT $LN8@PlotBarbar@4

; 2506 : 	{
; 2507 : 		eTargetType = AI_TACTICAL_TARGET_TRADE_UNIT_LAND;

	mov	eax, 20					; 00000014H
	jmp	SHORT $LN68@PlotBarbar@4
$LN8@PlotBarbar@4:

; 2508 : 	}
; 2509 : 	else if (eDomain == DOMAIN_SEA)

	test	eax, eax
	jne	$LN3@PlotBarbar@4

; 2510 : 	{
; 2511 : 		eTargetType = AI_TACTICAL_TARGET_TRADE_UNIT_SEA;

	mov	eax, 19					; 00000013H

; 2512 : 		bNavalOnly = true;

	mov	BYTE PTR _bNavalOnly$[esp+52], 1
$LN68@PlotBarbar@4:
	push	edi

; 2513 : 	}
; 2514 : 
; 2515 : 	CvAssertMsg(eTargetType != AI_TACTICAL_TARGET_NONE, "Undefined domain type for target");
; 2516 : 	if (eTargetType == AI_TACTICAL_TARGET_NONE)
; 2517 : 	{
; 2518 : 		return;
; 2519 : 	}
; 2520 : 
; 2521 : 	CvTacticalTarget* pTarget;
; 2522 : 	pTarget = GetFirstZoneTarget(eTargetType);

	push	eax
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	edi, eax
	mov	DWORD PTR _pTarget$[esp+52], edi

; 2523 : 	while(pTarget != NULL)

	test	edi, edi
	je	$LN73@PlotBarbar@4
	push	ebp
	push	esi
	jmp	SHORT $LN4@PlotBarbar@4
	npad	1
$LL70@PlotBarbar@4:
	mov	edi, DWORD PTR _pTarget$[esp+60]
$LN4@PlotBarbar@4:

; 2524 : 	{
; 2525 : 		// See what units we have who can reach target this turn
; 2526 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+4]
	mov	ebp, DWORD PTR [edi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN18@PlotBarbar@4
	cmp	ebp, -2147483647			; 80000001H
	je	$LN18@PlotBarbar@4
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN28@PlotBarbar@4
	test	eax, eax
	jge	SHORT $LN30@PlotBarbar@4
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN32@PlotBarbar@4
$LN30@PlotBarbar@4:
	cmp	eax, ecx
	jl	SHORT $LN28@PlotBarbar@4
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN32@PlotBarbar@4
$LN28@PlotBarbar@4:
	mov	esi, eax
$LN32@PlotBarbar@4:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN71@PlotBarbar@4
	test	ebp, ebp
	jge	SHORT $LN40@PlotBarbar@4
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN42@PlotBarbar@4
$LN40@PlotBarbar@4:
	cmp	ebp, edi
	jl	SHORT $LN71@PlotBarbar@4
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN42@PlotBarbar@4
$LN71@PlotBarbar@4:
	mov	edx, ebp
$LN42@PlotBarbar@4:
	test	esi, esi
	jl	SHORT $LN22@PlotBarbar@4
	cmp	esi, ecx
	jge	SHORT $LN22@PlotBarbar@4
	test	edx, edx
	jl	SHORT $LN22@PlotBarbar@4
	cmp	edx, edi
	jge	SHORT $LN22@PlotBarbar@4
	mov	edi, DWORD PTR _pTarget$[esp+60]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	ebx, DWORD PTR _this$[esp+64]
	mov	esi, ecx
	jmp	SHORT $LN20@PlotBarbar@4
$LN22@PlotBarbar@4:
	mov	edi, DWORD PTR _pTarget$[esp+60]
	mov	ebx, DWORD PTR _this$[esp+64]
$LN18@PlotBarbar@4:
	xor	esi, esi
$LN20@PlotBarbar@4:

; 2527 : 
; 2528 : 		if (FindUnitsWithinStrikingDistance(pPlot, 0, 0, false /* bNoRangedUnits */, bNavalOnly, true /*bMustMoveThrough*/, false /*bIncludeBlockedUnits*/, false /*bWillPillage*/))

	mov	eax, DWORD PTR _bNavalOnly$[esp+64]
	push	0
	push	0
	push	0
	push	1
	push	eax
	push	0
	push	0
	push	0
	push	esi
	mov	ecx, ebx
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
	test	al, al
	je	SHORT $LN1@PlotBarbar@4

; 2529 : 		{
; 2530 : 			// Queue best one up to capture it
; 2531 : 			ExecutePlunderTradeUnit(pPlot);

	push	esi
	mov	ecx, ebx
	call	?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecutePlunderTradeUnit

; 2532 : 
; 2533 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@PlotBarbar@4
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@PlotBarbar@4

; 2534 : 			{
; 2535 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221532[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2536 : 				strLogString.Format("Plundering trade unit, X: %d, Y: %d", pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strLogString$221532[esp+72]
	push	OFFSET $SG221533
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2537 : 				LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$221532[esp+68]
	push	edx
	mov	ecx, ebx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2538 : 			}

	lea	ecx, DWORD PTR _strLogString$221532[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@PlotBarbar@4:

; 2539 : 		}
; 2540 : 
; 2541 : 		pTarget = GetNextZoneTarget();

	mov	ecx, ebx
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	DWORD PTR _pTarget$[esp+60], eax
	test	eax, eax
	jne	$LL70@PlotBarbar@4
	pop	esi
	pop	ebp
$LN73@PlotBarbar@4:
	pop	edi
$LN3@PlotBarbar@4:

; 2542 : 	}
; 2543 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z$0:
	lea	ecx, DWORD PTR _strLogString$221532[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z ENDP ; CvTacticalAI::PlotBarbarianPlunderTradeUnitMove
PUBLIC	?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z ; CvTacticalAI::PlotPillageMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z$3
__ehfuncinfo$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z
_TEXT	SEGMENT
_iPillageHeal$ = -100					; size = 4
_szTargetName$ = -96					; size = 28
_strLogString$221595 = -68				; size = 28
_strLogString$221590 = -68				; size = 28
_strLogString$221600 = -40				; size = 28
__$EHRec$ = -12						; size = 12
$T293760 = 8						; size = 4
_eTarget$ = 8						; size = 4
_bFirstPass$ = 12					; size = 1
?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z PROC ; CvTacticalAI::PlotPillageMoves, COMDAT
; _this$ = ecx

; 2607 : {

	push	-1
	push	__ehhandler$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 2608 : 	int iPillageHeal = GC.getPILLAGE_HEAL_AMOUNT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8184
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 2609 : 
; 2610 : 	CvString szTargetName = "";

	push	OFFSET $SG221574
	lea	ecx, DWORD PTR _szTargetName$[esp+116]
	mov	DWORD PTR _iPillageHeal$[esp+116], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2611 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+120], 0
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	mov	esi, DWORD PTR _eTarget$[esp+108]
	test	al, al
	je	SHORT $LN11@PlotPillag
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN11@PlotPillag

; 2612 : 	{
; 2613 : 		if (eTarget == AI_TACTICAL_TARGET_CITADEL)
; 2614 : 		{
; 2615 : 			szTargetName = "Citadel";

	lea	ecx, DWORD PTR _szTargetName$[esp+112]
	cmp	esi, 23					; 00000017H
	jne	SHORT $LN14@PlotPillag
	push	OFFSET $SG221577
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN11@PlotPillag
$LN14@PlotPillag:

; 2616 : 		}
; 2617 : 		else if (eTarget == AI_TACTICAL_TARGET_IMPROVEMENT_RESOURCE)

	cmp	esi, 24					; 00000018H
	jne	SHORT $LN12@PlotPillag

; 2618 : 		{
; 2619 : 			szTargetName = "Improved Resource";

	push	OFFSET $SG221580

; 2620 : 		}
; 2621 : 		else

	jmp	SHORT $LN123@PlotPillag
$LN12@PlotPillag:

; 2622 : 		{
; 2623 : 			szTargetName = "Improvement";

	push	OFFSET $SG221582
$LN123@PlotPillag:
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
$LN11@PlotPillag:

; 2624 : 		}
; 2625 : 	}
; 2626 : 
; 2627 : 	CvTacticalTarget* pTarget;
; 2628 : 	pTarget = GetFirstZoneTarget(eTarget);

	push	esi
	mov	ecx, ebp
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	edi, eax

; 2629 : 	while(pTarget != NULL)

	test	edi, edi
	je	$LN9@PlotPillag
	push	ebx
	npad	4
$LL10@PlotPillag:

; 2630 : 	{
; 2631 : 		// See what units we have who can reach target this turn
; 2632 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR $T293760[esp+112], edx
	cmp	eax, -2147483647			; 80000001H
	je	$LN39@PlotPillag
	cmp	edx, -2147483647			; 80000001H
	je	$LN39@PlotPillag
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	bl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	bl, bl
	je	SHORT $LN49@PlotPillag
	test	eax, eax
	jge	SHORT $LN51@PlotPillag
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR $T293760[esp+112]
	add	esi, ecx
	jmp	SHORT $LN53@PlotPillag
$LN51@PlotPillag:
	cmp	eax, ecx
	jl	SHORT $LN49@PlotPillag
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR $T293760[esp+112]
	jmp	SHORT $LN53@PlotPillag
$LN49@PlotPillag:
	mov	esi, eax
$LN53@PlotPillag:
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebx+4057]
	mov	ebx, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN120@PlotPillag
	test	edx, edx
	jge	SHORT $LN61@PlotPillag
	mov	eax, edx
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN120@PlotPillag
$LN61@PlotPillag:
	cmp	edx, ebx
	jl	SHORT $LN120@PlotPillag
	mov	eax, edx
	cdq
	idiv	ebx
$LN120@PlotPillag:
	test	esi, esi
	jl	SHORT $LN39@PlotPillag
	cmp	esi, ecx
	jge	SHORT $LN39@PlotPillag
	test	edx, edx
	jl	SHORT $LN39@PlotPillag
	cmp	edx, ebx
	jge	SHORT $LN39@PlotPillag
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	esi, ecx
	jmp	SHORT $LN41@PlotPillag
$LN39@PlotPillag:
	xor	esi, esi
$LN41@PlotPillag:

; 2633 : 
; 2634 : 		// try paratroopers first, not because they are more effective, just because it looks cooler...
; 2635 : 		if (bFirstPass && FindParatroopersWithinStrikingDistance(pPlot))

	cmp	BYTE PTR _bFirstPass$[esp+112], 0
	mov	ecx, ebp
	je	$LN118@PlotPillag
	push	esi
	call	?FindParatroopersWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z ; CvTacticalAI::FindParatroopersWithinStrikingDistance

; 2636 : 		{
; 2637 : 			// Queue best one up to capture it
; 2638 : 			ExecuteParadropPillage(pPlot);

	mov	ecx, ebp
	test	al, al
	je	SHORT $LN8@PlotPillag
	push	esi
	call	?ExecuteParadropPillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteParadropPillage

; 2639 : 
; 2640 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN121@PlotPillag
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN121@PlotPillag

; 2641 : 			{
; 2642 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221590[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2643 : 				strLogString.Format("Paratrooping in to pillage %s, X: %d, Y: %d", szTargetName.GetCString(), pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR [edi+4]
	push	eax
	push	edi
	lea	ecx, DWORD PTR _szTargetName$[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$221590[esp+128]
	push	OFFSET $SG221591
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2644 : 				LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$221590[esp+120]
	push	ecx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2645 : 			}

	lea	ecx, DWORD PTR _strLogString$221590[esp+116]

; 2646 : 
; 2647 : 		}

	jmp	$LN124@PlotPillag
$LN8@PlotPillag:

; 2648 : 
; 2649 : 		else if (bFirstPass && FindUnitsWithinStrikingDistance(pPlot, 0, iPillageHeal, false /* bNoRangedUnits */, false /*bNavalOnly*/, true /*bMustMoveThrough*/, false /*bIncludeBlockedUnits*/, true /*bWillPillage*/))

	mov	edx, DWORD PTR _iPillageHeal$[esp+116]
	push	0
	push	1
	push	0
	push	1
	push	0
	push	0
	push	edx
	push	0
	push	esi
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
	test	al, al
	je	$LN121@PlotPillag

; 2650 : 		{
; 2651 : 			// Queue best one up to capture it
; 2652 : 			ExecutePillage(pPlot);

	push	esi
	mov	ecx, ebp
	call	?ExecutePillage@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecutePillage

; 2653 : 
; 2654 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN121@PlotPillag
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN121@PlotPillag

; 2655 : 			{
; 2656 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221595[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2657 : 				strLogString.Format("Pillaging %s, X: %d, Y: %d", szTargetName.GetCString(), pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR [edi+4]
	push	eax
	push	edi
	lea	ecx, DWORD PTR _szTargetName$[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$221595[esp+128]
	push	OFFSET $SG221596
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2658 : 				LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$221595[esp+120]
	push	ecx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2659 : 			}

	lea	ecx, DWORD PTR _strLogString$221595[esp+116]

; 2660 : 		}

	jmp	$LN124@PlotPillag
$LN118@PlotPillag:

; 2661 : 
; 2662 : 		// No one can reach it this turn, what about next turn?
; 2663 : 		else if(!bFirstPass && FindUnitsWithinStrikingDistance(pPlot, 2, iPillageHeal, false /* bNoRangedUnits */, false /*bNavalOnly*/, false /*bMustMoveThrough*/, false /*bIncludeBlockedUnits*/, true /*bWillPillage*/))

	mov	edx, DWORD PTR _iPillageHeal$[esp+116]
	push	0
	push	1
	push	0
	push	0
	push	0
	push	0
	push	edx
	push	2
	push	esi
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
	test	al, al
	je	SHORT $LN121@PlotPillag

; 2664 : 		{
; 2665 : 			ExecuteMoveToTarget(pPlot);

	push	esi
	mov	ecx, ebp
	call	?ExecuteMoveToTarget@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteMoveToTarget

; 2666 : 
; 2667 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN121@PlotPillag
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN121@PlotPillag

; 2668 : 			{
; 2669 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221600[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2670 : 				strLogString.Format("Moving toward %s for pillage, X: %d, Y: %d", szTargetName.GetCString(), pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR [edi+4]
	push	eax
	push	edi
	lea	ecx, DWORD PTR _szTargetName$[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$221600[esp+128]
	push	OFFSET $SG221601
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2671 : 				LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$221600[esp+120]
	push	ecx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2672 : 			}

	lea	ecx, DWORD PTR _strLogString$221600[esp+116]
$LN124@PlotPillag:
	mov	BYTE PTR __$EHRec$[esp+124], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN121@PlotPillag:

; 2673 : 		}
; 2674 : 
; 2675 : 		pTarget = GetNextZoneTarget();

	mov	ecx, ebp
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	edi, eax
	test	edi, edi
	jne	$LL10@PlotPillag
	pop	ebx
$LN9@PlotPillag:

; 2676 : 	}
; 2677 : }

	lea	ecx, DWORD PTR _szTargetName$[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z$0:
	lea	ecx, DWORD PTR _szTargetName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z$1:
	lea	ecx, DWORD PTR _strLogString$221590[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z$2:
	lea	ecx, DWORD PTR _strLogString$221595[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z$3:
	lea	ecx, DWORD PTR _strLogString$221600[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z ENDP ; CvTacticalAI::PlotPillageMoves
PUBLIC	?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z ; CvTacticalAI::PlotPlunderTradeUnitMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z$0
__ehfuncinfo$?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
_bNavalOnly$ = -44					; size = 1
_strLogString$221647 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
_eDomain$ = 8						; size = 4
?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z PROC ; CvTacticalAI::PlotPlunderTradeUnitMoves, COMDAT
; _this$ = ecx

; 2749 : {

	push	-1
	push	__ehhandler$?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H

; 2750 : 	AITacticalTargetType eTargetType = AI_TACTICAL_TARGET_NONE;
; 2751 : 	bool bNavalOnly = false;
; 2752 : 	if (eDomain == DOMAIN_LAND)

	mov	eax, DWORD PTR _eDomain$[esp+44]
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+52], ebx
	mov	BYTE PTR _bNavalOnly$[esp+52], 0
	cmp	eax, 2
	jne	SHORT $LN8@PlotPlunde@2

; 2753 : 	{
; 2754 : 		eTargetType = AI_TACTICAL_TARGET_TRADE_UNIT_LAND;

	mov	eax, 20					; 00000014H
	jmp	SHORT $LN68@PlotPlunde@2
$LN8@PlotPlunde@2:

; 2755 : 	}
; 2756 : 	else if (eDomain == DOMAIN_SEA)

	test	eax, eax
	jne	$LN3@PlotPlunde@2

; 2757 : 	{
; 2758 : 		eTargetType = AI_TACTICAL_TARGET_TRADE_UNIT_SEA;

	mov	eax, 19					; 00000013H

; 2759 : 		bNavalOnly = true;

	mov	BYTE PTR _bNavalOnly$[esp+52], 1
$LN68@PlotPlunde@2:
	push	edi

; 2760 : 	}
; 2761 : 
; 2762 : 	CvAssertMsg(eTargetType != AI_TACTICAL_TARGET_NONE, "Undefined domain type for target");
; 2763 : 	if (eTargetType == AI_TACTICAL_TARGET_NONE)
; 2764 : 	{
; 2765 : 		return;
; 2766 : 	}
; 2767 : 
; 2768 : 	CvTacticalTarget* pTarget;
; 2769 : 	pTarget = GetFirstZoneTarget(eTargetType);

	push	eax
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	edi, eax
	mov	DWORD PTR _pTarget$[esp+52], edi

; 2770 : 	while(pTarget != NULL)

	test	edi, edi
	je	$LN73@PlotPlunde@2
	push	ebp
	push	esi
	jmp	SHORT $LN4@PlotPlunde@2
	npad	1
$LL70@PlotPlunde@2:
	mov	edi, DWORD PTR _pTarget$[esp+60]
$LN4@PlotPlunde@2:

; 2771 : 	{
; 2772 : 		// See what units we have who can reach target this turn
; 2773 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+4]
	mov	ebp, DWORD PTR [edi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN18@PlotPlunde@2
	cmp	ebp, -2147483647			; 80000001H
	je	$LN18@PlotPlunde@2
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN28@PlotPlunde@2
	test	eax, eax
	jge	SHORT $LN30@PlotPlunde@2
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN32@PlotPlunde@2
$LN30@PlotPlunde@2:
	cmp	eax, ecx
	jl	SHORT $LN28@PlotPlunde@2
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN32@PlotPlunde@2
$LN28@PlotPlunde@2:
	mov	esi, eax
$LN32@PlotPlunde@2:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN71@PlotPlunde@2
	test	ebp, ebp
	jge	SHORT $LN40@PlotPlunde@2
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN42@PlotPlunde@2
$LN40@PlotPlunde@2:
	cmp	ebp, edi
	jl	SHORT $LN71@PlotPlunde@2
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN42@PlotPlunde@2
$LN71@PlotPlunde@2:
	mov	edx, ebp
$LN42@PlotPlunde@2:
	test	esi, esi
	jl	SHORT $LN22@PlotPlunde@2
	cmp	esi, ecx
	jge	SHORT $LN22@PlotPlunde@2
	test	edx, edx
	jl	SHORT $LN22@PlotPlunde@2
	cmp	edx, edi
	jge	SHORT $LN22@PlotPlunde@2
	mov	edi, DWORD PTR _pTarget$[esp+60]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	ebx, DWORD PTR _this$[esp+64]
	mov	esi, ecx
	jmp	SHORT $LN20@PlotPlunde@2
$LN22@PlotPlunde@2:
	mov	edi, DWORD PTR _pTarget$[esp+60]
	mov	ebx, DWORD PTR _this$[esp+64]
$LN18@PlotPlunde@2:
	xor	esi, esi
$LN20@PlotPlunde@2:

; 2774 : 
; 2775 : 		if (FindUnitsWithinStrikingDistance(pPlot, 0, 0, false /* bNoRangedUnits */, bNavalOnly, true /*bMustMoveThrough*/, false /*bIncludeBlockedUnits*/, false /*bWillPillage*/))

	mov	eax, DWORD PTR _bNavalOnly$[esp+64]
	push	0
	push	0
	push	0
	push	1
	push	eax
	push	0
	push	0
	push	0
	push	esi
	mov	ecx, ebx
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
	test	al, al
	je	SHORT $LN1@PlotPlunde@2

; 2776 : 		{
; 2777 : 			// Queue best one up to capture it
; 2778 : 			ExecutePlunderTradeUnit(pPlot);

	push	esi
	mov	ecx, ebx
	call	?ExecutePlunderTradeUnit@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecutePlunderTradeUnit

; 2779 : 
; 2780 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@PlotPlunde@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@PlotPlunde@2

; 2781 : 			{
; 2782 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221647[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2783 : 				strLogString.Format("Plundering trade unit, X: %d, Y: %d", pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strLogString$221647[esp+72]
	push	OFFSET $SG221648
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2784 : 				LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$221647[esp+68]
	push	edx
	mov	ecx, ebx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2785 : 			}

	lea	ecx, DWORD PTR _strLogString$221647[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@PlotPlunde@2:

; 2786 : 		}
; 2787 : 
; 2788 : 		pTarget = GetNextZoneTarget();

	mov	ecx, ebx
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	DWORD PTR _pTarget$[esp+60], eax
	test	eax, eax
	jne	$LL70@PlotPlunde@2
	pop	esi
	pop	ebp
$LN73@PlotPlunde@2:
	pop	edi
$LN3@PlotPlunde@2:

; 2789 : 	}
; 2790 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z$0:
	lea	ecx, DWORD PTR _strLogString$221647[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z ENDP ; CvTacticalAI::PlotPlunderTradeUnitMoves
PUBLIC	?PlotBlockadeImprovementMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotBlockadeImprovementMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotBlockadeImprovementMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotBlockadeImprovementMoves@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?PlotBlockadeImprovementMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotBlockadeImprovementMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotBlockadeImprovementMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_pTarget$ = -48						; size = 4
_this$ = -44						; size = 4
_strLogString$221659 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotBlockadeImprovementMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotBlockadeImprovementMoves, COMDAT
; _this$ = ecx

; 2794 : {

	push	-1
	push	__ehhandler$?PlotBlockadeImprovementMoves@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	edi
	mov	ebx, ecx

; 2795 : 	CvTacticalTarget* pTarget;
; 2796 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_BLOCKADE_RESOURCE_POINT);

	push	4
	mov	DWORD PTR _this$[esp+60], ebx
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	edi, eax
	mov	DWORD PTR _pTarget$[esp+56], edi

; 2797 : 	while(pTarget != NULL)

	test	edi, edi
	je	$LN3@PlotBlocka
	push	ebp
	push	esi
	jmp	SHORT $LN4@PlotBlocka
	npad	7
$LL65@PlotBlocka:
	mov	edi, DWORD PTR _pTarget$[esp+64]
$LN4@PlotBlocka:

; 2798 : 	{
; 2799 : 		// See what units we have who can reach target this turn
; 2800 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+4]
	mov	ebp, DWORD PTR [edi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN14@PlotBlocka
	cmp	ebp, -2147483647			; 80000001H
	je	$LN14@PlotBlocka
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN24@PlotBlocka
	test	eax, eax
	jge	SHORT $LN26@PlotBlocka
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN28@PlotBlocka
$LN26@PlotBlocka:
	cmp	eax, ecx
	jl	SHORT $LN24@PlotBlocka
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN28@PlotBlocka
$LN24@PlotBlocka:
	mov	esi, eax
$LN28@PlotBlocka:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN66@PlotBlocka
	test	ebp, ebp
	jge	SHORT $LN36@PlotBlocka
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN38@PlotBlocka
$LN36@PlotBlocka:
	cmp	ebp, edi
	jl	SHORT $LN66@PlotBlocka
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN38@PlotBlocka
$LN66@PlotBlocka:
	mov	edx, ebp
$LN38@PlotBlocka:
	test	esi, esi
	jl	SHORT $LN18@PlotBlocka
	cmp	esi, ecx
	jge	SHORT $LN18@PlotBlocka
	test	edx, edx
	jl	SHORT $LN18@PlotBlocka
	cmp	edx, edi
	jge	SHORT $LN18@PlotBlocka
	mov	edi, DWORD PTR _pTarget$[esp+64]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	ebx, DWORD PTR _this$[esp+64]
	mov	esi, ecx
	jmp	SHORT $LN16@PlotBlocka
$LN18@PlotBlocka:
	mov	ebx, DWORD PTR _this$[esp+64]
	mov	edi, DWORD PTR _pTarget$[esp+64]
$LN14@PlotBlocka:
	xor	esi, esi
$LN16@PlotBlocka:

; 2801 : 		if(FindUnitsWithinStrikingDistance(pPlot, 2, 0, false /* bNoRangedUnits */, true /* bNavalOnly */, false /*bMustMoveThrough*/))

	push	0
	push	0
	push	0
	push	0
	push	1
	push	0
	push	0
	push	2
	push	esi
	mov	ecx, ebx
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
	test	al, al
	je	SHORT $LN67@PlotBlocka

; 2802 : 		{
; 2803 : 			// Queue best one up to capture it
; 2804 : 			ExecuteNavalBlockadeMove(pPlot);

	push	esi
	mov	ecx, ebx
	call	?ExecuteNavalBlockadeMove@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteNavalBlockadeMove

; 2805 : 
; 2806 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN67@PlotBlocka
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN67@PlotBlocka

; 2807 : 			{
; 2808 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221659[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2809 : 				strLogString.Format("Blockading naval resource(s) with move to, X: %d, Y: %d", pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	lea	eax, DWORD PTR _strLogString$221659[esp+72]
	push	OFFSET $SG221660
	push	eax
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2810 : 				LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$221659[esp+68]
	push	ecx
	mov	ecx, ebx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2811 : 			}

	lea	ecx, DWORD PTR _strLogString$221659[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN67@PlotBlocka:

; 2812 : 		}
; 2813 : 		pTarget = GetNextZoneTarget();

	mov	ecx, ebx
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	DWORD PTR _pTarget$[esp+64], eax
	test	eax, eax
	jne	$LL65@PlotBlocka
	pop	esi
	pop	ebp
$LN3@PlotBlocka:

; 2814 : 	}
; 2815 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotBlockadeImprovementMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$221659[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotBlockadeImprovementMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotBlockadeImprovementMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotBlockadeImprovementMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotBlockadeImprovementMoves
PUBLIC	?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z ; CvTacticalAI::PlotCivilianAttackMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z$0
__ehfuncinfo$?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
_strLogString$221672 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_eTargetType$ = 8					; size = 4
?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z PROC ; CvTacticalAI::PlotCivilianAttackMoves, COMDAT
; _this$ = ecx

; 2819 : {

	push	-1
	push	__ehhandler$?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H

; 2820 : 	CvTacticalTarget* pTarget;
; 2821 : 	pTarget = GetFirstZoneTarget(eTargetType);

	mov	eax, DWORD PTR _eTargetType$[esp+40]
	push	ebp
	push	edi
	mov	ebp, ecx
	push	eax
	mov	DWORD PTR _this$[esp+56], ebp
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	edi, eax

; 2822 : 	while(pTarget != NULL)

	test	edi, edi
	je	$LN9@PlotCivili
	push	ebx
	push	esi
	npad	10
$LL10@PlotCivili:

; 2823 : 	{
; 2824 : 		// See what units we have who can reach target this turn
; 2825 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN20@PlotCivili
	cmp	ebx, -2147483647			; 80000001H
	je	$LN20@PlotCivili
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	dl, dl
	je	SHORT $LN30@PlotCivili
	test	eax, eax
	jge	SHORT $LN32@PlotCivili
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN34@PlotCivili
$LN32@PlotCivili:
	cmp	eax, ecx
	jl	SHORT $LN30@PlotCivili
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN34@PlotCivili
$LN30@PlotCivili:
	mov	esi, eax
$LN34@PlotCivili:
	mov	al, BYTE PTR [ebp+4057]
	mov	ebp, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN83@PlotCivili
	test	ebx, ebx
	jge	SHORT $LN42@PlotCivili
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN44@PlotCivili
$LN42@PlotCivili:
	cmp	ebx, ebp
	jl	SHORT $LN83@PlotCivili
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN44@PlotCivili
$LN83@PlotCivili:
	mov	edx, ebx
$LN44@PlotCivili:
	test	esi, esi
	jl	SHORT $LN24@PlotCivili
	cmp	esi, ecx
	jge	SHORT $LN24@PlotCivili
	test	edx, edx
	jl	SHORT $LN24@PlotCivili
	cmp	edx, ebp
	jge	SHORT $LN24@PlotCivili
	mov	ebp, DWORD PTR _this$[esp+60]
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	esi, ecx
	jmp	SHORT $LN22@PlotCivili
$LN24@PlotCivili:
	mov	ebp, DWORD PTR _this$[esp+60]
$LN20@PlotCivili:
	xor	esi, esi
$LN22@PlotCivili:

; 2826 : 		if(FindUnitsWithinStrikingDistance(pPlot, 1, 0, false /* bNoRangedUnits */, false /*bNavalOnly*/, false /*bMustMoveThrough*/, false /*bIncludeBlockedUnits*/, false /*bWillPillage*/, true /*bTargetUndefended*/))

	push	1
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	1
	push	esi
	mov	ecx, ebp
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
	test	al, al
	je	$LN85@PlotCivili

; 2827 : 		{
; 2828 : 			// Queue best one up to capture it
; 2829 : 			ExecuteCivilianCapture(pPlot);

	push	esi
	mov	ecx, ebp
	call	?ExecuteCivilianCapture@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ExecuteCivilianCapture

; 2830 : 
; 2831 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN85@PlotCivili
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN85@PlotCivili

; 2832 : 			{
; 2833 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221672[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2834 : 				switch(eTargetType)

	mov	eax, DWORD PTR _eTargetType$[esp+56]
	add	eax, -15				; fffffff1H
	mov	DWORD PTR __$EHRec$[esp+68], 0
	cmp	eax, 3
	ja	SHORT $LN5@PlotCivili
	jmp	DWORD PTR $LN89@PlotCivili[eax*4]
$LN4@PlotCivili:

; 2835 : 				{
; 2836 : 				case AI_TACTICAL_TARGET_VERY_HIGH_PRIORITY_CIVILIAN:
; 2837 : 					strLogString.Format("Attacking very high priority civilian, X: %d, Y: %d", pTarget->GetTargetX(),
; 2838 : 					                    pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR [edi+4]
	push	eax
	push	edi
	push	OFFSET $SG221678

; 2839 : 					break;

	jmp	SHORT $LN87@PlotCivili
$LN3@PlotCivili:

; 2840 : 				case AI_TACTICAL_TARGET_HIGH_PRIORITY_CIVILIAN:
; 2841 : 					strLogString.Format("Attacking high priority civilian, X: %d, Y: %d", pTarget->GetTargetX(),
; 2842 : 					                    pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR [edi+4]
	push	eax
	push	edi
	push	OFFSET $SG221680
	lea	ecx, DWORD PTR _strLogString$221672[esp+72]
	push	ecx

; 2843 : 					break;

	jmp	SHORT $LN88@PlotCivili
$LN2@PlotCivili:

; 2844 : 				case AI_TACTICAL_TARGET_MEDIUM_PRIORITY_CIVILIAN:
; 2845 : 					strLogString.Format("Attacking medium priority civilian, X: %d, Y: %d", pTarget->GetTargetX(),
; 2846 : 					                    pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR [edi+4]
	push	eax
	push	edi
	push	OFFSET $SG221682
	lea	edx, DWORD PTR _strLogString$221672[esp+72]
	push	edx

; 2847 : 					break;

	jmp	SHORT $LN88@PlotCivili
$LN1@PlotCivili:

; 2848 : 				case AI_TACTICAL_TARGET_LOW_PRIORITY_CIVILIAN:
; 2849 : 					strLogString.Format("Attacking low priority civilian, X: %d, Y: %d", pTarget->GetTargetX(),
; 2850 : 					                    pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR [edi+4]
	push	eax
	push	edi
	push	OFFSET $SG221684
$LN87@PlotCivili:
	lea	eax, DWORD PTR _strLogString$221672[esp+72]
	push	eax
$LN88@PlotCivili:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
$LN5@PlotCivili:

; 2851 : 					break;
; 2852 : 				}
; 2853 : 				LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$221672[esp+64]
	push	ecx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2854 : 			}

	lea	ecx, DWORD PTR _strLogString$221672[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN85@PlotCivili:

; 2855 : 		}
; 2856 : 		pTarget = GetNextZoneTarget();

	mov	ecx, ebp
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	edi, eax
	test	edi, edi
	jne	$LL10@PlotCivili
	pop	esi
	pop	ebx
$LN9@PlotCivili:

; 2857 : 	}
; 2858 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
$LN89@PlotCivili:
	DD	$LN4@PlotCivili
	DD	$LN3@PlotCivili
	DD	$LN2@PlotCivili
	DD	$LN1@PlotCivili
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z$0:
	lea	ecx, DWORD PTR _strLogString$221672[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z ENDP ; CvTacticalAI::PlotCivilianAttackMoves
PUBLIC	?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotCampDefenseMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_pTarget$ = -48						; size = 4
_this$ = -44						; size = 4
_strLogString$221740 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::PlotCampDefenseMoves, COMDAT
; _this$ = ecx

; 2958 : {

	push	-1
	push	__ehhandler$?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	edi
	mov	ebx, ecx

; 2959 : 	CvTacticalTarget* pTarget;
; 2960 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_BARBARIAN_CAMP);

	push	2
	mov	DWORD PTR _this$[esp+60], ebx
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	edi, eax
	mov	DWORD PTR _pTarget$[esp+56], edi

; 2961 : 	while(pTarget != NULL)

	test	edi, edi
	je	$LN3@PlotCampDe
	push	ebp
	push	esi
	jmp	SHORT $LN4@PlotCampDe
	npad	7
$LL65@PlotCampDe:
	mov	edi, DWORD PTR _pTarget$[esp+64]
$LN4@PlotCampDe:

; 2962 : 	{
; 2963 : 		CvPlot* pPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+4]
	mov	ebp, DWORD PTR [edi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN14@PlotCampDe
	cmp	ebp, -2147483647			; 80000001H
	je	$LN14@PlotCampDe
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN24@PlotCampDe
	test	eax, eax
	jge	SHORT $LN26@PlotCampDe
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN28@PlotCampDe
$LN26@PlotCampDe:
	cmp	eax, ecx
	jl	SHORT $LN24@PlotCampDe
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN28@PlotCampDe
$LN24@PlotCampDe:
	mov	esi, eax
$LN28@PlotCampDe:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN66@PlotCampDe
	test	ebp, ebp
	jge	SHORT $LN36@PlotCampDe
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN38@PlotCampDe
$LN36@PlotCampDe:
	cmp	ebp, edi
	jl	SHORT $LN66@PlotCampDe
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN38@PlotCampDe
$LN66@PlotCampDe:
	mov	edx, ebp
$LN38@PlotCampDe:
	test	esi, esi
	jl	SHORT $LN18@PlotCampDe
	cmp	esi, ecx
	jge	SHORT $LN18@PlotCampDe
	test	edx, edx
	jl	SHORT $LN18@PlotCampDe
	cmp	edx, edi
	jge	SHORT $LN18@PlotCampDe
	mov	edi, DWORD PTR _pTarget$[esp+64]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	ebx, DWORD PTR _this$[esp+64]
	mov	esi, ecx
	jmp	SHORT $LN16@PlotCampDe
$LN18@PlotCampDe:
	mov	ebx, DWORD PTR _this$[esp+64]
	mov	edi, DWORD PTR _pTarget$[esp+64]
$LN14@PlotCampDe:
	xor	esi, esi
$LN16@PlotCampDe:

; 2964 : 		if(FindUnitsWithinStrikingDistance(pPlot, 1, 0, true /* bNoRangedUnits */, false /*bNavalOnly*/, false /*bMustMoveThrough*/))

	push	0
	push	0
	push	0
	push	0
	push	0
	push	1
	push	0
	push	1
	push	esi
	mov	ecx, ebx
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
	test	al, al
	je	SHORT $LN67@PlotCampDe

; 2965 : 		{
; 2966 : 			ExecuteMoveToPlot(pPlot);

	push	0
	push	esi
	mov	ecx, ebx
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXPAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 2967 : 
; 2968 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN67@PlotCampDe
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN67@PlotCampDe

; 2969 : 			{
; 2970 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$221740[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2971 : 				strLogString.Format("Moving to protect camp, X: %d, Y: %d", pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	lea	eax, DWORD PTR _strLogString$221740[esp+72]
	push	OFFSET $SG221741
	push	eax
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2972 : 				LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$221740[esp+68]
	push	ecx
	mov	ecx, ebx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 2973 : 			}

	lea	ecx, DWORD PTR _strLogString$221740[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN67@PlotCampDe:

; 2974 : 		}
; 2975 : 		pTarget = GetNextZoneTarget();

	mov	ecx, ebx
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	DWORD PTR _pTarget$[esp+64], eax
	test	eax, eax
	jne	$LL65@PlotCampDe
	pop	esi
	pop	ebp
$LN3@PlotCampDe:

; 2976 : 	}
; 2977 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$221740[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::PlotCampDefenseMoves
PUBLIC	?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ		; CvTacticalAI::PlotWithdrawMoves
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_pZone$ = -56						; size = 4
$T294748 = -52						; size = 1
_it$ = -52						; size = 4
__Cat$294752 = -48					; size = 1
$T294750 = -48						; size = 1
$T294977 = -48						; size = 4
_pUnit$222083 = -44					; size = 8
_unit$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::PlotWithdrawMoves, COMDAT
; _this$ = ecx

; 3715 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	edi
	mov	edi, ecx

; 3716 : 	list<int>::iterator it;
; 3717 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [edi+24]
	cmp	ecx, eax
	je	SHORT $LN40@PlotWithdr
	mov	BYTE PTR $T294748[esp+60], 0
	mov	edx, DWORD PTR $T294748[esp+60]
	push	edx
	mov	edx, DWORD PTR __Cat$294752[esp+64]
	push	edx
	mov	edx, DWORD PTR $T294750[esp+68]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+28], eax
$LN40@PlotWithdr:

; 3718 : 	CvTacticalUnit unit;
; 3719 : 
; 3720 : 	CvTacticalDominanceZone* pZone = m_pMap->GetZone(m_iCurrentZoneIndex);

	mov	eax, DWORD PTR [edi+24792]
	mov	ecx, DWORD PTR [edi+4]
	push	ebx
	xor	ebx, ebx
	push	ebp
	push	eax
	mov	DWORD PTR _unit$[esp+72], ebx
	mov	DWORD PTR _unit$[esp+76], ebx
	mov	DWORD PTR _unit$[esp+80], ebx
	mov	DWORD PTR _unit$[esp+84], ebx
	mov	DWORD PTR _unit$[esp+88], ebx
	mov	DWORD PTR _unit$[esp+92], ebx
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
	mov	ebp, eax

; 3721 : 
; 3722 : 	// Loop through all recruited units
; 3723 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 3724 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 3725 : #else
; 3726 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pZone$[esp+68], ebp
	mov	DWORD PTR _it$[esp+68], ecx
	cmp	ecx, eax
	je	$LN16@PlotWithdr
	push	esi
	jmp	SHORT $LN79@PlotWithdr
	npad	4
$LL217@PlotWithdr:
	mov	ebp, DWORD PTR _pZone$[esp+72]
$LN79@PlotWithdr:

; 3727 : #endif
; 3728 : 	{
; 3729 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	ecx, DWORD PTR _it$[esp+72]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [edi]
	push	edx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$222083[esp+72], esi
	mov	BYTE PTR _pUnit$222083[esp+76], 0
	cmp	esi, ebx
	je	SHORT $LN102@PlotWithdr
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN102@PlotWithdr:
	mov	DWORD PTR __$EHRec$[esp+80], ebx

; 3730 : 		if(pUnit)

	cmp	esi, ebx
	je	$LN219@PlotWithdr

; 3731 : 		{
; 3732 : 			// Proper domain of unit?
; 3733 : 			if(pZone->IsWater() && pUnit->getDomainType() == DOMAIN_SEA || !pZone->IsWater() && pUnit->getDomainType() == DOMAIN_LAND)

	cmp	BYTE PTR [ebp+68], 0
	je	SHORT $LN222@PlotWithdr
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN13@PlotWithdr
	cmp	BYTE PTR [ebp+68], 0
	jne	$LN219@PlotWithdr
$LN222@PlotWithdr:
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	$LN219@PlotWithdr
$LN13@PlotWithdr:

; 3734 : 			{
; 3735 : 				// Am I in the current dominance zone?
; 3736 : 				int iPlotIndex = GC.getMap().plotNum(pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [eax+4020]
	mov	ecx, DWORD PTR [esi+88]
	mov	edx, DWORD PTR [esi+76]
	imul	eax, ecx

; 3737 : 				if(m_pMap->GetCell(iPlotIndex)->GetDominanceZone() == m_pMap->GetZone(m_iCurrentZoneIndex)->GetDominanceZoneID())

	mov	ecx, DWORD PTR [edi+4]
	add	eax, edx
	mov	edx, DWORD PTR [edi+24792]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+12]
	push	edx
	mov	ebp, DWORD PTR [eax+40]
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
	cmp	ebp, DWORD PTR [eax]
	jne	SHORT $LN11@PlotWithdr
$LN223@PlotWithdr:

; 3738 : 				{
; 3739 : 					unit.SetID(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]

; 3740 : 					m_CurrentMoveUnits.push_back(unit);

	lea	ecx, DWORD PTR _unit$[esp+72]
	push	ecx
	lea	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR _unit$[esp+76], eax
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back
	jmp	$LN219@PlotWithdr
$LN11@PlotWithdr:

; 3741 : 				}
; 3742 : 
; 3743 : 				// Or am I within tactical recruit range of center of zone and in danger and not in friendly territory?
; 3744 : 				else if(pZone->GetClosestCity() != NULL)

	mov	ebp, DWORD PTR _pZone$[esp+72]
	mov	ecx, ebp
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	test	eax, eax
	je	$LN9@PlotWithdr

; 3745 : 				{
; 3746 : 					if(plotDistance(pZone->GetClosestCity()->getX(), pZone->GetClosestCity()->getY(), pUnit->getX(), pUnit->getY()) <= m_iRecruitRange)

	mov	ecx, DWORD PTR _pZone$[esp+72]
	mov	ebp, DWORD PTR [esi+88]
	mov	ebx, DWORD PTR [esi+76]
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	edx, DWORD PTR [eax+108]
	mov	ecx, DWORD PTR _pZone$[esp+72]
	mov	DWORD PTR $T294977[esp+72], edx
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, DWORD PTR $T294977[esp+72]
	mov	eax, DWORD PTR [eax+96]
	push	ebp
	push	ebx
	push	ecx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR [edi+24756]
	jg	SHORT $LN218@PlotWithdr

; 3747 : 					{
; 3748 : 						CvPlot* pPlot = pUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 3749 : 						if(m_pPlayer->GetPlotDanger(*pPlot) > 0)

	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	test	eax, eax
	jle	SHORT $LN218@PlotWithdr

; 3750 : 						{
; 3751 : 							if(pUnit->plot()->getOwner() != pUnit->getOwner())

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	edx, BYTE PTR [eax+4]
	mov	ecx, DWORD PTR [esi+40]
	cmp	edx, ecx
	je	SHORT $LN218@PlotWithdr

; 3752 : 							{
; 3753 : 								unit.SetID(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]

; 3754 : 								m_CurrentMoveUnits.push_back(unit);

	lea	ecx, DWORD PTR _unit$[esp+72]
	push	ecx
	lea	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR _unit$[esp+76], eax
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back
$LN218@PlotWithdr:

; 3755 : 							}
; 3756 : 						}
; 3757 : 					}
; 3758 : 				}

	xor	ebx, ebx
$LN219@PlotWithdr:

; 3770 : 						}
; 3771 : 					}
; 3772 : 				}
; 3773 : 			}
; 3774 : 		}
; 3775 : 	}

	mov	DWORD PTR __$EHRec$[esp+80], -1
	cmp	esi, ebx
	je	SHORT $LN17@PlotWithdr
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN17@PlotWithdr:
	mov	edx, DWORD PTR _it$[esp+72]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$[esp+72], eax
	cmp	eax, DWORD PTR [edi+12]
	jne	$LL217@PlotWithdr
	pop	esi
$LN16@PlotWithdr:

; 3776 : 
; 3777 : 	if(m_CurrentMoveUnits.size() > 0)

	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	ebp
	pop	ebx
	je	SHORT $LN1@PlotWithdr

; 3778 : 	{
; 3779 : 		ExecuteWithdrawMoves();

	mov	ecx, edi
	call	?ExecuteWithdrawMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::ExecuteWithdrawMoves
$LN1@PlotWithdr:

; 3780 : 	}
; 3781 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	0
$LN9@PlotWithdr:

; 3759 : 
; 3760 : 				// Or we are withdrawing from unowned lands zone and this is a plot in danger
; 3761 : 				else if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_NO_OWNER)

	cmp	DWORD PTR [ebp+4], 1
	jne	SHORT $LN219@PlotWithdr

; 3762 : 				{
; 3763 : 					CvPlot* pPlot = pUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 3764 : 					if(m_pPlayer->GetPlotDanger(*pPlot) > 0)

	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	test	eax, eax
	jle	SHORT $LN219@PlotWithdr

; 3765 : 					{
; 3766 : 						if(pUnit->plot()->getOwner() != pUnit->getOwner())

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	edx, BYTE PTR [eax+4]
	mov	ecx, DWORD PTR [esi+40]
	cmp	edx, ecx
	je	$LN219@PlotWithdr

; 3767 : 						{
; 3768 : 							unit.SetID(pUnit->GetID());
; 3769 : 							m_CurrentMoveUnits.push_back(unit);

	jmp	$LN223@PlotWithdr
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$222083[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::PlotWithdrawMoves
PUBLIC	?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ; CvTacticalAI::ExecuteFormationMoves
EXTRN	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ:PROC		; CvArmyAI::Plot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$11
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$14
	DD	09H
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$16
	DD	0aH
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$18
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_iRangedUnitsToPlace$222715 = -108			; size = 4
_iMeleeUnitsToPlace$222693 = -108			; size = 4
_iRangedUnits$ = -104					; size = 4
tv1878 = -100						; size = 4
tv1853 = -100						; size = 4
tv1832 = -100						; size = 4
_iI$222733 = -96					; size = 4
_iI$222716 = -96					; size = 4
_iI$222695 = -96					; size = 4
_pUnit$ = -92						; size = 8
_pInnerUnit$222741 = -84				; size = 8
_pInnerUnit$222725 = -84				; size = 8
$T295101 = -84						; size = 8
$T295109 = -76						; size = 8
$T295105 = -76						; size = 8
_pInnerUnit$222703 = -76				; size = 8
_strMsg$222751 = -68					; size = 28
_strMsg$222745 = -68					; size = 28
_strMsg$222729 = -68					; size = 28
_strMsg$222713 = -68					; size = 28
_strMsg$222707 = -68					; size = 28
_strLogString$222690 = -68				; size = 28
$T295111 = -40						; size = 28
$T295107 = -40						; size = 28
$T295103 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_bDone$222694 = 8					; size = 1
_pTarget$ = 8						; size = 4
_pArmy$ = 8						; size = 4
$T295110 = 12						; size = 4
_bMoveWasSafe$222742 = 12				; size = 1
$T295106 = 12						; size = 4
_bMoveWasSafe$222726 = 12				; size = 1
$T295102 = 12						; size = 4
_bMoveWasSafe$222704 = 12				; size = 1
_eTargetType$ = 12					; size = 4
_pClosestCurrentCOMonPath$ = 12				; size = 4
?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z PROC ; CvTacticalAI::ExecuteFormationMoves, COMDAT
; _this$ = ecx

; 5070 : {

	push	-1
	push	__ehhandler$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	ebp
	push	esi

; 5071 : 	CvPlot* pTarget;
; 5072 : 	UnitHandle pUnit;

	xor	eax, eax
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _pUnit$[esp+124], eax
	mov	BYTE PTR _pUnit$[esp+128], al
	mov	DWORD PTR __$EHRec$[esp+132], eax

; 5073 : 	AITacticalTargetType eTargetType;
; 5074 : 	CvPlot* pLoopPlot;
; 5075 : 	FStaticVector<CvOperationUnit, SAFE_ESTIMATE_NUM_MULTIUNITFORMATION_ENTRIES, true, c_eCiv5GameplayDLL, 0>::iterator it;
; 5076 : 
; 5077 : 	if(m_OperationUnits.size() == 0)

	cmp	DWORD PTR [edi+28648], eax

; 5078 : 	{
; 5079 : 		return;

	je	$LN1@ExecuteFor

; 5080 : 	}
; 5081 : 
; 5082 : 	pTarget = pArmy->Plot();

	mov	ebp, DWORD PTR _pArmy$[esp+120]
	mov	ecx, ebp
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot

; 5083 : 
; 5084 : 	int iMeleeUnits = 0;
; 5085 : 	int iRangedUnits = 0;
; 5086 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 5087 : 	for (it = m_OperationUnits.begin(); it != m_OperationUnits.end(); ++it)
; 5088 : #else
; 5089 : 	for(it = m_OperationUnits.begin(); it != m_OperationUnits.end(); it++)

	mov	esi, DWORD PTR [edi+28644]
	mov	DWORD PTR _pTarget$[esp+120], eax
	mov	eax, DWORD PTR [edi+28648]
	mov	ecx, esi
	xor	ebx, ebx
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _iRangedUnits$[esp+124], ebx
	cmp	esi, edx
	je	SHORT $LN32@ExecuteFor
$LL34@ExecuteFor:

; 5090 : #endif
; 5091 : 	{
; 5092 : 		CvUnit *pOpUnit = m_pPlayer->getUnit(it->GetUnitID());

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 5093 : 		if (pOpUnit->IsCanAttackRanged())

	mov	ecx, eax
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	SHORT $LN31@ExecuteFor

; 5094 : 		{
; 5095 : 			iRangedUnits++;

	inc	DWORD PTR _iRangedUnits$[esp+124]

; 5096 : 		}
; 5097 : 		else

	jmp	SHORT $LN33@ExecuteFor
$LN31@ExecuteFor:

; 5098 : 		{
; 5099 : 			iMeleeUnits++;

	inc	ebx
$LN33@ExecuteFor:

; 5083 : 
; 5084 : 	int iMeleeUnits = 0;
; 5085 : 	int iRangedUnits = 0;
; 5086 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 5087 : 	for (it = m_OperationUnits.begin(); it != m_OperationUnits.end(); ++it)
; 5088 : #else
; 5089 : 	for(it = m_OperationUnits.begin(); it != m_OperationUnits.end(); it++)

	mov	eax, DWORD PTR [edi+28648]
	mov	ecx, DWORD PTR [edi+28644]
	add	esi, 8
	lea	edx, DWORD PTR [ecx+eax*8]
	cmp	esi, edx
	jne	SHORT $LL34@ExecuteFor
$LN32@ExecuteFor:

; 5100 : 		}
; 5101 : 	}
; 5102 : 
; 5103 : 	// See if we have enough places to put everyone
; 5104 : 	if(!ScoreFormationPlots(pArmy, pTarget, pClosestCurrentCOMonPath, iMeleeUnits + iRangedUnits))

	mov	eax, DWORD PTR _iRangedUnits$[esp+124]
	mov	ecx, DWORD PTR _pClosestCurrentCOMonPath$[esp+120]
	mov	edx, DWORD PTR _pTarget$[esp+120]
	add	eax, ebx
	push	eax
	push	ecx
	push	edx
	push	ebp
	mov	ecx, edi
	call	?ScoreFormationPlots@CvTacticalAI@@AAE_NPAVCvArmyAI@@PAVCvPlot@@1H@Z ; CvTacticalAI::ScoreFormationPlots
	test	al, al
	jne	$LN29@ExecuteFor

; 5105 : 	{
; 5106 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN28@ExecuteFor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN28@ExecuteFor

; 5107 : 		{
; 5108 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222690[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5109 : 			strLogString.Format("Operation aborting. Army ID: %d. Not enough spaces to deploy along formation's path", pArmy->GetID());

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+132], 1
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	lea	eax, DWORD PTR _strLogString$222690[esp+128]
	push	OFFSET $SG222691
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5110 : 			LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222690[esp+128]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 5111 : 		}

	lea	ecx, DWORD PTR _strLogString$222690[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN28@ExecuteFor:

; 5112 : 		m_pPlayer->getAIOperation(pArmy->GetOperationID())->SetToAbort(AI_ABORT_NO_ROOM_DEPLOY);

	mov	ebp, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+76]
	push	5
	call	eax

; 5275 : 		}
; 5276 : 	}
; 5277 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 108				; 0000006cH
	ret	8
$LN29@ExecuteFor:

; 5113 : 	}
; 5114 : 
; 5115 : 	// Compute the moves to get the best deployment
; 5116 : 	else
; 5117 : 	{
; 5118 : 		std::stable_sort(m_TempTargets.begin(), m_TempTargets.end());

	mov	eax, DWORD PTR [edi+23708]
	mov	ecx, DWORD PTR [edi+23704]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, ecx
	lea	eax, DWORD PTR [eax+edx*4]
	cmp	ecx, eax
	je	SHORT $LN84@ExecuteFor
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 16					; 00000010H
$LN84@ExecuteFor:

; 5122 : 		bool bDone = false;
; 5123 : #ifdef AUI_ITERATORIZE
; 5124 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5125 : 		{
; 5126 : 			eTargetType = it2->GetTargetType();
; 5127 : 
; 5128 : 			pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5129 : #else
; 5130 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	eax, DWORD PTR [edi+23708]
	mov	DWORD PTR _iMeleeUnitsToPlace$222693[esp+124], ebx
	mov	BYTE PTR _bDone$222694[esp+120], 0
	mov	DWORD PTR _iI$222695[esp+124], 0
	test	eax, eax
	jbe	$LN24@ExecuteFor

; 5119 : 
; 5120 : 		// First loop for melee units who should be out front
; 5121 : 		int iMeleeUnitsToPlace = iMeleeUnits;

	mov	DWORD PTR tv1832[esp+124], 0
$LN26@ExecuteFor:

; 5122 : 		bool bDone = false;
; 5123 : #ifdef AUI_ITERATORIZE
; 5124 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5125 : 		{
; 5126 : 			eTargetType = it2->GetTargetType();
; 5127 : 
; 5128 : 			pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5129 : #else
; 5130 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	cmp	BYTE PTR _bDone$222694[esp+120], 0
	jne	$LN24@ExecuteFor

; 5131 : 		{
; 5132 : 			eTargetType = m_TempTargets[iI].GetTargetType();
; 5133 : 
; 5134 : 			pLoopPlot = GC.getMap().plot(m_TempTargets[iI].GetTargetX(), m_TempTargets[iI].GetTargetY());

	mov	ecx, DWORD PTR [edi+23704]
	mov	edx, DWORD PTR tv1832[esp+124]
	mov	ebx, DWORD PTR [edx+ecx+8]
	lea	eax, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN107@ExecuteFor
	cmp	ebx, -2147483647			; 80000001H
	je	$LN107@ExecuteFor
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN117@ExecuteFor
	test	eax, eax
	jge	SHORT $LN119@ExecuteFor
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN121@ExecuteFor
$LN119@ExecuteFor:
	cmp	eax, ecx
	jl	SHORT $LN117@ExecuteFor
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN121@ExecuteFor
$LN117@ExecuteFor:
	mov	esi, eax
$LN121@ExecuteFor:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN127@ExecuteFor
	test	ebx, ebx
	jge	SHORT $LN129@ExecuteFor
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN131@ExecuteFor
$LN129@ExecuteFor:
	cmp	ebx, ebp
	jl	SHORT $LN127@ExecuteFor
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN131@ExecuteFor
$LN127@ExecuteFor:
	mov	edx, ebx
$LN131@ExecuteFor:
	test	esi, esi
	jl	SHORT $LN107@ExecuteFor
	cmp	esi, ecx
	jge	SHORT $LN107@ExecuteFor
	test	edx, edx
	jl	SHORT $LN107@ExecuteFor
	cmp	edx, ebp
	jge	SHORT $LN107@ExecuteFor
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	ebp, ecx
	jmp	SHORT $LN109@ExecuteFor
$LN107@ExecuteFor:
	xor	ebp, ebp
$LN109@ExecuteFor:

; 5135 : #endif
; 5136 : 
; 5137 : 			// Don't use if there's already someone here
; 5138 : 			if (!pLoopPlot->getBestDefender(NO_PLAYER))

	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	-1
	lea	ecx, DWORD PTR $T295101[esp+152]
	push	ecx
	mov	ecx, ebp
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T295101[esp+124]
	sete	bl
	test	ecx, ecx
	je	SHORT $LN150@ExecuteFor
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN150@ExecuteFor:
	test	bl, bl
	je	$LN200@ExecuteFor

; 5139 : 			{
; 5140 : 				if(FindClosestOperationUnit(pLoopPlot, false /*bSafeForRanged*/, false /*bMustBeRangedUnit*/))

	push	0
	push	0
	push	ebp
	mov	ecx, edi
	call	?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z ; CvTacticalAI::FindClosestOperationUnit
	test	al, al
	je	$LN200@ExecuteFor

; 5141 : 				{
; 5142 : #ifdef AUI_ITERATORIZE
; 5143 : 					UnitHandle pInnerUnit = m_pPlayer->getUnit(m_CurrentMoveUnits.begin()->GetID());
; 5144 : #else
; 5145 : 					UnitHandle pInnerUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pInnerUnit$222703[esp+124], esi
	mov	BYTE PTR _pInnerUnit$222703[esp+128], 0
	test	esi, esi
	je	SHORT $LN159@ExecuteFor
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN159@ExecuteFor:

; 5146 : #endif
; 5147 : 					bool bMoveWasSafe;
; 5148 : 					MoveToUsingSafeEmbark(pInnerUnit, pLoopPlot, bMoveWasSafe);

	lea	edx, DWORD PTR _bMoveWasSafe$222704[esp+120]
	push	edx
	push	ebp
	sub	esp, 8
	mov	eax, esp
	mov	BYTE PTR __$EHRec$[esp+148], 2
	mov	DWORD PTR $T295102[esp+136], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	test	esi, esi
	je	SHORT $LN164@ExecuteFor
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN164@ExecuteFor:
	mov	ecx, edi
	call	?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z ; CvTacticalAI::MoveToUsingSafeEmbark

; 5149 : 					pInnerUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 5150 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN21@ExecuteFor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN21@ExecuteFor

; 5151 : 					{
; 5152 : 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222707[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5153 : 						strMsg.Format("Deploying melee unit, %s, To X: %d, To Y: %d, At X: %d, At Y: %d", pInnerUnit->getName().GetCString(), pLoopPlot->getX(), pLoopPlot->getY(), pInnerUnit->getX(), pInnerUnit->getY());

	lea	eax, DWORD PTR $T295103[esp+124]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+136], 3
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+88]
	movsx	ebx, WORD PTR [ebp+2]
	mov	edx, DWORD PTR [esi+76]
	movsx	ebp, WORD PTR [ebp]
	push	ecx
	push	edx
	push	ebx
	push	ebp
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+148], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMsg$222707[esp+144]
	push	OFFSET $SG222709
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH
	lea	ecx, DWORD PTR $T295103[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5154 : 						LogTacticalMessage(strMsg);

	push	1
	lea	edx, DWORD PTR _strMsg$222707[esp+128]
	push	edx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 5155 : 					}

	lea	ecx, DWORD PTR _strMsg$222707[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN21@ExecuteFor:

; 5156 : 					iMeleeUnitsToPlace--;

	dec	DWORD PTR _iMeleeUnitsToPlace$222693[esp+124]

; 5157 : 				}

	mov	BYTE PTR __$EHRec$[esp+132], 0
	test	esi, esi
	je	SHORT $LN200@ExecuteFor
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN200@ExecuteFor:

; 5158 : 			}
; 5159 : 			if (iMeleeUnitsToPlace == 0)

	cmp	DWORD PTR _iMeleeUnitsToPlace$222693[esp+124], 0
	jne	SHORT $LN25@ExecuteFor

; 5160 : 			{
; 5161 : 				bDone = true;

	mov	BYTE PTR _bDone$222694[esp+120], 1
$LN25@ExecuteFor:

; 5122 : 		bool bDone = false;
; 5123 : #ifdef AUI_ITERATORIZE
; 5124 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5125 : 		{
; 5126 : 			eTargetType = it2->GetTargetType();
; 5127 : 
; 5128 : 			pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5129 : #else
; 5130 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	eax, DWORD PTR _iI$222695[esp+124]
	add	DWORD PTR tv1832[esp+124], 28		; 0000001cH
	inc	eax
	mov	DWORD PTR _iI$222695[esp+124], eax
	cmp	eax, DWORD PTR [edi+23708]
	jb	$LN26@ExecuteFor
$LN24@ExecuteFor:

; 5162 : 			}
; 5163 : 		}
; 5164 : 
; 5165 : 		// Log if someone in army didn't get a move assigned
; 5166 : 		if (iMeleeUnitsToPlace > 0)

	mov	ebx, DWORD PTR _iMeleeUnitsToPlace$222693[esp+124]
	xor	esi, esi
	cmp	ebx, esi
	jle	SHORT $LN18@ExecuteFor

; 5167 : 		{
; 5168 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN18@ExecuteFor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN18@ExecuteFor

; 5169 : 			{
; 5170 : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222713[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5171 : 				strMsg.Format("No army deployment move for %d melee units", iMeleeUnitsToPlace);

	push	ebx
	lea	eax, DWORD PTR _strMsg$222713[esp+128]
	push	OFFSET $SG222714
	push	eax
	mov	BYTE PTR __$EHRec$[esp+144], 5
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5172 : 				LogTacticalMessage(strMsg);

	push	1
	lea	ecx, DWORD PTR _strMsg$222713[esp+128]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 5173 : 			}

	lea	ecx, DWORD PTR _strMsg$222713[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN18@ExecuteFor:

; 5174 : 		}
; 5175 : 
; 5176 : 		// Second loop for ranged units
; 5177 : 		int iRangedUnitsToPlace = iRangedUnits;

	mov	edx, DWORD PTR _iRangedUnits$[esp+124]
	mov	DWORD PTR _iRangedUnitsToPlace$222715[esp+124], edx

; 5178 : 		bDone = false;

	mov	BYTE PTR _bDone$222694[esp+120], 0

; 5179 : #ifdef AUI_ITERATORIZE
; 5180 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5181 : 		{
; 5182 : 			eTargetType = it2->GetTargetType();
; 5183 : 
; 5184 : 			pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5185 : #else
; 5186 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	DWORD PTR _iI$222716[esp+124], esi
	cmp	DWORD PTR [edi+23708], esi
	jbe	$LN15@ExecuteFor

; 5174 : 		}
; 5175 : 
; 5176 : 		// Second loop for ranged units
; 5177 : 		int iRangedUnitsToPlace = iRangedUnits;

	mov	DWORD PTR tv1853[esp+124], esi
$LN17@ExecuteFor:

; 5179 : #ifdef AUI_ITERATORIZE
; 5180 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5181 : 		{
; 5182 : 			eTargetType = it2->GetTargetType();
; 5183 : 
; 5184 : 			pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5185 : #else
; 5186 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	cmp	BYTE PTR _bDone$222694[esp+120], 0
	jne	$LN15@ExecuteFor

; 5187 : 		{
; 5188 : 			eTargetType = m_TempTargets[iI].GetTargetType();

	mov	eax, DWORD PTR [edi+23704]
	mov	ecx, DWORD PTR tv1853[esp+124]
	mov	edx, DWORD PTR [eax+ecx]

; 5189 : 
; 5190 : 			pLoopPlot = GC.getMap().plot(m_TempTargets[iI].GetTargetX(), m_TempTargets[iI].GetTargetY());

	mov	ebx, DWORD PTR [eax+ecx+8]
	add	eax, ecx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _eTargetType$[esp+120], edx
	cmp	eax, -2147483647			; 80000001H
	je	$LN224@ExecuteFor
	cmp	ebx, -2147483647			; 80000001H
	je	$LN224@ExecuteFor
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN234@ExecuteFor
	test	eax, eax
	jge	SHORT $LN236@ExecuteFor
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN238@ExecuteFor
$LN236@ExecuteFor:
	cmp	eax, ecx
	jl	SHORT $LN234@ExecuteFor
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN238@ExecuteFor
$LN234@ExecuteFor:
	mov	esi, eax
$LN238@ExecuteFor:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN244@ExecuteFor
	test	ebx, ebx
	jge	SHORT $LN246@ExecuteFor
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN248@ExecuteFor
$LN246@ExecuteFor:
	cmp	ebx, ebp
	jl	SHORT $LN244@ExecuteFor
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN248@ExecuteFor
$LN244@ExecuteFor:
	mov	edx, ebx
$LN248@ExecuteFor:
	test	esi, esi
	jl	SHORT $LN224@ExecuteFor
	cmp	esi, ecx
	jge	SHORT $LN224@ExecuteFor
	test	edx, edx
	jl	SHORT $LN224@ExecuteFor
	cmp	edx, ebp
	jge	SHORT $LN224@ExecuteFor
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	ebp, ecx
	jmp	SHORT $LN226@ExecuteFor
$LN224@ExecuteFor:
	xor	ebp, ebp
$LN226@ExecuteFor:

; 5191 : #endif
; 5192 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)

	cmp	DWORD PTR _eTargetType$[esp+120], 7
	jne	$LN317@ExecuteFor

; 5193 : 			{
; 5194 : 				// Don't use if there's already someone here
; 5195 : 				if (!pLoopPlot->getBestDefender(NO_PLAYER))

	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	-1
	lea	ecx, DWORD PTR $T295105[esp+152]
	push	ecx
	mov	ecx, ebp
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T295105[esp+124]
	sete	bl
	test	ecx, ecx
	je	SHORT $LN267@ExecuteFor
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN267@ExecuteFor:
	test	bl, bl
	je	$LN317@ExecuteFor

; 5196 : 				{
; 5197 : 					if(FindClosestOperationUnit(pLoopPlot, true /*bSafeForRanged*/, true /*bMustBeRangedUnit*/))

	push	1
	push	1
	push	ebp
	mov	ecx, edi
	call	?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z ; CvTacticalAI::FindClosestOperationUnit
	test	al, al
	je	$LN317@ExecuteFor

; 5198 : 					{
; 5199 : #ifdef AUI_ITERATORIZE
; 5200 : 						UnitHandle pInnerUnit = m_pPlayer->getUnit(m_CurrentMoveUnits.begin()->GetID());
; 5201 : #else
; 5202 : 						UnitHandle pInnerUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pInnerUnit$222725[esp+124], esi
	mov	BYTE PTR _pInnerUnit$222725[esp+128], 0
	test	esi, esi
	je	SHORT $LN276@ExecuteFor
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN276@ExecuteFor:

; 5203 : #endif
; 5204 : 						bool bMoveWasSafe;
; 5205 : 						MoveToUsingSafeEmbark(pInnerUnit, pLoopPlot, bMoveWasSafe);

	lea	edx, DWORD PTR _bMoveWasSafe$222726[esp+120]
	push	edx
	push	ebp
	sub	esp, 8
	mov	eax, esp
	mov	BYTE PTR __$EHRec$[esp+148], 6
	mov	DWORD PTR $T295106[esp+136], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	test	esi, esi
	je	SHORT $LN281@ExecuteFor
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN281@ExecuteFor:
	mov	ecx, edi
	call	?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z ; CvTacticalAI::MoveToUsingSafeEmbark

; 5206 : 						pInnerUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 5207 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN11@ExecuteFor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN11@ExecuteFor

; 5208 : 						{
; 5209 : 							CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222729[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5210 : 							strMsg.Format("Deploying ranged unit, %s, To X: %d, To Y: %d, At X: %d, At Y: %d", pInnerUnit->getName().GetCString(), pLoopPlot->getX(), pLoopPlot->getY(), pInnerUnit->getX(), pInnerUnit->getY());

	lea	eax, DWORD PTR $T295107[esp+124]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+136], 7
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+88]
	movsx	ebx, WORD PTR [ebp+2]
	mov	edx, DWORD PTR [esi+76]
	movsx	ebp, WORD PTR [ebp]
	push	ecx
	push	edx
	push	ebx
	push	ebp
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+148], 8
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMsg$222729[esp+144]
	push	OFFSET $SG222731
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH
	lea	ecx, DWORD PTR $T295107[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5211 : 							LogTacticalMessage(strMsg);

	push	1
	lea	edx, DWORD PTR _strMsg$222729[esp+128]
	push	edx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 5212 : 						}

	lea	ecx, DWORD PTR _strMsg$222729[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN11@ExecuteFor:

; 5213 : 						iRangedUnitsToPlace--;

	dec	DWORD PTR _iRangedUnitsToPlace$222715[esp+124]

; 5214 : 					}

	mov	BYTE PTR __$EHRec$[esp+132], 0
	test	esi, esi
	je	SHORT $LN317@ExecuteFor
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN317@ExecuteFor:

; 5215 : 				}
; 5216 : 			}
; 5217 : 			if (iRangedUnitsToPlace == 0)

	cmp	DWORD PTR _iRangedUnitsToPlace$222715[esp+124], 0
	jne	SHORT $LN16@ExecuteFor

; 5218 : 			{
; 5219 : 				bDone = true;

	mov	BYTE PTR _bDone$222694[esp+120], 1
$LN16@ExecuteFor:

; 5179 : #ifdef AUI_ITERATORIZE
; 5180 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5181 : 		{
; 5182 : 			eTargetType = it2->GetTargetType();
; 5183 : 
; 5184 : 			pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5185 : #else
; 5186 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	eax, DWORD PTR _iI$222716[esp+124]
	add	DWORD PTR tv1853[esp+124], 28		; 0000001cH
	inc	eax
	mov	DWORD PTR _iI$222716[esp+124], eax
	cmp	eax, DWORD PTR [edi+23708]
	jb	$LN17@ExecuteFor
$LN15@ExecuteFor:

; 5220 : 			}
; 5221 : 		}
; 5222 : 
; 5223 : 		// Third loop for ranged units we couldn't put in an ideal spot
; 5224 : #ifdef AUI_ITERATORIZE
; 5225 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5226 : 		{
; 5227 : 			eTargetType = it2->GetTargetType();
; 5228 : 
; 5229 : 			pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5230 : #else
; 5231 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	xor	eax, eax
	mov	DWORD PTR _iI$222733[esp+124], eax
	cmp	DWORD PTR [edi+23708], eax
	jbe	$LN7@ExecuteFor
	mov	DWORD PTR tv1878[esp+124], eax
$LN9@ExecuteFor:
	cmp	BYTE PTR _bDone$222694[esp+120], 0
	jne	$LN7@ExecuteFor

; 5232 : 		{
; 5233 : 			eTargetType = m_TempTargets[iI].GetTargetType();
; 5234 : 
; 5235 : 			pLoopPlot = GC.getMap().plot(m_TempTargets[iI].GetTargetX(), m_TempTargets[iI].GetTargetY());

	mov	eax, DWORD PTR [edi+23704]
	mov	ecx, DWORD PTR tv1878[esp+124]
	mov	ebx, DWORD PTR [eax+ecx+8]
	add	eax, ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN335@ExecuteFor
	cmp	ebx, -2147483647			; 80000001H
	je	$LN335@ExecuteFor
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN345@ExecuteFor
	test	eax, eax
	jge	SHORT $LN347@ExecuteFor
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN349@ExecuteFor
$LN347@ExecuteFor:
	cmp	eax, ecx
	jl	SHORT $LN345@ExecuteFor
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN349@ExecuteFor
$LN345@ExecuteFor:
	mov	esi, eax
$LN349@ExecuteFor:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN355@ExecuteFor
	test	ebx, ebx
	jge	SHORT $LN357@ExecuteFor
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN359@ExecuteFor
$LN357@ExecuteFor:
	cmp	ebx, ebp
	jl	SHORT $LN355@ExecuteFor
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN359@ExecuteFor
$LN355@ExecuteFor:
	mov	edx, ebx
$LN359@ExecuteFor:
	test	esi, esi
	jl	SHORT $LN335@ExecuteFor
	cmp	esi, ecx
	jge	SHORT $LN335@ExecuteFor
	test	edx, edx
	jl	SHORT $LN335@ExecuteFor
	cmp	edx, ebp
	jge	SHORT $LN335@ExecuteFor
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	ebp, ecx
	jmp	SHORT $LN337@ExecuteFor
$LN335@ExecuteFor:
	xor	ebp, ebp
$LN337@ExecuteFor:

; 5236 : #endif
; 5237 : 
; 5238 : 			// Don't use if there's already someone here
; 5239 : 			if (!pLoopPlot->getBestDefender(NO_PLAYER))

	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	-1
	lea	eax, DWORD PTR $T295109[esp+152]
	push	eax
	mov	ecx, ebp
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T295109[esp+124]
	sete	bl
	test	ecx, ecx
	je	SHORT $LN378@ExecuteFor
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN378@ExecuteFor:
	test	bl, bl
	je	$LN428@ExecuteFor

; 5240 : 			{
; 5241 : 				if(FindClosestOperationUnit(pLoopPlot, true /*bSafeForRanged*/, true /*bMustBeRangedUnit*/))

	push	1
	push	1
	push	ebp
	mov	ecx, edi
	call	?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z ; CvTacticalAI::FindClosestOperationUnit
	test	al, al
	je	$LN428@ExecuteFor

; 5242 : 				{
; 5243 : #ifdef AUI_ITERATORIZE
; 5244 : 					UnitHandle pInnerUnit = m_pPlayer->getUnit(m_CurrentMoveUnits.begin()->GetID());
; 5245 : #else
; 5246 : 					UnitHandle pInnerUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pInnerUnit$222741[esp+124], esi
	mov	BYTE PTR _pInnerUnit$222741[esp+128], 0
	test	esi, esi
	je	SHORT $LN387@ExecuteFor
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN387@ExecuteFor:

; 5247 : #endif
; 5248 : 					bool bMoveWasSafe;
; 5249 : 					MoveToUsingSafeEmbark(pInnerUnit, pLoopPlot, bMoveWasSafe);

	lea	ecx, DWORD PTR _bMoveWasSafe$222742[esp+120]
	push	ecx
	push	ebp
	sub	esp, 8
	mov	eax, esp
	mov	BYTE PTR __$EHRec$[esp+148], 9
	mov	DWORD PTR $T295110[esp+136], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	test	esi, esi
	je	SHORT $LN392@ExecuteFor
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN392@ExecuteFor:
	mov	ecx, edi
	call	?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z ; CvTacticalAI::MoveToUsingSafeEmbark

; 5250 : 					pInnerUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 5251 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN4@ExecuteFor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN4@ExecuteFor

; 5252 : 					{
; 5253 : 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222745[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5254 : 						strMsg.Format("Deploying ranged unit (Pass 2), %s, To X: %d, To Y: %d, At X: %d, At Y: %d", pInnerUnit->getName().GetCString(), pLoopPlot->getX(), pLoopPlot->getY(), pInnerUnit->getX(), pInnerUnit->getY());

	lea	edx, DWORD PTR $T295111[esp+124]
	push	edx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+136], 10		; 0000000aH
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+88]
	movsx	ebx, WORD PTR [ebp+2]
	mov	edx, DWORD PTR [esi+76]
	movsx	ebp, WORD PTR [ebp]
	push	ecx
	push	edx
	push	ebx
	push	ebp
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+148], 11		; 0000000bH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strMsg$222745[esp+144]
	push	OFFSET $SG222747
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH
	lea	ecx, DWORD PTR $T295111[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 10		; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5255 : 						LogTacticalMessage(strMsg);

	push	1
	lea	ecx, DWORD PTR _strMsg$222745[esp+128]
	push	ecx
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 5256 : 					}

	lea	ecx, DWORD PTR _strMsg$222745[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@ExecuteFor:

; 5257 : 					iRangedUnitsToPlace--;

	dec	DWORD PTR _iRangedUnitsToPlace$222715[esp+124]

; 5258 : 				}

	mov	BYTE PTR __$EHRec$[esp+132], 0
	test	esi, esi
	je	SHORT $LN428@ExecuteFor
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN428@ExecuteFor:

; 5259 : 			}
; 5260 : 			if (iRangedUnitsToPlace == 0)

	cmp	DWORD PTR _iRangedUnitsToPlace$222715[esp+124], 0
	jne	SHORT $LN8@ExecuteFor

; 5261 : 			{
; 5262 : 				bDone = true;

	mov	BYTE PTR _bDone$222694[esp+120], 1
$LN8@ExecuteFor:

; 5220 : 			}
; 5221 : 		}
; 5222 : 
; 5223 : 		// Third loop for ranged units we couldn't put in an ideal spot
; 5224 : #ifdef AUI_ITERATORIZE
; 5225 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5226 : 		{
; 5227 : 			eTargetType = it2->GetTargetType();
; 5228 : 
; 5229 : 			pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5230 : #else
; 5231 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	eax, DWORD PTR _iI$222733[esp+124]
	add	DWORD PTR tv1878[esp+124], 28		; 0000001cH
	inc	eax
	mov	DWORD PTR _iI$222733[esp+124], eax
	cmp	eax, DWORD PTR [edi+23708]
	jb	$LN9@ExecuteFor
$LN7@ExecuteFor:

; 5263 : 			}
; 5264 : 		}
; 5265 : 
; 5266 : 		// Log if someone in army didn't get a move assigned
; 5267 : 		if (iRangedUnitsToPlace > 0)

	mov	esi, DWORD PTR _iRangedUnitsToPlace$222715[esp+124]
	test	esi, esi
	jle	SHORT $LN1@ExecuteFor

; 5268 : 		{
; 5269 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteFor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteFor

; 5270 : 			{
; 5271 : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222751[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5272 : 				strMsg.Format("No army deployment move for %d ranged units", iRangedUnitsToPlace);

	push	esi
	lea	edx, DWORD PTR _strMsg$222751[esp+128]
	push	OFFSET $SG222752
	push	edx
	mov	BYTE PTR __$EHRec$[esp+144], 12		; 0000000cH
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5273 : 				LogTacticalMessage(strMsg);

	push	1
	lea	eax, DWORD PTR _strMsg$222751[esp+128]
	push	eax
	mov	ecx, edi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 5274 : 			}

	lea	ecx, DWORD PTR _strMsg$222751[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteFor:

; 5275 : 		}
; 5276 : 	}
; 5277 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 108				; 0000006cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR _strLogString$222690[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$3:
	lea	ecx, DWORD PTR _pInnerUnit$222703[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$5:
	lea	ecx, DWORD PTR _strMsg$222707[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$6:
	lea	ecx, DWORD PTR $T295103[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$7:
	lea	ecx, DWORD PTR _strMsg$222713[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$9:
	lea	ecx, DWORD PTR _pInnerUnit$222725[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$11:
	lea	ecx, DWORD PTR _strMsg$222729[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$12:
	lea	ecx, DWORD PTR $T295107[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$14:
	lea	ecx, DWORD PTR _pInnerUnit$222741[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$16:
	lea	ecx, DWORD PTR _strMsg$222745[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$17:
	lea	ecx, DWORD PTR $T295111[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$18:
	lea	ecx, DWORD PTR _strMsg$222751[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ENDP ; CvTacticalAI::ExecuteFormationMoves
PUBLIC	?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ ; CvTacticalAI::EliminateNearbyBlockadePoints
EXTRN	__chkstk:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_it$ = -7208						; size = 4
tv588 = -7204						; size = 4
_this$ = -7200						; size = 4
_tempPoints$ = -7196					; size = 7184
__$EHRec$ = -12						; size = 12
?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ PROC ; CvTacticalAI::EliminateNearbyBlockadePoints, COMDAT
; _this$ = ecx

; 6020 : {

	push	-1
	push	__ehhandler$?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, 7196				; 00001c1cH
	mov	DWORD PTR fs:0, esp
	call	__chkstk
	push	ebx
	mov	ebx, ecx

; 6021 : 	// First, sort the sentry points by priority
; 6022 : 	std::stable_sort(m_NavalResourceBlockadePoints.begin(), m_NavalResourceBlockadePoints.end());

	mov	eax, DWORD PTR [ebx+16524]
	mov	ecx, DWORD PTR [ebx+16520]
	push	ebp
	lea	ebp, DWORD PTR [ebx+16520]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, ecx
	push	esi
	lea	eax, DWORD PTR [eax+edx*4]
	xor	esi, esi
	push	edi
	mov	DWORD PTR _this$[esp+7224], ebx
	cmp	ecx, eax
	je	SHORT $LN19@EliminateN
	push	esi
	push	esi
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 16					; 00000010H
$LN19@EliminateN:

; 6023 : 
; 6024 : 	// Create temporary copy of list
; 6025 : 	TacticalList tempPoints;

	mov	eax, 256				; 00000100H
	lea	ecx, DWORD PTR _tempPoints$[esp+7236]
	mov	DWORD PTR _tempPoints$[esp+7228], esi
	mov	DWORD PTR _tempPoints$[esp+7232], eax
	mov	DWORD PTR _tempPoints$[esp+7224], ecx
	mov	DWORD PTR __$EHRec$[esp+7232], esi

; 6026 : 	tempPoints = m_NavalResourceBlockadePoints;

	cmp	DWORD PTR [ebp+4], eax
	jb	SHORT $LL35@EliminateN
	mov	edx, DWORD PTR [ebp+8]
	push	edx
	lea	ecx, DWORD PTR _tempPoints$[esp+7228]
	call	?Alloc@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEPAVCvTacticalTarget@@I@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::Alloc
	mov	DWORD PTR _tempPoints$[esp+7224], eax
	npad	3
$LL35@EliminateN:
	push	ebp
	lea	ecx, DWORD PTR _tempPoints$[esp+7228]
	call	?Copy@?$BaseVector@VCvTacticalTarget@@$0A@@@IAEXABV1@@Z ; BaseVector<CvTacticalTarget,0>::Copy

; 6027 : 
; 6028 : 	// Clear out main list
; 6029 : 	m_NavalResourceBlockadePoints.clear();
; 6030 : 
; 6031 : 	// Loop through all points in copy
; 6032 : 	TacticalList::iterator it, it2;
; 6033 : 	for(it = tempPoints.begin(); it != tempPoints.end(); ++it)

	mov	ecx, DWORD PTR _tempPoints$[esp+7228]
	mov	eax, DWORD PTR _tempPoints$[esp+7224]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ebp+4], esi
	mov	DWORD PTR _it$[esp+7224], eax
	cmp	eax, ecx
	je	$LN9@EliminateN
	npad	3
$LL11@EliminateN:

; 6034 : 	{
; 6035 : 		bool bFoundAdjacent = false;
; 6036 : 
; 6037 : 		// Is it adjacent to a point in the main list?
; 6038 : 		for(it2 = m_NavalResourceBlockadePoints.begin(); it2 != m_NavalResourceBlockadePoints.end(); ++it2)

	mov	ecx, DWORD PTR [ebp+4]
	mov	esi, DWORD PTR [ebp]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+edx*4]
	cmp	esi, edx
	je	SHORT $LN125@EliminateN

; 6039 : 		{
; 6040 : 			if(plotDistance(it->GetTargetX(), it->GetTargetY(), it2->GetTargetX(), it2->GetTargetY()) <= 2)

	mov	edi, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	edx, esi
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv588[esp+7224], eax
$LL8@EliminateN:
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	push	edi
	push	ebx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jle	SHORT $LN127@EliminateN
	add	esi, 28					; 0000001cH
	cmp	esi, DWORD PTR tv588[esp+7224]
	jne	SHORT $LL8@EliminateN

; 6034 : 	{
; 6035 : 		bool bFoundAdjacent = false;
; 6036 : 
; 6037 : 		// Is it adjacent to a point in the main list?
; 6038 : 		for(it2 = m_NavalResourceBlockadePoints.begin(); it2 != m_NavalResourceBlockadePoints.end(); ++it2)

	mov	eax, DWORD PTR _it$[esp+7224]
$LN125@EliminateN:

; 6041 : 			{
; 6042 : 				bFoundAdjacent = true;
; 6043 : 				break;
; 6044 : 			}
; 6045 : 		}
; 6046 : 
; 6047 : 		if(!bFoundAdjacent)
; 6048 : 		{
; 6049 : 			m_NavalResourceBlockadePoints.push_back(*it);

	mov	ecx, DWORD PTR [ebp+8]
	mov	BYTE PTR [ebp+7180], 0
	cmp	DWORD PTR [ebp+4], ecx
	jne	SHORT $LN78@EliminateN
	push	ecx
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::GrowSize
	mov	eax, DWORD PTR _it$[esp+7224]
$LN78@EliminateN:
	mov	ecx, DWORD PTR [ebp+4]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR [ebp]
	lea	edi, DWORD PTR [ecx+edx*4]
	test	edi, edi
	je	SHORT $LN81@EliminateN
	mov	ecx, 7
	mov	esi, eax
	rep movsd
$LN81@EliminateN:
	inc	DWORD PTR [ebp+4]
	jmp	SHORT $LN10@EliminateN
$LN127@EliminateN:
	mov	eax, DWORD PTR _it$[esp+7224]
$LN10@EliminateN:

; 6027 : 
; 6028 : 	// Clear out main list
; 6029 : 	m_NavalResourceBlockadePoints.clear();
; 6030 : 
; 6031 : 	// Loop through all points in copy
; 6032 : 	TacticalList::iterator it, it2;
; 6033 : 	for(it = tempPoints.begin(); it != tempPoints.end(); ++it)

	mov	ecx, DWORD PTR _tempPoints$[esp+7228]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR _tempPoints$[esp+7224]
	add	eax, 28					; 0000001cH
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _it$[esp+7224], eax
	cmp	eax, edx
	jne	$LL11@EliminateN
	mov	ebx, DWORD PTR _this$[esp+7224]
$LN9@EliminateN:

; 6050 : 		}
; 6051 : 	}
; 6052 : 
; 6053 : 	// Now copy all points into main target list
; 6054 : 	for(it = m_NavalResourceBlockadePoints.begin(); it != m_NavalResourceBlockadePoints.end(); ++it)

	mov	eax, DWORD PTR [ebp+4]
	mov	esi, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	edx, esi
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _it$[esp+7224], esi
	cmp	esi, eax
	je	SHORT $LN1@EliminateN
	add	ebx, 2152				; 00000868H
$LL3@EliminateN:

; 6055 : 	{
; 6056 : 		m_AllTargets.push_back(*it);

	mov	eax, DWORD PTR [ebx+8]
	mov	BYTE PTR [ebx+7180], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN89@EliminateN
	push	eax
	mov	ecx, ebx
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::GrowSize
$LN89@EliminateN:
	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edi, DWORD PTR [edx+ecx*4]
	test	edi, edi
	je	SHORT $LN92@EliminateN
	mov	ecx, 7
	rep movsd
	mov	esi, DWORD PTR _it$[esp+7224]
$LN92@EliminateN:
	inc	DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	add	esi, 28					; 0000001cH
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _it$[esp+7224], esi
	cmp	esi, eax
	jne	SHORT $LL3@EliminateN
$LN1@EliminateN:

; 6057 : 	}
; 6058 : }

	mov	eax, DWORD PTR _tempPoints$[esp+7224]
	pop	edi
	pop	esi
	lea	ecx, DWORD PTR _tempPoints$[esp+7228]
	pop	ebp
	mov	DWORD PTR __$EHRec$[esp+7220], -1
	pop	ebx
	cmp	eax, ecx
	je	SHORT $LN98@EliminateN
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN98@EliminateN:
	mov	ecx, DWORD PTR __$EHRec$[esp+7208]
	mov	DWORD PTR fs:0, ecx
	add	esp, 7208				; 00001c28H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _tempPoints$[ebp]
	jmp	??1?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalTarget,256,0,297,0>::~FStaticVector<CvTacticalTarget,256,0,297,0>
__ehhandler$?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ ENDP ; CvTacticalAI::EliminateNearbyBlockadePoints
PUBLIC	?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteSafeBombards
EXTRN	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z:PROC ; CvPlot::canSeePlot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$9
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$11
	DD	08H
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$12
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$13
	DD	0aH
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$14
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$15
	DD	0cH
	DD	FLAT:__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$16
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z
_TEXT	SEGMENT
$T296265 = -196						; size = 4
_iRange$224324 = -196					; size = 4
_it$ = -196						; size = 4
_iRequiredDamage$ = -196				; size = 4
tv2009 = -192						; size = 4
_pTargetPlot$ = -192					; size = 4
$T296652 = -188						; size = 1
$T297239 = -188						; size = 4
_iDistance$224332 = -188				; size = 4
__Cat$296656 = -184					; size = 1
$T296654 = -184						; size = 1
$T297243 = -184						; size = 4
$T296233 = -184						; size = 4
$T296228 = -184						; size = 4
$T296222 = -184						; size = 4
_iTurnsToReach$224320 = -180				; size = 4
_iI$224260 = -180					; size = 4
_pFirstAttacker$ = -176					; size = 4
_iDX$ = -172						; size = 4
_iDY$ = -168						; size = 4
$T296408 = -164						; size = 4
_bFirstAttackCity$ = -160				; size = 1
_pBlockingUnit$224340 = -156				; size = 8
_pUnit$224286 = -156					; size = 8
_strMsg$224351 = -148					; size = 28
_strMsg$224346 = -148					; size = 28
_strMsg$224299 = -148					; size = 28
_strMsg$224294 = -148					; size = 28
tv2072 = -120						; size = 4
_strMsg$224356 = -116					; size = 28
_unit$ = -116						; size = 24
_pDefender$ = -88					; size = 8
$T296235 = -80						; size = 28
$T296234 = -80						; size = 28
$T296230 = -80						; size = 28
$T296229 = -80						; size = 28
_pUnit$224338 = -52					; size = 8
$T296236 = -44						; size = 28
__$EHRec$ = -12						; size = 12
_kTarget$ = 8						; size = 4
?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z PROC ; CvTacticalAI::ExecuteSafeBombards, COMDAT
; _this$ = ecx

; 7403 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 184				; 000000b8H
	push	ebx
	push	esi

; 7404 : 	CvTacticalUnit unit;

	xor	esi, esi
	push	edi
	mov	ebx, ecx
	mov	DWORD PTR _unit$[esp+208], esi
	mov	DWORD PTR _unit$[esp+212], esi
	mov	DWORD PTR _unit$[esp+216], esi
	mov	DWORD PTR _unit$[esp+220], esi
	mov	DWORD PTR _unit$[esp+224], esi
	mov	DWORD PTR _unit$[esp+228], esi

; 7405 : 	void* pFirstAttacker = NULL;

	mov	DWORD PTR _pFirstAttacker$[esp+208], esi

; 7406 : 	UnitHandle pDefender;

	mov	DWORD PTR _pDefender$[esp+208], esi
	mov	BYTE PTR _pDefender$[esp+212], 0

; 7407 : 	int iRequiredDamage = 0;
; 7408 : 	bool bCityCanAttack = false;
; 7409 : 	bool bFirstAttackCity = false;
; 7410 : 
; 7411 : 	CvPlot* pTargetPlot = GC.getMap().plot(kTarget.GetTargetX(), kTarget.GetTargetY());

	mov	eax, DWORD PTR _kTarget$[ebp]
	mov	edi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __$EHRec$[esp+216], esi
	mov	BYTE PTR _bFirstAttackCity$[esp+208], 0
	mov	DWORD PTR $T296265[esp+208], ecx
	cmp	edi, -2147483647			; 80000001H
	je	$LN79@ExecuteSaf
	cmp	ecx, -2147483647			; 80000001H
	je	$LN79@ExecuteSaf
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [eax+4056]
	mov	ecx, DWORD PTR [eax+4020]
	test	dl, dl
	je	SHORT $LN89@ExecuteSaf
	cmp	edi, esi
	jge	SHORT $LN91@ExecuteSaf
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN611@ExecuteSaf
$LN91@ExecuteSaf:
	cmp	edi, ecx
	jl	SHORT $LN89@ExecuteSaf
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN611@ExecuteSaf:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
$LN89@ExecuteSaf:
	mov	dl, BYTE PTR [eax+4057]
	mov	eax, DWORD PTR [eax+4024]
	test	dl, dl
	mov	edx, DWORD PTR $T296265[esp+208]
	mov	DWORD PTR tv2009[esp+208], eax
	je	SHORT $LN99@ExecuteSaf
	cmp	edx, esi
	jge	SHORT $LN101@ExecuteSaf
	mov	esi, DWORD PTR tv2009[esp+208]
	mov	eax, edx
	cdq
	idiv	esi
	add	edx, esi
	jmp	SHORT $LN612@ExecuteSaf
$LN101@ExecuteSaf:
	cmp	edx, eax
	jl	SHORT $LN99@ExecuteSaf
	mov	eax, edx
	cdq
	idiv	DWORD PTR tv2009[esp+208]
$LN612@ExecuteSaf:
	xor	esi, esi
$LN99@ExecuteSaf:
	cmp	edi, esi
	jl	SHORT $LN79@ExecuteSaf
	cmp	edi, ecx
	jge	SHORT $LN79@ExecuteSaf
	cmp	edx, esi
	jl	SHORT $LN79@ExecuteSaf
	cmp	edx, DWORD PTR tv2009[esp+208]
	jge	SHORT $LN79@ExecuteSaf
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	esi, ecx
	mov	DWORD PTR _pTargetPlot$[esp+208], ecx
	jmp	SHORT $LN81@ExecuteSaf
$LN79@ExecuteSaf:
	mov	DWORD PTR _pTargetPlot$[esp+208], esi
$LN81@ExecuteSaf:

; 7412 : 	if(PlotAlreadyTargeted(pTargetPlot) != -1)

	push	esi
	mov	ecx, ebx
	call	?PlotAlreadyTargeted@CvTacticalAI@@QAEHPAVCvPlot@@@Z ; CvTacticalAI::PlotAlreadyTargeted
	cmp	eax, -1

; 7413 : 	{
; 7414 : 		return false;

	jne	$LN582@ExecuteSaf

; 7415 : 	}
; 7416 : 
; 7417 : 	// Get required damage on unit target
; 7418 : 	pDefender = pTargetPlot->getVisibleEnemyDefender(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+44]
	push	eax
	mov	ecx, esi
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	mov	edi, eax
	mov	DWORD PTR $T296408[esp+208], edi
	mov	DWORD PTR _pDefender$[esp+208], edi
	test	edi, edi
	je	$LN48@ExecuteSaf
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 7419 : 	if(pDefender)
; 7420 : 	{
; 7421 : 		iRequiredDamage = pDefender->GetCurrHitPoints();

	mov	ecx, edi
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints

; 7422 : 
; 7423 : 		// If this is a unit target we might also be able to hit it with a city
; 7424 : 		bCityCanAttack = FindCitiesWithinStrikingDistance(pTargetPlot);

	push	esi
	mov	ecx, ebx
	mov	DWORD PTR _iRequiredDamage$[esp+212], eax
	call	?FindCitiesWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@@Z ; CvTacticalAI::FindCitiesWithinStrikingDistance

; 7425 : 		if(bCityCanAttack)

	test	al, al
	je	$LN606@ExecuteSaf

; 7426 : 		{
; 7427 : 			ComputeTotalExpectedBombardDamage(pDefender);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T296222[esp+216], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, ebx
	call	?ComputeTotalExpectedBombardDamage@CvTacticalAI@@AAEHV?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::ComputeTotalExpectedBombardDamage

; 7428 : 
; 7429 : 			// Start by applying damage from city bombards
; 7430 : 			for(unsigned int iI = 0; iI < m_CurrentMoveCities.size() && iRequiredDamage > 0; iI++)

	mov	ecx, DWORD PTR [ebx+60]
	sub	ecx, DWORD PTR [ebx+56]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iI$224260[esp+208], 0
	je	SHORT $LN606@ExecuteSaf

; 7426 : 		{
; 7427 : 			ComputeTotalExpectedBombardDamage(pDefender);

	xor	edi, edi
$LN46@ExecuteSaf:

; 7428 : 
; 7429 : 			// Start by applying damage from city bombards
; 7430 : 			for(unsigned int iI = 0; iI < m_CurrentMoveCities.size() && iRequiredDamage > 0; iI++)

	cmp	DWORD PTR _iRequiredDamage$[esp+208], 0
	jle	$LN1@ExecuteSaf

; 7431 : 			{
; 7432 : 				CvCity* pCity = m_pPlayer->getCity(m_CurrentMoveCities[iI].GetID());

	mov	eax, DWORD PTR [ebx+56]
	mov	ecx, DWORD PTR [ebx]
	add	eax, edi
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 7433 : 				if(pCity != NULL)

	test	esi, esi
	je	SHORT $LN45@ExecuteSaf

; 7434 : 				{
; 7435 : 					if(QueueAttack(pCity, &kTarget, true /*bRanged*/, true /*bCity*/))

	mov	ecx, DWORD PTR _kTarget$[ebp]
	push	1
	push	1
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z ; CvTacticalAI::QueueAttack
	test	al, al
	je	SHORT $LN42@ExecuteSaf

; 7436 : 					{
; 7437 : 						pFirstAttacker = (void*)pCity;

	mov	DWORD PTR _pFirstAttacker$[esp+208], esi

; 7438 : 						bFirstAttackCity = true;

	mov	BYTE PTR _bFirstAttackCity$[esp+208], 1
$LN42@ExecuteSaf:

; 7439 : 					}
; 7440 : 
; 7441 : 					// Subtract off expected damage
; 7442 : 					iRequiredDamage -= m_CurrentMoveCities[iI].GetExpectedTargetDamage();

	mov	edx, DWORD PTR [ebx+56]
	mov	eax, DWORD PTR [edx+edi+8]
	sub	DWORD PTR _iRequiredDamage$[esp+208], eax
$LN45@ExecuteSaf:
	mov	ecx, DWORD PTR [ebx+60]
	sub	ecx, DWORD PTR [ebx+56]
	mov	esi, DWORD PTR _iI$224260[esp+208]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	inc	esi
	add	ecx, edx
	add	edi, 12					; 0000000cH
	mov	DWORD PTR _iI$224260[esp+208], esi
	cmp	esi, ecx
	jb	SHORT $LN46@ExecuteSaf
$LN606@ExecuteSaf:

; 7443 : 				}
; 7444 : 			}
; 7445 : 		}
; 7446 : 	}
; 7447 : 
; 7448 : 	// Get required damage on city target
; 7449 : 	else

	mov	edi, DWORD PTR _iRequiredDamage$[esp+208]
$LN39@ExecuteSaf:

; 7460 : 			}
; 7461 : 		}
; 7462 : 	}
; 7463 : 
; 7464 : 	// Need to keep hitting target?
; 7465 : 	if(iRequiredDamage <= 0)

	test	edi, edi

; 7466 : 	{
; 7467 : 		return false;

	jle	$LN1@ExecuteSaf

; 7468 : 	}
; 7469 : 
; 7470 : 	// For each of our ranged units, see if they are already in a plot that can bombard that can't be attacked.
; 7471 : 	// If so, bombs away!
; 7472 : 	m_CurrentMoveUnits.clear();

	mov	eax, DWORD PTR [ebx+28]
	mov	ecx, DWORD PTR [ebx+24]
	cmp	ecx, eax
	je	SHORT $LN182@ExecuteSaf
	mov	BYTE PTR $T296652[esp+208], 0
	mov	edx, DWORD PTR $T296652[esp+208]
	push	edx
	mov	edx, DWORD PTR __Cat$296656[esp+212]
	push	edx
	mov	edx, DWORD PTR $T296654[esp+216]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvTacticalUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalUnit *,CvTacticalUnit *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebx+28], eax
$LN182@ExecuteSaf:

; 7473 : 	list<int>::iterator it;
; 7474 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 7475 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 7476 : #else
; 7477 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _it$[esp+208], ecx
	cmp	ecx, eax
	je	$LN35@ExecuteSaf
$LL223@ExecuteSaf:

; 7478 : #endif
; 7479 : 	{
; 7480 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR _it$[esp+208]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$224286[esp+208], esi
	mov	BYTE PTR _pUnit$224286[esp+212], 0
	test	esi, esi
	je	SHORT $LN246@ExecuteSaf
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN246@ExecuteSaf:
	mov	BYTE PTR __$EHRec$[esp+216], 1

; 7481 : 		if(pUnit && pUnit->IsCanAttackRanged() && !pUnit->isOutOfAttacks())

	test	esi, esi
	je	$LN30@ExecuteSaf
	mov	ecx, esi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	$LN30@ExecuteSaf
	mov	ecx, esi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	jne	$LN30@ExecuteSaf

; 7482 : 		{
; 7483 : 			int iPlotIndex = GC.getMap().plotNum(pUnit->getX(), pUnit->getY());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [esi+88]
	mov	edi, DWORD PTR [edx+4020]
	mov	ecx, DWORD PTR [esi+76]
	imul	edi, eax
	add	edi, ecx

; 7484 : 			CvTacticalAnalysisCell* pCell = GC.getGame().GetTacticalAnalysisMap()->GetCell(iPlotIndex);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	imul	edi, 44					; 0000002cH
	add	edi, DWORD PTR [eax+12]

; 7485 : 			if(pCell->IsWithinRangeOfTarget() && !pCell->IsSubjectToAttack() && IsExpectedToDamageWithRangedAttack(pUnit, pTargetPlot))

	mov	eax, DWORD PTR [edi]
	mov	ecx, eax
	shr	ecx, 17					; 00000011H
	test	cl, 1
	je	$LN30@ExecuteSaf
	shr	eax, 5
	test	al, 1
	jne	$LN30@ExecuteSaf
	mov	edx, DWORD PTR _pTargetPlot$[esp+208]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T296228[esp+220], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, ebx
	call	?IsExpectedToDamageWithRangedAttack@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@@Z ; CvTacticalAI::IsExpectedToDamageWithRangedAttack
	test	al, al
	je	$LN30@ExecuteSaf

; 7486 : 			{
; 7487 : 				if(pUnit->canSetUpForRangedAttack(NULL))

	push	0
	mov	ecx, esi
	call	?canSetUpForRangedAttack@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canSetUpForRangedAttack
	test	al, al
	je	$LN31@ExecuteSaf

; 7488 : 				{
; 7489 : 					pUnit->setSetUpForRangedAttack(true);

	push	1
	mov	ecx, esi
	call	?setSetUpForRangedAttack@CvUnit@@QAEX_N@Z ; CvUnit::setSetUpForRangedAttack

; 7490 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN31@ExecuteSaf
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN31@ExecuteSaf

; 7491 : 					{
; 7492 : 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224294[esp+208]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7493 : 						strMsg.Format("Set up %s for ranged attack", pUnit->getName().GetCString());

	lea	eax, DWORD PTR $T296229[esp+208]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+220], 2
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+216], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMsg$224294[esp+212]
	push	OFFSET $SG224296
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T296229[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7494 : 						LogTacticalMessage(strMsg, false);

	push	0
	lea	edx, DWORD PTR _strMsg$224294[esp+212]
	push	edx
	mov	ecx, ebx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7495 : 					}

	lea	ecx, DWORD PTR _strMsg$224294[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN31@ExecuteSaf:

; 7496 : 				}
; 7497 : 
; 7498 : 				if(pUnit->canMove() && pUnit->canRangeStrikeAt(kTarget.GetTargetX(), kTarget.GetTargetY()))

	mov	ecx, esi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN30@ExecuteSaf
	mov	edi, DWORD PTR _kTarget$[ebp]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	1
	push	1
	push	eax
	push	ecx
	mov	ecx, esi
	call	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z	; CvUnit::canRangeStrikeAt
	test	al, al
	je	$LN30@ExecuteSaf

; 7499 : 				{
; 7500 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN29@ExecuteSaf
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN29@ExecuteSaf

; 7501 : 					{
; 7502 : 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224299[esp+208]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7503 : 						strMsg.Format("Making a safe bombard (no move) with %s, Target X: %d, Target Y: %d, At X: %d, At Y: %d", pUnit->getName().GetCString(),
; 7504 : 						              kTarget.GetTargetX(), kTarget.GetTargetY(), pUnit->getX(), pUnit->getY());

	lea	eax, DWORD PTR $T296230[esp+208]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+220], 4
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+88]
	mov	edx, DWORD PTR [edi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi+76]
	push	ecx
	mov	ecx, DWORD PTR [edi+8]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+232], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMsg$224299[esp+228]
	push	OFFSET $SG224301
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH
	lea	ecx, DWORD PTR $T296230[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7505 : 						LogTacticalMessage(strMsg, false);

	push	0
	lea	edx, DWORD PTR _strMsg$224299[esp+212]
	push	edx
	mov	ecx, ebx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7506 : 					}

	lea	ecx, DWORD PTR _strMsg$224299[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN29@ExecuteSaf:

; 7507 : 
; 7508 : 					if(QueueAttack((void*)pUnit.pointer(), &kTarget, true /*bRanged*/, false /*bCity*/))

	push	0
	push	1
	push	edi
	push	esi
	mov	ecx, ebx
	call	?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z ; CvTacticalAI::QueueAttack
	test	al, al
	je	SHORT $LN28@ExecuteSaf

; 7509 : 					{
; 7510 : 						pFirstAttacker = (void*)pUnit.pointer();

	mov	DWORD PTR _pFirstAttacker$[esp+208], esi
$LN28@ExecuteSaf:

; 7511 : 					}
; 7512 : 
; 7513 : 					// Save off ID so can be cleared from list to process for turn
; 7514 : 					unit.SetID(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]

; 7515 : 					m_CurrentMoveUnits.push_back(unit);

	lea	ecx, DWORD PTR _unit$[esp+208]
	push	ecx
	lea	ecx, DWORD PTR [ebx+20]
	mov	DWORD PTR _unit$[esp+212], eax
	call	?push_back@?$vector@VCvTacticalUnit@@V?$allocator@VCvTacticalUnit@@@std@@@std@@QAEXABVCvTacticalUnit@@@Z ; std::vector<CvTacticalUnit,std::allocator<CvTacticalUnit> >::push_back
$LN30@ExecuteSaf:

; 7516 : 				}
; 7517 : 			}
; 7518 : 		}
; 7519 : 	}

	mov	BYTE PTR __$EHRec$[esp+216], 0
	test	esi, esi
	je	SHORT $LN36@ExecuteSaf
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN36@ExecuteSaf:
	mov	edx, DWORD PTR _it$[esp+208]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$[esp+208], eax
	cmp	eax, DWORD PTR [ebx+12]
	jne	$LL223@ExecuteSaf
$LN35@ExecuteSaf:

; 7520 : 
; 7521 : 	// Clear out the units we just processed from the list for this turn
; 7522 : 	std::vector<CvTacticalUnit>::iterator currMoveIt;
; 7523 : 	for(currMoveIt = m_CurrentMoveUnits.begin(); currMoveIt != m_CurrentMoveUnits.end(); ++currMoveIt)

	mov	esi, DWORD PTR [ebx+24]
	cmp	esi, DWORD PTR [ebx+28]
	je	SHORT $LN25@ExecuteSaf
$LL372@ExecuteSaf:

; 7524 : 	{
; 7525 : 		UnitProcessed(currMoveIt->GetID());

	mov	eax, DWORD PTR [esi]
	push	1
	push	eax
	mov	ecx, ebx
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed
	add	esi, 24					; 00000018H
	cmp	esi, DWORD PTR [ebx+28]
	jne	SHORT $LL372@ExecuteSaf
$LN25@ExecuteSaf:

; 7526 : 	}
; 7527 : 
; 7528 : 	// For each plot that we can bombard from that the enemy can't attack, try and move a ranged unit there.
; 7529 : 	// If so, make that move and mark that tile as blocked with our unit.  If unit has movement left, queue up an attack
; 7530 : 	int iDX, iDY;
; 7531 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 7532 : 	int iMaxDX;
; 7533 : #endif
; 7534 : 	CvPlot* pLoopPlot;
; 7535 : 	int iPlotIndex;
; 7536 : 	CvTacticalAnalysisCell* pCell;
; 7537 : 
; 7538 : 	for(int iTurnsToReach = 0; iTurnsToReach <= 2; iTurnsToReach++)

	mov	DWORD PTR _iTurnsToReach$224320[esp+208], 0
$LL24@ExecuteSaf:

; 7539 : 	{
; 7540 : 		int iRange = m_pMap->GetBestFriendlyRange();

	mov	eax, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+28]

; 7541 : 
; 7542 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 7543 : 		for (iDY = -iRange; iDY <= iRange; iDY++)
; 7544 : 		{
; 7545 : 			iMaxDX = iRange - MAX(0, iDY);
; 7546 : 			for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 7547 : #else
; 7548 : 		for(iDX = -(iRange); iDX <= iRange; iDX++)

	mov	ecx, eax
	neg	ecx
	cmp	ecx, eax
	mov	DWORD PTR _iRange$224324[esp+208], eax
	mov	DWORD PTR tv2072[esp+208], ecx
	mov	DWORD PTR _iDX$[esp+208], ecx
	jg	$LN23@ExecuteSaf
$LL21@ExecuteSaf:

; 7549 : 		{
; 7550 : 			for(iDY = -(iRange); iDY <= iRange; iDY++)

	mov	eax, DWORD PTR tv2072[esp+208]
	cmp	eax, DWORD PTR _iRange$224324[esp+208]
	mov	DWORD PTR _iDY$[esp+208], eax
	jg	$LN20@ExecuteSaf
$LL18@ExecuteSaf:

; 7551 : #endif
; 7552 : 			{
; 7553 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 7554 : 				if (iDX == 0 && iDY == 0)
; 7555 : 					continue;
; 7556 : #endif
; 7557 : 				pLoopPlot = plotXY(kTarget.GetTargetX(), kTarget.GetTargetY(), iDX, iDY);

	mov	edx, DWORD PTR _iDY$[esp+208]
	mov	ecx, DWORD PTR _kTarget$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+4]
	push	edx
	mov	edx, DWORD PTR _iDX$[esp+212]
	push	edx
	push	eax
	push	ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	edi, eax
	add	esp, 16					; 00000010H

; 7558 : 				if(pLoopPlot != NULL)

	test	edi, edi
	je	$LN17@ExecuteSaf

; 7559 : 				{
; 7560 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 7561 : 					int iDistance = hexDistance(iDX, iDY);
; 7562 : #else
; 7563 : 					int iDistance = plotDistance(pLoopPlot->getX(), pLoopPlot->getY(), kTarget.GetTargetX(), kTarget.GetTargetY());

	mov	edx, DWORD PTR _kTarget$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	movsx	esi, WORD PTR [edi+2]
	movsx	eax, WORD PTR [edi]
	push	ecx
	mov	ecx, DWORD PTR [edx+4]
	push	ecx
	push	esi
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$224332[esp+208], eax

; 7564 : #endif
; 7565 : #ifndef AUI_HEXSPACE_DX_LOOPS
; 7566 : 					if(iDistance > 0 && iDistance <= iRange)

	test	eax, eax
	jle	$LN17@ExecuteSaf
	mov	eax, DWORD PTR _iRange$224324[esp+208]
	cmp	DWORD PTR _iDistance$224332[esp+208], eax
	jg	$LN17@ExecuteSaf

; 7567 : #endif
; 7568 : 					{
; 7569 : 						iPlotIndex = GC.getMap().plotNum(pLoopPlot->getX(), pLoopPlot->getY());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	esi, DWORD PTR [ecx+4020]
	movsx	eax, WORD PTR [edi]

; 7570 : 						pCell = m_pMap->GetCell(iPlotIndex);

	mov	edx, DWORD PTR [ebx+4]
	add	esi, eax
	mov	eax, esi
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [edx+12]
	mov	esi, eax

; 7571 : 						if(pCell->IsRevealed() && pCell->CanUseForOperationGathering())

	test	BYTE PTR [esi], 1
	je	$LN17@ExecuteSaf
	mov	ecx, esi
	call	?CanUseForOperationGathering@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::CanUseForOperationGathering
	test	al, al
	je	$LN17@ExecuteSaf

; 7572 : 						{
; 7573 : 							if(pCell->IsWithinRangeOfTarget() && !pCell->IsSubjectToAttack())

	mov	esi, DWORD PTR [esi]
	mov	eax, esi
	shr	eax, 17					; 00000011H
	test	al, 1
	je	$LN17@ExecuteSaf
	mov	ecx, esi
	shr	ecx, 5
	test	cl, 1
	jne	$LN17@ExecuteSaf

; 7574 : 							{
; 7575 : 								bool bHaveLOS = pLoopPlot->canSeePlot(pTargetPlot, m_pPlayer->getTeam(), iRange, NO_DIRECTION);

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN434@ExecuteSaf
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN435@ExecuteSaf
$LN48@ExecuteSaf:

; 7450 : 	{
; 7451 : 		CvCity* pCity = pTargetPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	$LN1@ExecuteSaf
	cmp	eax, 64					; 00000040H
	jge	$LN1@ExecuteSaf
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 7452 : 		if(pCity != NULL)

	test	esi, esi
	je	$LN1@ExecuteSaf

; 7453 : 		{
; 7454 : 			iRequiredDamage = pCity->GetMaxHitPoints() - pCity->getDamage();

	mov	ecx, esi
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, esi
	mov	edi, eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	sub	edi, eax

; 7455 : 
; 7456 : 			// Can't eliminate a city with ranged fire, so don't target one if that low on health
; 7457 : 			if(iRequiredDamage <= 1)

	cmp	edi, 1
	jg	$LN39@ExecuteSaf

; 7458 : 			{
; 7459 : 				return false;

	jmp	$LN582@ExecuteSaf

; 7574 : 							{
; 7575 : 								bool bHaveLOS = pLoopPlot->canSeePlot(pTargetPlot, m_pPlayer->getTeam(), iRange, NO_DIRECTION);

$LN434@ExecuteSaf:
	or	eax, -1
$LN435@ExecuteSaf:
	mov	ecx, DWORD PTR _iRange$224324[esp+208]
	mov	esi, DWORD PTR _pTargetPlot$[esp+208]
	push	-1
	push	ecx
	push	eax
	push	esi
	mov	ecx, edi
	call	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ; CvPlot::canSeePlot

; 7576 : 								if(FindClosestUnit(pLoopPlot, iTurnsToReach, false/*bMustHaveHalfHP*/, true/*bMustBeRangedUnit*/, iDistance, !bHaveLOS, false/*bMustBeMeleeUnit*/, true/*bIgnoreUnits*/, pTargetPlot))

	mov	ecx, DWORD PTR _iDistance$224332[esp+208]
	push	esi
	push	1
	test	al, al
	push	0
	sete	dl
	movzx	eax, dl
	mov	edx, DWORD PTR _iTurnsToReach$224320[esp+220]
	push	eax
	push	ecx
	push	1
	push	0
	push	edx
	push	edi
	mov	ecx, ebx
	call	?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z ; CvTacticalAI::FindClosestUnit
	test	al, al
	je	$LN17@ExecuteSaf

; 7577 : 								{
; 7578 : 									UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$224338[esp+208], esi
	mov	BYTE PTR _pUnit$224338[esp+212], 0
	test	esi, esi
	je	SHORT $LN446@ExecuteSaf
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN446@ExecuteSaf:
	mov	BYTE PTR __$EHRec$[esp+216], 6

; 7579 : 									if(pUnit)

	test	esi, esi
	je	$LN567@ExecuteSaf

; 7580 : 									{
; 7581 : 										// Check for presence of unmovable friendly units
; 7582 : 										UnitHandle pBlockingUnit = pLoopPlot->getBestDefender(m_pPlayer->GetID());

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	eax
	lea	ecx, DWORD PTR _pBlockingUnit$224340[esp+236]
	push	ecx
	mov	ecx, edi
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender

; 7583 : 										if(!pBlockingUnit || ExecuteMoveOfBlockingUnit(pBlockingUnit))

	mov	ecx, DWORD PTR _pBlockingUnit$224340[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 7
	test	ecx, ecx
	je	SHORT $LN8@ExecuteSaf
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _pBlockingUnit$224340[esp+220]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T296233[esp+216], esp
	test	eax, eax
	je	SHORT $LN459@ExecuteSaf
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN459@ExecuteSaf:
	mov	ecx, ebx
	call	?ExecuteMoveOfBlockingUnit@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z ; CvTacticalAI::ExecuteMoveOfBlockingUnit
	test	al, al
	je	$LN2@ExecuteSaf
$LN8@ExecuteSaf:

; 7584 : 										{
; 7585 : 											pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pLoopPlot->getX(), pLoopPlot->getY());

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 7586 : 
; 7587 : 											if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN7@ExecuteSaf
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN7@ExecuteSaf

; 7588 : 											{
; 7589 : 												CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224346[esp+208]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7590 : 												strMsg.Format("Moving closer for safe bombard with %s, Target X: %d, Y: %d, Bombard From X: %d, Y: %d, Now At X: %d, Y: %d", pUnit->getName().GetCString(),
; 7591 : 												              kTarget.GetTargetX(), kTarget.GetTargetY(), pLoopPlot->getX(), pLoopPlot->getY(), pUnit->getX(), pUnit->getY());

	lea	eax, DWORD PTR $T296234[esp+208]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+220], 8
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	movsx	edx, WORD PTR [edi+2]
	movsx	edi, WORD PTR [edi]
	mov	ecx, DWORD PTR [esi+88]
	push	ecx
	mov	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR $T297239[esp+212], edi
	mov	edi, DWORD PTR _kTarget$[ebp]
	mov	edi, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, DWORD PTR $T297239[esp+216]
	push	edx
	mov	DWORD PTR $T297243[esp+220], edi
	mov	edx, DWORD PTR $T297243[esp+220]
	mov	edi, DWORD PTR _kTarget$[ebp]
	mov	edi, DWORD PTR [edi+4]
	push	ecx
	push	edx
	push	edi
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+240], 9
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strMsg$224346[esp+236]
	push	OFFSET $SG224348
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 36					; 00000024H
	lea	ecx, DWORD PTR $T296234[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7592 : 												LogTacticalMessage(strMsg, false);

	push	0
	lea	ecx, DWORD PTR _strMsg$224346[esp+212]
	push	ecx
	mov	ecx, ebx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7593 : 											}

	lea	ecx, DWORD PTR _strMsg$224346[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@ExecuteSaf:

; 7594 : 
; 7595 : 											UnitProcessed(m_CurrentMoveUnits[0].GetID());

	mov	edx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [edx]
	push	1
	push	eax
	mov	ecx, ebx
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 7596 : 
; 7597 : 											if(pUnit->canSetUpForRangedAttack(NULL))

	push	0
	mov	ecx, esi
	call	?canSetUpForRangedAttack@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canSetUpForRangedAttack
	test	al, al
	je	$LN5@ExecuteSaf

; 7598 : 											{
; 7599 : 												pUnit->setSetUpForRangedAttack(true);

	push	1
	mov	ecx, esi
	call	?setSetUpForRangedAttack@CvUnit@@QAEX_N@Z ; CvUnit::setSetUpForRangedAttack

; 7600 : 												if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN5@ExecuteSaf
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN5@ExecuteSaf

; 7601 : 												{
; 7602 : 													CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224351[esp+208]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7603 : 													strMsg.Format("Set up %s for ranged attack", pUnit->getName().GetCString());

	lea	eax, DWORD PTR $T296235[esp+208]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+220], 10		; 0000000aH
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+216], 11		; 0000000bH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMsg$224351[esp+212]
	push	OFFSET $SG224353
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T296235[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 10		; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7604 : 													LogTacticalMessage(strMsg, false);

	push	0
	lea	edx, DWORD PTR _strMsg$224351[esp+212]
	push	edx
	mov	ecx, ebx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7605 : 												}

	lea	ecx, DWORD PTR _strMsg$224351[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@ExecuteSaf:

; 7606 : 											}
; 7607 : 
; 7608 : 											if(pUnit->canMove() && !pUnit->isOutOfAttacks() && pUnit->canRangeStrikeAt(kTarget.GetTargetX(), kTarget.GetTargetY()))

	mov	ecx, esi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN2@ExecuteSaf
	mov	ecx, esi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	jne	$LN2@ExecuteSaf
	mov	edi, DWORD PTR _kTarget$[ebp]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	1
	push	1
	push	eax
	push	ecx
	mov	ecx, esi
	call	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z	; CvUnit::canRangeStrikeAt
	test	al, al
	je	$LN2@ExecuteSaf

; 7609 : 											{
; 7610 : 												if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN3@ExecuteSaf
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN3@ExecuteSaf

; 7611 : 												{
; 7612 : 													CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224356[esp+208]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7613 : 													strMsg.Format("Making a safe bombard (half move) with %s, Target X: %d, Target Y: %d, At X: %d, At Y: %d", pUnit->getName().GetCString(),
; 7614 : 													              kTarget.GetTargetX(), kTarget.GetTargetY(), pUnit->getX(), pUnit->getY());

	lea	eax, DWORD PTR $T296236[esp+208]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+220], 12		; 0000000cH
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+88]
	mov	edx, DWORD PTR [edi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi+76]
	push	ecx
	mov	ecx, DWORD PTR [edi+8]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+232], 13		; 0000000dH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMsg$224356[esp+228]
	push	OFFSET $SG224358
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH
	lea	ecx, DWORD PTR $T296236[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 12		; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7615 : 													LogTacticalMessage(strMsg, false);

	push	0
	lea	edx, DWORD PTR _strMsg$224356[esp+212]
	push	edx
	mov	ecx, ebx
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7616 : 												}

	lea	ecx, DWORD PTR _strMsg$224356[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@ExecuteSaf:

; 7617 : 
; 7618 : 												if(QueueAttack((void*)pUnit.pointer(), &kTarget, true /*bRanged*/, false /*bCityAttack*/))

	push	0
	push	1
	push	edi
	push	esi
	mov	ecx, ebx
	call	?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z ; CvTacticalAI::QueueAttack
	test	al, al
	je	SHORT $LN2@ExecuteSaf

; 7619 : 												{
; 7620 : 													pFirstAttacker = (void*)pUnit.pointer();

	mov	DWORD PTR _pFirstAttacker$[esp+208], esi
$LN2@ExecuteSaf:

; 7621 : 												}
; 7622 : 											}
; 7623 : 										}
; 7624 : 									}

	mov	ecx, DWORD PTR _pBlockingUnit$224340[esp+208]
	mov	BYTE PTR __$EHRec$[esp+216], 6
	test	ecx, ecx
	je	SHORT $LN567@ExecuteSaf
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN567@ExecuteSaf:

; 7625 : 								}

	mov	BYTE PTR __$EHRec$[esp+216], 0
	test	esi, esi
	je	SHORT $LN17@ExecuteSaf
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN17@ExecuteSaf:
	mov	eax, DWORD PTR _iDY$[esp+208]
	inc	eax
	cmp	eax, DWORD PTR _iRange$224324[esp+208]
	mov	DWORD PTR _iDY$[esp+208], eax
	jle	$LL18@ExecuteSaf
$LN20@ExecuteSaf:

; 7541 : 
; 7542 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 7543 : 		for (iDY = -iRange; iDY <= iRange; iDY++)
; 7544 : 		{
; 7545 : 			iMaxDX = iRange - MAX(0, iDY);
; 7546 : 			for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 7547 : #else
; 7548 : 		for(iDX = -(iRange); iDX <= iRange; iDX++)

	mov	eax, DWORD PTR _iDX$[esp+208]
	inc	eax
	cmp	eax, DWORD PTR _iRange$224324[esp+208]
	mov	DWORD PTR _iDX$[esp+208], eax
	jle	$LL21@ExecuteSaf
$LN23@ExecuteSaf:

; 7526 : 	}
; 7527 : 
; 7528 : 	// For each plot that we can bombard from that the enemy can't attack, try and move a ranged unit there.
; 7529 : 	// If so, make that move and mark that tile as blocked with our unit.  If unit has movement left, queue up an attack
; 7530 : 	int iDX, iDY;
; 7531 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 7532 : 	int iMaxDX;
; 7533 : #endif
; 7534 : 	CvPlot* pLoopPlot;
; 7535 : 	int iPlotIndex;
; 7536 : 	CvTacticalAnalysisCell* pCell;
; 7537 : 
; 7538 : 	for(int iTurnsToReach = 0; iTurnsToReach <= 2; iTurnsToReach++)

	mov	eax, DWORD PTR _iTurnsToReach$224320[esp+208]
	inc	eax
	cmp	eax, 2
	mov	DWORD PTR _iTurnsToReach$224320[esp+208], eax
	jle	$LL24@ExecuteSaf

; 7626 : 							}
; 7627 : 						}
; 7628 : 					}
; 7629 : 				}
; 7630 : 			}
; 7631 : 		}
; 7632 : 	}
; 7633 : 
; 7634 : 	// Launch the initial attack plotted
; 7635 : 	if(pFirstAttacker)

	mov	eax, DWORD PTR _pFirstAttacker$[esp+208]
	test	eax, eax
	je	SHORT $LN1@ExecuteSaf

; 7636 : 	{
; 7637 : 		LaunchAttack(pFirstAttacker, &kTarget, true /*bFirst*/, true /*bFirstAttackRanged*/, bFirstAttackCity);

	mov	ecx, DWORD PTR _bFirstAttackCity$[esp+208]
	mov	edx, DWORD PTR _kTarget$[ebp]
	push	ecx
	push	1
	push	1
	push	edx
	push	eax
	mov	ecx, ebx
	call	?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z ; CvTacticalAI::LaunchAttack

; 7638 : 		return true;

	mov	ecx, DWORD PTR $T296408[esp+208]
	mov	DWORD PTR __$EHRec$[esp+216], -1
	test	ecx, ecx
	je	SHORT $LN577@ExecuteSaf
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN577@ExecuteSaf:
	mov	al, 1

; 7641 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+208]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN1@ExecuteSaf:

; 7639 : 	}
; 7640 : 	return false;

	mov	ecx, DWORD PTR $T296408[esp+208]
	mov	DWORD PTR __$EHRec$[esp+216], -1
	test	ecx, ecx
	je	SHORT $LN582@ExecuteSaf
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN582@ExecuteSaf:

; 7641 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+208]
	pop	edi
	pop	esi
	xor	al, al
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$0:
	lea	ecx, DWORD PTR _pDefender$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$2:
	lea	ecx, DWORD PTR _pUnit$224286[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$4:
	lea	ecx, DWORD PTR _strMsg$224294[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$5:
	lea	ecx, DWORD PTR $T296229[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$6:
	lea	ecx, DWORD PTR _strMsg$224299[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$7:
	lea	ecx, DWORD PTR $T296230[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$8:
	lea	ecx, DWORD PTR _pUnit$224338[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$9:
	lea	ecx, DWORD PTR _pBlockingUnit$224340[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$11:
	lea	ecx, DWORD PTR _strMsg$224346[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$12:
	lea	ecx, DWORD PTR $T296234[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$13:
	lea	ecx, DWORD PTR _strMsg$224351[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$14:
	lea	ecx, DWORD PTR $T296235[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$15:
	lea	ecx, DWORD PTR _strMsg$224356[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$16:
	lea	ecx, DWORD PTR $T296236[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ENDP ; CvTacticalAI::ExecuteSafeBombards
PUBLIC	?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteFlankAttack
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z
_TEXT	SEGMENT
_iFillableHexes$224502 = -96				; size = 4
$T297650 = -92						; size = 4
_iNumAttackers$224503 = -92				; size = 4
_pLoopPlot$ = -92					; size = 4
_iPossibleFlankHexes$ = -92				; size = 4
tv1831 = -88						; size = 4
tv1850 = -84						; size = 4
_iI$224504 = -84					; size = 4
_jJ$224524 = -80					; size = 4
_pDefender$224549 = -76					; size = 8
_iI$224531 = -76					; size = 4
_iI$224517 = -76					; size = 4
_strMsg$224544 = -68					; size = 28
_strMsg$224539 = -68					; size = 28
_block$224528 = -68					; size = 16
_target$ = -68						; size = 28
$T297452 = -40						; size = 28
$T297451 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_kTarget$ = 8						; size = 4
?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z PROC ; CvTacticalAI::ExecuteFlankAttack, COMDAT
; _this$ = ecx

; 7965 : {

	push	-1
	push	__ehhandler$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	ebp
	push	esi

; 7966 : 	CvTacticalAnalysisCell* pCell;
; 7967 : 	CvPlot* pLoopPlot;
; 7968 : 	int iPlotIndex;
; 7969 : 	int iPossibleFlankHexes = 0;

	xor	esi, esi

; 7970 : 	CvTacticalTarget target;

	or	eax, -1
	mov	DWORD PTR _target$[esp+112], eax
	mov	DWORD PTR _target$[esp+116], eax
	mov	DWORD PTR _target$[esp+120], eax
	mov	DWORD PTR _target$[esp+132], eax

; 7971 : 
; 7972 : 	// Count number of possible flank attack spaces around target
; 7973 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	eax, DWORD PTR _kTarget$[esp+104]

; 7974 : 	{
; 7975 : 		pLoopPlot = plotDirection(kTarget.GetTargetX(), kTarget.GetTargetY(), ((DirectionTypes)iI));

	mov	ebx, DWORD PTR [eax+8]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	mov	ebp, ecx
	mov	DWORD PTR _iPossibleFlankHexes$[esp+112], esi
	mov	DWORD PTR _target$[esp+112], esi
	mov	DWORD PTR _target$[esp+128], esi
	mov	DWORD PTR _target$[esp+132], esi
	npad	3
$LL38@ExecuteFla:
	push	esi
	push	ebx
	push	edi
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 7976 : 		if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN37@ExecuteFla

; 7977 : 		{
; 7978 : 			iPlotIndex = GC.getMap().plotNum(pLoopPlot->getX(), pLoopPlot->getY());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edx, DWORD PTR [ecx+4020]
	movsx	ecx, WORD PTR [eax+2]
	imul	ecx, edx
	movsx	edx, WORD PTR [eax]

; 7979 : 			pCell = m_pMap->GetCell(iPlotIndex);

	mov	eax, DWORD PTR [ebp+4]
	add	ecx, edx
	imul	ecx, 44					; 0000002cH
	add	ecx, DWORD PTR [eax+12]

; 7980 : 			if(pCell->IsHelpsProvidesFlankBonus())

	mov	ecx, DWORD PTR [ecx]
	shr	ecx, 18					; 00000012H
	test	cl, 1
	je	SHORT $LN37@ExecuteFla

; 7981 : 			{
; 7982 : 				iPossibleFlankHexes++;

	inc	DWORD PTR _iPossibleFlankHexes$[esp+112]
$LN37@ExecuteFla:

; 7971 : 
; 7972 : 	// Count number of possible flank attack spaces around target
; 7973 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL38@ExecuteFla

; 7983 : 			}
; 7984 : 		}
; 7985 : 	}
; 7986 : 
; 7987 : 	// If more than 1, find how many we can fill with units
; 7988 : 	if(iPossibleFlankHexes > 1)

	cmp	DWORD PTR _iPossibleFlankHexes$[esp+112], 1
	jle	$LN411@ExecuteFla

; 7989 : 	{
; 7990 : 		int iFillableHexes = 0;

	xor	edx, edx
	mov	DWORD PTR _iFillableHexes$224502[esp+112], edx

; 7991 : 		int iNumAttackers = 0;

	mov	DWORD PTR _iNumAttackers$224503[esp+112], edx

; 7992 : 		m_TempTargets.clear();

	mov	DWORD PTR [ebp+23708], edx

; 7993 : 		for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$224504[esp+112], edx
	lea	edi, DWORD PTR [edx+1]
$LL434@ExecuteFla:

; 7994 : 		{
; 7995 : 			pLoopPlot = plotDirection(kTarget.GetTargetX(), kTarget.GetTargetY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _kTarget$[esp+108]
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+4]
	push	edx
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 7996 : 			if(pLoopPlot != NULL)

	test	esi, esi
	je	$LN31@ExecuteFla

; 7997 : 			{
; 7998 : 				iPlotIndex = GC.getMap().plotNum(pLoopPlot->getX(), pLoopPlot->getY());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [edx+4020]
	movsx	eax, WORD PTR [esi+2]

; 7999 : 				pCell = m_pMap->GetCell(iPlotIndex);

	mov	edx, DWORD PTR [ebp+4]
	imul	eax, ecx
	movsx	ecx, WORD PTR [esi]
	add	eax, ecx
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [edx+12]

; 8000 : 				if(pCell->IsHelpsProvidesFlankBonus())

	mov	eax, DWORD PTR [eax]
	shr	eax, 18					; 00000012H
	test	al, 1
	je	$LN31@ExecuteFla

; 8001 : 				{
; 8002 : 					if(FindClosestUnit(pLoopPlot, 0, true/*bMustHaveHalfHP*/, false /*bMustBeRangedUnit*/, 0 /*iRangeRequired*/, false /*bNeedsIgnoreLOS*/, true /*bMustBeMeleeUnit*/))

	push	0
	push	0
	push	edi
	push	0
	push	0
	push	0
	push	edi
	push	0
	push	esi
	mov	ecx, ebp
	call	?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z ; CvTacticalAI::FindClosestUnit
	test	al, al
	je	SHORT $LN27@ExecuteFla

; 8003 : 					{
; 8004 : 						iFillableHexes++;
; 8005 : 						iNumAttackers++;
; 8006 : 						target.SetTargetX(pLoopPlot->getX());

	movsx	ecx, WORD PTR [esi]

; 8007 : 						target.SetTargetY(pLoopPlot->getY());

	movsx	edx, WORD PTR [esi+2]

; 8008 : 						m_TempTargets.push_back(target);

	mov	eax, DWORD PTR [ebp+23712]
	add	DWORD PTR _iFillableHexes$224502[esp+112], edi
	add	DWORD PTR _iNumAttackers$224503[esp+112], edi
	lea	ebx, DWORD PTR [ebp+23704]
	mov	DWORD PTR _target$[esp+116], ecx
	mov	DWORD PTR _target$[esp+120], edx
	mov	BYTE PTR [ebx+1048], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN106@ExecuteFla
	push	eax
	mov	ecx, ebx
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::GrowSize
$LN106@ExecuteFla:
	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN438@ExecuteFla
$LN27@ExecuteFla:

; 8009 : 					}
; 8010 : 					// What about next turn?
; 8011 : 					else if(FindClosestUnit(pLoopPlot, 1, false/*bMustHaveHalfHP*/, false /*bMustBeRangedUnit*/, 0 /*iRangeRequired*/, false /*bNeedsIgnoreLOS*/, true /*bMustBeMeleeUnit*/))

	push	0
	push	0
	push	edi
	push	0
	push	0
	push	0
	push	0
	push	edi
	push	esi
	mov	ecx, ebp
	call	?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z ; CvTacticalAI::FindClosestUnit
	test	al, al
	je	SHORT $LN31@ExecuteFla

; 8012 : 					{
; 8013 : 						iFillableHexes++;
; 8014 : 						target.SetTargetX(pLoopPlot->getX());

	movsx	eax, WORD PTR [esi]

; 8015 : 						target.SetTargetY(pLoopPlot->getY());

	movsx	ecx, WORD PTR [esi+2]
	add	DWORD PTR _iFillableHexes$224502[esp+112], edi

; 8016 : 						m_TempTargets.push_back(target);

	lea	ebx, DWORD PTR [ebp+23704]
	mov	DWORD PTR _target$[esp+116], eax
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _target$[esp+120], ecx
	mov	BYTE PTR [ebx+1048], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN121@ExecuteFla
	push	eax
	mov	ecx, ebx
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::GrowSize
$LN121@ExecuteFla:
	mov	eax, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ebx]
	lea	eax, DWORD PTR [eax+edx*4]
$LN438@ExecuteFla:
	test	eax, eax
	je	SHORT $LN124@ExecuteFla
	mov	ecx, 7
	mov	edi, eax
	lea	esi, DWORD PTR _target$[esp+112]
	rep movsd
	mov	edi, 1
$LN124@ExecuteFla:
	add	DWORD PTR [ebx+4], edi
$LN31@ExecuteFla:

; 7993 : 		for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	edx, DWORD PTR _iI$224504[esp+112]
	add	edx, edi
	cmp	edx, 6
	mov	DWORD PTR _iI$224504[esp+112], edx
	jl	$LL434@ExecuteFla

; 8017 : 					}
; 8018 : 				}
; 8019 : 			}
; 8020 : 		}
; 8021 : 
; 8022 : 		// As long as we either get three hexes filled with one attacker, or two we can attack from, then this multi-hex attack is worth considering
; 8023 : 		if((iNumAttackers >= 1 && iFillableHexes >= 3) || iNumAttackers >= 2)

	mov	eax, DWORD PTR _iNumAttackers$224503[esp+112]
	cmp	eax, edi
	jl	SHORT $LN22@ExecuteFla
	cmp	DWORD PTR _iFillableHexes$224502[esp+112], 3
	jge	SHORT $LN23@ExecuteFla
$LN22@ExecuteFla:
	cmp	eax, 2
	jl	$LN411@ExecuteFla
$LN23@ExecuteFla:

; 8024 : 		{
; 8025 : 			// Compute best way to fill the hexes
; 8026 : 			m_PotentialBlocks.clear();

	xor	esi, esi
	lea	edi, DWORD PTR [ebp+26596]
	mov	DWORD PTR [edi+4], esi

; 8027 : #ifdef AUI_ITERATORIZE
; 8028 : 			for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it = m_TempTargets.begin(); it != m_TempTargets.end(); ++it)
; 8029 : 			{
; 8030 : 				pLoopPlot = GC.getMap().plot(it->GetTargetX(), it->GetTargetY());
; 8031 : #else
; 8032 : 			for(unsigned int iI = 0; iI < m_TempTargets.size(); iI++)

	mov	eax, DWORD PTR [ebp+23708]
	mov	DWORD PTR _iI$224517[esp+112], esi
	cmp	eax, esi
	jbe	$LN19@ExecuteFla

; 8024 : 		{
; 8025 : 			// Compute best way to fill the hexes
; 8026 : 			m_PotentialBlocks.clear();

	mov	DWORD PTR tv1850[esp+112], esi
	npad	9
$LL21@ExecuteFla:

; 8033 : 			{
; 8034 : 				pLoopPlot = GC.getMap().plot(m_TempTargets[iI].GetTargetX(), m_TempTargets[iI].GetTargetY());

	mov	ecx, DWORD PTR [ebp+23704]
	mov	edx, DWORD PTR tv1850[esp+112]
	lea	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T297650[esp+112], ecx
	cmp	eax, -2147483647			; 80000001H
	je	$LN148@ExecuteFla
	cmp	ecx, -2147483647			; 80000001H
	je	$LN148@ExecuteFla
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN429@ExecuteFla
	test	eax, eax
	jge	SHORT $LN160@ExecuteFla
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN162@ExecuteFla
$LN160@ExecuteFla:
	cmp	eax, ecx
	jl	SHORT $LN429@ExecuteFla
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN162@ExecuteFla
$LN429@ExecuteFla:
	mov	esi, eax
$LN162@ExecuteFla:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebx, DWORD PTR [edx+4024]
	mov	edx, DWORD PTR $T297650[esp+112]
	test	al, al
	je	SHORT $LN168@ExecuteFla
	test	edx, edx
	jge	SHORT $LN170@ExecuteFla
	mov	eax, edx
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN168@ExecuteFla
$LN170@ExecuteFla:
	cmp	edx, ebx
	jl	SHORT $LN168@ExecuteFla
	mov	eax, DWORD PTR $T297650[esp+112]
	cdq
	idiv	ebx
$LN168@ExecuteFla:
	test	esi, esi
	jl	SHORT $LN148@ExecuteFla
	cmp	esi, ecx
	jge	SHORT $LN148@ExecuteFla
	test	edx, edx
	jl	SHORT $LN148@ExecuteFla
	cmp	edx, ebx
	jge	SHORT $LN148@ExecuteFla
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	jmp	SHORT $LN439@ExecuteFla
$LN148@ExecuteFla:
	xor	ecx, ecx
$LN439@ExecuteFla:

; 8035 : #endif
; 8036 : 				if(!FindClosestUnit(pLoopPlot, 1, false/*bMustHaveHalfHP*/, false /*bMustBeRangedUnit*/, 0 /*iRangeRequired*/, false /*bNeedsIgnoreLOS*/, true /*bMustBeMeleeUnit*/))

	push	0
	push	0
	push	1
	push	0
	push	0
	push	0
	push	0
	push	1
	mov	DWORD PTR _pLoopPlot$[esp+144], ecx
	push	ecx
	mov	ecx, ebp
	call	?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z ; CvTacticalAI::FindClosestUnit
	test	al, al
	jne	SHORT $LN18@ExecuteFla

; 8037 : 				{
; 8038 : 					iFillableHexes--;

	mov	eax, DWORD PTR _iFillableHexes$224502[esp+112]
	dec	eax

; 8039 : 					if(iFillableHexes < 2)

	cmp	eax, 2
	mov	DWORD PTR _iFillableHexes$224502[esp+112], eax
	jl	$LN411@ExecuteFla

; 8040 : 					{
; 8041 : 						return false;
; 8042 : 					}
; 8043 : 				}
; 8044 : 				else

	jmp	$LN20@ExecuteFla
$LN18@ExecuteFla:

; 8045 : 				{
; 8046 : 					// Save off the units that could get here
; 8047 : #ifdef AUI_ITERATORIZE
; 8048 : 					for (std::vector<CvTacticalUnit>::const_iterator it2 = m_CurrentMoveUnits.begin(); it2 != m_CurrentMoveUnits.end(); ++it2)
; 8049 : 					{
; 8050 : 						CvBlockingUnit block;
; 8051 : 						block.SetUnitID(it2->GetID());
; 8052 : 						block.SetPlot(pLoopPlot);
; 8053 : 						block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 8054 : 						block.SetDistanceToTarget(it2->GetMovesToTarget());
; 8055 : #else
; 8056 : 					for(unsigned int jJ = 0; jJ < m_CurrentMoveUnits.size(); jJ++)

	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _jJ$224524[esp+112], 0
	je	$LN20@ExecuteFla
	mov	DWORD PTR tv1831[esp+112], 0
	npad	2
$LL15@ExecuteFla:

; 8057 : 					{
; 8058 : 						CvBlockingUnit block;
; 8059 : 						block.SetUnitID(m_CurrentMoveUnits[jJ].GetID());

	mov	edx, DWORD PTR [ebp+24]
	mov	eax, DWORD PTR tv1831[esp+112]
	mov	ecx, DWORD PTR [eax+edx]
	lea	ebx, DWORD PTR [eax+edx]

; 8060 : 						block.SetPlot(pLoopPlot);
; 8061 : 						block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 8062 : 						block.SetDistanceToTarget(m_CurrentMoveUnits[jJ].GetMovesToTarget());

	mov	ebx, DWORD PTR [ebx+12]
	mov	DWORD PTR _block$224528[esp+116], ecx
	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 8063 : #endif
; 8064 : 						m_PotentialBlocks.push_back(block);

	mov	eax, DWORD PTR [edi+8]
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	BYTE PTR [edi+412], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN208@ExecuteFla
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
$LN208@ExecuteFla:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN211@ExecuteFla
	mov	edx, DWORD PTR _pLoopPlot$[esp+112]
	mov	ecx, DWORD PTR _block$224528[esp+116]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], ebx
$LN211@ExecuteFla:
	inc	DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	esi, DWORD PTR _jJ$224524[esp+112]
	add	DWORD PTR tv1831[esp+112], 24		; 00000018H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	esi
	add	eax, edx
	mov	DWORD PTR _jJ$224524[esp+112], esi
	cmp	esi, eax
	jb	$LL15@ExecuteFla
$LN20@ExecuteFla:

; 8027 : #ifdef AUI_ITERATORIZE
; 8028 : 			for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it = m_TempTargets.begin(); it != m_TempTargets.end(); ++it)
; 8029 : 			{
; 8030 : 				pLoopPlot = GC.getMap().plot(it->GetTargetX(), it->GetTargetY());
; 8031 : #else
; 8032 : 			for(unsigned int iI = 0; iI < m_TempTargets.size(); iI++)

	mov	eax, DWORD PTR _iI$224517[esp+112]
	add	DWORD PTR tv1850[esp+112], 28		; 0000001cH
	inc	eax
	mov	DWORD PTR _iI$224517[esp+112], eax
	cmp	eax, DWORD PTR [ebp+23708]
	jb	$LL21@ExecuteFla

; 8039 : 					if(iFillableHexes < 2)

	xor	esi, esi
$LN19@ExecuteFla:

; 8065 : 					}
; 8066 : 				}
; 8067 : 			}
; 8068 : 
; 8069 : 			if(AssignFlankingUnits(iFillableHexes))

	mov	ecx, DWORD PTR _iFillableHexes$224502[esp+112]
	push	2
	push	ecx
	mov	DWORD PTR [ebp+27016], esi
	mov	ecx, ebp
	mov	DWORD PTR [ebp+27432], esi
	call	?ChooseRemainingAssignments@CvTacticalAI@@AAE_NHH@Z ; CvTacticalAI::ChooseRemainingAssignments
	test	al, al
	je	$LN411@ExecuteFla

; 8070 : 			{
; 8071 : 				// Make moves up into hexes
; 8072 : #ifdef AUI_ITERATORIZE
; 8073 : 				for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_ChosenBlocks.begin(); it != m_ChosenBlocks.end(); ++it)
; 8074 : 				{
; 8075 : 					CvUnit* pUnit = m_pPlayer->getUnit(it->GetUnitID());
; 8076 : 					if (pUnit)
; 8077 : 					{
; 8078 : 						if (pUnit->plot() != it->GetPlot())
; 8079 : #else
; 8080 : 				for(unsigned int iI = 0; iI < m_ChosenBlocks.size(); iI++)

	mov	DWORD PTR _iI$224531[esp+112], esi
	cmp	DWORD PTR [ebp+27432], esi
	jbe	$LN430@ExecuteFla
	xor	edi, edi
	npad	2
$LL11@ExecuteFla:

; 8081 : 				{
; 8082 : 					CvUnit* pUnit = m_pPlayer->getUnit(m_ChosenBlocks[iI].GetUnitID());

	mov	eax, DWORD PTR [ebp+27428]
	mov	ecx, DWORD PTR [ebp]
	add	eax, edi
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax

; 8083 : 					if(pUnit)

	test	esi, esi
	je	$LN10@ExecuteFla

; 8084 : 					{
; 8085 : 						if(pUnit->plot() == m_ChosenBlocks[iI].GetPlot())

	mov	eax, DWORD PTR [ebp+27428]
	mov	ebx, DWORD PTR [eax+edi]
	add	eax, edi
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	jne	$LN7@ExecuteFla

; 8086 : #endif
; 8087 : 						{
; 8088 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN10@ExecuteFla
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN10@ExecuteFla

; 8089 : 							{
; 8090 : 								CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224539[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 8091 : 								strMsg.Format("Already in a flanking position with %s, X: %d, Y: %d", pUnit->getName().GetCString(),
; 8092 : #ifdef AUI_ITERATORIZE
; 8093 : 											  it->GetPlot()->getX(), it->GetPlot()->getY());
; 8094 : #else
; 8095 : 								              m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY());

	lea	edx, DWORD PTR $T297451[esp+112]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+124], 0
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [ebp+27428]
	lea	edx, DWORD PTR [edi+ecx]
	mov	ecx, DWORD PTR [edx]
	movsx	ecx, WORD PTR [ecx+2]
	mov	edx, DWORD PTR [edx]
	movsx	edx, WORD PTR [edx]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+128], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strMsg$224539[esp+124]
	push	OFFSET $SG224541
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T297451[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 8096 : #endif
; 8097 : 								LogTacticalMessage(strMsg, false);

	push	0
	lea	eax, DWORD PTR _strMsg$224539[esp+116]
	push	eax
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 8098 : 							}

	lea	ecx, DWORD PTR _strMsg$224539[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 8099 : 						}
; 8100 : 						else

	jmp	$LN10@ExecuteFla
$LN7@ExecuteFla:

; 8101 : 						{
; 8102 : #ifdef AUI_ITERATORIZE
; 8103 : 							pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), it->GetPlot()->getX(), it->GetPlot()->getY());
; 8104 : #else
; 8105 : 							pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY());

	mov	ecx, DWORD PTR [ebp+27428]
	push	0
	push	0
	lea	eax, DWORD PTR [edi+ecx]
	mov	ecx, DWORD PTR [eax]
	movsx	ecx, WORD PTR [ecx+2]
	mov	eax, DWORD PTR [eax]
	movsx	eax, WORD PTR [eax]
	push	-1
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 8106 : #endif
; 8107 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN4@ExecuteFla
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN4@ExecuteFla

; 8108 : 							{
; 8109 : 								CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224544[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 8110 : 								strMsg.Format("Moving into a flanking position with %s, X: %d, Y: %d", pUnit->getName().GetCString(),
; 8111 : #ifdef AUI_ITERATORIZE
; 8112 : 											  it->GetPlot()->getX(), it->GetPlot()->getY());
; 8113 : #else
; 8114 : 								              m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY());

	lea	edx, DWORD PTR $T297452[esp+112]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+124], 2
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [ebp+27428]
	lea	edx, DWORD PTR [edi+ecx]
	mov	ecx, DWORD PTR [edx]
	movsx	ecx, WORD PTR [ecx+2]
	mov	edx, DWORD PTR [edx]
	movsx	edx, WORD PTR [edx]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+128], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strMsg$224544[esp+124]
	push	OFFSET $SG224546
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T297452[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 8115 : #endif
; 8116 : 								LogTacticalMessage(strMsg, false);

	push	0
	lea	eax, DWORD PTR _strMsg$224544[esp+116]
	push	eax
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 8117 : 							}

	lea	ecx, DWORD PTR _strMsg$224544[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@ExecuteFla:

; 8118 : 
; 8119 : 							if(pUnit->getMoves() <= 0)

	mov	ecx, esi
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jg	SHORT $LN10@ExecuteFla

; 8120 : 							{
; 8121 : 								UnitProcessed(pUnit->GetID());

	mov	esi, DWORD PTR [esi+100]
	push	1
	push	esi
	mov	ecx, ebp
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed
$LN10@ExecuteFla:
	mov	eax, DWORD PTR _iI$224531[esp+112]
	inc	eax
	add	edi, 16					; 00000010H
	mov	DWORD PTR _iI$224531[esp+112], eax
	cmp	eax, DWORD PTR [ebp+27432]
	jb	$LL11@ExecuteFla

; 8070 : 			{
; 8071 : 				// Make moves up into hexes
; 8072 : #ifdef AUI_ITERATORIZE
; 8073 : 				for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_ChosenBlocks.begin(); it != m_ChosenBlocks.end(); ++it)
; 8074 : 				{
; 8075 : 					CvUnit* pUnit = m_pPlayer->getUnit(it->GetUnitID());
; 8076 : 					if (pUnit)
; 8077 : 					{
; 8078 : 						if (pUnit->plot() != it->GetPlot())
; 8079 : #else
; 8080 : 				for(unsigned int iI = 0; iI < m_ChosenBlocks.size(); iI++)

	xor	esi, esi
$LN430@ExecuteFla:

; 8122 : 							}
; 8123 : 						}
; 8124 : 					}
; 8125 : 				}
; 8126 : 
; 8127 : 				// Make attacks
; 8128 : 				CvPlot* pTargetPlot = GC.getMap().plot(kTarget.GetTargetX(), kTarget.GetTargetY());

	mov	eax, DWORD PTR _kTarget$[esp+108]
	mov	ebx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN311@ExecuteFla
	cmp	ebx, -2147483647			; 80000001H
	je	$LN311@ExecuteFla
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN321@ExecuteFla
	cmp	eax, esi
	jge	SHORT $LN323@ExecuteFla
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN325@ExecuteFla
$LN323@ExecuteFla:
	cmp	eax, ecx
	jl	SHORT $LN321@ExecuteFla
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN325@ExecuteFla
$LN321@ExecuteFla:
	mov	esi, eax
$LN325@ExecuteFla:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	edi, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN331@ExecuteFla
	test	ebx, ebx
	jge	SHORT $LN333@ExecuteFla
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN335@ExecuteFla
$LN333@ExecuteFla:
	cmp	ebx, edi
	jl	SHORT $LN331@ExecuteFla
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN335@ExecuteFla
$LN331@ExecuteFla:
	mov	edx, ebx
$LN335@ExecuteFla:
	test	esi, esi
	jl	SHORT $LN311@ExecuteFla
	cmp	esi, ecx
	jge	SHORT $LN311@ExecuteFla
	test	edx, edx
	jl	SHORT $LN311@ExecuteFla
	cmp	edx, edi
	jge	SHORT $LN311@ExecuteFla
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	esi, ecx
	jmp	SHORT $LN313@ExecuteFla
$LN311@ExecuteFla:
	xor	esi, esi
$LN313@ExecuteFla:

; 8129 : 				UnitHandle pDefender = pTargetPlot->getVisibleEnemyDefender(m_pPlayer->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, esi
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	mov	edi, eax
	mov	DWORD PTR _pDefender$224549[esp+112], edi
	mov	BYTE PTR _pDefender$224549[esp+116], 0
	test	edi, edi
	je	SHORT $LN356@ExecuteFla
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN356@ExecuteFla:
	mov	DWORD PTR __$EHRec$[esp+120], 4

; 8130 : 				if(pDefender)

	test	edi, edi
	je	SHORT $LN432@ExecuteFla

; 8131 : 				{
; 8132 : 					kTarget.SetAuxIntData(pDefender->GetCurrHitPoints());

	mov	ecx, edi
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	mov	ebx, DWORD PTR _kTarget$[esp+108]
	mov	DWORD PTR [ebx+20], eax

; 8133 : 					m_CurrentMoveCities.clear();

	mov	edx, DWORD PTR [ebp+60]
	mov	ecx, DWORD PTR [ebp+56]
	cmp	ecx, edx
	je	SHORT $LN378@ExecuteFla
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN403@ExecuteFla
$LL405@ExecuteFla:
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebx
	mov	ebx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], ebx
	add	eax, 12					; 0000000cH
	add	ecx, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL405@ExecuteFla
$LN403@ExecuteFla:
	mov	ebx, DWORD PTR _kTarget$[esp+108]
	mov	DWORD PTR [ebp+60], ecx
$LN378@ExecuteFla:

; 8134 : 					if(FindUnitsWithinStrikingDistance(pTargetPlot, 1, 0, false /* bNoRangedUnits */))

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	1
	push	esi
	mov	ecx, ebp
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
	test	al, al
	je	SHORT $LN432@ExecuteFla

; 8135 : 					{
; 8136 : 						ComputeTotalExpectedDamage(&kTarget, pTargetPlot);

	push	esi
	push	ebx
	mov	ecx, ebp
	call	?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z ; CvTacticalAI::ComputeTotalExpectedDamage

; 8137 : 						ExecuteAttack(&kTarget, pTargetPlot, false/*bInflictWhatWeTake*/, true/*bMustSurviveAttack*/);

	push	1
	push	0
	push	esi
	push	ebx
	mov	ecx, ebp
	call	?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z ; CvTacticalAI::ExecuteAttack
$LN432@ExecuteFla:

; 8138 : 					}
; 8139 : 				}
; 8140 : 			}

	mov	DWORD PTR __$EHRec$[esp+120], -1
	test	edi, edi
	je	SHORT $LN411@ExecuteFla
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN411@ExecuteFla:

; 8141 : 		}
; 8142 : 	}
; 8143 : 
; 8144 : 	return false;
; 8145 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 96					; 00000060H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$224539[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$1:
	lea	ecx, DWORD PTR $T297451[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$2:
	lea	ecx, DWORD PTR _strMsg$224544[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$3:
	lea	ecx, DWORD PTR $T297452[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$4:
	lea	ecx, DWORD PTR _pDefender$224549[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ENDP ; CvTacticalAI::ExecuteFlankAttack
PUBLIC	?PerformChosenMoves@CvTacticalAI@@AAEXH@Z	; CvTacticalAI::PerformChosenMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fautovariable.h
xdata$x	SEGMENT
__ehfuncinfo$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$10
	DD	06H
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$12
	DD	08H
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$14
	DD	0aH
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$16
	DD	0cH
	DD	FLAT:__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$17
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PerformChosenMoves@CvTacticalAI@@AAEXH@Z
_TEXT	SEGMENT
_bMoveWasSafe$225708 = -137				; size = 1
_bMoveWasSafe$225692 = -137				; size = 1
_iI$225747 = -136					; size = 4
_iI$225733 = -136					; size = 4
_iI$225716 = -136					; size = 4
_iI$225698 = -136					; size = 4
_iI$225685 = -136					; size = 4
$T298905 = -132						; size = 4
$T298563 = -132						; size = 4
_pPlotBeforeMove$225723 = -132				; size = 4
_pPlotBeforeMove$225707 = -132				; size = 4
$T298410 = -132						; size = 4
$T298416 = -128						; size = 4
$T298414 = -128						; size = 4
$T298412 = -128						; size = 4
_strMsg$225762 = -124					; size = 28
_strMsg$225756 = -124					; size = 28
_strMsg$225744 = -124					; size = 28
_strMsg$225728 = -124					; size = 28
_strMsg$225711 = -124					; size = 28
_strMsg$225695 = -124					; size = 28
_strMsg$225767 = -96					; size = 28
$T298419 = -68						; size = 28
$T298418 = -68						; size = 28
$T298417 = -68						; size = 28
$T298415 = -68						; size = 28
$T298413 = -68						; size = 28
$T298411 = -68						; size = 28
$T298420 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_iFallbackMoveRange$ = 8				; size = 4
?PerformChosenMoves@CvTacticalAI@@AAEXH@Z PROC		; CvTacticalAI::PerformChosenMoves, COMDAT
; _this$ = ecx

; 10371: {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 10372: 	// Make moves up into hexes, starting with units already close to their final destination
; 10373: 	std::stable_sort(m_ChosenBlocks.begin(), m_ChosenBlocks.end(), TacticalAIHelpers::CvBlockingUnitDistanceSort);

	mov	eax, DWORD PTR [esi+27432]
	mov	ecx, DWORD PTR [esi+27428]
	shl	eax, 4
	add	eax, ecx
	push	edi
	cmp	ecx, eax
	je	SHORT $LN69@PerformCho
	push	OFFSET ?CvBlockingUnitDistanceSort@TacticalAIHelpers@@YA_NVCvBlockingUnit@@0@Z ; TacticalAIHelpers::CvBlockingUnitDistanceSort
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvBlockingUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvBlockingUnit@@0PAH0P6A_NV1@2@Z@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit,bool (__cdecl*)(CvBlockingUnit,CvBlockingUnit)>
	add	esp, 20					; 00000014H
$LN69@PerformCho:

; 10374: 
; 10375: 	// First loop through is for units that have a unit moving into their hex.  They need to leave first!
; 10376: #ifdef AUI_ITERATORIZE
; 10377: 	for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_ChosenBlocks.begin(); it != m_ChosenBlocks.end(); ++it)
; 10378: 	{
; 10379: 		CvUnit* pUnit = m_pPlayer->getUnit(it->GetUnitID());
; 10380: 		if (pUnit)
; 10381: 		{
; 10382: 			if (pUnit->plot() != it->GetPlot() && IsInChosenMoves(pUnit->plot()) && it->GetPlot()->getNumFriendlyUnitsOfType(pUnit) == 0)
; 10383: 			{
; 10384: 				bool bMoveWasSafe;
; 10385: 				MoveToUsingSafeEmbark(pUnit, it->GetPlot(), bMoveWasSafe);
; 10386: #else
; 10387: 	for(unsigned int iI = 0; iI < m_ChosenBlocks.size(); iI++)

	mov	eax, DWORD PTR [esi+27432]
	xor	ebp, ebp
	mov	DWORD PTR _iI$225685[esp+156], ebp
	cmp	eax, ebp
	jbe	$LN42@PerformCho
$LN44@PerformCho:

; 10388: 	{
; 10389: 		CvUnit* pUnit = m_pPlayer->getUnit(m_ChosenBlocks[iI].GetUnitID());

	mov	eax, DWORD PTR [esi+27428]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebp
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 10390: 		if(pUnit)

	test	edi, edi
	je	$LN43@PerformCho

; 10391: 		{
; 10392: 			if(pUnit->plot() != m_ChosenBlocks[iI].GetPlot() && IsInChosenMoves(pUnit->plot()) && m_ChosenBlocks[iI].GetPlot()->getNumFriendlyUnitsOfType(pUnit) == 0)

	mov	eax, DWORD PTR [esi+27428]
	mov	ebx, DWORD PTR [eax+ebp]
	add	eax, ebp
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	je	$LN43@PerformCho
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+27432]
	xor	ecx, ecx
	test	eax, eax
	jbe	$LN43@PerformCho
	mov	edx, DWORD PTR [esi+27428]
$LL89@PerformCho:
	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN420@PerformCho
	inc	ecx
	add	edx, 16					; 00000010H
	cmp	ecx, eax
	jb	SHORT $LL89@PerformCho
	jmp	$LN43@PerformCho
$LN420@PerformCho:
	mov	eax, DWORD PTR [esi+27428]
	mov	eax, DWORD PTR [eax+ebp]
	push	1
	push	edi
	mov	ecx, eax
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	test	eax, eax
	jne	$LN43@PerformCho

; 10393: 			{
; 10394: 				bool bMoveWasSafe;
; 10395: 				MoveToUsingSafeEmbark(pUnit, m_ChosenBlocks[iI].GetPlot(), bMoveWasSafe);

	mov	ecx, DWORD PTR [esi+27428]
	lea	eax, DWORD PTR _bMoveWasSafe$225692[esp+156]
	push	eax
	mov	eax, DWORD PTR [ecx+ebp]
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T298410[esp+172], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, esi
	call	?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z ; CvTacticalAI::MoveToUsingSafeEmbark

; 10396: #endif
; 10397: 
; 10398: 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN39@PerformCho
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN39@PerformCho

; 10399: 				{
; 10400: 					CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$225695[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10401: 					strMsg.Format("Deploying %s (to get out of way), To X: %d, To Y: %d, At X: %d, At Y: %d, Distance Before Move: %d",
; 10402: #ifdef AUI_ITERATORIZE
; 10403: 						pUnit->getName().GetCString(), it->GetPlot()->getX(), it->GetPlot()->getY(),
; 10404: 						pUnit->getX(), pUnit->getY(), it->GetDistanceToTarget());
; 10405: #else
; 10406: 					              pUnit->getName().GetCString(), m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY(),
; 10407: 					              pUnit->getX(), pUnit->getY(), m_ChosenBlocks[iI].GetDistanceToTarget());

	lea	edx, DWORD PTR $T298411[esp+156]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+168], 0
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+27428]
	mov	ebx, DWORD PTR [edi+88]
	mov	edi, DWORD PTR [edi+76]
	lea	edx, DWORD PTR [ecx+ebp]
	mov	ecx, DWORD PTR [edx+12]
	push	ecx
	mov	DWORD PTR $T298563[esp+160], edi
	mov	edi, DWORD PTR [edx]
	movsx	edi, WORD PTR [edi+2]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T298563[esp+160]
	movsx	edx, WORD PTR [edx]
	push	ebx
	push	ecx
	push	edi
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+184], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strMsg$225695[esp+180]
	push	OFFSET $SG225697
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR $T298411[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10408: #endif
; 10409: 					LogTacticalMessage(strMsg);

	push	1
	lea	eax, DWORD PTR _strMsg$225695[esp+160]
	push	eax
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 10410: 				}

	lea	ecx, DWORD PTR _strMsg$225695[esp+156]
	mov	DWORD PTR __$EHRec$[esp+164], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN39@PerformCho:
	mov	eax, DWORD PTR [esi+27428]
	add	eax, ebp

; 10411: 
; 10412: 				// Use number of choices field to indicate already moved
; 10413: #ifdef AUI_ITERATORIZE
; 10414: 				it->SetNumChoices(-1);
; 10415: #else
; 10416: 				m_ChosenBlocks[iI].SetNumChoices(-1);

	mov	DWORD PTR [eax+8], -1
$LN43@PerformCho:
	mov	eax, DWORD PTR _iI$225685[esp+156]
	inc	eax
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _iI$225685[esp+156], eax
	cmp	eax, DWORD PTR [esi+27432]
	jb	$LN44@PerformCho
$LN42@PerformCho:

; 10417: #endif
; 10418: 			}
; 10419: 		}
; 10420: 	}
; 10421: 
; 10422: 	// Second loop is for units moving into their chosen spot normally
; 10423: #ifdef AUI_ITERATORIZE
; 10424: 	for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_ChosenBlocks.begin(); it != m_ChosenBlocks.end(); ++it)
; 10425: 	{
; 10426: 		CvUnit* pUnit = m_pPlayer->getUnit(it->GetUnitID());
; 10427: 		if (pUnit)
; 10428: 		{
; 10429: 			if (pUnit->plot() == it->GetPlot())
; 10430: 			{
; 10431: 				it->SetNumChoices(-1);
; 10432: 			}
; 10433: 			else
; 10434: 			{
; 10435: 				// Someone we didn't move above?
; 10436: 				if (it->GetNumChoices() != -1)
; 10437: #else
; 10438: 	for(unsigned int iI = 0; iI < m_ChosenBlocks.size(); iI++)

	mov	eax, DWORD PTR [esi+27432]
	xor	ebp, ebp
	mov	DWORD PTR _iI$225698[esp+156], ebp
	cmp	eax, ebp
	jbe	$LN36@PerformCho
$LN38@PerformCho:

; 10439: 	{
; 10440: 		CvUnit* pUnit = m_pPlayer->getUnit(m_ChosenBlocks[iI].GetUnitID());

	mov	eax, DWORD PTR [esi+27428]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebp
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 10441: 		if(pUnit)

	test	edi, edi
	je	$LN37@PerformCho

; 10442: 		{
; 10443: 			if(pUnit->plot() == m_ChosenBlocks[iI].GetPlot())

	mov	eax, DWORD PTR [esi+27428]
	mov	ebx, DWORD PTR [eax+ebp]
	add	eax, ebp
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx

; 10444: 			{
; 10445: 				m_ChosenBlocks[iI].SetNumChoices(-1);
; 10446: 			}
; 10447: 			else

	je	$LN438@PerformCho

; 10448: 			{
; 10449: 				// Someone we didn't move above?
; 10450: 				if(m_ChosenBlocks[iI].GetNumChoices() != -1)

	mov	ecx, DWORD PTR [esi+27428]
	cmp	DWORD PTR [ecx+ebp+8], -1
	je	$LN37@PerformCho

; 10451: #endif
; 10452: 				{
; 10453: 					CvPlot* pPlotBeforeMove = pUnit->plot();

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pPlotBeforeMove$225707[esp+156], eax

; 10454: 					bool bMoveWasSafe;
; 10455: #ifdef AUI_ITERATORIZE
; 10456: 					MoveToUsingSafeEmbark(pUnit, it->GetPlot(), bMoveWasSafe);
; 10457: #else
; 10458: 					MoveToUsingSafeEmbark(pUnit, m_ChosenBlocks[iI].GetPlot(), bMoveWasSafe);

	mov	eax, DWORD PTR [esi+27428]
	mov	eax, DWORD PTR [eax+ebp]
	lea	edx, DWORD PTR _bMoveWasSafe$225708[esp+156]
	push	edx
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T298412[esp+172], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, esi
	call	?MoveToUsingSafeEmbark@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@AA_N@Z ; CvTacticalAI::MoveToUsingSafeEmbark

; 10459: #endif
; 10460: 
; 10461: 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN31@PerformCho
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN31@PerformCho

; 10462: 					{
; 10463: 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$225711[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10464: 						strMsg.Format("Deploying %s, To X: %d, To Y: %d, At X: %d, At Y: %d, Distance Before Move: %d",
; 10465: #ifdef AUI_ITERATORIZE
; 10466: 							pUnit->getName().GetCString(), it->GetPlot()->getX(), it->GetPlot()->getY(),
; 10467: 							pUnit->getX(), pUnit->getY(), it->GetDistanceToTarget());
; 10468: #else
; 10469: 						              pUnit->getName().GetCString(), m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY(),
; 10470: 						              pUnit->getX(), pUnit->getY(), m_ChosenBlocks[iI].GetDistanceToTarget());

	lea	ecx, DWORD PTR $T298413[esp+156]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+168], 2
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	edx, DWORD PTR [esi+27428]
	mov	ecx, DWORD PTR [edx+ebp+12]
	mov	ebx, DWORD PTR [edx+ebp]
	movsx	ebx, WORD PTR [ebx+2]
	add	edx, ebp
	mov	edx, DWORD PTR [edx]
	movsx	edx, WORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR [edi+88]
	push	ecx
	mov	ecx, DWORD PTR [edi+76]
	push	ecx
	push	ebx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+184], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strMsg$225711[esp+180]
	push	OFFSET $SG225713
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR $T298413[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10471: #endif
; 10472: 						LogTacticalMessage(strMsg);

	push	1
	lea	ecx, DWORD PTR _strMsg$225711[esp+160]
	push	ecx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 10473: 					}

	lea	ecx, DWORD PTR _strMsg$225711[esp+156]
	mov	DWORD PTR __$EHRec$[esp+164], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN31@PerformCho:

; 10474: 
; 10475: 					// Use number of choices field to indicate already moved
; 10476: 					if(pPlotBeforeMove != pUnit->plot())

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	DWORD PTR _pPlotBeforeMove$225707[esp+156], eax
	je	SHORT $LN37@PerformCho
$LN438@PerformCho:

; 10417: #endif
; 10418: 			}
; 10419: 		}
; 10420: 	}
; 10421: 
; 10422: 	// Second loop is for units moving into their chosen spot normally
; 10423: #ifdef AUI_ITERATORIZE
; 10424: 	for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_ChosenBlocks.begin(); it != m_ChosenBlocks.end(); ++it)
; 10425: 	{
; 10426: 		CvUnit* pUnit = m_pPlayer->getUnit(it->GetUnitID());
; 10427: 		if (pUnit)
; 10428: 		{
; 10429: 			if (pUnit->plot() == it->GetPlot())
; 10430: 			{
; 10431: 				it->SetNumChoices(-1);
; 10432: 			}
; 10433: 			else
; 10434: 			{
; 10435: 				// Someone we didn't move above?
; 10436: 				if (it->GetNumChoices() != -1)
; 10437: #else
; 10438: 	for(unsigned int iI = 0; iI < m_ChosenBlocks.size(); iI++)

	mov	eax, DWORD PTR [esi+27428]
	add	eax, ebp

; 10477: 					{
; 10478: #ifdef AUI_ITERATORIZE
; 10479: 						it->SetNumChoices(-1);
; 10480: #else
; 10481: 						m_ChosenBlocks[iI].SetNumChoices(-1);

	mov	DWORD PTR [eax+8], -1
$LN37@PerformCho:
	mov	eax, DWORD PTR _iI$225698[esp+156]
	inc	eax
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _iI$225698[esp+156], eax
	cmp	eax, DWORD PTR [esi+27432]
	jb	$LN38@PerformCho
$LN36@PerformCho:

; 10482: #endif
; 10483: 					}
; 10484: 				}
; 10485: 			}
; 10486: 		}
; 10487: 	}
; 10488: 
; 10489: 	// Third loop is for units we still haven't been able to move (other units must be blocking their target for this turn)
; 10490: 	if (iFallbackMoveRange > 0)

	xor	ebp, ebp
	cmp	DWORD PTR _iFallbackMoveRange$[esp+152], ebp
	jle	$LN26@PerformCho

; 10491: 	{
; 10492: #ifdef AUI_ITERATORIZE
; 10493: 		for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_ChosenBlocks.begin(); it != m_ChosenBlocks.end(); ++it)
; 10494: 		{
; 10495: 			CvUnit* pUnit = m_pPlayer->getUnit(it->GetUnitID());
; 10496: 			if (pUnit)
; 10497: 			{
; 10498: 				// Someone we didn't move above?
; 10499: 				if (it->GetNumChoices() != -1)
; 10500: 				{
; 10501: 					CvPlot* pPlotBeforeMove = pUnit->plot();
; 10502: 					if (MoveToEmptySpaceNearTarget(UnitHandle(pUnit), it->GetPlot(), (pUnit->getDomainType() == DOMAIN_LAND)))
; 10503: #else
; 10504: 		for(unsigned int iI = 0; iI < m_ChosenBlocks.size(); iI++)

	mov	DWORD PTR _iI$225716[esp+156], ebp
	cmp	DWORD PTR [esi+27432], ebp
	jbe	$LN26@PerformCho
	lea	ebx, DWORD PTR [ebp+4]
$LL28@PerformCho:

; 10505: 		{
; 10506: 			CvUnit* pUnit = m_pPlayer->getUnit(m_ChosenBlocks[iI].GetUnitID());

	mov	eax, DWORD PTR [esi+27428]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebp
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 10507: 			if(pUnit)

	test	edi, edi
	je	$LN27@PerformCho

; 10508: 			{
; 10509: 				// Someone we didn't move above?
; 10510: 				if(m_ChosenBlocks[iI].GetNumChoices() != -1)

	mov	edx, DWORD PTR [esi+27428]
	cmp	DWORD PTR [edx+ebp+8], -1
	je	$LN27@PerformCho

; 10511: 				{
; 10512: 					CvPlot* pPlotBeforeMove = pUnit->plot();

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 10513: 					if(MoveToEmptySpaceNearTarget(UnitHandle(pUnit), m_ChosenBlocks[iI].GetPlot(), (pUnit->getDomainType()==DOMAIN_LAND)))

	mov	ecx, edi
	mov	DWORD PTR _pPlotBeforeMove$225723[esp+156], eax
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	edx, DWORD PTR [esi+27428]
	cmp	eax, 2
	sete	al
	movzx	ecx, al
	mov	eax, DWORD PTR [edx+ebp]
	push	ecx
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T298414[esp+172], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, esi
	call	?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::MoveToEmptySpaceNearTarget
	test	al, al
	je	$LN27@PerformCho

; 10514: #endif
; 10515: 					{
; 10516: 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN22@PerformCho
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN22@PerformCho

; 10517: 						{
; 10518: 							CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$225728[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10519: 							strMsg.Format("Deploying %s to space near target, Target X: %d, Target Y: %d, At X: %d, At Y: %d, Distance Before Move: %d",
; 10520: #ifdef AUI_ITERATORIZE
; 10521: 								pUnit->getName().GetCString(), it->GetPlot()->getX(), it->GetPlot()->getY(),
; 10522: 								pUnit->getX(), pUnit->getY(), it->GetDistanceToTarget());
; 10523: #else
; 10524: 								pUnit->getName().GetCString(), m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY(),
; 10525: 								pUnit->getX(), pUnit->getY(), m_ChosenBlocks[iI].GetDistanceToTarget());

	lea	eax, DWORD PTR $T298415[esp+156]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+168], ebx
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+27428]
	mov	ebx, DWORD PTR [ecx+ebp]
	movsx	ebx, WORD PTR [ebx+2]
	lea	edx, DWORD PTR [ecx+ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR [edx]
	movsx	edx, WORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR [edi+88]
	push	ecx
	mov	ecx, DWORD PTR [edi+76]
	push	ecx
	push	ebx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+184], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strMsg$225728[esp+180]
	push	OFFSET $SG225730
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	mov	ebx, 4
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR $T298415[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10526: #endif
; 10527: 							LogTacticalMessage(strMsg);

	push	1
	lea	eax, DWORD PTR _strMsg$225728[esp+160]
	push	eax
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 10528: 						}

	lea	ecx, DWORD PTR _strMsg$225728[esp+156]
	mov	DWORD PTR __$EHRec$[esp+164], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN22@PerformCho:

; 10529: 
; 10530: 						if(pPlotBeforeMove != pUnit->plot())

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	DWORD PTR _pPlotBeforeMove$225723[esp+156], eax
	je	SHORT $LN27@PerformCho
	mov	eax, DWORD PTR [esi+27428]
	add	eax, ebp

; 10531: 						{
; 10532: #ifdef AUI_ITERATORIZE
; 10533: 							it->SetNumChoices(-1);
; 10534: #else
; 10535: 							m_ChosenBlocks[iI].SetNumChoices(-1);

	mov	DWORD PTR [eax+8], -1
$LN27@PerformCho:
	mov	eax, DWORD PTR _iI$225716[esp+156]
	inc	eax
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _iI$225716[esp+156], eax
	cmp	eax, DWORD PTR [esi+27432]
	jb	$LL28@PerformCho
$LN26@PerformCho:

; 10536: #endif
; 10537: 						}
; 10538: 					}
; 10539: 				}
; 10540: 			}
; 10541: 		}
; 10542: 	}
; 10543: 
; 10544: 	// Fourth loop let's unit end within 2 of target
; 10545: 	if (iFallbackMoveRange > 1)

	cmp	DWORD PTR _iFallbackMoveRange$[esp+152], 1
	jle	$LN17@PerformCho

; 10546: 	{
; 10547: #ifdef AUI_ITERATORIZE
; 10548: 		for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_ChosenBlocks.begin(); it != m_ChosenBlocks.end(); ++it)
; 10549: 		{
; 10550: 			CvUnit* pUnit = m_pPlayer->getUnit(it->GetUnitID());
; 10551: 			if (pUnit)
; 10552: 			{
; 10553: 				// Someone we didn't move above?
; 10554: 				if (it->GetNumChoices() != -1)
; 10555: 				{
; 10556: 					if (MoveToEmptySpaceNearTarget(UnitHandle(pUnit), it->GetPlot(), (pUnit->getDomainType() == DOMAIN_LAND)))
; 10557: #else
; 10558: 		for(unsigned int iI = 0; iI < m_ChosenBlocks.size(); iI++)

	xor	ebp, ebp
	mov	DWORD PTR _iI$225733[esp+156], ebp
	cmp	DWORD PTR [esi+27432], ebp
	jbe	$LN17@PerformCho
	lea	ebx, DWORD PTR [ebp+6]
$LL19@PerformCho:

; 10559: 		{
; 10560: 			CvUnit* pUnit = m_pPlayer->getUnit(m_ChosenBlocks[iI].GetUnitID());

	mov	eax, DWORD PTR [esi+27428]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebp
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 10561: 			if(pUnit)

	test	edi, edi
	je	$LN18@PerformCho

; 10562: 			{
; 10563: 				// Someone we didn't move above?
; 10564: 				if(m_ChosenBlocks[iI].GetNumChoices() != -1)

	mov	ecx, DWORD PTR [esi+27428]
	cmp	DWORD PTR [ecx+ebp+8], -1
	je	$LN18@PerformCho

; 10565: 				{
; 10566: 					if (MoveToEmptySpaceTwoFromTarget(UnitHandle(pUnit), m_ChosenBlocks[iI].GetPlot(), (pUnit->getDomainType()==DOMAIN_LAND)))

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	ecx, DWORD PTR [esi+27428]
	cmp	eax, 2
	sete	dl
	movzx	eax, dl
	push	eax
	mov	eax, DWORD PTR [ecx+ebp]
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T298416[esp+172], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, esi
	call	?MoveToEmptySpaceTwoFromTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::MoveToEmptySpaceTwoFromTarget
	test	al, al
	je	$LN18@PerformCho

; 10567: #endif
; 10568: 					{
; 10569: 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN18@PerformCho
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN18@PerformCho

; 10570: 						{
; 10571: 							CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$225744[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10572: 							strMsg.Format("Deploying %s to space within 2 of target, Target X: %d, Target Y: %d, At X: %d, At Y: %d, Distance Before Move: %d",
; 10573: #ifdef AUI_ITERATORIZE
; 10574: 								pUnit->getName().GetCString(), it->GetPlot()->getX(), it->GetPlot()->getY(),
; 10575: 								pUnit->getX(), pUnit->getY(), it->GetDistanceToTarget());
; 10576: #else
; 10577: 								pUnit->getName().GetCString(), m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY(),
; 10578: 								pUnit->getX(), pUnit->getY(), m_ChosenBlocks[iI].GetDistanceToTarget());

	lea	edx, DWORD PTR $T298417[esp+156]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+168], ebx
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+27428]
	mov	ebx, DWORD PTR [edi+88]
	mov	edi, DWORD PTR [edi+76]
	lea	edx, DWORD PTR [ecx+ebp]
	mov	ecx, DWORD PTR [edx+12]
	push	ecx
	mov	DWORD PTR $T298905[esp+160], edi
	mov	edi, DWORD PTR [edx]
	movsx	edi, WORD PTR [edi+2]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T298905[esp+160]
	movsx	edx, WORD PTR [edx]
	push	ebx
	push	ecx
	push	edi
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+184], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strMsg$225744[esp+180]
	push	OFFSET $SG225746
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	mov	ebx, 6
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR $T298417[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10579: #endif
; 10580: 							LogTacticalMessage(strMsg);

	push	1
	lea	eax, DWORD PTR _strMsg$225744[esp+160]
	push	eax
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 10581: 						}

	lea	ecx, DWORD PTR _strMsg$225744[esp+156]
	mov	DWORD PTR __$EHRec$[esp+164], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN18@PerformCho:
	mov	eax, DWORD PTR _iI$225733[esp+156]
	inc	eax
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _iI$225733[esp+156], eax
	cmp	eax, DWORD PTR [esi+27432]
	jb	$LL19@PerformCho
$LN17@PerformCho:

; 10582: 					}
; 10583: 				}
; 10584: 			}
; 10585: 		}
; 10586: 	}
; 10587: 
; 10588: 	// Finish moves for all units
; 10589: #ifdef AUI_ITERATORIZE
; 10590: 	for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_ChosenBlocks.begin(); it != m_ChosenBlocks.end(); ++it)
; 10591: 	{
; 10592: 		CvUnit* pUnit = m_pPlayer->getUnit(it->GetUnitID());
; 10593: #else
; 10594: 	for(unsigned int iI = 0; iI < m_ChosenBlocks.size(); iI++)

	xor	ebp, ebp
	mov	DWORD PTR _iI$225747[esp+156], ebp
	cmp	DWORD PTR [esi+27432], ebp
	jbe	$LN10@PerformCho
	lea	ebx, DWORD PTR [ebp+12]
$LL12@PerformCho:

; 10595: 	{
; 10596: 		CvUnit* pUnit = m_pPlayer->getUnit(m_ChosenBlocks[iI].GetUnitID());

	mov	eax, DWORD PTR [esi+27428]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebp
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 10597: #endif
; 10598: 		if(!pUnit->isDelayedDeath())

	mov	ecx, edi
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	$LN11@PerformCho

; 10599: 		{
; 10600: 			if (pUnit->getMoves() > 0)

	mov	ecx, edi
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jle	$LN8@PerformCho

; 10601: 			{
; 10602: 				if (pUnit->canPillage(pUnit->plot()) && pUnit->getDamage() > 0)

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canPillage@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canPillage
	test	al, al
	je	$LN7@PerformCho
	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	test	eax, eax
	jle	$LN7@PerformCho

; 10603: 				{
; 10604: 					pUnit->PushMission(CvTypes::getMISSION_PILLAGE());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_PILLAGE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PILLAGE
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 10605: 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@PerformCho
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@PerformCho

; 10606: 					{
; 10607: 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$225756[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10608: 						strMsg.Format("Already in position, will pillage with %s, X: %d, Y: %d", pUnit->getName().GetCString(),
; 10609: #ifdef AUI_ITERATORIZE
; 10610: 							it->GetPlot()->getX(), it->GetPlot()->getY());
; 10611: #else
; 10612: 							m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY());

	lea	ecx, DWORD PTR $T298418[esp+156]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+168], 8
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	edx, DWORD PTR [esi+27428]
	mov	ecx, DWORD PTR [edx+ebp]
	movsx	ecx, WORD PTR [ecx+2]
	add	edx, ebp
	mov	edx, DWORD PTR [edx]
	movsx	edx, WORD PTR [edx]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+172], 9
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strMsg$225756[esp+168]
	push	OFFSET $SG225758
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T298418[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10613: #endif
; 10614: 						LogTacticalMessage(strMsg);

	push	1
	lea	ecx, DWORD PTR _strMsg$225756[esp+160]
	push	ecx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 10615: 					}

	lea	ecx, DWORD PTR _strMsg$225756[esp+156]

; 10616: 
; 10617: 				}

	jmp	$LN439@PerformCho
$LN7@PerformCho:

; 10618: 				else if(pUnit->canFortify(pUnit->plot()))

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canFortify
	test	al, al
	je	$LN4@PerformCho

; 10619: 				{
; 10620: 					pUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 10621: 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@PerformCho
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@PerformCho

; 10622: 					{
; 10623: 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$225762[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10624: 						strMsg.Format("Already in position, will fortify with %s, X: %d, Y: %d", pUnit->getName().GetCString(),
; 10625: #ifdef AUI_ITERATORIZE
; 10626: 							it->GetPlot()->getX(), it->GetPlot()->getY());
; 10627: #else
; 10628: 							m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY());

	lea	edx, DWORD PTR $T298419[esp+156]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+168], 10	; 0000000aH
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+27428]
	lea	edx, DWORD PTR [ecx+ebp]
	mov	ecx, DWORD PTR [edx]
	movsx	ecx, WORD PTR [ecx+2]
	mov	edx, DWORD PTR [edx]
	movsx	edx, WORD PTR [edx]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+172], 11		; 0000000bH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strMsg$225762[esp+168]
	push	OFFSET $SG225764
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T298419[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], 10		; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10629: #endif
; 10630: 						LogTacticalMessage(strMsg);

	push	1
	lea	eax, DWORD PTR _strMsg$225762[esp+160]
	push	eax
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 10631: 					}

	lea	ecx, DWORD PTR _strMsg$225762[esp+156]

; 10632: 				}
; 10633: 				else

	jmp	$LN439@PerformCho
$LN4@PerformCho:

; 10634: 				{
; 10635: 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@PerformCho
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@PerformCho

; 10636: 					{
; 10637: 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$225767[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10638: 						strMsg.Format("Already in position, no move for %s, X: %d, Y: %d", pUnit->getName().GetCString(),
; 10639: #ifdef AUI_ITERATORIZE
; 10640: 							it->GetPlot()->getX(), it->GetPlot()->getY());
; 10641: #else
; 10642: 							m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY());

	lea	ecx, DWORD PTR $T298420[esp+156]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+168], ebx
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	edx, DWORD PTR [esi+27428]
	mov	ecx, DWORD PTR [edx+ebp]
	movsx	ecx, WORD PTR [ecx+2]
	add	edx, ebp
	mov	edx, DWORD PTR [edx]
	movsx	edx, WORD PTR [edx]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+172], 13		; 0000000dH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strMsg$225767[esp+168]
	push	OFFSET $SG225769
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T298420[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10643: #endif
; 10644: 						LogTacticalMessage(strMsg);

	push	1
	lea	ecx, DWORD PTR _strMsg$225767[esp+160]
	push	ecx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 10645: 					}

	lea	ecx, DWORD PTR _strMsg$225767[esp+156]
$LN439@PerformCho:
	mov	DWORD PTR __$EHRec$[esp+164], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@PerformCho:

; 10646: 				}
; 10647: 				pUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN8@PerformCho:

; 10648: 			}
; 10649: 			UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR [edi+100]
	push	1
	push	edx
	mov	ecx, esi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed
$LN11@PerformCho:
	mov	eax, DWORD PTR _iI$225747[esp+156]
	inc	eax
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _iI$225747[esp+156], eax
	cmp	eax, DWORD PTR [esi+27432]
	jb	$LL12@PerformCho
$LN10@PerformCho:

; 10650: 		}
; 10651: 	}
; 10652: }

	mov	ecx, DWORD PTR __$EHRec$[esp+156]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 140				; 0000008cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$1:
	lea	ecx, DWORD PTR _strMsg$225695[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$2:
	lea	ecx, DWORD PTR $T298411[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$4:
	lea	ecx, DWORD PTR _strMsg$225711[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$5:
	lea	ecx, DWORD PTR $T298413[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$7:
	lea	ecx, DWORD PTR _strMsg$225728[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$8:
	lea	ecx, DWORD PTR $T298415[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$10:
	lea	ecx, DWORD PTR _strMsg$225744[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$11:
	lea	ecx, DWORD PTR $T298417[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$12:
	lea	ecx, DWORD PTR _strMsg$225756[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$13:
	lea	ecx, DWORD PTR $T298418[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$14:
	lea	ecx, DWORD PTR _strMsg$225762[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$15:
	lea	ecx, DWORD PTR $T298419[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$16:
	lea	ecx, DWORD PTR _strMsg$225767[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z$17:
	lea	ecx, DWORD PTR $T298420[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z:
	mov	eax, OFFSET __ehfuncinfo$?PerformChosenMoves@CvTacticalAI@@AAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PerformChosenMoves@CvTacticalAI@@AAEXH@Z ENDP		; CvTacticalAI::PerformChosenMoves
PUBLIC	?NumUniqueUnitsLeft@CvTacticalAI@@AAEHXZ	; CvTacticalAI::NumUniqueUnitsLeft
; Function compile flags: /Ogtpy
;	COMDAT ?NumUniqueUnitsLeft@CvTacticalAI@@AAEHXZ
_TEXT	SEGMENT
?NumUniqueUnitsLeft@CvTacticalAI@@AAEHXZ PROC		; CvTacticalAI::NumUniqueUnitsLeft, COMDAT
; _this$ = ecx

; 10863: {

	push	ebx
	push	edi
	mov	edi, ecx

; 10864: 	int iRtnValue = 1;
; 10865: 	int iCurrentID;
; 10866: 
; 10867: 	if(m_PotentialBlocks.size() < 2)

	mov	eax, DWORD PTR [edi+26600]
	mov	ebx, 1
	cmp	eax, 2

; 10868: 	{
; 10869: 		return m_PotentialBlocks.size();

	jb	SHORT $LN6@NumUniqueU
	push	esi

; 10870: 	}
; 10871: 
; 10872: 	// Copy data over and sort it so in unit ID order
; 10873: 	m_TemporaryBlocks.clear();
; 10874: 	m_TemporaryBlocks = m_PotentialBlocks;

	lea	eax, DWORD PTR [edi+26596]
	lea	esi, DWORD PTR [edi+27012]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [edi+27016], 0
	call	??4?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::operator=

; 10875: 	std::stable_sort(m_TemporaryBlocks.begin(), m_TemporaryBlocks.end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	shl	eax, 4
	add	eax, ecx
	cmp	ecx, eax
	je	SHORT $LN24@NumUniqueU
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvBlockingUnit@@HV1@@std@@YAXPAVCvBlockingUnit@@0PAH0@Z ; std::_Stable_sort<CvBlockingUnit *,int,CvBlockingUnit>
	add	esp, 16					; 00000010H
$LN24@NumUniqueU:
	mov	edi, DWORD PTR [edi+27016]

; 10876: 
; 10877: #ifdef AUI_ITERATORIZE
; 10878: 	iCurrentID = m_TemporaryBlocks.begin()->GetUnitID();
; 10879: 	for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_TemporaryBlocks.begin() + 1; it != m_TemporaryBlocks.end(); ++it)
; 10880: 	{
; 10881: 		if (it->GetUnitID() != iCurrentID)
; 10882: 		{
; 10883: 			iRtnValue++;
; 10884: 			iCurrentID = it->GetUnitID();
; 10885: #else
; 10886: 	iCurrentID = m_TemporaryBlocks[0].GetUnitID();

	mov	esi, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]

; 10887: 	for(unsigned int iI = 1; iI < m_TemporaryBlocks.size(); iI++)

	cmp	edi, 1
	jbe	SHORT $LN2@NumUniqueU
	lea	ecx, DWORD PTR [esi+20]
	lea	esi, DWORD PTR [edi-1]
$LL4@NumUniqueU:

; 10888: 	{
; 10889: 		if(m_TemporaryBlocks[iI].GetUnitID() != iCurrentID)

	mov	eax, DWORD PTR [ecx]
	cmp	eax, edx
	je	SHORT $LN3@NumUniqueU

; 10890: 		{
; 10891: 			iRtnValue++;

	inc	ebx

; 10892: 			iCurrentID = m_TemporaryBlocks[iI].GetUnitID();

	mov	edx, eax
$LN3@NumUniqueU:
	add	ecx, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL4@NumUniqueU
$LN2@NumUniqueU:

; 10893: #endif
; 10894: 		}
; 10895: 	}
; 10896: 
; 10897: 	return iRtnValue;

	mov	eax, ebx
	pop	esi
$LN6@NumUniqueU:
	pop	edi
	pop	ebx

; 10898: }

	ret	0
?NumUniqueUnitsLeft@CvTacticalAI@@AAEHXZ ENDP		; CvTacticalAI::NumUniqueUnitsLeft
_TEXT	ENDS
PUBLIC	?FindTacticalTargets@CvTacticalAI@@AAEXXZ	; CvTacticalAI::FindTacticalTargets
EXTRN	?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z:PROC ; CvPlayerTrade::ContainsEnemyTradePlot
EXTRN	?GetAdjacentFriendlyCity@CvPlot@@QBEPAVCvCity@@W4TeamTypes@@_N@Z:PROC ; CvPlot::GetAdjacentFriendlyCity
EXTRN	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z:PROC ; CvPlot::defenseModifier
EXTRN	?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z:PROC ; CvPlayerTrade::ContainsEnemyTradeUnit
EXTRN	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isVisibleOtherUnit
EXTRN	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsTradeRoute
EXTRN	?IsRoutePillaged@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsRoutePillaged
EXTRN	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ:PROC ; CvPlot::getRouteType
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?IsImprovementPillaged@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovementPillaged
EXTRN	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC	; CvPlot::isGoody
EXTRN	?getThreatValue@CvCity@@QAEHXZ:PROC		; CvCity::getThreatValue
EXTRN	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ:PROC ; CvPlayer::GetTrade
; Function compile flags: /Ogtpy
;	COMDAT ?FindTacticalTargets@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_bBarbsAllowedYet$ = -37				; size = 1
_iI$ = -36						; size = 4
_pPlayerTrade$ = -32					; size = 4
_newTarget$ = -28					; size = 28
?FindTacticalTargets@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::FindTacticalTargets, COMDAT
; _this$ = ecx

; 1338 : {

	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	push	esi

; 1339 : #ifndef AUI_WARNING_FIXES
; 1340 : 	int iI;
; 1341 : #endif
; 1342 : 	CvPlot* pLoopPlot;
; 1343 : 	CvTacticalTarget newTarget;

	or	eax, -1
	push	edi
	mov	ebx, ecx

; 1344 : 	bool bValidPlot;
; 1345 : 	bool bEnemyDominatedPlot;
; 1346 : 	CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();

	mov	ecx, DWORD PTR [ebx]
	xor	edi, edi
	mov	DWORD PTR _newTarget$[esp+56], edi
	mov	DWORD PTR _newTarget$[esp+60], eax
	mov	DWORD PTR _newTarget$[esp+64], eax
	mov	DWORD PTR _newTarget$[esp+68], eax
	mov	DWORD PTR _newTarget$[esp+80], eax
	mov	DWORD PTR _newTarget$[esp+72], edi
	mov	DWORD PTR _newTarget$[esp+76], edi
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade

; 1347 : 
; 1348 : 	// Clear out target list since we rebuild it each turn
; 1349 : 	m_AllTargets.clear();

	lea	ebp, DWORD PTR [ebx+2152]
	mov	DWORD PTR [ebp+4], edi

; 1350 : 
; 1351 : 	bool bBarbsAllowedYet = GC.getGame().getGameTurn() >= GC.getGame().GetBarbarianReleaseTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [ecx+604]
	mov	DWORD PTR _pPlayerTrade$[esp+56], eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 1352 : 
; 1353 : 	// Look at every tile on map
; 1354 : #ifdef AUI_WARNING_FIXES
; 1355 : 	for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 1356 : #else
; 1357 : 	for(iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, esi
	setge	BYTE PTR _bBarbsAllowedYet$[esp+56]
	cmp	DWORD PTR [ecx+4028], edi
	mov	DWORD PTR _iI$[esp+56], edi
	jle	$LN58@FindTactic
	npad	4
$LL60@FindTactic:

; 1358 : #endif
; 1359 : 	{
; 1360 : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	esi, DWORD PTR _iI$[esp+56]
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]

; 1361 : 		bValidPlot = false;
; 1362 : 
; 1363 : 		if(pLoopPlot->isVisible(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	$LN59@FindTactic
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	cmp	eax, -1
	je	$LN59@FindTactic
	mov	edx, DWORD PTR [esi+156]
	cmp	WORD PTR [edx+eax*2], 0
	setg	al
	test	al, al
	je	$LN59@FindTactic

; 1364 : 		{
; 1365 : 			// Make sure I am not a barbarian who can not move into owned territory this early in the game
; 1366 : 			if(!m_pPlayer->isBarbarian() || bBarbsAllowedYet)

	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	je	SHORT $LN55@FindTactic
	cmp	BYTE PTR _bBarbsAllowedYet$[esp+56], 0
	jne	SHORT $LN55@FindTactic

; 1367 : 			{
; 1368 : 				bValidPlot = true;
; 1369 : 			}
; 1370 : 			else
; 1371 : 			{
; 1372 : 				if(!pLoopPlot->isOwned())

	mov	ecx, esi
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	jne	$LN59@FindTactic
$LN55@FindTactic:

; 1373 : 				{
; 1374 : 					bValidPlot = true;
; 1375 : 				}
; 1376 : 			}
; 1377 : 			if(bValidPlot)
; 1378 : 			{
; 1379 : 				if(PlotAlreadyTargeted(pLoopPlot) != -1)

	push	esi
	mov	ecx, ebx
	call	?PlotAlreadyTargeted@CvTacticalAI@@QAEHPAVCvPlot@@@Z ; CvTacticalAI::PlotAlreadyTargeted
	cmp	eax, -1
	jne	$LN59@FindTactic

; 1380 : 				{
; 1381 : 					bValidPlot = false;
; 1382 : 				}
; 1383 : 			}
; 1384 : 		}
; 1385 : 
; 1386 : 		if(bValidPlot)
; 1387 : 		{
; 1388 : 			newTarget.Clear();
; 1389 : 			newTarget.SetTargetX(pLoopPlot->getX());
; 1390 : 			newTarget.SetTargetY(pLoopPlot->getY());

	movsx	ecx, WORD PTR [esi+2]
	mov	DWORD PTR _newTarget$[esp+68], eax
	movsx	eax, WORD PTR [esi]
	xor	edi, edi
	mov	DWORD PTR _newTarget$[esp+64], ecx

; 1391 : 			newTarget.SetDominanceZone(GC.getGame().GetTacticalAnalysisMap()->GetCell(iI)->GetDominanceZone());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _newTarget$[esp+56], edi
	mov	DWORD PTR _newTarget$[esp+72], edi
	mov	DWORD PTR _newTarget$[esp+76], edi
	mov	DWORD PTR _newTarget$[esp+60], eax
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	edx, DWORD PTR _iI$[esp+56]
	mov	eax, DWORD PTR [eax+12]
	imul	edx, 44					; 0000002cH
	mov	ecx, DWORD PTR [eax+edx+40]
	mov	DWORD PTR _newTarget$[esp+80], ecx

; 1392 : 
; 1393 : 			bEnemyDominatedPlot = GC.getGame().GetTacticalAnalysisMap()->IsInEnemyDominatedZone(pLoopPlot);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	ecx, eax
	call	?IsInEnemyDominatedZone@CvTacticalAnalysisMap@@QAE_NPAVCvPlot@@@Z ; CvTacticalAnalysisMap::IsInEnemyDominatedZone

; 1394 : 
; 1395 : 			// Have a ...
; 1396 : 			// ... friendly city?
; 1397 : 			CvCity* pCity = pLoopPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	cmp	eax, edi
	jl	$LN49@FindTactic
	cmp	eax, 64					; 00000040H
	jge	$LN49@FindTactic
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax

; 1398 : 			if(pCity != NULL)

	test	edi, edi
	je	$LN396@FindTactic

; 1399 : 			{
; 1400 : 				if(m_pPlayer->GetID() == pCity->getOwner())

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, DWORD PTR [edi+84]
	jne	SHORT $LN48@FindTactic

; 1401 : 				{
; 1402 : 					newTarget.SetTargetType(AI_TACTICAL_TARGET_CITY_TO_DEFEND);
; 1403 : 					newTarget.SetAuxData((void*)pCity);
; 1404 : 					newTarget.SetAuxIntData(pCity->getThreatValue());

	mov	ecx, edi
	mov	DWORD PTR _newTarget$[esp+56], 8
	mov	DWORD PTR _newTarget$[esp+72], edi
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	mov	DWORD PTR _newTarget$[esp+76], eax

; 1405 : 					m_AllTargets.push_back(newTarget);

	mov	eax, DWORD PTR [ebp+8]
	mov	BYTE PTR [ebp+7180], 0
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN142@FindTactic
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::GrowSize
$LN142@FindTactic:
	mov	eax, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edi, DWORD PTR [edx+ecx*4]
	jmp	$LN404@FindTactic
$LN48@FindTactic:

; 1406 : 				}
; 1407 : 
; 1408 : 				// ... enemy city
; 1409 : 				else if(atWar(m_pPlayer->getTeam(), pCity->getTeam()))

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN153@FindTactic
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN154@FindTactic
$LN153@FindTactic:
	or	esi, -1
$LN154@FindTactic:
	mov	ecx, edi
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	push	esi
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	$LN59@FindTactic

; 1410 : 				{
; 1411 : 					newTarget.SetTargetType(AI_TACTICAL_TARGET_CITY);
; 1412 : 					newTarget.SetTargetPlayer(pCity->getOwner());

	mov	eax, DWORD PTR [edi+84]

; 1413 : 					newTarget.SetAuxData((void*)pCity);
; 1414 : 					m_AllTargets.push_back(newTarget);

	lea	ecx, DWORD PTR _newTarget$[esp+56]
	mov	DWORD PTR _newTarget$[esp+56], 1
	mov	DWORD PTR _newTarget$[esp+68], eax
	mov	DWORD PTR _newTarget$[esp+72], edi
	push	ecx

; 1415 : 				}
; 1416 : 			}
; 1417 : 			else

	jmp	$LN399@FindTactic
$LN396@FindTactic:
	xor	edi, edi
$LN49@FindTactic:

; 1418 : 			{
; 1419 : 				// ... enemy unit?
; 1420 : 				CvUnit* pUnit = pLoopPlot->getVisibleEnemyDefender(m_pPlayer->GetID());

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, esi
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender

; 1421 : 				if(pUnit != NULL)

	cmp	eax, edi
	je	SHORT $LN44@FindTactic

; 1422 : 				{
; 1423 : 					newTarget.SetTargetType(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT);
; 1424 : 					newTarget.SetTargetPlayer(pUnit->getOwner());

	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _newTarget$[esp+68], ecx

; 1425 : 					newTarget.SetAuxData((void*)pUnit);
; 1426 : 					newTarget.SetAuxIntData(pUnit->getDamage());

	mov	ecx, eax
	mov	DWORD PTR _newTarget$[esp+56], 5
	mov	DWORD PTR _newTarget$[esp+72], eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	DWORD PTR _newTarget$[esp+76], eax

; 1427 : 					m_AllTargets.push_back(newTarget);

	mov	eax, DWORD PTR [ebp+8]
	mov	BYTE PTR [ebp+7180], 0
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN184@FindTactic
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::GrowSize
$LN184@FindTactic:
	mov	eax, DWORD PTR [ebp+4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ebp]
	lea	edi, DWORD PTR [eax+edx*4]
$LN404@FindTactic:
	test	edi, edi
	je	SHORT $LN187@FindTactic
	mov	ecx, 7
	lea	esi, DWORD PTR _newTarget$[esp+56]
	rep movsd
$LN187@FindTactic:
	inc	DWORD PTR [ebp+4]
	jmp	$LN59@FindTactic
$LN44@FindTactic:

; 1428 : 				}
; 1429 : 
; 1430 : 				// ... undefended camp?
; 1431 : 				else if(pLoopPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, edi
	jne	SHORT $LN42@FindTactic

; 1432 : 				{
; 1433 : 					newTarget.SetTargetType(AI_TACTICAL_TARGET_BARBARIAN_CAMP);
; 1434 : 					newTarget.SetTargetPlayer(BARBARIAN_PLAYER);
; 1435 : 					newTarget.SetAuxData((void*)pLoopPlot);
; 1436 : 					m_AllTargets.push_back(newTarget);

	lea	ecx, DWORD PTR _newTarget$[esp+56]
	mov	DWORD PTR _newTarget$[esp+56], 2
	mov	DWORD PTR _newTarget$[esp+68], 63	; 0000003fH
	push	ecx
	jmp	$LN400@FindTactic
$LN42@FindTactic:

; 1437 : 				}
; 1438 : 
; 1439 : 				// ... goody hut?
; 1440 : 				else if(!m_pPlayer->isMinorCiv() && pLoopPlot->isGoody())

	mov	ecx, DWORD PTR [ebx]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN397@FindTactic
	push	-1
	mov	ecx, esi
	call	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isGoody
	test	al, al
	je	SHORT $LN397@FindTactic

; 1441 : 				{
; 1442 : 					newTarget.SetTargetType(AI_TACTICAL_TARGET_ANCIENT_RUINS);

	mov	DWORD PTR _newTarget$[esp+56], 11	; 0000000bH

; 1443 : 					newTarget.SetAuxData((void*)pLoopPlot);
; 1444 : 					m_AllTargets.push_back(newTarget);
; 1445 : 				}
; 1446 : 
; 1447 : 				// Or citadels!
; 1448 : 				else if(atWar(m_pPlayer->getTeam(), pLoopPlot->getTeam()) &&

	jmp	$LN401@FindTactic
$LN397@FindTactic:

; 1449 : 					pLoopPlot->getImprovementType() != NO_IMPROVEMENT &&
; 1450 : 					GC.getImprovementInfo(pLoopPlot->getImprovementType())->GetNearbyEnemyDamage() > 0)

	movsx	eax, BYTE PTR [esi+4]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, -1
	je	SHORT $LN204@FindTactic
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN211@FindTactic
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, eax
	jmp	SHORT $LN203@FindTactic
$LN211@FindTactic:
	or	eax, -1
	mov	ecx, eax
	jmp	SHORT $LN203@FindTactic
$LN204@FindTactic:
	or	ecx, -1
$LN203@FindTactic:
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN220@FindTactic
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN221@FindTactic
$LN220@FindTactic:
	or	eax, -1
$LN221@FindTactic:
	push	ecx
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	SHORT $LN398@FindTactic
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN398@FindTactic
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetNearbyEnemyDamage
	test	eax, eax
	jle	SHORT $LN398@FindTactic

; 1451 : 				{
; 1452 : 					newTarget.SetTargetType(AI_TACTICAL_TARGET_CITADEL);
; 1453 : 					newTarget.SetTargetPlayer(pLoopPlot->getOwner());

	movsx	eax, BYTE PTR [esi+4]

; 1454 : 					newTarget.SetAuxData((void*)pLoopPlot);
; 1455 : 					m_AllTargets.push_back(newTarget);

	lea	ecx, DWORD PTR _newTarget$[esp+56]
	mov	DWORD PTR _newTarget$[esp+56], 23	; 00000017H
	mov	DWORD PTR _newTarget$[esp+68], eax
	push	ecx

; 1456 : 				}
; 1457 : 
; 1458 : 				// ... enemy improvement?
; 1459 : 				else if(atWar(m_pPlayer->getTeam(), pLoopPlot->getTeam()) &&

	jmp	$LN400@FindTactic
$LN398@FindTactic:

; 1460 : 				        pLoopPlot->getImprovementType() != NO_IMPROVEMENT &&
; 1461 : 				        !pLoopPlot->IsImprovementPillaged())

	movsx	eax, BYTE PTR [esi+4]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, -1
	je	SHORT $LN234@FindTactic
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN241@FindTactic
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, eax
	jmp	SHORT $LN233@FindTactic
$LN241@FindTactic:
	or	eax, -1
	mov	ecx, eax
	jmp	SHORT $LN233@FindTactic
$LN234@FindTactic:
	or	ecx, -1
$LN233@FindTactic:
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN250@FindTactic
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN251@FindTactic
$LN250@FindTactic:
	or	eax, -1
$LN251@FindTactic:
	push	ecx
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	$LN36@FindTactic
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	$LN36@FindTactic
	mov	ecx, esi
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	test	al, al
	jne	$LN36@FindTactic

; 1462 : 				{
; 1463 : 					ResourceUsageTypes eRUT = (ResourceUsageTypes)-1;
; 1464 : 					ResourceTypes eResource = pLoopPlot->getResourceType();

	push	-1
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 1465 : 					if (eResource != NO_RESOURCE)

	cmp	eax, -1
	je	SHORT $LN394@FindTactic

; 1466 : 					{
; 1467 : 						eRUT = GC.getResourceInfo(eResource)->getResourceUsage();

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage

; 1468 : 					}
; 1469 : 
; 1470 : 					// On land, civs prioritize improvements built on resources
; 1471 : 					if (eRUT == RESOURCEUSAGE_STRATEGIC || eRUT == RESOURCEUSAGE_LUXURY || pLoopPlot->isWater() || m_pPlayer->isBarbarian())

	cmp	eax, 1
	je	SHORT $LN33@FindTactic
	cmp	eax, 2
	je	SHORT $LN33@FindTactic
$LN394@FindTactic:
	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN33@FindTactic
	mov	ecx, DWORD PTR [ebx]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN33@FindTactic
$LN402@FindTactic:

; 1484 : 						}
; 1485 : 					}
; 1486 : 					else
; 1487 : 					{
; 1488 : 						newTarget.SetTargetType(AI_TACTICAL_TARGET_IMPROVEMENT);
; 1489 : 						newTarget.SetTargetPlayer(pLoopPlot->getOwner());

	movsx	eax, BYTE PTR [esi+4]

; 1490 : 						newTarget.SetAuxData((void*)pLoopPlot);
; 1491 : 						m_AllTargets.push_back(newTarget);

	lea	ecx, DWORD PTR _newTarget$[esp+56]
	mov	DWORD PTR _newTarget$[esp+56], 3
	mov	DWORD PTR _newTarget$[esp+68], eax
	push	ecx
	jmp	$LN400@FindTactic
$LN33@FindTactic:

; 1472 : 					{
; 1473 : 						// Barbarians can't target naval improvements
; 1474 : 						if(m_pPlayer->isBarbarian() && pLoopPlot->isWater())

	mov	ecx, DWORD PTR [ebx]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	je	SHORT $LN32@FindTactic
	cmp	BYTE PTR [esi+5], 3
	je	$LN59@FindTactic
$LN32@FindTactic:

; 1475 : 						{
; 1476 : 							continue;
; 1477 : 						}
; 1478 : 						else
; 1479 : 						{
; 1480 : 							newTarget.SetTargetType(AI_TACTICAL_TARGET_IMPROVEMENT_RESOURCE);
; 1481 : 							newTarget.SetTargetPlayer(pLoopPlot->getOwner());

	movsx	edx, BYTE PTR [esi+4]

; 1482 : 							newTarget.SetAuxData((void*)pLoopPlot);
; 1483 : 							m_AllTargets.push_back(newTarget);

	lea	eax, DWORD PTR _newTarget$[esp+56]
	mov	DWORD PTR _newTarget$[esp+56], 24	; 00000018H
	mov	DWORD PTR _newTarget$[esp+68], edx
	push	eax

; 1492 : 					}
; 1493 : 				}
; 1494 : 
; 1495 : 				// ... enemy trade route?
; 1496 : 				else if(atWar(m_pPlayer->getTeam(), pLoopPlot->getTeam()) &&

	jmp	$LN400@FindTactic
$LN36@FindTactic:

; 1497 : 				        pLoopPlot->getRouteType() != NO_ROUTE && !pLoopPlot->IsRoutePillaged() && pLoopPlot->IsTradeRoute()/* && !bEnemyDominatedPlot*/)

	movsx	eax, BYTE PTR [esi+4]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, -1
	je	SHORT $LN276@FindTactic
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN283@FindTactic
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, eax
	jmp	SHORT $LN275@FindTactic
$LN283@FindTactic:
	or	eax, -1
	mov	ecx, eax
	jmp	SHORT $LN275@FindTactic
$LN276@FindTactic:
	or	ecx, -1
$LN275@FindTactic:
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN292@FindTactic
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN293@FindTactic
$LN292@FindTactic:
	or	eax, -1
$LN293@FindTactic:
	push	ecx
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	SHORT $LN28@FindTactic
	mov	ecx, esi
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN28@FindTactic
	mov	ecx, esi
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	test	al, al
	jne	SHORT $LN28@FindTactic
	push	-1
	mov	ecx, esi
	call	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsTradeRoute
	test	al, al

; 1498 : 				{
; 1499 : 					newTarget.SetTargetType(AI_TACTICAL_TARGET_IMPROVEMENT);
; 1500 : 					newTarget.SetTargetPlayer(pLoopPlot->getOwner());
; 1501 : 					newTarget.SetAuxData((void*)pLoopPlot);
; 1502 : 					m_AllTargets.push_back(newTarget);

	jne	$LN402@FindTactic
$LN28@FindTactic:

; 1503 : 				}
; 1504 : 
; 1505 : 				// ... enemy civilian (or embarked) unit?
; 1506 : 				else if(pLoopPlot->isVisibleOtherUnit(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, esi
	call	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleOtherUnit
	test	al, al
	je	$LN26@FindTactic

; 1507 : 				{
; 1508 : 					CvUnit* pTargetUnit = pLoopPlot->getUnitByIndex(0);

	push	0
	mov	ecx, esi
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	esi, eax

; 1509 : 					if(!pTargetUnit->isDelayedDeath() && atWar(m_pPlayer->getTeam(), pTargetUnit->getTeam()) && !pTargetUnit->IsCanDefend())

	mov	ecx, esi
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	$LN59@FindTactic
	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	$LN59@FindTactic
	push	0
	mov	ecx, esi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	jne	$LN59@FindTactic

; 1510 : 					{
; 1511 : 						newTarget.SetTargetType(AI_TACTICAL_TARGET_LOW_PRIORITY_CIVILIAN);
; 1512 : 						newTarget.SetTargetPlayer(pTargetUnit->getOwner());
; 1513 : 						newTarget.SetAuxData((void*)pTargetUnit);
; 1514 : 
; 1515 : 						if(pTargetUnit->isEmbarked())

	cmp	BYTE PTR [esi+1652], 0
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR _newTarget$[esp+56], 18	; 00000012H
	mov	DWORD PTR _newTarget$[esp+68], eax
	mov	DWORD PTR _newTarget$[esp+72], esi
	je	SHORT $LN24@FindTactic

; 1516 : 						{
; 1517 : 							if(pTargetUnit->IsCombatUnit())

	xor	ecx, ecx
	cmp	DWORD PTR [esi+1044], ecx

; 1539 : 							}
; 1540 : 						}
; 1541 : 						m_AllTargets.push_back(newTarget);

	lea	edx, DWORD PTR _newTarget$[esp+56]
	setle	cl
	push	edx
	add	ecx, 13					; 0000000dH
	mov	DWORD PTR _newTarget$[esp+60], ecx

; 1542 : 					}
; 1543 : 				}

	jmp	$LN399@FindTactic
$LN24@FindTactic:

; 1518 : 							{
; 1519 : 								newTarget.SetTargetType(AI_TACTICAL_TARGET_EMBARKED_MILITARY_UNIT);
; 1520 : 							}
; 1521 : 							else
; 1522 : 							{
; 1523 : 								newTarget.SetTargetType(AI_TACTICAL_TARGET_EMBARKED_CIVILIAN);
; 1524 : 							}
; 1525 : 						}
; 1526 : 						else
; 1527 : 						{
; 1528 : 							if(IsVeryHighPriorityCivilianTarget(&newTarget))

	lea	edx, DWORD PTR _newTarget$[esp+56]
	push	edx
	mov	ecx, ebx
	call	?IsVeryHighPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z ; CvTacticalAI::IsVeryHighPriorityCivilianTarget
	test	al, al
	je	SHORT $LN20@FindTactic

; 1539 : 							}
; 1540 : 						}
; 1541 : 						m_AllTargets.push_back(newTarget);

	lea	edx, DWORD PTR _newTarget$[esp+56]
	mov	DWORD PTR _newTarget$[esp+56], 15	; 0000000fH
	push	edx

; 1542 : 					}
; 1543 : 				}

	jmp	$LN399@FindTactic
$LN20@FindTactic:

; 1529 : 							{
; 1530 : 								newTarget.SetTargetType(AI_TACTICAL_TARGET_VERY_HIGH_PRIORITY_CIVILIAN);
; 1531 : 							}
; 1532 : 							else if(IsHighPriorityCivilianTarget(&newTarget))

	lea	eax, DWORD PTR _newTarget$[esp+56]
	push	eax
	mov	ecx, ebx
	call	?IsHighPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z ; CvTacticalAI::IsHighPriorityCivilianTarget
	test	al, al
	je	SHORT $LN18@FindTactic

; 1539 : 							}
; 1540 : 						}
; 1541 : 						m_AllTargets.push_back(newTarget);

	lea	edx, DWORD PTR _newTarget$[esp+56]
	mov	DWORD PTR _newTarget$[esp+56], 16	; 00000010H
	push	edx

; 1542 : 					}
; 1543 : 				}

	jmp	$LN399@FindTactic
$LN18@FindTactic:

; 1533 : 							{
; 1534 : 								newTarget.SetTargetType(AI_TACTICAL_TARGET_HIGH_PRIORITY_CIVILIAN);
; 1535 : 							}
; 1536 : 							else if(IsMediumPriorityCivilianTarget(&newTarget))

	lea	ecx, DWORD PTR _newTarget$[esp+56]
	push	ecx
	mov	ecx, ebx
	call	?IsMediumPriorityCivilianTarget@CvTacticalAI@@AAE_NPAVCvTacticalTarget@@@Z ; CvTacticalAI::IsMediumPriorityCivilianTarget
	test	al, al
	je	SHORT $LN335@FindTactic

; 1537 : 							{
; 1538 : 								newTarget.SetTargetType(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_CIVILIAN);

	mov	DWORD PTR _newTarget$[esp+56], 17	; 00000011H
$LN335@FindTactic:

; 1539 : 							}
; 1540 : 						}
; 1541 : 						m_AllTargets.push_back(newTarget);

	lea	edx, DWORD PTR _newTarget$[esp+56]
	push	edx

; 1542 : 					}
; 1543 : 				}

	jmp	$LN399@FindTactic
$LN26@FindTactic:

; 1544 : 
; 1545 : 				// ... trade unit
; 1546 : 				else if (pPlayerTrade->ContainsEnemyTradeUnit(pLoopPlot))

	mov	edi, DWORD PTR _pPlayerTrade$[esp+56]
	push	esi
	mov	ecx, edi
	call	?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ; CvPlayerTrade::ContainsEnemyTradeUnit
	test	al, al
	je	SHORT $LN14@FindTactic

; 1547 : 				{
; 1548 : 					if (pLoopPlot->isWater())

	xor	eax, eax
	cmp	BYTE PTR [esi+5], 3
	lea	ecx, DWORD PTR _newTarget$[esp+56]
	setne	al
	push	ecx
	add	eax, 19					; 00000013H
	mov	DWORD PTR _newTarget$[esp+60], eax
	jmp	$LN400@FindTactic
$LN14@FindTactic:

; 1549 : 					{
; 1550 : 						newTarget.SetTargetType(AI_TACTICAL_TARGET_TRADE_UNIT_SEA);
; 1551 : 					}
; 1552 : 					else
; 1553 : 					{
; 1554 : 						newTarget.SetTargetType(AI_TACTICAL_TARGET_TRADE_UNIT_LAND);
; 1555 : 					}
; 1556 : 
; 1557 : 					newTarget.SetAuxData((void*)pLoopPlot);
; 1558 : 					m_AllTargets.push_back(newTarget);
; 1559 : 				}
; 1560 : 
; 1561 : 				// ... defensive bastion?
; 1562 : 				else if(m_pPlayer->GetID() == pLoopPlot->getOwner() &&
; 1563 : 				        pLoopPlot->defenseModifier(m_pPlayer->getTeam(), true) > 0 &&
; 1564 : 				        m_pPlayer->GetPlotDanger(*pLoopPlot) > 0)

	movsx	edx, BYTE PTR [esi+4]
	mov	ecx, DWORD PTR [ebx]
	cmp	DWORD PTR [ecx+44], edx
	jne	SHORT $LN10@FindTactic
	push	0
	push	1
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, esi
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
	test	eax, eax
	jle	SHORT $LN10@FindTactic
	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	test	eax, eax
	jle	SHORT $LN10@FindTactic

; 1565 : 				{
; 1566 : 					CvCity* pDefenseCity = pLoopPlot->GetAdjacentFriendlyCity(m_pPlayer->getTeam(), true/*bLandOnly*/);

	mov	ecx, DWORD PTR [ebx]
	push	1
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, esi
	call	?GetAdjacentFriendlyCity@CvPlot@@QBEPAVCvCity@@W4TeamTypes@@_N@Z ; CvPlot::GetAdjacentFriendlyCity
	mov	edi, eax

; 1567 : 					if(pDefenseCity)

	test	edi, edi
	je	$LN59@FindTactic

; 1568 : 					{
; 1569 : 						newTarget.SetTargetType(AI_TACTICAL_TARGET_DEFENSIVE_BASTION);
; 1570 : 						newTarget.SetAuxData((void*)pLoopPlot);
; 1571 : 						newTarget.SetAuxIntData(pDefenseCity->getThreatValue() + m_pPlayer->GetPlotDanger(*pLoopPlot));

	mov	ecx, DWORD PTR [ebx]
	push	esi
	mov	DWORD PTR _newTarget$[esp+60], 10	; 0000000aH
	mov	DWORD PTR _newTarget$[esp+76], esi
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	ecx, edi
	mov	esi, eax
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	add	esi, eax

; 1572 : 						m_AllTargets.push_back(newTarget);

	lea	eax, DWORD PTR _newTarget$[esp+56]
	mov	DWORD PTR _newTarget$[esp+76], esi
	push	eax

; 1573 : 					}
; 1574 : 				}
; 1575 : 
; 1576 : 				// ... friendly improvement?
; 1577 : 				else if(m_pPlayer->GetID() == pLoopPlot->getOwner() &&

	jmp	SHORT $LN399@FindTactic
$LN10@FindTactic:

; 1578 : 				        pLoopPlot->getImprovementType() != NO_IMPROVEMENT &&
; 1579 : 				        !pLoopPlot->IsImprovementPillaged() && !pLoopPlot->isGoody())

	movsx	edx, BYTE PTR [esi+4]
	mov	ecx, DWORD PTR [ebx]
	cmp	DWORD PTR [ecx+44], edx
	jne	SHORT $LN7@FindTactic
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN7@FindTactic
	mov	ecx, esi
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	test	al, al
	jne	SHORT $LN7@FindTactic
	push	-1
	mov	ecx, esi
	call	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isGoody
	test	al, al
	jne	SHORT $LN7@FindTactic

; 1580 : 				{
; 1581 : 					newTarget.SetTargetType(AI_TACTICAL_TARGET_IMPROVEMENT_TO_DEFEND);
; 1582 : 					newTarget.SetAuxData((void*)pLoopPlot);
; 1583 : 					m_AllTargets.push_back(newTarget);

	lea	eax, DWORD PTR _newTarget$[esp+56]
	mov	DWORD PTR _newTarget$[esp+56], 9
	push	eax

; 1584 : 				}
; 1585 : 
; 1586 : 				// ... trade plot (for getting units to park on trade routes to try to get them to plunder enemy trade routes)
; 1587 : 				else if (pLoopPlot->isVisible(m_pPlayer->getTeam()) && 

	jmp	SHORT $LN400@FindTactic
$LN7@FindTactic:

; 1588 : 						 pPlayerTrade->ContainsEnemyTradePlot(pLoopPlot))

	mov	ecx, DWORD PTR [ebx]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, esi
	call	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isVisible
	test	al, al
	je	SHORT $LN59@FindTactic
	push	esi
	mov	ecx, edi
	call	?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ; CvPlayerTrade::ContainsEnemyTradePlot
	test	al, al
	je	SHORT $LN59@FindTactic

; 1589 : 				{
; 1590 : 					if (pLoopPlot->isWater())

	xor	ecx, ecx
	cmp	BYTE PTR [esi+5], 3
	setne	cl
	add	ecx, 21					; 00000015H
	mov	DWORD PTR _newTarget$[esp+56], ecx
$LN401@FindTactic:

; 1600 : 					m_AllTargets.push_back(newTarget);

	lea	edx, DWORD PTR _newTarget$[esp+56]
	push	edx
$LN400@FindTactic:

; 1591 : 					{
; 1592 : 						newTarget.SetTargetType(AI_TACTICAL_TARGET_TRADE_UNIT_SEA_PLOT);
; 1593 : 					}
; 1594 : 					else
; 1595 : 					{
; 1596 : 						newTarget.SetTargetType(AI_TACTICAL_TARGET_TRADE_UNIT_LAND_PLOT);
; 1597 : 					}
; 1598 : 
; 1599 : 					newTarget.SetAuxData((void*)pLoopPlot);

	mov	DWORD PTR _newTarget$[esp+76], esi
$LN399@FindTactic:

; 1600 : 					m_AllTargets.push_back(newTarget);

	mov	ecx, ebp
	call	?push_back@?$FStaticVector@VCvTacticalTarget@@$0BAA@$0A@$0BCJ@$0A@@@QAEIABVCvTacticalTarget@@@Z ; FStaticVector<CvTacticalTarget,256,0,297,0>::push_back
$LN59@FindTactic:
	mov	eax, DWORD PTR _iI$[esp+56]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	inc	eax
	cmp	eax, DWORD PTR [ecx+4028]
	mov	DWORD PTR _iI$[esp+56], eax
	jl	$LL60@FindTactic
$LN58@FindTactic:

; 1601 : 				}
; 1602 : 			}
; 1603 : 		}
; 1604 : 	}
; 1605 : 
; 1606 : 	// POST-PROCESSING ON TARGETS
; 1607 : 
; 1608 : 	// Mark enemy units threatening our cities (or camps) as priority targets
; 1609 : 	if(m_pPlayer->isBarbarian())

	mov	ecx, DWORD PTR [ebx]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian

; 1610 : 	{
; 1611 : 		IdentifyPriorityBarbarianTargets();

	mov	ecx, ebx
	test	al, al
	je	SHORT $LN2@FindTactic
	call	?IdentifyPriorityBarbarianTargets@CvTacticalAI@@AAEXXZ ; CvTacticalAI::IdentifyPriorityBarbarianTargets

; 1612 : 	}
; 1613 : 	else

	jmp	SHORT $LN1@FindTactic
$LN2@FindTactic:

; 1614 : 	{
; 1615 : 		IdentifyPriorityTargets();

	call	?IdentifyPriorityTargets@CvTacticalAI@@AAEXXZ ; CvTacticalAI::IdentifyPriorityTargets
$LN1@FindTactic:

; 1616 : 	}
; 1617 : 
; 1618 : 	// Also add some priority targets that we'd like to hit just because of their unit type (e.g. catapults)
; 1619 : 	IdentifyPriorityTargetsByType();

	mov	ecx, ebx
	call	?IdentifyPriorityTargetsByType@CvTacticalAI@@AAEXXZ ; CvTacticalAI::IdentifyPriorityTargetsByType

; 1620 : 
; 1621 : 	// Remove extra targets
; 1622 : 	EliminateNearbyBlockadePoints();

	mov	ecx, ebx
	call	?EliminateNearbyBlockadePoints@CvTacticalAI@@AAEXXZ ; CvTacticalAI::EliminateNearbyBlockadePoints

; 1623 : 
; 1624 : 	// Sort remaining targets by aux data (if used for that target type)
; 1625 : 	std::stable_sort(m_AllTargets.begin(), m_AllTargets.end());

	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	pop	edi
	mov	eax, ecx
	pop	esi
	lea	eax, DWORD PTR [eax+edx*4]
	pop	ebp
	pop	ebx
	cmp	ecx, eax
	je	SHORT $LN379@FindTactic
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 16					; 00000010H
$LN379@FindTactic:

; 1626 : }

	add	esp, 40					; 00000028H
	ret	0
?FindTacticalTargets@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::FindTacticalTargets
_TEXT	ENDS
PUBLIC	?AssignBarbarianMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::AssignBarbarianMoves
; Function compile flags: /Ogtpy
;	COMDAT ?AssignBarbarianMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_move$221172 = -8					; size = 8
?AssignBarbarianMoves@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::AssignBarbarianMoves, COMDAT
; _this$ = ecx

; 1971 : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 1972 : 	FStaticVector<CvTacticalMove, 256, true, c_eCiv5GameplayDLL >::iterator it;
; 1973 : 
; 1974 : 	// Proceed in priority order
; 1975 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1976 : 	for (it = m_MovePriorityList.begin(); it != m_MovePriorityList.end(); ++it)
; 1977 : #else
; 1978 : 	for(it = m_MovePriorityList.begin(); it != m_MovePriorityList.end(); it++)

	mov	eax, DWORD PTR [esi+72]
	push	edi
	mov	edi, DWORD PTR [esi+68]
	mov	ecx, edi
	lea	edx, DWORD PTR [ecx+eax*8]
	cmp	edi, edx
	je	$LN23@AssignBarb
	npad	6
$LL25@AssignBarb:

; 1979 : #endif
; 1980 : 	{
; 1981 : 		CvTacticalMove move = *it;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR _move$221172[esp+20], ecx

; 1982 : 
; 1983 : 		AI_PERF_FORMAT("AI-perf-tact.csv", ("Barb Move: %d, Turn %03d, %s", (int)move.m_eMoveType, GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 1984 : 
; 1985 : #ifdef AUI_WARNING_FIXES
; 1986 : 		switch (static_cast<AIBarbarianTacticalMove>(move.m_eMoveType))
; 1987 : #else
; 1988 : 		switch(move.m_eMoveType)

	cmp	eax, 19					; 00000013H
	ja	$LN24@AssignBarb
	jmp	DWORD PTR $LN36@AssignBarb[eax*4]
$LN20@AssignBarb:

; 1989 : #endif
; 1990 : 		{
; 1991 : 		case AI_TACTICAL_BARBARIAN_CAPTURE_CITY:
; 1992 : 			PlotCaptureCityMoves();

	mov	ecx, esi
	call	?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ ; CvTacticalAI::PlotCaptureCityMoves

; 1993 : 			break;

	jmp	$LN24@AssignBarb
$LN19@AssignBarb:

; 1994 : 		case AI_TACTICAL_BARBARIAN_DAMAGE_CITY:
; 1995 : 			PlotDamageCityMoves();

	mov	ecx, esi
	call	?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ ; CvTacticalAI::PlotDamageCityMoves

; 1996 : 			break;

	jmp	$LN24@AssignBarb
$LN18@AssignBarb:

; 1997 : 		case AI_TACTICAL_BARBARIAN_DESTROY_HIGH_PRIORITY_UNIT:
; 1998 : 			PlotDestroyUnitMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT, true);

	push	0
	push	1
	push	7
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 1999 : 			break;

	jmp	$LN24@AssignBarb
$LN17@AssignBarb:

; 2000 : 		case AI_TACTICAL_BARBARIAN_DESTROY_MEDIUM_PRIORITY_UNIT:
; 2001 : 			PlotDestroyUnitMoves(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT, true);

	push	0
	push	1
	push	6
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 2002 : 			break;

	jmp	$LN24@AssignBarb
$LN16@AssignBarb:

; 2003 : 		case AI_TACTICAL_BARBARIAN_DESTROY_LOW_PRIORITY_UNIT:
; 2004 : 			PlotDestroyUnitMoves(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT, true);

	push	0
	push	1
	push	5
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 2005 : 			break;

	jmp	$LN24@AssignBarb
$LN15@AssignBarb:

; 2006 : 		case AI_TACTICAL_BARBARIAN_MOVE_TO_SAFETY:
; 2007 : 			PlotMovesToSafety(true /*bCombatUnits*/);

	push	1
	mov	ecx, esi
	call	?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z ; CvTacticalAI::PlotMovesToSafety

; 2008 : 			break;

	jmp	$LN24@AssignBarb
$LN14@AssignBarb:

; 2009 : 		case AI_TACTICAL_BARBARIAN_ATTRIT_HIGH_PRIORITY_UNIT:
; 2010 : 			PlotDestroyUnitMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT, false);

	push	0
	push	0
	push	7
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 2011 : 			break;

	jmp	$LN24@AssignBarb
$LN13@AssignBarb:

; 2012 : 		case AI_TACTICAL_BARBARIAN_ATTRIT_MEDIUM_PRIORITY_UNIT:
; 2013 : 			PlotDestroyUnitMoves(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT, false);

	push	0
	push	0
	push	6
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 2014 : 			break;

	jmp	$LN24@AssignBarb
$LN12@AssignBarb:

; 2015 : 		case AI_TACTICAL_BARBARIAN_ATTRIT_LOW_PRIORITY_UNIT:
; 2016 : 			PlotDestroyUnitMoves(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT, false);

	push	0
	push	0
	push	5
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 2017 : 			break;

	jmp	$LN24@AssignBarb
$LN11@AssignBarb:

; 2018 : 		case AI_TACTICAL_BARBARIAN_PILLAGE:
; 2019 : 			PlotPillageMoves(AI_TACTICAL_TARGET_IMPROVEMENT_RESOURCE, true/*bFirstPass*/);

	push	1
	push	24					; 00000018H
	mov	ecx, esi
	call	?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z ; CvTacticalAI::PlotPillageMoves

; 2020 : 			break;

	jmp	$LN24@AssignBarb
$LN10@AssignBarb:

; 2021 : 		case AI_TACTICAL_BARBARIAN_PILLAGE_CITADEL:
; 2022 : 			PlotPillageMoves(AI_TACTICAL_TARGET_CITADEL, true/*bFirstPass*/);

	push	1
	push	23					; 00000017H
	mov	ecx, esi
	call	?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z ; CvTacticalAI::PlotPillageMoves

; 2023 : 			break;

	jmp	$LN24@AssignBarb
$LN9@AssignBarb:

; 2024 : 		case AI_TACTICAL_BARBARIAN_PILLAGE_NEXT_TURN:
; 2025 : 			PlotPillageMoves(AI_TACTICAL_TARGET_CITADEL, false/*bFirstPass*/);

	push	0
	push	23					; 00000017H
	mov	ecx, esi
	call	?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z ; CvTacticalAI::PlotPillageMoves

; 2026 : 			PlotPillageMoves(AI_TACTICAL_TARGET_IMPROVEMENT_RESOURCE, false/*bFirstPass*/);

	push	0
	push	24					; 00000018H
	mov	ecx, esi
	call	?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z ; CvTacticalAI::PlotPillageMoves

; 2027 : 			break;

	jmp	SHORT $LN24@AssignBarb
$LN7@AssignBarb:

; 2028 : 		case AI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE:
; 2029 : //			PlotBlockadeImprovementMoves();
; 2030 : 			break;
; 2031 : 		case AI_TACTICAL_BARBARIAN_CIVILIAN_ATTACK:
; 2032 : 			PlotCivilianAttackMoves(AI_TACTICAL_TARGET_VERY_HIGH_PRIORITY_CIVILIAN);

	push	15					; 0000000fH
	mov	ecx, esi
	call	?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z ; CvTacticalAI::PlotCivilianAttackMoves

; 2033 : 			PlotCivilianAttackMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_CIVILIAN);

	push	16					; 00000010H
	mov	ecx, esi
	call	?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z ; CvTacticalAI::PlotCivilianAttackMoves

; 2034 : 			PlotCivilianAttackMoves(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_CIVILIAN);

	push	17					; 00000011H
	mov	ecx, esi
	call	?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z ; CvTacticalAI::PlotCivilianAttackMoves

; 2035 : 			PlotCivilianAttackMoves(AI_TACTICAL_TARGET_LOW_PRIORITY_CIVILIAN);

	push	18					; 00000012H
	mov	ecx, esi
	call	?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z ; CvTacticalAI::PlotCivilianAttackMoves

; 2036 : 			break;

	jmp	SHORT $LN24@AssignBarb
$LN6@AssignBarb:

; 2037 : 		case AI_TACTICAL_BARBARIAN_CAMP_DEFENSE:
; 2038 : 			PlotCampDefenseMoves();

	mov	ecx, esi
	call	?PlotCampDefenseMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotCampDefenseMoves

; 2039 : 			break;

	jmp	SHORT $LN24@AssignBarb
$LN5@AssignBarb:

; 2040 : 		case AI_TACTICAL_BARBARIAN_AGGRESSIVE_MOVE:
; 2041 : 			PlotBarbarianMove(true /*bAggressive*/);

	push	1
	mov	ecx, esi
	call	?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z ; CvTacticalAI::PlotBarbarianMove

; 2042 : 			break;

	jmp	SHORT $LN24@AssignBarb
$LN4@AssignBarb:

; 2043 : 		case AI_TACTICAL_BARBARIAN_PASSIVE_MOVE:
; 2044 : 			PlotBarbarianMove(false /*bAggressive*/);

	push	0
	mov	ecx, esi
	call	?PlotBarbarianMove@CvTacticalAI@@AAEX_N@Z ; CvTacticalAI::PlotBarbarianMove

; 2045 : 			break;

	jmp	SHORT $LN24@AssignBarb
$LN3@AssignBarb:

; 2046 : 		case AI_TACTICAL_BARBARIAN_DESPERATE_ATTACK:
; 2047 : 			PlotDestroyUnitMoves(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT, false, true);

	push	1
	push	0
	push	5
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 2048 : 			break;

	jmp	SHORT $LN24@AssignBarb
$LN2@AssignBarb:

; 2049 : 		case AI_TACTICAL_BARBARIAN_ESCORT_CIVILIAN:
; 2050 : 			PlotBarbarianCivilianEscortMove();

	mov	ecx, esi
	call	?PlotBarbarianCivilianEscortMove@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotBarbarianCivilianEscortMove

; 2051 : 			break;

	jmp	SHORT $LN24@AssignBarb
$LN1@AssignBarb:

; 2052 : 		case AI_TACTICAL_BARBARIAN_PLUNDER_TRADE_UNIT:
; 2053 : 			PlotBarbarianPlunderTradeUnitMove(DOMAIN_LAND);

	push	2
	mov	ecx, esi
	call	?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z ; CvTacticalAI::PlotBarbarianPlunderTradeUnitMove

; 2054 : 			PlotBarbarianPlunderTradeUnitMove(DOMAIN_SEA);

	push	0
	mov	ecx, esi
	call	?PlotBarbarianPlunderTradeUnitMove@CvTacticalAI@@AAEXW4DomainTypes@@@Z ; CvTacticalAI::PlotBarbarianPlunderTradeUnitMove
$LN24@AssignBarb:
	mov	edx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+68]
	add	edi, 8
	lea	ecx, DWORD PTR [eax+edx*8]
	cmp	edi, ecx
	jne	$LL25@AssignBarb
$LN23@AssignBarb:
	pop	edi

; 2055 : 			break;
; 2056 : 		}
; 2057 : 	}
; 2058 : 
; 2059 : 	ReviewUnassignedUnits();

	mov	ecx, esi
	pop	esi

; 2060 : }

	add	esp, 8

; 2055 : 			break;
; 2056 : 		}
; 2057 : 	}
; 2058 : 
; 2059 : 	ReviewUnassignedUnits();

	jmp	?ReviewUnassignedUnits@CvTacticalAI@@AAEXXZ ; CvTacticalAI::ReviewUnassignedUnits
	npad	2
$LN36@AssignBarb:

; 2060 : }

	DD	$LN20@AssignBarb
	DD	$LN19@AssignBarb
	DD	$LN18@AssignBarb
	DD	$LN17@AssignBarb
	DD	$LN16@AssignBarb
	DD	$LN15@AssignBarb
	DD	$LN14@AssignBarb
	DD	$LN13@AssignBarb
	DD	$LN12@AssignBarb
	DD	$LN11@AssignBarb
	DD	$LN24@AssignBarb
	DD	$LN7@AssignBarb
	DD	$LN5@AssignBarb
	DD	$LN4@AssignBarb
	DD	$LN6@AssignBarb
	DD	$LN3@AssignBarb
	DD	$LN2@AssignBarb
	DD	$LN1@AssignBarb
	DD	$LN10@AssignBarb
	DD	$LN9@AssignBarb
?AssignBarbarianMoves@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::AssignBarbarianMoves
_TEXT	ENDS
PUBLIC	?PlotSafeBombardMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotSafeBombardMoves
EXTRN	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z:PROC ; CvTacticalAnalysisMap::SetTargetBombardCells
EXTRN	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ:PROC ; CvTacticalAnalysisMap::ClearDynamicFlags
; Function compile flags: /Ogtpy
;	COMDAT ?PlotSafeBombardMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PlotSafeBombardMoves@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::PlotSafeBombardMoves, COMDAT
; _this$ = ecx

; 2862 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 2863 : 	CvTacticalTarget* pTarget;
; 2864 : 
; 2865 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT);

	push	7
	mov	DWORD PTR _this$[esp+24], esi
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	ebp, eax

; 2866 : 	while(pTarget != NULL && pTarget->IsTargetStillAlive(m_pPlayer->GetID()))

	test	ebp, ebp
	je	$LN7@PlotSafeBo
	npad	4
$LL8@PlotSafeBo:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, ebp
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	$LN7@PlotSafeBo

; 2867 : 	{
; 2868 : 		m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [esi+4]
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 2869 : 		CvPlot* pTargetPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [ebp+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN21@PlotSafeBo
	cmp	ebx, -2147483647			; 80000001H
	je	$LN21@PlotSafeBo
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN31@PlotSafeBo
	test	eax, eax
	jge	SHORT $LN33@PlotSafeBo
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN35@PlotSafeBo
$LN33@PlotSafeBo:
	cmp	eax, ecx
	jl	SHORT $LN31@PlotSafeBo
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN35@PlotSafeBo
$LN31@PlotSafeBo:
	mov	esi, eax
$LN35@PlotSafeBo:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [eax+4057], 0
	mov	edi, DWORD PTR [eax+4024]
	je	SHORT $LN231@PlotSafeBo
	test	ebx, ebx
	jge	SHORT $LN43@PlotSafeBo
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN45@PlotSafeBo
$LN43@PlotSafeBo:
	cmp	ebx, edi
	jl	SHORT $LN231@PlotSafeBo
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN45@PlotSafeBo
$LN231@PlotSafeBo:
	mov	edx, ebx
$LN45@PlotSafeBo:
	test	esi, esi
	jl	SHORT $LN25@PlotSafeBo
	cmp	esi, ecx
	jge	SHORT $LN25@PlotSafeBo
	test	edx, edx
	jl	SHORT $LN25@PlotSafeBo
	cmp	edx, edi
	jge	SHORT $LN25@PlotSafeBo
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	mov	esi, DWORD PTR _this$[esp+20]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN23@PlotSafeBo
$LN25@PlotSafeBo:
	mov	esi, DWORD PTR _this$[esp+20]
$LN21@PlotSafeBo:
	xor	ecx, ecx
$LN23@PlotSafeBo:

; 2870 : 		m_pMap->SetTargetBombardCells(pTargetPlot, m_pMap->GetBestFriendlyRange(), m_pMap->CanIgnoreLOS());

	mov	eax, DWORD PTR [esi+4]
	movzx	edx, BYTE PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR [eax+28]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells

; 2871 : 
; 2872 : 		ExecuteSafeBombards(*pTarget);

	push	ebp
	mov	ecx, esi
	call	?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteSafeBombards

; 2873 : 		pTarget = GetNextZoneTarget();

	mov	ecx, esi
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL8@PlotSafeBo
$LN7@PlotSafeBo:

; 2874 : 	}
; 2875 : 
; 2876 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT);

	push	6
	mov	ecx, esi
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	ebp, eax

; 2877 : 	while(pTarget != NULL && pTarget->IsTargetStillAlive(m_pPlayer->GetID()))

	test	ebp, ebp
	je	$LN5@PlotSafeBo
	npad	6
$LL6@PlotSafeBo:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, ebp
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	$LN5@PlotSafeBo

; 2878 : 	{
; 2879 : 		m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [esi+4]
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 2880 : 		CvPlot* pTargetPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [ebp+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN73@PlotSafeBo
	cmp	ebx, -2147483647			; 80000001H
	je	$LN73@PlotSafeBo
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN83@PlotSafeBo
	test	eax, eax
	jge	SHORT $LN85@PlotSafeBo
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esi, ecx
	jmp	SHORT $LN87@PlotSafeBo
$LN85@PlotSafeBo:
	cmp	eax, ecx
	jl	SHORT $LN83@PlotSafeBo
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN87@PlotSafeBo
$LN83@PlotSafeBo:
	mov	esi, eax
$LN87@PlotSafeBo:
	cmp	BYTE PTR [edx+4057], 0
	mov	edi, DWORD PTR [edx+4024]
	je	SHORT $LN233@PlotSafeBo
	test	ebx, ebx
	jge	SHORT $LN95@PlotSafeBo
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN97@PlotSafeBo
$LN95@PlotSafeBo:
	cmp	ebx, edi
	jl	SHORT $LN233@PlotSafeBo
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN97@PlotSafeBo
$LN233@PlotSafeBo:
	mov	edx, ebx
$LN97@PlotSafeBo:
	test	esi, esi
	jl	SHORT $LN73@PlotSafeBo
	cmp	esi, ecx
	jge	SHORT $LN73@PlotSafeBo
	test	edx, edx
	jl	SHORT $LN73@PlotSafeBo
	cmp	edx, edi
	jge	SHORT $LN73@PlotSafeBo
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN75@PlotSafeBo
$LN73@PlotSafeBo:
	xor	ecx, ecx
$LN75@PlotSafeBo:

; 2881 : 		m_pMap->SetTargetBombardCells(pTargetPlot, m_pMap->GetBestFriendlyRange(), m_pMap->CanIgnoreLOS());

	mov	esi, DWORD PTR _this$[esp+20]
	mov	eax, DWORD PTR [esi+4]
	movzx	edx, BYTE PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR [eax+28]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells

; 2882 : 
; 2883 : 		ExecuteSafeBombards(*pTarget);

	push	ebp
	mov	ecx, esi
	call	?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteSafeBombards

; 2884 : 		pTarget = GetNextZoneTarget();

	mov	ecx, esi
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL6@PlotSafeBo
$LN5@PlotSafeBo:

; 2885 : 	}
; 2886 : 
; 2887 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT);

	push	5
	mov	ecx, esi
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	ebp, eax

; 2888 : 	while(pTarget != NULL && pTarget->IsTargetStillAlive(m_pPlayer->GetID()))

	test	ebp, ebp
	je	$LN3@PlotSafeBo
	npad	3
$LL4@PlotSafeBo:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, ebp
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	$LN3@PlotSafeBo

; 2889 : 	{
; 2890 : 		m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [esi+4]
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 2891 : 		CvPlot* pTargetPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [ebp+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN125@PlotSafeBo
	cmp	ebx, -2147483647			; 80000001H
	je	$LN125@PlotSafeBo
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN135@PlotSafeBo
	test	eax, eax
	jge	SHORT $LN137@PlotSafeBo
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esi, ecx
	jmp	SHORT $LN139@PlotSafeBo
$LN137@PlotSafeBo:
	cmp	eax, ecx
	jl	SHORT $LN135@PlotSafeBo
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN139@PlotSafeBo
$LN135@PlotSafeBo:
	mov	esi, eax
$LN139@PlotSafeBo:
	cmp	BYTE PTR [edx+4057], 0
	mov	edi, DWORD PTR [edx+4024]
	je	SHORT $LN235@PlotSafeBo
	test	ebx, ebx
	jge	SHORT $LN147@PlotSafeBo
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN149@PlotSafeBo
$LN147@PlotSafeBo:
	cmp	ebx, edi
	jl	SHORT $LN235@PlotSafeBo
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN149@PlotSafeBo
$LN235@PlotSafeBo:
	mov	edx, ebx
$LN149@PlotSafeBo:
	test	esi, esi
	jl	SHORT $LN125@PlotSafeBo
	cmp	esi, ecx
	jge	SHORT $LN125@PlotSafeBo
	test	edx, edx
	jl	SHORT $LN125@PlotSafeBo
	cmp	edx, edi
	jge	SHORT $LN125@PlotSafeBo
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN127@PlotSafeBo
$LN125@PlotSafeBo:
	xor	ecx, ecx
$LN127@PlotSafeBo:

; 2892 : 		m_pMap->SetTargetBombardCells(pTargetPlot, m_pMap->GetBestFriendlyRange(), m_pMap->CanIgnoreLOS());

	mov	esi, DWORD PTR _this$[esp+20]
	mov	eax, DWORD PTR [esi+4]
	movzx	edx, BYTE PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR [eax+28]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells

; 2893 : 
; 2894 : 		ExecuteSafeBombards(*pTarget);

	push	ebp
	mov	ecx, esi
	call	?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteSafeBombards

; 2895 : 		pTarget = GetNextZoneTarget();

	mov	ecx, esi
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL4@PlotSafeBo
$LN3@PlotSafeBo:

; 2896 : 	}
; 2897 : 
; 2898 : 	pTarget = GetFirstZoneTarget(AI_TACTICAL_TARGET_EMBARKED_MILITARY_UNIT);

	push	13					; 0000000dH
	mov	ecx, esi
	call	?GetFirstZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@W4AITacticalTargetType@@@Z ; CvTacticalAI::GetFirstZoneTarget
	mov	ebp, eax

; 2899 : 	while(pTarget != NULL && pTarget->IsTargetStillAlive(m_pPlayer->GetID()))

	test	ebp, ebp
	je	$LN1@PlotSafeBo
	jmp	SHORT $LN2@PlotSafeBo
	npad	1
$LL236@PlotSafeBo:
	mov	esi, ecx
$LN2@PlotSafeBo:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, ebp
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	$LN1@PlotSafeBo

; 2900 : 	{
; 2901 : 		m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [esi+4]
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 2902 : 		CvPlot* pTargetPlot = GC.getMap().plot(pTarget->GetTargetX(), pTarget->GetTargetY());

	mov	eax, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [ebp+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN177@PlotSafeBo
	cmp	ebx, -2147483647			; 80000001H
	je	$LN177@PlotSafeBo
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN187@PlotSafeBo
	test	eax, eax
	jge	SHORT $LN189@PlotSafeBo
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esi, ecx
	jmp	SHORT $LN191@PlotSafeBo
$LN189@PlotSafeBo:
	cmp	eax, ecx
	jl	SHORT $LN187@PlotSafeBo
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN191@PlotSafeBo
$LN187@PlotSafeBo:
	mov	esi, eax
$LN191@PlotSafeBo:
	cmp	BYTE PTR [edx+4057], 0
	mov	edi, DWORD PTR [edx+4024]
	je	SHORT $LN237@PlotSafeBo
	test	ebx, ebx
	jge	SHORT $LN199@PlotSafeBo
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN201@PlotSafeBo
$LN199@PlotSafeBo:
	cmp	ebx, edi
	jl	SHORT $LN237@PlotSafeBo
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN201@PlotSafeBo
$LN237@PlotSafeBo:
	mov	edx, ebx
$LN201@PlotSafeBo:
	test	esi, esi
	jl	SHORT $LN177@PlotSafeBo
	cmp	esi, ecx
	jge	SHORT $LN177@PlotSafeBo
	test	edx, edx
	jl	SHORT $LN177@PlotSafeBo
	cmp	edx, edi
	jge	SHORT $LN177@PlotSafeBo
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN179@PlotSafeBo
$LN177@PlotSafeBo:
	xor	ecx, ecx
$LN179@PlotSafeBo:

; 2903 : 		m_pMap->SetTargetBombardCells(pTargetPlot, m_pMap->GetBestFriendlyRange(), m_pMap->CanIgnoreLOS());

	mov	esi, DWORD PTR _this$[esp+20]
	mov	eax, DWORD PTR [esi+4]
	movzx	edx, BYTE PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR [eax+28]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells

; 2904 : 
; 2905 : 		ExecuteSafeBombards(*pTarget);

	push	ebp
	mov	ecx, esi
	call	?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteSafeBombards

; 2906 : 		pTarget = GetNextZoneTarget();

	mov	ecx, esi
	call	?GetNextZoneTarget@CvTacticalAI@@AAEPAVCvTacticalTarget@@XZ ; CvTacticalAI::GetNextZoneTarget
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL236@PlotSafeBo
$LN1@PlotSafeBo:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2907 : 	}
; 2908 : }

	pop	ecx
	ret	0
?PlotSafeBombardMoves@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::PlotSafeBombardMoves
_TEXT	ENDS
PUBLIC	?PlotExploitFlanksMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotExploitFlanksMoves
EXTRN	?SetTargetFlankBonusCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@@Z:PROC ; CvTacticalAnalysisMap::SetTargetFlankBonusCells
; Function compile flags: /Ogtpy
;	COMDAT ?PlotExploitFlanksMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
tv504 = -8						; size = 4
_iI$222002 = -4						; size = 4
?PlotExploitFlanksMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotExploitFlanksMoves, COMDAT
; _this$ = ecx

; 3500 : {

	sub	esp, 8
	push	ebx
	push	ebp

; 3501 : 	CvPlot* pTarget;
; 3502 : 	bool bAttackUnderway = false;
; 3503 : 	bool bAttackMade;
; 3504 : 
; 3505 : 	m_TempTargets.clear();

	xor	ebp, ebp
	mov	ebx, ecx
	mov	DWORD PTR [ebx+23708], ebp

; 3506 : 
; 3507 : 	// Loop through unit targets finding attack for this turn
; 3508 : #ifdef AUI_ITERATORIZE
; 3509 : 	for (TacticalList::iterator it = m_ZoneTargets.begin(); it != m_ZoneTargets.end(); ++it)
; 3510 : 	{
; 3511 : 		if (it->GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 3512 : 			it->GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 3513 : 			it->GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)
; 3514 : 		{
; 3515 : 			m_pMap->ClearDynamicFlags();
; 3516 : 			pTarget = GC.getMap().plot(it->GetTargetX(), it->GetTargetY());
; 3517 : 			m_pMap->SetTargetFlankBonusCells(pTarget);
; 3518 : 
; 3519 : 			bAttackMade = ExecuteFlankAttack(*it);
; 3520 : 			if (bAttackMade)
; 3521 : 			{
; 3522 : 				bAttackUnderway = true;
; 3523 : 			}
; 3524 : 
; 3525 : 			// No attack, see if we can set one up on this target later
; 3526 : 			else
; 3527 : 			{
; 3528 : 				m_TempTargets.push_back(*it);
; 3529 : #else
; 3530 : 	for(unsigned int iI = 0; iI < m_ZoneTargets.size(); iI++)

	mov	DWORD PTR _iI$222002[esp+16], ebp
	cmp	DWORD PTR [ebx+9340], ebp
	jbe	$LN5@PlotExploi
	push	esi
	mov	DWORD PTR tv504[esp+20], ebp
	push	edi
	npad	11
$LL96@PlotExploi:

; 3531 : 	{
; 3532 : 		if(m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 3533 : 		        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 3534 : 		        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	mov	eax, DWORD PTR [ebx+9336]
	mov	eax, DWORD PTR [eax+ebp]
	cmp	eax, 7
	je	SHORT $LN3@PlotExploi
	cmp	eax, 6
	je	SHORT $LN3@PlotExploi
	cmp	eax, 5
	jne	$LN6@PlotExploi
$LN3@PlotExploi:

; 3535 : 		{
; 3536 : 			m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [ebx+4]
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 3537 : 			pTarget = GC.getMap().plot(m_ZoneTargets[iI].GetTargetX(), m_ZoneTargets[iI].GetTargetY());

	mov	ecx, DWORD PTR [ebx+9336]
	mov	edi, DWORD PTR [ecx+ebp+8]
	lea	eax, DWORD PTR [ecx+ebp]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN42@PlotExploi
	cmp	edi, -2147483647			; 80000001H
	je	$LN42@PlotExploi
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN52@PlotExploi
	test	eax, eax
	jge	SHORT $LN54@PlotExploi
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esi, ecx
	jmp	SHORT $LN56@PlotExploi
$LN54@PlotExploi:
	cmp	eax, ecx
	jl	SHORT $LN52@PlotExploi
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN56@PlotExploi
$LN52@PlotExploi:
	mov	esi, eax
$LN56@PlotExploi:
	cmp	BYTE PTR [edx+4057], 0
	mov	ebp, DWORD PTR [edx+4024]
	je	SHORT $LN95@PlotExploi
	test	edi, edi
	jge	SHORT $LN64@PlotExploi
	mov	eax, edi
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN66@PlotExploi
$LN64@PlotExploi:
	cmp	edi, ebp
	jl	SHORT $LN95@PlotExploi
	mov	eax, edi
	cdq
	idiv	ebp
	jmp	SHORT $LN66@PlotExploi
$LN95@PlotExploi:
	mov	edx, edi
$LN66@PlotExploi:
	test	esi, esi
	jl	SHORT $LN46@PlotExploi
	cmp	esi, ecx
	jge	SHORT $LN46@PlotExploi
	test	edx, edx
	jl	SHORT $LN46@PlotExploi
	cmp	edx, ebp
	jge	SHORT $LN46@PlotExploi
	mov	ebp, DWORD PTR tv504[esp+24]
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN44@PlotExploi
$LN46@PlotExploi:
	mov	ebp, DWORD PTR tv504[esp+24]
$LN42@PlotExploi:
	xor	ecx, ecx
$LN44@PlotExploi:

; 3538 : 			m_pMap->SetTargetFlankBonusCells(pTarget);

	push	ecx
	mov	ecx, DWORD PTR [ebx+4]
	call	?SetTargetFlankBonusCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@@Z ; CvTacticalAnalysisMap::SetTargetFlankBonusCells

; 3539 : 
; 3540 : 			bAttackMade = ExecuteFlankAttack(m_ZoneTargets[iI]);

	mov	eax, DWORD PTR [ebx+9336]
	add	eax, ebp
	push	eax
	mov	ecx, ebx
	call	?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteFlankAttack

; 3541 : 			if(bAttackMade)

	test	al, al
	jne	SHORT $LN6@PlotExploi

; 3542 : 			{
; 3543 : 				bAttackUnderway = true;
; 3544 : 			}
; 3545 : 
; 3546 : 			// No attack, see if we can set one up on this target later
; 3547 : 			else
; 3548 : 			{
; 3549 : 				m_TempTargets.push_back(m_ZoneTargets[iI]);

	mov	esi, DWORD PTR [ebx+9336]
	add	esi, ebp
	lea	ebp, DWORD PTR [ebx+23704]
	mov	BYTE PTR [ebp+1048], al
	mov	eax, DWORD PTR [ebp+8]
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN84@PlotExploi
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::GrowSize
$LN84@PlotExploi:
	mov	eax, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	je	SHORT $LN87@PlotExploi
	mov	ecx, 7
	mov	edi, eax
	rep movsd
$LN87@PlotExploi:
	inc	DWORD PTR [ebp+4]
	mov	ebp, DWORD PTR tv504[esp+24]
$LN6@PlotExploi:
	mov	eax, DWORD PTR _iI$222002[esp+24]
	inc	eax
	add	ebp, 28					; 0000001cH
	mov	DWORD PTR _iI$222002[esp+24], eax
	mov	DWORD PTR tv504[esp+24], ebp
	cmp	eax, DWORD PTR [ebx+9340]
	jb	$LL96@PlotExploi
	pop	edi
	pop	esi
$LN5@PlotExploi:
	pop	ebp
	pop	ebx

; 3550 : #endif
; 3551 : 			}
; 3552 : 		}
; 3553 : 	}
; 3554 : }

	add	esp, 8
	ret	0
?PlotExploitFlanksMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotExploitFlanksMoves
_TEXT	ENDS
PUBLIC	?PlotShoreBombardmentMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotShoreBombardmentMoves
; Function compile flags: /Ogtpy
;	COMDAT ?PlotShoreBombardmentMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
tv805 = -8						; size = 4
tv774 = -8						; size = 4
_iI$222113 = -4						; size = 4
_iI$222106 = -4						; size = 4
?PlotShoreBombardmentMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotShoreBombardmentMoves, COMDAT
; _this$ = ecx

; 3785 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3786 : 	CvPlot* pTarget;
; 3787 : 
; 3788 : 	for(unsigned int iI = 0; iI < m_ZoneTargets.size(); iI++)

	xor	edi, edi
	mov	esi, ecx
	mov	DWORD PTR _iI$222106[esp+24], edi
	cmp	DWORD PTR [esi+9340], edi
	jbe	$LN9@PlotShoreB
	mov	DWORD PTR tv774[esp+24], edi
	npad	1
$LL162@PlotShoreB:

; 3789 : 	{
; 3790 : 		// Is the target of an appropriate type?
; 3791 : 		if(m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 3792 : 		        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 3793 : 		        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	mov	eax, DWORD PTR [esi+9336]
	lea	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 7
	je	SHORT $LN7@PlotShoreB
	cmp	eax, 6
	je	SHORT $LN7@PlotShoreB
	cmp	eax, 5
	jne	$LN10@PlotShoreB
$LN7@PlotShoreB:

; 3794 : 		{
; 3795 : 			if(m_ZoneTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	$LN10@PlotShoreB

; 3796 : 			{
; 3797 : 				m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [esi+4]
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 3798 : 				pTarget = GC.getMap().plot(m_ZoneTargets[iI].GetTargetX(), m_ZoneTargets[iI].GetTargetY());

	mov	eax, DWORD PTR [esi+9336]
	mov	ebp, DWORD PTR [eax+edi+8]
	add	eax, edi
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN44@PlotShoreB
	cmp	ebp, -2147483647			; 80000001H
	je	$LN44@PlotShoreB
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN54@PlotShoreB
	test	eax, eax
	jge	SHORT $LN56@PlotShoreB
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	edi, ecx
	jmp	SHORT $LN58@PlotShoreB
$LN56@PlotShoreB:
	cmp	eax, ecx
	jl	SHORT $LN54@PlotShoreB
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN58@PlotShoreB
$LN54@PlotShoreB:
	mov	edi, eax
$LN58@PlotShoreB:
	cmp	BYTE PTR [edx+4057], 0
	mov	ebx, DWORD PTR [edx+4024]
	je	SHORT $LN161@PlotShoreB
	test	ebp, ebp
	jge	SHORT $LN66@PlotShoreB
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN68@PlotShoreB
$LN66@PlotShoreB:
	cmp	ebp, ebx
	jl	SHORT $LN161@PlotShoreB
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN68@PlotShoreB
$LN161@PlotShoreB:
	mov	edx, ebp
$LN68@PlotShoreB:
	test	edi, edi
	jl	SHORT $LN48@PlotShoreB
	cmp	edi, ecx
	jge	SHORT $LN48@PlotShoreB
	test	edx, edx
	jl	SHORT $LN48@PlotShoreB
	cmp	edx, ebx
	jge	SHORT $LN48@PlotShoreB
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	mov	edi, DWORD PTR tv774[esp+24]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN46@PlotShoreB
$LN48@PlotShoreB:
	mov	edi, DWORD PTR tv774[esp+24]
$LN44@PlotShoreB:
	xor	ecx, ecx
$LN46@PlotShoreB:

; 3799 : 				m_pMap->SetTargetBombardCells(pTarget, m_pMap->GetBestFriendlyRange(), m_pMap->CanIgnoreLOS());

	mov	eax, DWORD PTR [esi+4]
	movzx	edx, BYTE PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR [eax+28]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells

; 3800 : 
; 3801 : 				ExecuteSafeBombards(m_ZoneTargets[iI]);

	mov	eax, DWORD PTR [esi+9336]
	add	eax, edi
	push	eax
	mov	ecx, esi
	call	?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteSafeBombards
$LN10@PlotShoreB:
	mov	eax, DWORD PTR _iI$222106[esp+24]
	inc	eax
	add	edi, 28					; 0000001cH
	mov	DWORD PTR _iI$222106[esp+24], eax
	mov	DWORD PTR tv774[esp+24], edi
	cmp	eax, DWORD PTR [esi+9340]
	jb	$LL162@PlotShoreB
$LN9@PlotShoreB:

; 3802 : 			}
; 3803 : 		}
; 3804 : 	}
; 3805 : 	for(unsigned int iI = 0; iI < m_ZoneTargets.size(); iI++)

	xor	edi, edi
	mov	DWORD PTR _iI$222113[esp+24], edi
	cmp	DWORD PTR [esi+9340], edi
	jbe	$LN3@PlotShoreB
	mov	DWORD PTR tv805[esp+24], edi
	npad	4
$LL163@PlotShoreB:

; 3806 : 	{
; 3807 : 		if(m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_CITY)

	mov	ecx, DWORD PTR [esi+9336]
	add	ecx, edi
	cmp	DWORD PTR [ecx], 1
	jne	$LN4@PlotShoreB

; 3808 : 		{
; 3809 : 			if(m_ZoneTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	$LN4@PlotShoreB

; 3810 : 			{
; 3811 : 				m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [esi+4]
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 3812 : 				pTarget = GC.getMap().plot(m_ZoneTargets[iI].GetTargetX(), m_ZoneTargets[iI].GetTargetY());

	mov	eax, DWORD PTR [esi+9336]
	mov	ebp, DWORD PTR [eax+edi+8]
	add	eax, edi
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN110@PlotShoreB
	cmp	ebp, -2147483647			; 80000001H
	je	$LN110@PlotShoreB
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN120@PlotShoreB
	test	eax, eax
	jge	SHORT $LN122@PlotShoreB
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	edi, ecx
	jmp	SHORT $LN124@PlotShoreB
$LN122@PlotShoreB:
	cmp	eax, ecx
	jl	SHORT $LN120@PlotShoreB
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN124@PlotShoreB
$LN120@PlotShoreB:
	mov	edi, eax
$LN124@PlotShoreB:
	cmp	BYTE PTR [edx+4057], 0
	mov	ebx, DWORD PTR [edx+4024]
	je	SHORT $LN160@PlotShoreB
	test	ebp, ebp
	jge	SHORT $LN132@PlotShoreB
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN134@PlotShoreB
$LN132@PlotShoreB:
	cmp	ebp, ebx
	jl	SHORT $LN160@PlotShoreB
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN134@PlotShoreB
$LN160@PlotShoreB:
	mov	edx, ebp
$LN134@PlotShoreB:
	test	edi, edi
	jl	SHORT $LN114@PlotShoreB
	cmp	edi, ecx
	jge	SHORT $LN114@PlotShoreB
	test	edx, edx
	jl	SHORT $LN114@PlotShoreB
	cmp	edx, ebx
	jge	SHORT $LN114@PlotShoreB
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	mov	edi, DWORD PTR tv805[esp+24]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN112@PlotShoreB
$LN114@PlotShoreB:
	mov	edi, DWORD PTR tv805[esp+24]
$LN110@PlotShoreB:
	xor	ecx, ecx
$LN112@PlotShoreB:

; 3813 : 				m_pMap->SetTargetBombardCells(pTarget, m_pMap->GetBestFriendlyRange(), m_pMap->CanIgnoreLOS());

	mov	eax, DWORD PTR [esi+4]
	movzx	edx, BYTE PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR [eax+28]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells

; 3814 : 
; 3815 : 				ExecuteSafeBombards(m_ZoneTargets[iI]);

	mov	eax, DWORD PTR [esi+9336]
	add	eax, edi
	push	eax
	mov	ecx, esi
	call	?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteSafeBombards
$LN4@PlotShoreB:
	mov	eax, DWORD PTR _iI$222113[esp+24]
	inc	eax
	add	edi, 28					; 0000001cH
	mov	DWORD PTR _iI$222113[esp+24], eax
	mov	DWORD PTR tv805[esp+24], edi
	cmp	eax, DWORD PTR [esi+9340]
	jb	$LL163@PlotShoreB
$LN3@PlotShoreB:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3816 : 			}
; 3817 : 		}
; 3818 : 	}
; 3819 : }

	add	esp, 8
	ret	0
?PlotShoreBombardmentMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotShoreBombardmentMoves
_TEXT	ENDS
PUBLIC	?AssignCoveringUnits@CvTacticalAI@@AAE_NH@Z	; CvTacticalAI::AssignCoveringUnits
; Function compile flags: /Ogtpy
;	COMDAT ?AssignCoveringUnits@CvTacticalAI@@AAE_NH@Z
_TEXT	SEGMENT
tv429 = -24						; size = 4
_jJ$225636 = -20					; size = 4
_iI$225627 = -20					; size = 4
_temp$225631 = -16					; size = 16
_iNumUnitsRequiredToCover$ = 8				; size = 4
?AssignCoveringUnits@CvTacticalAI@@AAE_NH@Z PROC	; CvTacticalAI::AssignCoveringUnits, COMDAT
; _this$ = ecx

; 10201: {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 10202: 	bool bChoseOne = true;
; 10203: 
; 10204: 	m_TemporaryBlocks.clear();

	xor	eax, eax
	mov	DWORD PTR [edi+27016], eax

; 10205: 	m_ChosenBlocks.clear();

	mov	DWORD PTR [edi+27432], eax
	npad	9
$LL13@AssignCove:

; 10208: 	{
; 10209: 		bChoseOne = false;

	xor	cl, cl

; 10210: 		m_NewlyChosen.clear();

	mov	DWORD PTR [edi+28040], eax

; 10211: 
; 10212: 		// Loop through potential blocks looking for assignments we MUST make (only one possibility)
; 10213: #ifdef AUI_ITERATORIZE
; 10214: 		for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>:: const_iterator it = m_PotentialBlocks.begin(); it != m_PotentialBlocks.end(); ++it)
; 10215: 		{
; 10216: 			CvBlockingUnit temp = *it;
; 10217: #else
; 10218: 		for(unsigned int iI = 0; iI < m_PotentialBlocks.size(); iI++)

	mov	DWORD PTR _iI$225627[esp+40], eax
	cmp	DWORD PTR [edi+26600], eax
	jbe	$LN12@AssignCove

; 10208: 	{
; 10209: 		bChoseOne = false;

	mov	DWORD PTR tv429[esp+40], eax
	npad	4
$LL11@AssignCove:

; 10211: 
; 10212: 		// Loop through potential blocks looking for assignments we MUST make (only one possibility)
; 10213: #ifdef AUI_ITERATORIZE
; 10214: 		for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>:: const_iterator it = m_PotentialBlocks.begin(); it != m_PotentialBlocks.end(); ++it)
; 10215: 		{
; 10216: 			CvBlockingUnit temp = *it;
; 10217: #else
; 10218: 		for(unsigned int iI = 0; iI < m_PotentialBlocks.size(); iI++)

	mov	eax, DWORD PTR [edi+26596]
	add	eax, DWORD PTR tv429[esp+40]

; 10219: 		{
; 10220: 			CvBlockingUnit temp = m_PotentialBlocks[iI];

	mov	edx, DWORD PTR [eax+4]
	mov	ebp, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _temp$225631[esp+44], edx
	mov	DWORD PTR _temp$225631[esp+52], eax

; 10221: #endif
; 10222: 
; 10223: 			if(temp.GetNumChoices() == 1)

	cmp	ebp, 1
	jne	SHORT $LN10@AssignCove

; 10224: 			{
; 10225: 				m_NewlyChosen.push_back(temp);

	mov	eax, DWORD PTR [edi+28044]
	lea	esi, DWORD PTR [edi+28036]
	mov	BYTE PTR [esi+604], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN46@AssignCove
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::GrowSize
$LN46@AssignCove:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN49@AssignCove
	mov	ecx, DWORD PTR _temp$225631[esp+44]
	mov	edx, DWORD PTR _temp$225631[esp+52]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], edx
$LN49@AssignCove:
	inc	DWORD PTR [esi+4]

; 10226: 				bChoseOne = true;

	mov	cl, 1
$LN10@AssignCove:
	mov	eax, DWORD PTR _iI$225627[esp+40]
	add	DWORD PTR tv429[esp+40], 16		; 00000010H
	inc	eax
	mov	DWORD PTR _iI$225627[esp+40], eax
	cmp	eax, DWORD PTR [edi+26600]
	jb	SHORT $LL11@AssignCove

; 10227: 			}
; 10228: 		}
; 10229: 
; 10230: 		if(bChoseOne)

	test	cl, cl
	je	$LN12@AssignCove

; 10231: 		{
; 10232: 			// Do we have the same unit in m_NewlyChosen twice?
; 10233: 			if(HaveDuplicateUnit())

	mov	ecx, edi
	call	?HaveDuplicateUnit@CvTacticalAI@@AAE_NXZ ; CvTacticalAI::HaveDuplicateUnit
	test	al, al
	jne	$LN69@AssignCove

; 10236: 			}
; 10237: 			else
; 10238: 			{
; 10239: 				// Copy to final list
; 10240: #ifdef AUI_ITERATORIZE
; 10241: 				for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it = m_NewlyChosen.begin(); it != m_NewlyChosen.end(); ++it)
; 10242: 				{
; 10243: 					m_ChosenBlocks.push_back(*it);
; 10244: #else
; 10245: 				for(unsigned int jJ = 0; jJ < m_NewlyChosen.size(); jJ++)

	xor	ebx, ebx
	mov	DWORD PTR _jJ$225636[esp+40], ebx
	cmp	DWORD PTR [edi+28040], ebx
	jbe	SHORT $LN2@AssignCove
	lea	esi, DWORD PTR [edi+27428]
$LL4@AssignCove:
	mov	ebp, DWORD PTR [edi+28036]

; 10246: 				{
; 10247: 					m_ChosenBlocks.push_back(m_NewlyChosen[jJ]);

	mov	eax, DWORD PTR [esi+8]
	add	ebp, ebx
	mov	BYTE PTR [esi+604], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN57@AssignCove
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::GrowSize
$LN57@AssignCove:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN60@AssignCove
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [ebp+12]
	mov	DWORD PTR [eax+12], edx
$LN60@AssignCove:
	mov	eax, DWORD PTR _jJ$225636[esp+40]
	inc	DWORD PTR [esi+4]
	inc	eax
	add	ebx, 16					; 00000010H
	mov	DWORD PTR _jJ$225636[esp+40], eax
	cmp	eax, DWORD PTR [edi+28040]
	jb	SHORT $LL4@AssignCove
$LN2@AssignCove:

; 10248: #endif
; 10249: 				}
; 10250: 
; 10251: 				RemoveChosenUnits();

	push	0
	mov	ecx, edi
	call	?RemoveChosenUnits@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::RemoveChosenUnits

; 10252: 
; 10253: 				// Do we have enough units left to cover everything?
; 10254: 				if(NumUniqueUnitsLeft() < (iNumUnitsRequiredToCover - (int)m_ChosenBlocks.size()))

	mov	esi, DWORD PTR [edi+27432]
	mov	ecx, edi
	call	?NumUniqueUnitsLeft@CvTacticalAI@@AAEHXZ ; CvTacticalAI::NumUniqueUnitsLeft
	mov	ecx, DWORD PTR _iNumUnitsRequiredToCover$[esp+36]
	sub	ecx, esi
	cmp	eax, ecx
	jl	SHORT $LN69@AssignCove

; 10206: 
; 10207: 	while(bChoseOne)

	xor	eax, eax
	jmp	$LL13@AssignCove
$LN69@AssignCove:
	pop	edi
	pop	esi
	pop	ebp

; 10234: 			{
; 10235: 				return false;   // Not going to work

	xor	al, al
	pop	ebx

; 10263: }

	add	esp, 24					; 00000018H
	ret	4
$LN12@AssignCove:

; 10255: 				{
; 10256: 					return false;
; 10257: 				}
; 10258: 			}
; 10259: 		}
; 10260: 	}
; 10261: 
; 10262: 	return ChooseRemainingAssignments(iNumUnitsRequiredToCover, iNumUnitsRequiredToCover);

	mov	eax, DWORD PTR _iNumUnitsRequiredToCover$[esp+36]
	push	eax
	push	eax
	mov	ecx, edi
	call	?ChooseRemainingAssignments@CvTacticalAI@@AAE_NHH@Z ; CvTacticalAI::ChooseRemainingAssignments
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10263: }

	add	esp, 24					; 00000018H
	ret	4
?AssignCoveringUnits@CvTacticalAI@@AAE_NH@Z ENDP	; CvTacticalAI::AssignCoveringUnits
_TEXT	ENDS
PUBLIC	?AssignDeployingUnits@CvTacticalAI@@AAE_NH@Z	; CvTacticalAI::AssignDeployingUnits
; Function compile flags: /Ogtpy
;	COMDAT ?AssignDeployingUnits@CvTacticalAI@@AAE_NH@Z
_TEXT	SEGMENT
_bRtnValue$ = -5					; size = 1
_jJ$225663 = -4						; size = 4
_iI$225655 = -4						; size = 4
_iNumUnitsRequiredToDeploy$ = 8				; size = 4
?AssignDeployingUnits@CvTacticalAI@@AAE_NH@Z PROC	; CvTacticalAI::AssignDeployingUnits, COMDAT
; _this$ = ecx

; 10276: {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 10277: 	bool bChoseOne = true;
; 10278: 	bool bRtnValue = true;
; 10279: 
; 10280: 	m_TemporaryBlocks.clear();

	xor	eax, eax
	mov	DWORD PTR [esi+27016], eax
	push	edi
	mov	BYTE PTR _bRtnValue$[esp+24], 1

; 10281: 	m_ChosenBlocks.clear();

	mov	DWORD PTR [esi+27432], eax
	npad	4
$LL16@AssignDepl:

; 10285: 	{
; 10286: 		bChoseOne = false;
; 10287: 		m_NewlyChosen.clear();

	xor	ebx, ebx
	xor	al, al
	mov	DWORD PTR [esi+28040], ebx

; 10288: 
; 10289: #ifdef AUI_ITERATORIZE
; 10290: 		for (FStaticVector<CvBlockingUnit, SAFE_ESTIMATE_NUM_BLOCKING_UNITS, true, c_eCiv5GameplayDLL, 0>::const_iterator it = m_PotentialBlocks.begin(); it != m_PotentialBlocks.end(); ++it)
; 10291: 		{
; 10292: 			if (it->GetNumChoices() == 1)
; 10293: 			{
; 10294: 				m_NewlyChosen.push_back(*it);
; 10295: #else
; 10296: 		for(unsigned int iI = 0; iI < m_PotentialBlocks.size(); iI++)

	mov	DWORD PTR _iI$225655[esp+24], ebx
	cmp	DWORD PTR [esi+26600], ebx
	jbe	$LN2@AssignDepl
	npad	6
$LL14@AssignDepl:

; 10297: 		{
; 10298: 			if(m_PotentialBlocks[iI].GetNumChoices() == 1)

	mov	ecx, DWORD PTR [esi+26596]
	cmp	DWORD PTR [ecx+ebx+8], 1
	lea	ebp, DWORD PTR [ecx+ebx]
	jne	SHORT $LN13@AssignDepl

; 10299: 			{
; 10300: 				m_NewlyChosen.push_back(m_PotentialBlocks[iI]);

	mov	eax, DWORD PTR [esi+28044]
	lea	edi, DWORD PTR [esi+28036]
	mov	BYTE PTR [edi+604], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN51@AssignDepl
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::GrowSize
$LN51@AssignDepl:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN54@AssignDepl
	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR [eax+12], ecx
$LN54@AssignDepl:
	inc	DWORD PTR [edi+4]

; 10301: #endif
; 10302: 				bChoseOne = true;

	mov	al, 1
$LN13@AssignDepl:
	mov	ecx, DWORD PTR _iI$225655[esp+24]
	inc	ecx
	add	ebx, 16					; 00000010H
	mov	DWORD PTR _iI$225655[esp+24], ecx
	cmp	ecx, DWORD PTR [esi+26600]
	jb	SHORT $LL14@AssignDepl

; 10303: 			}
; 10304: 		}
; 10305: 
; 10306: 		if(bChoseOne)

	test	al, al
	je	$LN116@AssignDepl

; 10307: 		{
; 10308: 			// Do we have the same unit in m_NewlyChosen twice?
; 10309: 			if(HaveDuplicateUnit())

	mov	ecx, esi
	call	?HaveDuplicateUnit@CvTacticalAI@@AAE_NXZ ; CvTacticalAI::HaveDuplicateUnit
	test	al, al
	jne	$LN109@AssignDepl

; 10312: 			}
; 10313: 			else
; 10314: 			{
; 10315: 				// Copy to final list
; 10316: #ifdef AUI_ITERATORIZE
; 10317: 				for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it = m_NewlyChosen.begin(); it != m_NewlyChosen.end(); ++it)
; 10318: 				{
; 10319: 					m_ChosenBlocks.push_back(*it);
; 10320: #else
; 10321: 				for(unsigned int jJ = 0; jJ < m_NewlyChosen.size(); jJ++)

	xor	ebx, ebx
	mov	DWORD PTR _jJ$225663[esp+24], ebx
	cmp	DWORD PTR [esi+28040], ebx
	jbe	SHORT $LN5@AssignDepl
	lea	edi, DWORD PTR [esi+27428]
$LL7@AssignDepl:
	mov	ebp, DWORD PTR [esi+28036]

; 10322: 				{
; 10323: 					m_ChosenBlocks.push_back(m_NewlyChosen[jJ]);

	mov	eax, DWORD PTR [edi+8]
	add	ebp, ebx
	mov	BYTE PTR [edi+604], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN62@AssignDepl
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::GrowSize
$LN62@AssignDepl:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN65@AssignDepl
	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR [eax+12], ecx
$LN65@AssignDepl:
	mov	eax, DWORD PTR _jJ$225663[esp+24]
	inc	DWORD PTR [edi+4]
	inc	eax
	add	ebx, 16					; 00000010H
	mov	DWORD PTR _jJ$225663[esp+24], eax
	cmp	eax, DWORD PTR [esi+28040]
	jb	SHORT $LL7@AssignDepl
$LN5@AssignDepl:

; 10324: #endif
; 10325: 				}
; 10326: 
; 10327: 				RemoveChosenUnits();

	push	0
	mov	ecx, esi
	call	?RemoveChosenUnits@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::RemoveChosenUnits

; 10328: 
; 10329: 				// Do we have enough units left to cover everything?
; 10330: 				if(NumUniqueUnitsLeft() < (iNumUnitsRequiredToDeploy - (int)m_ChosenBlocks.size()))

	mov	edi, DWORD PTR [esi+27432]
	mov	ecx, esi
	call	?NumUniqueUnitsLeft@CvTacticalAI@@AAEHXZ ; CvTacticalAI::NumUniqueUnitsLeft
	mov	edx, DWORD PTR _iNumUnitsRequiredToDeploy$[esp+20]
	sub	edx, edi
	cmp	eax, edx
	jge	$LL16@AssignDepl
$LN109@AssignDepl:
	pop	edi
	pop	esi
	pop	ebp

; 10310: 			{
; 10311: 				return false;   // Not going to work

	xor	al, al
	pop	ebx

; 10367: }

	add	esp, 8
	ret	4
$LN116@AssignDepl:

; 10282: 
; 10283: 	// Loop through potential blocks looking for assignments we MUST make (only one possibility)
; 10284: 	while(bChoseOne)

	xor	ebx, ebx

; 10331: 				{
; 10332: 					return false;
; 10333: 				}
; 10334: 			}
; 10335: 		}
; 10336: 	}
; 10337: 
; 10338: 	// Pick closest unit for highest priority assignment until all processed
; 10339: 	while(m_PotentialBlocks.size() > 0)

	cmp	DWORD PTR [esi+26600], ebx
	jbe	$LN2@AssignDepl
	lea	ebp, DWORD PTR [esi+28036]
	lea	edi, DWORD PTR [esi+27428]
	npad	10
$LL3@AssignDepl:

; 10340: 	{
; 10341: 		bChoseOne = false;
; 10342: 		m_NewlyChosen.clear();

	mov	DWORD PTR [esi+28040], 0

; 10343: 
; 10344: #ifdef AUI_ITERATORIZE
; 10345: 		m_NewlyChosen.push_back(*m_PotentialBlocks.begin());
; 10346: 		m_ChosenBlocks.push_back(*m_PotentialBlocks.begin());
; 10347: 
; 10348: 		// Don't copy the other entries for this hex so pass in the number of choices here
; 10349: 		RemoveChosenUnits(m_PotentialBlocks.begin()->GetNumChoices());
; 10350: #else
; 10351: 		m_NewlyChosen.push_back(m_PotentialBlocks[0]);

	mov	eax, DWORD PTR [ebp+8]
	mov	ebx, DWORD PTR [esi+26596]
	mov	BYTE PTR [ebp+604], 0
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN83@AssignDepl
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::GrowSize
$LN83@AssignDepl:
	mov	eax, DWORD PTR [ebp+4]
	shl	eax, 4
	add	eax, DWORD PTR [ebp]
	je	SHORT $LN86@AssignDepl
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+12], edx
$LN86@AssignDepl:
	inc	DWORD PTR [ebp+4]

; 10352: 		m_ChosenBlocks.push_back(m_PotentialBlocks[0]);

	mov	eax, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR [esi+26596]
	mov	BYTE PTR [edi+604], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN92@AssignDepl
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,37,1,297,0>::GrowSize
$LN92@AssignDepl:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN95@AssignDepl
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+12], edx
$LN95@AssignDepl:
	inc	DWORD PTR [edi+4]

; 10353: 
; 10354: 		// Don't copy the other entries for this hex so pass in the number of choices here
; 10355: 		RemoveChosenUnits(m_PotentialBlocks[0].GetNumChoices());

	mov	eax, DWORD PTR [esi+26596]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, esi
	call	?RemoveChosenUnits@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::RemoveChosenUnits

; 10356: #endif
; 10357: 
; 10358: 		// Do we have enough units left to cover everything?
; 10359: 		if(NumUniqueUnitsLeft() < (iNumUnitsRequiredToDeploy - (int)m_ChosenBlocks.size()))

	mov	ebx, DWORD PTR [esi+27432]
	mov	ecx, esi
	call	?NumUniqueUnitsLeft@CvTacticalAI@@AAEHXZ ; CvTacticalAI::NumUniqueUnitsLeft
	mov	edx, DWORD PTR _iNumUnitsRequiredToDeploy$[esp+20]
	sub	edx, ebx
	cmp	eax, edx
	jge	SHORT $LN1@AssignDepl

; 10360: 		{
; 10361: 			// Used to abort here, but better if we get the moves in we can
; 10362: 			bRtnValue = false;

	mov	BYTE PTR _bRtnValue$[esp+24], 0
$LN1@AssignDepl:

; 10331: 				{
; 10332: 					return false;
; 10333: 				}
; 10334: 			}
; 10335: 		}
; 10336: 	}
; 10337: 
; 10338: 	// Pick closest unit for highest priority assignment until all processed
; 10339: 	while(m_PotentialBlocks.size() > 0)

	cmp	DWORD PTR [esi+26600], 0
	ja	$LL3@AssignDepl
$LN2@AssignDepl:

; 10363: 		}
; 10364: 	}
; 10365: 
; 10366: 	return bRtnValue;

	mov	al, BYTE PTR _bRtnValue$[esp+24]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10367: }

	add	esp, 8
	ret	4
?AssignDeployingUnits@CvTacticalAI@@AAE_NH@Z ENDP	; CvTacticalAI::AssignDeployingUnits
_TEXT	ENDS
PUBLIC	?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ; CvTacticalAI::ExecuteGatherMoves
EXTRN	?GetGatherRangeForXUnits@OperationalAIHelpers@@YAHH@Z:PROC ; OperationalAIHelpers::GetGatherRangeForXUnits
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$3
__ehfuncinfo$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_bDone$ = -85						; size = 1
_pLoopPlot$ = -84					; size = 4
tv876 = -80						; size = 4
$T301442 = -80						; size = 4
_iUnits$ = -76						; size = 4
_iUnitsToPlace$ = -72					; size = 4
_jJ$222656 = -68					; size = 4
_iI$222647 = -64					; size = 4
tv895 = -60						; size = 4
_pUnitAlreadyThere$222651 = -56				; size = 8
_pUnit$ = -48						; size = 8
_strMsg$222666 = -40					; size = 28
_block$222660 = -40					; size = 16
_strLogString$222643 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z PROC ; CvTacticalAI::ExecuteGatherMoves, COMDAT
; _this$ = ecx

; 4945 : {

	push	-1
	push	__ehhandler$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH

; 4946 : 	CvPlot* pTarget;
; 4947 : 	UnitHandle pUnit;

	xor	eax, eax
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _pUnit$[esp+92], eax
	mov	BYTE PTR _pUnit$[esp+96], al
	mov	DWORD PTR __$EHRec$[esp+100], eax

; 4948 : 	int iUnits;
; 4949 : 	AITacticalTargetType eTargetType;
; 4950 : 	CvPlot* pLoopPlot;
; 4951 : 
; 4952 : 	if(m_OperationUnits.size() == 0)

	cmp	DWORD PTR [esi+28648], eax

; 4953 : 	{
; 4954 : 		return;

	je	$LN1@ExecuteGat

; 4955 : 	}
; 4956 : 
; 4957 : 	pTarget = pArmy->Plot();

	mov	ecx, DWORD PTR _pArmy$[esp+88]
	push	ebx
	push	ebp
	push	edi
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot

; 4958 : 
; 4959 : 	// Gathering - treat everyone as a melee unit; don't need ranged in the rear yet
; 4960 : 	iUnits = m_OperationUnits.size();

	mov	edi, DWORD PTR [esi+28648]

; 4961 : 
; 4962 : 	// Range around target based on number of units we need to place
; 4963 : 	int iRange = OperationalAIHelpers::GetGatherRangeForXUnits(iUnits);

	push	edi
	mov	ebp, eax
	mov	DWORD PTR _iUnits$[esp+108], edi
	call	?GetGatherRangeForXUnits@OperationalAIHelpers@@YAHH@Z ; OperationalAIHelpers::GetGatherRangeForXUnits
	add	esp, 4
	mov	ebx, eax

; 4964 : 
; 4965 : 	// Try one time with computed range
; 4966 : 	bool bFoundEnoughDeploymentPlots = false;
; 4967 : 	if (ScoreDeploymentPlots(pTarget, pArmy, iUnits, 0, iRange))

	mov	eax, DWORD PTR _pArmy$[esp+100]
	push	ebx
	push	0
	push	edi
	push	eax
	push	ebp
	mov	ecx, esi
	call	?ScoreDeploymentPlots@CvTacticalAI@@AAE_NPAVCvPlot@@PAVCvArmyAI@@HHH@Z ; CvTacticalAI::ScoreDeploymentPlots
	test	al, al
	je	SHORT $LN195@ExecuteGat

; 4968 : 	{
; 4969 : 		// Did we get twice as many possible plots as units?
; 4970 : 		if (m_TempTargets.size() >= (unsigned)(iUnits * 2))

	mov	eax, DWORD PTR [esi+23708]
	lea	ecx, DWORD PTR [edi+edi]
	cmp	eax, ecx

; 4971 : 		{
; 4972 : 			bFoundEnoughDeploymentPlots = true;
; 4973 : 		}
; 4974 : 		else

	jae	$LN196@ExecuteGat

; 4975 : 		{
; 4976 : 			m_TempTargets.clear();

	mov	DWORD PTR [esi+23708], 0

; 4977 : 			iRange = 3;

	mov	ebx, 3
$LN195@ExecuteGat:

; 4978 : 		}
; 4979 : 	}
; 4980 : 
; 4981 : 	if (!bFoundEnoughDeploymentPlots)
; 4982 : 	{
; 4983 : 		if (!ScoreDeploymentPlots(pTarget, pArmy, iUnits, 0, iRange))

	push	ebx
	mov	ebx, DWORD PTR _pArmy$[esp+104]
	push	0
	push	edi
	push	ebx
	push	ebp
	mov	ecx, esi
	call	?ScoreDeploymentPlots@CvTacticalAI@@AAE_NPAVCvPlot@@PAVCvArmyAI@@HHH@Z ; CvTacticalAI::ScoreDeploymentPlots
	test	al, al
	jne	$LN196@ExecuteGat

; 4984 : 		{
; 4985 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN13@ExecuteGat
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN13@ExecuteGat

; 4986 : 			{
; 4987 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222643[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4988 : 				strLogString.Format("Operation aborting. Army ID: %d. Not enough spaces to deploy near target", pArmy->GetID());

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+112], 1
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	lea	edx, DWORD PTR _strLogString$222643[esp+108]
	push	OFFSET $SG222644
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 4989 : 				LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$222643[esp+108]
	push	eax
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4990 : 			}

	lea	ecx, DWORD PTR _strLogString$222643[esp+104]
	mov	BYTE PTR __$EHRec$[esp+112], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN13@ExecuteGat:

; 4991 : 			m_pPlayer->getAIOperation(pArmy->GetOperationID())->SetToAbort(AI_ABORT_NO_ROOM_DEPLOY);

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+76]
	push	5
	call	eax
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 5065 : 	}
; 5066 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	4
$LN196@ExecuteGat:

; 4992 : 			return;
; 4993 : 		}
; 4994 : 	}
; 4995 : 
; 4996 : 	// Compute the moves to get the best deployment
; 4997 : 	std::stable_sort(m_TempTargets.begin(), m_TempTargets.end());

	mov	eax, DWORD PTR [esi+23708]
	mov	ecx, DWORD PTR [esi+23704]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, ecx
	lea	eax, DWORD PTR [eax+edx*4]
	cmp	ecx, eax
	je	SHORT $LN197@ExecuteGat
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 16					; 00000010H
$LN197@ExecuteGat:

; 4998 : 	m_PotentialBlocks.clear();

	xor	ebx, ebx
	lea	ebp, DWORD PTR [esi+26596]
	mov	DWORD PTR [ebp+4], ebx

; 4999 : 	bool bDone = false;
; 5000 : 
; 5001 : 	int iUnitsToPlace = iUnits;
; 5002 : 
; 5003 : #ifdef AUI_ITERATORIZE
; 5004 : 	for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it = m_TempTargets.begin(); it != m_TempTargets.end() && !bDone; ++it)
; 5005 : 	{
; 5006 : 		eTargetType = it->GetTargetType();
; 5007 : 
; 5008 : 		pLoopPlot = GC.getMap().plot(it->GetTargetX(), it->GetTargetY());
; 5009 : #else
; 5010 : 	for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	eax, DWORD PTR [esi+23708]
	mov	BYTE PTR _bDone$[esp+104], bl
	mov	DWORD PTR _iUnitsToPlace$[esp+104], edi
	mov	DWORD PTR _iI$222647[esp+104], ebx
	cmp	eax, ebx
	jbe	$LN10@ExecuteGat
	xor	eax, eax
	mov	DWORD PTR tv895[esp+104], eax
	npad	6
$LL198@ExecuteGat:
	cmp	BYTE PTR _bDone$[esp+104], 0
	jne	$LN10@ExecuteGat

; 5011 : 	{
; 5012 : 		eTargetType = m_TempTargets[iI].GetTargetType();
; 5013 : 
; 5014 : 		pLoopPlot = GC.getMap().plot(m_TempTargets[iI].GetTargetX(), m_TempTargets[iI].GetTargetY());

	mov	ecx, DWORD PTR [esi+23704]
	mov	edx, DWORD PTR [eax+ecx+8]
	add	eax, ecx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T301442[esp+104], edx
	cmp	eax, -2147483647			; 80000001H
	je	$LN95@ExecuteGat
	cmp	edx, -2147483647			; 80000001H
	je	$LN95@ExecuteGat
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	bl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	bl, bl
	je	SHORT $LN105@ExecuteGat
	test	eax, eax
	jge	SHORT $LN107@ExecuteGat
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR $T301442[esp+104]
	add	edi, ecx
	jmp	SHORT $LN109@ExecuteGat
$LN107@ExecuteGat:
	cmp	eax, ecx
	jl	SHORT $LN105@ExecuteGat
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR $T301442[esp+104]
	jmp	SHORT $LN109@ExecuteGat
$LN105@ExecuteGat:
	mov	edi, eax
$LN109@ExecuteGat:
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebx+4057]
	mov	ebx, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN194@ExecuteGat
	test	edx, edx
	jge	SHORT $LN117@ExecuteGat
	mov	eax, edx
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN194@ExecuteGat
$LN117@ExecuteGat:
	cmp	edx, ebx
	jl	SHORT $LN194@ExecuteGat
	mov	eax, edx
	cdq
	idiv	ebx
$LN194@ExecuteGat:
	test	edi, edi
	jl	SHORT $LN99@ExecuteGat
	cmp	edi, ecx
	jge	SHORT $LN99@ExecuteGat
	test	edx, edx
	jl	SHORT $LN99@ExecuteGat
	cmp	edx, ebx
	jge	SHORT $LN99@ExecuteGat
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	mov	edi, DWORD PTR _iUnits$[esp+104]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pLoopPlot$[esp+104], ecx
	jmp	SHORT $LN97@ExecuteGat
$LN99@ExecuteGat:
	mov	edi, DWORD PTR _iUnits$[esp+104]
	mov	DWORD PTR _pLoopPlot$[esp+104], 0
	jmp	SHORT $LN97@ExecuteGat
$LN95@ExecuteGat:
	mov	DWORD PTR _pLoopPlot$[esp+104], ebx
$LN97@ExecuteGat:

; 5015 : #endif
; 5016 : 		
; 5017 : 		// Don't use if there's already a unit not in the army here
; 5018 : 		UnitHandle pUnitAlreadyThere = pLoopPlot->getBestDefender(NO_PLAYER);

	mov	ecx, DWORD PTR _pLoopPlot$[esp+104]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	-1
	lea	eax, DWORD PTR _pUnitAlreadyThere$222651[esp+132]
	push	eax
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender

; 5019 : 		if (!pUnitAlreadyThere || pUnitAlreadyThere->getArmyID() == pArmy->GetID())

	mov	ecx, DWORD PTR _pUnitAlreadyThere$222651[esp+104]
	mov	BYTE PTR __$EHRec$[esp+112], 2
	test	ecx, ecx
	je	SHORT $LN8@ExecuteGat
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	mov	ecx, DWORD PTR _pArmy$[esp+100]
	mov	ebx, eax
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	cmp	ebx, eax
	jne	$LN193@ExecuteGat
$LN8@ExecuteGat:

; 5020 : 		{
; 5021 : 			if(FindClosestOperationUnit(pLoopPlot, true /*bSafeForRanged*/, false /*bMustBeRangedUnit*/))

	mov	ecx, DWORD PTR _pLoopPlot$[esp+104]
	xor	ebx, ebx
	push	ebx
	push	1
	push	ecx
	mov	ecx, esi
	call	?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z ; CvTacticalAI::FindClosestOperationUnit
	test	al, al
	je	$LN193@ExecuteGat

; 5022 : 			{
; 5023 : #ifdef AUI_ITERATORIZE
; 5024 : 				for (std::vector<CvTacticalUnit>::const_iterator it2 = m_CurrentMoveUnits.begin(); it2 != m_CurrentMoveUnits.end(); ++it2)
; 5025 : 				{
; 5026 : 					CvBlockingUnit block;
; 5027 : 					block.SetUnitID(it2->GetID());
; 5028 : 					block.SetPlot(pLoopPlot);
; 5029 : 					block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 5030 : 					block.SetDistanceToTarget(it2->GetMovesToTarget());
; 5031 : #else
; 5032 : 				for(unsigned int jJ = 0; jJ < m_CurrentMoveUnits.size(); jJ++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _jJ$222656[esp+104], ebx
	je	$LN4@ExecuteGat
	mov	DWORD PTR tv876[esp+104], ebx
	npad	5
$LL192@ExecuteGat:

; 5033 : 				{
; 5034 : 					CvBlockingUnit block;
; 5035 : 					block.SetUnitID(m_CurrentMoveUnits[jJ].GetID());

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR tv876[esp+104]
	mov	eax, DWORD PTR [edx+ecx]
	lea	ebx, DWORD PTR [edx+ecx]

; 5036 : 					block.SetPlot(pLoopPlot);
; 5037 : 					block.SetNumChoices((int)m_CurrentMoveUnits.size());

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]

; 5038 : 					block.SetDistanceToTarget(m_CurrentMoveUnits[jJ].GetMovesToTarget());

	mov	ebx, DWORD PTR [ebx+12]
	mov	DWORD PTR _block$222660[esp+108], eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 5039 : #endif
; 5040 : 					m_PotentialBlocks.push_back(block);

	mov	eax, DWORD PTR [ebp+8]
	sar	edx, 2
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	BYTE PTR [ebp+412], 0
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN159@ExecuteGat
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
$LN159@ExecuteGat:
	mov	eax, DWORD PTR [ebp+4]
	shl	eax, 4
	add	eax, DWORD PTR [ebp]
	je	SHORT $LN162@ExecuteGat
	mov	ecx, DWORD PTR _pLoopPlot$[esp+104]
	mov	edx, DWORD PTR _block$222660[esp+108]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], ebx
$LN162@ExecuteGat:
	inc	DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	edi, DWORD PTR _jJ$222656[esp+104]
	add	DWORD PTR tv876[esp+104], 24		; 00000018H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	edi
	add	eax, edx
	mov	DWORD PTR _jJ$222656[esp+104], edi
	cmp	edi, eax
	jb	$LL192@ExecuteGat

; 5022 : 			{
; 5023 : #ifdef AUI_ITERATORIZE
; 5024 : 				for (std::vector<CvTacticalUnit>::const_iterator it2 = m_CurrentMoveUnits.begin(); it2 != m_CurrentMoveUnits.end(); ++it2)
; 5025 : 				{
; 5026 : 					CvBlockingUnit block;
; 5027 : 					block.SetUnitID(it2->GetID());
; 5028 : 					block.SetPlot(pLoopPlot);
; 5029 : 					block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 5030 : 					block.SetDistanceToTarget(it2->GetMovesToTarget());
; 5031 : #else
; 5032 : 				for(unsigned int jJ = 0; jJ < m_CurrentMoveUnits.size(); jJ++)

	mov	edi, DWORD PTR _iUnits$[esp+104]
$LN4@ExecuteGat:

; 5041 : 				}
; 5042 : 				iUnitsToPlace--;

	sub	DWORD PTR _iUnitsToPlace$[esp+104], 1

; 5043 : 				if(iUnitsToPlace == 0)

	jne	SHORT $LN193@ExecuteGat

; 5044 : 				{
; 5045 : 					bDone = true;

	mov	BYTE PTR _bDone$[esp+104], 1
$LN193@ExecuteGat:

; 5046 : 				}	
; 5047 : 			}
; 5048 : 		}
; 5049 : 	}

	mov	ecx, DWORD PTR _pUnitAlreadyThere$222651[esp+104]
	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+112], 0
	cmp	ecx, ebx
	je	SHORT $LN11@ExecuteGat
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@ExecuteGat:

; 4999 : 	bool bDone = false;
; 5000 : 
; 5001 : 	int iUnitsToPlace = iUnits;
; 5002 : 
; 5003 : #ifdef AUI_ITERATORIZE
; 5004 : 	for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it = m_TempTargets.begin(); it != m_TempTargets.end() && !bDone; ++it)
; 5005 : 	{
; 5006 : 		eTargetType = it->GetTargetType();
; 5007 : 
; 5008 : 		pLoopPlot = GC.getMap().plot(it->GetTargetX(), it->GetTargetY());
; 5009 : #else
; 5010 : 	for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	ecx, DWORD PTR _iI$222647[esp+104]
	mov	eax, DWORD PTR tv895[esp+104]
	inc	ecx
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _iI$222647[esp+104], ecx
	mov	DWORD PTR tv895[esp+104], eax
	cmp	ecx, DWORD PTR [esi+23708]
	jb	$LL198@ExecuteGat
$LN10@ExecuteGat:

; 5050 : 
; 5051 : 	// Now ready to make the assignments
; 5052 : 	AssignDeployingUnits(iUnits - iUnitsToPlace);

	mov	ecx, edi
	sub	ecx, DWORD PTR _iUnitsToPlace$[esp+104]
	push	ecx
	mov	ecx, esi
	call	?AssignDeployingUnits@CvTacticalAI@@AAE_NH@Z ; CvTacticalAI::AssignDeployingUnits

; 5053 : 
; 5054 : 	PerformChosenMoves();

	push	1
	mov	ecx, esi
	call	?PerformChosenMoves@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::PerformChosenMoves

; 5055 : 
; 5056 : 	// Log if someone in army didn't get a move assigned (how do we address this in the future?)
; 5057 : 	if(m_ChosenBlocks.size() < (unsigned int)(iUnits))

	cmp	DWORD PTR [esi+27432], edi
	jae	SHORT $LN200@ExecuteGat

; 5058 : 	{
; 5059 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN200@ExecuteGat
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN200@ExecuteGat

; 5060 : 		{
; 5061 : 			CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222666[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5062 : 			strMsg.Format("No gather move for %d units", iUnits - m_ChosenBlocks.size());

	sub	edi, DWORD PTR [esi+27432]
	lea	edx, DWORD PTR _strMsg$222666[esp+104]
	push	edi
	push	OFFSET $SG222667
	push	edx
	mov	BYTE PTR __$EHRec$[esp+124], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5063 : 			LogTacticalMessage(strMsg);

	push	1
	lea	eax, DWORD PTR _strMsg$222666[esp+108]
	push	eax
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 5064 : 		}

	lea	ecx, DWORD PTR _strMsg$222666[esp+104]
	mov	BYTE PTR __$EHRec$[esp+112], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN200@ExecuteGat:
	pop	edi
	pop	ebp
	pop	ebx
$LN1@ExecuteGat:

; 5065 : 	}
; 5066 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$1:
	lea	ecx, DWORD PTR _strLogString$222643[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$2:
	lea	ecx, DWORD PTR _pUnitAlreadyThere$222651[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$3:
	lea	ecx, DWORD PTR _strMsg$222666[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ENDP ; CvTacticalAI::ExecuteGatherMoves
PUBLIC	?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ; CvTacticalAI::ExecuteNavalFormationMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$3
__ehfuncinfo$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z
_TEXT	SEGMENT
tv1644 = -80						; size = 4
_iLeastUnitsToPlace$222916 = -80			; size = 4
_iNavalUnits$ = -80					; size = 4
tv1699 = -76						; size = 4
tv1625 = -76						; size = 4
_iEscortedUnits$ = -76					; size = 4
tv1680 = -72						; size = 4
_iMostUnitsToPlace$222892 = -72				; size = 4
_bMoreEscorted$ = -68					; size = 1
_iLeastUnits$ = -64					; size = 4
_iI$222917 = -60					; size = 4
_jJ$222898 = -60					; size = 4
_jJ$222922 = -56					; size = 4
_iI$222893 = -56					; size = 4
_iMostUnits$ = -52					; size = 4
_pUnit$ = -48						; size = 8
_strMsg$222932 = -40					; size = 28
_block$222926 = -40					; size = 16
_temp$222911 = -40					; size = 28
_strMsg$222908 = -40					; size = 28
_block$222902 = -40					; size = 16
_strLogString$222888 = -40				; size = 28
__$EHRec$ = -12						; size = 12
tv1665 = 8						; size = 4
_bDone$222891 = 8					; size = 1
_pArmy$ = 8						; size = 4
$T302075 = 12						; size = 4
$T301788 = 12						; size = 4
_iI$222912 = 12						; size = 4
_pLoopPlot$ = 12					; size = 4
_pTurnTarget$ = 12					; size = 4
?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z PROC ; CvTacticalAI::ExecuteNavalFormationMoves, COMDAT
; _this$ = ecx

; 5558 : {

	push	-1
	push	__ehhandler$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	ebp
	push	edi

; 5559 : 	UnitHandle pUnit;

	xor	edi, edi
	mov	ebp, ecx
	mov	DWORD PTR _pUnit$[esp+88], edi
	mov	BYTE PTR _pUnit$[esp+92], 0
	mov	DWORD PTR __$EHRec$[esp+96], edi

; 5560 : 	int iMostUnits;
; 5561 : 	int iLeastUnits;
; 5562 : 	CvPlot* pLoopPlot;
; 5563 : 	bool bMoreEscorted = true;

	mov	BYTE PTR _bMoreEscorted$[esp+88], 1

; 5564 : 	FStaticVector<CvOperationUnit, SAFE_ESTIMATE_NUM_MULTIUNITFORMATION_ENTRIES, true, c_eCiv5GameplayDLL, 0>::iterator it;
; 5565 : 
; 5566 : 	if(m_OperationUnits.size() == 0)

	cmp	DWORD PTR [ebp+28648], edi

; 5567 : 	{
; 5568 : 		return;

	je	$LN1@ExecuteNav@2

; 5569 : 	}
; 5570 : 
; 5571 : 	int iNavalUnits = 0;
; 5572 : 	int iEscortedUnits = 0;
; 5573 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 5574 : 	for (it = m_OperationUnits.begin(); it != m_OperationUnits.end(); ++it)
; 5575 : #else
; 5576 : 	for(it = m_OperationUnits.begin(); it != m_OperationUnits.end(); it++)

	mov	eax, DWORD PTR [ebp+28648]
	push	ebx
	mov	ebx, DWORD PTR [ebp+28644]
	mov	ecx, ebx
	lea	edx, DWORD PTR [ecx+eax*8]
	push	esi
	mov	DWORD PTR _iNavalUnits$[esp+96], edi
	mov	DWORD PTR _iEscortedUnits$[esp+96], edi
	cmp	ebx, edx
	je	SHORT $LN346@ExecuteNav@2
	npad	5
$LL36@ExecuteNav@2:

; 5577 : #endif
; 5578 : 	{
; 5579 : 		CvUnit *pOpUnit = m_pPlayer->getUnit(it->GetUnitID());

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax

; 5580 : 		if (pOpUnit)

	test	esi, esi
	je	SHORT $LN35@ExecuteNav@2

; 5581 : 		{
; 5582 : 			if (pOpUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN32@ExecuteNav@2

; 5583 : 			{
; 5584 : 				iEscortedUnits++;

	inc	edi

; 5585 : 			}
; 5586 : 			else

	jmp	SHORT $LN35@ExecuteNav@2
$LN32@ExecuteNav@2:

; 5587 : 			{
; 5588 : 				if (pOpUnit->IsGreatAdmiral())

	mov	ecx, esi
	call	?IsGreatAdmiral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatAdmiral
	test	al, al
	je	SHORT $LN30@ExecuteNav@2

; 5589 : 				{
; 5590 : 					iEscortedUnits++;

	inc	edi

; 5591 : 				}
; 5592 : 				else

	jmp	SHORT $LN35@ExecuteNav@2
$LN30@ExecuteNav@2:

; 5593 : 				{
; 5594 : 					iNavalUnits++;

	inc	DWORD PTR _iNavalUnits$[esp+96]
$LN35@ExecuteNav@2:

; 5569 : 	}
; 5570 : 
; 5571 : 	int iNavalUnits = 0;
; 5572 : 	int iEscortedUnits = 0;
; 5573 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 5574 : 	for (it = m_OperationUnits.begin(); it != m_OperationUnits.end(); ++it)
; 5575 : #else
; 5576 : 	for(it = m_OperationUnits.begin(); it != m_OperationUnits.end(); it++)

	mov	eax, DWORD PTR [ebp+28648]
	mov	ecx, DWORD PTR [ebp+28644]
	add	ebx, 8
	lea	edx, DWORD PTR [ecx+eax*8]
	cmp	ebx, edx
	jne	SHORT $LL36@ExecuteNav@2

; 5595 : 				}
; 5596 : 			}
; 5597 : 		}
; 5598 : 	}
; 5599 : 
; 5600 : 	iMostUnits = max(iNavalUnits, iEscortedUnits);

	cmp	DWORD PTR _iNavalUnits$[esp+96], edi
	mov	DWORD PTR _iEscortedUnits$[esp+96], edi
	lea	eax, DWORD PTR _iEscortedUnits$[esp+96]
	jl	SHORT $LN62@ExecuteNav@2
$LN346@ExecuteNav@2:
	lea	eax, DWORD PTR _iNavalUnits$[esp+96]
$LN62@ExecuteNav@2:
	mov	esi, DWORD PTR [eax]

; 5601 : 	iLeastUnits = min(iNavalUnits, iEscortedUnits);

	mov	ecx, DWORD PTR _iNavalUnits$[esp+96]
	cmp	edi, ecx
	mov	DWORD PTR _iMostUnits$[esp+96], esi
	lea	eax, DWORD PTR _iEscortedUnits$[esp+96]
	jl	SHORT $LN66@ExecuteNav@2
	lea	eax, DWORD PTR _iNavalUnits$[esp+96]
$LN66@ExecuteNav@2:

; 5602 : 	if(iNavalUnits > iEscortedUnits)

	cmp	ecx, edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _iLeastUnits$[esp+96], eax
	jle	SHORT $LN28@ExecuteNav@2

; 5603 : 	{
; 5604 : 		bMoreEscorted = false;

	mov	BYTE PTR _bMoreEscorted$[esp+96], 0
$LN28@ExecuteNav@2:

; 5605 : 	}
; 5606 : 
; 5607 : 	// Range around turn target based on number of units we need to place
; 5608 : 	int iRange = OperationalAIHelpers::GetGatherRangeForXUnits(iMostUnits);

	push	esi
	call	?GetGatherRangeForXUnits@OperationalAIHelpers@@YAHH@Z ; OperationalAIHelpers::GetGatherRangeForXUnits

; 5609 : 
; 5610 : 	// See if we have enough places to put everyone
; 5611 : 	if(!ScoreDeploymentPlots(pTurnTarget, pArmy, iMostUnits, 0, iRange) &&
; 5612 : 	        !ScoreDeploymentPlots(pTurnTarget, pArmy, iMostUnits, 0, 3))

	mov	ebx, DWORD PTR _pArmy$[esp+96]
	mov	edi, DWORD PTR _pTurnTarget$[esp+96]
	add	esp, 4
	push	eax
	push	0
	push	esi
	push	ebx
	push	edi
	mov	ecx, ebp
	call	?ScoreDeploymentPlots@CvTacticalAI@@AAE_NPAVCvPlot@@PAVCvArmyAI@@HHH@Z ; CvTacticalAI::ScoreDeploymentPlots
	test	al, al
	jne	$LN27@ExecuteNav@2
	push	3
	push	0
	push	esi
	push	ebx
	push	edi
	mov	ecx, ebp
	call	?ScoreDeploymentPlots@CvTacticalAI@@AAE_NPAVCvPlot@@PAVCvArmyAI@@HHH@Z ; CvTacticalAI::ScoreDeploymentPlots
	test	al, al
	jne	$LN27@ExecuteNav@2

; 5613 : 	{
; 5614 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN26@ExecuteNav@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN26@ExecuteNav@2

; 5615 : 		{
; 5616 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222888[esp+96]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5617 : 			strLogString.Format("Operation aborting. Army ID: %d. Not enough spaces to deploy near turn target", pArmy->GetID());

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+104], 1
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	lea	ecx, DWORD PTR _strLogString$222888[esp+100]
	push	OFFSET $SG222889
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5618 : 			LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$222888[esp+100]
	push	edx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 5619 : 		}

	lea	ecx, DWORD PTR _strLogString$222888[esp+96]
	mov	BYTE PTR __$EHRec$[esp+104], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN26@ExecuteNav@2:

; 5620 : 		m_pPlayer->getAIOperation(pArmy->GetOperationID())->SetToAbort(AI_ABORT_NO_ROOM_DEPLOY);

	mov	ebx, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [ebp]
	push	ebx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+76]
	push	5
	call	eax
	pop	esi
	pop	ebx
	pop	edi
	pop	ebp

; 5758 : 			}
; 5759 : 		}
; 5760 : 	}
; 5761 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	8
$LN27@ExecuteNav@2:

; 5621 : 	}
; 5622 : 
; 5623 : 	// Compute moves for whomever has more units first
; 5624 : 	else
; 5625 : 	{
; 5626 : 		std::stable_sort(m_TempTargets.begin(), m_TempTargets.end());

	mov	eax, DWORD PTR [ebp+23708]
	mov	ecx, DWORD PTR [ebp+23704]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, ecx
	lea	eax, DWORD PTR [eax+edx*4]
	xor	edi, edi
	cmp	ecx, eax
	je	SHORT $LN79@ExecuteNav@2
	push	edi
	push	edi
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 16					; 00000010H
$LN79@ExecuteNav@2:

; 5627 : 		m_PotentialBlocks.clear();

	lea	ebx, DWORD PTR [ebp+26596]
	mov	DWORD PTR [ebx+4], edi

; 5628 : 		bool bDone = false;
; 5629 : 		int iMostUnitsToPlace = iMostUnits;
; 5630 : 
; 5631 : #ifdef AUI_ITERATORIZE
; 5632 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5633 : 		{
; 5634 : 			pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5635 : #else
; 5636 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	eax, DWORD PTR [ebp+23708]
	mov	BYTE PTR _bDone$222891[esp+92], 0
	mov	DWORD PTR _iMostUnitsToPlace$222892[esp+96], esi
	mov	DWORD PTR _iI$222893[esp+96], edi
	cmp	eax, edi
	jbe	$LN22@ExecuteNav@2

; 5627 : 		m_PotentialBlocks.clear();

	mov	DWORD PTR tv1644[esp+96], edi
	npad	3
$LL336@ExecuteNav@2:

; 5628 : 		bool bDone = false;
; 5629 : 		int iMostUnitsToPlace = iMostUnits;
; 5630 : 
; 5631 : #ifdef AUI_ITERATORIZE
; 5632 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5633 : 		{
; 5634 : 			pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5635 : #else
; 5636 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	cmp	BYTE PTR _bDone$222891[esp+92], 0
	jne	$LN22@ExecuteNav@2

; 5637 : 		{
; 5638 : 			pLoopPlot = GC.getMap().plot(m_TempTargets[iI].GetTargetX(), m_TempTargets[iI].GetTargetY());

	mov	ecx, DWORD PTR [ebp+23704]
	mov	edx, DWORD PTR tv1644[esp+96]
	mov	esi, DWORD PTR [edx+ecx+4]
	lea	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T301788[esp+92], ecx
	cmp	esi, -2147483647			; 80000001H
	je	$LN106@ExecuteNav@2
	cmp	ecx, -2147483647			; 80000001H
	je	$LN106@ExecuteNav@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	al, al
	je	SHORT $LN338@ExecuteNav@2
	test	esi, esi
	jge	SHORT $LN118@ExecuteNav@2
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN338@ExecuteNav@2
$LN118@ExecuteNav@2:
	cmp	esi, ecx
	jl	SHORT $LN338@ExecuteNav@2
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN338@ExecuteNav@2:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	edi, DWORD PTR [edx+4024]
	mov	edx, DWORD PTR $T301788[esp+92]
	test	al, al
	je	SHORT $LN126@ExecuteNav@2
	test	edx, edx
	jge	SHORT $LN128@ExecuteNav@2
	mov	eax, edx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN126@ExecuteNav@2
$LN128@ExecuteNav@2:
	cmp	edx, edi
	jl	SHORT $LN126@ExecuteNav@2
	mov	eax, DWORD PTR $T301788[esp+92]
	cdq
	idiv	edi
$LN126@ExecuteNav@2:
	test	esi, esi
	jl	SHORT $LN106@ExecuteNav@2
	cmp	esi, ecx
	jge	SHORT $LN106@ExecuteNav@2
	test	edx, edx
	jl	SHORT $LN106@ExecuteNav@2
	cmp	edx, edi
	jge	SHORT $LN106@ExecuteNav@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	jmp	SHORT $LN350@ExecuteNav@2
$LN106@ExecuteNav@2:
	xor	ecx, ecx
$LN350@ExecuteNav@2:

; 5639 : #endif
; 5640 : 			if(FindClosestNavalOperationUnit(pLoopPlot, bMoreEscorted))

	mov	edx, DWORD PTR _bMoreEscorted$[esp+96]
	push	edx
	mov	DWORD PTR _pLoopPlot$[esp+96], ecx
	push	ecx
	mov	ecx, ebp
	call	?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z ; CvTacticalAI::FindClosestNavalOperationUnit
	test	al, al
	je	$LN23@ExecuteNav@2

; 5641 : 			{
; 5642 : #ifdef AUI_ITERATORIZE
; 5643 : 				for (std::vector<CvTacticalUnit>::const_iterator it3 = m_CurrentMoveUnits.begin(); it3 != m_CurrentMoveUnits.end(); ++it3)
; 5644 : 				{
; 5645 : 					CvBlockingUnit block;
; 5646 : 					block.SetUnitID(it3->GetID());
; 5647 : 					block.SetPlot(pLoopPlot);
; 5648 : 					block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 5649 : 					block.SetDistanceToTarget(it3->GetMovesToTarget());
; 5650 : #else
; 5651 : 				for(unsigned int jJ = 0; jJ < m_CurrentMoveUnits.size(); jJ++)

	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	xor	esi, esi
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _jJ$222898[esp+96], esi
	je	$LN339@ExecuteNav@2
	mov	DWORD PTR tv1625[esp+96], esi
	npad	9
$LL20@ExecuteNav@2:

; 5652 : 				{
; 5653 : 					CvBlockingUnit block;
; 5654 : 					block.SetUnitID(m_CurrentMoveUnits[jJ].GetID());

	mov	ecx, DWORD PTR [ebp+24]
	mov	edx, DWORD PTR tv1625[esp+96]
	mov	eax, DWORD PTR [ecx+edx]
	lea	edi, DWORD PTR [ecx+edx]

; 5655 : 					block.SetPlot(pLoopPlot);
; 5656 : 					block.SetNumChoices((int)m_CurrentMoveUnits.size());

	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]

; 5657 : 					block.SetDistanceToTarget(m_CurrentMoveUnits[jJ].GetMovesToTarget());

	mov	edi, DWORD PTR [edi+12]
	mov	DWORD PTR _block$222902[esp+100], eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 5658 : #endif
; 5659 : 					m_PotentialBlocks.push_back(block);

	mov	eax, DWORD PTR [ebx+8]
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	BYTE PTR [ebx+412], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN166@ExecuteNav@2
	push	eax
	mov	ecx, ebx
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
$LN166@ExecuteNav@2:
	mov	eax, DWORD PTR [ebx+4]
	shl	eax, 4
	add	eax, DWORD PTR [ebx]
	je	SHORT $LN169@ExecuteNav@2
	mov	ecx, DWORD PTR _pLoopPlot$[esp+92]
	mov	edx, DWORD PTR _block$222902[esp+100]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], edi
$LN169@ExecuteNav@2:
	inc	DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	esi, DWORD PTR _jJ$222898[esp+96]
	add	DWORD PTR tv1625[esp+96], 24		; 00000018H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	esi
	add	eax, edx
	mov	DWORD PTR _jJ$222898[esp+96], esi
	cmp	esi, eax
	jb	$LL20@ExecuteNav@2
$LN339@ExecuteNav@2:

; 5660 : 				}
; 5661 : 				iMostUnitsToPlace--;

	sub	DWORD PTR _iMostUnitsToPlace$222892[esp+96], 1

; 5662 : 				if(iMostUnitsToPlace == 0)

	jne	SHORT $LN23@ExecuteNav@2

; 5663 : 				{
; 5664 : 					bDone = true;

	mov	BYTE PTR _bDone$222891[esp+92], 1
$LN23@ExecuteNav@2:

; 5628 : 		bool bDone = false;
; 5629 : 		int iMostUnitsToPlace = iMostUnits;
; 5630 : 
; 5631 : #ifdef AUI_ITERATORIZE
; 5632 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5633 : 		{
; 5634 : 			pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5635 : #else
; 5636 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	eax, DWORD PTR _iI$222893[esp+96]
	add	DWORD PTR tv1644[esp+96], 28		; 0000001cH
	inc	eax
	mov	DWORD PTR _iI$222893[esp+96], eax
	cmp	eax, DWORD PTR [ebp+23708]
	jb	$LL336@ExecuteNav@2
$LN22@ExecuteNav@2:

; 5665 : 				}
; 5666 : 			}
; 5667 : 		}
; 5668 : 
; 5669 : 		// Now ready to make the assignments
; 5670 : 		AssignDeployingUnits(iMostUnits - iMostUnitsToPlace);

	mov	esi, DWORD PTR _iMostUnits$[esp+96]
	mov	ecx, esi
	sub	ecx, DWORD PTR _iMostUnitsToPlace$222892[esp+96]
	push	ecx
	mov	ecx, ebp
	call	?AssignDeployingUnits@CvTacticalAI@@AAE_NH@Z ; CvTacticalAI::AssignDeployingUnits

; 5671 : 		PerformChosenMoves(2);

	push	2
	mov	ecx, ebp
	call	?PerformChosenMoves@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::PerformChosenMoves

; 5672 : 
; 5673 : 		// Log if someone in army didn't get a move assigned (how do we address this in the future?)
; 5674 : 		if(m_ChosenBlocks.size() < (unsigned int)iMostUnits)

	mov	eax, DWORD PTR [ebp+27432]
	cmp	eax, esi
	jae	SHORT $LN341@ExecuteNav@2

; 5675 : 		{
; 5676 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN341@ExecuteNav@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN341@ExecuteNav@2

; 5677 : 			{
; 5678 : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222908[esp+96]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5679 : 				strMsg.Format("No naval deployment move for %d units in first pass", iMostUnits - m_ChosenBlocks.size());

	sub	esi, DWORD PTR [ebp+27432]
	lea	edx, DWORD PTR _strMsg$222908[esp+96]
	push	esi
	push	OFFSET $SG222909
	push	edx
	mov	BYTE PTR __$EHRec$[esp+116], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5680 : 				LogTacticalMessage(strMsg);

	push	1
	lea	eax, DWORD PTR _strMsg$222908[esp+100]
	push	eax
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 5681 : 			}

	lea	ecx, DWORD PTR _strMsg$222908[esp+96]
	mov	BYTE PTR __$EHRec$[esp+104], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN341@ExecuteNav@2:

; 5682 : 		}
; 5683 : 		
; 5684 : 		if(iLeastUnits > 0)

	xor	edi, edi
	cmp	DWORD PTR _iLeastUnits$[esp+96], edi
	jle	$LN348@ExecuteNav@2

; 5688 : 			CvTacticalTarget temp;

	or	eax, -1
	lea	esi, DWORD PTR [ebp+23704]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR _temp$222911[esp+96], edi
	mov	DWORD PTR _temp$222911[esp+100], eax
	mov	DWORD PTR _temp$222911[esp+104], eax
	mov	DWORD PTR _temp$222911[esp+108], eax
	mov	DWORD PTR _temp$222911[esp+120], eax
	mov	DWORD PTR _temp$222911[esp+112], edi
	mov	DWORD PTR _temp$222911[esp+116], edi

; 5689 : 
; 5690 : #ifdef AUI_ITERATORIZE
; 5691 : 			for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_ChosenBlocks.begin(); it2 != m_ChosenBlocks.end(); ++it2)
; 5692 : 			{
; 5693 : 				temp.SetTargetX(it2->GetPlot()->getX());
; 5694 : 				temp.SetTargetY(it2->GetPlot()->getY());
; 5695 : #else
; 5696 : 			for(unsigned int iI = 0; iI < m_ChosenBlocks.size(); iI++)

	mov	DWORD PTR _iI$222912[esp+92], edi
	cmp	DWORD PTR [ebp+27432], edi
	jbe	SHORT $LN11@ExecuteNav@2

; 5685 : 		{
; 5686 : 			// Now repeat for the other type of units, using the same target plots
; 5687 : 			m_TempTargets.clear();

	mov	DWORD PTR tv1665[esp+92], edi
	npad	1
$LL13@ExecuteNav@2:

; 5697 : 			{
; 5698 : 				temp.SetTargetX(m_ChosenBlocks[iI].GetPlot()->getX());

	mov	ecx, DWORD PTR [ebp+27428]
	mov	edx, DWORD PTR tv1665[esp+92]
	mov	eax, DWORD PTR [edx+ecx]
	movsx	ecx, WORD PTR [eax]

; 5699 : 				temp.SetTargetY(m_ChosenBlocks[iI].GetPlot()->getY());

	movsx	edx, WORD PTR [eax+2]

; 5700 : #endif
; 5701 : 				m_TempTargets.push_back(temp);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _temp$222911[esp+100], ecx
	mov	DWORD PTR _temp$222911[esp+104], edx
	mov	BYTE PTR [esi+1048], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN213@ExecuteNav@2
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::GrowSize
$LN213@ExecuteNav@2:
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, edi
	je	SHORT $LN216@ExecuteNav@2
	mov	ecx, 7
	lea	esi, DWORD PTR _temp$222911[esp+96]
	mov	edi, eax
	rep movsd
	xor	edi, edi
$LN216@ExecuteNav@2:
	mov	eax, DWORD PTR _iI$222912[esp+92]
	inc	DWORD PTR [ebp+23708]
	add	DWORD PTR tv1665[esp+92], 16		; 00000010H
	lea	esi, DWORD PTR [ebp+23704]
	inc	eax
	mov	DWORD PTR _iI$222912[esp+92], eax
	cmp	eax, DWORD PTR [ebp+27432]
	jb	SHORT $LL13@ExecuteNav@2
$LN11@ExecuteNav@2:

; 5705 : 			bDone = false;
; 5706 : 			int iLeastUnitsToPlace = iLeastUnits;

	mov	eax, DWORD PTR _iLeastUnits$[esp+96]
	mov	DWORD PTR [ebx+4], edi
	mov	BYTE PTR _bDone$222891[esp+92], 0
	mov	DWORD PTR _iLeastUnitsToPlace$222916[esp+96], eax

; 5707 : 
; 5708 : #ifdef AUI_ITERATORIZE
; 5709 : 			for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5710 : 			{
; 5711 : 				pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5712 : #else
; 5713 : 			for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	DWORD PTR _iI$222917[esp+96], edi
	cmp	DWORD PTR [ebp+23708], edi
	jbe	$LN8@ExecuteNav@2

; 5702 : 			}
; 5703 : 
; 5704 : 			m_PotentialBlocks.clear();

	mov	DWORD PTR tv1699[esp+96], edi
	npad	3
$LL337@ExecuteNav@2:

; 5707 : 
; 5708 : #ifdef AUI_ITERATORIZE
; 5709 : 			for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5710 : 			{
; 5711 : 				pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5712 : #else
; 5713 : 			for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	cmp	BYTE PTR _bDone$222891[esp+92], 0
	jne	$LN8@ExecuteNav@2

; 5714 : 			{
; 5715 : 				pLoopPlot = GC.getMap().plot(m_TempTargets[iI].GetTargetX(), m_TempTargets[iI].GetTargetY());

	mov	ecx, DWORD PTR [ebp+23704]
	mov	edx, DWORD PTR tv1699[esp+96]
	mov	esi, DWORD PTR [edx+ecx+4]
	lea	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T302075[esp+92], ecx
	cmp	esi, -2147483647			; 80000001H
	je	$LN240@ExecuteNav@2
	cmp	ecx, -2147483647			; 80000001H
	je	$LN240@ExecuteNav@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	al, al
	je	SHORT $LN342@ExecuteNav@2
	test	esi, esi
	jge	SHORT $LN252@ExecuteNav@2
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN342@ExecuteNav@2
$LN252@ExecuteNav@2:
	cmp	esi, ecx
	jl	SHORT $LN342@ExecuteNav@2
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN342@ExecuteNav@2:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	edi, DWORD PTR [edx+4024]
	mov	edx, DWORD PTR $T302075[esp+92]
	test	al, al
	je	SHORT $LN260@ExecuteNav@2
	test	edx, edx
	jge	SHORT $LN262@ExecuteNav@2
	mov	eax, edx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN260@ExecuteNav@2
$LN262@ExecuteNav@2:
	cmp	edx, edi
	jl	SHORT $LN260@ExecuteNav@2
	mov	eax, DWORD PTR $T302075[esp+92]
	cdq
	idiv	edi
$LN260@ExecuteNav@2:
	test	esi, esi
	jl	SHORT $LN240@ExecuteNav@2
	cmp	esi, ecx
	jge	SHORT $LN240@ExecuteNav@2
	test	edx, edx
	jl	SHORT $LN240@ExecuteNav@2
	cmp	edx, edi
	jge	SHORT $LN240@ExecuteNav@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	jmp	SHORT $LN351@ExecuteNav@2
$LN240@ExecuteNav@2:
	xor	ecx, ecx
$LN351@ExecuteNav@2:

; 5716 : #endif
; 5717 : 				if(FindClosestNavalOperationUnit(pLoopPlot, !bMoreEscorted))

	cmp	BYTE PTR _bMoreEscorted$[esp+96], 0
	mov	DWORD PTR _pLoopPlot$[esp+92], ecx
	sete	dl
	movzx	eax, dl
	push	eax
	push	ecx
	mov	ecx, ebp
	call	?FindClosestNavalOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N@Z ; CvTacticalAI::FindClosestNavalOperationUnit
	test	al, al
	je	$LN9@ExecuteNav@2

; 5718 : 				{
; 5719 : #ifdef AUI_ITERATORIZE
; 5720 : 					for (std::vector<CvTacticalUnit>::const_iterator it3 = m_CurrentMoveUnits.begin(); it3 != m_CurrentMoveUnits.end(); ++it3)
; 5721 : 					{
; 5722 : 						CvBlockingUnit block;
; 5723 : 						block.SetUnitID(it3->GetID());
; 5724 : 						block.SetPlot(pLoopPlot);
; 5725 : 						block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 5726 : 						block.SetDistanceToTarget(it3->GetMovesToTarget());
; 5727 : #else
; 5728 : 					for(unsigned int jJ = 0; jJ < m_CurrentMoveUnits.size(); jJ++)

	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _jJ$222922[esp+96], 0
	je	$LN4@ExecuteNav@2
	mov	DWORD PTR tv1680[esp+96], 0
$LL6@ExecuteNav@2:

; 5729 : 					{
; 5730 : 						CvBlockingUnit block;
; 5731 : 						block.SetUnitID(m_CurrentMoveUnits[jJ].GetID());

	mov	edx, DWORD PTR [ebp+24]
	mov	eax, DWORD PTR tv1680[esp+96]
	mov	ecx, DWORD PTR [edx+eax]
	lea	edi, DWORD PTR [edx+eax]

; 5732 : 						block.SetPlot(pLoopPlot);
; 5733 : 						block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 5734 : 						block.SetDistanceToTarget(m_CurrentMoveUnits[jJ].GetMovesToTarget());

	mov	edi, DWORD PTR [edi+12]
	mov	DWORD PTR _block$222926[esp+100], ecx
	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 5735 : #endif
; 5736 : 						m_PotentialBlocks.push_back(block);

	mov	eax, DWORD PTR [ebx+8]
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	BYTE PTR [ebx+412], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN300@ExecuteNav@2
	push	eax
	mov	ecx, ebx
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
$LN300@ExecuteNav@2:
	mov	eax, DWORD PTR [ebx+4]
	shl	eax, 4
	add	eax, DWORD PTR [ebx]
	je	SHORT $LN303@ExecuteNav@2
	mov	edx, DWORD PTR _pLoopPlot$[esp+92]
	mov	ecx, DWORD PTR _block$222926[esp+100]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], edi
$LN303@ExecuteNav@2:
	inc	DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	esi, DWORD PTR _jJ$222922[esp+96]
	add	DWORD PTR tv1680[esp+96], 24		; 00000018H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	esi
	add	eax, edx
	mov	DWORD PTR _jJ$222922[esp+96], esi
	cmp	esi, eax
	jb	$LL6@ExecuteNav@2
$LN4@ExecuteNav@2:

; 5737 : 					}
; 5738 : 					iLeastUnitsToPlace--;

	sub	DWORD PTR _iLeastUnitsToPlace$222916[esp+96], 1

; 5739 : 					if(iLeastUnitsToPlace == 0)

	jne	SHORT $LN9@ExecuteNav@2

; 5740 : 					{
; 5741 : 						bDone = true;

	mov	BYTE PTR _bDone$222891[esp+92], 1
$LN9@ExecuteNav@2:

; 5707 : 
; 5708 : #ifdef AUI_ITERATORIZE
; 5709 : 			for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it2 = m_TempTargets.begin(); it2 != m_TempTargets.end() && !bDone; ++it2)
; 5710 : 			{
; 5711 : 				pLoopPlot = GC.getMap().plot(it2->GetTargetX(), it2->GetTargetY());
; 5712 : #else
; 5713 : 			for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	eax, DWORD PTR _iI$222917[esp+96]
	add	DWORD PTR tv1699[esp+96], 28		; 0000001cH
	inc	eax
	mov	DWORD PTR _iI$222917[esp+96], eax
	cmp	eax, DWORD PTR [ebp+23708]
	jb	$LL337@ExecuteNav@2
$LN8@ExecuteNav@2:

; 5742 : 					}
; 5743 : 				}
; 5744 : 			}
; 5745 : 
; 5746 : 			// Now ready to make the assignments
; 5747 : 			AssignDeployingUnits(iLeastUnits - iLeastUnitsToPlace);

	mov	esi, DWORD PTR _iLeastUnits$[esp+96]
	mov	ecx, esi
	sub	ecx, DWORD PTR _iLeastUnitsToPlace$222916[esp+96]
	push	ecx
	mov	ecx, ebp
	call	?AssignDeployingUnits@CvTacticalAI@@AAE_NH@Z ; CvTacticalAI::AssignDeployingUnits

; 5748 : 			PerformChosenMoves(2);

	push	2
	mov	ecx, ebp
	call	?PerformChosenMoves@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::PerformChosenMoves

; 5749 : 
; 5750 : 			if(m_ChosenBlocks.size() < (unsigned int)iLeastUnits)

	cmp	DWORD PTR [ebp+27432], esi
	jae	SHORT $LN348@ExecuteNav@2

; 5751 : 			{
; 5752 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN348@ExecuteNav@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN348@ExecuteNav@2

; 5753 : 				{
; 5754 : 					CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222932[esp+96]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5755 : 					strMsg.Format("No naval deployment move for %d units in second pass", iLeastUnits - m_ChosenBlocks.size());

	sub	esi, DWORD PTR [ebp+27432]
	lea	edx, DWORD PTR _strMsg$222932[esp+96]
	push	esi
	push	OFFSET $SG222933
	push	edx
	mov	BYTE PTR __$EHRec$[esp+116], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5756 : 					LogTacticalMessage(strMsg);

	push	1
	lea	eax, DWORD PTR _strMsg$222932[esp+100]
	push	eax
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 5757 : 				}

	lea	ecx, DWORD PTR _strMsg$222932[esp+96]
	mov	BYTE PTR __$EHRec$[esp+104], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN348@ExecuteNav@2:
	pop	esi
	pop	ebx
$LN1@ExecuteNav@2:

; 5758 : 			}
; 5759 : 		}
; 5760 : 	}
; 5761 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR _strLogString$222888[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR _strMsg$222908[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$3:
	lea	ecx, DWORD PTR _strMsg$222932[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ENDP ; CvTacticalAI::ExecuteNavalFormationMoves
PUBLIC	?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ; CvTacticalAI::ExecuteFleetMoveToTarget
EXTRN	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z:PROC ; CvMultiUnitFormationInfo::getFormationSlotEntry
EXTRN	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z:PROC ; CvGlobals::getMultiUnitFormationInfo
EXTRN	?GetFormationIndex@CvArmyAI@@QBEHXZ:PROC	; CvArmyAI::GetFormationIndex
EXTRN	?GetNumFormationEntries@CvArmyAI@@QBEHXZ:PROC	; CvArmyAI::GetNumFormationEntries
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$0
__ehfuncinfo$?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T302305 = -24						; size = 4
_pUnit$222958 = -20					; size = 8
__$EHRec$ = -12						; size = 12
tv245 = 8						; size = 4
_pArmy$ = 8						; size = 4
_pTarget$ = 12						; size = 4
?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z PROC ; CvTacticalAI::ExecuteFleetMoveToTarget, COMDAT
; _this$ = ecx

; 5797 : {

	push	-1
	push	__ehhandler$?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp

; 5798 : 	// Request moves for all units
; 5799 : 	for(int iI = 0; iI < pArmy->GetNumFormationEntries(); iI++)

	mov	ebp, DWORD PTR _pArmy$[esp+32]
	push	esi
	mov	DWORD PTR _this$[esp+40], ecx
	push	edi
	mov	ecx, ebp
	xor	ebx, ebx
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	$LN4@ExecuteFle
	mov	DWORD PTR tv245[esp+40], ebx
$LN6@ExecuteFle:

; 5800 : 	{
; 5801 : 		CvArmyFormationSlot* pSlot = pArmy->GetFormationSlot(iI);

	mov	edi, DWORD PTR [ebp+44]
	add	edi, DWORD PTR tv245[esp+40]

; 5802 : 		if(pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [edi]
	cmp	eax, -1
	je	$LN5@ExecuteFle

; 5803 : 		{
; 5804 : 			UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	push	eax
	mov	eax, DWORD PTR _this$[esp+48]
	mov	ecx, DWORD PTR [eax]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$222958[esp+44], esi
	mov	BYTE PTR _pUnit$222958[esp+48], 0
	test	esi, esi
	je	SHORT $LN22@ExecuteFle
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN22@ExecuteFle:
	mov	DWORD PTR __$EHRec$[esp+52], 0

; 5805 : 			if(pUnit && !pUnit->TurnProcessed())

	test	esi, esi
	je	SHORT $LN1@ExecuteFle
	mov	ecx, esi
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	SHORT $LN1@ExecuteFle

; 5806 : 			{
; 5807 : 				pSlot->SetStartedOnOperation(true);
; 5808 : 
; 5809 : 				CvMultiUnitFormationInfo* pkMultiUnitFormation = GC.getMultiUnitFormationInfo(pArmy->GetFormationIndex());

	mov	ecx, ebp
	mov	DWORD PTR [edi+8], 1
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo

; 5810 : 				if(pkMultiUnitFormation)

	test	eax, eax
	je	SHORT $LN1@ExecuteFle

; 5811 : 				{
; 5812 : 					const CvFormationSlotEntry& thisSlotEntry = pkMultiUnitFormation->getFormationSlotEntry(iI);

	push	ebx
	mov	ecx, eax
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry

; 5813 : 					MoveWithFormation(pUnit, thisSlotEntry.m_ePositionType);

	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T302305[esp+56], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, DWORD PTR _this$[esp+56]
	call	?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ; CvTacticalAI::MoveWithFormation
$LN1@ExecuteFle:

; 5814 : 				}
; 5815 : 			}
; 5816 : 		}

	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	esi, esi
	je	SHORT $LN5@ExecuteFle
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@ExecuteFle:
	add	DWORD PTR tv245[esp+40], 12		; 0000000cH
	mov	ecx, ebp
	inc	ebx
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	ebx, eax
	jl	$LN6@ExecuteFle
$LN4@ExecuteFle:

; 5817 : 	}
; 5818 : 	ExecuteNavalFormationMoves(pArmy, pTarget);

	mov	edx, DWORD PTR _pTarget$[esp+40]
	mov	ecx, DWORD PTR _this$[esp+44]
	push	edx
	push	ebp
	call	?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ; CvTacticalAI::ExecuteNavalFormationMoves

; 5819 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$222958[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ENDP ; CvTacticalAI::ExecuteFleetMoveToTarget
PUBLIC	?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::ExecuteCloseOnTarget
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z$0
__ehfuncinfo$?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
_iMeleeUnits$ = -60					; size = 4
_iRangedUnits$ = -56					; size = 4
tv1848 = -52						; size = 4
_iMeleeUnitsToPlace$224596 = -52			; size = 4
_it$ = -52						; size = 4
tv1894 = -48						; size = 4
_pLoopPlot$224604 = -48					; size = 4
_pTargetPlot$ = -48					; size = 4
_pLoopPlot$224619 = -44					; size = 4
_iRangedUnitsToPlace$224595 = -44			; size = 4
_unit$ = -44						; size = 8
$T302723 = -36						; size = 4
_iI$224613 = -36					; size = 4
_jJ$224606 = -36					; size = 4
_jJ$224621 = -32					; size = 4
_iI$224598 = -32					; size = 4
_iTacticalRadius$ = -32					; size = 4
_block$224625 = -28					; size = 16
_block$224610 = -28					; size = 16
_pUnit$224575 = -28					; size = 8
__$EHRec$ = -12						; size = 12
_bLandOnly$224592 = 8					; size = 1
_bDone$224597 = 8					; size = 1
_kTarget$ = 8						; size = 4
tv1913 = 12						; size = 4
tv1867 = 12						; size = 4
_pZone$ = 12						; size = 4
?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z PROC ; CvTacticalAI::ExecuteCloseOnTarget, COMDAT
; _this$ = ecx

; 8149 : {

	push	-1
	push	__ehhandler$?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	ebp
	push	esi

; 8150 : 	CvOperationUnit unit;

	xor	ebx, ebx
	mov	esi, ecx

; 8151 : 	int iDistance;
; 8152 : 	CvPlot* pTargetPlot;
; 8153 : 	int iRangedUnits = 0;
; 8154 : 	int iMeleeUnits = 0;
; 8155 : 	int iGenerals = 0;
; 8156 : 	list<int>::iterator it;
; 8157 : 	int iTacticalRadius = GC.getGame().GetTacticalAnalysisMap()->GetTacticalRange();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	mov	DWORD PTR _unit$[esp+76], ebx
	mov	DWORD PTR _unit$[esp+80], -1
	mov	DWORD PTR _iRangedUnits$[esp+76], ebx
	mov	DWORD PTR _iMeleeUnits$[esp+76], ebx
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _iTacticalRadius$[esp+76], eax

; 8158 : 
; 8159 : 	pTargetPlot = GC.getMap().plot(kTarget.GetTargetX(), kTarget.GetTargetY());

	mov	eax, DWORD PTR _kTarget$[esp+72]
	mov	edi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN57@ExecuteClo
	cmp	edi, -2147483647			; 80000001H
	je	$LN57@ExecuteClo
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN67@ExecuteClo
	cmp	eax, ebx
	jge	SHORT $LN69@ExecuteClo
	cdq
	idiv	ecx
	mov	ebp, edx
	add	ebp, ecx
	jmp	SHORT $LN71@ExecuteClo
$LN69@ExecuteClo:
	cmp	eax, ecx
	jl	SHORT $LN67@ExecuteClo
	cdq
	idiv	ecx
	mov	ebp, edx
	jmp	SHORT $LN71@ExecuteClo
$LN67@ExecuteClo:
	mov	ebp, eax
$LN71@ExecuteClo:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebx, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN447@ExecuteClo
	test	edi, edi
	jge	SHORT $LN79@ExecuteClo
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN81@ExecuteClo
$LN79@ExecuteClo:
	cmp	edi, ebx
	jl	SHORT $LN447@ExecuteClo
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN81@ExecuteClo
$LN447@ExecuteClo:
	mov	edx, edi
$LN81@ExecuteClo:
	test	ebp, ebp
	jl	SHORT $LN61@ExecuteClo
	cmp	ebp, ecx
	jge	SHORT $LN61@ExecuteClo
	test	edx, edx
	jl	SHORT $LN61@ExecuteClo
	cmp	edx, ebx
	jge	SHORT $LN61@ExecuteClo
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, ebp
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	xor	ebx, ebx
	mov	DWORD PTR _pTargetPlot$[esp+76], ecx
	jmp	SHORT $LN59@ExecuteClo
$LN61@ExecuteClo:
	mov	DWORD PTR _pTargetPlot$[esp+76], 0
	xor	ebx, ebx
	jmp	SHORT $LN59@ExecuteClo
$LN57@ExecuteClo:
	mov	DWORD PTR _pTargetPlot$[esp+76], ebx
$LN59@ExecuteClo:

; 8160 : 	m_OperationUnits.clear();

	lea	ebp, DWORD PTR [esi+28644]
	mov	DWORD PTR [ebp+4], ebx

; 8161 : 	m_GeneralsToMove.clear();

	mov	DWORD PTR [esi+28824], ebx

; 8162 : 
; 8163 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 8164 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 8165 : #else
; 8166 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _it$[esp+76], ecx
	cmp	ecx, eax
	je	$LN35@ExecuteClo
$LL123@ExecuteClo:

; 8167 : #endif
; 8168 : 	{
; 8169 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR _it$[esp+76]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$224575[esp+76], edi
	mov	BYTE PTR _pUnit$224575[esp+80], 0
	test	edi, edi
	je	SHORT $LN146@ExecuteClo
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN146@ExecuteClo:
	mov	DWORD PTR __$EHRec$[esp+84], 0

; 8170 : 		if(pUnit)

	test	edi, edi
	je	$LN23@ExecuteClo

; 8171 : 		{
; 8172 : 			// If not naval invasion, proper domain of unit?
; 8173 : 			if(pZone->IsNavalInvasion() ||
; 8174 : 			        (pZone->IsWater() && pUnit->getDomainType() == DOMAIN_SEA || !pZone->IsWater() && pUnit->getDomainType() == DOMAIN_LAND))

	mov	ebx, DWORD PTR _pZone$[esp+72]
	cmp	BYTE PTR [ebx+69], 0
	jne	SHORT $LN31@ExecuteClo
	cmp	BYTE PTR [ebx+68], 0
	je	SHORT $LN450@ExecuteClo
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN31@ExecuteClo
	cmp	BYTE PTR [ebx+68], 0
	jne	$LN23@ExecuteClo
$LN450@ExecuteClo:
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	$LN23@ExecuteClo
$LN31@ExecuteClo:

; 8175 : 			{
; 8176 : 				// Find units really close to target or somewhat close that just came out of an operation
; 8177 : 				iDistance = plotDistance(pUnit->getX(), pUnit->getY(), kTarget.GetTargetX(), kTarget.GetTargetY());

	mov	ecx, DWORD PTR _kTarget$[esp+72]
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [edi+88]
	mov	ebx, DWORD PTR [edi+76]
	push	eax
	push	ecx
	push	edx
	push	ebx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 8178 : 				if(iDistance <= iTacticalRadius || (iDistance <= (GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE() * 3) && pUnit->GetDeployFromOperationTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS() >= GC.getGame().getGameTurn()))

	cmp	eax, DWORD PTR _iTacticalRadius$[esp+76]
	jle	SHORT $LN28@ExecuteClo
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420
	lea	edx, DWORD PTR [ecx+ecx*2]
	cmp	eax, edx
	jg	$LN23@ExecuteClo
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, DWORD PTR [edi+124]
	mov	DWORD PTR $T302723[esp+76], eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR $T302723[esp+76]
	add	ecx, ebx
	cmp	ecx, eax
	jl	$LN23@ExecuteClo
$LN28@ExecuteClo:

; 8179 : 				{
; 8180 : 					unit.SetUnitID(pUnit->GetID());

	mov	edx, DWORD PTR [edi+100]

; 8181 : 
; 8182 : 					if(pUnit->IsCanAttackRanged())

	mov	ecx, edi
	mov	DWORD PTR _unit$[esp+76], edx
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	SHORT $LN27@ExecuteClo

; 8183 : 					{
; 8184 : 						unit.SetPosition((MultiunitPositionTypes)m_CachedInfoTypes[eMUPOSITION_BOMBARD]);
; 8185 : 						iRangedUnits++;
; 8186 : 						m_OperationUnits.push_back(unit);

	mov	eax, DWORD PTR [ebp+8]
	inc	DWORD PTR _iRangedUnits$[esp+76]
	mov	ebx, DWORD PTR [esi+29384]
	mov	BYTE PTR [ebp+172], 0
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN200@ExecuteClo
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::GrowSize
$LN200@ExecuteClo:
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN203@ExecuteClo
	mov	edx, DWORD PTR _unit$[esp+76]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
$LN203@ExecuteClo:
	inc	DWORD PTR [ebp+4]
	jmp	SHORT $LN23@ExecuteClo
$LN27@ExecuteClo:

; 8187 : 
; 8188 : 					}
; 8189 : 					else if(pUnit->IsGreatGeneral() || pUnit->IsGreatAdmiral())

	mov	ecx, edi
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	test	al, al
	jne	SHORT $LN24@ExecuteClo
	mov	ecx, edi
	call	?IsGreatAdmiral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatAdmiral
	test	al, al
	jne	SHORT $LN24@ExecuteClo

; 8194 : 					}
; 8195 : 					else
; 8196 : 					{
; 8197 : 						unit.SetPosition((MultiunitPositionTypes)m_CachedInfoTypes[eMUPOSITION_FRONT_LINE]);

	mov	eax, DWORD PTR [esi+29388]

; 8198 : 						iMeleeUnits++;

	inc	DWORD PTR _iMeleeUnits$[esp+76]

; 8199 : 						m_OperationUnits.push_back(unit);

	lea	ecx, DWORD PTR _unit$[esp+76]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR _unit$[esp+84], eax
	call	?push_back@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvOperationUnit@@@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::push_back
	jmp	SHORT $LN23@ExecuteClo
$LN24@ExecuteClo:

; 8190 : 					{
; 8191 : 						unit.SetPosition((MultiunitPositionTypes)m_CachedInfoTypes[eMUPOSITION_CIVILIAN_SUPPORT]);

	mov	edx, DWORD PTR [esi+29376]

; 8192 : 						iGenerals++;
; 8193 : 						m_GeneralsToMove.push_back(unit);

	mov	eax, DWORD PTR [esi+28828]
	lea	ebx, DWORD PTR [esi+28820]
	mov	DWORD PTR _unit$[esp+80], edx
	mov	BYTE PTR [ebx+172], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN213@ExecuteClo
	push	eax
	mov	ecx, ebx
	call	?GrowSize@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::GrowSize
$LN213@ExecuteClo:
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN216@ExecuteClo
	mov	edx, DWORD PTR _unit$[esp+76]
	mov	ecx, DWORD PTR _unit$[esp+80]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
$LN216@ExecuteClo:
	inc	DWORD PTR [ebx+4]
$LN23@ExecuteClo:

; 8200 : 					}
; 8201 : 				}
; 8202 : 			}
; 8203 : 		}
; 8204 : 	}

	mov	DWORD PTR __$EHRec$[esp+84], -1
	test	edi, edi
	je	SHORT $LN36@ExecuteClo
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN36@ExecuteClo:
	mov	edx, DWORD PTR _it$[esp+76]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$[esp+76], eax
	cmp	eax, DWORD PTR [esi+12]
	jne	$LL123@ExecuteClo
$LN35@ExecuteClo:

; 8205 : 
; 8206 : 	// If have any units to move...
; 8207 : 	if(m_OperationUnits.size() > 0)

	xor	edi, edi
	cmp	DWORD PTR [esi+28648], edi
	jbe	$LN22@ExecuteClo

; 8208 : 	{
; 8209 : 		/* Land only unless invasion or no enemy naval presence */
; 8210 : 		bool bLandOnly = true;
; 8211 : 		if (pZone->IsNavalInvasion() || pZone->GetEnemyNavalUnitCount() == 0)

	mov	eax, DWORD PTR _pZone$[esp+72]
	cmp	BYTE PTR [eax+69], 0
	mov	BYTE PTR _bLandOnly$224592[esp+72], 1
	jne	SHORT $LN20@ExecuteClo
	cmp	DWORD PTR [eax+56], edi
	jne	SHORT $LN21@ExecuteClo
$LN20@ExecuteClo:

; 8212 : 		{
; 8213 : 			bLandOnly = false;

	mov	BYTE PTR _bLandOnly$224592[esp+72], 0
$LN21@ExecuteClo:

; 8214 : 		}
; 8215 : 		ScoreCloseOnPlots(pTargetPlot, bLandOnly);

	mov	eax, DWORD PTR _bLandOnly$224592[esp+72]
	mov	ecx, DWORD PTR _pTargetPlot$[esp+76]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?ScoreCloseOnPlots@CvTacticalAI@@AAEHPAVCvPlot@@_N@Z ; CvTacticalAI::ScoreCloseOnPlots

; 8216 : 
; 8217 : 		// Compute the moves to get the best deployment
; 8218 : 		std::stable_sort(m_TempTargets.begin(), m_TempTargets.end());

	mov	eax, DWORD PTR [esi+23708]
	mov	ecx, DWORD PTR [esi+23704]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, ecx
	lea	eax, DWORD PTR [eax+edx*4]
	cmp	ecx, eax
	je	SHORT $LN237@ExecuteClo
	push	edi
	push	edi
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 16					; 00000010H
$LN237@ExecuteClo:

; 8220 : 
; 8221 : 		int iRangedUnitsToPlace = iRangedUnits;

	mov	ecx, DWORD PTR _iRangedUnits$[esp+76]
	mov	DWORD PTR [esi+26600], edi
	mov	DWORD PTR _iRangedUnitsToPlace$224595[esp+76], ecx

; 8222 : 		int iMeleeUnitsToPlace = iMeleeUnits;
; 8223 : 
; 8224 : 		// First loop for ranged unit spots
; 8225 : 		bool bDone = false;

	mov	BYTE PTR _bDone$224597[esp+72], 0

; 8226 : #ifdef AUI_ITERATORIZE
; 8227 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it3 = m_TempTargets.begin(); it3 != m_TempTargets.end(); ++it3)
; 8228 : 		{
; 8229 : 			AITacticalTargetType eTargetType = it3->GetTargetType();
; 8230 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)
; 8231 : 			{
; 8232 : 				CvPlot* pLoopPlot = GC.getMap().plot(it3->GetTargetX(), it3->GetTargetY());
; 8233 : #else
; 8234 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	DWORD PTR _iI$224598[esp+76], edi
	cmp	DWORD PTR [esi+23708], edi
	jbe	$LN17@ExecuteClo

; 8219 : 		m_PotentialBlocks.clear();

	mov	DWORD PTR tv1867[esp+72], 0
$LL443@ExecuteClo:

; 8226 : #ifdef AUI_ITERATORIZE
; 8227 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it3 = m_TempTargets.begin(); it3 != m_TempTargets.end(); ++it3)
; 8228 : 		{
; 8229 : 			AITacticalTargetType eTargetType = it3->GetTargetType();
; 8230 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)
; 8231 : 			{
; 8232 : 				CvPlot* pLoopPlot = GC.getMap().plot(it3->GetTargetX(), it3->GetTargetY());
; 8233 : #else
; 8234 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	cmp	BYTE PTR _bDone$224597[esp+72], 0
	jne	$LN17@ExecuteClo

; 8235 : 		{
; 8236 : 			AITacticalTargetType eTargetType = m_TempTargets[iI].GetTargetType();
; 8237 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)

	mov	edx, DWORD PTR [esi+23704]
	mov	eax, DWORD PTR tv1867[esp+72]
	cmp	DWORD PTR [eax+edx], 7
	jne	$LN18@ExecuteClo

; 8238 : 			{
; 8239 : 				CvPlot* pLoopPlot = GC.getMap().plot(m_TempTargets[iI].GetTargetX(), m_TempTargets[iI].GetTargetY());

	mov	ecx, edx
	mov	edx, eax
	mov	ebp, DWORD PTR [edx+ecx+8]
	lea	eax, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN268@ExecuteClo
	cmp	ebp, -2147483647			; 80000001H
	je	$LN268@ExecuteClo
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	ecx, DWORD PTR [ebx+4020]
	je	SHORT $LN444@ExecuteClo
	test	eax, eax
	jge	SHORT $LN280@ExecuteClo
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN282@ExecuteClo
$LN280@ExecuteClo:
	cmp	eax, ecx
	jl	SHORT $LN444@ExecuteClo
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN282@ExecuteClo
$LN444@ExecuteClo:
	mov	edi, eax
$LN282@ExecuteClo:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [eax+4057], 0
	mov	ebx, DWORD PTR [ebx+4024]
	je	SHORT $LN446@ExecuteClo
	test	ebp, ebp
	jge	SHORT $LN290@ExecuteClo
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN292@ExecuteClo
$LN290@ExecuteClo:
	cmp	ebp, ebx
	jl	SHORT $LN446@ExecuteClo
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN292@ExecuteClo
$LN446@ExecuteClo:
	mov	edx, ebp
$LN292@ExecuteClo:
	test	edi, edi
	jl	SHORT $LN268@ExecuteClo
	cmp	edi, ecx
	jge	SHORT $LN268@ExecuteClo
	test	edx, edx
	jl	SHORT $LN268@ExecuteClo
	cmp	edx, ebx
	jge	SHORT $LN268@ExecuteClo
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN451@ExecuteClo
$LN268@ExecuteClo:
	xor	ecx, ecx
$LN451@ExecuteClo:

; 8240 : #endif
; 8241 : 				if(FindClosestOperationUnit(pLoopPlot, true /*bSafeForRanged*/, true /*bMustBeRangedUnit*/))

	push	1
	push	1
	mov	DWORD PTR _pLoopPlot$224604[esp+84], ecx
	push	ecx
	mov	ecx, esi
	call	?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z ; CvTacticalAI::FindClosestOperationUnit
	test	al, al
	je	$LN18@ExecuteClo

; 8242 : 				{
; 8243 : #ifdef AUI_ITERATORIZE
; 8244 : 					for (std::vector<CvTacticalUnit>::const_iterator it2 = m_CurrentMoveUnits.begin(); it2 != m_CurrentMoveUnits.end(); ++it2)
; 8245 : 					{
; 8246 : 						CvBlockingUnit block;
; 8247 : 						block.SetUnitID(it2->GetID());
; 8248 : 						block.SetPlot(pLoopPlot);
; 8249 : 						block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 8250 : 						block.SetDistanceToTarget(it2->GetMovesToTarget());
; 8251 : #else
; 8252 : 					for(unsigned int jJ = 0; jJ < m_CurrentMoveUnits.size(); jJ++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _jJ$224606[esp+76], 0
	je	$LN12@ExecuteClo
	lea	edi, DWORD PTR [esi+26596]
	mov	DWORD PTR tv1848[esp+76], 0
	npad	8
$LL14@ExecuteClo:

; 8253 : 					{
; 8254 : 						CvBlockingUnit block;
; 8255 : 						block.SetUnitID(m_CurrentMoveUnits[jJ].GetID());

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR tv1848[esp+76]
	mov	eax, DWORD PTR [edx+ecx]
	lea	ebx, DWORD PTR [edx+ecx]

; 8256 : 						block.SetPlot(pLoopPlot);
; 8257 : 						block.SetNumChoices((int)m_CurrentMoveUnits.size());

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]

; 8258 : 						block.SetDistanceToTarget(m_CurrentMoveUnits[jJ].GetMovesToTarget());

	mov	ebx, DWORD PTR [ebx+12]
	mov	DWORD PTR _block$224610[esp+80], eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 8259 : #endif
; 8260 : 						m_PotentialBlocks.push_back(block);

	mov	eax, DWORD PTR [edi+8]
	sar	edx, 2
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH
	add	ebp, edx
	mov	BYTE PTR [edi+412], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN328@ExecuteClo
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
$LN328@ExecuteClo:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN331@ExecuteClo
	mov	ecx, DWORD PTR _pLoopPlot$224604[esp+76]
	mov	edx, DWORD PTR _block$224610[esp+80]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebx
$LN331@ExecuteClo:
	inc	DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	ebx, DWORD PTR _jJ$224606[esp+76]
	add	DWORD PTR tv1848[esp+76], 24		; 00000018H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	mov	DWORD PTR _jJ$224606[esp+76], ebx
	cmp	ebx, eax
	jb	$LL14@ExecuteClo
$LN12@ExecuteClo:

; 8261 : 					}
; 8262 : 
; 8263 : 					iRangedUnitsToPlace--;

	sub	DWORD PTR _iRangedUnitsToPlace$224595[esp+76], 1

; 8264 : 					if(iRangedUnitsToPlace == 0)

	jne	SHORT $LN18@ExecuteClo

; 8265 : 					{
; 8266 : 						bDone = true;

	mov	BYTE PTR _bDone$224597[esp+72], 1
$LN18@ExecuteClo:

; 8226 : #ifdef AUI_ITERATORIZE
; 8227 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it3 = m_TempTargets.begin(); it3 != m_TempTargets.end(); ++it3)
; 8228 : 		{
; 8229 : 			AITacticalTargetType eTargetType = it3->GetTargetType();
; 8230 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)
; 8231 : 			{
; 8232 : 				CvPlot* pLoopPlot = GC.getMap().plot(it3->GetTargetX(), it3->GetTargetY());
; 8233 : #else
; 8234 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	eax, DWORD PTR _iI$224598[esp+76]
	add	DWORD PTR tv1867[esp+72], 28		; 0000001cH
	inc	eax
	mov	DWORD PTR _iI$224598[esp+76], eax
	cmp	eax, DWORD PTR [esi+23708]
	jb	$LL443@ExecuteClo
$LN17@ExecuteClo:

; 8267 : 					}
; 8268 : 				}
; 8269 : 			}
; 8270 : 		}
; 8271 : 		AssignDeployingUnits(iRangedUnits - iRangedUnitsToPlace);

	mov	eax, DWORD PTR _iRangedUnits$[esp+76]
	mov	edi, DWORD PTR _iRangedUnitsToPlace$224595[esp+76]
	sub	eax, edi
	push	eax
	mov	ecx, esi
	call	?AssignDeployingUnits@CvTacticalAI@@AAE_NH@Z ; CvTacticalAI::AssignDeployingUnits

; 8272 : 		PerformChosenMoves();

	push	1
	mov	ecx, esi
	call	?PerformChosenMoves@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::PerformChosenMoves

; 8273 : 
; 8274 : 		// Second loop for everyone else (including remaining ranged units)
; 8275 : 		m_PotentialBlocks.clear();
; 8276 : 		iMeleeUnits += iRangedUnitsToPlace;

	mov	eax, DWORD PTR _iMeleeUnits$[esp+76]
	xor	ecx, ecx
	add	eax, edi
	mov	DWORD PTR [esi+26600], ecx
	mov	DWORD PTR _iMeleeUnits$[esp+76], eax
	mov	DWORD PTR _iMeleeUnitsToPlace$224596[esp+76], eax

; 8277 : 		iMeleeUnitsToPlace += iRangedUnitsToPlace;
; 8278 : 		bDone = false;

	mov	BYTE PTR _bDone$224597[esp+72], cl

; 8279 : #ifdef AUI_ITERATORIZE
; 8280 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it3 = m_TempTargets.begin(); it3 != m_TempTargets.end(); ++it3)
; 8281 : 		{
; 8282 : 			AITacticalTargetType eTargetType = it3->GetTargetType();
; 8283 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)
; 8284 : 			{
; 8285 : 				CvPlot* pLoopPlot = GC.getMap().plot(it3->GetTargetX(), it3->GetTargetY());
; 8286 : #else
; 8287 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	DWORD PTR _iI$224613[esp+76], ecx
	cmp	DWORD PTR [esi+23708], ecx
	jbe	$LN8@ExecuteClo

; 8267 : 					}
; 8268 : 				}
; 8269 : 			}
; 8270 : 		}
; 8271 : 		AssignDeployingUnits(iRangedUnits - iRangedUnitsToPlace);

	mov	DWORD PTR tv1913[esp+72], ecx
	npad	2
$LL441@ExecuteClo:

; 8279 : #ifdef AUI_ITERATORIZE
; 8280 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it3 = m_TempTargets.begin(); it3 != m_TempTargets.end(); ++it3)
; 8281 : 		{
; 8282 : 			AITacticalTargetType eTargetType = it3->GetTargetType();
; 8283 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)
; 8284 : 			{
; 8285 : 				CvPlot* pLoopPlot = GC.getMap().plot(it3->GetTargetX(), it3->GetTargetY());
; 8286 : #else
; 8287 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	cmp	BYTE PTR _bDone$224597[esp+72], 0
	jne	$LN8@ExecuteClo

; 8288 : 		{
; 8289 : 			AITacticalTargetType eTargetType = m_TempTargets[iI].GetTargetType();
; 8290 : 			if (eTargetType != AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)

	mov	ecx, DWORD PTR [esi+23704]
	mov	edx, DWORD PTR tv1913[esp+72]
	cmp	DWORD PTR [edx+ecx], 7
	je	$LN9@ExecuteClo

; 8291 : 			{
; 8292 : 				CvPlot* pLoopPlot = GC.getMap().plot(m_TempTargets[iI].GetTargetX(), m_TempTargets[iI].GetTargetY());

	mov	eax, ecx
	mov	ecx, edx
	mov	ebp, DWORD PTR [eax+ecx+8]
	add	eax, ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN359@ExecuteClo
	cmp	ebp, -2147483647			; 80000001H
	je	$LN359@ExecuteClo
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	ecx, DWORD PTR [ebx+4020]
	je	SHORT $LN442@ExecuteClo
	test	eax, eax
	jge	SHORT $LN371@ExecuteClo
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN373@ExecuteClo
$LN371@ExecuteClo:
	cmp	eax, ecx
	jl	SHORT $LN442@ExecuteClo
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN373@ExecuteClo
$LN442@ExecuteClo:
	mov	edi, eax
$LN373@ExecuteClo:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4057], 0
	mov	ebx, DWORD PTR [ebx+4024]
	je	SHORT $LN445@ExecuteClo
	test	ebp, ebp
	jge	SHORT $LN381@ExecuteClo
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN383@ExecuteClo
$LN381@ExecuteClo:
	cmp	ebp, ebx
	jl	SHORT $LN445@ExecuteClo
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN383@ExecuteClo
$LN445@ExecuteClo:
	mov	edx, ebp
$LN383@ExecuteClo:
	test	edi, edi
	jl	SHORT $LN359@ExecuteClo
	cmp	edi, ecx
	jge	SHORT $LN359@ExecuteClo
	test	edx, edx
	jl	SHORT $LN359@ExecuteClo
	cmp	edx, ebx
	jge	SHORT $LN359@ExecuteClo
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	jmp	SHORT $LN452@ExecuteClo
$LN359@ExecuteClo:
	xor	ecx, ecx
$LN452@ExecuteClo:

; 8293 : #endif
; 8294 : 				if(FindClosestOperationUnit(pLoopPlot, true /*bSafeForRanged*/, false /*bMustBeRangedUnit*/))

	push	0
	push	1
	mov	DWORD PTR _pLoopPlot$224619[esp+84], ecx
	push	ecx
	mov	ecx, esi
	call	?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z ; CvTacticalAI::FindClosestOperationUnit
	test	al, al
	je	$LN9@ExecuteClo

; 8295 : 				{
; 8296 : #ifdef AUI_ITERATORIZE
; 8297 : 					for (std::vector<CvTacticalUnit>::const_iterator it2 = m_CurrentMoveUnits.begin(); it2 != m_CurrentMoveUnits.end(); ++it2)
; 8298 : 					{
; 8299 : 						CvBlockingUnit block;
; 8300 : 						block.SetUnitID(it2->GetID());
; 8301 : 						block.SetPlot(pLoopPlot);
; 8302 : 						block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 8303 : 						block.SetDistanceToTarget(it2->GetMovesToTarget());
; 8304 : #else
; 8305 : 					for(unsigned int jJ = 0; jJ < m_CurrentMoveUnits.size(); jJ++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _jJ$224621[esp+76], 0
	je	$LN3@ExecuteClo
	lea	edi, DWORD PTR [esi+26596]
	mov	DWORD PTR tv1894[esp+76], 0
$LL5@ExecuteClo:

; 8306 : 					{
; 8307 : 						CvBlockingUnit block;
; 8308 : 						block.SetUnitID(m_CurrentMoveUnits[jJ].GetID());

	mov	edx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR tv1894[esp+76]
	mov	ecx, DWORD PTR [eax+edx]
	lea	ebx, DWORD PTR [eax+edx]

; 8309 : 						block.SetPlot(pLoopPlot);
; 8310 : 						block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 8311 : 						block.SetDistanceToTarget(m_CurrentMoveUnits[jJ].GetMovesToTarget());

	mov	ebx, DWORD PTR [ebx+12]
	mov	DWORD PTR _block$224625[esp+80], ecx
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 8312 : #endif
; 8313 : 						m_PotentialBlocks.push_back(block);

	mov	eax, DWORD PTR [edi+8]
	sar	edx, 2
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH
	add	ebp, edx
	mov	BYTE PTR [edi+412], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN419@ExecuteClo
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
$LN419@ExecuteClo:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN422@ExecuteClo
	mov	edx, DWORD PTR _pLoopPlot$224619[esp+76]
	mov	ecx, DWORD PTR _block$224625[esp+80]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebx
$LN422@ExecuteClo:
	inc	DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	ebx, DWORD PTR _jJ$224621[esp+76]
	add	DWORD PTR tv1894[esp+76], 24		; 00000018H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	mov	DWORD PTR _jJ$224621[esp+76], ebx
	cmp	ebx, eax
	jb	$LL5@ExecuteClo
$LN3@ExecuteClo:

; 8314 : 					}
; 8315 : 
; 8316 : 					iMeleeUnitsToPlace--;

	sub	DWORD PTR _iMeleeUnitsToPlace$224596[esp+76], 1

; 8317 : 					if(iMeleeUnitsToPlace == 0)

	jne	SHORT $LN9@ExecuteClo

; 8318 : 					{
; 8319 : 						bDone = true;

	mov	BYTE PTR _bDone$224597[esp+72], 1
$LN9@ExecuteClo:

; 8279 : #ifdef AUI_ITERATORIZE
; 8280 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it3 = m_TempTargets.begin(); it3 != m_TempTargets.end(); ++it3)
; 8281 : 		{
; 8282 : 			AITacticalTargetType eTargetType = it3->GetTargetType();
; 8283 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)
; 8284 : 			{
; 8285 : 				CvPlot* pLoopPlot = GC.getMap().plot(it3->GetTargetX(), it3->GetTargetY());
; 8286 : #else
; 8287 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	eax, DWORD PTR _iI$224613[esp+76]
	add	DWORD PTR tv1913[esp+72], 28		; 0000001cH
	inc	eax
	mov	DWORD PTR _iI$224613[esp+76], eax
	cmp	eax, DWORD PTR [esi+23708]
	jb	$LL441@ExecuteClo
$LN8@ExecuteClo:

; 8320 : 					}
; 8321 : 				}
; 8322 : 			}
; 8323 : 		}
; 8324 : 		AssignDeployingUnits(iMeleeUnits - iMeleeUnitsToPlace);

	mov	eax, DWORD PTR _iMeleeUnits$[esp+76]
	sub	eax, DWORD PTR _iMeleeUnitsToPlace$224596[esp+76]
	mov	ecx, esi
	push	eax
	call	?AssignDeployingUnits@CvTacticalAI@@AAE_NH@Z ; CvTacticalAI::AssignDeployingUnits

; 8325 : 		PerformChosenMoves();

	push	1
	mov	ecx, esi
	call	?PerformChosenMoves@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::PerformChosenMoves
$LN22@ExecuteClo:

; 8326 : 	}
; 8327 : 
; 8328 : 	if(m_GeneralsToMove.size() > 0)

	cmp	DWORD PTR [esi+28824], 0
	jbe	SHORT $LN1@ExecuteClo

; 8329 : 	{
; 8330 : 		MoveGreatGeneral();

	push	0
	mov	ecx, esi
	call	?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ; CvTacticalAI::MoveGreatGeneral
$LN1@ExecuteClo:

; 8331 : 	}
; 8332 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 60					; 0000003cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$224575[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z ENDP ; CvTacticalAI::ExecuteCloseOnTarget
PUBLIC	?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::ExecuteHedgehogDefense
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z$0
__ehfuncinfo$?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
_iMeleeUnits$ = -68					; size = 4
_iRangedUnits$ = -64					; size = 4
_pLoopPlot$224676 = -60					; size = 4
_iMeleeUnitsToPlace$224668 = -60			; size = 4
_pTargetPlot$ = -60					; size = 4
tv1688 = -56						; size = 4
tv1642 = -56						; size = 4
_pUnit$224651 = -56					; size = 8
_pLoopPlot$224691 = -48					; size = 4
_iRangedUnitsToPlace$224667 = -48			; size = 4
_operationUnit$224659 = -48				; size = 8
_iI$224685 = -40					; size = 4
_jJ$224678 = -40					; size = 4
_unit$ = -40						; size = 8
_jJ$224693 = -32					; size = 4
_iI$224670 = -32					; size = 4
_iTacticalRadius$ = -32					; size = 4
_block$224697 = -28					; size = 16
_block$224682 = -28					; size = 16
__$EHRec$ = -12						; size = 12
_bDone$224669 = 8					; size = 1
_it$ = 8						; size = 4
_kTarget$ = 8						; size = 4
tv1707 = 12						; size = 4
tv1661 = 12						; size = 4
_pZone$ = 12						; size = 4
?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z PROC ; CvTacticalAI::ExecuteHedgehogDefense, COMDAT
; _this$ = ecx

; 8336 : {

	push	-1
	push	__ehhandler$?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	ebx
	push	ebp
	push	esi

; 8337 : 	CvOperationUnit unit;

	xor	ebx, ebx
	mov	esi, ecx

; 8338 : 	int iDistance;
; 8339 : 	CvPlot* pTargetPlot;
; 8340 : 	int iRangedUnits = 0;
; 8341 : 	int iMeleeUnits = 0;
; 8342 : 	list<int>::iterator it;
; 8343 : 	int iTacticalRadius = GC.getGame().GetTacticalAnalysisMap()->GetTacticalRange();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	mov	DWORD PTR _unit$[esp+84], ebx
	mov	DWORD PTR _unit$[esp+88], -1
	mov	DWORD PTR _iRangedUnits$[esp+84], ebx
	mov	DWORD PTR _iMeleeUnits$[esp+84], ebx
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	eax, DWORD PTR [eax+8]

; 8344 : 
; 8345 : 	pTargetPlot = GC.getMap().plot(kTarget.GetTargetX(), kTarget.GetTargetY());

	mov	ebp, DWORD PTR _kTarget$[esp+80]
	mov	edi, DWORD PTR [ebp+8]
	mov	DWORD PTR _iTacticalRadius$[esp+84], eax
	mov	eax, DWORD PTR [ebp+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN53@ExecuteHed
	cmp	edi, -2147483647			; 80000001H
	je	$LN53@ExecuteHed
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN63@ExecuteHed
	cmp	eax, ebx
	jge	SHORT $LN65@ExecuteHed
	cdq
	idiv	ecx
	mov	ebx, edx
	add	ebx, ecx
	jmp	SHORT $LN67@ExecuteHed
$LN65@ExecuteHed:
	cmp	eax, ecx
	jl	SHORT $LN63@ExecuteHed
	cdq
	idiv	ecx
	mov	ebx, edx
	jmp	SHORT $LN67@ExecuteHed
$LN63@ExecuteHed:
	mov	ebx, eax
$LN67@ExecuteHed:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN421@ExecuteHed
	test	edi, edi
	jge	SHORT $LN75@ExecuteHed
	mov	eax, edi
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN77@ExecuteHed
$LN75@ExecuteHed:
	cmp	edi, ebp
	jl	SHORT $LN421@ExecuteHed
	mov	eax, edi
	cdq
	idiv	ebp
	jmp	SHORT $LN77@ExecuteHed
$LN421@ExecuteHed:
	mov	edx, edi
$LN77@ExecuteHed:
	test	ebx, ebx
	jl	SHORT $LN57@ExecuteHed
	cmp	ebx, ecx
	jge	SHORT $LN57@ExecuteHed
	test	edx, edx
	jl	SHORT $LN57@ExecuteHed
	cmp	edx, ebp
	jge	SHORT $LN57@ExecuteHed
	mov	ebp, DWORD PTR _kTarget$[esp+80]
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, ebx
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pTargetPlot$[esp+84], ecx
	jmp	SHORT $LN55@ExecuteHed
$LN57@ExecuteHed:
	mov	ebp, DWORD PTR _kTarget$[esp+80]
	mov	DWORD PTR _pTargetPlot$[esp+84], 0
	jmp	SHORT $LN55@ExecuteHed
$LN53@ExecuteHed:
	mov	DWORD PTR _pTargetPlot$[esp+84], ebx
$LN55@ExecuteHed:

; 8346 : 	m_OperationUnits.clear();

	xor	eax, eax
	mov	DWORD PTR [esi+28648], eax

; 8347 : 	m_GeneralsToMove.clear();

	mov	DWORD PTR [esi+28824], eax

; 8348 : 
; 8349 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 8350 : 	for (it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)
; 8351 : #else
; 8352 : 	for(it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); it++)

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _it$[esp+80], ecx
	cmp	ecx, eax
	je	$LN31@ExecuteHed
	npad	7
$LL119@ExecuteHed:

; 8353 : #endif
; 8354 : 	{
; 8355 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR _it$[esp+80]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$224651[esp+84], edi
	mov	BYTE PTR _pUnit$224651[esp+88], 0
	test	edi, edi
	je	SHORT $LN142@ExecuteHed
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN142@ExecuteHed:
	mov	DWORD PTR __$EHRec$[esp+92], 0

; 8356 : 		if(pUnit)

	test	edi, edi
	je	$LN21@ExecuteHed

; 8357 : 		{
; 8358 : 			// Proper domain of unit?
; 8359 : 			if(pZone->IsWater() && pUnit->getDomainType() == DOMAIN_SEA || !pZone->IsWater() && pUnit->getDomainType() == DOMAIN_LAND)

	mov	ebx, DWORD PTR _pZone$[esp+80]
	cmp	BYTE PTR [ebx+68], 0
	je	SHORT $LN424@ExecuteHed
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN28@ExecuteHed
	cmp	BYTE PTR [ebx+68], 0
	jne	$LN21@ExecuteHed
$LN424@ExecuteHed:
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	$LN21@ExecuteHed
$LN28@ExecuteHed:

; 8360 : 			{
; 8361 : 				// Find units really close to target or somewhat close that just came out of an operation
; 8362 : 				iDistance = plotDistance(pUnit->getX(), pUnit->getY(), kTarget.GetTargetX(), kTarget.GetTargetY());

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [edi+88]
	mov	ebx, DWORD PTR [edi+76]
	push	eax
	push	ecx
	push	edx
	push	ebx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 8363 : 				if(iDistance <= iTacticalRadius)

	cmp	eax, DWORD PTR _iTacticalRadius$[esp+84]
	jg	SHORT $LN21@ExecuteHed

; 8364 : 				{
; 8365 : 					unit.SetUnitID(pUnit->GetID());

	mov	edx, DWORD PTR [edi+100]

; 8366 : 
; 8367 : 					if (pUnit->IsGreatGeneral())

	mov	ecx, edi
	mov	DWORD PTR _unit$[esp+84], edx
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral

; 8368 : 					{
; 8369 : 						if(pUnit->getMoves() > 0)

	mov	ecx, edi
	test	al, al
	je	SHORT $LN25@ExecuteHed
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jle	SHORT $LN21@ExecuteHed

; 8370 : 						{
; 8371 : 							CvOperationUnit operationUnit;
; 8372 : 							operationUnit.SetUnitID(pUnit->GetID());
; 8373 : 							operationUnit.SetPosition((MultiunitPositionTypes)m_CachedInfoTypes[eMUPOSITION_CIVILIAN_SUPPORT]);

	mov	ecx, DWORD PTR [esi+29376]
	mov	eax, DWORD PTR [edi+100]

; 8374 : 							m_GeneralsToMove.push_back(operationUnit);

	lea	edx, DWORD PTR _operationUnit$224659[esp+84]
	mov	DWORD PTR _operationUnit$224659[esp+88], ecx
	mov	DWORD PTR _operationUnit$224659[esp+84], eax
	push	edx
	lea	ecx, DWORD PTR [esi+28820]

; 8375 : 						}
; 8376 : 					}

	jmp	SHORT $LN425@ExecuteHed
$LN25@ExecuteHed:

; 8377 : 					else if (pUnit->IsCanAttackRanged())

	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	SHORT $LN22@ExecuteHed

; 8378 : 					{
; 8379 : 						unit.SetPosition((MultiunitPositionTypes)m_CachedInfoTypes[eMUPOSITION_BOMBARD]);

	mov	eax, DWORD PTR [esi+29384]

; 8380 : 						iRangedUnits++;

	inc	DWORD PTR _iRangedUnits$[esp+84]

; 8381 : 						m_OperationUnits.push_back(unit);

	lea	ecx, DWORD PTR _unit$[esp+84]
	mov	DWORD PTR _unit$[esp+88], eax
	push	ecx

; 8382 : 					}
; 8383 : 					else

	jmp	SHORT $LN426@ExecuteHed
$LN22@ExecuteHed:

; 8384 : 					{
; 8385 : 						unit.SetPosition((MultiunitPositionTypes)m_CachedInfoTypes[eMUPOSITION_FRONT_LINE]);

	mov	edx, DWORD PTR [esi+29388]

; 8386 : 						iMeleeUnits++;

	inc	DWORD PTR _iMeleeUnits$[esp+84]

; 8387 : 						m_OperationUnits.push_back(unit);

	lea	eax, DWORD PTR _unit$[esp+84]
	mov	DWORD PTR _unit$[esp+88], edx
	push	eax
$LN426@ExecuteHed:
	lea	ecx, DWORD PTR [esi+28644]
$LN425@ExecuteHed:
	call	?push_back@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvOperationUnit@@@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::push_back
$LN21@ExecuteHed:

; 8388 : 					}
; 8389 : 				}
; 8390 : 			}
; 8391 : 		}
; 8392 : 	}

	mov	DWORD PTR __$EHRec$[esp+92], -1
	test	edi, edi
	je	SHORT $LN32@ExecuteHed
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN32@ExecuteHed:
	mov	ecx, DWORD PTR _it$[esp+80]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _it$[esp+80], eax
	cmp	eax, DWORD PTR [esi+12]
	jne	$LL119@ExecuteHed
$LN31@ExecuteHed:

; 8393 : 
; 8394 : 	// If have any units to move...
; 8395 : 	if(m_OperationUnits.size() > 0)

	xor	edi, edi
	cmp	DWORD PTR [esi+28648], edi
	jbe	$LN20@ExecuteHed

; 8396 : 	{
; 8397 : 		ScoreHedgehogPlots(pTargetPlot);

	mov	edx, DWORD PTR _pTargetPlot$[esp+84]
	push	edx
	mov	ecx, esi
	call	?ScoreHedgehogPlots@CvTacticalAI@@AAEXPAVCvPlot@@@Z ; CvTacticalAI::ScoreHedgehogPlots

; 8398 : 
; 8399 : 		// Compute the moves to get the best deployment
; 8400 : 		std::stable_sort(m_TempTargets.begin(), m_TempTargets.end());

	mov	eax, DWORD PTR [esi+23708]
	mov	ecx, DWORD PTR [esi+23704]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, ecx
	lea	eax, DWORD PTR [eax+edx*4]
	cmp	ecx, eax
	je	SHORT $LN211@ExecuteHed
	push	edi
	push	edi
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 16					; 00000010H
$LN211@ExecuteHed:

; 8402 : 
; 8403 : 		int iRangedUnitsToPlace = iRangedUnits;

	mov	ecx, DWORD PTR _iRangedUnits$[esp+84]
	mov	DWORD PTR [esi+26600], edi
	mov	DWORD PTR _iRangedUnitsToPlace$224667[esp+84], ecx

; 8404 : 		int iMeleeUnitsToPlace = iMeleeUnits;
; 8405 : 
; 8406 : 		// First loop for ranged unit spots
; 8407 : 		bool bDone = false;

	mov	BYTE PTR _bDone$224669[esp+80], 0

; 8408 : #ifdef AUI_ITERATORIZE
; 8409 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it3 = m_TempTargets.begin(); it3 != m_TempTargets.end() && !bDone; ++it3)
; 8410 : 		{
; 8411 : 			AITacticalTargetType eTargetType = it3->GetTargetType();
; 8412 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)
; 8413 : 			{
; 8414 : 				CvPlot* pLoopPlot = GC.getMap().plot(it3->GetTargetX(), it3->GetTargetY());
; 8415 : #else
; 8416 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	DWORD PTR _iI$224670[esp+84], edi
	cmp	DWORD PTR [esi+23708], edi
	jbe	$LN17@ExecuteHed

; 8401 : 		m_PotentialBlocks.clear();

	mov	DWORD PTR tv1661[esp+80], 0
	npad	2
$LL417@ExecuteHed:

; 8408 : #ifdef AUI_ITERATORIZE
; 8409 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it3 = m_TempTargets.begin(); it3 != m_TempTargets.end() && !bDone; ++it3)
; 8410 : 		{
; 8411 : 			AITacticalTargetType eTargetType = it3->GetTargetType();
; 8412 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)
; 8413 : 			{
; 8414 : 				CvPlot* pLoopPlot = GC.getMap().plot(it3->GetTargetX(), it3->GetTargetY());
; 8415 : #else
; 8416 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	cmp	BYTE PTR _bDone$224669[esp+80], 0
	jne	$LN17@ExecuteHed

; 8417 : 		{
; 8418 : 			AITacticalTargetType eTargetType = m_TempTargets[iI].GetTargetType();
; 8419 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)

	mov	edx, DWORD PTR [esi+23704]
	mov	eax, DWORD PTR tv1661[esp+80]
	cmp	DWORD PTR [eax+edx], 7
	jne	$LN18@ExecuteHed

; 8420 : 			{
; 8421 : 				CvPlot* pLoopPlot = GC.getMap().plot(m_TempTargets[iI].GetTargetX(), m_TempTargets[iI].GetTargetY());

	mov	ecx, edx
	mov	edx, eax
	mov	ebp, DWORD PTR [edx+ecx+8]
	lea	eax, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN242@ExecuteHed
	cmp	ebp, -2147483647			; 80000001H
	je	$LN242@ExecuteHed
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	ecx, DWORD PTR [ebx+4020]
	je	SHORT $LN418@ExecuteHed
	test	eax, eax
	jge	SHORT $LN254@ExecuteHed
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN256@ExecuteHed
$LN254@ExecuteHed:
	cmp	eax, ecx
	jl	SHORT $LN418@ExecuteHed
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN256@ExecuteHed
$LN418@ExecuteHed:
	mov	edi, eax
$LN256@ExecuteHed:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [eax+4057], 0
	mov	ebx, DWORD PTR [ebx+4024]
	je	SHORT $LN420@ExecuteHed
	test	ebp, ebp
	jge	SHORT $LN264@ExecuteHed
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN266@ExecuteHed
$LN264@ExecuteHed:
	cmp	ebp, ebx
	jl	SHORT $LN420@ExecuteHed
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN266@ExecuteHed
$LN420@ExecuteHed:
	mov	edx, ebp
$LN266@ExecuteHed:
	test	edi, edi
	jl	SHORT $LN242@ExecuteHed
	cmp	edi, ecx
	jge	SHORT $LN242@ExecuteHed
	test	edx, edx
	jl	SHORT $LN242@ExecuteHed
	cmp	edx, ebx
	jge	SHORT $LN242@ExecuteHed
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN427@ExecuteHed
$LN242@ExecuteHed:
	xor	ecx, ecx
$LN427@ExecuteHed:

; 8422 : #endif
; 8423 : 				if(FindClosestOperationUnit(pLoopPlot, true /*bSafeForRanged*/, true /*bMustBeRangedUnit*/))

	push	1
	push	1
	mov	DWORD PTR _pLoopPlot$224676[esp+92], ecx
	push	ecx
	mov	ecx, esi
	call	?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z ; CvTacticalAI::FindClosestOperationUnit
	test	al, al
	je	$LN18@ExecuteHed

; 8424 : 				{
; 8425 : #ifdef AUI_ITERATORIZE
; 8426 : 					for (std::vector<CvTacticalUnit>::const_iterator it2 = m_CurrentMoveUnits.begin(); it2 != m_CurrentMoveUnits.end(); ++it2)
; 8427 : 					{
; 8428 : 						CvBlockingUnit block;
; 8429 : 						block.SetUnitID(it2->GetID());
; 8430 : 						block.SetPlot(pLoopPlot);
; 8431 : 						block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 8432 : 						block.SetDistanceToTarget(it2->GetMovesToTarget());
; 8433 : #else
; 8434 : 					for(unsigned int jJ = 0; jJ < m_CurrentMoveUnits.size(); jJ++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _jJ$224678[esp+84], 0
	je	$LN12@ExecuteHed
	lea	edi, DWORD PTR [esi+26596]
	mov	DWORD PTR tv1642[esp+84], 0
	npad	9
$LL14@ExecuteHed:

; 8435 : 					{
; 8436 : 						CvBlockingUnit block;
; 8437 : 						block.SetUnitID(m_CurrentMoveUnits[jJ].GetID());

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR tv1642[esp+84]
	mov	eax, DWORD PTR [edx+ecx]
	lea	ebx, DWORD PTR [edx+ecx]

; 8438 : 						block.SetPlot(pLoopPlot);
; 8439 : 						block.SetNumChoices((int)m_CurrentMoveUnits.size());

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]

; 8440 : 						block.SetDistanceToTarget(m_CurrentMoveUnits[jJ].GetMovesToTarget());

	mov	ebx, DWORD PTR [ebx+12]
	mov	DWORD PTR _block$224682[esp+88], eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 8441 : #endif
; 8442 : 						m_PotentialBlocks.push_back(block);

	mov	eax, DWORD PTR [edi+8]
	sar	edx, 2
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH
	add	ebp, edx
	mov	BYTE PTR [edi+412], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN302@ExecuteHed
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
$LN302@ExecuteHed:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN305@ExecuteHed
	mov	ecx, DWORD PTR _pLoopPlot$224676[esp+84]
	mov	edx, DWORD PTR _block$224682[esp+88]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebx
$LN305@ExecuteHed:
	inc	DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	ebx, DWORD PTR _jJ$224678[esp+84]
	add	DWORD PTR tv1642[esp+84], 24		; 00000018H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	mov	DWORD PTR _jJ$224678[esp+84], ebx
	cmp	ebx, eax
	jb	$LL14@ExecuteHed
$LN12@ExecuteHed:

; 8443 : 					}
; 8444 : 
; 8445 : 					iRangedUnitsToPlace--;

	sub	DWORD PTR _iRangedUnitsToPlace$224667[esp+84], 1

; 8446 : 					if(iRangedUnitsToPlace == 0)

	jne	SHORT $LN18@ExecuteHed

; 8447 : 					{
; 8448 : 						bDone = true;

	mov	BYTE PTR _bDone$224669[esp+80], 1
$LN18@ExecuteHed:

; 8408 : #ifdef AUI_ITERATORIZE
; 8409 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it3 = m_TempTargets.begin(); it3 != m_TempTargets.end() && !bDone; ++it3)
; 8410 : 		{
; 8411 : 			AITacticalTargetType eTargetType = it3->GetTargetType();
; 8412 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)
; 8413 : 			{
; 8414 : 				CvPlot* pLoopPlot = GC.getMap().plot(it3->GetTargetX(), it3->GetTargetY());
; 8415 : #else
; 8416 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	eax, DWORD PTR _iI$224670[esp+84]
	add	DWORD PTR tv1661[esp+80], 28		; 0000001cH
	inc	eax
	mov	DWORD PTR _iI$224670[esp+84], eax
	cmp	eax, DWORD PTR [esi+23708]
	jb	$LL417@ExecuteHed
$LN17@ExecuteHed:

; 8449 : 					}
; 8450 : 				}
; 8451 : 			}
; 8452 : 		}
; 8453 : 		AssignDeployingUnits(iRangedUnits - iRangedUnitsToPlace);

	mov	eax, DWORD PTR _iRangedUnits$[esp+84]
	mov	edi, DWORD PTR _iRangedUnitsToPlace$224667[esp+84]
	sub	eax, edi
	push	eax
	mov	ecx, esi
	call	?AssignDeployingUnits@CvTacticalAI@@AAE_NH@Z ; CvTacticalAI::AssignDeployingUnits

; 8454 : 		PerformChosenMoves();

	push	1
	mov	ecx, esi
	call	?PerformChosenMoves@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::PerformChosenMoves

; 8455 : 
; 8456 : 		// Second loop for everyone else (including remaining ranged units)
; 8457 : 		m_PotentialBlocks.clear();
; 8458 : 		iMeleeUnits += iRangedUnitsToPlace;

	mov	eax, DWORD PTR _iMeleeUnits$[esp+84]
	xor	ecx, ecx
	add	eax, edi
	mov	DWORD PTR [esi+26600], ecx
	mov	DWORD PTR _iMeleeUnits$[esp+84], eax
	mov	DWORD PTR _iMeleeUnitsToPlace$224668[esp+84], eax

; 8459 : 		iMeleeUnitsToPlace += iRangedUnitsToPlace;
; 8460 : 		bDone = false;

	mov	BYTE PTR _bDone$224669[esp+80], cl

; 8461 : #ifdef AUI_ITERATORIZE
; 8462 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it3 = m_TempTargets.begin(); it3 != m_TempTargets.end() && !bDone; ++it3)
; 8463 : 		{
; 8464 : 			AITacticalTargetType eTargetType = it3->GetTargetType();
; 8465 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)
; 8466 : 			{
; 8467 : 				CvPlot* pLoopPlot = GC.getMap().plot(it3->GetTargetX(), it3->GetTargetY());
; 8468 : #else
; 8469 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	DWORD PTR _iI$224685[esp+84], ecx
	cmp	DWORD PTR [esi+23708], ecx
	jbe	$LN8@ExecuteHed

; 8449 : 					}
; 8450 : 				}
; 8451 : 			}
; 8452 : 		}
; 8453 : 		AssignDeployingUnits(iRangedUnits - iRangedUnitsToPlace);

	mov	DWORD PTR tv1707[esp+80], ecx
	npad	2
$LL415@ExecuteHed:

; 8461 : #ifdef AUI_ITERATORIZE
; 8462 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it3 = m_TempTargets.begin(); it3 != m_TempTargets.end() && !bDone; ++it3)
; 8463 : 		{
; 8464 : 			AITacticalTargetType eTargetType = it3->GetTargetType();
; 8465 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)
; 8466 : 			{
; 8467 : 				CvPlot* pLoopPlot = GC.getMap().plot(it3->GetTargetX(), it3->GetTargetY());
; 8468 : #else
; 8469 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	cmp	BYTE PTR _bDone$224669[esp+80], 0
	jne	$LN8@ExecuteHed

; 8470 : 		{
; 8471 : 			AITacticalTargetType eTargetType = m_TempTargets[iI].GetTargetType();
; 8472 : 			if (eTargetType != AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)

	mov	ecx, DWORD PTR [esi+23704]
	mov	edx, DWORD PTR tv1707[esp+80]
	cmp	DWORD PTR [edx+ecx], 7
	je	$LN9@ExecuteHed

; 8473 : 			{
; 8474 : 				CvPlot* pLoopPlot = GC.getMap().plot(m_TempTargets[iI].GetTargetX(), m_TempTargets[iI].GetTargetY());

	mov	eax, ecx
	mov	ecx, edx
	mov	ebp, DWORD PTR [eax+ecx+8]
	add	eax, ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN333@ExecuteHed
	cmp	ebp, -2147483647			; 80000001H
	je	$LN333@ExecuteHed
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	ecx, DWORD PTR [ebx+4020]
	je	SHORT $LN416@ExecuteHed
	test	eax, eax
	jge	SHORT $LN345@ExecuteHed
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN347@ExecuteHed
$LN345@ExecuteHed:
	cmp	eax, ecx
	jl	SHORT $LN416@ExecuteHed
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN347@ExecuteHed
$LN416@ExecuteHed:
	mov	edi, eax
$LN347@ExecuteHed:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4057], 0
	mov	ebx, DWORD PTR [ebx+4024]
	je	SHORT $LN419@ExecuteHed
	test	ebp, ebp
	jge	SHORT $LN355@ExecuteHed
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN357@ExecuteHed
$LN355@ExecuteHed:
	cmp	ebp, ebx
	jl	SHORT $LN419@ExecuteHed
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN357@ExecuteHed
$LN419@ExecuteHed:
	mov	edx, ebp
$LN357@ExecuteHed:
	test	edi, edi
	jl	SHORT $LN333@ExecuteHed
	cmp	edi, ecx
	jge	SHORT $LN333@ExecuteHed
	test	edx, edx
	jl	SHORT $LN333@ExecuteHed
	cmp	edx, ebx
	jge	SHORT $LN333@ExecuteHed
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	jmp	SHORT $LN428@ExecuteHed
$LN333@ExecuteHed:
	xor	ecx, ecx
$LN428@ExecuteHed:

; 8475 : #endif
; 8476 : 				if(FindClosestOperationUnit(pLoopPlot, true /*bSafeForRanged*/, false /*bMustBeRangedUnit*/))

	push	0
	push	1
	mov	DWORD PTR _pLoopPlot$224691[esp+92], ecx
	push	ecx
	mov	ecx, esi
	call	?FindClosestOperationUnit@CvTacticalAI@@AAE_NPAVCvPlot@@_N1@Z ; CvTacticalAI::FindClosestOperationUnit
	test	al, al
	je	$LN9@ExecuteHed

; 8477 : 				{
; 8478 : #ifdef AUI_ITERATORIZE
; 8479 : 					for (std::vector<CvTacticalUnit>::const_iterator it2 = m_CurrentMoveUnits.begin(); it2 != m_CurrentMoveUnits.end(); ++it2)
; 8480 : 					{
; 8481 : 						CvBlockingUnit block;
; 8482 : 						block.SetUnitID(it2->GetID());
; 8483 : 						block.SetPlot(pLoopPlot);
; 8484 : 						block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 8485 : 						block.SetDistanceToTarget(it2->GetMovesToTarget());
; 8486 : #else
; 8487 : 					for(unsigned int jJ = 0; jJ < m_CurrentMoveUnits.size(); jJ++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _jJ$224693[esp+84], 0
	je	$LN3@ExecuteHed
	lea	edi, DWORD PTR [esi+26596]
	mov	DWORD PTR tv1688[esp+84], 0
$LL5@ExecuteHed:

; 8488 : 					{
; 8489 : 						CvBlockingUnit block;
; 8490 : 						block.SetUnitID(m_CurrentMoveUnits[jJ].GetID());

	mov	edx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR tv1688[esp+84]
	mov	ecx, DWORD PTR [eax+edx]
	lea	ebx, DWORD PTR [eax+edx]

; 8491 : 						block.SetPlot(pLoopPlot);
; 8492 : 						block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 8493 : 						block.SetDistanceToTarget(m_CurrentMoveUnits[jJ].GetMovesToTarget());

	mov	ebx, DWORD PTR [ebx+12]
	mov	DWORD PTR _block$224697[esp+88], ecx
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 8494 : #endif
; 8495 : 						m_PotentialBlocks.push_back(block);

	mov	eax, DWORD PTR [edi+8]
	sar	edx, 2
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH
	add	ebp, edx
	mov	BYTE PTR [edi+412], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN393@ExecuteHed
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::GrowSize
$LN393@ExecuteHed:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN396@ExecuteHed
	mov	edx, DWORD PTR _pLoopPlot$224691[esp+84]
	mov	ecx, DWORD PTR _block$224697[esp+88]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebx
$LN396@ExecuteHed:
	inc	DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	ebx, DWORD PTR _jJ$224693[esp+84]
	add	DWORD PTR tv1688[esp+84], 24		; 00000018H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	mov	DWORD PTR _jJ$224693[esp+84], ebx
	cmp	ebx, eax
	jb	$LL5@ExecuteHed
$LN3@ExecuteHed:

; 8496 : 					}
; 8497 : 
; 8498 : 					iMeleeUnitsToPlace--;

	sub	DWORD PTR _iMeleeUnitsToPlace$224668[esp+84], 1

; 8499 : 					if(iMeleeUnitsToPlace == 0)

	jne	SHORT $LN9@ExecuteHed

; 8500 : 					{
; 8501 : 						bDone = true;

	mov	BYTE PTR _bDone$224669[esp+80], 1
$LN9@ExecuteHed:

; 8461 : #ifdef AUI_ITERATORIZE
; 8462 : 		for (FStaticVector<CvTacticalTarget, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::const_iterator it3 = m_TempTargets.begin(); it3 != m_TempTargets.end() && !bDone; ++it3)
; 8463 : 		{
; 8464 : 			AITacticalTargetType eTargetType = it3->GetTargetType();
; 8465 : 			if (eTargetType == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT)
; 8466 : 			{
; 8467 : 				CvPlot* pLoopPlot = GC.getMap().plot(it3->GetTargetX(), it3->GetTargetY());
; 8468 : #else
; 8469 : 		for(unsigned int iI = 0; iI < m_TempTargets.size() && !bDone; iI++)

	mov	eax, DWORD PTR _iI$224685[esp+84]
	add	DWORD PTR tv1707[esp+80], 28		; 0000001cH
	inc	eax
	mov	DWORD PTR _iI$224685[esp+84], eax
	cmp	eax, DWORD PTR [esi+23708]
	jb	$LL415@ExecuteHed
$LN8@ExecuteHed:

; 8502 : 					}
; 8503 : 				}
; 8504 : 			}
; 8505 : 		}
; 8506 : 		AssignDeployingUnits(iMeleeUnits - iMeleeUnitsToPlace);

	mov	eax, DWORD PTR _iMeleeUnits$[esp+84]
	sub	eax, DWORD PTR _iMeleeUnitsToPlace$224668[esp+84]
	mov	ecx, esi
	push	eax
	call	?AssignDeployingUnits@CvTacticalAI@@AAE_NH@Z ; CvTacticalAI::AssignDeployingUnits

; 8507 : 		PerformChosenMoves();

	push	1
	mov	ecx, esi
	call	?PerformChosenMoves@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::PerformChosenMoves
$LN20@ExecuteHed:

; 8508 : 	}
; 8509 : 
; 8510 : 	if(m_GeneralsToMove.size() > 0)

	cmp	DWORD PTR [esi+28824], 0
	jbe	SHORT $LN1@ExecuteHed

; 8511 : 	{
; 8512 : 		MoveGreatGeneral();

	push	0
	mov	ecx, esi
	call	?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ; CvTacticalAI::MoveGreatGeneral
$LN1@ExecuteHed:

; 8513 : 	}
; 8514 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$224651[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z ENDP ; CvTacticalAI::ExecuteHedgehogDefense
PUBLIC	?CanCoverFromEnemy@CvTacticalAI@@AAE_NPAVCvPlot@@AAHH@Z ; CvTacticalAI::CanCoverFromEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?CanCoverFromEnemy@CvTacticalAI@@AAE_NPAVCvPlot@@AAHH@Z
_TEXT	SEGMENT
_iI$225603 = -24					; size = 4
_pLoopPlot$ = -20					; size = 4
_block$225617 = -16					; size = 16
_pPlot$ = 8						; size = 4
_iNumUnitsRequiredToCover$ = 12				; size = 4
_iAttackingUnitID$ = 16					; size = 4
?CanCoverFromEnemy@CvTacticalAI@@AAE_NPAVCvPlot@@AAHH@Z PROC ; CvTacticalAI::CanCoverFromEnemy, COMDAT
; _this$ = ecx

; 10108: {

	sub	esp, 24					; 00000018H
	push	ebp

; 10109: 	CvPlot* pLoopPlot;
; 10110: 	int iPlotIndex;
; 10111: 
; 10112: 	iNumUnitsRequiredToCover = 0;

	mov	ebp, DWORD PTR _iNumUnitsRequiredToCover$[esp+24]
	push	esi
	push	edi

; 10113: 
; 10114: 	// Can't melee attack at sea so those hexes are always covered
; 10115: 	if(pPlot->isWater())

	mov	edi, DWORD PTR _pPlot$[esp+32]
	mov	DWORD PTR [ebp], 0
	cmp	BYTE PTR [edi+5], 3
	mov	esi, ecx
	jne	SHORT $LN20@CanCoverFr
	pop	edi
	pop	esi

; 10116: 	{
; 10117: 		return true;

	mov	al, 1
	pop	ebp

; 10197: }

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
$LN20@CanCoverFr:
	push	ebx

; 10118: 	}
; 10119: 
; 10120: 	// Find all the hexes we need to cover
; 10121: 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	xor	ebx, ebx
	npad	5
$LL19@CanCoverFr:

; 10122: 	{
; 10123: 		pLoopPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	ebx
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 10124: 
; 10125: 		// Don't need to cover a water hex
; 10126: 		if(pLoopPlot != NULL && !pLoopPlot->isWater())

	test	eax, eax
	je	SHORT $LN18@CanCoverFr
	cmp	BYTE PTR [eax+5], 3
	je	SHORT $LN18@CanCoverFr

; 10127: 		{
; 10128: 			iPlotIndex = GC.getMap().plotNum(pLoopPlot->getX(), pLoopPlot->getY());

	movsx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, DWORD PTR [edx+4020]
	movsx	eax, WORD PTR [eax]

; 10129: 			if(m_pMap->GetCell(iPlotIndex)->IsEnemyCanMovePast() && !m_pMap->GetCell(iPlotIndex)->IsFriendlyTurnEndTile())

	mov	edx, DWORD PTR [esi+4]
	add	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	imul	ecx, 44					; 0000002cH
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, ecx
	shr	edx, 6
	test	dl, 1
	je	SHORT $LN18@CanCoverFr
	shr	ecx, 7
	test	cl, 1
	jne	SHORT $LN18@CanCoverFr

; 10130: 			{
; 10131: 				iNumUnitsRequiredToCover++;

	inc	DWORD PTR [ebp]
$LN18@CanCoverFr:

; 10118: 	}
; 10119: 
; 10120: 	// Find all the hexes we need to cover
; 10121: 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	inc	ebx
	cmp	ebx, 6
	jl	SHORT $LL19@CanCoverFr

; 10132: 			}
; 10133: 		}
; 10134: 	}
; 10135: 
; 10136: 	if(iNumUnitsRequiredToCover == 0)

	mov	eax, DWORD PTR [ebp]
	xor	ebp, ebp
	cmp	eax, ebp
	jne	SHORT $LN14@CanCoverFr
	pop	ebx
	pop	edi

; 10137: 	{
; 10138: 		m_ChosenBlocks.clear();

	mov	DWORD PTR [esi+27432], ebp
	pop	esi

; 10139: 		return true;

	mov	al, 1
	pop	ebp

; 10197: }

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
$LN14@CanCoverFr:

; 10140: 	}
; 10141: 	else
; 10142: 	{
; 10143: 		if(iNumUnitsRequiredToCover > (int)m_CurrentTurnUnits.size())

	cmp	eax, DWORD PTR [esi+16]

; 10144: 		{
; 10145: 			return false;

	jg	$LN128@CanCoverFr

; 10146: 		}
; 10147: 
; 10148: 		// Have some unit that can cover each hex this turn?
; 10149: 		m_PotentialBlocks.clear();

	mov	DWORD PTR [esi+26600], ebp

; 10150: 		for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$225603[esp+40], ebp
$LL11@CanCoverFr:

; 10151: 		{
; 10152: 			pLoopPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	ebp
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	ecx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[esp+40], ecx

; 10153: 			if(pLoopPlot != NULL && !pLoopPlot->isWater())

	test	ecx, ecx
	je	$LN10@CanCoverFr
	cmp	BYTE PTR [ecx+5], 3
	je	$LN10@CanCoverFr

; 10154: 			{
; 10155: 				iPlotIndex = GC.getMap().plotNum(pLoopPlot->getX(), pLoopPlot->getY());

	movsx	eax, WORD PTR [ecx+2]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	eax, DWORD PTR [edx+4020]
	movsx	edx, WORD PTR [ecx]
	add	eax, edx

; 10156: 				if(m_pMap->GetCell(iPlotIndex)->IsEnemyCanMovePast() && !m_pMap->GetCell(iPlotIndex)->IsFriendlyTurnEndTile())

	mov	edx, DWORD PTR [esi+4]
	imul	eax, 44					; 0000002cH
	mov	edx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [eax+edx]
	mov	edx, eax
	shr	edx, 6
	test	dl, 1
	je	$LN10@CanCoverFr
	shr	eax, 7
	test	al, 1
	jne	$LN10@CanCoverFr

; 10157: 				{
; 10158: 					if(!FindClosestUnit(pLoopPlot, 1, false/*bMustHaveHalfHP*/, false /*bMustBeRangedUnit*/, 2 /*iRangeRequired*/, false /*bNeedsIgnoreLOS*/, true /*bMustBeMeleeUnit*/))

	push	0
	push	0
	push	1
	push	0
	push	2
	push	0
	push	0
	push	1
	push	ecx
	mov	ecx, esi
	call	?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z ; CvTacticalAI::FindClosestUnit
	test	al, al
	je	$LN128@CanCoverFr

; 10161: 					}
; 10162: 					else
; 10163: 					{
; 10164: 						// Save off the units that could get here
; 10165: #ifdef AUI_ITERATORIZE
; 10166: 						for (std::vector<CvTacticalUnit>::const_iterator it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)
; 10167: 						{
; 10168: 							if (it->GetID() != iAttackingUnitID)
; 10169: 							{
; 10170: 								CvBlockingUnit block;
; 10171: 								block.SetUnitID(it->GetID());
; 10172: 								block.SetPlot(pLoopPlot);
; 10173: 								block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 10174: 								block.SetDistanceToTarget(it->GetMovesToTarget());
; 10175: #else
; 10176: 						for(unsigned int iJ = 0; iJ < m_CurrentMoveUnits.size(); iJ++)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	ebx, ebx
	add	eax, edx
	je	$LN10@CanCoverFr
	xor	ebp, ebp
	npad	3
$LL4@CanCoverFr:

; 10177: 						{
; 10178: 							if(m_CurrentMoveUnits[iJ].GetID() != iAttackingUnitID)

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR _iAttackingUnitID$[esp+36]
	cmp	DWORD PTR [ecx+ebp], edx
	je	SHORT $LN3@CanCoverFr

; 10179: 							{
; 10180: 								CvBlockingUnit block;
; 10181: 								block.SetUnitID(m_CurrentMoveUnits[iJ].GetID());
; 10182: 								block.SetPlot(pLoopPlot);

	mov	edx, DWORD PTR _pLoopPlot$[esp+40]
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+ebp]
	lea	edi, DWORD PTR [eax+ebp]
	mov	DWORD PTR _block$225617[esp+44], ecx

; 10183: 								block.SetNumChoices((int)m_CurrentMoveUnits.size());

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, eax
	mov	DWORD PTR _block$225617[esp+40], edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 10184: 								block.SetDistanceToTarget(m_CurrentMoveUnits[iJ].GetMovesToTarget());

	mov	ecx, DWORD PTR [edi+12]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 10185: #endif
; 10186: 								m_PotentialBlocks.push_back(block);

	lea	edx, DWORD PTR _block$225617[esp+40]
	mov	DWORD PTR _block$225617[esp+52], ecx
	push	edx
	lea	ecx, DWORD PTR [esi+26596]
	mov	DWORD PTR _block$225617[esp+52], eax
	call	?push_back@?$FStaticVector@VCvBlockingUnit@@$0BJ@$00$0BCJ@$0A@@@QAEIABVCvBlockingUnit@@@Z ; FStaticVector<CvBlockingUnit,25,1,297,0>::push_back
	mov	edi, DWORD PTR _pPlot$[esp+36]
$LN3@CanCoverFr:
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	add	ebp, 24					; 00000018H
	cmp	ebx, eax
	jb	SHORT $LL4@CanCoverFr

; 10161: 					}
; 10162: 					else
; 10163: 					{
; 10164: 						// Save off the units that could get here
; 10165: #ifdef AUI_ITERATORIZE
; 10166: 						for (std::vector<CvTacticalUnit>::const_iterator it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)
; 10167: 						{
; 10168: 							if (it->GetID() != iAttackingUnitID)
; 10169: 							{
; 10170: 								CvBlockingUnit block;
; 10171: 								block.SetUnitID(it->GetID());
; 10172: 								block.SetPlot(pLoopPlot);
; 10173: 								block.SetNumChoices((int)m_CurrentMoveUnits.size());
; 10174: 								block.SetDistanceToTarget(it->GetMovesToTarget());
; 10175: #else
; 10176: 						for(unsigned int iJ = 0; iJ < m_CurrentMoveUnits.size(); iJ++)

	mov	ebp, DWORD PTR _iI$225603[esp+40]
$LN10@CanCoverFr:

; 10150: 		for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	inc	ebp
	cmp	ebp, 6
	mov	DWORD PTR _iI$225603[esp+40], ebp
	jl	$LL11@CanCoverFr

; 10187: 							}
; 10188: 						}
; 10189: 					}
; 10190: 				}
; 10191: 			}
; 10192: 		}
; 10193: 	}
; 10194: 
; 10195: 	// Now select exact covering units, making sure we didn't over commit a unit to covering more than one hex
; 10196: 	return AssignCoveringUnits(iNumUnitsRequiredToCover);

	mov	ecx, DWORD PTR _iNumUnitsRequiredToCover$[esp+36]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, esi
	call	?AssignCoveringUnits@CvTacticalAI@@AAE_NH@Z ; CvTacticalAI::AssignCoveringUnits
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 10197: }

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
$LN128@CanCoverFr:
	pop	ebx
	pop	edi
	pop	esi

; 10159: 					{
; 10160: 						return false;

	xor	al, al
	pop	ebp

; 10197: }

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
?CanCoverFromEnemy@CvTacticalAI@@AAE_NPAVCvPlot@@AAHH@Z ENDP ; CvTacticalAI::CanCoverFromEnemy
_TEXT	ENDS
PUBLIC	?PlotCloseOnTarget@CvTacticalAI@@AAEX_N@Z	; CvTacticalAI::PlotCloseOnTarget
; Function compile flags: /Ogtpy
;	COMDAT ?PlotCloseOnTarget@CvTacticalAI@@AAEX_N@Z
_TEXT	SEGMENT
_target$ = -28						; size = 28
_bCheckDominance$ = 8					; size = 1
?PlotCloseOnTarget@CvTacticalAI@@AAEX_N@Z PROC		; CvTacticalAI::PlotCloseOnTarget, COMDAT
; _this$ = ecx

; 3823 : {

	sub	esp, 28					; 0000001cH
	push	ebp
	mov	ebp, ecx

; 3824 : 	CvTacticalDominanceZone* pZone = GC.getGame().GetTacticalAnalysisMap()->GetZone(m_iCurrentZoneIndex);

	mov	eax, DWORD PTR [ebp+24792]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	push	eax
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	ecx, eax
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone

; 3825 : 	if (bCheckDominance && pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_ENEMY)

	cmp	BYTE PTR _bCheckDominance$[esp+32], 0
	mov	esi, eax
	mov	ecx, 2
	je	SHORT $LN6@PlotCloseO
	cmp	DWORD PTR [esi+8], ecx
	je	$LN2@PlotCloseO
$LN6@PlotCloseO:

; 3826 : 	{
; 3827 : 		return;
; 3828 : 	}
; 3829 : 
; 3830 : 	// Flank attacks done; if in an enemy zone, close in on target
; 3831 : 	CvTacticalTarget target;

	xor	eax, eax
	mov	DWORD PTR _target$[esp+36], eax
	mov	DWORD PTR _target$[esp+52], eax
	mov	DWORD PTR _target$[esp+56], eax

; 3832 : 	if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_TEMP_ZONE)

	mov	eax, DWORD PTR [esi+4]
	push	ebx
	or	ebx, -1
	mov	DWORD PTR _target$[esp+44], ebx
	mov	DWORD PTR _target$[esp+48], ebx
	mov	DWORD PTR _target$[esp+52], ebx
	mov	DWORD PTR _target$[esp+64], ebx
	cmp	eax, 5
	jne	SHORT $LN5@PlotCloseO

; 3833 : 	{
; 3834 : 		target.SetTargetType(AI_TACTICAL_TARGET_BARBARIAN_CAMP);
; 3835 : 		target.SetTargetPlayer(BARBARIAN_PLAYER);
; 3836 : 		target.SetTargetX(pZone->GetTempZoneCenter()->getX());

	mov	eax, DWORD PTR [esi+72]

; 3837 : 		target.SetTargetY(pZone->GetTempZoneCenter()->getY());

	movsx	edx, WORD PTR [eax+2]
	mov	DWORD PTR _target$[esp+40], ecx
	movsx	ecx, WORD PTR [eax]

; 3838 : 		target.SetDominanceZone(pZone->GetDominanceZoneID());

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _target$[esp+44], ecx

; 3839 : 
; 3840 : 		ExecuteCloseOnTarget(target, pZone);

	push	esi
	lea	ecx, DWORD PTR _target$[esp+44]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR _target$[esp+60], 63		; 0000003fH
	mov	DWORD PTR _target$[esp+56], edx
	mov	DWORD PTR _target$[esp+72], eax
	call	?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::ExecuteCloseOnTarget
	pop	ebx
	pop	esi
	pop	ebp

; 3856 : 		}
; 3857 : 	}
; 3858 : }

	add	esp, 28					; 0000001cH
	ret	4
$LN5@PlotCloseO:

; 3841 : 	}
; 3842 : 	else if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_ENEMY && pZone->GetClosestCity() != NULL)

	cmp	eax, 3
	jne	$LN79@PlotCloseO
	mov	ecx, esi
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	test	eax, eax
	je	$LN79@PlotCloseO

; 3843 : 	{
; 3844 : 		bool bCanSeeCity = pZone->GetClosestCity()->plot()->isVisible(m_pPlayer->getTeam());

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+44]
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN45@PlotCloseO
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN46@PlotCloseO
$LN45@PlotCloseO:
	mov	edi, ebx
$LN46@PlotCloseO:
	mov	ecx, esi
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	edi, ebx
	je	SHORT $LN1@PlotCloseO
	mov	eax, DWORD PTR [eax+156]
	cmp	WORD PTR [eax+edi*2], 0
	setg	al

; 3845 : 
; 3846 : 		// If we can't see the city, be careful advancing on it.  We want to be sure we're not heavily outnumbered
; 3847 : 		if(!bCanSeeCity || pZone->GetFriendlyStrength() > (pZone->GetEnemyStrength() / 2))

	test	al, al
	je	SHORT $LN1@PlotCloseO
	mov	eax, DWORD PTR [esi+28]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR [esi+24], eax
	jle	SHORT $LN80@PlotCloseO
$LN1@PlotCloseO:

; 3848 : 		{
; 3849 : 			target.SetTargetType(AI_TACTICAL_TARGET_CITY);
; 3850 : 			target.SetTargetPlayer(pZone->GetClosestCity()->getOwner());

	mov	ecx, esi
	mov	DWORD PTR _target$[esp+44], 1
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _target$[esp+56], ecx

; 3851 : 			target.SetTargetX(pZone->GetClosestCity()->plot()->getX());

	mov	ecx, esi
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	edx, WORD PTR [eax]

; 3852 : 			target.SetTargetY(pZone->GetClosestCity()->plot()->getY());

	mov	ecx, esi
	mov	DWORD PTR _target$[esp+48], edx
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 3853 : 			target.SetDominanceZone(pZone->GetDominanceZoneID());

	mov	ecx, DWORD PTR [esi]
	movsx	eax, WORD PTR [eax+2]

; 3854 : 
; 3855 : 			ExecuteCloseOnTarget(target, pZone);

	push	esi
	lea	edx, DWORD PTR _target$[esp+48]
	mov	DWORD PTR _target$[esp+72], ecx
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR _target$[esp+60], eax
	call	?ExecuteCloseOnTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::ExecuteCloseOnTarget
$LN80@PlotCloseO:
	pop	edi
$LN79@PlotCloseO:
	pop	ebx
$LN2@PlotCloseO:
	pop	esi
	pop	ebp

; 3856 : 		}
; 3857 : 	}
; 3858 : }

	add	esp, 28					; 0000001cH
	ret	4
?PlotCloseOnTarget@CvTacticalAI@@AAEX_N@Z ENDP		; CvTacticalAI::PlotCloseOnTarget
_TEXT	ENDS
PUBLIC	?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z ; CvTacticalAI::PlotNavalEscortOperationMoves
EXTRN	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z:PROC ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
EXTRN	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z:PROC ; CvStepPathFinder::GetXPlotsFromEnd
EXTRN	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z:PROC ; CvStepPathFinder::GetStepDistanceBetweenPoints
EXTRN	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ:PROC ; CvGlobals::getStepFinder
EXTRN	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ:PROC ; CvAIOperation::GetEnemy
EXTRN	?GetGoalX@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetGoalX
EXTRN	?GetGoalY@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetGoalY
EXTRN	?GetUnitsOfType@CvArmyAI@@QBEHW4MultiunitPositionTypes@@@Z:PROC ; CvArmyAI::GetUnitsOfType
EXTRN	?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z:PROC ; CvAINavalEscortedOperation::RetargetCivilian
EXTRN	?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z:PROC ; CvArmyAI::GetFirstUnitInDomain
EXTRN	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z:PROC ; CvAIOperation::LogOperationSpecialMessage
EXTRN	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FOUND
EXTRN	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canFound
EXTRN	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ:PROC	; CvArmyAI::GetGoalPlot
EXTRN	?SetXY@CvArmyAI@@QAEXHH@Z:PROC			; CvArmyAI::SetXY
EXTRN	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ:PROC ; CvAIOperation::GetMusterPlot
EXTRN	?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ:PROC	; CvArmyAI::GetTurnAtNextCheckpoint
EXTRN	?UpdateCheckpointTurns@CvArmyAI@@QAEXXZ:PROC	; CvArmyAI::UpdateCheckpointTurns
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z DD 019930522H
	DD	015H
	DD	FLAT:__unwindtable$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$8
	DD	02H
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$11
	DD	04H
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$13
	DD	06H
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$15
	DD	07H
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$19
	DD	0aH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$20
	DD	0aH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$21
	DD	0aH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$22
	DD	0aH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$24
	DD	0fH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$25
	DD	0fH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$26
	DD	0fH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$27
	DD	0fH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$29
	DD	0fH
	DD	FLAT:__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$30
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z
_TEXT	SEGMENT
_iI$222519 = -144					; size = 4
_iI$222491 = -144					; size = 4
_pBestPlot$222487 = -144				; size = 4
_iI$222471 = -144					; size = 4
_iI$222436 = -144					; size = 4
_iBestDistance$222421 = -144				; size = 4
_iI$222407 = -144					; size = 4
$T304497 = -144						; size = 4
$T304496 = -144						; size = 4
$T304495 = -144						; size = 4
$T304494 = -144						; size = 4
$T304493 = -144						; size = 4
$T304491 = -144						; size = 4
_thisSlotEntry$222372 = -144				; size = 4
tv2274 = -140						; size = 4
tv2264 = -140						; size = 4
tv2254 = -140						; size = 4
_iI$222503 = -140					; size = 4
_iI$222451 = -140					; size = 4
_pEscort$ = -140					; size = 4
tv2314 = -136						; size = 4
$T304924 = -136						; size = 4
_pBestPlot$222422 = -136				; size = 4
_iI$222362 = -136					; size = 4
_iSlowestMovementRate$222488 = -132			; size = 4
_iDistanceToMove$222462 = -132				; size = 4
_iDistance$222460 = -132				; size = 4
$T304499 = -132						; size = 4
$T304498 = -132						; size = 4
$T304492 = -132						; size = 4
_iBestDistance$222485 = -128				; size = 4
_eEnemy$222469 = -128					; size = 4
$T304500 = -128						; size = 4
_pUnit$222525 = -124					; size = 8
_pUnit$222509 = -124					; size = 8
_pUnit$222497 = -124					; size = 8
_pUnit$222477 = -124					; size = 8
_pUnit$222442 = -124					; size = 8
_pUnit$222413 = -124					; size = 8
$T304501 = -116						; size = 4
_pUnit$222429 = -116					; size = 8
_pUnit$222368 = -116					; size = 8
_pClosestUnitAtSea$222489 = -108			; size = 8
_pUnitAtSea$222433 = -108				; size = 8
_pCivilian$ = -100					; size = 4
_strLogString$222500 = -96				; size = 28
_strLogString$222480 = -96				; size = 28
_strLogString$222445 = -96				; size = 28
_strLogString$222418 = -96				; size = 28
_strLogString$222405 = -96				; size = 28
_strTemp$222398 = -96					; size = 28
_strTemp$222417 = -68					; size = 28
_strTemp$222404 = -68					; size = 28
_strLogString$222399 = -68				; size = 28
_strMsg$222389 = -68					; size = 28
_strLogString$222528 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_pOperation$ = 8					; size = 4
?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z PROC ; CvTacticalAI::PlotNavalEscortOperationMoves, COMDAT
; _this$ = ecx

; 4375 : {

	push	-1
	push	__ehhandler$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 4376 : 	CvUnit* pCivilian = 0, *pEscort = 0;
; 4377 : 	int iUnitID;
; 4378 : 
; 4379 : 	// Simplification - assume only 1 army per operation now
; 4380 : 	if(pOperation->GetFirstArmyID() == -1)

	mov	ecx, DWORD PTR _pOperation$[esp+156]
	xor	ebx, ebx
	xor	edi, edi
	mov	DWORD PTR _pCivilian$[esp+160], ebx
	mov	DWORD PTR _pEscort$[esp+160], edi
	call	?GetFirstArmyID@CvAIOperation@@QAEHXZ	; CvAIOperation::GetFirstArmyID
	cmp	eax, -1
	je	$LN484@PlotNavalE

; 4381 : 	{
; 4382 : 		return;
; 4383 : 	}
; 4384 : 	CvArmyAI* pThisArmy = m_pPlayer->getArmyAI(pOperation->GetFirstArmyID());

	mov	ecx, DWORD PTR _pOperation$[esp+156]
	call	?GetFirstArmyID@CvAIOperation@@QAEHXZ	; CvAIOperation::GetFirstArmyID
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	esi, eax

; 4385 : 	iUnitID = pThisArmy->GetFirstUnitID();

	mov	ecx, esi
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 4386 : 	if(iUnitID != -1)

	cmp	eax, -1
	je	SHORT $LN505@PlotNavalE

; 4387 : 	{
; 4388 : 		pCivilian = m_pPlayer->getUnit(iUnitID);

	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebx, eax

; 4389 : 
; 4390 : 		iUnitID = pThisArmy->GetNextUnitID();

	mov	ecx, esi
	mov	DWORD PTR _pCivilian$[esp+160], ebx
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID

; 4391 : 		if(iUnitID != -1)

	cmp	eax, -1
	je	SHORT $LN93@PlotNavalE

; 4392 : 		{
; 4393 : 			pEscort = m_pPlayer->getUnit(iUnitID);

	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 4394 : 			if(pEscort->getDomainType() != DOMAIN_LAND)

	mov	ecx, edi
	mov	DWORD PTR _pEscort$[esp+160], eax
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	je	SHORT $LN93@PlotNavalE

; 4395 : 			{
; 4396 : 				pEscort = NULL;   // Second unit wasn't the escort

	xor	edi, edi
	mov	DWORD PTR _pEscort$[esp+160], edi
$LN93@PlotNavalE:

; 4397 : 			}
; 4398 : 		}
; 4399 : 	}
; 4400 : 
; 4401 : 	if(!pCivilian && pOperation->IsCivilianRequired())

	test	ebx, ebx
	jne	SHORT $LN92@PlotNavalE
$LN505@PlotNavalE:
	mov	ecx, DWORD PTR _pOperation$[esp+156]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+144]
	call	edx
	test	al, al
	jne	$LN484@PlotNavalE
$LN92@PlotNavalE:

; 4402 : 	{
; 4403 : 		return;
; 4404 : 	}
; 4405 : 
; 4406 : 	m_OperationUnits.clear();
; 4407 : 	pThisArmy->UpdateCheckpointTurns();

	mov	ecx, esi
	mov	DWORD PTR [ebp+28648], 0
	call	?UpdateCheckpointTurns@CvArmyAI@@QAEXXZ	; CvArmyAI::UpdateCheckpointTurns

; 4408 : 
; 4409 : 	// RECRUITING
; 4410 : 	if(pThisArmy->GetArmyAIState() == ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE)

	mov	ecx, esi
	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState

; 4411 : 	{
; 4412 : 		// If no estimate for when recruiting will end, let the rest of the AI use these units
; 4413 : 		if(pThisArmy->GetTurnAtNextCheckpoint() == ARMYSLOT_UNKNOWN_TURN_AT_CHECKPOINT)

	mov	ecx, esi
	test	eax, eax
	jne	$LN91@PlotNavalE
	call	?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ ; CvArmyAI::GetTurnAtNextCheckpoint
	cmp	eax, -1
	je	$LN484@PlotNavalE

; 4414 : 		{
; 4415 : 			return;
; 4416 : 		}
; 4417 : 		else
; 4418 : 		{
; 4419 : 			for(int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	ecx, esi
	mov	DWORD PTR _iI$222362[esp+160], 0
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	$LN86@PlotNavalE
	mov	DWORD PTR tv2254[esp+160], 0
$LN88@PlotNavalE:

; 4420 : 			{
; 4421 : 				CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(iI);

	mov	edi, DWORD PTR [esi+44]
	add	edi, DWORD PTR tv2254[esp+160]

; 4422 : 				if(pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [edi]
	cmp	eax, -1
	je	$LN87@PlotNavalE

; 4423 : 				{
; 4424 : 					// See if we are just able to get to muster point in time.  If so, time for us to head over there
; 4425 : 					UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebx, eax
	mov	DWORD PTR _pUnit$222368[esp+160], ebx
	mov	BYTE PTR _pUnit$222368[esp+164], 0
	test	ebx, ebx
	je	SHORT $LN149@PlotNavalE
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN149@PlotNavalE:
	mov	DWORD PTR __$EHRec$[esp+168], 0

; 4426 : 					if(pUnit && !pUnit->TurnProcessed())

	test	ebx, ebx
	je	$LN80@PlotNavalE
	mov	ecx, ebx
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	$LN80@PlotNavalE

; 4427 : 					{
; 4428 : 						CvMultiUnitFormationInfo* pkUnitFormationInfo = GC.getMultiUnitFormationInfo(pThisArmy->GetFormationIndex());

	mov	ecx, esi
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo

; 4429 : 						if (pkUnitFormationInfo)

	test	eax, eax
	je	$LN80@PlotNavalE

; 4430 : 						{
; 4431 : 							const CvFormationSlotEntry& thisSlotEntry = pkUnitFormationInfo->getFormationSlotEntry(iI);

	mov	ecx, DWORD PTR _iI$222362[esp+160]
	push	ecx
	mov	ecx, eax
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry

; 4432 : 
; 4433 : 							// Continue moving to target
; 4434 : 							if(pSlot->HasStartedOnOperation())

	cmp	DWORD PTR [edi+8], 0
	mov	DWORD PTR _thisSlotEntry$222372[esp+160], eax
	je	SHORT $LN82@PlotNavalE

; 4435 : 							{
; 4436 : 								MoveWithFormation(pUnit, thisSlotEntry.m_ePositionType);

	mov	edx, DWORD PTR [eax+8]
	push	edx
	sub	esp, 8
	lea	eax, DWORD PTR _pUnit$222368[esp+172]
	mov	ecx, esp
	mov	DWORD PTR $T304491[esp+172], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, ebp
	call	?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ; CvTacticalAI::MoveWithFormation

; 4437 : 							}
; 4438 : 
; 4439 : 							else

	jmp	SHORT $LN80@PlotNavalE
$LN82@PlotNavalE:

; 4440 : 							{
; 4441 : 								// See if we are just able to get to muster point in time.  If so, time for us to head over there
; 4442 : 								int iTurns = TurnsToReachTarget(pUnit, pOperation->GetMusterPlot(), true /*bReusePaths*/, true, true);

	mov	ecx, DWORD PTR _pOperation$[esp+156]
	push	1
	push	1
	push	1
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pUnit$222368[esp+184]
	mov	ecx, esp
	mov	DWORD PTR $T304492[esp+184], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget

; 4443 : 								if(iTurns + GC.getGame().getGameTurn() >= pThisArmy->GetTurnAtNextCheckpoint())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esp, 24					; 00000018H
	mov	ebx, eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, esi
	add	ebx, eax
	call	?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ ; CvArmyAI::GetTurnAtNextCheckpoint
	cmp	ebx, eax
	jl	SHORT $LN515@PlotNavalE

; 4444 : 								{
; 4445 : 									pSlot->SetStartedOnOperation(true);
; 4446 : 									MoveWithFormation(pUnit, thisSlotEntry.m_ePositionType);

	mov	eax, DWORD PTR _thisSlotEntry$222372[esp+160]
	mov	DWORD PTR [edi+8], 1
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	sub	esp, 8
	lea	edx, DWORD PTR _pUnit$222368[esp+172]
	mov	ecx, esp
	mov	DWORD PTR $T304493[esp+172], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, ebp
	call	?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ; CvTacticalAI::MoveWithFormation
$LN515@PlotNavalE:
	mov	ebx, DWORD PTR _pUnit$222368[esp+160]
$LN80@PlotNavalE:

; 4447 : 								}
; 4448 : 							}
; 4449 : 						}
; 4450 : 					}
; 4451 : 				}

	mov	DWORD PTR __$EHRec$[esp+168], -1
	test	ebx, ebx
	je	SHORT $LN87@PlotNavalE
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN87@PlotNavalE:
	mov	edi, DWORD PTR _iI$222362[esp+160]
	add	DWORD PTR tv2254[esp+160], 12		; 0000000cH
	inc	edi
	mov	ecx, esi
	mov	DWORD PTR _iI$222362[esp+160], edi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	edi, eax
	jl	$LN88@PlotNavalE
$LN86@PlotNavalE:

; 4452 : 			}
; 4453 : 			ExecuteNavalFormationMoves(pThisArmy, pOperation->GetMusterPlot());

	mov	ecx, DWORD PTR _pOperation$[esp+156]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	push	esi
	mov	ecx, ebp
	call	?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ; CvTacticalAI::ExecuteNavalFormationMoves
	jmp	$LN484@PlotNavalE
$LN91@PlotNavalE:

; 4454 : 		}
; 4455 : 	}
; 4456 : 
; 4457 : 	// GATHERING FORCES
; 4458 : 	else if(pThisArmy->GetArmyAIState() == ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP)

	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState
	cmp	eax, 1
	jne	SHORT $LN78@PlotNavalE

; 4459 : 	{
; 4460 : 		ExecuteFleetMoveToTarget(pThisArmy, pOperation->GetMusterPlot());

	mov	ecx, DWORD PTR _pOperation$[esp+156]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	push	esi
	mov	ecx, ebp
	call	?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ; CvTacticalAI::ExecuteFleetMoveToTarget
	jmp	$LN484@PlotNavalE
$LN78@PlotNavalE:

; 4461 : 	}
; 4462 : 
; 4463 : 	// MOVING TO TARGET with a civilian
; 4464 : 	else if(pThisArmy->GetArmyAIState() == ARMYAISTATE_MOVING_TO_DESTINATION && pOperation->IsCivilianRequired())

	mov	ecx, esi
	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState
	cmp	eax, 2
	jne	$LN76@PlotNavalE
	mov	ecx, DWORD PTR _pOperation$[esp+156]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+144]
	call	edx
	test	al, al
	je	$LN76@PlotNavalE

; 4465 : 	{
; 4466 : 		// Update army's current location
; 4467 : 		CvPlot* pThisTurnTarget;
; 4468 : 		pThisTurnTarget = pThisArmy->GetCenterOfMass(DOMAIN_SEA);

	push	0
	mov	ecx, esi
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass

; 4469 : 		if(pThisTurnTarget != NULL)

	test	eax, eax
	je	SHORT $LN75@PlotNavalE

; 4470 : 		{
; 4471 : 			pThisArmy->SetXY(pThisTurnTarget->getX(), pThisTurnTarget->getY());

	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	mov	ecx, esi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY
$LN75@PlotNavalE:

; 4472 : 		}
; 4473 : 
; 4474 : 		// Settler at the target?
; 4475 : 		if(!pCivilian->plot()->isWater() && pCivilian->plot() == pThisArmy->GetGoalPlot())

	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 3
	je	$LN74@PlotNavalE
	mov	ecx, esi
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	ecx, ebx
	mov	edi, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, edi
	jne	$LN510@PlotNavalE

; 4476 : 		{
; 4477 : 			if(pCivilian->canFound(pCivilian->plot()))

	push	0
	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, ebx
	call	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canFound
	test	al, al
	je	$LN484@PlotNavalE

; 4478 : 			{
; 4479 : 				pCivilian->PushMission(CvTypes::getMISSION_FOUND());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND
	push	eax
	mov	ecx, ebx
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4480 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN509@PlotNavalE
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN509@PlotNavalE

; 4481 : 				{
; 4482 : 					CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222389[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4483 : 					strMsg.Format("City founded, At X=%d, At Y=%d", pCivilian->plot()->getX(), pCivilian->plot()->getY());

	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+168], 1
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	esi, WORD PTR [eax+2]
	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	eax, WORD PTR [eax]
	push	esi
	push	eax
	lea	ecx, DWORD PTR _strMsg$222389[esp+168]
	push	OFFSET $SG222390
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4484 : 					pOperation->LogOperationSpecialMessage(strMsg);

	mov	esi, DWORD PTR _pOperation$[esp+172]
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR _strMsg$222389[esp+160]
	push	edx
	mov	ecx, esi
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage

; 4485 : 				}

	lea	ecx, DWORD PTR _strMsg$222389[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4486 : 				pOperation->SetToAbort(AI_ABORT_SUCCESS);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+76]
	push	0
	mov	ecx, esi
	call	edx

; 4487 : 			}
; 4488 : 		}
; 4489 : 
; 4490 : 		// Is our settler and his escort both one move from the destination?  If so, targeted moves to finish up
; 4491 : 		else if(TurnsToReachTarget(pCivilian, pOperation->GetTargetPlot()) <= 1 &&

	jmp	$LN484@PlotNavalE
$LN509@PlotNavalE:

; 4485 : 				}

	mov	esi, DWORD PTR _pOperation$[esp+156]

; 4486 : 				pOperation->SetToAbort(AI_ABORT_SUCCESS);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+76]
	push	0
	mov	ecx, esi
	call	edx

; 4487 : 			}
; 4488 : 		}
; 4489 : 
; 4490 : 		// Is our settler and his escort both one move from the destination?  If so, targeted moves to finish up
; 4491 : 		else if(TurnsToReachTarget(pCivilian, pOperation->GetTargetPlot()) <= 1 &&

	jmp	$LN484@PlotNavalE
$LN510@PlotNavalE:
	mov	edi, DWORD PTR _pEscort$[esp+160]
$LN74@PlotNavalE:

; 4492 : 		        (!pEscort || TurnsToReachTarget(pEscort, pOperation->GetTargetPlot()) <= 1))

	mov	ecx, DWORD PTR _pOperation$[esp+156]
	push	0
	push	0
	push	0
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T304494[esp+184], esp
	push	ebx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jg	$LN70@PlotNavalE
	test	edi, edi
	je	SHORT $LN69@PlotNavalE
	mov	ecx, DWORD PTR _pOperation$[esp+156]
	push	0
	push	0
	push	0
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T304495[esp+184], esp
	push	edi
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jg	$LN70@PlotNavalE
$LN69@PlotNavalE:

; 4493 : 		{
; 4494 : 			ExecuteMoveToPlot(pCivilian, pOperation->GetTargetPlot(), true);

	mov	ecx, DWORD PTR _pOperation$[esp+156]
	push	1
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T304496[esp+176], esp
	push	ebx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, ebp
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 4495 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN68@PlotNavalE
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN68@PlotNavalE

; 4496 : 			{
; 4497 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222398[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4498 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222399[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4499 : 				strTemp = GC.getUnitInfo(pCivilian->getUnitType())->GetDescription();

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+168], 3
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222398[esp+164]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 4500 : 				strLogString.Format("Moving %s to target, X: %d, Y: %d", strTemp.GetCString(), pCivilian->getX(), pCivilian->getY());

	mov	eax, DWORD PTR [ebx+88]
	mov	ecx, DWORD PTR [ebx+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$222398[esp+168]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$222399[esp+172]
	push	OFFSET $SG222400
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4501 : 				LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222399[esp+164]
	push	ecx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4502 : 			}

	lea	ecx, DWORD PTR _strLogString$222399[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$222398[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN68@PlotNavalE:

; 4503 : 
; 4504 : 			if(pEscort)

	test	edi, edi
	je	$LN66@PlotNavalE

; 4505 : 			{
; 4506 : 				ExecuteMoveToPlot(pEscort, pOperation->GetTargetPlot(), false);

	mov	ecx, DWORD PTR _pOperation$[esp+156]
	push	0
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T304497[esp+176], esp
	push	edi
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, ebp
	call	?ExecuteMoveToPlot@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::ExecuteMoveToPlot

; 4507 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN66@PlotNavalE
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN66@PlotNavalE

; 4508 : 				{
; 4509 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222404[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4510 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222405[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4511 : 					strTemp = GC.getUnitInfo(pEscort->getUnitType())->GetDescription();

	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+168], 5
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222404[esp+164]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 4512 : 					strLogString.Format("Moving %s to target, X: %d, Y: %d", strTemp.GetCString(), pEscort->getX(), pEscort->getY());

	mov	eax, DWORD PTR [edi+88]
	mov	edi, DWORD PTR [edi+76]
	push	eax
	push	edi
	lea	ecx, DWORD PTR _strTemp$222404[esp+168]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$222405[esp+172]
	push	OFFSET $SG222406
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4513 : 					LogTacticalMessage(strLogString);

	push	1
	lea	eax, DWORD PTR _strLogString$222405[esp+164]
	push	eax
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4514 : 				}

	lea	ecx, DWORD PTR _strLogString$222405[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$222404[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN66@PlotNavalE:

; 4515 : 			}
; 4516 : 
; 4517 : 			// Move naval escorts in close
; 4518 : 			for(int iI = 2; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	ecx, esi
	mov	DWORD PTR _iI$222407[esp+160], 2
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	eax, 2
	jle	$LN484@PlotNavalE
	mov	DWORD PTR tv2264[esp+160], 24		; 00000018H
$LN65@PlotNavalE:

; 4519 : 			{
; 4520 : 				CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(iI);

	mov	eax, DWORD PTR [esi+44]
	add	eax, DWORD PTR tv2264[esp+160]

; 4521 : 				if(pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [eax]
	cmp	eax, -1
	je	$LN64@PlotNavalE

; 4522 : 				{
; 4523 : 					UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	push	eax
	lea	ecx, DWORD PTR _pUnit$222413[esp+164]
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>

; 4524 : 					if(pUnit && !pUnit->TurnProcessed())

	mov	edi, DWORD PTR _pUnit$222413[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], 6
	test	edi, edi
	je	$LN60@PlotNavalE
	mov	ecx, edi
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	$LN60@PlotNavalE

; 4525 : 					{
; 4526 : 						MoveToEmptySpaceNearTarget(pUnit, pOperation->GetTargetPlot(), false /*bLand */);

	mov	ecx, DWORD PTR _pOperation$[esp+156]
	push	0
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pUnit$222413[esp+176]
	mov	ecx, esp
	mov	DWORD PTR $T304498[esp+176], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, ebp
	call	?MoveToEmptySpaceNearTarget@CvTacticalAI@@AAE_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N@Z ; CvTacticalAI::MoveToEmptySpaceNearTarget

; 4527 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN60@PlotNavalE
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN60@PlotNavalE

; 4528 : 						{
; 4529 : 							CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222417[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4530 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222418[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 7
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4531 : 							strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+168], 8
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$222417[esp+164]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 4532 : 							strLogString.Format("Moving %s near target, Now at X: %d, Y: %d", strTemp.GetCString(), pCivilian->getX(), pCivilian->getY());

	mov	eax, DWORD PTR [ebx+88]
	mov	ecx, DWORD PTR [ebx+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$222417[esp+168]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$222418[esp+172]
	push	OFFSET $SG222419
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4533 : 							LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222418[esp+164]
	push	ecx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4534 : 						}

	lea	ecx, DWORD PTR _strLogString$222418[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$222417[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN60@PlotNavalE:

; 4535 : 					}
; 4536 : 				}

	mov	DWORD PTR __$EHRec$[esp+168], -1
	test	edi, edi
	je	SHORT $LN64@PlotNavalE
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN64@PlotNavalE:
	mov	edi, DWORD PTR _iI$222407[esp+160]
	add	DWORD PTR tv2264[esp+160], 12		; 0000000cH
	inc	edi
	mov	ecx, esi
	mov	DWORD PTR _iI$222407[esp+160], edi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	edi, eax
	jl	$LN65@PlotNavalE

; 4537 : 			}
; 4538 : 		}
; 4539 : 
; 4540 : 		// Still further away, move as formation
; 4541 : 		else

	jmp	$LN484@PlotNavalE
$LN70@PlotNavalE:

; 4544 : 			CvPlot* pBestPlot = NULL;

	xor	edi, edi

; 4545 : 
; 4546 : 			// Request moves for all units
; 4547 : 			for(int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	ecx, esi
	mov	DWORD PTR _iBestDistance$222421[esp+160], 2147483647 ; 7fffffffH
	mov	DWORD PTR _pBestPlot$222422[esp+160], edi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	$LN56@PlotNavalE

; 4542 : 		{
; 4543 : 			int iBestDistance = MAX_INT;

	mov	DWORD PTR tv2274[esp+160], edi
$LN58@PlotNavalE:

; 4548 : 			{
; 4549 : 				CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(iI);

	mov	eax, DWORD PTR [esi+44]
	add	eax, DWORD PTR tv2274[esp+160]

; 4550 : 				if(pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [eax]
	cmp	eax, -1
	je	$LN57@PlotNavalE

; 4551 : 				{
; 4552 : 					UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	push	eax
	lea	ecx, DWORD PTR _pUnit$222429[esp+164]
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>

; 4553 : 					if(pUnit && !pUnit->TurnProcessed())

	cmp	DWORD PTR _pUnit$222429[esp+160], 0
	mov	DWORD PTR __$EHRec$[esp+168], 9
	je	SHORT $LN54@PlotNavalE
	mov	ecx, DWORD PTR _pUnit$222429[esp+160]
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	SHORT $LN54@PlotNavalE

; 4554 : 					{
; 4555 : 						const CvFormationSlotEntry& thisSlotEntry = GC.getMultiUnitFormationInfo(pThisArmy->GetFormationIndex())->getFormationSlotEntry(iI);

	push	edi
	mov	ecx, esi
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
	mov	ecx, eax
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry

; 4556 : 						MoveWithFormation(pUnit, thisSlotEntry.m_ePositionType);

	mov	edx, DWORD PTR [eax+8]
	push	edx
	sub	esp, 8
	lea	eax, DWORD PTR _pUnit$222429[esp+172]
	mov	ecx, esp
	mov	DWORD PTR $T304499[esp+172], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, ebp
	call	?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ; CvTacticalAI::MoveWithFormation
$LN54@PlotNavalE:

; 4557 : 					}
; 4558 : 				}

	cmp	DWORD PTR _pUnit$222429[esp+160], 0
	mov	DWORD PTR __$EHRec$[esp+168], -1
	je	SHORT $LN57@PlotNavalE
	mov	ecx, DWORD PTR _pUnit$222429[esp+160]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN57@PlotNavalE:
	add	DWORD PTR tv2274[esp+160], 12		; 0000000cH
	mov	ecx, esi
	inc	edi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	edi, eax
	jl	$LN58@PlotNavalE
$LN56@PlotNavalE:

; 4559 : 			}
; 4560 : 
; 4561 : 			// Plot one turn of movement for the first unit in the army we find out in the water
; 4562 : 			UnitHandle pUnitAtSea = pThisArmy->GetFirstUnitInDomain(DOMAIN_SEA);

	xor	edi, edi
	push	edi
	lea	ecx, DWORD PTR _pUnitAtSea$222433[esp+164]
	push	ecx
	mov	ecx, esi
	call	?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z ; CvArmyAI::GetFirstUnitInDomain
	mov	DWORD PTR __$EHRec$[esp+168], 10	; 0000000aH

; 4563 : 			if(!pUnitAtSea)

	cmp	DWORD PTR _pUnitAtSea$222433[esp+160], edi
	jne	$LN53@PlotNavalE

; 4564 : 			{
; 4565 : 				pOperation->RetargetCivilian(pCivilian, pThisArmy);

	mov	ecx, DWORD PTR _pOperation$[esp+156]
	push	esi
	push	ebx
	call	?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAINavalEscortedOperation::RetargetCivilian

; 4566 : 				for(int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	ecx, esi
	mov	DWORD PTR _iI$222436[esp+160], edi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	SHORT $LN50@PlotNavalE

; 4564 : 			{
; 4565 : 				pOperation->RetargetCivilian(pCivilian, pThisArmy);

	xor	ebx, ebx
	npad	4
$LL52@PlotNavalE:

; 4567 : 				{
; 4568 : 					CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(iI);

	mov	eax, DWORD PTR [esi+44]
	add	eax, ebx

; 4569 : 					if(pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [eax]
	cmp	eax, -1
	je	SHORT $LN51@PlotNavalE

; 4570 : 					{
; 4571 : 						UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$222442[esp+160], edi
	mov	BYTE PTR _pUnit$222442[esp+164], 0
	test	edi, edi
	je	SHORT $LN303@PlotNavalE
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN303@PlotNavalE:
	mov	BYTE PTR __$EHRec$[esp+168], 11		; 0000000bH

; 4572 : 						if(pUnit)

	test	edi, edi
	je	SHORT $LN48@PlotNavalE

; 4573 : 						{
; 4574 : 							pUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN48@PlotNavalE:

; 4575 : 						}
; 4576 : 					}

	mov	BYTE PTR __$EHRec$[esp+168], 10		; 0000000aH
	test	edi, edi
	je	SHORT $LN51@PlotNavalE
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN51@PlotNavalE:
	mov	edi, DWORD PTR _iI$222436[esp+160]
	inc	edi
	mov	ecx, esi
	mov	DWORD PTR _iI$222436[esp+160], edi
	add	ebx, 12					; 0000000cH
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	edi, eax
	jl	SHORT $LL52@PlotNavalE
$LN50@PlotNavalE:

; 4577 : 				}
; 4578 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN2@PlotNavalE
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN2@PlotNavalE

; 4579 : 				{
; 4580 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222445[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4581 : 					strLogString.Format("Retargeting naval escort operation (no unit in water!), X: %d, Y: %d", pOperation->GetTargetPlot()->getX(), pOperation->GetTargetPlot()->getY());

	mov	edi, DWORD PTR _pOperation$[esp+156]
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+168], 12		; 0000000cH
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	esi, WORD PTR [eax+2]
	mov	ecx, edi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	edx, WORD PTR [eax]
	push	esi
	push	edx
	lea	eax, DWORD PTR _strLogString$222445[esp+168]
	push	OFFSET $SG222446
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4582 : 					LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222445[esp+164]
	push	ecx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4583 : 				}

	lea	ecx, DWORD PTR _strLogString$222445[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 10		; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4584 : 			}
; 4585 : 			else

	jmp	$LN2@PlotNavalE
$LN53@PlotNavalE:

; 4586 : 			{
; 4587 : 				int iFlags;
; 4588 : 				if(pThisArmy->GetUnitsOfType((MultiunitPositionTypes)m_CachedInfoTypes[eMUPOSITION_NAVAL_ESCORT]) > 0)

	mov	edx, DWORD PTR [ebp+29380]
	push	edx
	mov	ecx, esi
	call	?GetUnitsOfType@CvArmyAI@@QBEHW4MultiunitPositionTypes@@@Z ; CvArmyAI::GetUnitsOfType

; 4589 : 				{
; 4590 : 					iFlags = MOVE_UNITS_IGNORE_DANGER;
; 4591 : 				}
; 4592 : 
; 4593 : 				// Goal should be a water tile one hex shy of our target
; 4594 : 				for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$222451[esp+160], edi
$LL44@PlotNavalE:

; 4595 : 				{
; 4596 : 					CvPlot* pAdjacentPlot = plotDirection(pThisArmy->GetGoalX(), pThisArmy->GetGoalY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR _iI$222451[esp+160]
	push	eax
	mov	ecx, esi
	call	?GetGoalY@CvArmyAI@@QBEHXZ		; CvArmyAI::GetGoalY
	push	eax
	mov	ecx, esi
	call	?GetGoalX@CvArmyAI@@QBEHXZ		; CvArmyAI::GetGoalX
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 4597 : 					if(pAdjacentPlot != NULL && pAdjacentPlot->isWater())

	test	ebx, ebx
	je	$LN43@PlotNavalE
	cmp	BYTE PTR [ebx+5], 3
	jne	$LN43@PlotNavalE

; 4598 : 					{
; 4599 : 						if(pUnitAtSea->plot() == pAdjacentPlot)

	mov	ecx, DWORD PTR _pUnitAtSea$222433[esp+160]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	je	$LN495@PlotNavalE

; 4602 : 							break;
; 4603 : 						}
; 4604 : 						else
; 4605 : 						{
; 4606 : 							// Using step finder could get tripped up by ocean hexes (since they are in the area but not valid movement targets for coastal vessels.  Watch this!
; 4607 : 							int iDistance = GC.getStepFinder().GetStepDistanceBetweenPoints(m_pPlayer->GetID(), pOperation->GetEnemy(), pUnitAtSea->plot(), pAdjacentPlot);

	mov	ecx, DWORD PTR [ebp]
	mov	edi, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _pUnitAtSea$222433[esp+160]
	push	ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR _pOperation$[esp+160]
	push	eax
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	push	eax
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
	mov	edi, eax
	mov	DWORD PTR _iDistance$222460[esp+160], edi

; 4608 : 							if(iDistance > 0 && iDistance < iBestDistance)

	test	edi, edi
	jle	SHORT $LN43@PlotNavalE
	cmp	edi, DWORD PTR _iBestDistance$222421[esp+160]
	jge	SHORT $LN43@PlotNavalE

; 4609 : 							{
; 4610 : 								iBestDistance = iDistance;
; 4611 : 								int iDistanceToMove = min(4, iDistance);

	cmp	edi, 4
	mov	DWORD PTR _iBestDistance$222421[esp+160], edi
	mov	DWORD PTR $T304500[esp+160], 4
	lea	eax, DWORD PTR _iDistance$222460[esp+160]
	jl	SHORT $LN337@PlotNavalE
	lea	eax, DWORD PTR $T304500[esp+160]
$LN337@PlotNavalE:
	mov	edx, DWORD PTR [eax]

; 4612 : 								PlayerTypes eEnemy = pOperation->GetEnemy();

	mov	ecx, DWORD PTR _pOperation$[esp+156]
	mov	DWORD PTR _iDistanceToMove$222462[esp+160], edx
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy

; 4613 : 								pBestPlot = GC.getStepFinder().GetXPlotsFromEnd(m_pPlayer->GetID(), eEnemy, pUnitAtSea->plot(), pAdjacentPlot, (iDistance - iDistanceToMove), false);

	sub	edi, DWORD PTR _iDistanceToMove$222462[esp+160]
	mov	DWORD PTR _eEnemy$222469[esp+160], eax
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	0
	push	edi
	mov	DWORD PTR $T304924[esp+168], ecx
	mov	ecx, DWORD PTR _pUnitAtSea$222433[esp+168]
	push	ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	edx, DWORD PTR _eEnemy$222469[esp+172]
	push	eax
	mov	eax, DWORD PTR $T304924[esp+176]
	push	edx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd
	mov	DWORD PTR _pBestPlot$222422[esp+160], eax
$LN43@PlotNavalE:
	mov	eax, DWORD PTR _iI$222451[esp+160]
	inc	eax
	cmp	eax, 6
	mov	DWORD PTR _iI$222451[esp+160], eax
	jl	$LL44@PlotNavalE

; 4598 : 					{
; 4599 : 						if(pUnitAtSea->plot() == pAdjacentPlot)

	jmp	SHORT $LN42@PlotNavalE
$LN495@PlotNavalE:

; 4600 : 						{
; 4601 : 							pBestPlot = pAdjacentPlot;

	mov	DWORD PTR _pBestPlot$222422[esp+160], ebx
$LN42@PlotNavalE:

; 4614 : 							}
; 4615 : 						}
; 4616 : 					}
; 4617 : 				}
; 4618 : 
; 4619 : 				if(pBestPlot == NULL)

	cmp	DWORD PTR _pBestPlot$222422[esp+160], 0
	jne	$LN37@PlotNavalE

; 4620 : 				{
; 4621 : 					pOperation->RetargetCivilian(pCivilian, pThisArmy);

	mov	ecx, DWORD PTR _pCivilian$[esp+160]
	mov	edi, DWORD PTR _pOperation$[esp+156]
	push	esi
	push	ecx
	mov	ecx, edi
	call	?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAINavalEscortedOperation::RetargetCivilian

; 4622 : 					for(int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	xor	ebx, ebx
	mov	ecx, esi
	mov	DWORD PTR _iI$222471[esp+160], ebx
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	SHORT $LN34@PlotNavalE
	npad	7
$LL36@PlotNavalE:

; 4623 : 					{
; 4624 : 						CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(iI);

	mov	eax, DWORD PTR [esi+44]
	add	eax, ebx

; 4625 : 						if(pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [eax]
	cmp	eax, -1
	je	SHORT $LN35@PlotNavalE

; 4626 : 						{
; 4627 : 							UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$222477[esp+160], edi
	mov	BYTE PTR _pUnit$222477[esp+164], 0
	test	edi, edi
	je	SHORT $LN355@PlotNavalE
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN355@PlotNavalE:
	mov	BYTE PTR __$EHRec$[esp+168], 13		; 0000000dH

; 4628 : 							if(pUnit)

	test	edi, edi
	je	SHORT $LN32@PlotNavalE

; 4629 : 							{
; 4630 : 								pUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN32@PlotNavalE:

; 4631 : 							}
; 4632 : 						}

	mov	BYTE PTR __$EHRec$[esp+168], 10		; 0000000aH
	test	edi, edi
	je	SHORT $LN35@PlotNavalE
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN35@PlotNavalE:
	mov	edi, DWORD PTR _iI$222471[esp+160]
	inc	edi
	mov	ecx, esi
	mov	DWORD PTR _iI$222471[esp+160], edi
	add	ebx, 12					; 0000000cH
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	edi, eax
	jl	SHORT $LL36@PlotNavalE

; 4622 : 					for(int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	edi, DWORD PTR _pOperation$[esp+156]
$LN34@PlotNavalE:

; 4633 : 					}
; 4634 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN2@PlotNavalE
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN2@PlotNavalE

; 4635 : 					{
; 4636 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222480[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4637 : 						strLogString.Format("Retargeting naval escort operation (path lost to target), X: %d, Y: %d", pOperation->GetTargetPlot()->getX(), pOperation->GetTargetPlot()->getY());

	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+168], 14		; 0000000eH
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	esi, WORD PTR [eax+2]
	mov	ecx, edi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	edx, WORD PTR [eax]
	push	esi
	push	edx
	lea	eax, DWORD PTR _strLogString$222480[esp+168]
	push	OFFSET $SG222481
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4638 : 						LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222480[esp+164]
	push	ecx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4639 : 					}

	lea	ecx, DWORD PTR _strLogString$222480[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 10		; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4640 : 				}
; 4641 : 				else

	jmp	$LN2@PlotNavalE
$LN37@PlotNavalE:

; 4642 : 				{
; 4643 : 					ExecuteNavalFormationMoves(pThisArmy, pBestPlot);

	mov	edx, DWORD PTR _pBestPlot$222422[esp+160]
	push	edx

; 4644 : 				}
; 4645 : 			}
; 4646 : 		}

	jmp	$LN526@PlotNavalE
$LN76@PlotNavalE:

; 4647 : 	}
; 4648 : 
; 4649 : 	// MOVING TO TARGET as an army
; 4650 : 	else if(pThisArmy->GetArmyAIState() == ARMYAISTATE_MOVING_TO_DESTINATION && !pOperation->IsCivilianRequired())

	mov	ecx, esi
	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState
	cmp	eax, 2
	jne	$LN484@PlotNavalE
	mov	edi, DWORD PTR _pOperation$[esp+156]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+144]
	mov	ecx, edi
	call	edx
	test	al, al
	jne	$LN484@PlotNavalE

; 4651 : 	{
; 4652 : 		int iBestDistance = MAX_INT;
; 4653 : 		int iDistance;
; 4654 : 		CvPlot *pBestPlot = NULL;
; 4655 : 		int iSlowestMovementRate = MAX_INT;

	mov	DWORD PTR _iSlowestMovementRate$222488[esp+160], 2147483647 ; 7fffffffH

; 4656 : 		UnitHandle pClosestUnitAtSea;

	mov	DWORD PTR _pClosestUnitAtSea$222489[esp+160], 0
	mov	BYTE PTR _pClosestUnitAtSea$222489[esp+164], al

; 4657 : 		pBestPlot = m_pPlayer->GetMilitaryAI()->GetCoastalPlotAdjacentToTarget(pThisArmy->GetGoalPlot(), pThisArmy);

	push	esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+172], 15	; 0000000fH
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
	mov	DWORD PTR _pBestPlot$222487[esp+160], eax

; 4658 : 
; 4659 : 		// Error handling: couldn't find path to plot next to target
; 4660 : 		if (pBestPlot == NULL)

	test	eax, eax
	jne	$LN27@PlotNavalE

; 4661 : 		{
; 4662 : 			pOperation->RetargetCivilian(pCivilian, pThisArmy);

	push	esi
	push	ebx
	mov	ecx, edi
	call	?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAINavalEscortedOperation::RetargetCivilian

; 4663 : 			for (int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	xor	edi, edi
	mov	ecx, esi
	mov	DWORD PTR _iI$222491[esp+160], edi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	SHORT $LN24@PlotNavalE
$LL26@PlotNavalE:

; 4664 : 			{
; 4665 : 				CvArmyFormationSlot *pSlot = pThisArmy->GetFormationSlot(iI);

	mov	eax, DWORD PTR [esi+44]
	add	eax, edi

; 4666 : 				if (pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [eax]
	cmp	eax, -1
	je	SHORT $LN25@PlotNavalE

; 4667 : 				{
; 4668 : 					UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	push	eax
	lea	ecx, DWORD PTR _pUnit$222497[esp+164]
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>

; 4669 : 					if (pUnit) 

	mov	ebx, DWORD PTR _pUnit$222497[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 16		; 00000010H
	test	ebx, ebx
	je	SHORT $LN22@PlotNavalE

; 4670 : 					{
; 4671 : 						pUnit->finishMoves();

	mov	ecx, ebx
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN22@PlotNavalE:

; 4672 : 					}
; 4673 : 				}

	mov	BYTE PTR __$EHRec$[esp+168], 15		; 0000000fH
	test	ebx, ebx
	je	SHORT $LN25@PlotNavalE
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN25@PlotNavalE:
	mov	ebx, DWORD PTR _iI$222491[esp+160]
	inc	ebx
	mov	ecx, esi
	mov	DWORD PTR _iI$222491[esp+160], ebx
	add	edi, 12					; 0000000cH
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	ebx, eax
	jl	SHORT $LL26@PlotNavalE
$LN24@PlotNavalE:

; 4674 : 			}
; 4675 : 			if (GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN2@PlotNavalE
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN2@PlotNavalE

; 4676 : 			{
; 4677 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222500[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4678 : 				strLogString.Format("Retargeting naval escort operation (path lost to target), X: %d, Y: %d", pOperation->GetTargetPlot()->getX(), pOperation->GetTargetPlot()->getY());

	mov	edi, DWORD PTR _pOperation$[esp+156]
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+168], 17		; 00000011H
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	esi, WORD PTR [eax+2]
	mov	ecx, edi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	eax, WORD PTR [eax]
	push	esi
	push	eax
	lea	ecx, DWORD PTR _strLogString$222500[esp+168]
	push	OFFSET $SG222501
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4679 : 				LogTacticalMessage(strLogString);

	push	1
	lea	edx, DWORD PTR _strLogString$222500[esp+164]
	push	edx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4680 : 			}

	lea	ecx, DWORD PTR _strLogString$222500[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 15		; 0000000fH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4681 : 		}
; 4682 : 
; 4683 : 		else

	jmp	$LN2@PlotNavalE
$LN27@PlotNavalE:

; 4687 : 			for (int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	ecx, esi
	mov	DWORD PTR _iBestDistance$222485[esp+160], 2147483647 ; 7fffffffH
	mov	DWORD PTR _iI$222503[esp+160], 0
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	$LN506@PlotNavalE

; 4684 : 		{
; 4685 : 			// Request moves for all units, getting the slowest movement rate and the closest unit
; 4686 : 			iBestDistance = MAX_INT;

	mov	DWORD PTR tv2314[esp+160], 0
$LL19@PlotNavalE:

; 4688 : 			{
; 4689 : 				CvArmyFormationSlot *pSlot = pThisArmy->GetFormationSlot(iI);

	mov	eax, DWORD PTR [esi+44]
	add	eax, DWORD PTR tv2314[esp+160]

; 4690 : 				if (pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [eax]
	cmp	eax, -1
	je	$LN18@PlotNavalE

; 4691 : 				{
; 4692 : 					UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	push	eax
	lea	ecx, DWORD PTR _pUnit$222509[esp+164]
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>

; 4693 : 					if (pUnit && !pUnit->TurnProcessed())

	mov	edi, DWORD PTR _pUnit$222509[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 18		; 00000012H
	test	edi, edi
	je	$LN12@PlotNavalE
	mov	ecx, edi
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	$LN12@PlotNavalE

; 4694 : 					{
; 4695 : 						CvMultiUnitFormationInfo* pMultiUnitFormationInfo = GC.getMultiUnitFormationInfo(pThisArmy->GetFormationIndex());

	mov	ecx, esi
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo

; 4696 : 						if (pMultiUnitFormationInfo)

	test	eax, eax
	je	$LN12@PlotNavalE

; 4697 : 						{
; 4698 : 							const CvFormationSlotEntry& thisSlotEntry = pMultiUnitFormationInfo->getFormationSlotEntry(iI);

	mov	ecx, DWORD PTR _iI$222503[esp+160]
	push	ecx
	mov	ecx, eax
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry

; 4699 : 							MoveWithFormation(pUnit, thisSlotEntry.m_ePositionType);

	mov	edx, DWORD PTR [eax+8]
	push	edx
	sub	esp, 8
	lea	eax, DWORD PTR _pUnit$222509[esp+172]
	mov	ecx, esp
	mov	DWORD PTR $T304501[esp+172], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, ebp
	call	?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ; CvTacticalAI::MoveWithFormation

; 4700 : 
; 4701 : 							int iMoves = pUnit->getMoves() / GC.getMOVE_DENOMINATOR();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	ecx, edi
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	cdq
	idiv	ebx

; 4702 : 							if (iMoves < iSlowestMovementRate)

	cmp	eax, DWORD PTR _iSlowestMovementRate$222488[esp+160]
	jge	SHORT $LN13@PlotNavalE

; 4703 : 							{
; 4704 : 								iSlowestMovementRate = iMoves;

	mov	DWORD PTR _iSlowestMovementRate$222488[esp+160], eax
$LN13@PlotNavalE:

; 4705 : 							}
; 4706 : 
; 4707 : 							// At sea?
; 4708 : 							iDistance = GC.getStepFinder().GetStepDistanceBetweenPoints(m_pPlayer->GetID(), pOperation->GetEnemy(), pUnit->plot(), pBestPlot);

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR _pBestPlot$222487[esp+160]
	mov	ebx, DWORD PTR [ecx+44]
	push	edx
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR _pOperation$[esp+160]
	push	eax
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	push	eax
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints

; 4709 : 							if (iDistance > 0 && iDistance < iBestDistance)

	test	eax, eax
	jle	SHORT $LN12@PlotNavalE
	cmp	eax, DWORD PTR _iBestDistance$222485[esp+160]
	jge	SHORT $LN12@PlotNavalE

; 4710 : 							{
; 4711 : 								iBestDistance = iDistance;

	mov	DWORD PTR _iBestDistance$222485[esp+160], eax

; 4712 : 								pClosestUnitAtSea = pUnit;

	lea	eax, DWORD PTR _pUnit$222509[esp+160]
	push	eax
	lea	ecx, DWORD PTR _pClosestUnitAtSea$222489[esp+164]
	call	??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z ; FObjectHandle<CvUnit>::operator=
$LN12@PlotNavalE:

; 4713 : 							}
; 4714 : 						}
; 4715 : 					}
; 4716 : 				}

	mov	BYTE PTR __$EHRec$[esp+168], 15		; 0000000fH
	test	edi, edi
	je	SHORT $LN18@PlotNavalE
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN18@PlotNavalE:
	mov	edi, DWORD PTR _iI$222503[esp+160]
	add	DWORD PTR tv2314[esp+160], 12		; 0000000cH
	inc	edi
	mov	ecx, esi
	mov	DWORD PTR _iI$222503[esp+160], edi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	edi, eax
	jl	$LL19@PlotNavalE

; 4717 : 			}	
; 4718 : 
; 4719 : 			// Error handling: no one at sea, retarget
; 4720 : 			if (!pClosestUnitAtSea)

	cmp	DWORD PTR _pClosestUnitAtSea$222489[esp+160], 0
	jne	$LN11@PlotNavalE
$LN506@PlotNavalE:

; 4721 : 			{
; 4722 : 				pOperation->RetargetCivilian(pCivilian, pThisArmy);

	mov	ecx, DWORD PTR _pCivilian$[esp+160]
	push	esi
	push	ecx
	mov	ecx, DWORD PTR _pOperation$[esp+164]
	call	?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAINavalEscortedOperation::RetargetCivilian

; 4723 : 				for (int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	xor	ebx, ebx
	mov	ecx, esi
	mov	DWORD PTR _iI$222519[esp+160], ebx
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	SHORT $LN8@PlotNavalE
	npad	7
$LL10@PlotNavalE:

; 4724 : 				{
; 4725 : 					CvArmyFormationSlot *pSlot = pThisArmy->GetFormationSlot(iI);

	mov	eax, DWORD PTR [esi+44]
	add	eax, ebx

; 4726 : 					if (pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [eax]
	cmp	eax, -1
	je	SHORT $LN9@PlotNavalE

; 4727 : 					{
; 4728 : 						UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$222525[esp+160], edi
	mov	BYTE PTR _pUnit$222525[esp+164], 0
	test	edi, edi
	je	SHORT $LN450@PlotNavalE
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN450@PlotNavalE:
	mov	BYTE PTR __$EHRec$[esp+168], 19		; 00000013H

; 4729 : 						if (pUnit) 

	test	edi, edi
	je	SHORT $LN6@PlotNavalE

; 4730 : 						{
; 4731 : 							pUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN6@PlotNavalE:

; 4732 : 						}
; 4733 : 					}

	mov	BYTE PTR __$EHRec$[esp+168], 15		; 0000000fH
	test	edi, edi
	je	SHORT $LN9@PlotNavalE
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@PlotNavalE:
	mov	edi, DWORD PTR _iI$222519[esp+160]
	inc	edi
	mov	ecx, esi
	mov	DWORD PTR _iI$222519[esp+160], edi
	add	ebx, 12					; 0000000cH
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	edi, eax
	jl	SHORT $LL10@PlotNavalE
$LN8@PlotNavalE:

; 4734 : 				}
; 4735 : 				if (GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN2@PlotNavalE
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN2@PlotNavalE

; 4736 : 				{
; 4737 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$222528[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4738 : 					strLogString.Format("Retargeting naval escort operation (no unit in water!), X: %d, Y: %d", pOperation->GetTargetPlot()->getX(), pOperation->GetTargetPlot()->getY());

	mov	edi, DWORD PTR _pOperation$[esp+156]
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+168], 20		; 00000014H
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	esi, WORD PTR [eax+2]
	mov	ecx, edi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	edx, WORD PTR [eax]
	push	esi
	push	edx
	lea	eax, DWORD PTR _strLogString$222528[esp+168]
	push	OFFSET $SG222529
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4739 : 					LogTacticalMessage(strLogString);

	push	1
	lea	ecx, DWORD PTR _strLogString$222528[esp+164]
	push	ecx
	mov	ecx, ebp
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 4740 : 				}

	lea	ecx, DWORD PTR _strLogString$222528[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 15		; 0000000fH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4741 : 			}
; 4742 : 			else

	jmp	SHORT $LN2@PlotNavalE
$LN11@PlotNavalE:

; 4743 : 			{
; 4744 : 				// If not close yet, find best plot for this turn's movement along path to ultimate best plot
; 4745 : 				if (iBestDistance > iSlowestMovementRate)

	mov	eax, DWORD PTR _iBestDistance$222485[esp+160]
	mov	ecx, DWORD PTR _iSlowestMovementRate$222488[esp+160]
	cmp	eax, ecx
	jle	SHORT $LN508@PlotNavalE

; 4746 : 				{
; 4747 : 					pBestPlot = GC.getStepFinder().GetXPlotsFromEnd(m_pPlayer->GetID(), pOperation->GetEnemy(), pClosestUnitAtSea->plot(), pBestPlot, (iBestDistance - iSlowestMovementRate), true);					

	mov	edx, DWORD PTR [ebp]
	mov	edi, DWORD PTR [edx+44]
	sub	eax, ecx
	mov	ecx, DWORD PTR _pClosestUnitAtSea$222489[esp+160]
	push	1
	push	eax
	mov	eax, DWORD PTR _pBestPlot$222487[esp+168]
	push	eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR _pOperation$[esp+168]
	push	eax
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	push	eax
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd
	mov	edi, eax
	jmp	SHORT $LN3@PlotNavalE
$LN508@PlotNavalE:
	mov	edi, DWORD PTR _pBestPlot$222487[esp+160]
$LN3@PlotNavalE:

; 4748 : 				}
; 4749 : 				if (pBestPlot)

	test	edi, edi
	je	SHORT $LN2@PlotNavalE

; 4750 : 				{
; 4751 : 					pThisArmy->SetXY(pBestPlot->getX(), pBestPlot->getY());

	movsx	ecx, WORD PTR [edi+2]
	movsx	edx, WORD PTR [edi]
	push	ecx
	push	edx
	mov	ecx, esi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 4752 : 					ExecuteNavalFormationMoves(pThisArmy, pBestPlot);

	push	edi
$LN526@PlotNavalE:
	push	esi
	mov	ecx, ebp
	call	?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ; CvTacticalAI::ExecuteNavalFormationMoves
$LN2@PlotNavalE:

; 4753 : 				}
; 4754 : 				else
; 4755 : 				{
; 4756 : 					CvAssertMsg (false, "Naval operation logic error.");
; 4757 : 				}
; 4758 : 			}
; 4759 : 		}
; 4760 : 	}

	mov	ecx, DWORD PTR _pClosestUnitAtSea$222489[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], -1
	test	ecx, ecx
	je	SHORT $LN484@PlotNavalE
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN484@PlotNavalE:

; 4761 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+160]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 144				; 00000090H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$222368[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$4:
	lea	ecx, DWORD PTR _strMsg$222389[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$8:
	lea	ecx, DWORD PTR _strTemp$222398[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$9:
	lea	ecx, DWORD PTR _strLogString$222399[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$11:
	lea	ecx, DWORD PTR _strTemp$222404[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$12:
	lea	ecx, DWORD PTR _strLogString$222405[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$13:
	lea	ecx, DWORD PTR _pUnit$222413[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$15:
	lea	ecx, DWORD PTR _strTemp$222417[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$16:
	lea	ecx, DWORD PTR _strLogString$222418[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$17:
	lea	ecx, DWORD PTR _pUnit$222429[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$19:
	lea	ecx, DWORD PTR _pUnitAtSea$222433[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$20:
	lea	ecx, DWORD PTR _pUnit$222442[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$21:
	lea	ecx, DWORD PTR _strLogString$222445[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$22:
	lea	ecx, DWORD PTR _pUnit$222477[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$23:
	lea	ecx, DWORD PTR _strLogString$222480[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$24:
	lea	ecx, DWORD PTR _pClosestUnitAtSea$222489[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$25:
	lea	ecx, DWORD PTR _pUnit$222497[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$26:
	lea	ecx, DWORD PTR _strLogString$222500[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$27:
	lea	ecx, DWORD PTR _pUnit$222509[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$29:
	lea	ecx, DWORD PTR _pUnit$222525[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z$30:
	lea	ecx, DWORD PTR _strLogString$222528[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z ENDP ; CvTacticalAI::PlotNavalEscortOperationMoves
PUBLIC	?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z ; CvTacticalAI::PlotFreeformNavalOperationMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z$0
__ehfuncinfo$?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
_iI$222543 = -32					; size = 4
tv422 = -28						; size = 4
$T305236 = -24						; size = 4
$T305235 = -24						; size = 4
$T305234 = -24						; size = 4
_pUnit$222549 = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pOperation$ = 8					; size = 4
?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z PROC ; CvTacticalAI::PlotFreeformNavalOperationMoves, COMDAT
; _this$ = ecx

; 4765 : {

	push	-1
	push	__ehhandler$?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp

; 4766 : 	// Simplification - assume only 1 army per operation now
; 4767 : 	if(pOperation->GetFirstArmyID() == -1)

	mov	ebp, DWORD PTR _pOperation$[esp+40]
	push	esi
	mov	ebx, ecx
	push	edi
	mov	ecx, ebp
	mov	DWORD PTR _this$[esp+52], ebx
	call	?GetFirstArmyID@CvAIOperation@@QAEHXZ	; CvAIOperation::GetFirstArmyID
	cmp	eax, -1
	je	$LN1@PlotFreefo

; 4768 : 	{
; 4769 : 		return;
; 4770 : 	}
; 4771 : 	CvArmyAI* pThisArmy = m_pPlayer->getArmyAI(pOperation->GetFirstArmyID());

	mov	ecx, ebp
	call	?GetFirstArmyID@CvAIOperation@@QAEHXZ	; CvAIOperation::GetFirstArmyID
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	esi, eax

; 4772 : 
; 4773 : 	m_OperationUnits.clear();

	xor	edi, edi

; 4774 : 	pThisArmy->UpdateCheckpointTurns();

	mov	ecx, esi
	mov	DWORD PTR [ebx+28648], edi
	call	?UpdateCheckpointTurns@CvArmyAI@@QAEXXZ	; CvArmyAI::UpdateCheckpointTurns

; 4775 : 
; 4776 : 	// RECRUITING
; 4777 : 	if(pThisArmy->GetArmyAIState() == ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE)

	mov	ecx, esi
	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState

; 4778 : 	{
; 4779 : 		// If no estimate for when recruiting will end, let the rest of the AI use these units
; 4780 : 		if(pThisArmy->GetTurnAtNextCheckpoint() == ARMYSLOT_UNKNOWN_TURN_AT_CHECKPOINT)

	mov	ecx, esi
	test	eax, eax
	jne	$LN16@PlotFreefo
	call	?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ ; CvArmyAI::GetTurnAtNextCheckpoint
	cmp	eax, -1
	je	$LN1@PlotFreefo

; 4781 : 		{
; 4782 : 			return;
; 4783 : 		}
; 4784 : 		else
; 4785 : 		{
; 4786 : 			for(int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	ecx, esi
	mov	DWORD PTR _iI$222543[esp+52], edi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	$LN11@PlotFreefo
	mov	DWORD PTR tv422[esp+52], edi
$LN13@PlotFreefo:

; 4787 : 			{
; 4788 : 				CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(iI);

	mov	edi, DWORD PTR [esi+44]
	add	edi, DWORD PTR tv422[esp+52]

; 4789 : 				if(pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [edi]
	cmp	eax, -1
	je	$LN12@PlotFreefo

; 4790 : 				{
; 4791 : 					// See if we are just able to get to muster point in time.  If so, time for us to head over there
; 4792 : 					UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebp, eax
	mov	DWORD PTR _pUnit$222549[esp+52], ebp
	mov	BYTE PTR _pUnit$222549[esp+56], 0
	test	ebp, ebp
	je	SHORT $LN43@PlotFreefo
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN43@PlotFreefo:
	mov	DWORD PTR __$EHRec$[esp+60], 0

; 4793 : 					if(pUnit && !pUnit->TurnProcessed())

	test	ebp, ebp
	je	$LN5@PlotFreefo
	mov	ecx, ebp
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	$LN5@PlotFreefo

; 4794 : 					{
; 4795 : 						CvMultiUnitFormationInfo* pkMultiUnitFormationInfo = GC.getMultiUnitFormationInfo(pThisArmy->GetFormationIndex());

	mov	ecx, esi
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo

; 4796 : 						if(pkMultiUnitFormationInfo)

	test	eax, eax
	je	$LN5@PlotFreefo

; 4797 : 						{
; 4798 : 							const CvFormationSlotEntry& thisSlotEntry = pkMultiUnitFormationInfo->getFormationSlotEntry(iI);

	mov	ecx, DWORD PTR _iI$222543[esp+52]
	push	ecx
	mov	ecx, eax
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry

; 4799 : 
; 4800 : 							// Continue moving to target
; 4801 : 							if(pSlot->HasStartedOnOperation())

	cmp	DWORD PTR [edi+8], 0
	mov	ebx, eax
	je	SHORT $LN7@PlotFreefo

; 4802 : 							{
; 4803 : 								MoveWithFormation(pUnit, thisSlotEntry.m_ePositionType);

	mov	edx, DWORD PTR [ebx+8]
	push	edx
	sub	esp, 8
	lea	eax, DWORD PTR _pUnit$222549[esp+64]
	mov	ecx, esp
	mov	DWORD PTR $T305234[esp+64], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, DWORD PTR _this$[esp+64]
	call	?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ; CvTacticalAI::MoveWithFormation

; 4804 : 							}
; 4805 : 							else

	jmp	SHORT $LN69@PlotFreefo
$LN7@PlotFreefo:

; 4806 : 							{
; 4807 : 								// See if we are just able to get to muster point in time.  If so, time for us to head over there
; 4808 : 								int iTurns = TurnsToReachTarget(pUnit, pOperation->GetMusterPlot(), true /*bReusePaths*/, true, true);

	mov	ecx, DWORD PTR _pOperation$[esp+48]
	push	1
	push	1
	push	1
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pUnit$222549[esp+76]
	mov	ecx, esp
	mov	DWORD PTR $T305235[esp+76], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget

; 4809 : 								if(iTurns + GC.getGame().getGameTurn() >= pThisArmy->GetTurnAtNextCheckpoint())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esp, 24					; 00000018H
	mov	ebp, eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, esi
	add	ebp, eax
	call	?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ ; CvArmyAI::GetTurnAtNextCheckpoint
	cmp	ebp, eax
	jl	SHORT $LN62@PlotFreefo

; 4810 : 								{
; 4811 : 									pSlot->SetStartedOnOperation(true);

	mov	DWORD PTR [edi+8], 1

; 4812 : 									MoveWithFormation(pUnit, thisSlotEntry.m_ePositionType);

	mov	eax, DWORD PTR [ebx+8]
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pUnit$222549[esp+64]
	mov	ecx, esp
	mov	DWORD PTR $T305236[esp+64], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, DWORD PTR _this$[esp+64]
	call	?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ; CvTacticalAI::MoveWithFormation
$LN62@PlotFreefo:
	mov	ebp, DWORD PTR _pUnit$222549[esp+52]
$LN69@PlotFreefo:
	mov	ebx, DWORD PTR _this$[esp+52]
$LN5@PlotFreefo:

; 4813 : 								}
; 4814 : 							}
; 4815 : 						}
; 4816 : 					}
; 4817 : 				}

	mov	DWORD PTR __$EHRec$[esp+60], -1
	test	ebp, ebp
	je	SHORT $LN66@PlotFreefo
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN66@PlotFreefo:
	mov	ebp, DWORD PTR _pOperation$[esp+48]
$LN12@PlotFreefo:

; 4781 : 		{
; 4782 : 			return;
; 4783 : 		}
; 4784 : 		else
; 4785 : 		{
; 4786 : 			for(int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	edi, DWORD PTR _iI$222543[esp+52]
	add	DWORD PTR tv422[esp+52], 12		; 0000000cH
	inc	edi
	mov	ecx, esi
	mov	DWORD PTR _iI$222543[esp+52], edi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	edi, eax
	jl	$LN13@PlotFreefo
$LN11@PlotFreefo:

; 4818 : 			}
; 4819 : 			ExecuteNavalFormationMoves(pThisArmy, pOperation->GetMusterPlot());

	mov	ecx, ebp
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	push	esi
	mov	ecx, ebx
	call	?ExecuteNavalFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ; CvTacticalAI::ExecuteNavalFormationMoves

; 4837 : 	}
; 4838 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	4
$LN16@PlotFreefo:

; 4820 : 		}
; 4821 : 	}
; 4822 : 
; 4823 : 	// GATHERING FORCES
; 4824 : 	else if(pThisArmy->GetArmyAIState() == ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP)

	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState
	cmp	eax, 1

; 4825 : 	{
; 4826 : 		// Get them moving to target without delay
; 4827 : 		pOperation->ArmyInPosition(pThisArmy);
; 4828 : 		ExecuteFleetMoveToTarget(pThisArmy, pOperation->GetTargetPlot());

	je	SHORT $LN70@PlotFreefo

; 4829 : 	}
; 4830 : 
; 4831 : 	// MOVING TO TARGET
; 4832 : 	else if(pThisArmy->GetArmyAIState() == ARMYAISTATE_MOVING_TO_DESTINATION)

	mov	ecx, esi
	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState
	cmp	eax, 2
	jne	SHORT $LN1@PlotFreefo
$LN70@PlotFreefo:

; 4833 : 	{
; 4834 : 		// Get them moving to target without delay
; 4835 : 		pOperation->ArmyInPosition(pThisArmy);

	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+60]
	push	esi
	mov	ecx, ebp
	call	edx

; 4836 : 		ExecuteFleetMoveToTarget(pThisArmy, pOperation->GetTargetPlot());

	mov	ecx, ebp
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	push	esi
	mov	ecx, ebx
	call	?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ; CvTacticalAI::ExecuteFleetMoveToTarget
$LN1@PlotFreefo:

; 4837 : 	}
; 4838 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 36					; 00000024H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$222549[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z ENDP ; CvTacticalAI::PlotFreeformNavalOperationMoves
PUBLIC	?PlotEscortNavalOperationMoves@CvTacticalAI@@AAE_NPAVCvArmyAI@@@Z ; CvTacticalAI::PlotEscortNavalOperationMoves
EXTRN	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z:PROC ; CvPlayer::haveAIOperationOfType
; Function compile flags: /Ogtpy
;	COMDAT ?PlotEscortNavalOperationMoves@CvTacticalAI@@AAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_iOperationID$ = -4					; size = 4
_pArmy$ = 8						; size = 4
?PlotEscortNavalOperationMoves@CvTacticalAI@@AAE_NPAVCvArmyAI@@@Z PROC ; CvTacticalAI::PlotEscortNavalOperationMoves, COMDAT
; _this$ = ecx

; 5765 : {

	push	ecx
	push	esi

; 5766 : 	CvPlot* pTarget = NULL;
; 5767 : 	int iOperationID;
; 5768 : 	int iArmyID;
; 5769 : 	CvArmyAI* pArmyToEscort;
; 5770 : 
; 5771 : 	// Only one colonization operation at a time, so don't have to search for more than one
; 5772 : 	if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_COLONIZE, &iOperationID))

	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[esp+16]
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	11					; 0000000bH
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN1@PlotEscort@2

; 5773 : 	{
; 5774 : 		CvAIOperation* pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation

; 5775 : 		iArmyID = pOperation->GetFirstArmyID();

	mov	ecx, eax
	call	?GetFirstArmyID@CvAIOperation@@QAEHXZ	; CvAIOperation::GetFirstArmyID

; 5776 : 		if(iArmyID != -1)

	cmp	eax, -1
	je	SHORT $LN1@PlotEscort@2

; 5777 : 		{
; 5778 : 			pArmyToEscort = m_pPlayer->getArmyAI(iArmyID);

	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 5779 : 			if(pArmyToEscort)

	test	eax, eax
	je	SHORT $LN1@PlotEscort@2

; 5780 : 			{
; 5781 : 				pTarget = pArmyToEscort->GetCenterOfMass(DOMAIN_SEA);

	push	0
	mov	ecx, eax
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass

; 5782 : 			}
; 5783 : 		}
; 5784 : 	}
; 5785 : 
; 5786 : 	if(pTarget)

	test	eax, eax
	je	SHORT $LN1@PlotEscort@2

; 5787 : 	{
; 5788 : 		ExecuteFleetMoveToTarget(pArmy, pTarget);

	mov	edx, DWORD PTR _pArmy$[esp+4]
	push	eax
	push	edx
	mov	ecx, esi
	call	?ExecuteFleetMoveToTarget@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ; CvTacticalAI::ExecuteFleetMoveToTarget

; 5789 : 		return true;

	mov	al, 1
	pop	esi

; 5793 : }

	pop	ecx
	ret	4
$LN1@PlotEscort@2:

; 5790 : 	}
; 5791 : 
; 5792 : 	return false;

	xor	al, al
	pop	esi

; 5793 : }

	pop	ecx
	ret	4
?PlotEscortNavalOperationMoves@CvTacticalAI@@AAE_NPAVCvArmyAI@@@Z ENDP ; CvTacticalAI::PlotEscortNavalOperationMoves
_TEXT	ENDS
PUBLIC	?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteOneProtectedBombard
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$14
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z
_TEXT	SEGMENT
_iRange$ = -108						; size = 4
_pTargetPlot$ = -104					; size = 4
tv1506 = -100						; size = 4
_iPlotDistance$224405 = -100				; size = 4
_pAttackPlot$ = -100					; size = 4
_iDY$ = -96						; size = 4
_iAttackingUnitID$224432 = -92				; size = 4
_iDX$ = -92						; size = 4
_iI$224434 = -88					; size = 4
_iNumUnitsRequiredToCover$ = -88			; size = 4
tv1570 = -84						; size = 4
tv1509 = -80						; size = 4
_pFirstAttacker$ = -76					; size = 8
_strMsg$224476 = -68					; size = 28
_strMsg$224471 = -68					; size = 28
_strMsg$224466 = -68					; size = 28
_strMsg$224459 = -68					; size = 28
_strMsg$224454 = -68					; size = 28
_strMsg$224448 = -68					; size = 28
_strMsg$224442 = -68					; size = 28
_target$224425 = -68					; size = 28
$T305343 = -40						; size = 28
$T305342 = -40						; size = 28
$T305341 = -40						; size = 28
$T305340 = -40						; size = 28
$T305339 = -40						; size = 28
$T305338 = -40						; size = 28
$T305337 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_kTarget$ = 8						; size = 4
?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z PROC ; CvTacticalAI::ExecuteOneProtectedBombard, COMDAT
; _this$ = ecx

; 7663 : {

	push	-1
	push	__ehhandler$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 7664 : 	UnitHandle pFirstAttacker;

	xor	edi, edi
	mov	esi, ecx
	mov	DWORD PTR _pFirstAttacker$[esp+124], edi
	mov	BYTE PTR _pFirstAttacker$[esp+128], 0

; 7665 : 	int iDX, iDY;
; 7666 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 7667 : 	int iMaxDX;
; 7668 : #endif
; 7669 : 	CvPlot* pAttackPlot;
; 7670 : 	int iPlotIndex;
; 7671 : 	CvTacticalAnalysisCell* pCell;
; 7672 : 	int iPriority;
; 7673 : 	int iNumTurns;
; 7674 : 	int iNumUnitsRequiredToCover;
; 7675 : 
; 7676 : 	CvPlot* pTargetPlot = GC.getMap().plot(kTarget.GetTargetX(), kTarget.GetTargetY());

	mov	eax, DWORD PTR _kTarget$[esp+120]
	mov	ebp, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __$EHRec$[esp+132], edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN77@ExecuteOne
	cmp	ebp, -2147483647			; 80000001H
	je	$LN77@ExecuteOne
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN87@ExecuteOne
	cmp	eax, edi
	jge	SHORT $LN89@ExecuteOne
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN91@ExecuteOne
$LN89@ExecuteOne:
	cmp	eax, ecx
	jl	SHORT $LN87@ExecuteOne
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN91@ExecuteOne
$LN87@ExecuteOne:
	mov	edi, eax
$LN91@ExecuteOne:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebx, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN516@ExecuteOne
	test	ebp, ebp
	jge	SHORT $LN99@ExecuteOne
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN101@ExecuteOne
$LN99@ExecuteOne:
	cmp	ebp, ebx
	jl	SHORT $LN516@ExecuteOne
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN101@ExecuteOne
$LN516@ExecuteOne:
	mov	edx, ebp
$LN101@ExecuteOne:
	test	edi, edi
	jl	SHORT $LN77@ExecuteOne
	cmp	edi, ecx
	jge	SHORT $LN77@ExecuteOne
	test	edx, edx
	jl	SHORT $LN77@ExecuteOne
	cmp	edx, ebx
	jge	SHORT $LN77@ExecuteOne
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	ebx, ecx
	mov	DWORD PTR _pTargetPlot$[esp+124], ecx
	jmp	SHORT $LN79@ExecuteOne
$LN77@ExecuteOne:
	xor	ebx, ebx
	mov	DWORD PTR _pTargetPlot$[esp+124], ebx
$LN79@ExecuteOne:

; 7677 : 	if(PlotAlreadyTargeted(pTargetPlot) != -1)

	push	ebx
	mov	ecx, esi
	call	?PlotAlreadyTargeted@CvTacticalAI@@QAEHPAVCvPlot@@@Z ; CvTacticalAI::PlotAlreadyTargeted
	cmp	eax, -1

; 7678 : 	{
; 7679 : 		return false;

	jne	$LN499@ExecuteOne

; 7680 : 	}
; 7681 : 
; 7682 : 	CvCity* pCity = pTargetPlot->getPlotCity();

	mov	eax, DWORD PTR [ebx+104]
	test	eax, eax
	jl	SHORT $LN49@ExecuteOne
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN49@ExecuteOne
	mov	ecx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebx, eax

; 7683 : 	if(pCity != NULL)

	test	ebx, ebx
	je	SHORT $LN49@ExecuteOne

; 7684 : 	{
; 7685 : 		int iRequiredDamage = pCity->GetMaxHitPoints() - pCity->getDamage();

	mov	ecx, ebx
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, ebx
	mov	edi, eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	sub	edi, eax

; 7686 : 
; 7687 : 		// Can't eliminate a city with ranged fire, so don't target one if that low on health
; 7688 : 		if(iRequiredDamage <= 1)

	cmp	edi, 1

; 7689 : 		{
; 7690 : 			return false;

	jle	$LN499@ExecuteOne
$LN49@ExecuteOne:

; 7691 : 		}
; 7692 : 	}
; 7693 : 
; 7694 : 	int iRange = m_pMap->GetBestFriendlyRange();

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edx+28]

; 7695 : 	m_TempTargets.clear();
; 7696 : 
; 7697 : 	// Build a list of all plots that have LOS to target where no enemy unit is adjacent
; 7698 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 7699 : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 7700 : 	{
; 7701 : 		iMaxDX = iRange - MAX(0, iDY);
; 7702 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 7703 : #else
; 7704 : 	for(iDX = -(iRange); iDX <= iRange; iDX++)

	mov	eax, ecx
	neg	eax
	cmp	eax, ecx
	mov	DWORD PTR _iRange$[esp+124], ecx
	mov	DWORD PTR [esi+23708], 0
	mov	DWORD PTR tv1570[esp+124], eax
	mov	DWORD PTR _iDX$[esp+124], eax
	jg	$LN513@ExecuteOne
$LL48@ExecuteOne:

; 7705 : 	{
; 7706 : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	mov	eax, DWORD PTR tv1570[esp+124]
	cmp	eax, DWORD PTR _iRange$[esp+124]
	mov	DWORD PTR _iDY$[esp+124], eax
	jg	$LN47@ExecuteOne
	npad	12
$LL45@ExecuteOne:

; 7707 : #endif
; 7708 : 		{
; 7709 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 7710 : 			if (iDY == 0 && iDX == 0)
; 7711 : 				continue;
; 7712 : #endif
; 7713 : 			pAttackPlot = plotXY(kTarget.GetTargetX(), kTarget.GetTargetY(), iDX, iDY);

	mov	edx, DWORD PTR _iDY$[esp+124]
	mov	ecx, DWORD PTR _kTarget$[esp+120]
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+4]
	push	edx
	mov	edx, DWORD PTR _iDX$[esp+128]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv1506[esp+140], eax
	mov	DWORD PTR tv1509[esp+140], ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	edi, eax
	add	esp, 16					; 00000010H

; 7714 : 			if(pAttackPlot != NULL)

	test	edi, edi
	je	$LN44@ExecuteOne

; 7715 : 			{
; 7716 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 7717 : 				int iPlotDistance = hexDistance(iDX, iDY);
; 7718 : #else
; 7719 : 				int iPlotDistance = plotDistance(pAttackPlot->getX(), pAttackPlot->getY(), kTarget.GetTargetX(), kTarget.GetTargetY());

	mov	eax, DWORD PTR tv1506[esp+124]
	mov	ecx, DWORD PTR tv1509[esp+124]
	movsx	ebp, WORD PTR [edi+2]
	movsx	ebx, WORD PTR [edi]
	push	eax
	push	ecx
	push	ebp
	push	ebx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iPlotDistance$224405[esp+124], eax

; 7720 : #endif
; 7721 : #ifndef AUI_HEXSPACE_DX_LOOPS
; 7722 : 				if(iPlotDistance > 0 && iPlotDistance <= iRange)

	test	eax, eax
	jle	$LN44@ExecuteOne
	mov	edx, DWORD PTR _iRange$[esp+124]
	cmp	eax, edx
	jg	$LN44@ExecuteOne

; 7723 : #endif
; 7724 : 				{
; 7725 : 					iPlotIndex = GC.getMap().plotNum(pAttackPlot->getX(), pAttackPlot->getY());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ebp, DWORD PTR [eax+4020]

; 7726 : 					pCell = m_pMap->GetCell(iPlotIndex);

	mov	ecx, DWORD PTR [esi+4]
	add	ebp, ebx
	mov	eax, ebp
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+12]
	mov	ebx, eax

; 7727 : 					if(pCell->IsRevealed() && pCell->CanUseForOperationGathering())

	test	BYTE PTR [ebx], 1
	je	$LN44@ExecuteOne
	mov	ecx, ebx
	call	?CanUseForOperationGathering@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::CanUseForOperationGathering
	test	al, al
	je	$LN44@ExecuteOne

; 7728 : 					{
; 7729 : 						if(pCell->IsWithinRangeOfTarget())

	mov	edx, DWORD PTR [ebx]
	shr	edx, 17					; 00000011H
	test	dl, 1
	je	$LN44@ExecuteOne

; 7730 : 						{
; 7731 : 							// Check for adjacent enemy unit
; 7732 : 							CvPlot* pLoopPlot;
; 7733 : 							bool bNoEnemyAdjacent = true;

	mov	bl, 1

; 7734 : 							for(int iI = 0; iI < NUM_DIRECTION_TYPES && bNoEnemyAdjacent; iI++)

	xor	ebp, ebp
	npad	5
$LL38@ExecuteOne:
	test	bl, bl
	je	$LN44@ExecuteOne

; 7735 : 							{
; 7736 : 								pLoopPlot = plotDirection(pAttackPlot->getX(), pAttackPlot->getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	ebp
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 7737 : 								if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN37@ExecuteOne

; 7738 : 								{
; 7739 : 									iPlotIndex = GC.getMap().plotNum(pLoopPlot->getX(), pLoopPlot->getY());

	movsx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edx, DWORD PTR [edx+4020]
	movsx	eax, WORD PTR [eax]
	imul	ecx, edx

; 7740 : 									if(m_pMap->GetCell(iPlotIndex)->GetEnemyMilitaryUnit() != NULL)

	mov	edx, DWORD PTR [esi+4]
	add	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	imul	ecx, 44					; 0000002cH
	cmp	DWORD PTR [eax+ecx+4], 0
	je	SHORT $LN37@ExecuteOne

; 7741 : 									{
; 7742 : 										bNoEnemyAdjacent = false;

	xor	bl, bl
$LN37@ExecuteOne:

; 7734 : 							for(int iI = 0; iI < NUM_DIRECTION_TYPES && bNoEnemyAdjacent; iI++)

	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL38@ExecuteOne

; 7743 : 									}
; 7744 : 								}
; 7745 : 							}
; 7746 : 
; 7747 : 							if(bNoEnemyAdjacent)

	test	bl, bl
	je	$LN44@ExecuteOne

; 7748 : 							{
; 7749 : 								// Do we have a unit that can get off a bombard from here THIS turn
; 7750 : 								iNumTurns = -1;
; 7751 : 								bool bHaveLOS = pAttackPlot->canSeePlot(pTargetPlot, m_pPlayer->getTeam(), iRange, NO_DIRECTION);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN194@ExecuteOne
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN195@ExecuteOne
$LN194@ExecuteOne:
	or	eax, -1
$LN195@ExecuteOne:
	mov	edx, DWORD PTR _iRange$[esp+124]
	mov	ebp, DWORD PTR _pTargetPlot$[esp+124]
	push	-1
	push	edx
	push	eax
	push	ebp
	mov	ecx, edi
	call	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ; CvPlot::canSeePlot

; 7752 : 								if(FindClosestUnit(pAttackPlot, 0, false/*bMustHaveHalfHP*/, true /*bMustBeRangedUnit*/, iPlotDistance, !bHaveLOS, false/*bMustBeMeleeUnit*/,  false/*bIgnoreUnits*/, pTargetPlot))

	push	ebp
	test	al, al
	mov	eax, DWORD PTR _iPlotDistance$224405[esp+128]
	push	0
	sete	bl
	push	0
	mov	ecx, esi
	push	ebx
	push	eax
	push	1
	push	0
	push	0
	push	edi
	call	?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z ; CvTacticalAI::FindClosestUnit
	test	al, al
	je	SHORT $LN32@ExecuteOne

; 7753 : 								{
; 7754 : 									iNumTurns = 0;

	xor	ebx, ebx
	jmp	SHORT $LN510@ExecuteOne
$LN32@ExecuteOne:

; 7755 : 								}
; 7756 : 								// What about next turn?
; 7757 : 								else if(FindClosestUnit(pAttackPlot, 1, false/*bMustHaveHalfHP*/, true /*bMustBeRangedUnit*/, iPlotDistance, !bHaveLOS, false/*bMustBeMeleeUnit*/,  false/*bIgnoreUnits*/,  pTargetPlot))

	mov	ecx, DWORD PTR _iPlotDistance$224405[esp+124]
	push	ebp
	push	0
	push	0
	push	ebx
	push	ecx
	push	1
	push	0
	push	1
	push	edi
	mov	ecx, esi
	call	?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z ; CvTacticalAI::FindClosestUnit
	test	al, al
	je	SHORT $LN44@ExecuteOne

; 7758 : 								{
; 7759 : 									iNumTurns = 1;

	mov	ebx, 1
$LN510@ExecuteOne:

; 7760 : 								}
; 7761 : 
; 7762 : 								// If found a unit that could get here, see if we can cover the hex from enemy attack
; 7763 : 								if(iNumTurns >= 0)
; 7764 : 								{
; 7765 : 									if(CanCoverFromEnemy(pAttackPlot, iNumUnitsRequiredToCover, m_CurrentMoveUnits[0].GetID()))

	mov	eax, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	edx, DWORD PTR _iNumUnitsRequiredToCover$[esp+128]
	push	edx
	push	edi
	mov	ecx, esi
	call	?CanCoverFromEnemy@CvTacticalAI@@AAE_NPAVCvPlot@@AAHH@Z ; CvTacticalAI::CanCoverFromEnemy
	test	al, al
	je	SHORT $LN44@ExecuteOne

; 7766 : 									{
; 7767 : 										CvTacticalTarget target;

	or	eax, -1
	mov	DWORD PTR _target$224425[esp+136], eax
	mov	DWORD PTR _target$224425[esp+148], eax

; 7768 : 										target.SetTargetX(pAttackPlot->getX());

	movsx	eax, WORD PTR [edi]
	xor	ecx, ecx
	mov	DWORD PTR _target$224425[esp+128], eax
	mov	DWORD PTR _target$224425[esp+124], ecx
	mov	DWORD PTR _target$224425[esp+140], ecx

; 7769 : 										target.SetTargetY(pAttackPlot->getY());

	movsx	ecx, WORD PTR [edi+2]

; 7770 : 
; 7771 : 										// How desirable is this move?
; 7772 : 										// Set up math so having to allocate 3 extra units to defend is worse than waiting a turn to attack
; 7773 : 										iPriority = 300 - (iNumTurns * 100);

	mov	eax, 3
	sub	eax, ebx
	mov	DWORD PTR _target$224425[esp+132], ecx
	imul	eax, 100				; 00000064H

; 7774 : 										iPriority -= 40 * iNumUnitsRequiredToCover;

	mov	ecx, DWORD PTR _iNumUnitsRequiredToCover$[esp+124]
	lea	edx, DWORD PTR [ecx+ecx*4]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	sub	eax, edx

; 7775 : 										target.SetAuxIntData(iPriority);

	mov	DWORD PTR _target$224425[esp+144], eax

; 7776 : 										m_TempTargets.push_back(target);

	lea	eax, DWORD PTR _target$224425[esp+124]
	push	eax
	lea	ecx, DWORD PTR [esi+23704]
	call	?push_back@?$FStaticVector@VCvTacticalTarget@@$0CF@$00$0BCJ@$0A@@@QAEIABVCvTacticalTarget@@@Z ; FStaticVector<CvTacticalTarget,37,1,297,0>::push_back
$LN44@ExecuteOne:
	mov	eax, DWORD PTR _iDY$[esp+124]
	inc	eax
	cmp	eax, DWORD PTR _iRange$[esp+124]
	mov	DWORD PTR _iDY$[esp+124], eax
	jle	$LL45@ExecuteOne
$LN47@ExecuteOne:

; 7695 : 	m_TempTargets.clear();
; 7696 : 
; 7697 : 	// Build a list of all plots that have LOS to target where no enemy unit is adjacent
; 7698 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 7699 : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 7700 : 	{
; 7701 : 		iMaxDX = iRange - MAX(0, iDY);
; 7702 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 7703 : #else
; 7704 : 	for(iDX = -(iRange); iDX <= iRange; iDX++)

	mov	eax, DWORD PTR _iDX$[esp+124]
	inc	eax
	cmp	eax, DWORD PTR _iRange$[esp+124]
	mov	DWORD PTR _iDX$[esp+124], eax
	jle	$LL48@ExecuteOne
$LN513@ExecuteOne:

; 7777 : 									}
; 7778 : 								}
; 7779 : 							}
; 7780 : 						}
; 7781 : 					}
; 7782 : 				}
; 7783 : 			}
; 7784 : 		}
; 7785 : 	}
; 7786 : 
; 7787 : 	// No plots to shoot from?
; 7788 : 	if(m_TempTargets.size() == 0)

	cmp	DWORD PTR [esi+23708], 0

; 7789 : 	{
; 7790 : 		return false;

	je	$LN499@ExecuteOne

; 7791 : 	}
; 7792 : 
; 7793 : 	// Sort potential spots
; 7794 : 	std::stable_sort(m_TempTargets.begin(), m_TempTargets.end());

	mov	ecx, DWORD PTR [esi+23708]
	mov	eax, DWORD PTR [esi+23704]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	ecx, eax
	lea	ecx, DWORD PTR [ecx+edx*4]
	cmp	eax, ecx
	je	SHORT $LN228@ExecuteOne
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvTacticalTarget@@HV1@@std@@YAXPAVCvTacticalTarget@@0PAH0@Z ; std::_Stable_sort<CvTacticalTarget *,int,CvTacticalTarget>
	add	esp, 16					; 00000010H
$LN228@ExecuteOne:

; 7795 : 
; 7796 : 	// Have to rebuild blocking position info for this specific spot
; 7797 : #ifdef AUI_ITERATORIZE
; 7798 : 	pAttackPlot = GC.getMap().plot(m_TempTargets.begin()->GetTargetX(), m_TempTargets.begin()->GetTargetY());
; 7799 : #else
; 7800 : 	pAttackPlot = GC.getMap().plot(m_TempTargets[0].GetTargetX(), m_TempTargets[0].GetTargetY());

	mov	eax, DWORD PTR [esi+23704]
	mov	ebp, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN245@ExecuteOne
	cmp	ebp, -2147483647			; 80000001H
	je	$LN245@ExecuteOne
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	bl, BYTE PTR [edx+4056]
	mov	ecx, DWORD PTR [edx+4020]
	test	bl, bl
	je	SHORT $LN255@ExecuteOne
	test	eax, eax
	jge	SHORT $LN257@ExecuteOne
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	edi, ecx
	jmp	SHORT $LN259@ExecuteOne
$LN257@ExecuteOne:
	cmp	eax, ecx
	jl	SHORT $LN255@ExecuteOne
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN259@ExecuteOne
$LN255@ExecuteOne:
	mov	edi, eax
$LN259@ExecuteOne:
	mov	al, BYTE PTR [edx+4057]
	mov	ebx, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN517@ExecuteOne
	test	ebp, ebp
	jge	SHORT $LN267@ExecuteOne
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN269@ExecuteOne
$LN267@ExecuteOne:
	cmp	ebp, ebx
	jl	SHORT $LN517@ExecuteOne
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN269@ExecuteOne
$LN517@ExecuteOne:
	mov	edx, ebp
$LN269@ExecuteOne:
	test	edi, edi
	jl	SHORT $LN245@ExecuteOne
	cmp	edi, ecx
	jge	SHORT $LN245@ExecuteOne
	test	edx, edx
	jl	SHORT $LN245@ExecuteOne
	cmp	edx, ebx
	jge	SHORT $LN245@ExecuteOne
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	edi, ecx
	mov	DWORD PTR _pAttackPlot$[esp+124], ecx
	jmp	SHORT $LN247@ExecuteOne
$LN245@ExecuteOne:
	xor	edi, edi
	mov	DWORD PTR _pAttackPlot$[esp+124], edi
$LN247@ExecuteOne:

; 7801 : #endif
; 7802 : #ifdef AUI_WARNING_FIXES
; 7803 : 	if (!pAttackPlot)
; 7804 : 		return false;
; 7805 : #endif
; 7806 : 	int iPlotDistance = plotDistance(pAttackPlot->getX(), pAttackPlot->getY(), kTarget.GetTargetX(), kTarget.GetTargetY());

	mov	ecx, DWORD PTR _kTarget$[esp+120]
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+4]
	push	eax
	movsx	eax, WORD PTR [edi+2]
	push	ecx
	movsx	ecx, WORD PTR [edi]
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 7807 : 	bool bHaveLOS = pAttackPlot->canSeePlot(pTargetPlot, m_pPlayer->getTeam(), iRange, NO_DIRECTION);

	mov	edx, DWORD PTR [esi]
	mov	ebp, eax
	mov	eax, DWORD PTR [edx+44]
	add	esp, 16					; 00000010H
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN295@ExecuteOne
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN296@ExecuteOne
$LN295@ExecuteOne:
	or	eax, -1
$LN296@ExecuteOne:
	mov	ecx, DWORD PTR _iRange$[esp+124]
	mov	edx, DWORD PTR _pTargetPlot$[esp+124]
	push	-1
	push	ecx
	push	eax
	push	edx
	mov	ecx, edi
	call	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ; CvPlot::canSeePlot

; 7808 : 	if(FindClosestUnit(pAttackPlot, 0, false/*bMustHaveHalfHP*/, true /*bMustBeRangedUnit*/, iPlotDistance, !bHaveLOS, false/*bMustBeMeleeUnit*/,  false/*bIgnoreUnits*/, pTargetPlot) ||
; 7809 : 	        FindClosestUnit(pAttackPlot, 1, false/*bMustHaveHalfHP*/, true /*bMustBeRangedUnit*/, iPlotDistance, !bHaveLOS, false/*bMustBeMeleeUnit*/,  false/*bIgnoreUnits*/, pTargetPlot))

	test	al, al
	mov	eax, DWORD PTR _pTargetPlot$[esp+124]
	push	eax
	push	0
	sete	bl
	push	0
	mov	ecx, esi
	push	ebx
	push	ebp
	push	1
	push	0
	push	0
	push	edi
	call	?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z ; CvTacticalAI::FindClosestUnit
	test	al, al
	jne	SHORT $LN25@ExecuteOne
	mov	ecx, DWORD PTR _pTargetPlot$[esp+124]
	push	ecx
	push	0
	push	0
	push	ebx
	push	ebp
	push	1
	push	0
	push	1
	push	edi
	mov	ecx, esi
	call	?FindClosestUnit@CvTacticalAI@@AAE_NPAVCvPlot@@H_N1H1110@Z ; CvTacticalAI::FindClosestUnit
	test	al, al
	je	$LN1@ExecuteOne
	mov	edi, DWORD PTR _pAttackPlot$[esp+124]
$LN25@ExecuteOne:

; 7810 : 	{
; 7811 : #ifdef AUI_ITERATORIZE
; 7812 : 		int iAttackingUnitID = m_CurrentMoveUnits.begin()->GetID();
; 7813 : #else
; 7814 : 		int iAttackingUnitID = m_CurrentMoveUnits[0].GetID();

	mov	edx, DWORD PTR [esi+24]
	mov	ebx, DWORD PTR [edx]

; 7815 : #endif
; 7816 : #ifdef AUI_WARNING_FIXES
; 7817 : 		if(CanCoverFromEnemy(pAttackPlot, iNumUnitsRequiredToCover, iAttackingUnitID))
; 7818 : #else
; 7819 : 		if(pAttackPlot && CanCoverFromEnemy(pAttackPlot, iNumUnitsRequiredToCover, iAttackingUnitID))

	push	ebx
	lea	eax, DWORD PTR _iNumUnitsRequiredToCover$[esp+128]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _iAttackingUnitID$224432[esp+136], ebx
	call	?CanCoverFromEnemy@CvTacticalAI@@AAE_NPAVCvPlot@@AAHH@Z ; CvTacticalAI::CanCoverFromEnemy
	test	al, al
	je	$LN1@ExecuteOne

; 7820 : #endif
; 7821 : 		{
; 7822 : 			// Make each blocking move
; 7823 : #ifdef AUI_ITERATORIZE
; 7824 : 			for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_ChosenBlocks.begin(); it != m_ChosenBlocks.end(); ++it)
; 7825 : 			{
; 7826 : 				CvUnit* pChosenUnit = m_pPlayer->getUnit(it->GetUnitID());
; 7827 : 				if (pChosenUnit)
; 7828 : 				{
; 7829 : 					if (pChosenUnit->plot() != it->GetPlot())
; 7830 : #else
; 7831 : 			for(unsigned int iI = 0; iI < m_ChosenBlocks.size(); iI++)

	mov	eax, DWORD PTR [esi+27432]
	mov	DWORD PTR _iI$224434[esp+124], 0
	test	eax, eax
	jbe	$LN21@ExecuteOne
	xor	ebp, ebp
$LL23@ExecuteOne:

; 7832 : 			{
; 7833 : 				CvUnit* pChosenUnit = m_pPlayer->getUnit(m_ChosenBlocks[iI].GetUnitID());

	mov	eax, DWORD PTR [esi+27428]
	mov	ecx, DWORD PTR [esi]
	add	eax, ebp
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 7834 : 				if(pChosenUnit)

	test	edi, edi
	je	$LN22@ExecuteOne

; 7835 : 				{
; 7836 : 					if (pChosenUnit->plot() != m_ChosenBlocks[iI].GetPlot())

	mov	eax, DWORD PTR [esi+27428]
	mov	ebx, DWORD PTR [eax+ebp]
	add	eax, ebp
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	je	$LN19@ExecuteOne

; 7837 : #endif
; 7838 : 					{
; 7839 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN515@ExecuteOne
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN515@ExecuteOne

; 7840 : 						{
; 7841 : 							CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224442[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7842 : 							strMsg.Format("Moving to cover a protected bombard with %s, X: %d, Y: %d", pChosenUnit->getName().GetCString(),
; 7843 : #ifdef AUI_ITERATORIZE
; 7844 : 								it->GetPlot()->getX(), it->GetPlot()->getY());
; 7845 : #else
; 7846 : 								m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY());

	lea	ecx, DWORD PTR $T305337[esp+124]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+136], 1
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	edx, DWORD PTR [esi+27428]
	mov	ecx, DWORD PTR [edx+ebp]
	movsx	ecx, WORD PTR [ecx+2]
	add	edx, ebp
	mov	edx, DWORD PTR [edx]
	movsx	edx, WORD PTR [edx]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+140], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strMsg$224442[esp+136]
	push	OFFSET $SG224444
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T305337[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7847 : #endif
; 7848 : 							LogTacticalMessage(strMsg, false);

	push	0
	lea	ecx, DWORD PTR _strMsg$224442[esp+128]
	push	ecx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7849 : 						}

	lea	ecx, DWORD PTR _strMsg$224442[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN515@ExecuteOne:

; 7850 : #ifdef AUI_ITERATORIZE
; 7851 : 						pChosenUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), it->GetPlot()->getX(), it->GetPlot()->getY());
; 7852 : #else
; 7853 : 						pChosenUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY());

	mov	edx, DWORD PTR [esi+27428]
	mov	ecx, DWORD PTR [edx+ebp]
	movsx	ecx, WORD PTR [ecx+2]
	push	0
	push	0
	push	-1
	lea	eax, DWORD PTR [edx+ebp]
	mov	eax, DWORD PTR [eax]
	movsx	eax, WORD PTR [eax]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission
	jmp	$LN10@ExecuteOne
$LN19@ExecuteOne:

; 7854 : #endif
; 7855 : 					}
; 7856 : 					else if (pChosenUnit->canPillage(pChosenUnit->plot()) && pChosenUnit->getDamage() > 0)

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canPillage@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canPillage
	test	al, al
	je	$LN16@ExecuteOne
	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	test	eax, eax
	jle	$LN16@ExecuteOne

; 7857 : 					{
; 7858 : 						pChosenUnit->PushMission(CvTypes::getMISSION_PILLAGE());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_PILLAGE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PILLAGE
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 7859 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN10@ExecuteOne
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN10@ExecuteOne

; 7860 : 						{
; 7861 : 							CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224448[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7862 : 							strMsg.Format("Pillaging during a protected bombard with %s, X: %d, Y: %d", pChosenUnit->getName().GetCString(),
; 7863 : #ifdef AUI_ITERATORIZE
; 7864 : 								it->GetPlot()->getX(), it->GetPlot()->getY());
; 7865 : #else
; 7866 : 								m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY());

	lea	eax, DWORD PTR $T305338[esp+124]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+136], 3
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+27428]
	lea	edx, DWORD PTR [ecx+ebp]
	mov	ecx, DWORD PTR [edx]
	movsx	ecx, WORD PTR [ecx+2]
	mov	edx, DWORD PTR [edx]
	movsx	edx, WORD PTR [edx]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+140], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strMsg$224448[esp+136]
	push	OFFSET $SG224450
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	mov	BYTE PTR __$EHRec$[esp+152], 3

; 7867 : #endif
; 7868 : 							LogTacticalMessage(strMsg, false);
; 7869 : 						}
; 7870 : 					}

	jmp	$LN519@ExecuteOne
$LN16@ExecuteOne:

; 7871 : 					else if(pChosenUnit->canFortify(pChosenUnit->plot()))

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canFortify
	test	al, al
	je	$LN13@ExecuteOne

; 7872 : 					{
; 7873 : 						pChosenUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 7874 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN10@ExecuteOne
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN10@ExecuteOne

; 7875 : 						{
; 7876 : 							CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224454[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7877 : 							strMsg.Format("Fortifying during a protected bombard with %s, X: %d, Y: %d", pChosenUnit->getName().GetCString(),
; 7878 : #ifdef AUI_ITERATORIZE
; 7879 : 								it->GetPlot()->getX(), it->GetPlot()->getY());
; 7880 : #else
; 7881 : 								m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY());

	lea	ecx, DWORD PTR $T305339[esp+124]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+136], 5
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	edx, DWORD PTR [esi+27428]
	mov	ecx, DWORD PTR [edx+ebp]
	movsx	ecx, WORD PTR [ecx+2]
	add	edx, ebp
	mov	edx, DWORD PTR [edx]
	movsx	edx, WORD PTR [edx]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+140], 6
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strMsg$224454[esp+136]
	push	OFFSET $SG224456
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T305339[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7882 : #endif
; 7883 : 							LogTacticalMessage(strMsg, false);

	push	0
	lea	ecx, DWORD PTR _strMsg$224454[esp+128]
	push	ecx

; 7884 : 						}
; 7885 : 					}
; 7886 : 					else

	jmp	$LN520@ExecuteOne
$LN13@ExecuteOne:

; 7887 : 					{
; 7888 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN10@ExecuteOne
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN10@ExecuteOne

; 7889 : 						{
; 7890 : 							CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224459[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7891 : 							strMsg.Format("Sitting during a protected bombard with %s, X: %d, Y: %d", pChosenUnit->getName().GetCString(),
; 7892 : #ifdef AUI_ITERATORIZE
; 7893 : 								it->GetPlot()->getX(), it->GetPlot()->getY());
; 7894 : #else
; 7895 : 								m_ChosenBlocks[iI].GetPlot()->getX(), m_ChosenBlocks[iI].GetPlot()->getY());

	lea	edx, DWORD PTR $T305340[esp+124]
	push	edx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+136], 7
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+27428]
	lea	edx, DWORD PTR [ecx+ebp]
	mov	ecx, DWORD PTR [edx]
	movsx	ecx, WORD PTR [ecx+2]
	mov	edx, DWORD PTR [edx]
	movsx	edx, WORD PTR [edx]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+140], 8
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strMsg$224459[esp+136]
	push	OFFSET $SG224461
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	mov	BYTE PTR __$EHRec$[esp+152], 7
$LN519@ExecuteOne:
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T305340[esp+124]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7896 : #endif
; 7897 : 							LogTacticalMessage(strMsg, false);

	push	0
	lea	eax, DWORD PTR _strMsg$224459[esp+128]
	push	eax
$LN520@ExecuteOne:
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7898 : 						}

	lea	ecx, DWORD PTR _strMsg$224459[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@ExecuteOne:

; 7899 : 					}
; 7900 : 					pChosenUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 7901 : 					UnitProcessed(pChosenUnit->GetID());

	mov	edi, DWORD PTR [edi+100]
	push	1
	push	edi
	mov	ecx, esi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed
$LN22@ExecuteOne:
	mov	eax, DWORD PTR _iI$224434[esp+124]
	inc	eax
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _iI$224434[esp+124], eax
	cmp	eax, DWORD PTR [esi+27432]
	jb	$LL23@ExecuteOne

; 7820 : #endif
; 7821 : 		{
; 7822 : 			// Make each blocking move
; 7823 : #ifdef AUI_ITERATORIZE
; 7824 : 			for (FStaticVector<CvBlockingUnit, NUM_CITY_PLOTS, true, c_eCiv5GameplayDLL, 0>::iterator it = m_ChosenBlocks.begin(); it != m_ChosenBlocks.end(); ++it)
; 7825 : 			{
; 7826 : 				CvUnit* pChosenUnit = m_pPlayer->getUnit(it->GetUnitID());
; 7827 : 				if (pChosenUnit)
; 7828 : 				{
; 7829 : 					if (pChosenUnit->plot() != it->GetPlot())
; 7830 : #else
; 7831 : 			for(unsigned int iI = 0; iI < m_ChosenBlocks.size(); iI++)

	mov	ebx, DWORD PTR _iAttackingUnitID$224432[esp+124]
$LN21@ExecuteOne:

; 7902 : 				}
; 7903 : 			}
; 7904 : 
; 7905 : 			// Then move the attacking unit
; 7906 : 			CvUnit* pUnit = m_pPlayer->getUnit(iAttackingUnitID);

	mov	ecx, DWORD PTR [esi]
	push	ebx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 7907 : 			if(pUnit)

	test	edi, edi
	je	$LN1@ExecuteOne

; 7908 : 			{
; 7909 : 				if(pAttackPlot != pUnit->plot())

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebp, DWORD PTR _pAttackPlot$[esp+124]
	cmp	ebp, eax
	je	$LN514@ExecuteOne

; 7910 : 				{
; 7911 : 					pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pAttackPlot->getX(), pAttackPlot->getY());

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 7912 : 
; 7913 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN514@ExecuteOne
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN514@ExecuteOne

; 7914 : 					{
; 7915 : 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224466[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7916 : 						strMsg.Format("Moving closer for protected bombard with %s, Target X: %d, Target Y: %d, At X: %d, At Y: %d", pUnit->getName().GetCString(),
; 7917 : 						              pAttackPlot->getX(), pAttackPlot->getY(), pUnit->getX(), pUnit->getY());

	lea	ecx, DWORD PTR $T305341[esp+124]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+136], 9
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [edi+88]
	movsx	ebx, WORD PTR [ebp+2]
	mov	edx, DWORD PTR [edi+76]
	movsx	ebp, WORD PTR [ebp]
	push	ecx
	push	edx
	push	ebx
	push	ebp
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+148], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strMsg$224466[esp+144]
	push	OFFSET $SG224468
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH
	lea	ecx, DWORD PTR $T305341[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7918 : 						LogTacticalMessage(strMsg, false);

	push	0
	lea	eax, DWORD PTR _strMsg$224466[esp+128]
	push	eax
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7919 : 					}

	lea	ecx, DWORD PTR _strMsg$224466[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN514@ExecuteOne:

; 7920 : 				}
; 7921 : 
; 7922 : 				UnitProcessed(iAttackingUnitID);

	mov	ecx, DWORD PTR _iAttackingUnitID$224432[esp+124]
	push	1
	push	ecx
	mov	ecx, esi
	call	?UnitProcessed@CvTacticalAI@@AAEXH_N@Z	; CvTacticalAI::UnitProcessed

; 7923 : 
; 7924 : 				if(pUnit->canSetUpForRangedAttack(NULL))

	push	0
	mov	ecx, edi
	call	?canSetUpForRangedAttack@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canSetUpForRangedAttack
	test	al, al
	je	$LN5@ExecuteOne

; 7925 : 				{
; 7926 : 					pUnit->setSetUpForRangedAttack(true);

	push	1
	mov	ecx, edi
	call	?setSetUpForRangedAttack@CvUnit@@QAEX_N@Z ; CvUnit::setSetUpForRangedAttack

; 7927 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN5@ExecuteOne
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN5@ExecuteOne

; 7928 : 					{
; 7929 : 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224471[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7930 : 						strMsg.Format("Set up %s for ranged attack", pUnit->getName().GetCString());

	lea	edx, DWORD PTR $T305342[esp+124]
	mov	bl, 11					; 0000000bH
	push	edx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+136], bl
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+132], 12		; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strMsg$224471[esp+128]
	push	OFFSET $SG224473
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T305342[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7931 : 						LogTacticalMessage(strMsg, false);

	push	0
	lea	ecx, DWORD PTR _strMsg$224471[esp+128]
	push	ecx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7932 : 					}

	lea	ecx, DWORD PTR _strMsg$224471[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@ExecuteOne:

; 7933 : 				}
; 7934 : 
; 7935 : 				if(pUnit->canMove() && !pUnit->isOutOfAttacks() && pUnit->canRangeStrikeAt(kTarget.GetTargetX(), kTarget.GetTargetY()))

	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN1@ExecuteOne
	mov	ecx, edi
	call	?isOutOfAttacks@CvUnit@@QBE_NXZ		; CvUnit::isOutOfAttacks
	test	al, al
	jne	$LN1@ExecuteOne
	mov	ebp, DWORD PTR _kTarget$[esp+120]
	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebp+4]
	push	1
	push	1
	push	eax
	push	ecx
	mov	ecx, edi
	call	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z	; CvUnit::canRangeStrikeAt
	test	al, al
	je	$LN1@ExecuteOne

; 7936 : 				{
; 7937 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN3@ExecuteOne
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN3@ExecuteOne

; 7938 : 					{
; 7939 : 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$224476[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7940 : 						strMsg.Format("Making a protected bombard with %s, Target X: %d, Target Y: %d, At X: %d, At Y: %d", pUnit->getName().GetCString(),
; 7941 : 						              kTarget.GetTargetX(), kTarget.GetTargetY(), pUnit->getX(), pUnit->getY());

	lea	edx, DWORD PTR $T305343[esp+124]
	push	edx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+136], 13		; 0000000dH
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [edi+88]
	mov	edx, DWORD PTR [edi+76]
	mov	ebx, DWORD PTR [ebp+4]
	push	ecx
	mov	ecx, DWORD PTR [ebp+8]
	push	edx
	push	ecx
	push	ebx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+148], 14		; 0000000eH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strMsg$224476[esp+144]
	push	OFFSET $SG224478
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH
	lea	ecx, DWORD PTR $T305343[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 13		; 0000000dH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7942 : 						LogTacticalMessage(strMsg, false);

	push	0
	lea	ecx, DWORD PTR _strMsg$224476[esp+128]
	push	ecx
	mov	ecx, esi
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 7943 : 					}

	lea	ecx, DWORD PTR _strMsg$224476[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@ExecuteOne:

; 7944 : 
; 7945 : 					if(QueueAttack((void*)pUnit, &kTarget, true /*bRanged*/, false /*bCityAttack*/))

	push	0
	push	1
	push	ebp
	push	edi
	mov	ecx, esi
	call	?QueueAttack@CvTacticalAI@@QAE_NPAXPAVCvTacticalTarget@@_N2@Z ; CvTacticalAI::QueueAttack
	test	al, al
	je	SHORT $LN1@ExecuteOne

; 7946 : 					{
; 7947 : 						pFirstAttacker = pUnit;

	push	edi
	lea	ecx, DWORD PTR _pFirstAttacker$[esp+128]
	call	??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=

; 7948 : 					}
; 7949 : 				}
; 7950 : 			}
; 7951 : 		}
; 7952 : 
; 7953 : 		if(pFirstAttacker)

	mov	edi, DWORD PTR _pFirstAttacker$[esp+124]
	test	edi, edi
	je	SHORT $LN1@ExecuteOne

; 7954 : 		{
; 7955 : 			LaunchAttack((void*)pFirstAttacker.pointer(), &kTarget, true /*bFirst*/, true /*bFirstAttackRanged*/, false /*bCityAttack*/);

	push	0
	push	1
	push	1
	push	ebp
	push	edi
	mov	ecx, esi
	call	?LaunchAttack@CvTacticalAI@@QAEXPAXPAVCvTacticalTarget@@_N22@Z ; CvTacticalAI::LaunchAttack

; 7956 : 			return true;

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+132], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 7961 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	mov	DWORD PTR fs:0, ecx
	add	esp, 108				; 0000006cH
	ret	4
$LN1@ExecuteOne:

; 7957 : 		}
; 7958 : 	}
; 7959 : 
; 7960 : 	return false;

	mov	ecx, DWORD PTR _pFirstAttacker$[esp+124]
	mov	DWORD PTR __$EHRec$[esp+132], -1
	test	ecx, ecx
	je	SHORT $LN499@ExecuteOne
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN499@ExecuteOne:

; 7961 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 108				; 0000006cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$0:
	lea	ecx, DWORD PTR _pFirstAttacker$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$1:
	lea	ecx, DWORD PTR _strMsg$224442[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$2:
	lea	ecx, DWORD PTR $T305337[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$3:
	lea	ecx, DWORD PTR _strMsg$224448[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$4:
	lea	ecx, DWORD PTR $T305338[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$5:
	lea	ecx, DWORD PTR _strMsg$224454[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$6:
	lea	ecx, DWORD PTR $T305339[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$7:
	lea	ecx, DWORD PTR _strMsg$224459[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$8:
	lea	ecx, DWORD PTR $T305340[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$9:
	lea	ecx, DWORD PTR _strMsg$224466[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$10:
	lea	ecx, DWORD PTR $T305341[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$11:
	lea	ecx, DWORD PTR _strMsg$224471[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$12:
	lea	ecx, DWORD PTR $T305342[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$13:
	lea	ecx, DWORD PTR _strMsg$224476[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z$14:
	lea	ecx, DWORD PTR $T305343[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ENDP ; CvTacticalAI::ExecuteOneProtectedBombard
PUBLIC	?ExecuteProtectedBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@_N@Z ; CvTacticalAI::ExecuteProtectedBombards
; Function compile flags: /Ogtpy
;	COMDAT ?ExecuteProtectedBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@_N@Z
_TEXT	SEGMENT
_kTarget$ = 8						; size = 4
_bAttackUnderway$ = 12					; size = 1
?ExecuteProtectedBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@_N@Z PROC ; CvTacticalAI::ExecuteProtectedBombards, COMDAT
; _this$ = ecx

; 7645 : {

	push	ebx
	push	esi
	push	edi

; 7646 : 	bool bAttackMade = true;
; 7647 : 	bool bAtLeastOneAttackInitiated = false;

	mov	edi, DWORD PTR _kTarget$[esp+8]
	mov	esi, ecx
	xor	bl, bl
	npad	5
$LL3@ExecutePro:

; 7648 : 
; 7649 : 	while(bAttackMade && kTarget.IsTargetStillAlive(m_pPlayer->GetID()))

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, edi
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN12@ExecutePro

; 7650 : 	{
; 7651 : 		bAttackMade = ExecuteOneProtectedBombard(kTarget);

	push	edi
	mov	ecx, esi
	call	?ExecuteOneProtectedBombard@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteOneProtectedBombard

; 7652 : 		if(bAttackMade)

	test	al, al
	je	SHORT $LN12@ExecutePro

; 7653 : 		{
; 7654 : 			bAttackUnderway = true;
; 7655 : 			bAtLeastOneAttackInitiated = true;

	mov	bl, 1

; 7648 : 
; 7649 : 	while(bAttackMade && kTarget.IsTargetStillAlive(m_pPlayer->GetID()))

	jmp	SHORT $LL3@ExecutePro
$LN12@ExecutePro:
	pop	edi
	pop	esi

; 7656 : 		}
; 7657 : 	}
; 7658 : 	return bAtLeastOneAttackInitiated;

	mov	al, bl
	pop	ebx

; 7659 : }

	ret	8
?ExecuteProtectedBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@_N@Z ENDP ; CvTacticalAI::ExecuteProtectedBombards
_TEXT	ENDS
PUBLIC	?ExecutePriorityAttacksOnUnitTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecutePriorityAttacksOnUnitTarget
; Function compile flags: /Ogtpy
;	COMDAT ?ExecutePriorityAttacksOnUnitTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@@Z
_TEXT	SEGMENT
_bAttackUnderway$ = -4					; size = 1
_kTarget$ = 8						; size = 4
?ExecutePriorityAttacksOnUnitTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@@Z PROC ; CvTacticalAI::ExecutePriorityAttacksOnUnitTarget, COMDAT
; _this$ = ecx

; 8518 : {

	push	ecx
	push	ebx

; 8519 : 	bool bAttackUnderway = false;
; 8520 : 	bool bAttackMade = false;
; 8521 : 	CvPlot* pTarget;
; 8522 : 
; 8523 : 	pTarget = GC.getMap().plot(kTarget.GetTargetX(), kTarget.GetTargetY());

	mov	ebx, DWORD PTR _kTarget$[esp+4]
	mov	eax, DWORD PTR [ebx+4]
	push	ebp
	mov	ebp, DWORD PTR [ebx+8]
	push	esi
	push	edi
	mov	esi, ecx
	mov	BYTE PTR _bAttackUnderway$[esp+20], 0
	cmp	eax, -2147483647			; 80000001H
	je	$LN13@ExecutePri
	cmp	ebp, -2147483647			; 80000001H
	je	$LN13@ExecutePri
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	ecx, DWORD PTR [ebx+4020]
	je	SHORT $LN68@ExecutePri
	test	eax, eax
	jge	SHORT $LN25@ExecutePri
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN27@ExecutePri
$LN25@ExecutePri:
	cmp	eax, ecx
	jl	SHORT $LN68@ExecutePri
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN27@ExecutePri
$LN68@ExecutePri:
	mov	edi, eax
$LN27@ExecutePri:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [eax+4057], 0
	mov	ebx, DWORD PTR [ebx+4024]
	je	SHORT $LN69@ExecutePri
	test	ebp, ebp
	jge	SHORT $LN35@ExecutePri
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@ExecutePri
$LN35@ExecutePri:
	cmp	ebp, ebx
	jl	SHORT $LN69@ExecutePri
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN37@ExecutePri
$LN69@ExecutePri:
	mov	edx, ebp
$LN37@ExecutePri:
	test	edi, edi
	jl	SHORT $LN17@ExecutePri
	cmp	edi, ecx
	jge	SHORT $LN17@ExecutePri
	test	edx, edx
	jl	SHORT $LN17@ExecutePri
	cmp	edx, ebx
	jge	SHORT $LN17@ExecutePri
	mov	ebx, DWORD PTR _kTarget$[esp+16]
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	edi, ecx
	jmp	SHORT $LN15@ExecutePri
$LN17@ExecutePri:
	mov	ebx, DWORD PTR _kTarget$[esp+16]
$LN13@ExecutePri:
	xor	edi, edi
$LN15@ExecutePri:

; 8524 : 
; 8525 : 	// Try to find a bombard first
; 8526 : 	m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [esi+4]
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 8527 : 	m_pMap->SetTargetBombardCells(pTarget, m_pMap->GetBestFriendlyRange(), m_pMap->CanIgnoreLOS());

	mov	ecx, DWORD PTR [esi+4]
	movzx	eax, BYTE PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+28]
	push	eax
	push	edx
	push	edi
	call	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells

; 8528 : 
; 8529 : 	if(kTarget.IsTargetStillAlive(m_pPlayer->GetID()))

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, ebx
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN4@ExecutePri

; 8530 : 	{
; 8531 : 		bAttackUnderway = ExecuteSafeBombards(kTarget);

	push	ebx
	mov	ecx, esi
	call	?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteSafeBombards
	mov	BYTE PTR _bAttackUnderway$[esp+20], al
$LN4@ExecutePri:

; 8532 : 	}
; 8533 : 
; 8534 : 	if(kTarget.IsTargetStillAlive(m_pPlayer->GetID()))

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+44]
	push	eax
	mov	ecx, ebx
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN3@ExecutePri

; 8535 : 	{
; 8536 : 		ExecuteProtectedBombards(kTarget, bAttackUnderway);

	mov	edx, DWORD PTR _bAttackUnderway$[esp+20]
	push	edx
	push	ebx
	mov	ecx, esi
	call	?ExecuteProtectedBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@_N@Z ; CvTacticalAI::ExecuteProtectedBombards
$LN3@ExecutePri:

; 8537 : 	}
; 8538 : 
; 8539 : 	// Then try for a flank attack
; 8540 : 	if(kTarget.IsTargetStillAlive(m_pPlayer->GetID()))

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, ebx
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN1@ExecutePri

; 8541 : 	{
; 8542 : 		m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [esi+4]
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 8543 : 		m_pMap->SetTargetFlankBonusCells(pTarget);

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	call	?SetTargetFlankBonusCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@@Z ; CvTacticalAnalysisMap::SetTargetFlankBonusCells

; 8544 : 
; 8545 : 		bAttackMade = ExecuteFlankAttack(kTarget);

	push	ebx
	mov	ecx, esi
	call	?ExecuteFlankAttack@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteFlankAttack
$LN1@ExecutePri:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 8546 : 		if(bAttackMade)
; 8547 : 		{
; 8548 : 			bAttackUnderway = true;
; 8549 : 		}
; 8550 : 	}
; 8551 : }

	pop	ecx
	ret	4
?ExecutePriorityAttacksOnUnitTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@@Z ENDP ; CvTacticalAI::ExecutePriorityAttacksOnUnitTarget
_TEXT	ENDS
PUBLIC	?PlotSitAndBombardMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotSitAndBombardMoves
; Function compile flags: /Ogtpy
;	COMDAT ?PlotSitAndBombardMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_bAttackUnderway$ = -40					; size = 1
tv871 = -36						; size = 4
_iI$221975 = -32					; size = 4
_target$ = -28						; size = 28
?PlotSitAndBombardMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotSitAndBombardMoves, COMDAT
; _this$ = ecx

; 3395 : {

	sub	esp, 40					; 00000028H

; 3396 : 	// Find primary target for zone (i.e. enemy city)
; 3397 : 	CvTacticalTarget target;

	or	eax, -1
	push	esi
	mov	esi, ecx
	xor	ecx, ecx
	mov	DWORD PTR _target$[esp+48], eax
	mov	DWORD PTR _target$[esp+52], eax
	mov	DWORD PTR _target$[esp+56], eax
	mov	DWORD PTR _target$[esp+68], eax

; 3398 : 	CvPlot* pTarget;
; 3399 : 	bool bAttackUnderway;
; 3400 : 	bool bAttackMade;
; 3401 : 
; 3402 : 	CvTacticalDominanceZone* pZone = GC.getGame().GetTacticalAnalysisMap()->GetZone(m_iCurrentZoneIndex);

	mov	eax, DWORD PTR [esi+24792]
	push	edi
	mov	DWORD PTR _target$[esp+48], ecx
	mov	DWORD PTR _target$[esp+64], ecx
	mov	DWORD PTR _target$[esp+68], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	ecx, eax
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
	mov	edi, eax

; 3403 : 	if(pZone->GetClosestCity() != NULL)

	mov	ecx, edi
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	test	eax, eax
	je	$LN13@PlotSitAnd

; 3404 : 	{
; 3405 : 		// Turn off moves we don't want to mix with this posture
; 3406 : 		TurnOffMove((TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_DAMAGE_CITY]);

	mov	ecx, DWORD PTR [esi+29208]
	push	ebx
	push	ebp
	push	ecx
	mov	ecx, esi
	call	?TurnOffMove@CvTacticalAI@@AAEXW4TacticalAIMoveTypes@@@Z ; CvTacticalAI::TurnOffMove

; 3407 : 
; 3408 : 		target.SetTargetType(AI_TACTICAL_TARGET_CITY);
; 3409 : 		target.SetTargetPlayer(pZone->GetClosestCity()->getOwner());

	mov	ecx, edi
	mov	DWORD PTR _target$[esp+56], 1
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	edx, DWORD PTR [eax+84]

; 3410 : 		target.SetTargetX(pZone->GetClosestCity()->plot()->getX());

	mov	ecx, edi
	mov	DWORD PTR _target$[esp+68], edx
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	ebp, WORD PTR [eax]

; 3411 : 		target.SetTargetY(pZone->GetClosestCity()->plot()->getY());

	mov	ecx, edi
	mov	DWORD PTR _target$[esp+60], ebp
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	ebx, WORD PTR [eax+2]

; 3412 : 		target.SetDominanceZone(pZone->GetDominanceZoneID());

	mov	eax, DWORD PTR [edi]

; 3413 : 
; 3414 : 		m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _target$[esp+64], ebx
	mov	DWORD PTR _target$[esp+80], eax
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 3415 : 		pTarget = GC.getMap().plot(target.GetTargetX(), target.GetTargetY());

	cmp	ebp, -2147483647			; 80000001H
	je	$LN48@PlotSitAnd
	cmp	ebx, -2147483647			; 80000001H
	je	$LN48@PlotSitAnd
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edi+4056], 0
	mov	ecx, DWORD PTR [edi+4020]
	je	SHORT $LN190@PlotSitAnd
	test	ebp, ebp
	jge	SHORT $LN60@PlotSitAnd
	mov	eax, ebp
	cdq
	idiv	ecx
	mov	ebp, edx
	add	ebp, ecx
	jmp	SHORT $LN190@PlotSitAnd
$LN60@PlotSitAnd:
	cmp	ebp, ecx
	jl	SHORT $LN190@PlotSitAnd
	mov	eax, ebp
	cdq
	idiv	ecx
	mov	ebp, edx
$LN190@PlotSitAnd:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4057], 0
	mov	edi, DWORD PTR [edi+4024]
	je	SHORT $LN191@PlotSitAnd
	test	ebx, ebx
	jge	SHORT $LN70@PlotSitAnd
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN72@PlotSitAnd
$LN70@PlotSitAnd:
	cmp	ebx, edi
	jl	SHORT $LN191@PlotSitAnd
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN72@PlotSitAnd
$LN191@PlotSitAnd:
	mov	edx, ebx
$LN72@PlotSitAnd:
	test	ebp, ebp
	jl	SHORT $LN48@PlotSitAnd
	cmp	ebp, ecx
	jge	SHORT $LN48@PlotSitAnd
	test	edx, edx
	jl	SHORT $LN48@PlotSitAnd
	cmp	edx, edi
	jge	SHORT $LN48@PlotSitAnd
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, ebp
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	jmp	SHORT $LN50@PlotSitAnd
$LN48@PlotSitAnd:
	xor	ecx, ecx
$LN50@PlotSitAnd:

; 3416 : 		m_pMap->SetTargetBombardCells(pTarget, m_pMap->GetBestFriendlyRange(), m_pMap->CanIgnoreLOS());

	mov	eax, DWORD PTR [esi+4]
	movzx	edx, BYTE PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR [eax+28]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells

; 3417 : 
; 3418 : 		// Attack primary target (city)
; 3419 : 		bAttackUnderway = ExecuteSafeBombards(target);

	lea	eax, DWORD PTR _target$[esp+56]
	push	eax
	mov	ecx, esi
	call	?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteSafeBombards

; 3420 : 		if(target.IsTargetStillAlive(m_pPlayer->GetID()))

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR _bAttackUnderway$[esp+56], al
	mov	eax, DWORD PTR [ecx+44]
	push	eax
	lea	ecx, DWORD PTR _target$[esp+60]
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN8@PlotSitAnd

; 3421 : 		{
; 3422 : 			bAttackMade = PlotCaptureCityMoves();

	mov	ecx, esi
	call	?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ ; CvTacticalAI::PlotCaptureCityMoves

; 3423 : 			if(bAttackMade)

	test	al, al
	je	SHORT $LN11@PlotSitAnd

; 3424 : 			{
; 3425 : 				bAttackUnderway = true;

	mov	BYTE PTR _bAttackUnderway$[esp+56], 1
$LN11@PlotSitAnd:

; 3426 : 			}
; 3427 : 			if(target.IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	lea	ecx, DWORD PTR _target$[esp+60]
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN8@PlotSitAnd

; 3428 : 			{
; 3429 : 				bAttackMade = ExecuteProtectedBombards(target, bAttackUnderway);

	mov	eax, DWORD PTR _bAttackUnderway$[esp+56]
	push	eax
	lea	ecx, DWORD PTR _target$[esp+60]
	push	ecx
	mov	ecx, esi
	call	?ExecuteProtectedBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@_N@Z ; CvTacticalAI::ExecuteProtectedBombards

; 3430 : 				if(bAttackMade)
; 3431 : 				{
; 3432 : 					bAttackUnderway = true;
; 3433 : 				}
; 3434 : 				if(target.IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	lea	ecx, DWORD PTR _target$[esp+60]
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN8@PlotSitAnd

; 3435 : 				{
; 3436 : 					PlotCaptureCityMoves();

	mov	ecx, esi
	call	?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ ; CvTacticalAI::PlotCaptureCityMoves
$LN8@PlotSitAnd:

; 3437 : 				}
; 3438 : 			}
; 3439 : 		}
; 3440 : 
; 3441 : 		// Attack ancillary target (nearby units)
; 3442 : 		for(unsigned int iI = 0; iI < m_ZoneTargets.size(); iI++)

	xor	edi, edi
	mov	DWORD PTR _iI$221975[esp+56], edi
	cmp	DWORD PTR [esi+9340], edi
	jbe	$LN5@PlotSitAnd
	mov	DWORD PTR tv871[esp+56], edi
	npad	4
$LL7@PlotSitAnd:

; 3443 : 		{
; 3444 : 			// Is the target of an appropriate type?
; 3445 : 			if(m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 3446 : 			        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 3447 : 			        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	mov	eax, DWORD PTR [esi+9336]
	lea	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 7
	je	SHORT $LN3@PlotSitAnd
	cmp	eax, 6
	je	SHORT $LN3@PlotSitAnd
	cmp	eax, 5
	jne	$LN6@PlotSitAnd
$LN3@PlotSitAnd:

; 3448 : 			{
; 3449 : 				if(m_ZoneTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	$LN6@PlotSitAnd

; 3450 : 				{
; 3451 : 					m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [esi+4]
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 3452 : 					pTarget = GC.getMap().plot(m_ZoneTargets[iI].GetTargetX(), m_ZoneTargets[iI].GetTargetY());

	mov	eax, DWORD PTR [esi+9336]
	mov	ebx, DWORD PTR [eax+edi+8]
	add	eax, edi
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN132@PlotSitAnd
	cmp	ebx, -2147483647			; 80000001H
	je	$LN132@PlotSitAnd
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN142@PlotSitAnd
	test	eax, eax
	jge	SHORT $LN144@PlotSitAnd
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	edi, ecx
	jmp	SHORT $LN146@PlotSitAnd
$LN144@PlotSitAnd:
	cmp	eax, ecx
	jl	SHORT $LN142@PlotSitAnd
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN146@PlotSitAnd
$LN142@PlotSitAnd:
	mov	edi, eax
$LN146@PlotSitAnd:
	cmp	BYTE PTR [edx+4057], 0
	mov	ebp, DWORD PTR [edx+4024]
	je	SHORT $LN188@PlotSitAnd
	test	ebx, ebx
	jge	SHORT $LN154@PlotSitAnd
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN156@PlotSitAnd
$LN154@PlotSitAnd:
	cmp	ebx, ebp
	jl	SHORT $LN188@PlotSitAnd
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN156@PlotSitAnd
$LN188@PlotSitAnd:
	mov	edx, ebx
$LN156@PlotSitAnd:
	test	edi, edi
	jl	SHORT $LN136@PlotSitAnd
	cmp	edi, ecx
	jge	SHORT $LN136@PlotSitAnd
	test	edx, edx
	jl	SHORT $LN136@PlotSitAnd
	cmp	edx, ebp
	jge	SHORT $LN136@PlotSitAnd
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	mov	edi, DWORD PTR tv871[esp+56]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN134@PlotSitAnd
$LN136@PlotSitAnd:
	mov	edi, DWORD PTR tv871[esp+56]
$LN132@PlotSitAnd:
	xor	ecx, ecx
$LN134@PlotSitAnd:

; 3453 : 					m_pMap->SetTargetBombardCells(pTarget, m_pMap->GetBestFriendlyRange(), m_pMap->CanIgnoreLOS());

	mov	eax, DWORD PTR [esi+4]
	movzx	edx, BYTE PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR [eax+28]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells

; 3454 : 
; 3455 : 					bAttackUnderway = ExecuteSafeBombards(m_ZoneTargets[iI]);

	mov	eax, DWORD PTR [esi+9336]
	add	eax, edi
	push	eax
	mov	ecx, esi
	call	?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteSafeBombards

; 3456 : 					if(m_ZoneTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	ecx, DWORD PTR [esi+9336]
	mov	BYTE PTR _bAttackUnderway$[esp+56], al
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	add	ecx, edi
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN6@PlotSitAnd

; 3457 : 					{
; 3458 : 						ExecuteProtectedBombards(m_ZoneTargets[iI], bAttackUnderway);

	mov	ecx, DWORD PTR _bAttackUnderway$[esp+56]
	mov	edx, DWORD PTR [esi+9336]
	push	ecx
	add	edx, edi
	push	edx
	mov	ecx, esi
	call	?ExecuteProtectedBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@_N@Z ; CvTacticalAI::ExecuteProtectedBombards
$LN6@PlotSitAnd:
	mov	eax, DWORD PTR _iI$221975[esp+56]
	inc	eax
	add	edi, 28					; 0000001cH
	mov	DWORD PTR _iI$221975[esp+56], eax
	mov	DWORD PTR tv871[esp+56], edi
	cmp	eax, DWORD PTR [esi+9340]
	jb	$LL7@PlotSitAnd
$LN5@PlotSitAnd:

; 3459 : 					}
; 3460 : 				}
; 3461 : 			}
; 3462 : 		}
; 3463 : 
; 3464 : 		PlotCloseOnTarget(true /*bCheckDominance*/);

	push	1
	mov	ecx, esi
	call	?PlotCloseOnTarget@CvTacticalAI@@AAEX_N@Z ; CvTacticalAI::PlotCloseOnTarget
	pop	ebp
	pop	ebx
$LN13@PlotSitAnd:
	pop	edi
	pop	esi

; 3465 : 	}
; 3466 : }

	add	esp, 40					; 00000028H
	ret	0
?PlotSitAndBombardMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotSitAndBombardMoves
_TEXT	ENDS
PUBLIC	?PlotAttritFromRangeMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotAttritFromRangeMoves
; Function compile flags: /Ogtpy
;	COMDAT ?PlotAttritFromRangeMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
tv492 = -12						; size = 4
_iI$221988 = -8						; size = 4
_bAttackUnderway$ = -4					; size = 1
?PlotAttritFromRangeMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotAttritFromRangeMoves, COMDAT
; _this$ = ecx

; 3470 : {

	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 3471 : 	CvPlot* pTarget;
; 3472 : 	bool bAttackUnderway;
; 3473 : 
; 3474 : 	// Find unit targets
; 3475 : 	for(unsigned int iI = 0; iI < m_ZoneTargets.size(); iI++)

	xor	edi, edi
	mov	esi, ecx
	mov	DWORD PTR _iI$221988[esp+20], edi
	cmp	DWORD PTR [esi+9340], edi
	jbe	$LN5@PlotAttrit
	push	ebx
	mov	DWORD PTR tv492[esp+24], edi
	push	ebp
	npad	1
$LL97@PlotAttrit:

; 3476 : 	{
; 3477 : 		// Is the target of an appropriate type?
; 3478 : 		if(m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 3479 : 		        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 3480 : 		        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	mov	eax, DWORD PTR [esi+9336]
	lea	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 7
	je	SHORT $LN3@PlotAttrit
	cmp	eax, 6
	je	SHORT $LN3@PlotAttrit
	cmp	eax, 5
	jne	$LN6@PlotAttrit
$LN3@PlotAttrit:

; 3481 : 		{
; 3482 : 			if(m_ZoneTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	$LN6@PlotAttrit

; 3483 : 			{
; 3484 : 				m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [esi+4]
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 3485 : 				pTarget = GC.getMap().plot(m_ZoneTargets[iI].GetTargetX(), m_ZoneTargets[iI].GetTargetY());

	mov	eax, DWORD PTR [esi+9336]
	mov	ebp, DWORD PTR [eax+edi+8]
	add	eax, edi
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN40@PlotAttrit
	cmp	ebp, -2147483647			; 80000001H
	je	$LN40@PlotAttrit
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN50@PlotAttrit
	test	eax, eax
	jge	SHORT $LN52@PlotAttrit
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	edi, ecx
	jmp	SHORT $LN54@PlotAttrit
$LN52@PlotAttrit:
	cmp	eax, ecx
	jl	SHORT $LN50@PlotAttrit
	cdq
	idiv	ecx
	mov	edi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN54@PlotAttrit
$LN50@PlotAttrit:
	mov	edi, eax
$LN54@PlotAttrit:
	cmp	BYTE PTR [edx+4057], 0
	mov	ebx, DWORD PTR [edx+4024]
	je	SHORT $LN95@PlotAttrit
	test	ebp, ebp
	jge	SHORT $LN62@PlotAttrit
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN64@PlotAttrit
$LN62@PlotAttrit:
	cmp	ebp, ebx
	jl	SHORT $LN95@PlotAttrit
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN64@PlotAttrit
$LN95@PlotAttrit:
	mov	edx, ebp
$LN64@PlotAttrit:
	test	edi, edi
	jl	SHORT $LN44@PlotAttrit
	cmp	edi, ecx
	jge	SHORT $LN44@PlotAttrit
	test	edx, edx
	jl	SHORT $LN44@PlotAttrit
	cmp	edx, ebx
	jge	SHORT $LN44@PlotAttrit
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	mov	edi, DWORD PTR tv492[esp+28]
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN42@PlotAttrit
$LN44@PlotAttrit:
	mov	edi, DWORD PTR tv492[esp+28]
$LN40@PlotAttrit:
	xor	ecx, ecx
$LN42@PlotAttrit:

; 3486 : 				m_pMap->SetTargetBombardCells(pTarget, m_pMap->GetBestFriendlyRange(), m_pMap->CanIgnoreLOS());

	mov	eax, DWORD PTR [esi+4]
	movzx	edx, BYTE PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR [eax+28]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells

; 3487 : 
; 3488 : 				bAttackUnderway = ExecuteSafeBombards(m_ZoneTargets[iI]);

	mov	eax, DWORD PTR [esi+9336]
	add	eax, edi
	push	eax
	mov	ecx, esi
	call	?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteSafeBombards

; 3489 : 				if(m_ZoneTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	ecx, DWORD PTR [esi+9336]
	mov	BYTE PTR _bAttackUnderway$[esp+28], al
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	add	ecx, edi
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN6@PlotAttrit

; 3490 : 				{
; 3491 : 					ExecuteProtectedBombards(m_ZoneTargets[iI], bAttackUnderway);

	mov	ecx, DWORD PTR _bAttackUnderway$[esp+28]
	mov	edx, DWORD PTR [esi+9336]
	push	ecx
	add	edx, edi
	push	edx
	mov	ecx, esi
	call	?ExecuteProtectedBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@_N@Z ; CvTacticalAI::ExecuteProtectedBombards
$LN6@PlotAttrit:
	mov	eax, DWORD PTR _iI$221988[esp+28]
	inc	eax
	add	edi, 28					; 0000001cH
	mov	DWORD PTR _iI$221988[esp+28], eax
	mov	DWORD PTR tv492[esp+28], edi
	cmp	eax, DWORD PTR [esi+9340]
	jb	$LL97@PlotAttrit
	pop	ebp
	pop	ebx
$LN5@PlotAttrit:
	pop	edi
	pop	esi

; 3492 : 				}
; 3493 : 			}
; 3494 : 		}
; 3495 : 	}
; 3496 : }

	add	esp, 12					; 0000000cH
	ret	0
?PlotAttritFromRangeMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotAttritFromRangeMoves
_TEXT	ENDS
PUBLIC	?PlotSteamrollMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotSteamrollMoves
; Function compile flags: /Ogtpy
;	COMDAT ?PlotSteamrollMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
?PlotSteamrollMoves@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::PlotSteamrollMoves, COMDAT
; _this$ = ecx

; 3558 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 3559 : 	m_TempTargets.clear();
; 3560 : 	bool bAttackMade;
; 3561 : 
; 3562 : 	// Loop through unit targets finding advantageous attacks for this turn
; 3563 : 	for(unsigned int iI = 0; iI < m_ZoneTargets.size(); iI++)

	xor	ebx, ebx
	mov	DWORD PTR [esi+23708], 0
	cmp	DWORD PTR [esi+9340], ebx
	jbe	SHORT $LN5@PlotSteamr
	push	edi
	xor	edi, edi
	npad	5
$LL7@PlotSteamr:

; 3564 : 	{
; 3565 : 		if(m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 3566 : 		        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 3567 : 		        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	mov	eax, DWORD PTR [esi+9336]
	lea	ecx, DWORD PTR [eax+edi]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 7
	je	SHORT $LN3@PlotSteamr
	cmp	eax, 6
	je	SHORT $LN3@PlotSteamr
	cmp	eax, 5
	jne	SHORT $LN6@PlotSteamr
$LN3@PlotSteamr:

; 3568 : 		{
; 3569 : 			if(m_ZoneTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN6@PlotSteamr

; 3570 : 			{
; 3571 : 				ExecutePriorityAttacksOnUnitTarget(m_ZoneTargets[iI]);

	mov	eax, DWORD PTR [esi+9336]
	add	eax, edi
	push	eax
	mov	ecx, esi
	call	?ExecutePriorityAttacksOnUnitTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecutePriorityAttacksOnUnitTarget
$LN6@PlotSteamr:
	inc	ebx
	add	edi, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+9340]
	jb	SHORT $LL7@PlotSteamr
	pop	edi
$LN5@PlotSteamr:

; 3572 : 			}
; 3573 : 		}
; 3574 : 	}
; 3575 : 
; 3576 : 	// See if there are any other anti-unit attacks we can make.
; 3577 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT, true);

	push	0
	push	1
	push	7
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3578 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT, true);

	push	0
	push	1
	push	6
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3579 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT, true);

	push	0
	push	1
	push	5
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3580 : 
; 3581 : 	// See if it is time to go after the city
; 3582 : 	bAttackMade = PlotCaptureCityMoves();

	mov	ecx, esi
	call	?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ ; CvTacticalAI::PlotCaptureCityMoves

; 3583 : 
; 3584 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT, false);

	push	0
	push	0
	push	7
	mov	ecx, esi
	mov	bl, al
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3585 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT, false);

	push	0
	push	0
	push	6
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3586 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT, false, true);

	push	1
	push	0
	push	5
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3587 : 
; 3588 : 	if(!bAttackMade)

	test	bl, bl
	jne	SHORT $LN1@PlotSteamr

; 3589 : 	{
; 3590 : 		PlotDamageCityMoves();

	mov	ecx, esi
	call	?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ ; CvTacticalAI::PlotDamageCityMoves
$LN1@PlotSteamr:

; 3591 : 	}
; 3592 : 
; 3593 : 	PlotCloseOnTarget(false /*bCheckDominance*/);

	push	0
	mov	ecx, esi
	call	?PlotCloseOnTarget@CvTacticalAI@@AAEX_N@Z ; CvTacticalAI::PlotCloseOnTarget
	pop	esi
	pop	ebx

; 3594 : }

	ret	0
?PlotSteamrollMoves@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::PlotSteamrollMoves
_TEXT	ENDS
PUBLIC	?PlotSurgicalCityStrikeMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotSurgicalCityStrikeMoves
; Function compile flags: /Ogtpy
;	COMDAT ?PlotSurgicalCityStrikeMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_target$ = -28						; size = 28
?PlotSurgicalCityStrikeMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotSurgicalCityStrikeMoves, COMDAT
; _this$ = ecx

; 3598 : {

	sub	esp, 28					; 0000001cH
	push	ebp

; 3599 : 	CvTacticalTarget target;

	or	eax, -1
	push	esi
	mov	esi, ecx

; 3600 : 	bool bAttackUnderway;
; 3601 : 
; 3602 : 	CvTacticalDominanceZone* pZone = m_pMap->GetZone(m_iCurrentZoneIndex);

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _target$[esp+40], eax
	mov	DWORD PTR _target$[esp+44], eax
	mov	DWORD PTR _target$[esp+48], eax
	mov	DWORD PTR _target$[esp+60], eax
	mov	eax, DWORD PTR [esi+24792]
	push	edi
	xor	ebp, ebp
	push	eax
	mov	DWORD PTR _target$[esp+44], ebp
	mov	DWORD PTR _target$[esp+60], ebp
	mov	DWORD PTR _target$[esp+64], ebp
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
	mov	edi, eax

; 3603 : 	if(pZone->GetClosestCity() != NULL)

	mov	ecx, edi
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	test	eax, eax
	je	$LN9@PlotSurgic

; 3604 : 	{
; 3605 : 		target.SetTargetType(AI_TACTICAL_TARGET_CITY);
; 3606 : 		target.SetTargetPlayer(pZone->GetClosestCity()->getOwner());

	mov	ecx, edi
	mov	DWORD PTR _target$[esp+40], 1
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _target$[esp+52], ecx

; 3607 : 		target.SetTargetX(pZone->GetClosestCity()->plot()->getX());

	mov	ecx, edi
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	edx, WORD PTR [eax]

; 3608 : 		target.SetTargetY(pZone->GetClosestCity()->plot()->getY());

	mov	ecx, edi
	mov	DWORD PTR _target$[esp+44], edx
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 3609 : 		target.SetDominanceZone(pZone->GetDominanceZoneID());

	mov	ecx, DWORD PTR [edi]
	movsx	eax, WORD PTR [eax+2]
	mov	DWORD PTR _target$[esp+64], ecx

; 3610 : 		bAttackUnderway = PlotCaptureCityMoves();

	mov	ecx, esi
	mov	DWORD PTR _target$[esp+48], eax
	call	?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ ; CvTacticalAI::PlotCaptureCityMoves

; 3611 : 
; 3612 : 		// Any unit targets adjacent to city?
; 3613 : 		for(unsigned int iI = 0; iI < m_ZoneTargets.size(); iI++)

	cmp	DWORD PTR [esi+9340], ebp
	jbe	SHORT $LN6@PlotSurgic
	xor	edi, edi
	push	ebx
$LL8@PlotSurgic:

; 3614 : 		{
; 3615 : 			if(m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 3616 : 			        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 3617 : 			        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	mov	edx, DWORD PTR [esi+9336]
	mov	eax, DWORD PTR [edx+edi]
	lea	ebx, DWORD PTR [edx+edi]
	cmp	eax, 7
	je	SHORT $LN4@PlotSurgic
	cmp	eax, 6
	je	SHORT $LN4@PlotSurgic
	cmp	eax, 5
	jne	SHORT $LN7@PlotSurgic
$LN4@PlotSurgic:

; 3618 : 			{
; 3619 : 				if(plotDistance(m_ZoneTargets[iI].GetTargetX(), m_ZoneTargets[iI].GetTargetY(), target.GetTargetX(), target.GetTargetY()) == 1)

	mov	ecx, DWORD PTR _target$[esp+52]
	mov	eax, edx
	mov	edx, DWORD PTR _target$[esp+48]
	push	ecx
	mov	ecx, DWORD PTR [eax+edi+8]
	add	eax, edi
	push	edx
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jne	SHORT $LN7@PlotSurgic

; 3620 : 				{
; 3621 : 					if(m_ZoneTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, ebx
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN7@PlotSurgic

; 3622 : 					{
; 3623 : 						ExecutePriorityAttacksOnUnitTarget(m_ZoneTargets[iI]);

	mov	ecx, DWORD PTR [esi+9336]
	add	ecx, edi
	push	ecx
	mov	ecx, esi
	call	?ExecutePriorityAttacksOnUnitTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecutePriorityAttacksOnUnitTarget
$LN7@PlotSurgic:
	inc	ebp
	add	edi, 28					; 0000001cH
	cmp	ebp, DWORD PTR [esi+9340]
	jb	SHORT $LL8@PlotSurgic
	xor	ebp, ebp
	pop	ebx
$LN6@PlotSurgic:

; 3624 : 					}
; 3625 : 				}
; 3626 : 			}
; 3627 : 		}
; 3628 : 
; 3629 : 		if(target.IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	lea	ecx, DWORD PTR _target$[esp+44]
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN1@PlotSurgic

; 3630 : 		{
; 3631 : 			PlotDamageCityMoves();

	mov	ecx, esi
	call	?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ ; CvTacticalAI::PlotDamageCityMoves
$LN1@PlotSurgic:

; 3632 : 		}
; 3633 : 
; 3634 : 		// Take any other really good attacks we've set up
; 3635 : 		PlotDestroyUnitMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT, true);

	push	ebp
	push	1
	push	7
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3636 : 		PlotDestroyUnitMoves(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT, true);

	push	ebp
	push	1
	push	6
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3637 : 		PlotDestroyUnitMoves(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT, true);

	push	ebp
	push	1
	push	5
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3638 : 
; 3639 : 		PlotCloseOnTarget(false /*bCheckDominance*/);

	push	ebp
	mov	ecx, esi
	call	?PlotCloseOnTarget@CvTacticalAI@@AAEX_N@Z ; CvTacticalAI::PlotCloseOnTarget
$LN9@PlotSurgic:
	pop	edi
	pop	esi
	pop	ebp

; 3640 : 	}
; 3641 : }

	add	esp, 28					; 0000001cH
	ret	0
?PlotSurgicalCityStrikeMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotSurgicalCityStrikeMoves
_TEXT	ENDS
PUBLIC	?PlotHedgehogMoves@CvTacticalAI@@AAEXXZ		; CvTacticalAI::PlotHedgehogMoves
; Function compile flags: /Ogtpy
;	COMDAT ?PlotHedgehogMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_target$222050 = -28					; size = 28
?PlotHedgehogMoves@CvTacticalAI@@AAEXXZ PROC		; CvTacticalAI::PlotHedgehogMoves, COMDAT
; _this$ = ecx

; 3645 : {

	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	esi, ecx

; 3646 : 	// Attack priority unit targets
; 3647 : 	for(unsigned int iI = 0; iI < m_ZoneTargets.size(); iI++)

	xor	ebx, ebx
	push	edi
	cmp	DWORD PTR [esi+9340], ebx
	jbe	SHORT $LN55@PlotHedgeh
	xor	edi, edi
$LL7@PlotHedgeh:

; 3648 : 	{
; 3649 : 		if(m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 3650 : 		        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT)

	mov	eax, DWORD PTR [esi+9336]
	lea	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 7
	je	SHORT $LN3@PlotHedgeh
	cmp	eax, 6
	jne	SHORT $LN6@PlotHedgeh
$LN3@PlotHedgeh:

; 3651 : 		{
; 3652 : 			if(m_ZoneTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN6@PlotHedgeh

; 3653 : 			{
; 3654 : 				ExecutePriorityAttacksOnUnitTarget(m_ZoneTargets[iI]);

	mov	eax, DWORD PTR [esi+9336]
	add	eax, edi
	push	eax
	mov	ecx, esi
	call	?ExecutePriorityAttacksOnUnitTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecutePriorityAttacksOnUnitTarget
$LN6@PlotHedgeh:
	inc	ebx
	add	edi, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+9340]
	jb	SHORT $LL7@PlotHedgeh
$LN55@PlotHedgeh:

; 3655 : 			}
; 3656 : 		}
; 3657 : 	}
; 3658 : 
; 3659 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT, true);

	push	0
	push	1
	push	7
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3660 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT, true);

	push	0
	push	1
	push	6
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3661 : 
; 3662 : 	// But after best attacks are exhausted, go right to playing defense
; 3663 : 	CvTacticalDominanceZone* pZone = m_pMap->GetZone(m_iCurrentZoneIndex);

	mov	ecx, DWORD PTR [esi+24792]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
	mov	edi, eax

; 3664 : 	if(pZone->GetClosestCity() != NULL)

	mov	ecx, edi
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	test	eax, eax
	je	SHORT $LN1@PlotHedgeh

; 3665 : 	{
; 3666 : 		CvTacticalTarget target;
; 3667 : 		target.SetTargetType(AI_TACTICAL_TARGET_CITY);
; 3668 : 		target.SetTargetPlayer(pZone->GetClosestCity()->getOwner());

	mov	ecx, edi
	mov	DWORD PTR _target$222050[esp+56], 0
	mov	DWORD PTR _target$222050[esp+60], 0
	mov	DWORD PTR _target$222050[esp+40], 1
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	edx, DWORD PTR [eax+84]

; 3669 : 		target.SetTargetX(pZone->GetClosestCity()->plot()->getX());

	mov	ecx, edi
	mov	DWORD PTR _target$222050[esp+52], edx
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	eax, WORD PTR [eax]

; 3670 : 		target.SetTargetY(pZone->GetClosestCity()->plot()->getY());

	mov	ecx, edi
	mov	DWORD PTR _target$222050[esp+44], eax
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	ecx, WORD PTR [eax+2]

; 3671 : 		target.SetDominanceZone(pZone->GetDominanceZoneID());

	mov	edx, DWORD PTR [edi]

; 3672 : 		ExecuteHedgehogDefense(target, pZone);

	push	edi
	lea	eax, DWORD PTR _target$222050[esp+44]
	mov	DWORD PTR _target$222050[esp+52], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _target$222050[esp+72], edx
	call	?ExecuteHedgehogDefense@CvTacticalAI@@AAEXAAVCvTacticalTarget@@PAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::ExecuteHedgehogDefense
$LN1@PlotHedgeh:
	pop	edi
	pop	esi
	pop	ebx

; 3673 : 	}
; 3674 : }

	add	esp, 28					; 0000001cH
	ret	0
?PlotHedgehogMoves@CvTacticalAI@@AAEXXZ ENDP		; CvTacticalAI::PlotHedgehogMoves
_TEXT	ENDS
PUBLIC	?PlotCounterattackMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotCounterattackMoves
; Function compile flags: /Ogtpy
;	COMDAT ?PlotCounterattackMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
?PlotCounterattackMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotCounterattackMoves, COMDAT
; _this$ = ecx

; 3678 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 3679 : 	// Attack priority unit targets
; 3680 : 	for(unsigned int iI = 0; iI < m_ZoneTargets.size(); iI++)

	xor	ebx, ebx
	push	edi
	cmp	DWORD PTR [esi+9340], ebx
	jbe	SHORT $LN9@PlotCounte
	xor	edi, edi
$LL11@PlotCounte:

; 3681 : 	{
; 3682 : 		if(m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 3683 : 		        m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT)

	mov	eax, DWORD PTR [esi+9336]
	lea	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 7
	je	SHORT $LN7@PlotCounte
	cmp	eax, 6
	jne	SHORT $LN10@PlotCounte
$LN7@PlotCounte:

; 3684 : 		{
; 3685 : 			if(m_ZoneTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN10@PlotCounte

; 3686 : 			{
; 3687 : 				ExecutePriorityAttacksOnUnitTarget(m_ZoneTargets[iI]);

	mov	eax, DWORD PTR [esi+9336]
	add	eax, edi
	push	eax
	mov	ecx, esi
	call	?ExecutePriorityAttacksOnUnitTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecutePriorityAttacksOnUnitTarget
$LN10@PlotCounte:
	inc	ebx
	add	edi, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+9340]
	jb	SHORT $LL11@PlotCounte
$LN9@PlotCounte:

; 3688 : 			}
; 3689 : 		}
; 3690 : 	}
; 3691 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT, true);

	push	0
	push	1
	push	7
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3692 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT, true);

	push	0
	push	1
	push	6
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3693 : 
; 3694 : 	// Now low priority targets
; 3695 : 	for(unsigned int iI = 0; iI < m_ZoneTargets.size(); iI++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+9340], ebx
	jbe	SHORT $LN3@PlotCounte

; 3688 : 			}
; 3689 : 		}
; 3690 : 	}
; 3691 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT, true);

	xor	edi, edi
	npad	9
$LL5@PlotCounte:

; 3696 : 	{
; 3697 : 		if(m_ZoneTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	mov	ecx, DWORD PTR [esi+9336]
	add	ecx, edi
	cmp	DWORD PTR [ecx], 5
	jne	SHORT $LN4@PlotCounte

; 3698 : 		{
; 3699 : 			if(m_ZoneTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN4@PlotCounte

; 3700 : 			{
; 3701 : 				ExecutePriorityAttacksOnUnitTarget(m_ZoneTargets[iI]);

	mov	eax, DWORD PTR [esi+9336]
	add	eax, edi
	push	eax
	mov	ecx, esi
	call	?ExecutePriorityAttacksOnUnitTarget@CvTacticalAI@@AAEXAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecutePriorityAttacksOnUnitTarget
$LN4@PlotCounte:
	inc	ebx
	add	edi, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+9340]
	jb	SHORT $LL5@PlotCounte
$LN3@PlotCounte:

; 3702 : 			}
; 3703 : 		}
; 3704 : 	}
; 3705 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT, true);

	push	0
	push	1
	push	5
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3706 : 
; 3707 : 	// Now targets we can't destroy
; 3708 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT, false);

	push	0
	push	0
	push	7
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3709 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT, false);

	push	0
	push	0
	push	6
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves

; 3710 : 	PlotDestroyUnitMoves(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT, false);

	push	0
	push	0
	push	5
	mov	ecx, esi
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves
	pop	edi
	pop	esi
	pop	ebx

; 3711 : }

	ret	0
?PlotCounterattackMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotCounterattackMoves
_TEXT	ENDS
PUBLIC	?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ; CvTacticalAI::ClearEnemiesNearArmy
EXTRN	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ:PROC ; CvArmyAI::GetNextUnit
EXTRN	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ:PROC ; CvArmyAI::GetFirstUnit
EXTRN	?GetX@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetX
EXTRN	?GetY@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetY
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$3
__ehfuncinfo$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z
_TEXT	SEGMENT
$T307791 = -48						; size = 4
_iI$222603 = -44					; size = 4
$T307366 = -44						; size = 4
$T307907 = -40						; size = 1
_bAttackUnderway$ = -36					; size = 1
$T308024 = -32						; size = 4
_pUnit$ = -28						; size = 8
_pDefender$222614 = -20					; size = 8
$T307367 = -20						; size = 8
$T307360 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z PROC ; CvTacticalAI::ClearEnemiesNearArmy, COMDAT
; _this$ = ecx

; 4842 : {

	push	-1
	push	__ehhandler$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 4843 : 	bool bEnemyNear = false;
; 4844 : 	CvPlot* pPlot;
; 4845 : 	int iRange = 1;
; 4846 : 	bool bAttackUnderway;
; 4847 : 	bool bAttackMade = false;
; 4848 : 	UnitHandle pUnit;

	xor	ebx, ebx
	xor	edi, edi
	mov	esi, ecx
	mov	DWORD PTR _pUnit$[esp+64], edi
	mov	BYTE PTR _pUnit$[esp+68], bl

; 4849 : 
; 4850 : 	// Loop through all appropriate targets to see if any is of concern
; 4851 : 	for(unsigned int iI = 0; iI < m_AllTargets.size(); iI++)

	xor	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	cmp	DWORD PTR [esi+2156], ebx
	jbe	$LN332@ClearEnemi
	npad	4
$LL23@ClearEnemi:

; 4852 : 	{
; 4853 : 		// Is the target of an appropriate type?
; 4854 : 		if(m_AllTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 4855 : 		        m_AllTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 4856 : 		        m_AllTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	mov	eax, DWORD PTR [esi+2152]
	mov	eax, DWORD PTR [ebx+eax]
	cmp	eax, 7
	je	SHORT $LN320@ClearEnemi
	cmp	eax, 6
	je	SHORT $LN320@ClearEnemi
	cmp	eax, 5
	jne	SHORT $LN22@ClearEnemi
$LN320@ClearEnemi:

; 4857 : 		{
; 4858 : 			// Is this unit near enough?
; 4859 : 			if(plotDistance(pArmy->GetX(), pArmy->GetY(), m_AllTargets[iI].GetTargetX(), m_AllTargets[iI].GetTargetY()) <= iRange)

	mov	ecx, DWORD PTR [esi+2152]
	lea	eax, DWORD PTR [ebx+ecx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _pArmy$[esp+64]
	push	eax
	call	?GetY@CvArmyAI@@QBEHXZ			; CvArmyAI::GetY
	mov	ecx, DWORD PTR _pArmy$[esp+68]
	push	eax
	call	?GetX@CvArmyAI@@QBEHXZ			; CvArmyAI::GetX
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jle	SHORT $LN313@ClearEnemi
$LN22@ClearEnemi:

; 4849 : 
; 4850 : 	// Loop through all appropriate targets to see if any is of concern
; 4851 : 	for(unsigned int iI = 0; iI < m_AllTargets.size(); iI++)

	inc	ebp
	add	ebx, 28					; 0000001cH
	cmp	ebp, DWORD PTR [esi+2156]
	jb	SHORT $LL23@ClearEnemi

; 4874 : 			{
; 4875 : 				if(std::find(m_CurrentTurnUnits.begin(), m_CurrentTurnUnits.end(), pUnit->GetID()) == m_CurrentTurnUnits.end())

	jmp	$LN332@ClearEnemi
$LN313@ClearEnemi:

; 4860 : 			{
; 4861 : 				bEnemyNear = true;
; 4862 : 				break;
; 4863 : 			}
; 4864 : 		}
; 4865 : 	}
; 4866 : 
; 4867 : 	if(bEnemyNear)
; 4868 : 	{
; 4869 : 		// Add units from army to tactical AI for this turn
; 4870 : 		pUnit = pArmy->GetFirstUnit();

	mov	ebp, DWORD PTR _pArmy$[esp+60]
	lea	edx, DWORD PTR $T307360[esp+64]
	push	edx
	mov	ecx, ebp
	call	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetFirstUnit
	lea	ecx, DWORD PTR _pUnit$[esp+64]
	mov	BYTE PTR __$EHRec$[esp+72], 1
	cmp	eax, ecx
	je	SHORT $LN329@ClearEnemi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pUnit$[esp+64], eax
	test	eax, eax
	je	SHORT $LN323@ClearEnemi
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN323@ClearEnemi:
	mov	edi, DWORD PTR _pUnit$[esp+64]
$LN329@ClearEnemi:
	mov	ecx, DWORD PTR $T307360[esp+64]
	mov	BYTE PTR __$EHRec$[esp+72], 0
	test	ecx, ecx
	je	SHORT $LN310@ClearEnemi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN310@ClearEnemi:

; 4871 : 		while(pUnit)

	test	edi, edi
	je	$LN15@ClearEnemi
$LL16@ClearEnemi:

; 4872 : 		{
; 4873 : 			if(!pUnit->TurnProcessed() && !pUnit->isDelayedDeath() && pUnit->canMove())

	mov	ecx, edi
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	SHORT $LN142@ClearEnemi
	mov	ecx, edi
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	SHORT $LN142@ClearEnemi
	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	SHORT $LN142@ClearEnemi

; 4874 : 			{
; 4875 : 				if(std::find(m_CurrentTurnUnits.begin(), m_CurrentTurnUnits.end(), pUnit->GetID()) == m_CurrentTurnUnits.end())

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edi+100]
	cmp	eax, ecx
	je	SHORT $LN337@ClearEnemi
$LL112@ClearEnemi:
	cmp	DWORD PTR [eax+8], edx
	je	SHORT $LN314@ClearEnemi
	mov	eax, DWORD PTR [eax]
	cmp	eax, ecx
	jne	SHORT $LL112@ClearEnemi
$LN314@ClearEnemi:
	cmp	eax, ecx
	jne	SHORT $LN142@ClearEnemi
$LN337@ClearEnemi:

; 4876 : 				{
; 4877 : 					m_CurrentTurnUnits.push_back(pUnit->GetID());

	mov	ebx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [ebx+4]
	lea	ebp, DWORD PTR [esi+8]
	mov	DWORD PTR $T307366[esp+64], edx
	lea	edx, DWORD PTR $T307366[esp+64]
	push	edx
	push	eax
	push	ebx
	mov	ecx, ebp
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ; std::list<int,std::allocator<int> >::_Buynode
	push	1
	mov	ecx, ebp
	mov	edi, eax
	call	?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::list<int,std::allocator<int> >::_Incsize
	mov	DWORD PTR [ebx+4], edi
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR _pUnit$[esp+64]
$LN142@ClearEnemi:

; 4878 : 				}
; 4879 : 			}
; 4880 : 			pUnit = pArmy->GetNextUnit();

	mov	ebp, DWORD PTR _pArmy$[esp+60]
	lea	ecx, DWORD PTR $T307367[esp+64]
	push	ecx
	mov	ecx, ebp
	call	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetNextUnit
	mov	ebx, eax
	lea	edx, DWORD PTR _pUnit$[esp+64]
	mov	BYTE PTR __$EHRec$[esp+72], 2
	cmp	ebx, edx
	je	SHORT $LN334@ClearEnemi
	test	edi, edi
	je	SHORT $LN159@ClearEnemi
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN159@ClearEnemi:
	mov	ebx, DWORD PTR [ebx]
	mov	DWORD PTR _pUnit$[esp+64], ebx
	test	ebx, ebx
	je	SHORT $LN324@ClearEnemi
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN324@ClearEnemi:
	mov	edi, DWORD PTR _pUnit$[esp+64]
$LN334@ClearEnemi:
	mov	ecx, DWORD PTR $T307367[esp+64]
	mov	BYTE PTR __$EHRec$[esp+72], 0
	test	ecx, ecx
	je	SHORT $LN166@ClearEnemi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN166@ClearEnemi:

; 4871 : 		while(pUnit)

	test	edi, edi
	jne	$LL16@ClearEnemi
$LN15@ClearEnemi:

; 4881 : 		}
; 4882 : 
; 4883 : 		// Now attack these targets
; 4884 : 		for(unsigned int iI = 0; iI < m_AllTargets.size(); iI++)

	cmp	DWORD PTR [esi+2156], 0
	mov	DWORD PTR _iI$222603[esp+64], 0
	jbe	$LN332@ClearEnemi
	xor	ebx, ebx
	jmp	SHORT $LN12@ClearEnemi
	npad	9
$LL333@ClearEnemi:
	mov	ebp, DWORD PTR _pArmy$[esp+60]
$LN12@ClearEnemi:

; 4885 : 		{
; 4886 : 			// Is the target of an appropriate type?
; 4887 : 			if(m_AllTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT ||
; 4888 : 			        m_AllTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT ||
; 4889 : 			        m_AllTargets[iI].GetTargetType() == AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT)

	mov	eax, DWORD PTR [esi+2152]
	lea	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 7
	je	SHORT $LN8@ClearEnemi
	cmp	eax, 6
	je	SHORT $LN8@ClearEnemi
	cmp	eax, 5
	jne	$LN11@ClearEnemi
$LN8@ClearEnemi:

; 4890 : 			{
; 4891 : 				if(m_AllTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	$LN11@ClearEnemi

; 4892 : 				{
; 4893 : 					// Is this unit near enough?
; 4894 : 					if(plotDistance(pArmy->GetX(), pArmy->GetY(), m_AllTargets[iI].GetTargetX(), m_AllTargets[iI].GetTargetY()) <= iRange)

	mov	eax, DWORD PTR [esi+2152]
	mov	ecx, DWORD PTR [eax+ebx+8]
	add	eax, ebx
	mov	eax, DWORD PTR [eax+4]
	push	ecx
	push	eax
	mov	ecx, ebp
	call	?GetY@CvArmyAI@@QBEHXZ			; CvArmyAI::GetY
	push	eax
	mov	ecx, ebp
	call	?GetX@CvArmyAI@@QBEHXZ			; CvArmyAI::GetX
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jg	$LN11@ClearEnemi

; 4895 : 					{
; 4896 : 						pPlot = GC.getMap().plot(m_AllTargets[iI].GetTargetX(), m_AllTargets[iI].GetTargetY());

	mov	ecx, DWORD PTR [esi+2152]
	mov	ebp, DWORD PTR [ebx+ecx+4]
	mov	edx, DWORD PTR [ebx+ecx+8]
	lea	eax, DWORD PTR [ebx+ecx]
	mov	DWORD PTR $T307791[esp+64], edx
	cmp	ebp, -2147483647			; 80000001H
	je	$LN206@ClearEnemi
	cmp	edx, -2147483647			; 80000001H
	je	$LN206@ClearEnemi
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	al, al
	je	SHORT $LN216@ClearEnemi
	test	ebp, ebp
	jge	SHORT $LN218@ClearEnemi
	mov	eax, ebp
	cdq
	idiv	ecx
	mov	ebp, edx
	add	ebp, ecx
	jmp	SHORT $LN338@ClearEnemi
$LN218@ClearEnemi:
	cmp	ebp, ecx
	jl	SHORT $LN216@ClearEnemi
	mov	eax, ebp
	cdq
	idiv	ecx
	mov	ebp, edx
$LN338@ClearEnemi:
	mov	edx, DWORD PTR $T307791[esp+64]
$LN216@ClearEnemi:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [eax+4057]
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edi, DWORD PTR [edi+4024]
	test	al, al
	je	SHORT $LN327@ClearEnemi
	test	edx, edx
	jge	SHORT $LN228@ClearEnemi
	mov	eax, edx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN327@ClearEnemi
$LN228@ClearEnemi:
	cmp	edx, edi
	jl	SHORT $LN327@ClearEnemi
	mov	eax, edx
	cdq
	idiv	edi
$LN327@ClearEnemi:
	test	ebp, ebp
	jl	SHORT $LN210@ClearEnemi
	cmp	ebp, ecx
	jge	SHORT $LN210@ClearEnemi
	test	edx, edx
	jl	SHORT $LN210@ClearEnemi
	cmp	edx, edi
	jge	SHORT $LN210@ClearEnemi
	mov	edi, DWORD PTR _pUnit$[esp+64]
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, ebp
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	ebp, ecx
	jmp	SHORT $LN208@ClearEnemi
$LN210@ClearEnemi:
	mov	edi, DWORD PTR _pUnit$[esp+64]
$LN206@ClearEnemi:
	xor	ebp, ebp
$LN208@ClearEnemi:

; 4897 : 
; 4898 : 						m_pMap->ClearDynamicFlags();

	mov	ecx, DWORD PTR [esi+4]
	call	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags

; 4899 : 						m_pMap->SetTargetBombardCells(pPlot, m_pMap->GetBestFriendlyRange(), m_pMap->CanIgnoreLOS());

	mov	ecx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [ecx+32]
	mov	BYTE PTR $T307907[esp+64], al
	mov	edx, DWORD PTR $T307907[esp+64]
	mov	eax, DWORD PTR [ecx+28]
	push	edx
	push	eax
	push	ebp
	call	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells

; 4900 : 
; 4901 : 						bAttackUnderway = ExecuteSafeBombards(m_AllTargets[iI]);

	mov	eax, DWORD PTR [esi+2152]
	add	eax, ebx
	push	eax
	mov	ecx, esi
	call	?ExecuteSafeBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@@Z ; CvTacticalAI::ExecuteSafeBombards

; 4902 : 						if(m_AllTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	ecx, DWORD PTR [esi+2152]
	mov	BYTE PTR _bAttackUnderway$[esp+64], al
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	add	ecx, ebx
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	SHORT $LN5@ClearEnemi

; 4903 : 						{
; 4904 : 							bAttackMade = ExecuteProtectedBombards(m_AllTargets[iI], bAttackUnderway);

	mov	eax, DWORD PTR [esi+2152]
	mov	ecx, DWORD PTR _bAttackUnderway$[esp+64]
	push	ecx
	add	eax, ebx
	push	eax
	mov	ecx, esi
	call	?ExecuteProtectedBombards@CvTacticalAI@@AAE_NAAVCvTacticalTarget@@_N@Z ; CvTacticalAI::ExecuteProtectedBombards
$LN5@ClearEnemi:

; 4905 : 						}
; 4906 : 						if(bAttackMade)
; 4907 : 						{
; 4908 : 							bAttackUnderway = true;
; 4909 : 						}
; 4910 : 						if(m_AllTargets[iI].IsTargetStillAlive(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [esi+2152]
	add	ecx, ebx
	push	eax
	call	?IsTargetStillAlive@CvTacticalTarget@@QAE_NW4PlayerTypes@@@Z ; CvTacticalTarget::IsTargetStillAlive
	test	al, al
	je	$LN11@ClearEnemi

; 4911 : 						{
; 4912 : 							UnitHandle pDefender = pPlot->getVisibleEnemyDefender(m_pPlayer->GetID());

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, ebp
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	mov	edi, eax
	mov	DWORD PTR _pDefender$222614[esp+64], edi
	mov	BYTE PTR _pDefender$222614[esp+68], 0
	test	edi, edi
	je	SHORT $LN271@ClearEnemi
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN271@ClearEnemi:
	mov	BYTE PTR __$EHRec$[esp+72], 3

; 4913 : 							if(pDefender)

	test	edi, edi
	je	SHORT $LN1@ClearEnemi

; 4914 : 							{
; 4915 : 								m_AllTargets[iI].SetAuxIntData(pDefender->GetCurrHitPoints());

	mov	edi, DWORD PTR [esi+2152]
	mov	ecx, DWORD PTR _pDefender$222614[esp+64]
	add	edi, ebx
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints

; 4916 : 								m_CurrentMoveCities.clear();

	lea	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [edi+20], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	edx, DWORD PTR $T308024[esp+72]
	push	edx
	call	?erase@?$vector@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@V?$_Vector_const_iterator@VCvTacticalCity@@V?$allocator@VCvTacticalCity@@@std@@@2@0@Z ; std::vector<CvTacticalCity,std::allocator<CvTacticalCity> >::erase

; 4917 : 								if(FindUnitsWithinStrikingDistance(pPlot, 1, 0, false /* bNoRangedUnits */))

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	1
	push	ebp
	mov	ecx, esi
	call	?FindUnitsWithinStrikingDistance@CvTacticalAI@@AAE_NPAVCvPlot@@HH_N11111@Z ; CvTacticalAI::FindUnitsWithinStrikingDistance
	test	al, al
	je	SHORT $LN325@ClearEnemi

; 4918 : 								{
; 4919 : 									ComputeTotalExpectedDamage(&m_AllTargets[iI], pPlot);

	mov	eax, DWORD PTR [esi+2152]
	push	ebp
	add	eax, ebx
	push	eax
	mov	ecx, esi
	call	?ComputeTotalExpectedDamage@CvTacticalAI@@AAEHPAVCvTacticalTarget@@PAVCvPlot@@@Z ; CvTacticalAI::ComputeTotalExpectedDamage

; 4920 : 									ExecuteAttack(&m_AllTargets[iI], pPlot, true /*bInflictWhatWeTake*/, true /*bMustSurviveAttack*/);

	mov	ecx, DWORD PTR [esi+2152]
	push	1
	push	1
	add	ecx, ebx
	push	ebp
	push	ecx
	mov	ecx, esi
	call	?ExecuteAttack@CvTacticalAI@@AAEXPAVCvTacticalTarget@@PAVCvPlot@@_N2@Z ; CvTacticalAI::ExecuteAttack
$LN325@ClearEnemi:
	mov	edi, DWORD PTR _pDefender$222614[esp+64]
$LN1@ClearEnemi:

; 4921 : 								}
; 4922 : 							}
; 4923 : 						}

	mov	BYTE PTR __$EHRec$[esp+72], 0
	test	edi, edi
	je	SHORT $LN326@ClearEnemi
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN326@ClearEnemi:
	mov	edi, DWORD PTR _pUnit$[esp+64]
$LN11@ClearEnemi:

; 4881 : 		}
; 4882 : 
; 4883 : 		// Now attack these targets
; 4884 : 		for(unsigned int iI = 0; iI < m_AllTargets.size(); iI++)

	mov	eax, DWORD PTR _iI$222603[esp+64]
	inc	eax
	add	ebx, 28					; 0000001cH
	mov	DWORD PTR _iI$222603[esp+64], eax
	cmp	eax, DWORD PTR [esi+2156]
	jb	$LL333@ClearEnemi
$LN332@ClearEnemi:

; 4924 : 					}
; 4925 : 				}
; 4926 : 			}
; 4927 : 		}
; 4928 : 	}
; 4929 : }

	mov	DWORD PTR __$EHRec$[esp+72], -1
	test	edi, edi
	je	SHORT $LN307@ClearEnemi
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN307@ClearEnemi:
	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$1:
	lea	ecx, DWORD PTR $T307360[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$2:
	lea	ecx, DWORD PTR $T307367[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z$3:
	lea	ecx, DWORD PTR _pDefender$222614[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ENDP ; CvTacticalAI::ClearEnemiesNearArmy
PUBLIC	?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z ; CvTacticalAI::PlotEnemyTerritoryOperationMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z$6
__ehfuncinfo$?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
_iI$222277 = -44					; size = 4
tv874 = -40						; size = 4
tv864 = -40						; size = 4
_pClosestCurrentCOMonPath$222324 = -36			; size = 4
$T308100 = -36						; size = 4
_thisSlotEntry$222293 = -36				; size = 4
$T308104 = -32						; size = 4
$T308103 = -32						; size = 4
$T308102 = -32						; size = 4
$T308101 = -32						; size = 4
_operationUnit$222337 = -28				; size = 8
_operationUnit$222314 = -28				; size = 8
_pUnit$222283 = -28					; size = 8
_pUnit$222332 = -20					; size = 8
_pUnit$222309 = -20					; size = 8
_operationUnit$222288 = -20				; size = 8
__$EHRec$ = -12						; size = 12
tv884 = 8						; size = 4
_iI$222303 = 8						; size = 4
_pOperation$ = 8					; size = 4
?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z PROC ; CvTacticalAI::PlotEnemyTerritoryOperationMoves, COMDAT
; _this$ = ecx

; 4193 : {

	push	-1
	push	__ehhandler$?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 4194 : 	// Simplification - assume only 1 army per operation now
; 4195 : 	if(pOperation->GetFirstArmyID() == -1)

	mov	edi, DWORD PTR _pOperation$[esp+60]
	mov	ebx, ecx
	mov	ecx, edi
	mov	DWORD PTR _this$[esp+64], ebx
	call	?GetFirstArmyID@CvAIOperation@@QAEHXZ	; CvAIOperation::GetFirstArmyID
	cmp	eax, -1
	je	$LN1@PlotEnemyT

; 4196 : 	{
; 4197 : 		return;
; 4198 : 	}
; 4199 : 	CvArmyAI* pThisArmy = m_pPlayer->getArmyAI(pOperation->GetFirstArmyID());

	mov	ecx, edi
	call	?GetFirstArmyID@CvAIOperation@@QAEHXZ	; CvAIOperation::GetFirstArmyID
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 4200 : 
; 4201 : 	m_OperationUnits.clear();

	xor	ebp, ebp
	mov	esi, eax
	mov	DWORD PTR [ebx+28648], ebp

; 4202 : 	m_GeneralsToMove.clear();

	mov	DWORD PTR [ebx+28824], ebp

; 4203 : 	m_ParatroopersToMove.clear();
; 4204 : 	pThisArmy->UpdateCheckpointTurns();

	mov	ecx, esi
	mov	DWORD PTR [ebx+29000], ebp
	call	?UpdateCheckpointTurns@CvArmyAI@@QAEXXZ	; CvArmyAI::UpdateCheckpointTurns

; 4205 : 
; 4206 : 	// RECRUITING
; 4207 : 	if(pThisArmy->GetArmyAIState() == ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE)

	mov	ecx, esi
	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState

; 4208 : 	{
; 4209 : 		// If no estimate for when recruiting will end, let the rest of the AI use these units
; 4210 : 		if(pThisArmy->GetTurnAtNextCheckpoint() == ARMYSLOT_UNKNOWN_TURN_AT_CHECKPOINT)

	mov	ecx, esi
	test	eax, eax
	jne	$LN43@PlotEnemyT
	call	?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ ; CvArmyAI::GetTurnAtNextCheckpoint
	cmp	eax, -1
	je	$LN1@PlotEnemyT

; 4211 : 		{
; 4212 : 			return;
; 4213 : 		}
; 4214 : 		else
; 4215 : 		{
; 4216 : 			for(int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	ecx, esi
	mov	DWORD PTR _iI$222277[esp+64], ebp
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	$LN38@PlotEnemyT
	mov	DWORD PTR tv864[esp+64], ebp
$LN40@PlotEnemyT:

; 4217 : 			{
; 4218 : 				CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(iI);

	mov	edi, DWORD PTR [esi+44]
	add	edi, DWORD PTR tv864[esp+64]

; 4219 : 				if(pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [edi]
	cmp	eax, -1
	je	$LN39@PlotEnemyT

; 4220 : 				{
; 4221 : 					// See if we are just able to get to muster point in time.  If so, time for us to head over there
; 4222 : 					UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebp, eax
	mov	DWORD PTR _pUnit$222283[esp+64], ebp
	mov	BYTE PTR _pUnit$222283[esp+68], 0
	test	ebp, ebp
	je	SHORT $LN90@PlotEnemyT
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN90@PlotEnemyT:
	mov	DWORD PTR __$EHRec$[esp+72], 0

; 4223 : 					if(pUnit && !pUnit->TurnProcessed())

	test	ebp, ebp
	je	$LN33@PlotEnemyT
	mov	ecx, ebp
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	$LN33@PlotEnemyT

; 4224 : 					{
; 4225 : 						// Great general?
; 4226 : 						if(pUnit->IsGreatGeneral() || pUnit->IsGreatAdmiral())

	mov	ecx, ebp
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	test	al, al
	jne	$LN34@PlotEnemyT
	mov	ecx, ebp
	call	?IsGreatAdmiral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatAdmiral
	test	al, al
	jne	$LN34@PlotEnemyT

; 4234 : 							}
; 4235 : 						}
; 4236 : 
; 4237 : 						else
; 4238 : 						{
; 4239 : 							CvMultiUnitFormationInfo* pkMultiUnitFormationInfo = GC.getMultiUnitFormationInfo(pThisArmy->GetFormationIndex());

	mov	ecx, esi
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo

; 4240 : 							if(pkMultiUnitFormationInfo)

	test	eax, eax
	je	$LN33@PlotEnemyT

; 4241 : 							{
; 4242 : 								const CvFormationSlotEntry& thisSlotEntry = pkMultiUnitFormationInfo->getFormationSlotEntry(iI);

	mov	ecx, DWORD PTR _iI$222277[esp+64]
	push	ecx
	mov	ecx, eax
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry

; 4243 : 
; 4244 : 								// Continue moving to target
; 4245 : 								if(pSlot->HasStartedOnOperation())

	cmp	DWORD PTR [edi+8], 0
	mov	DWORD PTR _thisSlotEntry$222293[esp+64], eax
	je	SHORT $LN30@PlotEnemyT

; 4246 : 								{
; 4247 : 									MoveWithFormation(pUnit, thisSlotEntry.m_ePositionType);

	mov	edx, DWORD PTR [eax+8]
	push	edx
	sub	esp, 8
	lea	eax, DWORD PTR _pUnit$222283[esp+76]
	mov	ecx, esp
	mov	DWORD PTR $T308100[esp+76], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, ebx
	call	?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ; CvTacticalAI::MoveWithFormation

; 4248 : 								}
; 4249 : 
; 4250 : 								else

	jmp	SHORT $LN33@PlotEnemyT
$LN30@PlotEnemyT:

; 4251 : 								{
; 4252 : 									// See if we are just able to get to muster point in time.  If so, time for us to head over there
; 4253 : 									int iTurns = TurnsToReachTarget(pUnit, pOperation->GetMusterPlot(), true /*bReusePaths*/, true, true);

	mov	ecx, DWORD PTR _pOperation$[esp+60]
	push	1
	push	1
	push	1
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pUnit$222283[esp+88]
	mov	ecx, esp
	mov	DWORD PTR $T308101[esp+88], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget

; 4254 : 									if(iTurns + GC.getGame().getGameTurn() >= pThisArmy->GetTurnAtNextCheckpoint())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esp, 24					; 00000018H
	mov	ebx, eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, esi
	add	ebx, eax
	call	?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ ; CvArmyAI::GetTurnAtNextCheckpoint
	cmp	ebx, eax
	jl	SHORT $LN222@PlotEnemyT

; 4255 : 									{
; 4256 : 										pSlot->SetStartedOnOperation(true);
; 4257 : 										MoveWithFormation(pUnit, thisSlotEntry.m_ePositionType);

	mov	eax, DWORD PTR _thisSlotEntry$222293[esp+64]
	mov	DWORD PTR [edi+8], 1
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	sub	esp, 8
	lea	edx, DWORD PTR _pUnit$222283[esp+76]
	mov	ecx, esp
	mov	DWORD PTR $T308102[esp+76], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, DWORD PTR _this$[esp+76]
	call	?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ; CvTacticalAI::MoveWithFormation
$LN222@PlotEnemyT:
	mov	ebx, DWORD PTR _this$[esp+64]
$LN33@PlotEnemyT:

; 4258 : 									}
; 4259 : 								}
; 4260 : 							}
; 4261 : 						}
; 4262 : 					}
; 4263 : 				}

	mov	DWORD PTR __$EHRec$[esp+72], -1
	test	ebp, ebp
	je	SHORT $LN39@PlotEnemyT
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN39@PlotEnemyT:
	mov	edi, DWORD PTR _iI$222277[esp+64]
	add	DWORD PTR tv864[esp+64], 12		; 0000000cH
	inc	edi
	mov	ecx, esi
	mov	DWORD PTR _iI$222277[esp+64], edi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	edi, eax
	jl	$LN40@PlotEnemyT
$LN38@PlotEnemyT:

; 4264 : 			}
; 4265 : 			ExecuteGatherMoves(pThisArmy);

	push	esi
	mov	ecx, ebx
	call	?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ; CvTacticalAI::ExecuteGatherMoves
	jmp	$LN14@PlotEnemyT
$LN34@PlotEnemyT:

; 4227 : 						{
; 4228 : 							if(pUnit->getMoves() > 0)

	mov	ecx, ebp
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jle	SHORT $LN33@PlotEnemyT

; 4229 : 							{
; 4230 : 								CvOperationUnit operationUnit;
; 4231 : 								operationUnit.SetUnitID(pUnit->GetID());
; 4232 : 								operationUnit.SetPosition((MultiunitPositionTypes)m_CachedInfoTypes[eMUPOSITION_CIVILIAN_SUPPORT]);

	mov	ecx, DWORD PTR [ebx+29376]
	mov	eax, DWORD PTR [ebp+100]

; 4233 : 								m_GeneralsToMove.push_back(operationUnit);

	lea	edx, DWORD PTR _operationUnit$222288[esp+64]
	mov	DWORD PTR _operationUnit$222288[esp+68], ecx
	push	edx
	lea	ecx, DWORD PTR [ebx+28820]
	mov	DWORD PTR _operationUnit$222288[esp+68], eax
	call	?push_back@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvOperationUnit@@@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::push_back
	jmp	SHORT $LN33@PlotEnemyT
$LN43@PlotEnemyT:

; 4266 : 		}
; 4267 : 	}
; 4268 : 
; 4269 : 	// GATHERING FORCES
; 4270 : 	else if(pThisArmy->GetArmyAIState() == ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP)

	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState
	cmp	eax, 1
	jne	$LN26@PlotEnemyT

; 4271 : 	{
; 4272 : 		ClearEnemiesNearArmy(pThisArmy);

	push	esi
	mov	ecx, ebx
	call	?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ; CvTacticalAI::ClearEnemiesNearArmy

; 4273 : 
; 4274 : 		// Request moves for all units
; 4275 : 		for(int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	ecx, esi
	mov	DWORD PTR _iI$222303[esp+60], ebp
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	$LN23@PlotEnemyT

; 4271 : 	{
; 4272 : 		ClearEnemiesNearArmy(pThisArmy);

	mov	DWORD PTR tv874[esp+64], ebp
$LN25@PlotEnemyT:

; 4276 : 		{
; 4277 : 			CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(iI);

	mov	edi, DWORD PTR [esi+44]
	add	edi, DWORD PTR tv874[esp+64]

; 4278 : 			if(pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [edi]
	cmp	eax, -1
	je	$LN24@PlotEnemyT

; 4279 : 			{
; 4280 : 				UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebp, eax
	mov	DWORD PTR _pUnit$222309[esp+64], ebp
	mov	BYTE PTR _pUnit$222309[esp+68], 0
	test	ebp, ebp
	je	SHORT $LN136@PlotEnemyT
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN136@PlotEnemyT:
	mov	DWORD PTR __$EHRec$[esp+72], 1

; 4281 : 				if(pUnit && !pUnit->TurnProcessed())

	test	ebp, ebp
	je	$LN18@PlotEnemyT
	mov	ecx, ebp
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	$LN18@PlotEnemyT

; 4282 : 				{
; 4283 : 					// Great general or admiral?
; 4284 : 					if(pUnit->IsGreatGeneral() || pUnit->IsGreatAdmiral())

	mov	ecx, ebp
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	test	al, al
	jne	SHORT $LN19@PlotEnemyT
	mov	ecx, ebp
	call	?IsGreatAdmiral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatAdmiral
	test	al, al
	jne	SHORT $LN19@PlotEnemyT

; 4292 : 						}
; 4293 : 					}
; 4294 : 
; 4295 : 					else
; 4296 : 					{
; 4297 : 						pSlot->SetStartedOnOperation(true);
; 4298 : 						CvMultiUnitFormationInfo* pkMultiUnitFormationInfo = GC.getMultiUnitFormationInfo(pThisArmy->GetFormationIndex());

	mov	ecx, esi
	mov	DWORD PTR [edi+8], 1
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo

; 4299 : 						if(pkMultiUnitFormationInfo)

	test	eax, eax
	je	SHORT $LN18@PlotEnemyT

; 4300 : 						{
; 4301 : 							const CvFormationSlotEntry& thisSlotEntry = pkMultiUnitFormationInfo->getFormationSlotEntry(iI);

	mov	ecx, DWORD PTR _iI$222303[esp+60]
	push	ecx
	mov	ecx, eax
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry

; 4302 : 							MoveWithFormation(pUnit, thisSlotEntry.m_ePositionType);

	mov	edx, DWORD PTR [eax+8]
	push	edx
	sub	esp, 8
	lea	eax, DWORD PTR _pUnit$222309[esp+76]
	mov	ecx, esp
	mov	DWORD PTR $T308103[esp+76], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, ebx
	call	?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ; CvTacticalAI::MoveWithFormation
	jmp	SHORT $LN18@PlotEnemyT
$LN19@PlotEnemyT:

; 4285 : 					{
; 4286 : 						if(pUnit->getMoves() > 0)

	mov	ecx, ebp
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jle	SHORT $LN18@PlotEnemyT

; 4287 : 						{
; 4288 : 							CvOperationUnit operationUnit;
; 4289 : 							operationUnit.SetUnitID(pUnit->GetID());

	mov	ecx, DWORD PTR [ebp+100]

; 4290 : 							operationUnit.SetPosition((MultiunitPositionTypes)m_CachedInfoTypes[eMUPOSITION_CIVILIAN_SUPPORT]);

	mov	edx, DWORD PTR [ebx+29376]

; 4291 : 							m_GeneralsToMove.push_back(operationUnit);

	lea	eax, DWORD PTR _operationUnit$222314[esp+64]
	mov	DWORD PTR _operationUnit$222314[esp+64], ecx
	push	eax
	lea	ecx, DWORD PTR [ebx+28820]
	mov	DWORD PTR _operationUnit$222314[esp+72], edx
	call	?push_back@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvOperationUnit@@@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::push_back
$LN18@PlotEnemyT:

; 4303 : 						}
; 4304 : 					}
; 4305 : 				}
; 4306 : 			}

	mov	DWORD PTR __$EHRec$[esp+72], -1
	test	ebp, ebp
	je	SHORT $LN24@PlotEnemyT
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN24@PlotEnemyT:
	mov	edi, DWORD PTR _iI$222303[esp+60]
	add	DWORD PTR tv874[esp+64], 12		; 0000000cH
	inc	edi
	mov	ecx, esi
	mov	DWORD PTR _iI$222303[esp+60], edi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	edi, eax
	jl	$LN25@PlotEnemyT
$LN23@PlotEnemyT:

; 4307 : 		}
; 4308 : 			ExecuteGatherMoves(pThisArmy);

	push	esi
	mov	ecx, ebx
	call	?ExecuteGatherMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ; CvTacticalAI::ExecuteGatherMoves
	jmp	$LN14@PlotEnemyT
$LN26@PlotEnemyT:

; 4309 : 	}
; 4310 : 
; 4311 : 	// MOVING TO TARGET
; 4312 : 	else if(pThisArmy->GetArmyAIState() == ARMYAISTATE_MOVING_TO_DESTINATION)

	mov	ecx, esi
	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState
	cmp	eax, 2
	jne	$LN14@PlotEnemyT

; 4313 : 	{
; 4314 : 		// Update army's current location
; 4315 : 		CvPlot* pThisTurnTarget;
; 4316 : 		CvPlot* pClosestCurrentCOMonPath = NULL;
; 4317 : 		pThisTurnTarget = pOperation->ComputeCenterOfMassForTurn(pThisArmy, &pClosestCurrentCOMonPath);

	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+120]
	lea	eax, DWORD PTR _pClosestCurrentCOMonPath$222324[esp+64]
	push	eax
	push	esi
	mov	ecx, edi
	mov	DWORD PTR _pClosestCurrentCOMonPath$222324[esp+72], ebp
	call	edx

; 4318 : 		if(pThisTurnTarget == NULL)

	cmp	eax, ebp
	jne	SHORT $LN13@PlotEnemyT

; 4319 : 		{
; 4320 : 			pOperation->SetToAbort(AI_ABORT_LOST_PATH);

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+76]
	push	14					; 0000000eH
	mov	ecx, edi
	call	edx

; 4370 : 	}
; 4371 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 48					; 00000030H
	ret	4
$LN13@PlotEnemyT:

; 4321 : 			return;
; 4322 : 		}
; 4323 : 
; 4324 : 		pThisArmy->SetXY(pThisTurnTarget->getX(), pThisTurnTarget->getY());

	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	mov	ecx, esi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 4325 : 		ClearEnemiesNearArmy(pThisArmy);

	push	esi
	mov	ecx, ebx
	call	?ClearEnemiesNearArmy@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ; CvTacticalAI::ClearEnemiesNearArmy

; 4326 : 
; 4327 : 		// Request moves for all units
; 4328 : 		for(int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	ecx, esi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	$LN10@PlotEnemyT

; 4321 : 			return;
; 4322 : 		}
; 4323 : 
; 4324 : 		pThisArmy->SetXY(pThisTurnTarget->getX(), pThisTurnTarget->getY());

	mov	DWORD PTR tv884[esp+60], ebp
	npad	6
$LL12@PlotEnemyT:

; 4329 : 		{
; 4330 : 			CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(iI);

	mov	eax, DWORD PTR [esi+44]
	add	eax, DWORD PTR tv884[esp+60]

; 4331 : 			if(pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [eax]
	cmp	eax, -1
	je	$LN11@PlotEnemyT

; 4332 : 			{
; 4333 : 				UnitHandle pUnit = m_pPlayer->getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$222332[esp+64], edi
	mov	BYTE PTR _pUnit$222332[esp+68], 0
	test	edi, edi
	je	SHORT $LN182@PlotEnemyT
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN182@PlotEnemyT:
	mov	DWORD PTR __$EHRec$[esp+72], 2

; 4334 : 				if(pUnit && !pUnit->TurnProcessed())

	test	edi, edi
	je	$LN5@PlotEnemyT
	mov	ecx, edi
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	$LN5@PlotEnemyT

; 4335 : 				{
; 4336 : 					// Great general?
; 4337 : 					if(pUnit->IsGreatGeneral() || pUnit->IsGreatAdmiral())

	mov	ecx, edi
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	test	al, al
	jne	SHORT $LN6@PlotEnemyT
	mov	ecx, edi
	call	?IsGreatAdmiral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatAdmiral
	test	al, al
	jne	SHORT $LN6@PlotEnemyT

; 4345 : 						}
; 4346 : 					}
; 4347 : 					else
; 4348 : 					{
; 4349 : 						CvMultiUnitFormationInfo* pkMultiUnitFormationInfo = GC.getMultiUnitFormationInfo(pThisArmy->GetFormationIndex());

	mov	ecx, esi
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo

; 4350 : 						if(pkMultiUnitFormationInfo)

	test	eax, eax
	je	SHORT $LN5@PlotEnemyT

; 4351 : 						{
; 4352 : 							const CvFormationSlotEntry& thisSlotEntry = pkMultiUnitFormationInfo->getFormationSlotEntry(iI);

	push	ebp
	mov	ecx, eax
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry

; 4353 : 							MoveWithFormation(pUnit, thisSlotEntry.m_ePositionType);

	mov	eax, DWORD PTR [eax+8]
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pUnit$222332[esp+76]
	mov	ecx, esp
	mov	DWORD PTR $T308104[esp+76], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, ebx
	call	?MoveWithFormation@CvTacticalAI@@AAEXV?$FObjectHandle@VCvUnit@@@@W4MultiunitPositionTypes@@@Z ; CvTacticalAI::MoveWithFormation
	jmp	SHORT $LN5@PlotEnemyT
$LN6@PlotEnemyT:

; 4338 : 					{
; 4339 : 						if(pUnit->getMoves() > 0)

	mov	ecx, edi
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jle	SHORT $LN5@PlotEnemyT

; 4340 : 						{
; 4341 : 							CvOperationUnit operationUnit;
; 4342 : 							operationUnit.SetUnitID(pUnit->GetID());
; 4343 : 							operationUnit.SetPosition((MultiunitPositionTypes)m_CachedInfoTypes[eMUPOSITION_CIVILIAN_SUPPORT]);

	mov	ecx, DWORD PTR [ebx+29376]
	mov	eax, DWORD PTR [edi+100]

; 4344 : 							m_GeneralsToMove.push_back(operationUnit);

	lea	edx, DWORD PTR _operationUnit$222337[esp+64]
	mov	DWORD PTR _operationUnit$222337[esp+68], ecx
	push	edx
	lea	ecx, DWORD PTR [ebx+28820]
	mov	DWORD PTR _operationUnit$222337[esp+68], eax
	call	?push_back@?$FStaticVector@VCvOperationUnit@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvOperationUnit@@@Z ; FStaticVector<CvOperationUnit,20,1,297,0>::push_back
$LN5@PlotEnemyT:

; 4354 : 						}
; 4355 : 					}
; 4356 : 				}
; 4357 : 			}

	mov	DWORD PTR __$EHRec$[esp+72], -1
	test	edi, edi
	je	SHORT $LN11@PlotEnemyT
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@PlotEnemyT:
	add	DWORD PTR tv884[esp+60], 12		; 0000000cH
	mov	ecx, esi
	inc	ebp
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	ebp, eax
	jl	$LL12@PlotEnemyT
$LN10@PlotEnemyT:

; 4358 : 		}
; 4359 : 		ExecuteFormationMoves(pThisArmy, pClosestCurrentCOMonPath);

	mov	eax, DWORD PTR _pClosestCurrentCOMonPath$222324[esp+64]
	push	eax
	push	esi
	mov	ecx, ebx
	call	?ExecuteFormationMoves@CvTacticalAI@@AAEXPAVCvArmyAI@@PAVCvPlot@@@Z ; CvTacticalAI::ExecuteFormationMoves
$LN14@PlotEnemyT:

; 4360 : 	}
; 4361 : 
; 4362 : 	if(m_ParatroopersToMove.size() > 0)
; 4363 : 	{
; 4364 : 		//MoveParatroopers(pThisArmy);
; 4365 : 	}
; 4366 : 
; 4367 : 	if(m_GeneralsToMove.size() > 0)

	cmp	DWORD PTR [ebx+28824], 0
	jbe	SHORT $LN1@PlotEnemyT

; 4368 : 	{
; 4369 : 		MoveGreatGeneral(pThisArmy);

	push	esi
	mov	ecx, ebx
	call	?MoveGreatGeneral@CvTacticalAI@@AAEXPAVCvArmyAI@@@Z ; CvTacticalAI::MoveGreatGeneral
$LN1@PlotEnemyT:

; 4370 : 	}
; 4371 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 48					; 00000030H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$222283[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z$4:
	lea	ecx, DWORD PTR _pUnit$222309[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z$6:
	lea	ecx, DWORD PTR _pUnit$222332[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z ENDP ; CvTacticalAI::PlotEnemyTerritoryOperationMoves
PUBLIC	?PlotOperationalArmyMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotOperationalArmyMoves
EXTRN	?getNextAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ:PROC ; CvPlayer::getNextAIOperation
EXTRN	?getFirstAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ:PROC ; CvPlayer::getFirstAIOperation
; Function compile flags: /Ogtpy
;	COMDAT ?PlotOperationalArmyMoves@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
?PlotOperationalArmyMoves@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::PlotOperationalArmyMoves, COMDAT
; _this$ = ecx

; 2547 : {

	push	esi
	push	edi
	mov	edi, ecx

; 2548 : #ifndef AUI_WARNING_FIXES
; 2549 : 	list<int>::iterator it;
; 2550 : #endif
; 2551 : 
; 2552 : 	// Update all operations (moved down - previously was in the PlayerAI object)
; 2553 : 	CvAIOperation* nextOp = NULL;
; 2554 : 	nextOp = m_pPlayer->getFirstAIOperation();

	mov	ecx, DWORD PTR [edi]
	call	?getFirstAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ ; CvPlayer::getFirstAIOperation
	mov	esi, eax

; 2555 : 	while(nextOp != NULL)

	test	esi, esi
	je	SHORT $LL6@PlotOperat
	push	ebx
$LL15@PlotOperat:

; 2556 : 	{
; 2557 : 		if(nextOp->GetLastTurnMoved() < GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, DWORD PTR [esi+68]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	ebx, eax
	jge	SHORT $LN13@PlotOperat

; 2558 : 		{
; 2559 : 			switch(nextOp->GetMoveType())

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+36]
	mov	ecx, esi
	call	edx
	cmp	eax, 3
	ja	SHORT $LN11@PlotOperat
	jmp	DWORD PTR $LN45@PlotOperat[eax*4]
$LN10@PlotOperat:

; 2560 : 			{
; 2561 : 			case AI_OPERATION_MOVETYPE_SINGLE_HEX:
; 2562 : 				PlotSingleHexOperationMoves((CvAIEscortedOperation*)nextOp);

	push	esi
	mov	ecx, edi
	call	?PlotSingleHexOperationMoves@CvTacticalAI@@AAEXPAVCvAIEscortedOperation@@@Z ; CvTacticalAI::PlotSingleHexOperationMoves

; 2563 : 				break;

	jmp	SHORT $LN11@PlotOperat
$LN9@PlotOperat:

; 2564 : 
; 2565 : 			case AI_OPERATION_MOVETYPE_ENEMY_TERRITORY:
; 2566 : 				PlotEnemyTerritoryOperationMoves((CvAIEnemyTerritoryOperation*)nextOp);

	push	esi
	mov	ecx, edi
	call	?PlotEnemyTerritoryOperationMoves@CvTacticalAI@@AAEXPAVCvAIEnemyTerritoryOperation@@@Z ; CvTacticalAI::PlotEnemyTerritoryOperationMoves

; 2567 : 				break;

	jmp	SHORT $LN11@PlotOperat
$LN8@PlotOperat:

; 2568 : 
; 2569 : 			case AI_OPERATION_MOVETYPE_NAVAL_ESCORT:
; 2570 : 				PlotNavalEscortOperationMoves((CvAINavalEscortedOperation*)nextOp);

	push	esi
	mov	ecx, edi
	call	?PlotNavalEscortOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalEscortedOperation@@@Z ; CvTacticalAI::PlotNavalEscortOperationMoves

; 2571 : 				break;

	jmp	SHORT $LN11@PlotOperat
$LN7@PlotOperat:

; 2572 : 
; 2573 : 			case AI_OPERATION_MOVETYPE_FREEFORM_NAVAL:
; 2574 : 				PlotFreeformNavalOperationMoves((CvAINavalOperation*)nextOp);

	push	esi
	mov	ecx, edi
	call	?PlotFreeformNavalOperationMoves@CvTacticalAI@@AAEXPAVCvAINavalOperation@@@Z ; CvTacticalAI::PlotFreeformNavalOperationMoves
$LN11@PlotOperat:

; 2575 : 				break;
; 2576 : 			}
; 2577 : 
; 2578 : 			nextOp->SetLastTurnMoved(GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR [esi+68], eax

; 2579 : 			nextOp->CheckOnTarget();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+56]
	mov	ecx, esi
	call	edx
$LN13@PlotOperat:

; 2580 : 		}
; 2581 : 
; 2582 : 
; 2583 : 		nextOp = m_pPlayer->getNextAIOperation();

	mov	ecx, DWORD PTR [edi]
	call	?getNextAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ ; CvPlayer::getNextAIOperation
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL15@PlotOperat
	pop	ebx
$LL6@PlotOperat:

; 2584 : 	}
; 2585 : 
; 2586 : 	bool bKilledSomething;
; 2587 : 	do
; 2588 : 	{
; 2589 : 		bKilledSomething = false;
; 2590 : 		nextOp = m_pPlayer->getFirstAIOperation();

	mov	ecx, DWORD PTR [edi]
	call	?getFirstAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ ; CvPlayer::getFirstAIOperation

; 2591 : 		while(nextOp != NULL)

	test	eax, eax
	je	SHORT $LN39@PlotOperat
	npad	1
$LL3@PlotOperat:

; 2592 : 		{
; 2593 : 			if(nextOp->DoDelayedDeath())

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+88]
	call	eax
	test	al, al
	jne	SHORT $LL6@PlotOperat

; 2594 : 			{
; 2595 : 				bKilledSomething = true;
; 2596 : 				break;
; 2597 : 			}
; 2598 : 			nextOp = m_pPlayer->getNextAIOperation();

	mov	ecx, DWORD PTR [edi]
	call	?getNextAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ ; CvPlayer::getNextAIOperation
	test	eax, eax
	jne	SHORT $LL3@PlotOperat
$LN39@PlotOperat:
	pop	edi
	pop	esi

; 2599 : 		}
; 2600 : 		// hack
; 2601 : 	}
; 2602 : 	while(bKilledSomething);
; 2603 : }

	ret	0
	npad	1
$LN45@PlotOperat:
	DD	$LN10@PlotOperat
	DD	$LN9@PlotOperat
	DD	$LN8@PlotOperat
	DD	$LN7@PlotOperat
?PlotOperationalArmyMoves@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::PlotOperationalArmyMoves
_TEXT	ENDS
PUBLIC	?AssignTacticalMove@CvTacticalAI@@AAEXVCvTacticalMove@@@Z ; CvTacticalAI::AssignTacticalMove
; Function compile flags: /Ogtpy
;	COMDAT ?AssignTacticalMove@CvTacticalAI@@AAEXVCvTacticalMove@@@Z
_TEXT	SEGMENT
_move$ = 8						; size = 8
?AssignTacticalMove@CvTacticalAI@@AAEXVCvTacticalMove@@@Z PROC ; CvTacticalAI::AssignTacticalMove, COMDAT
; _this$ = ecx

; 1760 : #pragma warning ( push )
; 1761 : #pragma warning ( disable : 6011 ) // Dereferencing NULL pointer
; 1762 : 	AI_PERF_FORMAT("AI-perf-tact.csv", ("Move Type: %s (%d), Turn %03d, %s", GC.getTacticalMoveInfo(move.m_eMoveType)->GetType(), (int)move.m_eMoveType, GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 1763 : #pragma warning ( pop )
; 1764 : 
; 1765 : 	if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_MOVE_NONCOMBATANTS_TO_SAFETY])

	mov	eax, DWORD PTR _move$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	eax, DWORD PTR [esi+29200]
	jne	SHORT $LN99@AssignTact

; 1766 : 	{
; 1767 : 		PlotMovesToSafety(false /*bCombatUnits*/);

	push	0
	call	?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z ; CvTacticalAI::PlotMovesToSafety
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN99@AssignTact:

; 1768 : 	}
; 1769 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_CAPTURE_CITY])

	cmp	eax, DWORD PTR [esi+29204]
	jne	SHORT $LN97@AssignTact

; 1770 : 	{
; 1771 : 		PlotCaptureCityMoves();

	call	?PlotCaptureCityMoves@CvTacticalAI@@AAE_NXZ ; CvTacticalAI::PlotCaptureCityMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN97@AssignTact:

; 1772 : 	}
; 1773 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_DAMAGE_CITY])

	cmp	eax, DWORD PTR [esi+29208]
	jne	SHORT $LN95@AssignTact

; 1774 : 	{
; 1775 : 		PlotDamageCityMoves();

	call	?PlotDamageCityMoves@CvTacticalAI@@AAE_NXZ ; CvTacticalAI::PlotDamageCityMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN95@AssignTact:

; 1776 : 	}
; 1777 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_DESTROY_HIGH_UNIT])

	cmp	eax, DWORD PTR [esi+29212]
	jne	SHORT $LN93@AssignTact

; 1778 : 	{
; 1779 : 		PlotDestroyUnitMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT, true);

	push	0
	push	1
	push	7
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN93@AssignTact:

; 1780 : 	}
; 1781 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_DESTROY_MEDIUM_UNIT])

	cmp	eax, DWORD PTR [esi+29216]
	jne	SHORT $LN91@AssignTact

; 1782 : 	{
; 1783 : 		PlotDestroyUnitMoves(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT, true);

	push	0
	push	1
	push	6
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN91@AssignTact:

; 1784 : 	}
; 1785 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_DESTROY_LOW_UNIT])

	cmp	eax, DWORD PTR [esi+29220]
	jne	SHORT $LN89@AssignTact

; 1786 : 	{
; 1787 : 		PlotDestroyUnitMoves(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT, true);

	push	0
	push	1
	push	5
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN89@AssignTact:

; 1788 : 	}
; 1789 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_TO_SAFETY])

	cmp	eax, DWORD PTR [esi+29224]
	jne	SHORT $LN87@AssignTact

; 1790 : 	{
; 1791 : 		PlotMovesToSafety(true /*bCombatUnits*/);

	push	1
	call	?PlotMovesToSafety@CvTacticalAI@@AAEX_N@Z ; CvTacticalAI::PlotMovesToSafety
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN87@AssignTact:

; 1792 : 	}
; 1793 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_ATTRIT_HIGH_UNIT])

	cmp	eax, DWORD PTR [esi+29228]
	jne	SHORT $LN85@AssignTact

; 1794 : 	{
; 1795 : 		PlotDestroyUnitMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_UNIT, false);

	push	0
	push	0
	push	7
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN85@AssignTact:

; 1796 : 	}
; 1797 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_ATTRIT_MEDIUM_UNIT])

	cmp	eax, DWORD PTR [esi+29232]
	jne	SHORT $LN83@AssignTact

; 1798 : 	{
; 1799 : 		PlotDestroyUnitMoves(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_UNIT, false);

	push	0
	push	0
	push	6
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN83@AssignTact:

; 1800 : 	}
; 1801 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_ATTRIT_LOW_UNIT])

	cmp	eax, DWORD PTR [esi+29236]
	jne	SHORT $LN81@AssignTact

; 1802 : 	{
; 1803 : 		PlotDestroyUnitMoves(AI_TACTICAL_TARGET_LOW_PRIORITY_UNIT, false);

	push	0
	push	0
	push	5
	call	?PlotDestroyUnitMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N1@Z ; CvTacticalAI::PlotDestroyUnitMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN81@AssignTact:

; 1804 : 	}
; 1805 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_REPOSITION])

	cmp	eax, DWORD PTR [esi+29240]
	jne	SHORT $LN79@AssignTact

; 1806 : 	{
; 1807 : 		PlotRepositionMoves();

	call	?PlotRepositionMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotRepositionMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN79@AssignTact:

; 1808 : 	}
; 1809 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_BARBARIAN_CAMP])

	cmp	eax, DWORD PTR [esi+29244]
	jne	SHORT $LN77@AssignTact

; 1810 : 	{
; 1811 : 		PlotBarbarianCampMoves();

	call	?PlotBarbarianCampMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotBarbarianCampMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN77@AssignTact:

; 1812 : 	}
; 1813 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_PILLAGE_CITADEL])

	cmp	eax, DWORD PTR [esi+29356]
	jne	SHORT $LN75@AssignTact

; 1814 : 	{
; 1815 : 		PlotPillageMoves(AI_TACTICAL_TARGET_CITADEL, true /*bFirstPass*/);

	push	1
	push	23					; 00000017H
	call	?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z ; CvTacticalAI::PlotPillageMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN75@AssignTact:

; 1816 : 	}
; 1817 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_PILLAGE_RESOURCE])

	cmp	eax, DWORD PTR [esi+29360]
	jne	SHORT $LN73@AssignTact

; 1818 : 	{
; 1819 : 		PlotPillageMoves(AI_TACTICAL_TARGET_IMPROVEMENT_RESOURCE, true /*bFirstPass*/);

	push	1
	push	24					; 00000018H
	call	?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z ; CvTacticalAI::PlotPillageMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN73@AssignTact:

; 1820 : 	}
; 1821 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_PILLAGE])

	cmp	eax, DWORD PTR [esi+29248]
	jne	SHORT $LN71@AssignTact

; 1822 : 	{
; 1823 : 		PlotPillageMoves(AI_TACTICAL_TARGET_IMPROVEMENT, true /*bFirstPass*/);

	push	1
	push	3
	call	?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z ; CvTacticalAI::PlotPillageMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN71@AssignTact:

; 1824 : 	}
; 1825 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_PILLAGE_CITADEL_NEXT_TURN])

	cmp	eax, DWORD PTR [esi+29364]
	jne	SHORT $LN69@AssignTact

; 1826 : 	{
; 1827 : 		PlotPillageMoves(AI_TACTICAL_TARGET_CITADEL, false /*bFirstPass*/);

	push	0
	push	23					; 00000017H
	call	?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z ; CvTacticalAI::PlotPillageMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN69@AssignTact:

; 1828 : 	}
; 1829 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_PILLAGE_RESOURCE_NEXT_TURN])

	cmp	eax, DWORD PTR [esi+29368]
	jne	SHORT $LN67@AssignTact

; 1830 : 	{
; 1831 : 		PlotPillageMoves(AI_TACTICAL_TARGET_IMPROVEMENT_RESOURCE, false /*bFirstPass*/);

	push	0
	push	24					; 00000018H
	call	?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z ; CvTacticalAI::PlotPillageMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN67@AssignTact:

; 1832 : 	}
; 1833 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_PILLAGE_NEXT_TURN])

	cmp	eax, DWORD PTR [esi+29372]
	jne	SHORT $LN65@AssignTact

; 1834 : 	{
; 1835 : 		PlotPillageMoves(AI_TACTICAL_TARGET_IMPROVEMENT, false /*bFirstPass*/);

	push	0
	push	3
	call	?PlotPillageMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@_N@Z ; CvTacticalAI::PlotPillageMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN65@AssignTact:

; 1836 : 	}
; 1837 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_PLUNDER_TRADE_UNIT])

	cmp	eax, DWORD PTR [esi+29344]
	jne	SHORT $LN63@AssignTact

; 1838 : 	{
; 1839 : 		PlotPlunderTradeUnitMoves(DOMAIN_LAND);

	push	2
	call	?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z ; CvTacticalAI::PlotPlunderTradeUnitMoves

; 1840 : 		PlotPlunderTradeUnitMoves(DOMAIN_SEA);

	push	0
	mov	ecx, esi
	call	?PlotPlunderTradeUnitMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z ; CvTacticalAI::PlotPlunderTradeUnitMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN63@AssignTact:

; 1841 : 	}
; 1842 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_PARK_ON_TRADE_ROUTE])

	cmp	eax, DWORD PTR [esi+29348]
	jne	SHORT $LN61@AssignTact

; 1843 : 	{
; 1844 : 		PlotPlunderTradePlotMoves(DOMAIN_LAND);

	push	2
	call	?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z ; CvTacticalAI::PlotPlunderTradePlotMoves

; 1845 : 		PlotPlunderTradePlotMoves(DOMAIN_SEA);

	push	0
	mov	ecx, esi
	call	?PlotPlunderTradePlotMoves@CvTacticalAI@@AAEXW4DomainTypes@@@Z ; CvTacticalAI::PlotPlunderTradePlotMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN61@AssignTact:

; 1846 : 	}
; 1847 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_ATTACK_VERY_HIGH_PRIORITY_CIVILIAN])

	cmp	eax, DWORD PTR [esi+29252]
	jne	SHORT $LN59@AssignTact

; 1848 : 	{
; 1849 : 		PlotCivilianAttackMoves(AI_TACTICAL_TARGET_VERY_HIGH_PRIORITY_CIVILIAN);

	push	15					; 0000000fH
	call	?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z ; CvTacticalAI::PlotCivilianAttackMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN59@AssignTact:

; 1850 : 	}
; 1851 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_ATTACK_HIGH_PRIORITY_CIVILIAN])

	cmp	eax, DWORD PTR [esi+29256]
	jne	SHORT $LN57@AssignTact

; 1852 : 	{
; 1853 : 		PlotCivilianAttackMoves(AI_TACTICAL_TARGET_HIGH_PRIORITY_CIVILIAN);

	push	16					; 00000010H
	call	?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z ; CvTacticalAI::PlotCivilianAttackMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN57@AssignTact:

; 1854 : 	}
; 1855 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_ATTACK_MEDIUM_PRIORITY_CIVILIAN])

	cmp	eax, DWORD PTR [esi+29260]
	jne	SHORT $LN55@AssignTact

; 1856 : 	{
; 1857 : 		PlotCivilianAttackMoves(AI_TACTICAL_TARGET_MEDIUM_PRIORITY_CIVILIAN);

	push	17					; 00000011H
	call	?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z ; CvTacticalAI::PlotCivilianAttackMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN55@AssignTact:

; 1858 : 	}
; 1859 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_ATTACK_LOW_PRIORITY_CIVILIAN])

	cmp	eax, DWORD PTR [esi+29264]
	jne	SHORT $LN53@AssignTact

; 1860 : 	{
; 1861 : 		PlotCivilianAttackMoves(AI_TACTICAL_TARGET_LOW_PRIORITY_CIVILIAN);

	push	18					; 00000012H
	call	?PlotCivilianAttackMoves@CvTacticalAI@@AAEXW4AITacticalTargetType@@@Z ; CvTacticalAI::PlotCivilianAttackMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN53@AssignTact:

; 1862 : 	}
; 1863 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_SAFE_BOMBARDS])

	cmp	eax, DWORD PTR [esi+29268]
	jne	SHORT $LN51@AssignTact

; 1864 : 	{
; 1865 : 		PlotSafeBombardMoves();

	call	?PlotSafeBombardMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotSafeBombardMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN51@AssignTact:

; 1866 : 	}
; 1867 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_HEAL])

	cmp	eax, DWORD PTR [esi+29272]
	jne	SHORT $LN49@AssignTact

; 1868 : 	{
; 1869 : 		PlotHealMoves();

	call	?PlotHealMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotHealMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN49@AssignTact:

; 1870 : 	}
; 1871 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_ANCIENT_RUINS])

	cmp	eax, DWORD PTR [esi+29276]
	jne	SHORT $LN47@AssignTact

; 1872 : 	{
; 1873 : 		PlotAncientRuinMoves(1);

	push	1
	call	?PlotAncientRuinMoves@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::PlotAncientRuinMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN47@AssignTact:

; 1874 : 	}
; 1875 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_GARRISON_TO_ALLOW_BOMBARD])

	cmp	eax, DWORD PTR [esi+29280]
	jne	SHORT $LN45@AssignTact

; 1876 : 	{
; 1877 : 		PlotGarrisonMoves(1, true /*bMustAllowRangedAttack*/);

	push	1
	push	1
	call	?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z ; CvTacticalAI::PlotGarrisonMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN45@AssignTact:

; 1878 : 	}
; 1879 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_GARRISON_ALREADY_THERE])

	cmp	eax, DWORD PTR [esi+29284]
	jne	SHORT $LN43@AssignTact

; 1880 : 	{
; 1881 : 		PlotGarrisonMoves(0);

	push	0
	push	0
	call	?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z ; CvTacticalAI::PlotGarrisonMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN43@AssignTact:

; 1882 : 	}
; 1883 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_BASTION_ALREADY_THERE])

	cmp	eax, DWORD PTR [esi+29288]
	jne	SHORT $LN41@AssignTact

; 1884 : 	{
; 1885 : 		PlotBastionMoves(0);

	push	0
	call	?PlotBastionMoves@CvTacticalAI@@AAEXH@Z	; CvTacticalAI::PlotBastionMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN41@AssignTact:

; 1886 : 	}
; 1887 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_GUARD_IMPROVEMENT_ALREADY_THERE])

	cmp	eax, DWORD PTR [esi+29292]
	jne	SHORT $LN39@AssignTact

; 1888 : 	{
; 1889 : 		PlotGuardImprovementMoves(0);

	push	0
	call	?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::PlotGuardImprovementMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN39@AssignTact:

; 1890 : 	}
; 1891 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_GARRISON_1_TURN])

	cmp	eax, DWORD PTR [esi+29296]
	jne	SHORT $LN37@AssignTact

; 1892 : 	{
; 1893 : 		PlotGarrisonMoves(1);

	push	0
	push	1
	call	?PlotGarrisonMoves@CvTacticalAI@@AAEXH_N@Z ; CvTacticalAI::PlotGarrisonMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN37@AssignTact:

; 1894 : 	}
; 1895 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_BASTION_1_TURN])

	cmp	eax, DWORD PTR [esi+29300]
	jne	SHORT $LN35@AssignTact

; 1896 : 	{
; 1897 : 		PlotBastionMoves(1);

	push	1
	call	?PlotBastionMoves@CvTacticalAI@@AAEXH@Z	; CvTacticalAI::PlotBastionMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN35@AssignTact:

; 1898 : 	}
; 1899 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_GUARD_IMPROVEMENT_1_TURN])

	cmp	eax, DWORD PTR [esi+29304]
	jne	SHORT $LN33@AssignTact

; 1900 : 	{
; 1901 : 		PlotGuardImprovementMoves(1);

	push	1
	call	?PlotGuardImprovementMoves@CvTacticalAI@@AAEXH@Z ; CvTacticalAI::PlotGuardImprovementMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN33@AssignTact:

; 1902 : 	}
; 1903 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_AIR_INTERCEPT])

	cmp	eax, DWORD PTR [esi+29308]
	jne	SHORT $LN31@AssignTact

; 1904 : 	{
; 1905 : 		PlotAirInterceptMoves();

	call	?PlotAirInterceptMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotAirInterceptMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN31@AssignTact:

; 1906 : 	}
; 1907 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_AIR_SWEEP])

	cmp	eax, DWORD PTR [esi+29312]
	jne	SHORT $LN29@AssignTact

; 1908 : 	{
; 1909 : 		PlotAirSweepMoves();

	call	?PlotAirSweepMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotAirSweepMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN29@AssignTact:

; 1910 : 	}
; 1911 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_SIT_AND_BOMBARD])

	cmp	eax, DWORD PTR [esi+29176]
	jne	SHORT $LN27@AssignTact

; 1912 : 	{
; 1913 : 		PlotSitAndBombardMoves();

	call	?PlotSitAndBombardMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotSitAndBombardMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN27@AssignTact:

; 1914 : 	}
; 1915 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_ATTRIT_FROM_RANGE])

	cmp	eax, DWORD PTR [esi+29180]
	jne	SHORT $LN25@AssignTact

; 1916 : 	{
; 1917 : 		PlotAttritFromRangeMoves();

	call	?PlotAttritFromRangeMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotAttritFromRangeMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN25@AssignTact:

; 1918 : 	}
; 1919 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_EXPLOIT_FLANKS])

	cmp	eax, DWORD PTR [esi+29184]
	jne	SHORT $LN23@AssignTact

; 1920 : 	{
; 1921 : 		PlotExploitFlanksMoves();

	call	?PlotExploitFlanksMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotExploitFlanksMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN23@AssignTact:

; 1922 : 	}
; 1923 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_STEAMROLL])

	cmp	eax, DWORD PTR [esi+29188]
	jne	SHORT $LN21@AssignTact

; 1924 : 	{
; 1925 : 		PlotSteamrollMoves();

	call	?PlotSteamrollMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotSteamrollMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN21@AssignTact:

; 1926 : 	}
; 1927 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_SURGICAL_CITY_STRIKE])

	cmp	eax, DWORD PTR [esi+29192]
	jne	SHORT $LN19@AssignTact

; 1928 : 	{
; 1929 : 		PlotSurgicalCityStrikeMoves();

	call	?PlotSurgicalCityStrikeMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotSurgicalCityStrikeMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN19@AssignTact:

; 1930 : 	}
; 1931 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_HEDGEHOG])

	cmp	eax, DWORD PTR [esi+29316]
	jne	SHORT $LN17@AssignTact

; 1932 : 	{
; 1933 : 		PlotHedgehogMoves();

	call	?PlotHedgehogMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotHedgehogMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN17@AssignTact:

; 1934 : 	}
; 1935 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_COUNTERATTACK])

	cmp	eax, DWORD PTR [esi+29196]
	jne	SHORT $LN15@AssignTact

; 1936 : 	{
; 1937 : 		PlotCounterattackMoves();

	call	?PlotCounterattackMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotCounterattackMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN15@AssignTact:

; 1938 : 	}
; 1939 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_WITHDRAW])

	cmp	eax, DWORD PTR [esi+29320]
	jne	SHORT $LN13@AssignTact

; 1940 : 	{
; 1941 : 		PlotWithdrawMoves();

	call	?PlotWithdrawMoves@CvTacticalAI@@AAEXXZ	; CvTacticalAI::PlotWithdrawMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN13@AssignTact:

; 1942 : 	}
; 1943 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_SHORE_BOMBARDMENT])

	cmp	eax, DWORD PTR [esi+29324]
	jne	SHORT $LN11@AssignTact

; 1944 : 	{
; 1945 : 		PlotShoreBombardmentMoves();

	call	?PlotShoreBombardmentMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotShoreBombardmentMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN11@AssignTact:

; 1946 : 	}
; 1947 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_CLOSE_ON_TARGET])

	cmp	eax, DWORD PTR [esi+29328]
	jne	SHORT $LN9@AssignTact

; 1948 : 	{
; 1949 : 		PlotCloseOnTarget(true /*bCheckDominance*/);

	push	1
	call	?PlotCloseOnTarget@CvTacticalAI@@AAEX_N@Z ; CvTacticalAI::PlotCloseOnTarget
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN9@AssignTact:

; 1950 : 	}
; 1951 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_MOVE_OPERATIONS])

	cmp	eax, DWORD PTR [esi+29332]
	jne	SHORT $LN7@AssignTact

; 1952 : 	{
; 1953 : 		PlotOperationalArmyMoves();

	call	?PlotOperationalArmyMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotOperationalArmyMoves
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN7@AssignTact:

; 1954 : 	}
; 1955 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_EMERGENCY_PURCHASES])

	cmp	eax, DWORD PTR [esi+29336]
	jne	SHORT $LN5@AssignTact

; 1956 : 	{
; 1957 : 		PlotEmergencyPurchases();

	call	?PlotEmergencyPurchases@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotEmergencyPurchases
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN5@AssignTact:

; 1958 : 	}
; 1959 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_DEFENSIVE_AIRLIFT])

	cmp	eax, DWORD PTR [esi+29352]
	jne	SHORT $LN3@AssignTact

; 1960 : 	{
; 1961 : 		PlotDefensiveAirlifts();

	call	?PlotDefensiveAirlifts@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotDefensiveAirlifts
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
$LN3@AssignTact:

; 1962 : 	}
; 1963 : 	else if(move.m_eMoveType == (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_ESCORT_EMBARKED_UNIT])

	cmp	eax, DWORD PTR [esi+29340]
	jne	SHORT $LN1@AssignTact

; 1964 : 	{
; 1965 : 		PlotEscortEmbarkedMoves();

	call	?PlotEscortEmbarkedMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::PlotEscortEmbarkedMoves
$LN1@AssignTact:
	pop	esi

; 1966 : 	}
; 1967 : }

	ret	8
?AssignTacticalMove@CvTacticalAI@@AAEXVCvTacticalMove@@@Z ENDP ; CvTacticalAI::AssignTacticalMove
_TEXT	ENDS
PUBLIC	?ProcessDominanceZones@CvTacticalAI@@AAEXXZ	; CvTacticalAI::ProcessDominanceZones
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?ProcessDominanceZones@CvTacticalAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessDominanceZones@CvTacticalAI@@AAEXXZ$0
__ehfuncinfo$?ProcessDominanceZones@CvTacticalAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ProcessDominanceZones@CvTacticalAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.cpp
xdata$x	ENDS
;	COMDAT ?ProcessDominanceZones@CvTacticalAI@@AAEXXZ
_TEXT	SEGMENT
_iI$220958 = -60					; size = 4
_it$ = -56						; size = 4
tv414 = -52						; size = 4
_move$220954 = -48					; size = 8
_strMoveName$220963 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ProcessDominanceZones@CvTacticalAI@@AAEXXZ PROC	; CvTacticalAI::ProcessDominanceZones, COMDAT
; _this$ = ecx

; 1629 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ProcessDominanceZones@CvTacticalAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	esi
	mov	esi, ecx

; 1630 : 	CvTacticalDominanceZone* pZone;
; 1631 : 	FStaticVector<CvTacticalMove, 256, true, c_eCiv5GameplayDLL >::iterator it;
; 1632 : 
; 1633 : 	// Barbarian processing is straightforward -- just one big list of priorites and everything is considered at once
; 1634 : 	if(m_pPlayer->isBarbarian())

	mov	ecx, DWORD PTR [esi]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian

; 1635 : 	{
; 1636 : 		EstablishBarbarianPriorities();

	mov	ecx, esi
	test	al, al
	je	SHORT $LN37@ProcessDom
	call	?EstablishBarbarianPriorities@CvTacticalAI@@AAEXXZ ; CvTacticalAI::EstablishBarbarianPriorities

; 1637 : 		ExtractTargetsForZone(NULL);

	push	0
	mov	ecx, esi
	call	?ExtractTargetsForZone@CvTacticalAI@@AAEXPAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::ExtractTargetsForZone

; 1638 : 		AssignBarbarianMoves();

	mov	ecx, esi
	call	?AssignBarbarianMoves@CvTacticalAI@@AAEXXZ ; CvTacticalAI::AssignBarbarianMoves
	pop	esi

; 1751 : 				}
; 1752 : 			}
; 1753 : 		}
; 1754 : 	}
; 1755 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	mov	DWORD PTR fs:0, ecx
	add	esp, 60					; 0000003cH
	ret	0
$LN37@ProcessDom:
	push	ebx

; 1639 : 	}
; 1640 : 
; 1641 : 	else
; 1642 : 	{
; 1643 : 		EstablishTacticalPriorities();

	call	?EstablishTacticalPriorities@CvTacticalAI@@AAEXXZ ; CvTacticalAI::EstablishTacticalPriorities

; 1644 : 		UpdatePostures();

	mov	ecx, esi
	call	?UpdatePostures@CvTacticalAI@@AAEXXZ	; CvTacticalAI::UpdatePostures

; 1645 : 
; 1646 : 		// Proceed in priority order
; 1647 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 1648 : 		for (it = m_MovePriorityList.begin(); it != m_MovePriorityList.end(); ++it)
; 1649 : #else
; 1650 : 		for(it = m_MovePriorityList.begin(); it != m_MovePriorityList.end(); it++)

	mov	ebx, DWORD PTR [esi+68]
	mov	eax, DWORD PTR [esi+72]
	mov	ecx, ebx
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _it$[esp+68], ebx
	cmp	ebx, edx
	je	$LN92@ProcessDom
	push	ebp
	push	edi
$LL35@ProcessDom:

; 1651 : #endif
; 1652 : 		{
; 1653 : 			CvTacticalMove move = *it;

	mov	edi, DWORD PTR [ebx+4]
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR _move$220954[esp+76], ebp
	mov	DWORD PTR _move$220954[esp+80], edi

; 1654 : 
; 1655 : 			if(move.m_iPriority >= 0)

	test	edi, edi
	jl	$LN34@ProcessDom

; 1656 : 			{
; 1657 : 				CvTacticalMoveXMLEntry* pkTacticalMoveInfo = GC.getTacticalMoveInfo(move.m_eMoveType);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTacticalMoveInfo@CvGlobals@@QAEPAVCvTacticalMoveXMLEntry@@W4TacticalAIMoveTypes@@@Z ; CvGlobals::getTacticalMoveInfo

; 1658 : 				if(pkTacticalMoveInfo && pkTacticalMoveInfo->IsDominanceZoneMove())

	test	eax, eax
	je	$LN31@ProcessDom
	cmp	BYTE PTR [eax+277], 0
	je	$LN31@ProcessDom

; 1659 : 				{
; 1660 : 					for(int iI = 0; iI < m_pMap->GetNumZones(); iI++)

	mov	edx, DWORD PTR [esi+4]
	xor	ecx, ecx
	cmp	DWORD PTR [edx+116], ecx
	mov	DWORD PTR _iI$220958[esp+76], ecx
	jle	$LN34@ProcessDom

; 1750 : 					AssignTacticalMove(move);

	add	eax, 176				; 000000b0H
	mov	DWORD PTR tv414[esp+76], eax
	jmp	SHORT $LN30@ProcessDom
	npad	11
$LL88@ProcessDom:

; 1659 : 				{
; 1660 : 					for(int iI = 0; iI < m_pMap->GetNumZones(); iI++)

	mov	ecx, DWORD PTR _iI$220958[esp+76]
	mov	ebp, DWORD PTR _move$220954[esp+76]
$LN30@ProcessDom:

; 1661 : 					{
; 1662 : 						m_iCurrentZoneIndex = iI;

	mov	DWORD PTR [esi+24792], ecx

; 1663 : 						pZone = m_pMap->GetZone(iI);

	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
	mov	edi, eax

; 1664 : 						AITacticalPosture ePosture = FindPosture(pZone);

	push	edi
	mov	ecx, esi
	call	?FindPosture@CvTacticalAI@@AAE?AW4AITacticalPosture@@PAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::FindPosture

; 1665 : 						CvString strMoveName = (CvString)pkTacticalMoveInfo->GetType();

	mov	ecx, DWORD PTR tv414[esp+76]
	mov	ebx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	jne	SHORT $LN56@ProcessDom
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN56@ProcessDom:
	push	eax
	lea	ecx, DWORD PTR _strMoveName$220963[esp+80]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1666 : 						CvTacticalMove moveToPassOn = move;
; 1667 : 
; 1668 : 						// Is this move of the right type for this zone?
; 1669 : 						bool bMatch = false;
; 1670 : 						if(strMoveName == "TACTICAL_CLOSE_ON_TARGET")    // This one okay for all zones

	lea	eax, DWORD PTR _strMoveName$220963[esp+76]
	push	OFFSET $SG220969
	push	eax
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al

; 1671 : 						{
; 1672 : 							bMatch = true;

	jne	$LN87@ProcessDom

; 1673 : 						}
; 1674 : 						else if(ePosture == AI_TACTICAL_POSTURE_WITHDRAW && strMoveName == "TACTICAL_POSTURE_WITHDRAW")

	test	ebx, ebx
	jne	SHORT $LN25@ProcessDom
	push	OFFSET $SG220972
	lea	ecx, DWORD PTR _strMoveName$220963[esp+80]
	push	ecx
$LN95@ProcessDom:
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN21@ProcessDom

; 1675 : 						{
; 1676 : 							bMatch = true;

	jmp	$LN87@ProcessDom
$LN25@ProcessDom:

; 1677 : 						}
; 1678 : 						else if(ePosture == AI_TACTICAL_POSTURE_HEDGEHOG && strMoveName == "TACTICAL_POSTURE_HEDGEHOG")

	cmp	ebx, 6
	jne	SHORT $LN23@ProcessDom
	push	OFFSET $SG220975
	lea	edx, DWORD PTR _strMoveName$220963[esp+80]
	push	edx

; 1679 : 						{
; 1680 : 							bMatch = true;

	jmp	SHORT $LN95@ProcessDom
$LN23@ProcessDom:

; 1681 : 						}
; 1682 : 						else if(ePosture == AI_TACTICAL_POSTURE_SHORE_BOMBARDMENT && strMoveName == "TACTICAL_POSTURE_SHORE_BOMBARDMENT")

	cmp	ebx, 8
	jne	SHORT $LN21@ProcessDom
	lea	eax, DWORD PTR _strMoveName$220963[esp+76]
	push	OFFSET $SG220978
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al

; 1683 : 						{
; 1684 : 							bMatch = true;

	jne	$LN87@ProcessDom
$LN21@ProcessDom:

; 1685 : 						}
; 1686 : 						else if(pZone->GetDominanceFlag() != TACTICAL_DOMINANCE_FRIENDLY && pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY && strMoveName == "TACTICAL_EMERGENCY_PURCHASES")

	cmp	DWORD PTR [edi+8], 1
	je	SHORT $LN17@ProcessDom
	cmp	DWORD PTR [edi+4], 2
	jne	SHORT $LN89@ProcessDom
	lea	ecx, DWORD PTR _strMoveName$220963[esp+76]
	push	OFFSET $SG220981
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al

; 1687 : 						{
; 1688 : 							bMatch = true;

	jne	SHORT $LN87@ProcessDom
$LN89@ProcessDom:

; 1689 : 						}
; 1690 : 						else if(pZone->GetDominanceFlag() != TACTICAL_DOMINANCE_FRIENDLY && pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY && strMoveName == "TACTICAL_DEFENSIVE_AIRLIFT")

	cmp	DWORD PTR [edi+8], 1
	je	SHORT $LN17@ProcessDom
	cmp	DWORD PTR [edi+4], 2
	jne	SHORT $LN17@ProcessDom
	lea	edx, DWORD PTR _strMoveName$220963[esp+76]
	push	OFFSET $SG220984
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al

; 1691 : 						{
; 1692 : 							bMatch = true;

	jne	SHORT $LN87@ProcessDom
$LN17@ProcessDom:

; 1693 : 						}
; 1694 : 						else if (strMoveName == "TACTICAL_OFFENSIVE_POSTURE_MOVES")

	lea	eax, DWORD PTR _strMoveName$220963[esp+76]
	push	OFFSET $SG220987
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN5@ProcessDom

; 1695 : 						{
; 1696 : 							// If this is an offensive posture move, map us to the detailed move type.  Why?  Well we want these offensive moves
; 1697 : 							// processed in order of zone priority. This allows us to set them all to the same priority but then break them out
; 1698 : 							// into individual move types that get passed into AssignTacticalMove()
; 1699 : 							bMatch = true;
; 1700 : 							
; 1701 : 							switch (ePosture)

	lea	eax, DWORD PTR [ebx-1]
	cmp	eax, 6
	ja	SHORT $LN5@ProcessDom
	jmp	DWORD PTR $LN96@ProcessDom[eax*4]
$LN12@ProcessDom:

; 1702 : 							{
; 1703 : 							case AI_TACTICAL_POSTURE_SIT_AND_BOMBARD:
; 1704 : 								moveToPassOn.m_eMoveType = (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_SIT_AND_BOMBARD];

	mov	ebp, DWORD PTR [esi+29176]

; 1705 : 								break;

	jmp	SHORT $LN87@ProcessDom
$LN11@ProcessDom:

; 1706 : 							case AI_TACTICAL_POSTURE_ATTRIT_FROM_RANGE:
; 1707 : 								moveToPassOn.m_eMoveType = (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_ATTRIT_FROM_RANGE];

	mov	ebp, DWORD PTR [esi+29180]

; 1708 : 								break;

	jmp	SHORT $LN87@ProcessDom
$LN10@ProcessDom:

; 1709 : 							case AI_TACTICAL_POSTURE_EXPLOIT_FLANKS:
; 1710 : 								moveToPassOn.m_eMoveType = (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_EXPLOIT_FLANKS];

	mov	ebp, DWORD PTR [esi+29184]

; 1711 : 								break;

	jmp	SHORT $LN87@ProcessDom
$LN9@ProcessDom:

; 1712 : 							case AI_TACTICAL_POSTURE_STEAMROLL:
; 1713 : 								moveToPassOn.m_eMoveType = (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_STEAMROLL];

	mov	ebp, DWORD PTR [esi+29188]

; 1714 : 								break;

	jmp	SHORT $LN87@ProcessDom
$LN8@ProcessDom:

; 1715 : 							case AI_TACTICAL_POSTURE_SURGICAL_CITY_STRIKE:
; 1716 : 								moveToPassOn.m_eMoveType = (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_SURGICAL_CITY_STRIKE];

	mov	ebp, DWORD PTR [esi+29192]

; 1717 : 								break;

	jmp	SHORT $LN87@ProcessDom
$LN7@ProcessDom:

; 1718 : 							case AI_TACTICAL_POSTURE_COUNTERATTACK:
; 1719 : 								moveToPassOn.m_eMoveType = (TacticalAIMoveTypes)m_CachedInfoTypes[eTACTICAL_POSTURE_COUNTERATTACK];

	mov	ebp, DWORD PTR [esi+29196]
$LN87@ProcessDom:

; 1720 : 								break;
; 1721 : 							default:
; 1722 : 								bMatch = false;
; 1723 : 								break;
; 1724 : 							}
; 1725 : 						}
; 1726 : 
; 1727 : 						if(bMatch)
; 1728 : 						{
; 1729 : 							if(!UseThisDominanceZone(pZone))

	push	edi
	mov	ecx, esi
	call	?UseThisDominanceZone@CvTacticalAI@@AAE_NPAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::UseThisDominanceZone
	test	al, al

; 1730 : 							{
; 1731 : 								continue;

	je	SHORT $LN5@ProcessDom

; 1732 : 							}
; 1733 : 
; 1734 : 							ExtractTargetsForZone(pZone);

	push	edi
	mov	ecx, esi
	call	?ExtractTargetsForZone@CvTacticalAI@@AAEXPAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::ExtractTargetsForZone

; 1735 : 
; 1736 : 							// Must have some moves to continue or it must be land around an enemy city (which we always want to process because
; 1737 : 							// we might have an operation targeting it)
; 1738 : 							if(m_ZoneTargets.size() <= 0 && pZone->GetTerritoryType() != TACTICAL_TERRITORY_TEMP_ZONE && (pZone->GetTerritoryType() != TACTICAL_TERRITORY_ENEMY || pZone->IsWater()))

	cmp	DWORD PTR [esi+9340], 0
	ja	SHORT $LN3@ProcessDom
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 5
	je	SHORT $LN3@ProcessDom
	cmp	eax, 3
	jne	SHORT $LN5@ProcessDom
	cmp	BYTE PTR [edi+68], 0

; 1739 : 							{
; 1740 : 								continue;

	jne	SHORT $LN5@ProcessDom
$LN3@ProcessDom:

; 1741 : 							}
; 1742 : 
; 1743 : 							AssignTacticalMove(moveToPassOn);

	mov	eax, DWORD PTR _move$220954[esp+80]
	push	eax
	push	ebp
	mov	ecx, esi
	call	?AssignTacticalMove@CvTacticalAI@@AAEXVCvTacticalMove@@@Z ; CvTacticalAI::AssignTacticalMove
$LN5@ProcessDom:

; 1744 : 						}
; 1745 : 					}

	lea	ecx, DWORD PTR _strMoveName$220963[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _iI$220958[esp+76]
	mov	ecx, DWORD PTR [esi+4]
	inc	eax
	cmp	eax, DWORD PTR [ecx+116]
	mov	DWORD PTR _iI$220958[esp+76], eax
	jl	$LL88@ProcessDom

; 1746 : 				}
; 1747 : 				else

	mov	ebx, DWORD PTR _it$[esp+76]
	jmp	SHORT $LN34@ProcessDom
$LN31@ProcessDom:

; 1748 : 				{
; 1749 : 					ExtractTargetsForZone(NULL);

	push	0
	mov	ecx, esi
	call	?ExtractTargetsForZone@CvTacticalAI@@AAEXPAVCvTacticalDominanceZone@@@Z ; CvTacticalAI::ExtractTargetsForZone

; 1750 : 					AssignTacticalMove(move);

	push	edi
	push	ebp
	mov	ecx, esi
	call	?AssignTacticalMove@CvTacticalAI@@AAEXVCvTacticalMove@@@Z ; CvTacticalAI::AssignTacticalMove
$LN34@ProcessDom:
	mov	edx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+68]
	add	ebx, 8
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _it$[esp+76], ebx
	cmp	ebx, ecx
	jne	$LL35@ProcessDom
	pop	edi
	pop	ebp
$LN92@ProcessDom:

; 1751 : 				}
; 1752 : 			}
; 1753 : 		}
; 1754 : 	}
; 1755 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	pop	ebx
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 60					; 0000003cH
	ret	0
	npad	2
$LN96@ProcessDom:
	DD	$LN12@ProcessDom
	DD	$LN11@ProcessDom
	DD	$LN10@ProcessDom
	DD	$LN9@ProcessDom
	DD	$LN8@ProcessDom
	DD	$LN5@ProcessDom
	DD	$LN7@ProcessDom
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ProcessDominanceZones@CvTacticalAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strMoveName$220963[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ProcessDominanceZones@CvTacticalAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ProcessDominanceZones@CvTacticalAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ProcessDominanceZones@CvTacticalAI@@AAEXXZ ENDP	; CvTacticalAI::ProcessDominanceZones
PUBLIC	?Update@CvTacticalAI@@QAEXXZ			; CvTacticalAI::Update
; Function compile flags: /Ogtpy
;	COMDAT ?Update@CvTacticalAI@@QAEXXZ
_TEXT	SEGMENT
?Update@CvTacticalAI@@QAEXXZ PROC			; CvTacticalAI::Update, COMDAT
; _this$ = ecx

; 425  : {

	push	esi
	mov	esi, ecx

; 426  : 	AI_PERF_FORMAT("AI-perf.csv", ("Tactical AI, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 427  : 
; 428  : 	FindTacticalTargets();

	call	?FindTacticalTargets@CvTacticalAI@@AAEXXZ ; CvTacticalAI::FindTacticalTargets

; 429  : 
; 430  : 	// Loop through each dominance zone assigning moves
; 431  : 	ProcessDominanceZones();

	mov	ecx, esi
	pop	esi
	jmp	?ProcessDominanceZones@CvTacticalAI@@AAEXXZ ; CvTacticalAI::ProcessDominanceZones
?Update@CvTacticalAI@@QAEXXZ ENDP			; CvTacticalAI::Update
_TEXT	ENDS
END
