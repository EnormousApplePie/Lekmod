; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvGrandStrategyAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG223864 DB	'AIGrandStrategyType', 00H
$SG223865 DB	'AIGrandStrategy_Flavors', 00H
$SG223866 DB	'AIGrandStrategyType', 00H
$SG223867 DB	'AIGrandStrategy_Yields', 00H
	ORG $+1
$SG223868 DB	'AIGrandStrategyType', 00H
$SG223869 DB	'AIGrandStrategy_FlavorMods', 00H
	ORG $+1
$SG224198 DB	'AIGRANDSTRATEGY_CONQUEST', 00H
	ORG $+3
$SG224201 DB	'AIGRANDSTRATEGY_CULTURE', 00H
$SG224204 DB	'AIGRANDSTRATEGY_UNITED_NATIONS', 00H
	ORG $+1
$SG224207 DB	'AIGRANDSTRATEGY_SPACESHIP', 00H
	ORG $+2
$SG224208 DB	'Grand Strategy AI: GS rand roll.', 00H
	ORG $+3
$SG224324 DB	'VICTORY_DOMINATION', 00H
	ORG $+1
$SG224395 DB	'VICTORY_CULTURAL', 00H
	ORG $+3
$SG224400 DB	'FLAVOR_CULTURE', 00H
	ORG $+1
$SG224430 DB	'VICTORY_DIPLOMATIC', 00H
	ORG $+1
$SG224441 DB	'FLAVOR_DIPLOMACY', 00H
	ORG $+3
$SG224485 DB	'VICTORY_SPACE_RACE', 00H
	ORG $+1
$SG224490 DB	'FLAVOR_SCIENCE', 00H
	ORG $+1
$SG224493 DB	'PROJECT_APOLLO_PROGRAM', 00H
	ORG $+1
$SG224811 DB	'AIGRANDSTRATEGY_CONQUEST', 00H
	ORG $+3
$SG224814 DB	'AIGRANDSTRATEGY_CULTURE', 00H
$SG224817 DB	'AIGRANDSTRATEGY_UNITED_NATIONS', 00H
	ORG $+1
$SG224820 DB	'AIGRANDSTRATEGY_SPACESHIP', 00H
	ORG $+2
$SG224860 DB	'VICTORY_CULTURAL', 00H
	ORG $+3
$SG224878 DB	'VICTORY_DIPLOMATIC', 00H
	ORG $+1
$SG224902 DB	'VICTORY_SPACE_RACE', 00H
	ORG $+1
$SG224907 DB	'PROJECT_APOLLO_PROGRAM', 00H
	ORG $+1
$SG224928 DB	'.csv', 00H
	ORG $+3
$SG224929 DB	'GrandStrategyAI_Log_', 00H
	ORG $+3
$SG224931 DB	'GrandStrategyAI_Log.csv', 00H
$SG224938 DB	'%03d, ', 00H
	ORG $+1
$SG224940 DB	', ', 00H
	ORG $+1
$SG224944 DB	'Unknown Type', 00H
	ORG $+3
$SG224946 DB	'*** %s, %d, %d', 00H
	ORG $+1
$SG224948 DB	'%s, %d, %d', 00H
	ORG $+1
$SG224967 DB	'.csv', 00H
	ORG $+3
$SG224968 DB	'GrandStrategyAI_Guess_Log_', 00H
	ORG $+1
$SG224970 DB	'GrandStrategyAI_Guess_Log.csv', 00H
	ORG $+2
$SG224978 DB	'%03d, ', 00H
	ORG $+1
$SG224980 DB	', ', 00H
	ORG $+1
$SG224984 DB	'Unknown Strategy', 00H
	ORG $+3
$SG224986 DB	'*** %s, %d', 00H
	ORG $+1
$SG224988 DB	'%s, %d', 00H
	ORG $+1
$SG224992 DB	', ', 00H
	ORG $+1
$SG224999 DB	'Positive', 00H
	ORG $+3
$SG225001 DB	'Likely', 00H
	ORG $+1
$SG225003 DB	'Unsure', 00H
	ORG $+1
$SG225005 DB	'XXX', 00H
$SG225007 DB	', ', 00H
	ORG $+1
$SG225008 DB	'%03d, ', 00H
	ORG $+1
$SG225010 DB	', ', 00H
	ORG $+1
$SG225011 DB	'NO_GRAND_STRATEGY, %d', 00H
	ORG $+2
$SG225015 DB	', ', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?GetFlavorValue@CvAIGrandStrategyXMLEntry@@QBEHH@Z ; CvAIGrandStrategyXMLEntry::GetFlavorValue
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
;	COMDAT ?GetFlavorValue@CvAIGrandStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFlavorValue@CvAIGrandStrategyXMLEntry@@QBEHH@Z PROC	; CvAIGrandStrategyXMLEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 56   : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 57   : #endif
; 58   : 	FAssertMsg(i > -1, "Index out of bounds");
; 59   : 	return m_piFlavorValue ? m_piFlavorValue[i] : -1;

	mov	eax, DWORD PTR [ecx+260]
	test	eax, eax
	je	SHORT $LN3@GetFlavorV
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 60   : }

	ret	4
$LN3@GetFlavorV:

; 56   : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 57   : #endif
; 58   : 	FAssertMsg(i > -1, "Index out of bounds");
; 59   : 	return m_piFlavorValue ? m_piFlavorValue[i] : -1;

	or	eax, -1

; 60   : }

	ret	4
?GetFlavorValue@CvAIGrandStrategyXMLEntry@@QBEHH@Z ENDP	; CvAIGrandStrategyXMLEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?GetSpecializationBoost@CvAIGrandStrategyXMLEntry@@QBEHW4YieldTypes@@@Z ; CvAIGrandStrategyXMLEntry::GetSpecializationBoost
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecializationBoost@CvAIGrandStrategyXMLEntry@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_eYield$ = 8						; size = 4
?GetSpecializationBoost@CvAIGrandStrategyXMLEntry@@QBEHW4YieldTypes@@@Z PROC ; CvAIGrandStrategyXMLEntry::GetSpecializationBoost, COMDAT
; _this$ = ecx

; 65   : 	FAssertMsg(eYield < NUM_YIELD_TYPES, "Index out of bounds");
; 66   : 	FAssertMsg(eYield > -1, "Index out of bounds");
; 67   : 	return m_piSpecializationBoost ? m_piSpecializationBoost[(int)eYield] : 0;

	mov	eax, DWORD PTR [ecx+264]
	test	eax, eax
	je	SHORT $LN3@GetSpecial
	mov	ecx, DWORD PTR _eYield$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 68   : }

	ret	4
$LN3@GetSpecial:

; 65   : 	FAssertMsg(eYield < NUM_YIELD_TYPES, "Index out of bounds");
; 66   : 	FAssertMsg(eYield > -1, "Index out of bounds");
; 67   : 	return m_piSpecializationBoost ? m_piSpecializationBoost[(int)eYield] : 0;

	xor	eax, eax

; 68   : }

	ret	4
?GetSpecializationBoost@CvAIGrandStrategyXMLEntry@@QBEHW4YieldTypes@@@Z ENDP ; CvAIGrandStrategyXMLEntry::GetSpecializationBoost
_TEXT	ENDS
PUBLIC	?GetFlavorModValue@CvAIGrandStrategyXMLEntry@@QBEHH@Z ; CvAIGrandStrategyXMLEntry::GetFlavorModValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlavorModValue@CvAIGrandStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFlavorModValue@CvAIGrandStrategyXMLEntry@@QBEHH@Z PROC ; CvAIGrandStrategyXMLEntry::GetFlavorModValue, COMDAT
; _this$ = ecx

; 78   : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 79   : #endif
; 80   : 	FAssertMsg(i > -1, "Index out of bounds");
; 81   : 	return m_piFlavorModValue ? m_piFlavorModValue[i] : 0;

	mov	eax, DWORD PTR [ecx+268]
	test	eax, eax
	je	SHORT $LN3@GetFlavorM
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 82   : }

	ret	4
$LN3@GetFlavorM:

; 78   : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 79   : #endif
; 80   : 	FAssertMsg(i > -1, "Index out of bounds");
; 81   : 	return m_piFlavorModValue ? m_piFlavorModValue[i] : 0;

	xor	eax, eax

; 82   : }

	ret	4
?GetFlavorModValue@CvAIGrandStrategyXMLEntry@@QBEHH@Z ENDP ; CvAIGrandStrategyXMLEntry::GetFlavorModValue
_TEXT	ENDS
PUBLIC	?GetAIGrandStrategyEntries@CvAIGrandStrategyXMLEntries@@QAEAAV?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@XZ ; CvAIGrandStrategyXMLEntries::GetAIGrandStrategyEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetAIGrandStrategyEntries@CvAIGrandStrategyXMLEntries@@QAEAAV?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetAIGrandStrategyEntries@CvAIGrandStrategyXMLEntries@@QAEAAV?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@XZ PROC ; CvAIGrandStrategyXMLEntries::GetAIGrandStrategyEntries, COMDAT
; _this$ = ecx

; 103  : {

	mov	eax, ecx

; 104  : 	return m_paAIGrandStrategyEntries;
; 105  : }

	ret	0
?GetAIGrandStrategyEntries@CvAIGrandStrategyXMLEntries@@QAEAAV?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@XZ ENDP ; CvAIGrandStrategyXMLEntries::GetAIGrandStrategyEntries
_TEXT	ENDS
PUBLIC	??0CvGrandStrategyAI@@QAE@XZ			; CvGrandStrategyAI::CvGrandStrategyAI
; Function compile flags: /Ogtpy
;	COMDAT ??0CvGrandStrategyAI@@QAE@XZ
_TEXT	SEGMENT
??0CvGrandStrategyAI@@QAE@XZ PROC			; CvGrandStrategyAI::CvGrandStrategyAI, COMDAT
; _this$ = ecx

; 154  : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx

; 155  : }

	ret	0
??0CvGrandStrategyAI@@QAE@XZ ENDP			; CvGrandStrategyAI::CvGrandStrategyAI
_TEXT	ENDS
PUBLIC	??1CvGrandStrategyAI@@QAE@XZ			; CvGrandStrategyAI::~CvGrandStrategyAI
; Function compile flags: /Ogtpy
;	COMDAT ??1CvGrandStrategyAI@@QAE@XZ
_TEXT	SEGMENT
??1CvGrandStrategyAI@@QAE@XZ PROC			; CvGrandStrategyAI::~CvGrandStrategyAI, COMDAT
; _this$ = ecx

; 160  : }

	ret	0
??1CvGrandStrategyAI@@QAE@XZ ENDP			; CvGrandStrategyAI::~CvGrandStrategyAI
_TEXT	ENDS
PUBLIC	?GetPlayer@CvGrandStrategyAI@@QAEPAVCvPlayer@@XZ ; CvGrandStrategyAI::GetPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayer@CvGrandStrategyAI@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
?GetPlayer@CvGrandStrategyAI@@QAEPAVCvPlayer@@XZ PROC	; CvGrandStrategyAI::GetPlayer, COMDAT
; _this$ = ecx

; 273  : 	return m_pPlayer;

	mov	eax, DWORD PTR [ecx]

; 274  : }

	ret	0
?GetPlayer@CvGrandStrategyAI@@QAEPAVCvPlayer@@XZ ENDP	; CvGrandStrategyAI::GetPlayer
_TEXT	ENDS
PUBLIC	?GetAIGrandStrategies@CvGrandStrategyAI@@QAEPAVCvAIGrandStrategyXMLEntries@@XZ ; CvGrandStrategyAI::GetAIGrandStrategies
; Function compile flags: /Ogtpy
;	COMDAT ?GetAIGrandStrategies@CvGrandStrategyAI@@QAEPAVCvAIGrandStrategyXMLEntries@@XZ
_TEXT	SEGMENT
?GetAIGrandStrategies@CvGrandStrategyAI@@QAEPAVCvAIGrandStrategyXMLEntries@@XZ PROC ; CvGrandStrategyAI::GetAIGrandStrategies, COMDAT
; _this$ = ecx

; 283  : 	return m_pAIGrandStrategies;

	mov	eax, DWORD PTR [ecx+4]

; 284  : }

	ret	0
?GetAIGrandStrategies@CvGrandStrategyAI@@QAEPAVCvAIGrandStrategyXMLEntries@@XZ ENDP ; CvGrandStrategyAI::GetAIGrandStrategies
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
;	COMDAT ?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ
_TEXT	SEGMENT
?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ PROC ; CvGrandStrategyAI::GetActiveGrandStrategy, COMDAT
; _this$ = ecx

; 860  : 	return m_eActiveGrandStrategy;

	mov	eax, DWORD PTR [ecx+12]

; 861  : }

	ret	0
?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ENDP ; CvGrandStrategyAI::GetActiveGrandStrategy
_TEXT	ENDS
PUBLIC	?GetNumTurnsSinceActiveSet@CvGrandStrategyAI@@QBEHXZ ; CvGrandStrategyAI::GetNumTurnsSinceActiveSet
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTurnsSinceActiveSet@CvGrandStrategyAI@@QBEHXZ
_TEXT	SEGMENT
?GetNumTurnsSinceActiveSet@CvGrandStrategyAI@@QBEHXZ PROC ; CvGrandStrategyAI::GetNumTurnsSinceActiveSet, COMDAT
; _this$ = ecx

; 877  : 	return m_iNumTurnsSinceActiveSet;

	mov	eax, DWORD PTR [ecx+8]

; 878  : }

	ret	0
?GetNumTurnsSinceActiveSet@CvGrandStrategyAI@@QBEHXZ ENDP ; CvGrandStrategyAI::GetNumTurnsSinceActiveSet
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
PUBLIC	?SetNumTurnsSinceActiveSet@CvGrandStrategyAI@@QAEXH@Z ; CvGrandStrategyAI::SetNumTurnsSinceActiveSet
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
;	COMDAT ?SetNumTurnsSinceActiveSet@CvGrandStrategyAI@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetNumTurnsSinceActiveSet@CvGrandStrategyAI@@QAEXH@Z PROC ; CvGrandStrategyAI::SetNumTurnsSinceActiveSet, COMDAT
; _this$ = ecx

; 883  : 	m_iNumTurnsSinceActiveSet = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 884  : 	FAssert(m_iNumTurnsSinceActiveSet >= 0);
; 885  : }

	ret	4
?SetNumTurnsSinceActiveSet@CvGrandStrategyAI@@QAEXH@Z ENDP ; CvGrandStrategyAI::SetNumTurnsSinceActiveSet
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?ChangeNumTurnsSinceActiveSet@CvGrandStrategyAI@@QAEXH@Z ; CvGrandStrategyAI::ChangeNumTurnsSinceActiveSet
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumTurnsSinceActiveSet@CvGrandStrategyAI@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeNumTurnsSinceActiveSet@CvGrandStrategyAI@@QAEXH@Z PROC ; CvGrandStrategyAI::ChangeNumTurnsSinceActiveSet, COMDAT
; _this$ = ecx

; 890  : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@ChangeNumT

; 891  : 	{
; 892  : 		m_iNumTurnsSinceActiveSet += iChange;

	add	DWORD PTR [ecx+8], eax
$LN1@ChangeNumT:

; 893  : 	}
; 894  : 
; 895  : 	FAssert(m_iNumTurnsSinceActiveSet >= 0);
; 896  : }

	ret	4
?ChangeNumTurnsSinceActiveSet@CvGrandStrategyAI@@QAEXH@Z ENDP ; CvGrandStrategyAI::ChangeNumTurnsSinceActiveSet
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	?GetGrandStrategyPriority@CvGrandStrategyAI@@QBEHW4AIGrandStrategyTypes@@@Z ; CvGrandStrategyAI::GetGrandStrategyPriority
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
;	COMDAT ?GetGrandStrategyPriority@CvGrandStrategyAI@@QBEHW4AIGrandStrategyTypes@@@Z
_TEXT	SEGMENT
_eGrandStrategy$ = 8					; size = 4
?GetGrandStrategyPriority@CvGrandStrategyAI@@QBEHW4AIGrandStrategyTypes@@@Z PROC ; CvGrandStrategyAI::GetGrandStrategyPriority, COMDAT
; _this$ = ecx

; 901  : 	FAssert(eGrandStrategy != NO_AIGRANDSTRATEGY);
; 902  : 	return m_paiGrandStrategyPriority[eGrandStrategy];

	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _eGrandStrategy$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 903  : }

	ret	4
?GetGrandStrategyPriority@CvGrandStrategyAI@@QBEHW4AIGrandStrategyTypes@@@Z ENDP ; CvGrandStrategyAI::GetGrandStrategyPriority
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?SetGrandStrategyPriority@CvGrandStrategyAI@@QAEXW4AIGrandStrategyTypes@@H@Z ; CvGrandStrategyAI::SetGrandStrategyPriority
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
;	COMDAT ?SetGrandStrategyPriority@CvGrandStrategyAI@@QAEXW4AIGrandStrategyTypes@@H@Z
_TEXT	SEGMENT
_eGrandStrategy$ = 8					; size = 4
_iValue$ = 12						; size = 4
?SetGrandStrategyPriority@CvGrandStrategyAI@@QAEXW4AIGrandStrategyTypes@@H@Z PROC ; CvGrandStrategyAI::SetGrandStrategyPriority, COMDAT
; _this$ = ecx

; 908  : 	FAssert(eGrandStrategy != NO_AIGRANDSTRATEGY);
; 909  : 	m_paiGrandStrategyPriority[eGrandStrategy] = iValue;

	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _iValue$[esp-4]
	mov	edx, DWORD PTR _eGrandStrategy$[esp-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 910  : }

	ret	8
?SetGrandStrategyPriority@CvGrandStrategyAI@@QAEXW4AIGrandStrategyTypes@@H@Z ENDP ; CvGrandStrategyAI::SetGrandStrategyPriority
_TEXT	ENDS
PUBLIC	?ChangeGrandStrategyPriority@CvGrandStrategyAI@@QAEXW4AIGrandStrategyTypes@@H@Z ; CvGrandStrategyAI::ChangeGrandStrategyPriority
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeGrandStrategyPriority@CvGrandStrategyAI@@QAEXW4AIGrandStrategyTypes@@H@Z
_TEXT	SEGMENT
_eGrandStrategy$ = 8					; size = 4
_iChange$ = 12						; size = 4
?ChangeGrandStrategyPriority@CvGrandStrategyAI@@QAEXW4AIGrandStrategyTypes@@H@Z PROC ; CvGrandStrategyAI::ChangeGrandStrategyPriority, COMDAT
; _this$ = ecx

; 915  : 	FAssert(eGrandStrategy != NO_AIGRANDSTRATEGY);
; 916  : 
; 917  : 	if(iChange != 0)

	mov	edx, DWORD PTR _iChange$[esp-4]
	test	edx, edx
	je	SHORT $LN1@ChangeGran

; 918  : 	{
; 919  : 		m_paiGrandStrategyPriority[eGrandStrategy] += iChange;

	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _eGrandStrategy$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]
$LN1@ChangeGran:

; 920  : 	}
; 921  : }

	ret	8
?ChangeGrandStrategyPriority@CvGrandStrategyAI@@QAEXW4AIGrandStrategyTypes@@H@Z ENDP ; CvGrandStrategyAI::ChangeGrandStrategyPriority
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetGuessOtherPlayerActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@W4PlayerTypes@@@Z ; CvGrandStrategyAI::GetGuessOtherPlayerActiveGrandStrategy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
;	COMDAT ?GetGuessOtherPlayerActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetGuessOtherPlayerActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@W4PlayerTypes@@@Z PROC ; CvGrandStrategyAI::GetGuessOtherPlayerActiveGrandStrategy, COMDAT
; _this$ = ecx

; 1074 : 	FAssert(ePlayer < MAX_MAJOR_CIVS);
; 1075 : 	return (AIGrandStrategyTypes) m_eGuessOtherPlayerActiveGrandStrategy[ePlayer];

	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _ePlayer$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1076 : }

	ret	4
?GetGuessOtherPlayerActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@W4PlayerTypes@@@Z ENDP ; CvGrandStrategyAI::GetGuessOtherPlayerActiveGrandStrategy
_TEXT	ENDS
PUBLIC	?GetGuessOtherPlayerActiveGrandStrategyConfidence@CvGrandStrategyAI@@QBE?AW4GuessConfidenceTypes@@W4PlayerTypes@@@Z ; CvGrandStrategyAI::GetGuessOtherPlayerActiveGrandStrategyConfidence
; Function compile flags: /Ogtpy
;	COMDAT ?GetGuessOtherPlayerActiveGrandStrategyConfidence@CvGrandStrategyAI@@QBE?AW4GuessConfidenceTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetGuessOtherPlayerActiveGrandStrategyConfidence@CvGrandStrategyAI@@QBE?AW4GuessConfidenceTypes@@W4PlayerTypes@@@Z PROC ; CvGrandStrategyAI::GetGuessOtherPlayerActiveGrandStrategyConfidence, COMDAT
; _this$ = ecx

; 1081 : 	FAssert(ePlayer < MAX_MAJOR_CIVS);
; 1082 : 	return (GuessConfidenceTypes) m_eGuessOtherPlayerActiveGrandStrategyConfidence[ePlayer];

	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR _ePlayer$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1083 : }

	ret	4
?GetGuessOtherPlayerActiveGrandStrategyConfidence@CvGrandStrategyAI@@QBE?AW4GuessConfidenceTypes@@W4PlayerTypes@@@Z ENDP ; CvGrandStrategyAI::GetGuessOtherPlayerActiveGrandStrategyConfidence
_TEXT	ENDS
PUBLIC	?SetGuessOtherPlayerActiveGrandStrategy@CvGrandStrategyAI@@QAEXW4PlayerTypes@@W4AIGrandStrategyTypes@@W4GuessConfidenceTypes@@@Z ; CvGrandStrategyAI::SetGuessOtherPlayerActiveGrandStrategy
; Function compile flags: /Ogtpy
;	COMDAT ?SetGuessOtherPlayerActiveGrandStrategy@CvGrandStrategyAI@@QAEXW4PlayerTypes@@W4AIGrandStrategyTypes@@W4GuessConfidenceTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eGrandStrategy$ = 12					; size = 4
_eGuessConfidence$ = 16					; size = 4
?SetGuessOtherPlayerActiveGrandStrategy@CvGrandStrategyAI@@QAEXW4PlayerTypes@@W4AIGrandStrategyTypes@@W4GuessConfidenceTypes@@@Z PROC ; CvGrandStrategyAI::SetGuessOtherPlayerActiveGrandStrategy, COMDAT
; _this$ = ecx

; 1088 : 	FAssert(ePlayer < MAX_MAJOR_CIVS);
; 1089 : 	m_eGuessOtherPlayerActiveGrandStrategy[ePlayer] = eGrandStrategy;

	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _ePlayer$[esp-4]
	push	esi
	mov	esi, DWORD PTR _eGrandStrategy$[esp]
	mov	DWORD PTR [edx+eax*4], esi

; 1090 : 	m_eGuessOtherPlayerActiveGrandStrategyConfidence[ePlayer] = eGuessConfidence;

	mov	ecx, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _eGuessConfidence$[esp]
	mov	DWORD PTR [ecx+eax*4], edx
	pop	esi

; 1091 : }

	ret	12					; 0000000cH
?SetGuessOtherPlayerActiveGrandStrategy@CvGrandStrategyAI@@QAEXW4PlayerTypes@@W4AIGrandStrategyTypes@@W4GuessConfidenceTypes@@@Z ENDP ; CvGrandStrategyAI::SetGuessOtherPlayerActiveGrandStrategy
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$00@@QAEAAHI@Z			; BaseVector<int,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@H$00@@QAEAAHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$00@@QAEAAHI@Z PROC			; BaseVector<int,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@H$00@@QAEAAHI@Z ENDP			; BaseVector<int,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$00@@QBEABHI@Z			; BaseVector<int,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@H$00@@QBEABHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$00@@QBEABHI@Z PROC			; BaseVector<int,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 137  : 	};

	ret	4
??A?$BaseVector@H$00@@QBEABHI@Z ENDP			; BaseVector<int,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvAIGrandStrategyXMLEntry@@I@Z ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvAIGrandStrategyXMLEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvAIGrandStrategyXMLEntry@@I@Z PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvAIGrandStrategyXMLEntry@@I@Z ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@H@@QAE@HPAH@Z			; ArrayWrapper<int>::ArrayWrapper<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??0?$ArrayWrapper@H@@QAE@HPAH@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@H@@QAE@HPAH@Z PROC			; ArrayWrapper<int>::ArrayWrapper<int>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@H@@QAE@HPAH@Z ENDP			; ArrayWrapper<int>::ArrayWrapper<int>
_TEXT	ENDS
PUBLIC	??1?$BaseVector@H$00@@QAE@XZ			; BaseVector<int,1>::~BaseVector<int,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@H$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@H$00@@QAE@XZ PROC			; BaseVector<int,1>::~BaseVector<int,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@H$00@@QAE@XZ ENDP			; BaseVector<int,1>::~BaseVector<int,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@H$00@@IAE@XZ			; BaseVector<int,1>::BaseVector<int,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@H$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@H$00@@IAE@XZ PROC			; BaseVector<int,1>::BaseVector<int,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@H$00@@IAE@XZ ENDP			; BaseVector<int,1>::BaseVector<int,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@H$00@@IAEXPAHI@Z		; BaseVector<int,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@H$00@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@H$00@@IAEXPAHI@Z PROC		; BaseVector<int,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@H$00@@IAEXPAHI@Z ENDP		; BaseVector<int,1>::Destroy
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvAIGrandStrategyXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvAIGrandStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvAIGrandStrategyXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvAIGrandStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvAIGrandStrategyXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvAIGrandStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAE@XZ ; std::allocator<CvAIGrandStrategyXMLEntry *>::allocator<CvAIGrandStrategyXMLEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAE@XZ PROC ; std::allocator<CvAIGrandStrategyXMLEntry *>::allocator<CvAIGrandStrategyXMLEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAE@XZ ENDP ; std::allocator<CvAIGrandStrategyXMLEntry *>::allocator<CvAIGrandStrategyXMLEntry *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEABQAVCvAIGrandStrategyXMLEntry@@XZ ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEABQAVCvAIGrandStrategyXMLEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEABQAVCvAIGrandStrategyXMLEntry@@XZ PROC ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEABQAVCvAIGrandStrategyXMLEntry@@XZ ENDP ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator==
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEPAHI@Z ; FStaticVector<int,5,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEPAHI@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEPAHI@Z PROC ; FStaticVector<int,5,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 5
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 5
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEPAHI@Z ENDP ; FStaticVector<int,5,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXPAHI@Z ; FStaticVector<int,5,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXPAHI@Z PROC ; FStaticVector<int,5,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXPAHI@Z ENDP ; FStaticVector<int,5,1,297,0>::Free
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$04$00@@XZ ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$04$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$04$00@@XZ PROC ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$04$00@@XZ ENDP ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$04$00@@XZ ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$04$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$04$00@@XZ PROC ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$04$00@@XZ ENDP ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$04$00@@QAE@XZ ; CvWeightedVector<int,5,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$04$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@H$04$00@@QAE@XZ PROC ; CvWeightedVector<int,5,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@H$04$00@@QAE@XZ ENDP ; CvWeightedVector<int,5,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T226459 = -80						; size = 28
$T226458 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T226459[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T226458[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T226459[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T226458[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T226458[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T226458[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T226458[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T226459[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T226458[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvAIGrandStrategyXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvAIGrandStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvAIGrandStrategyXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvAIGrandStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvAIGrandStrategyXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvAIGrandStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvAIGrandStrategyXMLEntry *>::allocator<CvAIGrandStrategyXMLEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvAIGrandStrategyXMLEntry *>::allocator<CvAIGrandStrategyXMLEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvAIGrandStrategyXMLEntry *>::allocator<CvAIGrandStrategyXMLEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAEXPAPAVCvAIGrandStrategyXMLEntry@@I@Z ; std::allocator<CvAIGrandStrategyXMLEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAEXPAPAVCvAIGrandStrategyXMLEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAEXPAPAVCvAIGrandStrategyXMLEntry@@I@Z PROC ; std::allocator<CvAIGrandStrategyXMLEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAEXPAPAVCvAIGrandStrategyXMLEntry@@I@Z ENDP ; std::allocator<CvAIGrandStrategyXMLEntry *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvAIGrandStrategyXMLEntry@@@Z ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvAIGrandStrategyXMLEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvAIGrandStrategyXMLEntry@@@Z PROC ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvAIGrandStrategyXMLEntry@@@Z ENDP ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z PROC ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 5
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 5
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$04$00@@QAE@ABU01@@Z ; CvWeightedVector<int,5,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$04$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@H$04$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<int,5,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@H$04$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<int,5,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QBEIXZ ; std::allocator<CvAIGrandStrategyXMLEntry *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QBEIXZ PROC ; std::allocator<CvAIGrandStrategyXMLEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvAIGrandStrategyXMLEntry *>::max_size
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvAIGrandStrategyXMLEntry@@@@YAXAAPAVCvAIGrandStrategyXMLEntry@@@Z ; SAFE_DELETE<CvAIGrandStrategyXMLEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvAIGrandStrategyXMLEntry@@@@YAXAAPAVCvAIGrandStrategyXMLEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvAIGrandStrategyXMLEntry@@@@YAXAAPAVCvAIGrandStrategyXMLEntry@@@Z PROC ; SAFE_DELETE<CvAIGrandStrategyXMLEntry>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvAIGrandStrategyXMLEntry@@@@YAXAAPAVCvAIGrandStrategyXMLEntry@@@Z ENDP ; SAFE_DELETE<CvAIGrandStrategyXMLEntry>
_TEXT	ENDS
PUBLIC	??$?6W4AIGrandStrategyTypes@@@FDataStream@@QAEAAV0@ABW4AIGrandStrategyTypes@@@Z ; FDataStream::operator<<<enum AIGrandStrategyTypes>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6W4AIGrandStrategyTypes@@@FDataStream@@QAEAAV0@ABW4AIGrandStrategyTypes@@@Z
_TEXT	SEGMENT
$T226528 = 8						; size = 4
_kData$ = 8						; size = 4
??$?6W4AIGrandStrategyTypes@@@FDataStream@@QAEAAV0@ABW4AIGrandStrategyTypes@@@Z PROC ; FDataStream::operator<<<enum AIGrandStrategyTypes>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR $T226528[esp]
	mov	DWORD PTR $T226528[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6W4AIGrandStrategyTypes@@@FDataStream@@QAEAAV0@ABW4AIGrandStrategyTypes@@@Z ENDP ; FDataStream::operator<<<enum AIGrandStrategyTypes>
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvAIGrandStrategyXMLEntry@@@std@@YAPAPAVCvAIGrandStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvAIGrandStrategyXMLEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvAIGrandStrategyXMLEntry@@@std@@YAPAPAVCvAIGrandStrategyXMLEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T226544 = -12						; size = 12
$T226548 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvAIGrandStrategyXMLEntry@@@std@@YAPAPAVCvAIGrandStrategyXMLEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvAIGrandStrategyXMLEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T226548[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T226544[esp+16]
	mov	DWORD PTR $T226548[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T226544[esp+16]
	push	ecx
	mov	DWORD PTR $T226544[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvAIGrandStrategyXMLEntry@@@std@@YAPAPAVCvAIGrandStrategyXMLEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvAIGrandStrategyXMLEntry *>
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QAEPAHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ?getArray@?$ArrayWrapper@H@@QAEPAHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QAEPAHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 382  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 383  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QAEPAHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QBEPBHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@H@@QBEPBHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QBEPBHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 386  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 387  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QBEPBHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@H@@QBEHXZ		; ArrayWrapper<int>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@H@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@H@@QBEHXZ PROC			; ArrayWrapper<int>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@H@@QBEHXZ ENDP			; ArrayWrapper<int>::getCount
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvAIGrandStrategyXMLEntry@@0@Z ; std::_Iter_random<CvAIGrandStrategyXMLEntry * *,CvAIGrandStrategyXMLEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvAIGrandStrategyXMLEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvAIGrandStrategyXMLEntry@@0@Z PROC ; std::_Iter_random<CvAIGrandStrategyXMLEntry * *,CvAIGrandStrategyXMLEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvAIGrandStrategyXMLEntry@@0@Z ENDP ; std::_Iter_random<CvAIGrandStrategyXMLEntry * *,CvAIGrandStrategyXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvAIGrandStrategyXMLEntry@@0@Z ; std::_Ptr_cat<CvAIGrandStrategyXMLEntry * *,CvAIGrandStrategyXMLEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvAIGrandStrategyXMLEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvAIGrandStrategyXMLEntry@@0@Z PROC ; std::_Ptr_cat<CvAIGrandStrategyXMLEntry * *,CvAIGrandStrategyXMLEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvAIGrandStrategyXMLEntry@@0@Z ENDP ; std::_Ptr_cat<CvAIGrandStrategyXMLEntry * *,CvAIGrandStrategyXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvAIGrandStrategyXMLEntry * *,CvAIGrandStrategyXMLEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvAIGrandStrategyXMLEntry * *,CvAIGrandStrategyXMLEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvAIGrandStrategyXMLEntry * *,CvAIGrandStrategyXMLEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvAIGrandStrategyXMLEntry@@0AAV?$allocator@PAVCvAIGrandStrategyXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvAIGrandStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvAIGrandStrategyXMLEntry@@0AAV?$allocator@PAVCvAIGrandStrategyXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvAIGrandStrategyXMLEntry@@0AAV?$allocator@PAVCvAIGrandStrategyXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvAIGrandStrategyXMLEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvAIGrandStrategyXMLEntry@@0AAV?$allocator@PAVCvAIGrandStrategyXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvAIGrandStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@H$04$00@@QBE_NABU01@@Z ; CvWeightedVector<int,5,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@H$04$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@H$04$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<int,5,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@H$04$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<int,5,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::pair<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>::pair<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z PROC ; std::pair<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>::pair<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ENDP ; std::pair<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>::pair<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$04$00@@@Z ; std::_Dist_type<CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$04$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$04$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$04$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::swap<CvWeightedVector<int,5,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z PROC ; std::swap<CvWeightedVector<int,5,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ENDP ; std::swap<CvWeightedVector<int,5,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap
	npad	1
$LL3@Push_heap:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::_Iter_random<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getNumFlavorTypes@CvGlobals@@QAEHXZ		; CvGlobals::getNumFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFlavorTypes@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFlavorTypes@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFlavorTypes, COMDAT
; _this$ = ecx

; 804  : 		return m_iNumFlavorTypes;

	mov	eax, DWORD PTR [ecx+1764]

; 805  : 	}

	ret	0
?getNumFlavorTypes@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFlavorTypes
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_NUM_TURNS_STRATEGY_MUST_BE_ACTIVE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_NUM_TURNS_STRATEGY_MUST_BE_ACTIVE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_NUM_TURNS_STRATEGY_MUST_BE_ACTIVE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_NUM_TURNS_STRATEGY_MUST_BE_ACTIVE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_NUM_TURNS_STRATEGY_MUST_BE_ACTIVE, COMDAT
; _this$ = ecx

; 957  : 		return m_iAI_GRAND_STRATEGY_NUM_TURNS_STRATEGY_MUST_BE_ACTIVE;

	mov	eax, DWORD PTR [ecx+1892]

; 958  : 	}

	ret	0
?getAI_GRAND_STRATEGY_NUM_TURNS_STRATEGY_MUST_BE_ACTIVE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_NUM_TURNS_STRATEGY_MUST_BE_ACTIVE
_TEXT	ENDS
PUBLIC	?getAI_GS_RAND_ROLL@CvGlobals@@QAEHXZ		; CvGlobals::getAI_GS_RAND_ROLL
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GS_RAND_ROLL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GS_RAND_ROLL@CvGlobals@@QAEHXZ PROC		; CvGlobals::getAI_GS_RAND_ROLL, COMDAT
; _this$ = ecx

; 961  : 		return m_iAI_GS_RAND_ROLL;

	mov	eax, DWORD PTR [ecx+1896]

; 962  : 	}

	ret	0
?getAI_GS_RAND_ROLL@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getAI_GS_RAND_ROLL
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_CURRENT_STRATEGY_WEIGHT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_CURRENT_STRATEGY_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_CURRENT_STRATEGY_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_CURRENT_STRATEGY_WEIGHT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_CURRENT_STRATEGY_WEIGHT, COMDAT
; _this$ = ecx

; 965  : 		return m_iAI_GRAND_STRATEGY_CURRENT_STRATEGY_WEIGHT;

	mov	eax, DWORD PTR [ecx+1900]

; 966  : 	}

	ret	0
?getAI_GRAND_STRATEGY_CURRENT_STRATEGY_WEIGHT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_CURRENT_STRATEGY_WEIGHT
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_GUESS_NO_CLUE_WEIGHT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_GUESS_NO_CLUE_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_GUESS_NO_CLUE_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_GUESS_NO_CLUE_WEIGHT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_GUESS_NO_CLUE_WEIGHT, COMDAT
; _this$ = ecx

; 969  : 		return m_iAI_GRAND_STRATEGY_GUESS_NO_CLUE_WEIGHT;

	mov	eax, DWORD PTR [ecx+1904]

; 970  : 	}

	ret	0
?getAI_GRAND_STRATEGY_GUESS_NO_CLUE_WEIGHT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_GUESS_NO_CLUE_WEIGHT
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_GUESS_POSITIVE_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_GUESS_POSITIVE_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_GUESS_POSITIVE_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_GUESS_POSITIVE_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_GUESS_POSITIVE_THRESHOLD, COMDAT
; _this$ = ecx

; 973  : 		return m_iAI_GRAND_STRATEGY_GUESS_POSITIVE_THRESHOLD;

	mov	eax, DWORD PTR [ecx+1908]

; 974  : 	}

	ret	0
?getAI_GRAND_STRATEGY_GUESS_POSITIVE_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_GUESS_POSITIVE_THRESHOLD
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_GUESS_LIKELY_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_GUESS_LIKELY_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_GUESS_LIKELY_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_GUESS_LIKELY_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_GUESS_LIKELY_THRESHOLD, COMDAT
; _this$ = ecx

; 977  : 		return m_iAI_GRAND_STRATEGY_GUESS_LIKELY_THRESHOLD;

	mov	eax, DWORD PTR [ecx+1912]

; 978  : 	}

	ret	0
?getAI_GRAND_STRATEGY_GUESS_LIKELY_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_GUESS_LIKELY_THRESHOLD
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_OTHER_PLAYERS_GS_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_OTHER_PLAYERS_GS_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_OTHER_PLAYERS_GS_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_OTHER_PLAYERS_GS_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_OTHER_PLAYERS_GS_MULTIPLIER, COMDAT
; _this$ = ecx

; 981  : 		return m_iAI_GRAND_STRATEGY_OTHER_PLAYERS_GS_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+1916]

; 982  : 	}

	ret	0
?getAI_GRAND_STRATEGY_OTHER_PLAYERS_GS_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_OTHER_PLAYERS_GS_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getAI_GS_CONQUEST_NOBODY_MET_FIRST_TURN@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GS_CONQUEST_NOBODY_MET_FIRST_TURN
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GS_CONQUEST_NOBODY_MET_FIRST_TURN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GS_CONQUEST_NOBODY_MET_FIRST_TURN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GS_CONQUEST_NOBODY_MET_FIRST_TURN, COMDAT
; _this$ = ecx

; 985  : 		return m_iAI_GS_CONQUEST_NOBODY_MET_FIRST_TURN;

	mov	eax, DWORD PTR [ecx+1920]

; 986  : 	}

	ret	0
?getAI_GS_CONQUEST_NOBODY_MET_FIRST_TURN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GS_CONQUEST_NOBODY_MET_FIRST_TURN
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_CONQUEST_NOBODY_MET_WEIGHT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_NOBODY_MET_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_CONQUEST_NOBODY_MET_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_CONQUEST_NOBODY_MET_WEIGHT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_NOBODY_MET_WEIGHT, COMDAT
; _this$ = ecx

; 989  : 		return m_iAI_GRAND_STRATEGY_CONQUEST_NOBODY_MET_WEIGHT;

	mov	eax, DWORD PTR [ecx+1924]

; 990  : 	}

	ret	0
?getAI_GRAND_STRATEGY_CONQUEST_NOBODY_MET_WEIGHT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_NOBODY_MET_WEIGHT
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_CONQUEST_AT_WAR_WEIGHT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_AT_WAR_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_CONQUEST_AT_WAR_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_CONQUEST_AT_WAR_WEIGHT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_AT_WAR_WEIGHT, COMDAT
; _this$ = ecx

; 993  : 		return m_iAI_GRAND_STRATEGY_CONQUEST_AT_WAR_WEIGHT;

	mov	eax, DWORD PTR [ecx+1928]

; 994  : 	}

	ret	0
?getAI_GRAND_STRATEGY_CONQUEST_AT_WAR_WEIGHT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_AT_WAR_WEIGHT
_TEXT	ENDS
PUBLIC	?getAI_GS_CONQUEST_MILITARY_STRENGTH_FIRST_TURN@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GS_CONQUEST_MILITARY_STRENGTH_FIRST_TURN
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GS_CONQUEST_MILITARY_STRENGTH_FIRST_TURN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GS_CONQUEST_MILITARY_STRENGTH_FIRST_TURN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GS_CONQUEST_MILITARY_STRENGTH_FIRST_TURN, COMDAT
; _this$ = ecx

; 997  : 		return m_iAI_GS_CONQUEST_MILITARY_STRENGTH_FIRST_TURN;

	mov	eax, DWORD PTR [ecx+1932]

; 998  : 	}

	ret	0
?getAI_GS_CONQUEST_MILITARY_STRENGTH_FIRST_TURN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GS_CONQUEST_MILITARY_STRENGTH_FIRST_TURN
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER, COMDAT
; _this$ = ecx

; 1001 : 		return m_iAI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+1936]

; 1002 : 	}

	ret	0
?getAI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_CONQUEST_CRAMPED_WEIGHT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_CRAMPED_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_CONQUEST_CRAMPED_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_CONQUEST_CRAMPED_WEIGHT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_CRAMPED_WEIGHT, COMDAT
; _this$ = ecx

; 1005 : 		return m_iAI_GRAND_STRATEGY_CONQUEST_CRAMPED_WEIGHT;

	mov	eax, DWORD PTR [ecx+1940]

; 1006 : 	}

	ret	0
?getAI_GRAND_STRATEGY_CONQUEST_CRAMPED_WEIGHT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_CRAMPED_WEIGHT
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_ATTACKED@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_ATTACKED
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_ATTACKED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_ATTACKED@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_ATTACKED, COMDAT
; _this$ = ecx

; 1009 : 		return m_iAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_ATTACKED;

	mov	eax, DWORD PTR [ecx+1944]

; 1010 : 	}

	ret	0
?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_ATTACKED@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_ATTACKED
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_CONQUERED@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_CONQUERED
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_CONQUERED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_CONQUERED@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_CONQUERED, COMDAT
; _this$ = ecx

; 1013 : 		return m_iAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_CONQUERED;

	mov	eax, DWORD PTR [ecx+1948]

; 1014 : 	}

	ret	0
?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_CONQUERED@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_CONQUERED
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_ATTACKED@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_ATTACKED
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_ATTACKED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_ATTACKED@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_ATTACKED, COMDAT
; _this$ = ecx

; 1017 : 		return m_iAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_ATTACKED;

	mov	eax, DWORD PTR [ecx+1952]

; 1018 : 	}

	ret	0
?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_ATTACKED@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_ATTACKED
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_CONQUERED@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_CONQUERED
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_CONQUERED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_CONQUERED@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_CONQUERED, COMDAT
; _this$ = ecx

; 1021 : 		return m_iAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_CONQUERED;

	mov	eax, DWORD PTR [ecx+1956]

; 1022 : 	}

	ret	0
?getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_CONQUERED@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_CONQUERED
_TEXT	ENDS
PUBLIC	?getAI_GS_CULTURE_RATIO_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GS_CULTURE_RATIO_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GS_CULTURE_RATIO_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GS_CULTURE_RATIO_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GS_CULTURE_RATIO_MULTIPLIER, COMDAT
; _this$ = ecx

; 1025 : 		return m_iAI_GS_CULTURE_RATIO_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+1960]

; 1026 : 	}

	ret	0
?getAI_GS_CULTURE_RATIO_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GS_CULTURE_RATIO_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getAI_GS_TOURISM_RATIO_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GS_TOURISM_RATIO_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GS_TOURISM_RATIO_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GS_TOURISM_RATIO_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GS_TOURISM_RATIO_MULTIPLIER, COMDAT
; _this$ = ecx

; 1029 : 		return m_iAI_GS_TOURISM_RATIO_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+1964]

; 1030 : 	}

	ret	0
?getAI_GS_TOURISM_RATIO_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GS_TOURISM_RATIO_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getAI_GS_CULTURE_AHEAD_WEIGHT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GS_CULTURE_AHEAD_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GS_CULTURE_AHEAD_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GS_CULTURE_AHEAD_WEIGHT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_GS_CULTURE_AHEAD_WEIGHT, COMDAT
; _this$ = ecx

; 1033 : 		return m_iAI_GS_CULTURE_AHEAD_WEIGHT;

	mov	eax, DWORD PTR [ecx+1968]

; 1034 : 	}

	ret	0
?getAI_GS_CULTURE_AHEAD_WEIGHT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_GS_CULTURE_AHEAD_WEIGHT
_TEXT	ENDS
PUBLIC	?getAI_GS_CULTURE_TOURISM_AHEAD_WEIGHT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GS_CULTURE_TOURISM_AHEAD_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GS_CULTURE_TOURISM_AHEAD_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GS_CULTURE_TOURISM_AHEAD_WEIGHT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GS_CULTURE_TOURISM_AHEAD_WEIGHT, COMDAT
; _this$ = ecx

; 1037 : 		return m_iAI_GS_CULTURE_TOURISM_AHEAD_WEIGHT;

	mov	eax, DWORD PTR [ecx+1972]

; 1038 : 	}

	ret	0
?getAI_GS_CULTURE_TOURISM_AHEAD_WEIGHT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GS_CULTURE_TOURISM_AHEAD_WEIGHT
_TEXT	ENDS
PUBLIC	?getAI_GS_CULTURE_INFLUENTIAL_CIV_MOD@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GS_CULTURE_INFLUENTIAL_CIV_MOD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GS_CULTURE_INFLUENTIAL_CIV_MOD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GS_CULTURE_INFLUENTIAL_CIV_MOD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GS_CULTURE_INFLUENTIAL_CIV_MOD, COMDAT
; _this$ = ecx

; 1041 : 		return m_iAI_GS_CULTURE_INFLUENTIAL_CIV_MOD;

	mov	eax, DWORD PTR [ecx+1976]

; 1042 : 	}

	ret	0
?getAI_GS_CULTURE_INFLUENTIAL_CIV_MOD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GS_CULTURE_INFLUENTIAL_CIV_MOD
_TEXT	ENDS
PUBLIC	?getAI_GRAND_STRATEGY_UN_EACH_MINOR_ATTACKED_WEIGHT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GRAND_STRATEGY_UN_EACH_MINOR_ATTACKED_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GRAND_STRATEGY_UN_EACH_MINOR_ATTACKED_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GRAND_STRATEGY_UN_EACH_MINOR_ATTACKED_WEIGHT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GRAND_STRATEGY_UN_EACH_MINOR_ATTACKED_WEIGHT, COMDAT
; _this$ = ecx

; 1045 : 		return m_iAI_GRAND_STRATEGY_UN_EACH_MINOR_ATTACKED_WEIGHT;

	mov	eax, DWORD PTR [ecx+1980]

; 1046 : 	}

	ret	0
?getAI_GRAND_STRATEGY_UN_EACH_MINOR_ATTACKED_WEIGHT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GRAND_STRATEGY_UN_EACH_MINOR_ATTACKED_WEIGHT
_TEXT	ENDS
PUBLIC	?getAI_GS_UN_SECURED_VOTE_MOD@CvGlobals@@QAEHXZ	; CvGlobals::getAI_GS_UN_SECURED_VOTE_MOD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GS_UN_SECURED_VOTE_MOD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GS_UN_SECURED_VOTE_MOD@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_GS_UN_SECURED_VOTE_MOD, COMDAT
; _this$ = ecx

; 1049 : 		return m_iAI_GS_UN_SECURED_VOTE_MOD;

	mov	eax, DWORD PTR [ecx+1984]

; 1050 : 	}

	ret	0
?getAI_GS_UN_SECURED_VOTE_MOD@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_GS_UN_SECURED_VOTE_MOD
_TEXT	ENDS
PUBLIC	?getAI_GS_SS_HAS_APOLLO_PROGRAM@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GS_SS_HAS_APOLLO_PROGRAM
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GS_SS_HAS_APOLLO_PROGRAM@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GS_SS_HAS_APOLLO_PROGRAM@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_GS_SS_HAS_APOLLO_PROGRAM, COMDAT
; _this$ = ecx

; 1053 : 		return m_iAI_GS_SS_HAS_APOLLO_PROGRAM;

	mov	eax, DWORD PTR [ecx+1988]

; 1054 : 	}

	ret	0
?getAI_GS_SS_HAS_APOLLO_PROGRAM@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_GS_SS_HAS_APOLLO_PROGRAM
_TEXT	ENDS
PUBLIC	?getAI_GS_SS_TECH_PROGRESS_MOD@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GS_SS_TECH_PROGRESS_MOD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GS_SS_TECH_PROGRESS_MOD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GS_SS_TECH_PROGRESS_MOD@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_GS_SS_TECH_PROGRESS_MOD, COMDAT
; _this$ = ecx

; 1057 : 		return m_iAI_GS_SS_TECH_PROGRESS_MOD;

	mov	eax, DWORD PTR [ecx+1992]

; 1058 : 	}

	ret	0
?getAI_GS_SS_TECH_PROGRESS_MOD@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_GS_SS_TECH_PROGRESS_MOD
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?isAlive@CvTeam@@QBE_NXZ			; CvTeam::isAlive
; Function compile flags: /Ogtpy
;	COMDAT ?isAlive@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvTeam@@QBE_NXZ PROC				; CvTeam::isAlive, COMDAT
; _this$ = ecx

; 131  : 		return m_iAliveCount > 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx+12], eax
	setg	al

; 132  : 	}

	ret	0
?isAlive@CvTeam@@QBE_NXZ ENDP				; CvTeam::isAlive
_TEXT	ENDS
PUBLIC	?GetCityStateBonusModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetCityStateBonusModifier
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetCityStateBonusModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateBonusModifier@CvPlayerTraits@@QBEHXZ PROC	; CvPlayerTraits::GetCityStateBonusModifier, COMDAT
; _this$ = ecx

; 467  : 		return m_iCityStateBonusModifier;

	mov	eax, DWORD PTR [ecx+88]

; 468  : 	};

	ret	0
?GetCityStateBonusModifier@CvPlayerTraits@@QBEHXZ ENDP	; CvPlayerTraits::GetCityStateBonusModifier
_TEXT	ENDS
PUBLIC	?GetCityStateFriendshipModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetCityStateFriendshipModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateFriendshipModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateFriendshipModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetCityStateFriendshipModifier, COMDAT
; _this$ = ecx

; 471  : 		return m_iCityStateFriendshipModifier;

	mov	eax, DWORD PTR [ecx+92]

; 472  : 	};

	ret	0
?GetCityStateFriendshipModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetCityStateFriendshipModifier
_TEXT	ENDS
PUBLIC	?GetCityStateCombatModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetCityStateCombatModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateCombatModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateCombatModifier@CvPlayerTraits@@QBEHXZ PROC	; CvPlayerTraits::GetCityStateCombatModifier, COMDAT
; _this$ = ecx

; 475  : 		return m_iCityStateCombatModifier;

	mov	eax, DWORD PTR [ecx+96]

; 476  : 	};

	ret	0
?GetCityStateCombatModifier@CvPlayerTraits@@QBEHXZ ENDP	; CvPlayerTraits::GetCityStateCombatModifier
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvAIGrandStrategyXMLEntry@@6B@		; CvAIGrandStrategyXMLEntry::`vftable'
PUBLIC	??1CvAIGrandStrategyXMLEntry@@UAE@XZ		; CvAIGrandStrategyXMLEntry::~CvAIGrandStrategyXMLEntry
PUBLIC	??_R4CvAIGrandStrategyXMLEntry@@6B@		; CvAIGrandStrategyXMLEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIGrandStrategyXMLEntry@@@8		; CvAIGrandStrategyXMLEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvAIGrandStrategyXMLEntry@@8		; CvAIGrandStrategyXMLEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIGrandStrategyXMLEntry@@8		; CvAIGrandStrategyXMLEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIGrandStrategyXMLEntry@@8	; CvAIGrandStrategyXMLEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvAIGrandStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvAIGrandStrategyXMLEntry::CacheResults
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
EXTRN	??_ECvAIGrandStrategyXMLEntry@@UAEPAXI@Z:PROC	; CvAIGrandStrategyXMLEntry::`vector deleting destructor'
;	COMDAT ??_R2CvBaseInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvAIGrandStrategyXMLEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIGrandStrategyXMLEntry@@8 DD FLAT:??_R0?AVCvAIGrandStrategyXMLEntry@@@8 ; CvAIGrandStrategyXMLEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIGrandStrategyXMLEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIGrandStrategyXMLEntry@@8
rdata$r	SEGMENT
??_R2CvAIGrandStrategyXMLEntry@@8 DD FLAT:??_R1A@?0A@EA@CvAIGrandStrategyXMLEntry@@8 ; CvAIGrandStrategyXMLEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIGrandStrategyXMLEntry@@8
rdata$r	SEGMENT
??_R3CvAIGrandStrategyXMLEntry@@8 DD 00H		; CvAIGrandStrategyXMLEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvAIGrandStrategyXMLEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIGrandStrategyXMLEntry@@@8
_DATA	SEGMENT
??_R0?AVCvAIGrandStrategyXMLEntry@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIGrandStrategyXMLEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIGrandStrategyXMLEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIGrandStrategyXMLEntry@@6B@
rdata$r	SEGMENT
??_R4CvAIGrandStrategyXMLEntry@@6B@ DD 00H		; CvAIGrandStrategyXMLEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIGrandStrategyXMLEntry@@@8
	DD	FLAT:??_R3CvAIGrandStrategyXMLEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIGrandStrategyXMLEntry@@6B@
CONST	SEGMENT
??_7CvAIGrandStrategyXMLEntry@@6B@ DD FLAT:??_R4CvAIGrandStrategyXMLEntry@@6B@ ; CvAIGrandStrategyXMLEntry::`vftable'
	DD	FLAT:?CacheResults@CvAIGrandStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvAIGrandStrategyXMLEntry@@UAEPAXI@Z
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
CONST	ENDS
;	COMDAT ??1CvAIGrandStrategyXMLEntry@@UAE@XZ
_TEXT	SEGMENT
??1CvAIGrandStrategyXMLEntry@@UAE@XZ PROC		; CvAIGrandStrategyXMLEntry::~CvAIGrandStrategyXMLEntry, COMDAT
; _this$ = ecx

; 28   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIGrandStrategyXMLEntry@@6B@

; 29   : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	eax, DWORD PTR [esi+260]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+260], 0

; 30   : 	SAFE_DELETE_ARRAY(m_piSpecializationBoost);

	mov	ecx, DWORD PTR [esi+264]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+264], 0

; 31   : 	SAFE_DELETE_ARRAY(m_piFlavorModValue);

	mov	edx, DWORD PTR [esi+268]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+268], 0

; 32   : }

	mov	ecx, esi
	pop	esi
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvAIGrandStrategyXMLEntry@@UAE@XZ ENDP		; CvAIGrandStrategyXMLEntry::~CvAIGrandStrategyXMLEntry
_TEXT	ENDS
EXTRN	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z:PROC ; CvDatabaseUtility::SetYields
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvAIGrandStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvAIGrandStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvAIGrandStrategyXMLEntry::CacheResults, COMDAT
; _this$ = ecx

; 36   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kResults$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _kUtility$[esp]
	push	esi
	push	ebx
	push	eax
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul
	pop	esi
	pop	ebx

; 46   : }

	ret	8
$LN1@CacheResul:
	push	edi

; 37   : 		return false;
; 38   : 
; 39   : 	//Arrays
; 40   : 	const char* szType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 41   : 	kUtility.SetFlavors(m_piFlavorValue, "AIGrandStrategy_Flavors", "AIGrandStrategyType", szType);

	push	0
	mov	edi, eax
	push	edi
	push	OFFSET $SG223864
	push	OFFSET $SG223865
	lea	ecx, DWORD PTR [esi+260]
	push	ecx
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 42   : 	kUtility.SetYields(m_piSpecializationBoost, "AIGrandStrategy_Yields", "AIGrandStrategyType", szType);

	push	edi
	push	OFFSET $SG223866
	push	OFFSET $SG223867
	lea	edx, DWORD PTR [esi+264]
	push	edx
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 43   : 	kUtility.SetFlavors(m_piFlavorModValue, "AIGrandStrategy_FlavorMods", "AIGrandStrategyType", szType);

	push	0
	push	edi
	push	OFFSET $SG223868
	push	OFFSET $SG223869
	add	esi, 268				; 0000010cH
	push	esi
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors
	pop	edi
	pop	esi

; 44   : 
; 45   : 	return true;

	mov	al, 1
	pop	ebx

; 46   : }

	ret	8
?CacheResults@CvAIGrandStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvAIGrandStrategyXMLEntry::CacheResults
_TEXT	ENDS
PUBLIC	?GetNumAIGrandStrategies@CvAIGrandStrategyXMLEntries@@QAEHXZ ; CvAIGrandStrategyXMLEntries::GetNumAIGrandStrategies
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumAIGrandStrategies@CvAIGrandStrategyXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumAIGrandStrategies@CvAIGrandStrategyXMLEntries@@QAEHXZ PROC ; CvAIGrandStrategyXMLEntries::GetNumAIGrandStrategies, COMDAT
; _this$ = ecx

; 114  : 	return m_paAIGrandStrategyEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 115  : }

	ret	0
?GetNumAIGrandStrategies@CvAIGrandStrategyXMLEntries@@QAEHXZ ENDP ; CvAIGrandStrategyXMLEntries::GetNumAIGrandStrategies
_TEXT	ENDS
PUBLIC	?GetEntry@CvAIGrandStrategyXMLEntries@@QAEPAVCvAIGrandStrategyXMLEntry@@H@Z ; CvAIGrandStrategyXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvAIGrandStrategyXMLEntries@@QAEPAVCvAIGrandStrategyXMLEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvAIGrandStrategyXMLEntries@@QAEPAVCvAIGrandStrategyXMLEntry@@H@Z PROC ; CvAIGrandStrategyXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 135  : 	return m_paAIGrandStrategyEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 136  : }

	ret	4
?GetEntry@CvAIGrandStrategyXMLEntries@@QAEPAVCvAIGrandStrategyXMLEntry@@H@Z ENDP ; CvAIGrandStrategyXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	?Uninit@CvGrandStrategyAI@@QAEXXZ		; CvGrandStrategyAI::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvGrandStrategyAI@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvGrandStrategyAI@@QAEXXZ PROC			; CvGrandStrategyAI::Uninit, COMDAT
; _this$ = ecx

; 185  : {

	push	esi
	mov	esi, ecx

; 186  : 	SAFE_DELETE_ARRAY(m_paiGrandStrategyPriority);

	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+16], 0

; 187  : 	SAFE_DELETE_ARRAY(m_eGuessOtherPlayerActiveGrandStrategy);

	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+20], 0

; 188  : 	SAFE_DELETE_ARRAY(m_eGuessOtherPlayerActiveGrandStrategyConfidence);

	mov	edx, DWORD PTR [esi+24]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+24], 0
	pop	esi

; 189  : }

	ret	0
?Uninit@CvGrandStrategyAI@@QAEXXZ ENDP			; CvGrandStrategyAI::Uninit
_TEXT	ENDS
PUBLIC	?Reset@CvGrandStrategyAI@@QAEXXZ		; CvGrandStrategyAI::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvGrandStrategyAI@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvGrandStrategyAI@@QAEXXZ PROC			; CvGrandStrategyAI::Reset, COMDAT
; _this$ = ecx

; 194  : #ifdef AUI_WARNING_FIXES
; 195  : 	uint iI;
; 196  : #else
; 197  : 	int iI;
; 198  : #endif
; 199  : 
; 200  : 	m_iNumTurnsSinceActiveSet = 0;
; 201  : 
; 202  : 	m_eActiveGrandStrategy = NO_AIGRANDSTRATEGY;
; 203  : 
; 204  : 	for(iI = 0; iI < m_pAIGrandStrategies->GetNumAIGrandStrategies(); iI++)

	mov	edx, DWORD PTR [ecx+4]
	push	esi
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], -1
	mov	esi, DWORD PTR [edx+8]
	sub	esi, DWORD PTR [edx+4]
	xor	eax, eax
	test	esi, -4					; fffffffcH
	jle	SHORT $LN4@Reset
$LL6@Reset:

; 205  : 	{
; 206  : 		m_paiGrandStrategyPriority[iI] = -1;

	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+eax*4], -1
	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [edx+8]
	sub	esi, DWORD PTR [edx+4]
	inc	eax
	sar	esi, 2
	cmp	eax, esi
	jl	SHORT $LL6@Reset
$LN4@Reset:

; 207  : 	}
; 208  : 
; 209  : 	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)

	xor	eax, eax
	pop	esi
$LL3@Reset:

; 210  : 	{
; 211  : 		m_eGuessOtherPlayerActiveGrandStrategy[iI] = NO_AIGRANDSTRATEGY;

	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+edx], -1

; 212  : 		m_eGuessOtherPlayerActiveGrandStrategyConfidence[iI] = NO_GUESS_CONFIDENCE_TYPE;

	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+edx], -1
	add	eax, 4
	cmp	eax, 88					; 00000058H
	jl	SHORT $LL3@Reset

; 213  : 	}
; 214  : }

	ret	0
?Reset@CvGrandStrategyAI@@QAEXXZ ENDP			; CvGrandStrategyAI::Reset
_TEXT	ENDS
PUBLIC	?GetBaseGrandStrategyPriority@CvGrandStrategyAI@@QAEHW4AIGrandStrategyTypes@@@Z ; CvGrandStrategyAI::GetBaseGrandStrategyPriority
EXTRN	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z:PROC ; CvFlavorManager::GetPersonalityIndividualFlavor
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?GetBaseGrandStrategyPriority@CvGrandStrategyAI@@QAEHW4AIGrandStrategyTypes@@@Z
_TEXT	SEGMENT
_pGrandStrategy$ = 8					; size = 4
_eGrandStrategy$ = 8					; size = 4
?GetBaseGrandStrategyPriority@CvGrandStrategyAI@@QAEHW4AIGrandStrategyTypes@@@Z PROC ; CvGrandStrategyAI::GetBaseGrandStrategyPriority, COMDAT
; _this$ = ecx

; 824  : 	CvAIGrandStrategyXMLEntry* pGrandStrategy = GetAIGrandStrategies()->GetEntry(eGrandStrategy);

	mov	edx, DWORD PTR _eGrandStrategy$[esp-4]
	push	ebx
	mov	ebx, ecx
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	ebp
	push	esi

; 825  : 
; 826  : 	int iPriority = 0;
; 827  : 
; 828  : 	// Personality effect on Priority
; 829  : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	esi, esi
	xor	ebp, ebp
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	mov	DWORD PTR _pGrandStrategy$[esp+8], eax
	jle	SHORT $LN28@GetBaseGra
	push	edi
$LL29@GetBaseGra:

; 830  : 	{
; 831  : 		if(pGrandStrategy->GetFlavorValue(iFlavorLoop) != 0)

	mov	ecx, DWORD PTR _pGrandStrategy$[esp+12]
	mov	eax, DWORD PTR [ecx+260]
	test	eax, eax
	je	SHORT $LN21@GetBaseGra
	mov	edi, DWORD PTR [eax+esi*4]
	test	edi, edi
	je	SHORT $LN3@GetBaseGra

; 832  : 		{
; 833  : 			iPriority += (pGrandStrategy->GetFlavorValue(iFlavorLoop) * GetPlayer()->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes) iFlavorLoop));

	jmp	SHORT $LN22@GetBaseGra
$LN21@GetBaseGra:
	or	edi, -1
$LN22@GetBaseGra:
	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	imul	eax, edi
	add	ebp, eax
$LN3@GetBaseGra:
	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL29@GetBaseGra
	pop	edi
$LN28@GetBaseGra:
	pop	esi

; 834  : 		}
; 835  : 	}
; 836  : 
; 837  : 	return iPriority;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 838  : }

	ret	4
?GetBaseGrandStrategyPriority@CvGrandStrategyAI@@QAEHW4AIGrandStrategyTypes@@@Z ENDP ; CvGrandStrategyAI::GetBaseGrandStrategyPriority
_TEXT	ENDS
PUBLIC	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
; Function compile flags: /Ogtpy
;	COMDAT ?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z
_TEXT	SEGMENT
$T227012 = -4						; size = 4
_iModdedFlavor$224514 = 8				; size = 4
_eFlavorType$ = 8					; size = 4
?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy, COMDAT
; _this$ = ecx

; 846  : {

	push	ecx

; 847  : 	if(m_eActiveGrandStrategy != NO_AIGRANDSTRATEGY)

	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, -1
	je	SHORT $LN1@GetPersona

; 848  : 	{
; 849  : 		CvAIGrandStrategyXMLEntry* pGrandStrategy = GetAIGrandStrategies()->GetEntry(m_eActiveGrandStrategy);

	mov	edx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 850  : 		int iModdedFlavor = pGrandStrategy->GetFlavorModValue(eFlavorType) + m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavorType);

	mov	eax, DWORD PTR [eax+268]
	mov	edx, DWORD PTR _eFlavorType$[esp]
	push	esi
	test	eax, eax
	je	SHORT $LN12@GetPersona
	mov	esi, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN13@GetPersona
$LN12@GetPersona:
	xor	esi, esi
$LN13@GetPersona:
	mov	ecx, DWORD PTR [ecx]
	push	edx
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	add	eax, esi
	mov	DWORD PTR _iModdedFlavor$224514[esp+4], eax

; 851  : 		iModdedFlavor = max(0,iModdedFlavor);

	test	eax, eax
	mov	DWORD PTR $T227012[esp+8], 0
	pop	esi
	lea	eax, DWORD PTR _iModdedFlavor$224514[esp]
	jg	SHORT $LN17@GetPersona
	lea	eax, DWORD PTR $T227012[esp+4]
$LN17@GetPersona:

; 852  : 		return iModdedFlavor;

	mov	eax, DWORD PTR [eax]

; 855  : }

	pop	ecx
	ret	4
$LN1@GetPersona:

; 853  : 	}
; 854  : 	return m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavorType);

	mov	eax, DWORD PTR _eFlavorType$[esp]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor

; 855  : }

	pop	ecx
	ret	4
?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ENDP ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
_TEXT	ENDS
PUBLIC	?SetActiveGrandStrategy@CvGrandStrategyAI@@QAEXW4AIGrandStrategyTypes@@@Z ; CvGrandStrategyAI::SetActiveGrandStrategy
; Function compile flags: /Ogtpy
;	COMDAT ?SetActiveGrandStrategy@CvGrandStrategyAI@@QAEXW4AIGrandStrategyTypes@@@Z
_TEXT	SEGMENT
_eGrandStrategy$ = 8					; size = 4
?SetActiveGrandStrategy@CvGrandStrategyAI@@QAEXW4AIGrandStrategyTypes@@@Z PROC ; CvGrandStrategyAI::SetActiveGrandStrategy, COMDAT
; _this$ = ecx

; 866  : 	if(eGrandStrategy != NO_AIGRANDSTRATEGY)

	mov	eax, DWORD PTR _eGrandStrategy$[esp-4]
	cmp	eax, -1
	je	SHORT $LN4@SetActiveG

; 867  : 	{
; 868  : 		m_eActiveGrandStrategy = eGrandStrategy;

	mov	DWORD PTR [ecx+12], eax

; 869  : 
; 870  : 		SetNumTurnsSinceActiveSet(0);

	mov	DWORD PTR [ecx+8], 0
$LN4@SetActiveG:

; 871  : 	}
; 872  : }

	ret	4
?SetActiveGrandStrategy@CvGrandStrategyAI@@QAEXW4AIGrandStrategyTypes@@@Z ENDP ; CvGrandStrategyAI::SetActiveGrandStrategy
_TEXT	ENDS
PUBLIC	?GetGuessOtherPlayerConquestPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@H@Z ; CvGrandStrategyAI::GetGuessOtherPlayerConquestPriority
EXTRN	?GetOtherPlayerNumMajorsConquered@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetOtherPlayerNumMajorsConquered
EXTRN	?GetOtherPlayerNumMajorsAttacked@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetOtherPlayerNumMajorsAttacked
EXTRN	?GetOtherPlayerNumMinorsConquered@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetOtherPlayerNumMinorsConquered
EXTRN	?GetOtherPlayerNumMinorsAttacked@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetOtherPlayerNumMinorsAttacked
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?GetMilitaryMight@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetMilitaryMight
; Function compile flags: /Ogtpy
;	COMDAT ?GetGuessOtherPlayerConquestPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iWorldMilitaryAverage$ = 12				; size = 4
?GetGuessOtherPlayerConquestPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@H@Z PROC ; CvGrandStrategyAI::GetGuessOtherPlayerConquestPriority, COMDAT
; _this$ = ecx

; 1095 : {

	push	ebx
	push	ebp

; 1096 : 	int iConquestPriority = 0;
; 1097 : 
; 1098 : 	// Compare their Military to the world average; Possible range is 100 to -100 (but will typically be around -20 to 20)
; 1099 : 	if(iWorldMilitaryAverage > 0)

	mov	ebp, DWORD PTR _iWorldMilitaryAverage$[esp+4]
	push	esi
	xor	esi, esi
	push	edi
	mov	edi, DWORD PTR _ePlayer$[esp+12]
	mov	ebx, ecx
	test	ebp, ebp
	jle	SHORT $LN1@GetGuessOt

; 1100 : 	{
; 1101 : 		iConquestPriority += (GET_PLAYER(ePlayer).GetMilitaryMight() - iWorldMilitaryAverage) * /*100*/ GC.getAI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER() / iWorldMilitaryAverage;

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1936
	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetMilitaryMight@CvPlayer@@QBEHXZ	; CvPlayer::GetMilitaryMight
	sub	eax, ebp
	imul	eax, esi
	cdq
	idiv	ebp
	mov	esi, eax
$LN1@GetGuessOt:

; 1102 : 	}
; 1103 : 
; 1104 : 	// Minors attacked
; 1105 : 	iConquestPriority += (GetPlayer()->GetDiplomacyAI()->GetOtherPlayerNumMinorsAttacked(ePlayer) * /*5*/ GC.getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_ATTACKED());

	mov	ecx, DWORD PTR [ebx]
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1944
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetOtherPlayerNumMinorsAttacked@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetOtherPlayerNumMinorsAttacked
	imul	eax, ebp

; 1106 : 
; 1107 : 	// Minors Conquered
; 1108 : 	iConquestPriority += (GetPlayer()->GetDiplomacyAI()->GetOtherPlayerNumMinorsConquered(ePlayer) * /*10*/ GC.getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_CONQUERED());

	mov	ecx, DWORD PTR [ebx]
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1948
	push	edi
	add	esi, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetOtherPlayerNumMinorsConquered@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetOtherPlayerNumMinorsConquered
	imul	eax, ebp

; 1109 : 
; 1110 : 	// Majors attacked
; 1111 : 	iConquestPriority += (GetPlayer()->GetDiplomacyAI()->GetOtherPlayerNumMajorsAttacked(ePlayer) * /*10*/ GC.getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_ATTACKED());

	mov	ecx, DWORD PTR [ebx]
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1952
	push	edi
	add	esi, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetOtherPlayerNumMajorsAttacked@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetOtherPlayerNumMajorsAttacked
	imul	eax, ebp

; 1112 : 
; 1113 : 	// Majors Conquered
; 1114 : 	iConquestPriority += (GetPlayer()->GetDiplomacyAI()->GetOtherPlayerNumMajorsConquered(ePlayer) * /*15*/ GC.getAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_CONQUERED());

	mov	ecx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1956
	push	edi
	add	esi, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetOtherPlayerNumMajorsConquered@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetOtherPlayerNumMajorsConquered
	imul	eax, ebx
	pop	edi
	add	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1115 : 
; 1116 : 	return iConquestPriority;
; 1117 : }

	ret	8
?GetGuessOtherPlayerConquestPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@H@Z ENDP ; CvGrandStrategyAI::GetGuessOtherPlayerConquestPriority
_TEXT	ENDS
PUBLIC	?GetGuessOtherPlayerCulturePriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@HH@Z ; CvGrandStrategyAI::GetGuessOtherPlayerCulturePriority
EXTRN	?GetTourism@CvPlayerCulture@@QAEHXZ:PROC	; CvPlayerCulture::GetTourism
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetJONSCultureEverGenerated
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
; Function compile flags: /Ogtpy
;	COMDAT ?GetGuessOtherPlayerCulturePriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@HH@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iWorldCultureAverage$ = 12				; size = 4
_iWorldTourismAverage$ = 16				; size = 4
?GetGuessOtherPlayerCulturePriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@HH@Z PROC ; CvGrandStrategyAI::GetGuessOtherPlayerCulturePriority, COMDAT
; _this$ = ecx

; 1122 : 	VictoryTypes eVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_CULTURAL", true);

	push	1
	push	OFFSET $SG224860
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1123 : 
; 1124 : 	// If Culture Victory isn't even available then don't bother with anything
; 1125 : 	if(eVictory == NO_VICTORY)

	cmp	eax, -1
	jne	SHORT $LN9@GetGuessOt@2

; 1126 : 	{
; 1127 : 		return -100;

	mov	eax, -100				; ffffff9cH

; 1163 : }

	ret	12					; 0000000cH
$LN9@GetGuessOt@2:
	push	ebp
	push	esi

; 1128 : 	}
; 1129 : 
; 1130 : 	int iCulturePriority = 0;
; 1131 : 	int iRatio;
; 1132 : 
; 1133 : 	// Compare their Culture to the world average; Possible range is 75 to -75
; 1134 : 	if(iWorldCultureAverage > 0)

	mov	esi, DWORD PTR _ePlayer$[esp+4]
	push	edi
	mov	edi, DWORD PTR _iWorldCultureAverage$[esp+8]
	xor	ebp, ebp
	test	edi, edi
	jle	SHORT $LN8@GetGuessOt@2

; 1135 : 	{
; 1136 : 		iRatio = (GET_PLAYER(ePlayer).GetJONSCultureEverGenerated() - iWorldCultureAverage) * /*75*/ GC.getAI_GS_CULTURE_RATIO_MULTIPLIER() / iWorldCultureAverage;

	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1960
	call	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ ; CvPlayer::GetJONSCultureEverGenerated
	sub	eax, edi
	imul	eax, ebx
	cdq
	idiv	edi

; 1137 : 		if (iRatio > GC.getAI_GS_CULTURE_RATIO_MULTIPLIER())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1960
	pop	ebx
	cmp	eax, ecx

; 1138 : 		{
; 1139 : 			iCulturePriority += GC.getAI_GS_CULTURE_RATIO_MULTIPLIER();

	jg	SHORT $LN36@GetGuessOt@2

; 1140 : 		}
; 1141 : 		else if (iRatio < -GC.getAI_GS_CULTURE_RATIO_MULTIPLIER())

	mov	edx, ecx
	neg	edx
	cmp	eax, edx
	jge	SHORT $LN5@GetGuessOt@2

; 1142 : 		{
; 1143 : 			iCulturePriority += -GC.getAI_GS_CULTURE_RATIO_MULTIPLIER();

	neg	ecx
$LN36@GetGuessOt@2:
	mov	ebp, ecx
$LN5@GetGuessOt@2:

; 1144 : 		}
; 1145 : 		iCulturePriority += iRatio;

	add	ebp, eax
$LN8@GetGuessOt@2:

; 1146 : 	}
; 1147 : 
; 1148 : 	// Compare their Tourism to the world average; Possible range is 75 to -75
; 1149 : 	if(iWorldTourismAverage > 0)

	mov	edi, DWORD PTR _iWorldTourismAverage$[esp+8]
	test	edi, edi
	jle	SHORT $LN4@GetGuessOt@2

; 1150 : 	{
; 1151 : 		iRatio = (GET_PLAYER(ePlayer).GetCulture()->GetTourism() - iWorldTourismAverage) * /*75*/ GC.getAI_GS_TOURISM_RATIO_MULTIPLIER() / iWorldTourismAverage;

	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1964
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetTourism@CvPlayerCulture@@QAEHXZ	; CvPlayerCulture::GetTourism
	sub	eax, edi
	imul	eax, esi
	cdq
	idiv	edi

; 1152 : 		if (iRatio > GC.getAI_GS_TOURISM_RATIO_MULTIPLIER())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1964
	cmp	eax, ecx
	jle	SHORT $LN3@GetGuessOt@2

; 1153 : 		{
; 1154 : 			iCulturePriority += GC.getAI_GS_TOURISM_RATIO_MULTIPLIER();

	add	ebp, ecx
	pop	edi

; 1159 : 		}
; 1160 : 		iCulturePriority += iRatio;	}

	add	ebp, eax
	pop	esi

; 1161 : 
; 1162 : 	return iCulturePriority;

	mov	eax, ebp
	pop	ebp

; 1163 : }

	ret	12					; 0000000cH
$LN3@GetGuessOt@2:

; 1155 : 		}
; 1156 : 		else if (iRatio < -GC.getAI_GS_TOURISM_RATIO_MULTIPLIER())

	mov	edx, ecx
	neg	edx
	cmp	eax, edx
	jge	SHORT $LN1@GetGuessOt@2

; 1157 : 		{
; 1158 : 			iCulturePriority += -GC.getAI_GS_TOURISM_RATIO_MULTIPLIER();

	sub	ebp, ecx
$LN1@GetGuessOt@2:

; 1159 : 		}
; 1160 : 		iCulturePriority += iRatio;	}

	add	ebp, eax
$LN4@GetGuessOt@2:
	pop	edi
	pop	esi

; 1161 : 
; 1162 : 	return iCulturePriority;

	mov	eax, ebp
	pop	ebp

; 1163 : }

	ret	12					; 0000000cH
?GetGuessOtherPlayerCulturePriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@HH@Z ENDP ; CvGrandStrategyAI::GetGuessOtherPlayerCulturePriority
_TEXT	ENDS
PUBLIC	?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z ; CvGrandStrategyAI::LogGrandStrategies
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?getAIGrandStrategyInfo@CvGlobals@@QAEPAVCvAIGrandStrategyXMLEntry@@W4AIGrandStrategyTypes@@@Z:PROC ; CvGlobals::getAIGrandStrategyInfo
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?getNumAIGrandStrategyInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumAIGrandStrategyInfos
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$9
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
$T227150 = -236						; size = 28
$T227147 = -236						; size = 28
$T227145 = -236						; size = 28
_playerName$224922 = -208				; size = 28
_strBaseString$224920 = -180				; size = 28
_strLogName$224924 = -152				; size = 28
_strTemp$224921 = -124					; size = 28
_strOutBuf$224919 = -96					; size = 28
$T227146 = -68						; size = 28
_strDesc$224923 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_vModifiedGrandStrategyPriorities$ = 8			; size = 4
?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z PROC ; CvGrandStrategyAI::LogGrandStrategies, COMDAT
; _this$ = ecx

; 1244 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 224				; 000000e0H
	push	ebp
	mov	ebp, ecx

; 1245 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN8@LogGrandSt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN8@LogGrandSt

; 1246 : 	{
; 1247 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$224919[esp+240]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1248 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$224920[esp+240]
	mov	DWORD PTR __$EHRec$[esp+248], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1249 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$224921[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1250 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$224922[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1251 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$224923[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1252 : 		CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$224924[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1253 : 
; 1254 : 		// Find the name of this civ and city
; 1255 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [ebp]
	mov	BYTE PTR __$EHRec$[esp+248], 5
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$224922[esp+240]
	test	eax, eax
	je	SHORT $LN44@LogGrandSt
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN43@LogGrandSt
$LN44@LogGrandSt:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN43@LogGrandSt:
	push	ebx
	push	esi
	push	edi

; 1256 : 
; 1257 : 		// Open the log file
; 1258 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	SHORT $LN7@LogGrandSt

; 1259 : 		{
; 1260 : 			strLogName = "GrandStrategyAI_Log_" + playerName + ".csv";

	lea	eax, DWORD PTR _playerName$224922[esp+252]
	push	eax
	lea	ecx, DWORD PTR $T227145[esp+256]
	push	OFFSET $SG224929
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG224928
	push	eax
	lea	edx, DWORD PTR $T227146[esp+272]
	mov	bl, 6
	push	edx
	mov	BYTE PTR __$EHRec$[esp+284], bl
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+260], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$224924[esp+256]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T227146[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T227145[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1261 : 		}
; 1262 : 		else

	jmp	SHORT $LN49@LogGrandSt
$LN7@LogGrandSt:

; 1263 : 		{
; 1264 : 			strLogName = "GrandStrategyAI_Log.csv";

	push	OFFSET $SG224931
	lea	ecx, DWORD PTR _strLogName$224924[esp+256]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN49@LogGrandSt:

; 1265 : 		}
; 1266 : 
; 1267 : 		FILogFile* pLog;
; 1268 : 		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$224924[esp+252]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 1269 : 
; 1270 : 		AIGrandStrategyTypes eGrandStrategy;
; 1271 : 
; 1272 : 		// Loop through Grand Strategies
; 1273 : #ifdef AUI_WARNING_FIXES
; 1274 : 		for (uint iGrandStrategyLoop = 0; iGrandStrategyLoop < GC.getNumAIGrandStrategyInfos(); iGrandStrategyLoop++)
; 1275 : #else
; 1276 : 		for(int iGrandStrategyLoop = 0; iGrandStrategyLoop < GC.getNumAIGrandStrategyInfos(); iGrandStrategyLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	xor	esi, esi
	call	?getNumAIGrandStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumAIGrandStrategyInfos
	test	eax, eax
	jle	$LN3@LogGrandSt
	mov	ebx, DWORD PTR _vModifiedGrandStrategyPriorities$[esp+248]
	npad	6
$LL5@LogGrandSt:

; 1277 : #endif
; 1278 : 		{
; 1279 : 			// Get the leading info for this line
; 1280 : 			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224920[esp+256]
	push	OFFSET $SG224938
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1281 : 			strBaseString += playerName + ", ";

	push	OFFSET $SG224940
	lea	edx, DWORD PTR _playerName$224922[esp+268]
	push	edx
	lea	eax, DWORD PTR $T227147[esp+272]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224920[esp+256]
	mov	BYTE PTR __$EHRec$[esp+264], 8
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227147[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1282 : 
; 1283 : 			eGrandStrategy = (AIGrandStrategyTypes) iGrandStrategyLoop;
; 1284 : 
; 1285 : 			// GrandStrategy Info
; 1286 : 			CvAIGrandStrategyXMLEntry* pEntry = GC.getAIGrandStrategyInfo(eGrandStrategy);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAIGrandStrategyInfo@CvGlobals@@QAEPAVCvAIGrandStrategyXMLEntry@@W4AIGrandStrategyTypes@@@Z ; CvGlobals::getAIGrandStrategyInfo

; 1287 : 			const char* szAIGrandStrategyType = (pEntry != NULL)? pEntry->GetType() : "Unknown Type";

	test	eax, eax
	je	SHORT $LN11@LogGrandSt
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN12@LogGrandSt
$LN11@LogGrandSt:
	mov	eax, OFFSET $SG224944
$LN12@LogGrandSt:

; 1288 : 
; 1289 : 			if(GetActiveGrandStrategy() == eGrandStrategy)
; 1290 : 			{
; 1291 : 				strTemp.Format("*** %s, %d, %d", szAIGrandStrategyType, GetGrandStrategyPriority(eGrandStrategy), vModifiedGrandStrategyPriorities[eGrandStrategy]);

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR [ecx+esi*4]
	push	edx
	push	ecx
	push	eax
	lea	eax, DWORD PTR _strTemp$224921[esp+264]
	cmp	DWORD PTR [ebp+12], esi
	jne	SHORT $LN2@LogGrandSt
	push	OFFSET $SG224946

; 1292 : 			}
; 1293 : 			else

	jmp	SHORT $LN94@LogGrandSt
$LN2@LogGrandSt:

; 1294 : 			{
; 1295 : 				strTemp.Format("%s, %d, %d", szAIGrandStrategyType, GetGrandStrategyPriority(eGrandStrategy), vModifiedGrandStrategyPriorities[eGrandStrategy]);

	push	OFFSET $SG224948
$LN94@LogGrandSt:
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1296 : 			}
; 1297 : 			strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$224921[esp+252]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$224920[esp+256]
	push	edx
	lea	eax, DWORD PTR $T227150[esp+260]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+260], 9
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224919[esp+256]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T227150[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1298 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$224919[esp+252]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	edx
	add	esp, 8
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumAIGrandStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumAIGrandStrategyInfos
	cmp	esi, eax
	jl	$LL5@LogGrandSt
$LN3@LogGrandSt:

; 1299 : 		}
; 1300 : 	}

	lea	ecx, DWORD PTR _strLogName$224924[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strDesc$224923[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$224922[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$224921[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$224920[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$224919[esp+252]
	mov	DWORD PTR __$EHRec$[esp+260], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
$LN8@LogGrandSt:

; 1301 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+240]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 236				; 000000ecH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$224919[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$224920[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$224921[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$3:
	lea	ecx, DWORD PTR _playerName$224922[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$4:
	lea	ecx, DWORD PTR _strDesc$224923[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$5:
	lea	ecx, DWORD PTR _strLogName$224924[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$6:
	lea	ecx, DWORD PTR $T227145[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$7:
	lea	ecx, DWORD PTR $T227146[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$8:
	lea	ecx, DWORD PTR $T227147[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z$9:
	lea	ecx, DWORD PTR $T227150[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z ENDP ; CvGrandStrategyAI::LogGrandStrategies
PUBLIC	?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z ; CvGrandStrategyAI::LogGuessOtherPlayerGrandStrategy
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z DD 019930522H
	DD	012H
	DD	FLAT:__unwindtable$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$12
	DD	06H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$13
	DD	06H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$14
	DD	06H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$15
	DD	0fH
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$16
	DD	010H
	DD	FLAT:__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$17
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
xdata$x	ENDS
;	COMDAT ?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_pLog$224971 = -304					; size = 4
_this$ = -300						; size = 4
tv696 = -296						; size = 4
_strTemp$224959 = -292					; size = 28
_strBaseString$224958 = -264				; size = 28
$T227289 = -236						; size = 28
$T227286 = -236						; size = 28
$T227285 = -236						; size = 28
$T227282 = -236						; size = 28
_otherPlayerName$224961 = -208				; size = 28
$T227288 = -180						; size = 28
$T227284 = -180						; size = 28
$T227279 = -180						; size = 28
$T227277 = -180						; size = 28
_playerName$224960 = -152				; size = 28
_strOutBuf$224957 = -124				; size = 28
$T227287 = -96						; size = 28
$T227283 = -96						; size = 28
$T227278 = -96						; size = 28
_strLogName$224963 = -68				; size = 28
_strDesc$224962 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_vGrandStrategyPriorities$ = 8				; size = 4
_ePlayer$ = 12						; size = 4
?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z PROC ; CvGrandStrategyAI::LogGuessOtherPlayerGrandStrategy, COMDAT
; _this$ = ecx

; 1305 : {

	push	-1
	push	__ehhandler$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 292				; 00000124H
	push	esi
	mov	esi, ecx

; 1306 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+308], esi
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN15@LogGuessOt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN15@LogGuessOt

; 1307 : 	{
; 1308 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$224957[esp+308]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1309 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$224958[esp+308]
	mov	DWORD PTR __$EHRec$[esp+316], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1310 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$224959[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1311 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$224960[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1312 : 		CvString otherPlayerName;

	lea	ecx, DWORD PTR _otherPlayerName$224961[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1313 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$224962[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1314 : 		CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$224963[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 5
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1315 : 
; 1316 : 		// Find the name of this civ and city
; 1317 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+316], 6
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$224960[esp+308]
	test	eax, eax
	je	SHORT $LN62@LogGuessOt
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN61@LogGuessOt
$LN62@LogGuessOt:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN61@LogGuessOt:
	push	ebx
	push	ebp

; 1318 : 
; 1319 : 		// Open the log file
; 1320 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	test	al, al
	je	$LN14@LogGuessOt

; 1321 : 		{
; 1322 : 			strLogName = "GrandStrategyAI_Guess_Log_" + playerName + ".csv";

	lea	eax, DWORD PTR _playerName$224960[esp+316]
	push	eax
	lea	ecx, DWORD PTR $T227277[esp+320]
	push	OFFSET $SG224968
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG224967
	push	eax
	lea	edx, DWORD PTR $T227278[esp+336]
	mov	bl, 7
	push	edx
	mov	BYTE PTR __$EHRec$[esp+348], bl
	call	ebp
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+324], 8
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$224963[esp+320]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T227278[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T227277[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1323 : 		}
; 1324 : 		else

	jmp	SHORT $LN67@LogGuessOt
$LN14@LogGuessOt:

; 1325 : 		{
; 1326 : 			strLogName = "GrandStrategyAI_Guess_Log.csv";

	push	OFFSET $SG224970
	lea	ecx, DWORD PTR _strLogName$224963[esp+320]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN67@LogGuessOt:
	push	edi

; 1327 : 		}
; 1328 : 
; 1329 : 		FILogFile* pLog;
; 1330 : 		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$224963[esp+320]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	mov	ebx, eax

; 1331 : 
; 1332 : 		AIGrandStrategyTypes eGrandStrategy;
; 1333 : 		int iPriority;
; 1334 : 
; 1335 : 		// Loop through Grand Strategies
; 1336 : #ifdef AUI_WARNING_FIXES
; 1337 : 		for (uint iGrandStrategyLoop = 0; iGrandStrategyLoop < GC.getNumAIGrandStrategyInfos(); iGrandStrategyLoop++)
; 1338 : #else
; 1339 : 		for(int iGrandStrategyLoop = 0; iGrandStrategyLoop < GC.getNumAIGrandStrategyInfos(); iGrandStrategyLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _pLog$224971[esp+320], ebx
	xor	esi, esi
	call	?getNumAIGrandStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumAIGrandStrategyInfos
	mov	edi, DWORD PTR _ePlayer$[esp+316]
	test	eax, eax
	jle	$LN10@LogGuessOt
	mov	eax, edi
	imul	eax, 63236				; 0000f704H
	mov	DWORD PTR tv696[esp+320], eax
$LL12@LogGuessOt:

; 1340 : #endif
; 1341 : 		{
; 1342 : 			// Get the leading info for this line
; 1343 : 			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224958[esp+324]
	push	OFFSET $SG224978
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1344 : 			strBaseString += playerName + ", ";

	push	OFFSET $SG224980
	lea	edx, DWORD PTR _playerName$224960[esp+336]
	push	edx
	lea	eax, DWORD PTR $T227279[esp+340]
	push	eax
	call	ebp
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224958[esp+324]
	mov	BYTE PTR __$EHRec$[esp+332], 9
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227279[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1345 : 
; 1346 : 			eGrandStrategy = (AIGrandStrategyTypes) iGrandStrategyLoop;
; 1347 : 			iPriority = vGrandStrategyPriorities[iGrandStrategyLoop];

	mov	ecx, DWORD PTR _vGrandStrategyPriorities$[esp+316]
	mov	edx, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [edx+esi*4]

; 1348 : 
; 1349 : 			CvAIGrandStrategyXMLEntry* pEntry = GC.getAIGrandStrategyInfo(eGrandStrategy);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAIGrandStrategyInfo@CvGlobals@@QAEPAVCvAIGrandStrategyXMLEntry@@W4AIGrandStrategyTypes@@@Z ; CvGlobals::getAIGrandStrategyInfo

; 1350 : 			const char* szGrandStrategyType = (pEntry != NULL)? pEntry->GetType() : "Unknown Strategy";

	test	eax, eax
	je	SHORT $LN18@LogGuessOt
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN19@LogGuessOt
$LN18@LogGuessOt:
	mov	eax, OFFSET $SG224984
$LN19@LogGuessOt:

; 1351 : 
; 1352 : 			// GrandStrategy Info
; 1353 : 			if(GetActiveGrandStrategy() == eGrandStrategy)

	mov	ecx, DWORD PTR _this$[esp+320]

; 1354 : 			{
; 1355 : 				strTemp.Format("*** %s, %d", szGrandStrategyType, iPriority);

	push	ebx
	push	eax
	cmp	DWORD PTR [ecx+12], esi
	jne	SHORT $LN9@LogGuessOt
	push	OFFSET $SG224986
	lea	edx, DWORD PTR _strTemp$224959[esp+332]
	push	edx

; 1356 : 			}
; 1357 : 			else

	jmp	SHORT $LN134@LogGuessOt
$LN9@LogGuessOt:

; 1358 : 			{
; 1359 : 				strTemp.Format("%s, %d", szGrandStrategyType, iPriority);

	push	OFFSET $SG224988
	lea	eax, DWORD PTR _strTemp$224959[esp+332]
	push	eax
$LN134@LogGuessOt:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1360 : 			}
; 1361 : 			otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR tv696[esp+336]
	add	esp, 16					; 00000010H
	add	ecx, edx
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _otherPlayerName$224961[esp+320]
	test	eax, eax
	je	SHORT $LN84@LogGuessOt
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN83@LogGuessOt
$LN84@LogGuessOt:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN83@LogGuessOt:

; 1362 : 			strOutBuf = strBaseString + otherPlayerName + ", " + strTemp;

	mov	ebx, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	lea	eax, DWORD PTR _otherPlayerName$224961[esp+320]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224958[esp+324]
	push	ecx
	lea	edx, DWORD PTR $T227282[esp+328]
	push	edx
	call	ebx
	push	OFFSET $SG224992
	push	eax
	lea	eax, DWORD PTR $T227283[esp+340]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+352], 10		; 0000000aH
	call	ebp
	lea	ecx, DWORD PTR _strTemp$224959[esp+344]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T227284[esp+352]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+364], 11		; 0000000bH
	call	ebx
	add	esp, 36					; 00000024H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+328], 12		; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224957[esp+324]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T227284[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 11		; 0000000bH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T227283[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 10		; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T227282[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1363 : 
; 1364 : 			if(GetGuessOtherPlayerActiveGrandStrategy(ePlayer) == eGrandStrategy)

	mov	eax, DWORD PTR _this$[esp+320]
	mov	ecx, DWORD PTR [eax+20]
	cmp	DWORD PTR [ecx+edi*4], esi
	jne	$LN132@LogGuessOt

; 1365 : 			{
; 1366 : 				// Confidence in our guess
; 1367 : 				switch(GetGuessOtherPlayerActiveGrandStrategyConfidence(ePlayer))

	mov	edx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR [edx+edi*4]
	sub	eax, 0
	je	SHORT $LN2@LogGuessOt
	sub	eax, 1
	je	SHORT $LN3@LogGuessOt
	sub	eax, 1
	je	SHORT $LN4@LogGuessOt

; 1377 : 					break;
; 1378 : 				default:
; 1379 : 					strTemp.Format("XXX");

	push	OFFSET $SG225005

; 1380 : 					break;

	jmp	SHORT $LN135@LogGuessOt
$LN4@LogGuessOt:

; 1368 : 				{
; 1369 : 				case GUESS_CONFIDENCE_POSITIVE:
; 1370 : 					strTemp.Format("Positive");

	push	OFFSET $SG224999
	lea	ecx, DWORD PTR _strTemp$224959[esp+324]
	push	ecx

; 1371 : 					break;

	jmp	SHORT $LN136@LogGuessOt
$LN3@LogGuessOt:

; 1372 : 				case GUESS_CONFIDENCE_LIKELY:
; 1373 : 					strTemp.Format("Likely");

	push	OFFSET $SG225001
	lea	edx, DWORD PTR _strTemp$224959[esp+324]
	push	edx

; 1374 : 					break;

	jmp	SHORT $LN136@LogGuessOt
$LN2@LogGuessOt:

; 1375 : 				case GUESS_CONFIDENCE_UNSURE:
; 1376 : 					strTemp.Format("Unsure");

	push	OFFSET $SG225003
$LN135@LogGuessOt:
	lea	eax, DWORD PTR _strTemp$224959[esp+324]
	push	eax
$LN136@LogGuessOt:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 1381 : 				}
; 1382 : 
; 1383 : 				strOutBuf += ", " + strTemp;

	lea	ecx, DWORD PTR _strTemp$224959[esp+320]
	push	ecx
	lea	edx, DWORD PTR $T227285[esp+324]
	push	OFFSET $SG225007
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224957[esp+324]
	mov	BYTE PTR __$EHRec$[esp+332], 13		; 0000000dH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227285[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN132@LogGuessOt:

; 1384 : 			}
; 1385 : 
; 1386 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$224957[esp+320]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _pLog$224971[esp+320]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	call	eax
	add	esp, 8
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumAIGrandStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumAIGrandStrategyInfos
	cmp	esi, eax
	jl	$LL12@LogGuessOt

; 1331 : 
; 1332 : 		AIGrandStrategyTypes eGrandStrategy;
; 1333 : 		int iPriority;
; 1334 : 
; 1335 : 		// Loop through Grand Strategies
; 1336 : #ifdef AUI_WARNING_FIXES
; 1337 : 		for (uint iGrandStrategyLoop = 0; iGrandStrategyLoop < GC.getNumAIGrandStrategyInfos(); iGrandStrategyLoop++)
; 1338 : #else
; 1339 : 		for(int iGrandStrategyLoop = 0; iGrandStrategyLoop < GC.getNumAIGrandStrategyInfos(); iGrandStrategyLoop++)

	mov	ebx, DWORD PTR _pLog$224971[esp+320]
$LN10@LogGuessOt:

; 1387 : 		}
; 1388 : 
; 1389 : 		// One more entry for NO GRAND STRATEGY
; 1390 : 		// Get the leading info for this line
; 1391 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224958[esp+324]
	push	OFFSET $SG225008
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1392 : 		strBaseString += playerName + ", ";

	push	OFFSET $SG225010
	lea	edx, DWORD PTR _playerName$224960[esp+336]
	push	edx
	lea	eax, DWORD PTR $T227286[esp+340]
	push	eax
	call	ebp
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224958[esp+324]
	mov	BYTE PTR __$EHRec$[esp+332], 14		; 0000000eH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T227286[esp+320]
	mov	BYTE PTR __$EHRec$[esp+328], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1393 : 
; 1394 : 		iPriority = vGrandStrategyPriorities[GC.getNumAIGrandStrategyInfos()];

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumAIGrandStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumAIGrandStrategyInfos
	mov	ecx, DWORD PTR _vGrandStrategyPriorities$[esp+316]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax*4]

; 1395 : 
; 1396 : 		// GrandStrategy Info
; 1397 : 		strTemp.Format("NO_GRAND_STRATEGY, %d", iPriority);

	push	eax
	lea	eax, DWORD PTR _strTemp$224959[esp+324]
	push	OFFSET $SG225011
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1398 : 		otherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();

	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	esp, 12					; 0000000cH
	mov	ecx, edi
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	pop	edi
	lea	ecx, DWORD PTR _otherPlayerName$224961[esp+316]
	test	eax, eax
	je	SHORT $LN102@LogGuessOt
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN101@LogGuessOt
$LN102@LogGuessOt:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN101@LogGuessOt:

; 1399 : 		strOutBuf = strBaseString + otherPlayerName + ", " + strTemp;

	mov	esi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	lea	ecx, DWORD PTR _otherPlayerName$224961[esp+316]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$224958[esp+320]
	push	edx
	lea	eax, DWORD PTR $T227287[esp+324]
	push	eax
	call	esi
	push	OFFSET $SG225015
	push	eax
	lea	ecx, DWORD PTR $T227288[esp+336]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+348], 15		; 0000000fH
	call	ebp
	lea	edx, DWORD PTR _strTemp$224959[esp+340]
	push	edx
	push	eax
	lea	eax, DWORD PTR $T227289[esp+348]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+360], 16		; 00000010H
	call	esi
	add	esp, 36					; 00000024H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+324], 17		; 00000011H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224957[esp+320]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T227289[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 16		; 00000010H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T227288[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 15		; 0000000fH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T227287[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1400 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$224957[esp+316]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebx
	call	edx
	add	esp, 8

; 1401 : 	}

	lea	ecx, DWORD PTR _strLogName$224963[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strDesc$224962[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _otherPlayerName$224961[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$224960[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$224959[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$224958[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$224957[esp+316]
	mov	DWORD PTR __$EHRec$[esp+324], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	ebp
	pop	ebx
$LN15@LogGuessOt:

; 1402 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+308]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 304				; 00000130H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$224957[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$224958[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$224959[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR _playerName$224960[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _otherPlayerName$224961[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$5:
	lea	ecx, DWORD PTR _strDesc$224962[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$6:
	lea	ecx, DWORD PTR _strLogName$224963[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$7:
	lea	ecx, DWORD PTR $T227277[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$8:
	lea	ecx, DWORD PTR $T227278[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$9:
	lea	ecx, DWORD PTR $T227279[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$10:
	lea	ecx, DWORD PTR $T227282[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$11:
	lea	ecx, DWORD PTR $T227283[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$12:
	lea	ecx, DWORD PTR $T227284[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$13:
	lea	ecx, DWORD PTR $T227285[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$14:
	lea	ecx, DWORD PTR $T227286[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$15:
	lea	ecx, DWORD PTR $T227287[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$16:
	lea	ecx, DWORD PTR $T227288[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z$17:
	lea	ecx, DWORD PTR $T227289[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z ENDP ; CvGrandStrategyAI::LogGuessOtherPlayerGrandStrategy
PUBLIC	?clear@?$BaseVector@H$00@@QAEXXZ		; BaseVector<int,1>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@H$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@H$00@@QAEXXZ PROC			; BaseVector<int,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@H$00@@QAEXXZ ENDP			; BaseVector<int,1>::clear
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEAAPAVCvAIGrandStrategyXMLEntry@@XZ ; std::_Vector_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEAAPAVCvAIGrandStrategyXMLEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEAAPAVCvAIGrandStrategyXMLEntry@@XZ PROC ; std::_Vector_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEAAPAVCvAIGrandStrategyXMLEntry@@XZ ENDP ; std::_Vector_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@H$04$00$0BCJ@$0A@@@QAE@XZ	; FStaticVector<int,5,1,297,0>::FStaticVector<int,5,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@H$04$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@H$04$00$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,5,1,297,0>::FStaticVector<int,5,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 5
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@H$04$00$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,5,1,297,0>::FStaticVector<int,5,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@H$04$00$0BCJ@$0A@@@QAE@XZ	; FStaticVector<int,5,1,297,0>::~FStaticVector<int,5,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@H$04$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@H$04$00$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,5,1,297,0>::~FStaticVector<int,5,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@H$04$00$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,5,1,297,0>::~FStaticVector<int,5,1,297,0>
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@H$04$00@@QBEABHI@Z ; CvWeightedVector<int,5,1>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@H$04$00@@QBEABHI@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@H$04$00@@QBEABHI@Z PROC	; CvWeightedVector<int,5,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@H$04$00@@QBEABHI@Z ENDP	; CvWeightedVector<int,5,1>::GetElement
_TEXT	ENDS
PUBLIC	?GetWeight@?$CvWeightedVector@H$04$00@@QBEHI@Z	; CvWeightedVector<int,5,1>::GetWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeight@?$CvWeightedVector@H$04$00@@QBEHI@Z
_TEXT	SEGMENT
_elem$ = -8						; size = 8
_iIndex$ = 8						; size = 4
?GetWeight@?$CvWeightedVector@H$04$00@@QBEHI@Z PROC	; CvWeightedVector<int,5,1>::GetWeight, COMDAT
; _this$ = ecx

; 70   : 	{

	sub	esp, 8

; 71   : 		WeightedElement elem;
; 72   : 		assert(iIndex < m_pItems.size());
; 73   : 		elem = m_pItems[iIndex];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp+4]
	mov	edx, DWORD PTR [eax+ecx*8]

; 74   : 		return elem.m_iWeight;

	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$[esp+8], edx

; 75   : 	}

	add	esp, 8
	ret	4
?GetWeight@?$CvWeightedVector@H$04$00@@QBEHI@Z ENDP	; CvWeightedVector<int,5,1>::GetWeight
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@H$04$00@@QAEHXZ	; CvWeightedVector<int,5,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@H$04$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@H$04$00@@QAEHXZ PROC		; CvWeightedVector<int,5,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@H$04$00@@QAEHXZ ENDP		; CvWeightedVector<int,5,1>::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::~_Vector_val<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::~_Vector_val<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::~_Vector_val<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@1@@Z ; std::_Vector_val<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Vector_val<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@1@@Z PROC ; std::_Vector_val<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Vector_val<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@1@@Z ENDP ; std::_Vector_val<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Vector_val<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvAIGrandStrategyXMLEntry@@@Z ; std::_Vector_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Vector_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvAIGrandStrategyXMLEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvAIGrandStrategyXMLEntry@@@Z PROC ; std::_Vector_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Vector_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvAIGrandStrategyXMLEntry@@@Z ENDP ; std::_Vector_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Vector_iterator<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,5,1,297,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<int,5,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 5
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 5
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+32], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<int,5,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 5
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAEXXZ ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAEXXZ PROC ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$00@@QAEXXZ ENDP ; BaseVector<CvWeightedVector<int,5,1>::WeightedElement,1>::clear
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@@Z ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@@Z PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@@Z ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAEPAPAVCvAIGrandStrategyXMLEntry@@I@Z ; std::allocator<CvAIGrandStrategyXMLEntry *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAEPAPAVCvAIGrandStrategyXMLEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAEPAPAVCvAIGrandStrategyXMLEntry@@I@Z PROC ; std::allocator<CvAIGrandStrategyXMLEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvAIGrandStrategyXMLEntry@@@std@@YAPAPAVCvAIGrandStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvAIGrandStrategyXMLEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@QAEPAPAVCvAIGrandStrategyXMLEntry@@I@Z ENDP ; std::allocator<CvAIGrandStrategyXMLEntry *>::allocate
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z PROC ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$04$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::Free
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 516  : 	int i = 0;
; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 518  : 	ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 519  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@2
	push	ebx
	mov	ebx, DWORD PTR _loadFrom$[esp+8]
$LL3@operator@2:

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	push	esi
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@2

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 524  : }

	ret	0
$LN14@operator@2:

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[esp+4]
	pop	edi
	pop	esi

; 524  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 503  : 	int i = 0;
; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 505  : 	const ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 506  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@3
	push	ebx
	mov	ebx, DWORD PTR _saveTo$[esp+8]
$LL3@operator@3:

; 507  : 	{
; 508  : 		saveTo << values[i];

	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@3

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 511  : }

	ret	0
$LN14@operator@3:

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+4]
	pop	edi
	pop	esi

; 511  : }

	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvAIGrandStrategyXMLEntry * *,CvAIGrandStrategyXMLEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvAIGrandStrategyXMLEntry * *,CvAIGrandStrategyXMLEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvAIGrandStrategyXMLEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvAIGrandStrategyXMLEntry * *,CvAIGrandStrategyXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvAIGrandStrategyXMLEntry@@0AAV?$allocator@PAVCvAIGrandStrategyXMLEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvAIGrandStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvAIGrandStrategyXMLEntry@@0AAV?$allocator@PAVCvAIGrandStrategyXMLEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvAIGrandStrategyXMLEntry@@0AAV?$allocator@PAVCvAIGrandStrategyXMLEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvAIGrandStrategyXMLEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvAIGrandStrategyXMLEntry@@0AAV?$allocator@PAVCvAIGrandStrategyXMLEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvAIGrandStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::iter_swap<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ; std::_Med3<CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z PROC ; std::_Med3<CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea
	npad	7
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea
$LN14@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@2
	push	esi
$LL8@unchecked_@2:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@2
	pop	esi
$LN7@unchecked_@2:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	??0CvAIGrandStrategyXMLEntry@@QAE@XZ		; CvAIGrandStrategyXMLEntry::CvAIGrandStrategyXMLEntry
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
;	COMDAT ??0CvAIGrandStrategyXMLEntry@@QAE@XZ
_TEXT	SEGMENT
??0CvAIGrandStrategyXMLEntry@@QAE@XZ PROC		; CvAIGrandStrategyXMLEntry::CvAIGrandStrategyXMLEntry, COMDAT
; _this$ = ecx

; 24   : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvAIGrandStrategyXMLEntry@@6B@

; 25   : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIGrandStrategyXMLEntry@@QAE@XZ ENDP		; CvAIGrandStrategyXMLEntry::CvAIGrandStrategyXMLEntry
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIGrandStrategyXMLEntry@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIGrandStrategyXMLEntry@@UAEPAXI@Z PROC		; CvAIGrandStrategyXMLEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvAIGrandStrategyXMLEntry@@UAE@XZ	; CvAIGrandStrategyXMLEntry::~CvAIGrandStrategyXMLEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIGrandStrategyXMLEntry@@UAEPAXI@Z ENDP		; CvAIGrandStrategyXMLEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Init@CvGrandStrategyAI@@QAEXPAVCvAIGrandStrategyXMLEntries@@PAVCvPlayer@@@Z ; CvGrandStrategyAI::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvGrandStrategyAI@@QAEXPAVCvAIGrandStrategyXMLEntries@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_pAIGrandStrategies$ = 8				; size = 4
_pPlayer$ = 12						; size = 4
?Init@CvGrandStrategyAI@@QAEXPAVCvAIGrandStrategyXMLEntries@@PAVCvPlayer@@@Z PROC ; CvGrandStrategyAI::Init, COMDAT
; _this$ = ecx

; 165  : 	// Store off the pointer to the AIStrategies active for this game
; 166  : 	m_pAIGrandStrategies = pAIGrandStrategies;
; 167  : 
; 168  : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _pPlayer$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _pAIGrandStrategies$[esp]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi], eax

; 169  : 
; 170  : 	// Initialize AIGrandStrategy status array
; 171  : 	FAssertMsg(m_paiGrandStrategyPriority==NULL, "about to leak memory, CvGrandStrategyAI::m_paiGrandStrategyPriority");
; 172  : 	m_paiGrandStrategyPriority = FNEW(int[m_pAIGrandStrategies->GetNumAIGrandStrategies()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	sar	eax, 2
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 173  : 
; 174  : 	FAssertMsg(m_eGuessOtherPlayerActiveGrandStrategy==NULL, "about to leak memory, CvGrandStrategyAI::m_eGuessOtherPlayerActiveGrandStrategy");
; 175  : 	m_eGuessOtherPlayerActiveGrandStrategy = FNEW(int[MAX_MAJOR_CIVS], c_eCiv5GameplayDLL, 0);

	push	88					; 00000058H
	mov	DWORD PTR [esi+16], eax
	call	??_U@YAPAXI@Z				; operator new[]

; 176  : 
; 177  : 	FAssertMsg(m_eGuessOtherPlayerActiveGrandStrategyConfidence==NULL, "about to leak memory, CvGrandStrategyAI::m_eGuessOtherPlayerActiveGrandStrategyConfidence");
; 178  : 	m_eGuessOtherPlayerActiveGrandStrategyConfidence = FNEW(int[MAX_MAJOR_CIVS], c_eCiv5GameplayDLL, 0);

	push	88					; 00000058H
	mov	DWORD PTR [esi+20], eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 12					; 0000000cH

; 179  : 
; 180  : 	Reset();

	mov	ecx, esi
	mov	DWORD PTR [esi+24], eax
	call	?Reset@CvGrandStrategyAI@@QAEXXZ	; CvGrandStrategyAI::Reset
	pop	esi

; 181  : }

	ret	8
?Init@CvGrandStrategyAI@@QAEXPAVCvAIGrandStrategyXMLEntries@@PAVCvPlayer@@@Z ENDP ; CvGrandStrategyAI::Init
_TEXT	ENDS
PUBLIC	?Read@CvGrandStrategyAI@@QAEXAAVFDataStream@@@Z	; CvGrandStrategyAI::Read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvGrandStrategyAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvGrandStrategyAI@@QAEXAAVFDataStream@@@Z PROC	; CvGrandStrategyAI::Read, COMDAT
; _this$ = ecx

; 218  : {

	push	ebx
	push	ebp
	push	esi

; 219  : 	// Version number to maintain backwards compatibility
; 220  : 	uint uiVersion;
; 221  : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+8]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 222  : 
; 223  : 	kStream >> m_iNumTurnsSinceActiveSet;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 224  : 	kStream >> (int&)m_eActiveGrandStrategy;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 225  : 
; 226  : 	FAssertMsg(m_pAIGrandStrategies != NULL && m_pAIGrandStrategies->GetNumAIGrandStrategies() > 0, "Number of AIGrandStrategies to serialize is expected to greater than 0");
; 227  : #ifdef _MSC_VER
; 228  : // JAR - if m_pAIGrandStrategies can be NULL at this point,
; 229  : // the load will fail if the data isn't read. Better to crash
; 230  : // here where the problem is than defer it.
; 231  : #pragma warning ( push )
; 232  : #pragma warning ( disable : 6011 )
; 233  : #endif//_MSC_VER
; 234  : 	ArrayWrapper<int> wrapm_paiGrandStrategyPriority(m_pAIGrandStrategies->GetNumAIGrandStrategies(), m_paiGrandStrategyPriority);

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [edi+16]
	sar	eax, 2

; 235  : #ifdef _MSC_VER
; 236  : #pragma warning ( pop )
; 237  : #endif//_MSC_VER
; 238  : 
; 239  : 	kStream >> wrapm_paiGrandStrategyPriority;

	test	eax, eax
	jle	SHORT $LN15@Read

; 219  : 	// Version number to maintain backwards compatibility
; 220  : 	uint uiVersion;
; 221  : 	kStream >> uiVersion;

	mov	ebp, eax

; 235  : #ifdef _MSC_VER
; 236  : #pragma warning ( pop )
; 237  : #endif//_MSC_VER
; 238  : 
; 239  : 	kStream >> wrapm_paiGrandStrategyPriority;

$LL17@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL17@Read
$LN15@Read:

; 240  : 
; 241  : 	ArrayWrapper<int> wrapm_eGuessOtherPlayerActiveGrandStrategy(MAX_MAJOR_CIVS, m_eGuessOtherPlayerActiveGrandStrategy);

	mov	ebx, DWORD PTR [edi+20]
	mov	ebp, 22					; 00000016H
	npad	7

; 242  : 	kStream >> wrapm_eGuessOtherPlayerActiveGrandStrategy;

$LL30@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL30@Read

; 243  : 
; 244  : 	ArrayWrapper<int> wrapm_eGuessOtherPlayerActiveGrandStrategyConfidence(MAX_MAJOR_CIVS, m_eGuessOtherPlayerActiveGrandStrategyConfidence);

	mov	edi, DWORD PTR [edi+24]
	lea	ebx, DWORD PTR [ebp+22]

; 245  : 	kStream >> wrapm_eGuessOtherPlayerActiveGrandStrategyConfidence;

$LL43@Read:
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL43@Read
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 246  : 
; 247  : }

	ret	4
?Read@CvGrandStrategyAI@@QAEXAAVFDataStream@@@Z ENDP	; CvGrandStrategyAI::Read
_TEXT	ENDS
PUBLIC	?Write@CvGrandStrategyAI@@QAEXAAVFDataStream@@@Z ; CvGrandStrategyAI::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvGrandStrategyAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T228072 = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvGrandStrategyAI@@QAEXAAVFDataStream@@@Z PROC	; CvGrandStrategyAI::Write, COMDAT
; _this$ = ecx

; 251  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 254  : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+12]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+24], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 255  : 
; 256  : 	kStream << m_iNumTurnsSinceActiveSet;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 257  : 	kStream << m_eActiveGrandStrategy;

	mov	edx, DWORD PTR [edi+12]
	lea	eax, DWORD PTR $T228072[esp+16]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T228072[esp+20], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 258  : 
; 259  : 	FAssertMsg(GC.getNumAIGrandStrategyInfos() > 0, "Number of AIStrategies to serialize is expected to greater than 0");
; 260  : 	kStream << ArrayWrapper<int>(m_pAIGrandStrategies->GetNumAIGrandStrategies(), m_paiGrandStrategyPriority);

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [edi+16]
	sar	eax, 2
	test	eax, eax
	jle	SHORT $LN15@Write

; 252  : 	// Current version number
; 253  : 	uint uiVersion = 1;

	mov	ebp, eax

; 258  : 
; 259  : 	FAssertMsg(GC.getNumAIGrandStrategyInfos() > 0, "Number of AIStrategies to serialize is expected to greater than 0");
; 260  : 	kStream << ArrayWrapper<int>(m_pAIGrandStrategies->GetNumAIGrandStrategies(), m_paiGrandStrategyPriority);

$LL17@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL17@Write
$LN15@Write:

; 261  : 
; 262  : 	kStream << ArrayWrapper<int>(MAX_MAJOR_CIVS, m_eGuessOtherPlayerActiveGrandStrategy);

	mov	ebx, DWORD PTR [edi+20]
	mov	ebp, 22					; 00000016H
	npad	6
$LL30@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL30@Write

; 263  : 	kStream << ArrayWrapper<int>(MAX_MAJOR_CIVS, m_eGuessOtherPlayerActiveGrandStrategyConfidence);

	mov	edi, DWORD PTR [edi+24]
	lea	ebx, DWORD PTR [ebp+22]
$LL43@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL43@Write
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 264  : }

	pop	ecx
	ret	4
?Write@CvGrandStrategyAI@@QAEXAAVFDataStream@@@Z ENDP	; CvGrandStrategyAI::Write
_TEXT	ENDS
PUBLIC	?GetConquestPriority@CvGrandStrategyAI@@QAEHXZ	; CvGrandStrategyAI::GetConquestPriority
EXTRN	?getNumNukeUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumNukeUnits
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?IsCramped@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsCramped
EXTRN	?getAtWarCount@CvTeam@@QBEH_N@Z:PROC		; CvTeam::getAtWarCount
EXTRN	?GetWorldMilitaryStrengthAverage@CvGame@@QAEHW4PlayerTypes@@_N1@Z:PROC ; CvGame::GetWorldMilitaryStrengthAverage
EXTRN	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isHasMet
EXTRN	?isMinorCiv@CvTeam@@QBE_NXZ:PROC		; CvTeam::isMinorCiv
EXTRN	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ:PROC	; CvTeam::GetID
EXTRN	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ:PROC ; CvPlayer::GetCurrentEra
EXTRN	?GetBoldness@CvDiplomacyAI@@QBEHXZ:PROC		; CvDiplomacyAI::GetBoldness
EXTRN	?GetPersonalityMajorCivApproachBias@CvDiplomacyAI@@QBEHW4MajorCivApproachTypes@@@Z:PROC ; CvDiplomacyAI::GetPersonalityMajorCivApproachBias
EXTRN	?areNoVictoriesValid@CvGame@@QBE_NXZ:PROC	; CvGame::areNoVictoriesValid
EXTRN	?isVictoryValid@CvGame@@QBE_NW4VictoryTypes@@@Z:PROC ; CvGame::isVictoryValid
; Function compile flags: /Ogtpy
;	COMDAT ?GetConquestPriority@CvGrandStrategyAI@@QAEHXZ
_TEXT	SEGMENT
_iPriority$ = -20					; size = 4
_this$ = -16						; size = 4
_pTeam$ = -12						; size = 4
_iGeneralWarlikeness$ = -12				; size = 4
_iNumPlayersMet$224358 = -8				; size = 4
_iGeneralDeceptiveness$ = -8				; size = 4
_iTotalLandMe$224359 = -4				; size = 4
_iGeneralHostility$ = -4				; size = 4
?GetConquestPriority@CvGrandStrategyAI@@QAEHXZ PROC	; CvGrandStrategyAI::GetConquestPriority, COMDAT
; _this$ = ecx

; 439  : {

	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, ecx

; 440  : 	int iPriority = 0;
; 441  : 
; 442  : 	// If Conquest Victory isn't even available then don't bother with anything
; 443  : 	VictoryTypes eVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_DOMINATION", true);

	push	1
	push	OFFSET $SG224324
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+32], ebx
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 444  : 	if(eVictory == NO_VICTORY || !GC.getGame().isVictoryValid(eVictory))

	cmp	eax, -1
	je	SHORT $LN36@GetConques
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?isVictoryValid@CvGame@@QBE_NW4VictoryTypes@@@Z ; CvGame::isVictoryValid
	test	al, al
	jne	SHORT $LN35@GetConques
$LN36@GetConques:

; 445  : 	{
; 446  : 		if(!GC.getGame().areNoVictoriesValid())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?areNoVictoriesValid@CvGame@@QBE_NXZ	; CvGame::areNoVictoriesValid
	test	al, al
	jne	SHORT $LN35@GetConques

; 447  : 		{
; 448  : 			return -100;

	mov	eax, -100				; ffffff9cH
	pop	ebx

; 591  : }

	add	esp, 20					; 00000014H
	ret	0
$LN35@GetConques:

; 449  : 		}
; 450  : 	}
; 451  : 
; 452  : 	int iGeneralWarlikeness = GetPlayer()->GetDiplomacyAI()->GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_WAR);

	mov	ecx, DWORD PTR [ebx]
	push	ebp
	push	esi
	push	edi
	push	0
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetPersonalityMajorCivApproachBias@CvDiplomacyAI@@QBEHW4MajorCivApproachTypes@@@Z ; CvDiplomacyAI::GetPersonalityMajorCivApproachBias

; 453  : 	int iGeneralHostility = GetPlayer()->GetDiplomacyAI()->GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_HOSTILE);

	mov	ecx, DWORD PTR [ebx]
	mov	ebp, eax
	push	1
	mov	DWORD PTR _iGeneralWarlikeness$[esp+40], ebp
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetPersonalityMajorCivApproachBias@CvDiplomacyAI@@QBEHW4MajorCivApproachTypes@@@Z ; CvDiplomacyAI::GetPersonalityMajorCivApproachBias

; 454  : 	int iGeneralDeceptiveness = GetPlayer()->GetDiplomacyAI()->GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_DECEPTIVE);

	mov	ecx, DWORD PTR [ebx]
	mov	esi, eax
	push	2
	mov	DWORD PTR _iGeneralHostility$[esp+40], esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetPersonalityMajorCivApproachBias@CvDiplomacyAI@@QBEHW4MajorCivApproachTypes@@@Z ; CvDiplomacyAI::GetPersonalityMajorCivApproachBias

; 455  : 	int iGeneralFriendliness = GetPlayer()->GetDiplomacyAI()->GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_FRIENDLY);

	mov	ecx, DWORD PTR [ebx]
	mov	edi, eax
	push	5
	mov	DWORD PTR _iGeneralDeceptiveness$[esp+40], edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetPersonalityMajorCivApproachBias@CvDiplomacyAI@@QBEHW4MajorCivApproachTypes@@@Z ; CvDiplomacyAI::GetPersonalityMajorCivApproachBias

; 456  : 
; 457  : 	int iGeneralApproachModifier = max(max(iGeneralDeceptiveness, iGeneralHostility),iGeneralWarlikeness) - iGeneralFriendliness;

	cmp	edi, esi
	mov	ebx, eax
	lea	esi, DWORD PTR _iGeneralHostility$[esp+36]
	jl	SHORT $LN55@GetConques
	lea	esi, DWORD PTR _iGeneralDeceptiveness$[esp+36]
$LN55@GetConques:
	cmp	DWORD PTR [esi], ebp
	jge	SHORT $LN58@GetConques
	lea	esi, DWORD PTR _iGeneralWarlikeness$[esp+36]
$LN58@GetConques:

; 458  : 	// Boldness gives the base weight for Conquest (no flavors added earlier)
; 459  : 	iPriority += ((GetPlayer()->GetDiplomacyAI()->GetBoldness() + iGeneralApproachModifier) * (12 - m_pPlayer->GetCurrentEra())); // make a little less likely as time goes on

	mov	ebp, DWORD PTR _this$[esp+36]
	mov	ecx, DWORD PTR [ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetBoldness@CvDiplomacyAI@@QBEHXZ	; CvDiplomacyAI::GetBoldness
	mov	ecx, DWORD PTR [esi]
	sub	ecx, ebx
	lea	esi, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [ebp]
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra

; 460  : 
; 461  : 	CvTeam& pTeam = GET_TEAM(GetPlayer()->getTeam());

	mov	edx, DWORD PTR [ebp]
	mov	ebx, 12					; 0000000cH
	sub	ebx, eax
	mov	eax, DWORD PTR [edx+44]
	imul	ebx, esi
	mov	DWORD PTR _iPriority$[esp+36], ebx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN68@GetConques
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN69@GetConques
$LN68@GetConques:
	or	eax, -1
$LN69@GetConques:

; 462  : 
; 463  : 	// How many turns must have passed before we test for having met nobody?
; 464  : 	if(GC.getGame().getElapsedGameTurns() >= /*20*/ GC.getAI_GS_CONQUEST_NOBODY_MET_FIRST_TURN())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1920
	mov	DWORD PTR _pTeam$[esp+36], eax
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cmp	eax, esi
	jl	SHORT $LN202@GetConques

; 465  : 	{
; 466  : 		// If we haven't met any Major Civs yet, then we probably shouldn't be planning on conquering the world
; 467  : 		bool bHasMetMajor = false;
; 468  : 
; 469  : 		for(int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	xor	edi, edi
	xor	esi, esi
	npad	7
$LL33@GetConques:

; 470  : 		{
; 471  : 			if(pTeam.GetID() != iTeamLoop && !GET_TEAM((TeamTypes) iTeamLoop).isMinorCiv())

	mov	ecx, DWORD PTR _pTeam$[esp+36]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	eax, edi
	je	SHORT $LN32@GetConques
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [esi+eax]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN32@GetConques

; 472  : 			{
; 473  : 				if(pTeam.isHasMet((TeamTypes) iTeamLoop))

	mov	ecx, DWORD PTR _pTeam$[esp+36]
	push	edi
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	jne	SHORT $LN202@GetConques
$LN32@GetConques:

; 465  : 	{
; 466  : 		// If we haven't met any Major Civs yet, then we probably shouldn't be planning on conquering the world
; 467  : 		bool bHasMetMajor = false;
; 468  : 
; 469  : 		for(int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	add	esi, 2980				; 00000ba4H
	inc	edi
	cmp	esi, 187740				; 0002dd5cH
	jl	SHORT $LL33@GetConques

; 474  : 				{
; 475  : 					bHasMetMajor = true;
; 476  : 					break;
; 477  : 				}
; 478  : 			}
; 479  : 		}
; 480  : 		if(!bHasMetMajor)
; 481  : 		{
; 482  : 			iPriority += /*-50*/ GC.getAI_GRAND_STRATEGY_CONQUEST_NOBODY_MET_WEIGHT();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1924
	mov	DWORD PTR _iPriority$[esp+36], ebx
$LN202@GetConques:

; 483  : 		}
; 484  : 	}
; 485  : 
; 486  : 	// How many turns must have passed before we test for us having a weak military?
; 487  : 	if(GC.getGame().getElapsedGameTurns() >= /*60*/ GC.getAI_GS_CONQUEST_MILITARY_STRENGTH_FIRST_TURN())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1932
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cmp	eax, esi
	jl	SHORT $LN203@GetConques

; 488  : 	{
; 489  : 		// Compare our military strength to the rest of the world
; 490  : 		int iWorldMilitaryStrength = GC.getGame().GetWorldMilitaryStrengthAverage(GetPlayer()->GetID(), true, true);

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	push	1
	push	eax
	call	?GetWorldMilitaryStrengthAverage@CvGame@@QAEHW4PlayerTypes@@_N1@Z ; CvGame::GetWorldMilitaryStrengthAverage
	mov	esi, eax

; 491  : 
; 492  : 		if(iWorldMilitaryStrength > 0)

	test	esi, esi
	jle	SHORT $LN203@GetConques

; 493  : 		{
; 494  : 			int iMilitaryRatio = (GetPlayer()->GetMilitaryMight() - iWorldMilitaryStrength) * /*100*/ GC.getAI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER() / iWorldMilitaryStrength;

	mov	ecx, DWORD PTR [ebp]
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1936
	call	?GetMilitaryMight@CvPlayer@@QBEHXZ	; CvPlayer::GetMilitaryMight
	sub	eax, esi
	imul	eax, edi
	cdq
	idiv	esi

; 495  : 
; 496  : 			// Make the likelihood of BECOMING a warmonger lower than dropping the bad behavior
; 497  : 			if(iMilitaryRatio > 0)

	test	eax, eax
	jle	SHORT $LN25@GetConques

; 498  : 				iMilitaryRatio /= 2;

	cdq
	sub	eax, edx
	sar	eax, 1
$LN25@GetConques:

; 499  : 
; 500  : 			iPriority += iMilitaryRatio;	// This will add between -100 and 100 depending on this player's MilitaryStrength relative the world average. The number will typically be near 0 though, as it's fairly hard to get away from the world average

	add	ebx, eax
	mov	DWORD PTR _iPriority$[esp+36], ebx
$LN203@GetConques:

; 501  : 		}
; 502  : 	}
; 503  : 
; 504  : 	// If we're at war, then boost the weight a bit
; 505  : 	if(pTeam.getAtWarCount(/*bIgnoreMinors*/ false) > 0)

	mov	ecx, DWORD PTR _pTeam$[esp+36]
	xor	edi, edi
	push	edi
	call	?getAtWarCount@CvTeam@@QBEH_N@Z		; CvTeam::getAtWarCount
	test	eax, eax
	jle	SHORT $LN24@GetConques

; 506  : 	{
; 507  : 		iPriority += /*10*/ GC.getAI_GRAND_STRATEGY_CONQUEST_AT_WAR_WEIGHT();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1928
	mov	DWORD PTR _iPriority$[esp+36], ebx
$LN24@GetConques:

; 508  : 	}
; 509  : 
; 510  : 	// If our neighbors are cramping our style, consider less... scrupulous means of obtaining more land
; 511  : 	if(GetPlayer()->IsCramped())

	mov	ecx, DWORD PTR [ebp]
	call	?IsCramped@CvPlayer@@QBE_NXZ		; CvPlayer::IsCramped
	test	al, al
	je	$LN8@GetConques

; 512  : 	{
; 513  : 		PlayerTypes ePlayer;
; 514  : 		int iNumPlayersMet = 1;	// Include 1 for me!
; 515  : 		int iTotalLandMe = 0;
; 516  : 		int iTotalLandPlayersMet = 0;

	xor	ebp, ebp
	mov	DWORD PTR _iNumPlayersMet$224358[esp+36], 1
	mov	DWORD PTR _iTotalLandMe$224359[esp+36], edi
	xor	esi, esi
	npad	11
$LL22@GetConques:

; 520  : 		{
; 521  : 			ePlayer = (PlayerTypes) iMajorLoop;
; 522  : 
; 523  : 			if(GET_PLAYER(ePlayer).isAlive() && iMajorLoop != GetPlayer()->GetID())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	je	SHORT $LN21@GetConques
	mov	edx, DWORD PTR _this$[esp+36]
	mov	ecx, DWORD PTR [edx]
	cmp	edi, DWORD PTR [ecx+44]
	je	SHORT $LN21@GetConques

; 524  : 			{
; 525  : 				if(pTeam.isHasMet(GET_PLAYER(ePlayer).getTeam()))

	mov	eax, DWORD PTR [esi+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN121@GetConques
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN122@GetConques
$LN121@GetConques:
	or	eax, -1
$LN122@GetConques:
	mov	ecx, DWORD PTR _pTeam$[esp+36]
	push	eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN21@GetConques

; 526  : 				{
; 527  : 					iNumPlayersMet++;

	inc	DWORD PTR _iNumPlayersMet$224358[esp+36]
$LN21@GetConques:

; 517  : 
; 518  : 		// Count the number of Majors we know
; 519  : 		for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL22@GetConques

; 528  : 				}
; 529  : 			}
; 530  : 		}
; 531  : 
; 532  : 		if(iNumPlayersMet > 0)

	cmp	DWORD PTR _iNumPlayersMet$224358[esp+36], ebp
	jle	$LN206@GetConques

; 533  : 		{
; 534  : 			// Check every plot for ownership
; 535  : #ifdef AUI_WARNING_FIXES
; 536  : 			for (uint iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
; 537  : #else
; 538  : 			for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	xor	ebx, ebx
	cmp	DWORD PTR [eax+4028], ebp
	jle	$LN207@GetConques
	xor	edi, edi
	npad	12
$LL16@GetConques:

; 539  : #endif
; 540  : 			{
; 541  : 				if(GC.getMap().plotByIndexUnchecked(iPlotLoop)->isOwned())

	mov	ecx, DWORD PTR [eax+4068]
	add	ecx, edi
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	je	SHORT $LN15@GetConques

; 542  : 				{
; 543  : 					ePlayer = GC.getMap().plotByIndexUnchecked(iPlotLoop)->getOwner();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [edx+4068]
	movsx	esi, BYTE PTR [eax+edi+4]

; 544  : 
; 545  : 					if(ePlayer == GetPlayer()->GetID())

	mov	ecx, DWORD PTR _this$[esp+36]
	mov	edx, DWORD PTR [ecx]
	cmp	esi, DWORD PTR [edx+44]
	jne	SHORT $LN12@GetConques

; 546  : 					{
; 547  : 						iTotalLandPlayersMet++;

	inc	ebp

; 548  : 						iTotalLandMe++;

	inc	DWORD PTR _iTotalLandMe$224359[esp+36]
	jmp	SHORT $LN15@GetConques
$LN12@GetConques:

; 549  : 					}
; 550  : 					else if(!GET_PLAYER(ePlayer).isMinorCiv() && pTeam.isHasMet(GET_PLAYER(ePlayer).getTeam()))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN15@GetConques
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, DWORD PTR [esi+ecx+44]
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN154@GetConques
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	eax, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN155@GetConques
$LN154@GetConques:
	or	esi, -1
$LN155@GetConques:
	mov	ecx, DWORD PTR _pTeam$[esp+36]
	push	esi
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN15@GetConques

; 551  : 					{
; 552  : 						iTotalLandPlayersMet++;

	inc	ebp
$LN15@GetConques:

; 533  : 		{
; 534  : 			// Check every plot for ownership
; 535  : #ifdef AUI_WARNING_FIXES
; 536  : 			for (uint iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
; 537  : #else
; 538  : 			for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	inc	ebx
	add	edi, 484				; 000001e4H
	cmp	ebx, DWORD PTR [eax+4028]
	jl	$LL16@GetConques

; 553  : 					}
; 554  : 				}
; 555  : 			}
; 556  : 
; 557  : 			iTotalLandPlayersMet /= iNumPlayersMet;
; 558  : 
; 559  : 			if(iTotalLandMe > 0)

	mov	ecx, DWORD PTR _iTotalLandMe$224359[esp+36]
	test	ecx, ecx
	jle	SHORT $LN207@GetConques
	mov	eax, ebp
	cdq
	idiv	DWORD PTR _iNumPlayersMet$224358[esp+36]

; 560  : 			{
; 561  : 				if(iTotalLandPlayersMet / iTotalLandMe > 0)

	cdq
	idiv	ecx
	test	eax, eax
	jle	SHORT $LN207@GetConques

; 562  : 				{
; 563  : 					iPriority += /*20*/ GC.getAI_GRAND_STRATEGY_CONQUEST_CRAMPED_WEIGHT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1940
	add	DWORD PTR _iPriority$[esp+36], ecx
$LN207@GetConques:
	mov	ebx, DWORD PTR _iPriority$[esp+36]
$LN206@GetConques:
	mov	ebp, DWORD PTR _this$[esp+36]
$LN8@GetConques:

; 564  : 				}
; 565  : 			}
; 566  : 		}
; 567  : 	}
; 568  : 
; 569  : 	// if we do not have nukes and we know someone else who does...
; 570  : 	if(GetPlayer()->getNumNukeUnits() == 0)

	mov	ecx, DWORD PTR [ebp]
	call	?getNumNukeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getNumNukeUnits
	test	eax, eax
	jne	SHORT $LN4@GetConques

; 571  : 	{
; 572  : 		for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	edi, edi
	xor	esi, esi
	npad	1
$LL6@GetConques:

; 573  : 		{
; 574  : 			PlayerTypes ePlayer = (PlayerTypes) iMajorLoop;
; 575  : 
; 576  : 			if(GET_PLAYER(ePlayer).isAlive() && iMajorLoop != GetPlayer()->GetID())

	cmp	BYTE PTR [esi+eax+2256], 0
	je	SHORT $LN5@GetConques
	mov	edx, DWORD PTR [ebp]
	cmp	edi, DWORD PTR [edx+44]
	je	SHORT $LN5@GetConques

; 577  : 			{
; 578  : 				if(pTeam.isHasMet(GET_PLAYER(ePlayer).getTeam()))

	mov	eax, DWORD PTR [esi+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN181@GetConques
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN182@GetConques
$LN181@GetConques:
	or	eax, -1
$LN182@GetConques:
	mov	ecx, DWORD PTR _pTeam$[esp+36]
	push	eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN201@GetConques

; 579  : 				{
; 580  : 					if (GET_PLAYER(ePlayer).getNumNukeUnits() > 0)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?getNumNukeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getNumNukeUnits
	test	eax, eax
	jg	SHORT $LN193@GetConques
$LN201@GetConques:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN5@GetConques:

; 571  : 	{
; 572  : 		for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL6@GetConques
	pop	edi
	pop	esi
	pop	ebp

; 583  : 						break;
; 584  : 					}
; 585  : 				}
; 586  : 			}
; 587  : 		}
; 588  : 	}
; 589  : 
; 590  : 	return iPriority;

	mov	eax, ebx
	pop	ebx

; 591  : }

	add	esp, 20					; 00000014H
	ret	0
$LN193@GetConques:

; 581  : 					{
; 582  : 						iPriority -= 50; 

	sub	ebx, 50					; 00000032H
$LN4@GetConques:
	pop	edi
	pop	esi
	pop	ebp

; 583  : 						break;
; 584  : 					}
; 585  : 				}
; 586  : 			}
; 587  : 		}
; 588  : 	}
; 589  : 
; 590  : 	return iPriority;

	mov	eax, ebx
	pop	ebx

; 591  : }

	add	esp, 20					; 00000014H
	ret	0
?GetConquestPriority@CvGrandStrategyAI@@QAEHXZ ENDP	; CvGrandStrategyAI::GetConquestPriority
_TEXT	ENDS
PUBLIC	?GetCulturePriority@CvGrandStrategyAI@@QAEHXZ	; CvGrandStrategyAI::GetCulturePriority
EXTRN	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ:PROC ; CvPlayerCulture::GetNumCivsInfluentialOn
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?GetTotalJONSCulturePerTurn@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetTotalJONSCulturePerTurn
; Function compile flags: /Ogtpy
;	COMDAT ?GetCulturePriority@CvGrandStrategyAI@@QAEHXZ
_TEXT	SEGMENT
_iPlayerLoop$224409 = -32				; size = 4
_iNumCivsAlive$ = -28					; size = 4
_iNumCivsAheadCulture$ = -24				; size = 4
_iNumCivsBehindCulture$ = -20				; size = 4
_iNumCivsAheadTourism$ = -16				; size = 4
_iNumCivsBehindTourism$ = -12				; size = 4
_iOurCulture$ = -8					; size = 4
_iOurTourism$ = -4					; size = 4
?GetCulturePriority@CvGrandStrategyAI@@QAEHXZ PROC	; CvGrandStrategyAI::GetCulturePriority, COMDAT
; _this$ = ecx

; 599  : {

	sub	esp, 32					; 00000020H
	push	edi

; 600  : 	int iPriority = 0;
; 601  : 
; 602  : 	// If Culture Victory isn't even available then don't bother with anything
; 603  : 	VictoryTypes eVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_CULTURAL", true);

	push	1
	mov	edi, ecx
	push	OFFSET $SG224395
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 604  : 	if(eVictory == NO_VICTORY || !GC.getGame().isVictoryValid(eVictory))

	cmp	eax, -1
	je	$LN11@GetCulture
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?isVictoryValid@CvGame@@QBE_NW4VictoryTypes@@@Z ; CvGame::isVictoryValid
	test	al, al
	je	$LN11@GetCulture
	push	ebx
	push	ebp
	push	esi

; 607  : 	}
; 608  : 
; 609  : 	// Before tourism kicks in, add weight based on flavor
; 610  : 	int iFlavorCulture =  m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_CULTURE"));

	xor	ebx, ebx
	push	ebx
	push	OFFSET $SG224400
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor

; 611  : 	iPriority += (10 - m_pPlayer->GetCurrentEra()) * iFlavorCulture * 200 / 100;

	mov	ecx, DWORD PTR [edi]
	mov	esi, eax
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	mov	ecx, 10					; 0000000aH
	sub	ecx, eax
	imul	ecx, esi
	imul	ecx, 200				; 000000c8H
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 612  : 
; 613  : 	// Loop through Players to see how we are doing on Tourism and Culture
; 614  : 	PlayerTypes eLoopPlayer;
; 615  : 	int iOurCulture = m_pPlayer->GetTotalJONSCulturePerTurn();

	mov	ecx, DWORD PTR [edi]
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?GetTotalJONSCulturePerTurn@CvPlayer@@QBEHXZ ; CvPlayer::GetTotalJONSCulturePerTurn

; 616  : 	int iOurTourism = m_pPlayer->GetCulture()->GetTourism();

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR _iOurCulture$[esp+48], eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetTourism@CvPlayerCulture@@QAEHXZ	; CvPlayerCulture::GetTourism
	mov	DWORD PTR _iOurTourism$[esp+48], eax

; 617  : 	int iNumCivsBehindCulture = 0;

	mov	DWORD PTR _iNumCivsBehindCulture$[esp+48], ebx

; 618  : 	int iNumCivsAheadCulture = 0;

	mov	DWORD PTR _iNumCivsAheadCulture$[esp+48], ebx

; 619  : 	int iNumCivsBehindTourism = 0;

	mov	DWORD PTR _iNumCivsBehindTourism$[esp+48], ebx

; 620  : 	int iNumCivsAheadTourism = 0;

	mov	DWORD PTR _iNumCivsAheadTourism$[esp+48], ebx

; 621  : 	int iNumCivsAlive = 0;

	mov	DWORD PTR _iNumCivsAlive$[esp+48], ebx

; 622  : 
; 623  : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$224409[esp+48], ebx
	npad	9
$LL10@GetCulture:

; 624  : 	{
; 625  : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 626  : 		CvPlayer &kPlayer = GET_PLAYER(eLoopPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 627  : 
; 628  : 		if (kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian() && iPlayerLoop != m_pPlayer->GetID())

	cmp	BYTE PTR [ebx+eax+2256], 0
	lea	ebp, DWORD PTR [ebx+eax]
	je	SHORT $LN9@GetCulture
	mov	ecx, ebp
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN9@GetCulture
	mov	ecx, ebp
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN9@GetCulture
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _iPlayerLoop$224409[esp+48]
	cmp	edx, DWORD PTR [ecx+44]
	je	SHORT $LN9@GetCulture

; 629  : 		{
; 630  : 			if (iOurCulture > kPlayer.GetTotalJONSCulturePerTurn())

	mov	ecx, ebp
	call	?GetTotalJONSCulturePerTurn@CvPlayer@@QBEHXZ ; CvPlayer::GetTotalJONSCulturePerTurn
	cmp	DWORD PTR _iOurCulture$[esp+48], eax
	jle	SHORT $LN6@GetCulture

; 631  : 			{
; 632  : 				iNumCivsAheadCulture++;

	inc	DWORD PTR _iNumCivsAheadCulture$[esp+48]

; 633  : 			}
; 634  : 			else

	jmp	SHORT $LN5@GetCulture
$LN6@GetCulture:

; 635  : 			{
; 636  : 				iNumCivsBehindCulture++;

	inc	DWORD PTR _iNumCivsBehindCulture$[esp+48]
$LN5@GetCulture:

; 637  : 			}
; 638  : 			if (iOurTourism > kPlayer.GetCulture()->GetTourism())

	mov	ecx, ebp
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetTourism@CvPlayerCulture@@QAEHXZ	; CvPlayerCulture::GetTourism
	cmp	DWORD PTR _iOurTourism$[esp+48], eax
	jle	SHORT $LN4@GetCulture

; 639  : 			{
; 640  : 				iNumCivsAheadTourism++;

	inc	DWORD PTR _iNumCivsAheadTourism$[esp+48]

; 641  : 			}
; 642  : 			else

	jmp	SHORT $LN3@GetCulture
$LN4@GetCulture:

; 643  : 			{
; 644  : 				iNumCivsBehindTourism++;

	inc	DWORD PTR _iNumCivsBehindTourism$[esp+48]
$LN3@GetCulture:

; 645  : 			}
; 646  : 			iNumCivsAlive++;

	inc	DWORD PTR _iNumCivsAlive$[esp+48]
$LN9@GetCulture:

; 622  : 
; 623  : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	inc	DWORD PTR _iPlayerLoop$224409[esp+48]
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 3983868				; 003cc9fcH
	jl	SHORT $LL10@GetCulture

; 647  : 		}
; 648  : 	}
; 649  : 
; 650  : 	if (iNumCivsAlive > 0 && iNumCivsAheadCulture > iNumCivsBehindCulture)

	mov	ecx, DWORD PTR _iNumCivsAlive$[esp+48]
	test	ecx, ecx
	jle	SHORT $LN1@GetCulture
	mov	eax, DWORD PTR _iNumCivsAheadCulture$[esp+48]
	mov	edx, DWORD PTR _iNumCivsBehindCulture$[esp+48]
	cmp	eax, edx
	jle	SHORT $LN2@GetCulture

; 651  : 	{
; 652  : 		iPriority += (GC.getAI_GS_CULTURE_AHEAD_WEIGHT() * (iNumCivsAheadCulture - iNumCivsBehindCulture) / iNumCivsAlive);

	sub	eax, edx
	imul	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1968
	cdq
	idiv	ecx
	add	esi, eax
$LN2@GetCulture:

; 653  : 	}
; 654  : 	if (iNumCivsAlive > 0 && iNumCivsAheadTourism > iNumCivsBehindTourism)

	mov	eax, DWORD PTR _iNumCivsAheadTourism$[esp+48]
	mov	edx, DWORD PTR _iNumCivsBehindTourism$[esp+48]
	cmp	eax, edx
	jle	SHORT $LN1@GetCulture

; 655  : 	{
; 656  : 		iPriority += (GC.getAI_GS_CULTURE_TOURISM_AHEAD_WEIGHT() * (iNumCivsAheadTourism - iNumCivsBehindTourism) / iNumCivsAlive);

	sub	eax, edx
	imul	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1972
	cdq
	idiv	ecx
	add	esi, eax
$LN1@GetCulture:

; 657  : 	}
; 658  : 
; 659  : 	// for every civ we are Influential over increase this
; 660  : 	int iNumInfluential = m_pPlayer->GetCulture()->GetNumCivsInfluentialOn();

	mov	ecx, DWORD PTR [edi]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsInfluentialOn
	mov	ecx, eax

; 661  : 	iPriority += iNumInfluential * GC.getAI_GS_CULTURE_INFLUENTIAL_CIV_MOD();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1976
	imul	eax, ecx
	add	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 662  : 
; 663  : 	return iPriority;
; 664  : }

	add	esp, 32					; 00000020H
	ret	0
$LN11@GetCulture:

; 605  : 	{
; 606  : 		return -100;

	mov	eax, -100				; ffffff9cH
	pop	edi

; 662  : 
; 663  : 	return iPriority;
; 664  : }

	add	esp, 32					; 00000020H
	ret	0
?GetCulturePriority@CvGrandStrategyAI@@QAEHXZ ENDP	; CvGrandStrategyAI::GetCulturePriority
_TEXT	ENDS
PUBLIC	?GetUnitedNationsPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetUnitedNationsPriority
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?CalculateStartingVotesForMember@CvLeague@@QAEHW4PlayerTypes@@_N@Z:PROC ; CvLeague::CalculateStartingVotesForMember
EXTRN	?GetActiveLeague@CvGameLeagues@@QAEPAVCvLeague@@XZ:PROC ; CvGameLeagues::GetActiveLeague
EXTRN	?GetNumActiveLeagues@CvGameLeagues@@QAEHXZ:PROC	; CvGameLeagues::GetNumActiveLeagues
EXTRN	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ:PROC ; CvGame::GetGameLeagues
EXTRN	?GetVotesNeededForDiploVictory@CvGame@@QBEHXZ:PROC ; CvGame::GetVotesNeededForDiploVictory
EXTRN	?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ:PROC	; CvTeam::GetNumMinorCivsAttacked
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitedNationsPriority@CvGrandStrategyAI@@QAEHXZ
_TEXT	SEGMENT
_iVotesControlled$ = -24				; size = 4
_iUnalliedCityStates$ = -20				; size = 4
_ePlayer$ = -16						; size = 4
_iVotesNeededToWin$ = -12				; size = 4
$T228573 = -8						; size = 4
$T228571 = -8						; size = 4
$T228569 = -8						; size = 4
_pLeague$224443 = -8					; size = 4
$T228572 = -4						; size = 4
$T228570 = -4						; size = 4
$T228568 = -4						; size = 4
_this$ = -4						; size = 4
?GetUnitedNationsPriority@CvGrandStrategyAI@@QAEHXZ PROC ; CvGrandStrategyAI::GetUnitedNationsPriority, COMDAT
; _this$ = ecx

; 672  : {

	sub	esp, 24					; 00000018H
	push	ebp
	mov	ebp, ecx

; 673  : 	int iPriority = 0;
; 674  : 	PlayerTypes ePlayer = m_pPlayer->GetID();

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+44]

; 675  : 
; 676  : 	// If UN Victory isn't even available then don't bother with anything
; 677  : 	VictoryTypes eVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_DIPLOMATIC", true);

	push	1
	mov	DWORD PTR _ePlayer$[esp+32], ecx
	push	OFFSET $SG224430
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+36], ebp
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 678  : 	if(eVictory == NO_VICTORY || !GC.getGame().isVictoryValid(eVictory))

	cmp	eax, -1
	je	$LN20@GetUnitedN
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?isVictoryValid@CvGame@@QBE_NW4VictoryTypes@@@Z ; CvGame::isVictoryValid
	test	al, al
	je	$LN20@GetUnitedN

; 681  : 	}
; 682  : 
; 683  : 	int iNumMinorsAttacked = GET_TEAM(GetPlayer()->getTeam()).GetNumMinorCivsAttacked();

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN36@GetUnitedN
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN37@GetUnitedN
$LN36@GetUnitedN:
	or	eax, -1
$LN37@GetUnitedN:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebx
	push	esi
	push	edi
	mov	ecx, eax
	call	?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ	; CvTeam::GetNumMinorCivsAttacked

; 684  : 	iPriority += (iNumMinorsAttacked* /*-30*/ GC.getAI_GRAND_STRATEGY_UN_EACH_MINOR_ATTACKED_WEIGHT());

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1980

; 685  : 
; 686  : 	int iVotesNeededToWin = GC.getGame().GetVotesNeededForDiploVictory();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	imul	ebx, eax
	call	?GetVotesNeededForDiploVictory@CvGame@@QBEHXZ ; CvGame::GetVotesNeededForDiploVictory

; 687  : 
; 688  : 	int iVotesControlled = 0;
; 689  : 	int iVotesControlledDelta = 0;
; 690  : 	int iUnalliedCityStates = 0;
; 691  : #ifdef AUI_LEAGUES_FIX_POSSIBLE_DEALLOCATION_CRASH
; 692  : 	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
; 693  : 	if (pLeague == NULL)
; 694  : #else
; 695  : 	if (GC.getGame().GetGameLeagues()->GetNumActiveLeagues() == 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, eax
	xor	esi, esi
	mov	DWORD PTR _iVotesNeededToWin$[esp+40], edi
	mov	DWORD PTR _iVotesControlled$[esp+40], esi
	mov	DWORD PTR _iUnalliedCityStates$[esp+40], esi
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetNumActiveLeagues@CvGameLeagues@@QAEHXZ ; CvGameLeagues::GetNumActiveLeagues
	test	eax, eax
	jne	SHORT $LN19@GetUnitedN

; 696  : #endif
; 697  : 	{
; 698  : 		// Before leagues kick in, add weight based on flavor
; 699  : 		int iFlavorDiplo =  m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_DIPLOMACY"));

	push	eax
	push	OFFSET $SG224441
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor

; 700  : 		iPriority += (10 - m_pPlayer->GetCurrentEra()) * iFlavorDiplo * 150 / 100;

	mov	ecx, DWORD PTR [ebp]
	mov	edi, eax
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	mov	ecx, 10					; 0000000aH
	sub	ecx, eax
	imul	ecx, edi
	imul	ecx, 150				; 00000096H
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	ebx, eax

; 701  : 	}
; 702  : 	else

	jmp	$LN86@GetUnitedN
$LN19@GetUnitedN:

; 703  : 	{
; 704  : #ifndef AUI_LEAGUES_FIX_POSSIBLE_DEALLOCATION_CRASH
; 705  : 		CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetActiveLeague@CvGameLeagues@@QAEPAVCvLeague@@XZ ; CvGameLeagues::GetActiveLeague
	mov	DWORD PTR _pLeague$224443[esp+40], eax

; 706  : 		CvAssert(pLeague != NULL);
; 707  : 		if (pLeague != NULL)

	test	eax, eax
	je	$LN17@GetUnitedN

; 708  : #endif
; 709  : 		{
; 710  : 			// Votes we control
; 711  : 			iVotesControlled += pLeague->CalculateStartingVotesForMember(ePlayer);

	mov	ecx, DWORD PTR _ePlayer$[esp+40]
	push	0
	push	ecx
	mov	ecx, eax
	call	?CalculateStartingVotesForMember@CvLeague@@QAEHW4PlayerTypes@@_N@Z ; CvLeague::CalculateStartingVotesForMember

; 712  : 
; 713  : 			// Votes other players control
; 714  : 			int iHighestOtherPlayerVotes = 0;

	xor	ebp, ebp

; 715  : 			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	xor	edi, edi
	mov	DWORD PTR _iVotesControlled$[esp+40], eax
	xor	esi, esi
$LL16@GetUnitedN:

; 716  : 			{
; 717  : 				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 718  : 
; 719  : 				if(eLoopPlayer != ePlayer && GET_PLAYER(eLoopPlayer).isAlive())

	cmp	edi, DWORD PTR _ePlayer$[esp+40]
	je	SHORT $LN15@GetUnitedN
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+edx+2256], 0
	lea	ecx, DWORD PTR [esi+edx]
	je	SHORT $LN15@GetUnitedN

; 720  : 				{
; 721  : 					if (GET_PLAYER(eLoopPlayer).isMinorCiv())

	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN12@GetUnitedN

; 722  : 					{
; 723  : 						if (GET_PLAYER(eLoopPlayer).GetMinorCivAI()->GetAlly() == NO_PLAYER)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, -1
	jne	SHORT $LN15@GetUnitedN

; 724  : 						{
; 725  : 							iUnalliedCityStates++;

	inc	DWORD PTR _iUnalliedCityStates$[esp+40]

; 726  : 						}
; 727  : 					}
; 728  : 					else

	jmp	SHORT $LN15@GetUnitedN
$LN12@GetUnitedN:

; 729  : 					{
; 730  : 						int iOtherPlayerVotes = pLeague->CalculateStartingVotesForMember(eLoopPlayer);

	mov	ecx, DWORD PTR _pLeague$224443[esp+40]
	push	0
	push	edi
	call	?CalculateStartingVotesForMember@CvLeague@@QAEHW4PlayerTypes@@_N@Z ; CvLeague::CalculateStartingVotesForMember

; 731  : 						if (iOtherPlayerVotes > iHighestOtherPlayerVotes)

	cmp	eax, ebp
	jle	SHORT $LN15@GetUnitedN

; 732  : 						{
; 733  : 							iHighestOtherPlayerVotes = iOtherPlayerVotes;

	mov	ebp, eax
$LN15@GetUnitedN:

; 715  : 			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 3983868				; 003cc9fcH
	jl	SHORT $LL16@GetUnitedN

; 734  : 						}
; 735  : 					}
; 736  : 				}
; 737  : 			}
; 738  : 
; 739  : 			// How we compare
; 740  : 			iVotesControlledDelta = iVotesControlled - iHighestOtherPlayerVotes;

	mov	esi, DWORD PTR _iVotesControlled$[esp+40]
	sub	esi, ebp
	mov	ebp, DWORD PTR _this$[esp+40]
$LN86@GetUnitedN:
	mov	edi, DWORD PTR _iVotesNeededToWin$[esp+40]
$LN17@GetUnitedN:

; 741  : 		}
; 742  : 	}
; 743  : 
; 744  : 	// Are we close to winning?
; 745  : 	if (iVotesControlled >= iVotesNeededToWin)

	mov	ecx, DWORD PTR _iVotesControlled$[esp+40]
	cmp	ecx, edi
	jl	SHORT $LN8@GetUnitedN
	pop	edi
	pop	esi
	pop	ebx

; 746  : 	{
; 747  : 		return 1000;

	mov	eax, 1000				; 000003e8H
	pop	ebp

; 781  : }

	add	esp, 24					; 00000018H
	ret	0
$LN8@GetUnitedN:

; 748  : 	}
; 749  : 	else if (iVotesControlled >= ((iVotesNeededToWin * 3) / 4))

	lea	eax, DWORD PTR [edi+edi*2]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	ecx, eax
	jl	SHORT $LN6@GetUnitedN

; 750  : 	{
; 751  : 		iPriority += 40;

	add	ebx, 40					; 00000028H
$LN6@GetUnitedN:

; 752  : 	}
; 753  : 
; 754  : 	// We have the most votes
; 755  : 	if (iVotesControlledDelta > 0)

	test	esi, esi
	jle	SHORT $LN5@GetUnitedN

; 756  : 	{
; 757  : 		iPriority += MAX(40, iVotesControlledDelta * 5);

	lea	eax, DWORD PTR [esi+esi*4]
	mov	DWORD PTR $T228568[esp+40], eax
	cmp	eax, 40					; 00000028H
	mov	DWORD PTR $T228569[esp+40], 40		; 00000028H
	lea	eax, DWORD PTR $T228568[esp+40]
	jg	SHORT $LN72@GetUnitedN

; 758  : 	}
; 759  : 	// We are equal or behind in votes
; 760  : 	else

	jmp	SHORT $LN71@GetUnitedN
$LN5@GetUnitedN:

; 761  : 	{
; 762  : 		// Could we make up the difference with currently unallied city-states?
; 763  : 		int iPotentialCityStateVotes = iUnalliedCityStates * 2;
; 764  : 		int iPotentialVotesDelta = iPotentialCityStateVotes + iVotesControlledDelta;

	mov	ecx, DWORD PTR _iUnalliedCityStates$[esp+40]
	lea	eax, DWORD PTR [esi+ecx*2]

; 765  : 		if (iPotentialVotesDelta > 0)

	test	eax, eax
	jle	SHORT $LN87@GetUnitedN

; 766  : 		{
; 767  : 			iPriority += MAX(20, iPotentialVotesDelta * 5);

	lea	eax, DWORD PTR [eax+eax*4]
	mov	DWORD PTR $T228570[esp+40], eax
	cmp	eax, 20					; 00000014H
	mov	DWORD PTR $T228571[esp+40], 20		; 00000014H
	lea	eax, DWORD PTR $T228570[esp+40]
	jg	SHORT $LN72@GetUnitedN
	jmp	SHORT $LN71@GetUnitedN
$LN87@GetUnitedN:

; 768  : 		}
; 769  : 		else if (iPotentialVotesDelta < 0)

	jge	SHORT $LN1@GetUnitedN

; 770  : 		{
; 771  : 			iPriority += MIN(-40, iPotentialVotesDelta * -5);

	mov	ecx, eax
	neg	ecx
	add	ecx, ecx
	add	ecx, ecx
	sub	ecx, eax
	cmp	ecx, -40				; ffffffd8H
	mov	DWORD PTR $T228572[esp+40], ecx
	mov	DWORD PTR $T228573[esp+40], -40		; ffffffd8H
	lea	eax, DWORD PTR $T228572[esp+40]
	jl	SHORT $LN72@GetUnitedN
$LN71@GetUnitedN:
	lea	eax, DWORD PTR $T228573[esp+40]
$LN72@GetUnitedN:
	add	ebx, DWORD PTR [eax]
$LN1@GetUnitedN:

; 772  : 		}
; 773  : 	}
; 774  : 
; 775  : 	// factor in some traits that could be useful (or harmful)
; 776  : 	iPriority += m_pPlayer->GetPlayerTraits()->GetCityStateFriendshipModifier();

	mov	ecx, DWORD PTR [ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 777  : 	iPriority += m_pPlayer->GetPlayerTraits()->GetCityStateBonusModifier();

	mov	ecx, DWORD PTR [ebp]
	mov	esi, DWORD PTR [eax+92]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 778  : 	iPriority -= m_pPlayer->GetPlayerTraits()->GetCityStateCombatModifier();

	mov	ecx, DWORD PTR [ebp]
	mov	edi, DWORD PTR [eax+88]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax

; 779  : 
; 780  : 	return iPriority;

	mov	eax, edi
	sub	eax, DWORD PTR [ecx+96]
	pop	edi
	add	eax, esi
	pop	esi
	add	eax, ebx
	pop	ebx
	pop	ebp

; 781  : }

	add	esp, 24					; 00000018H
	ret	0
$LN20@GetUnitedN:

; 679  : 	{
; 680  : 		return -100;

	mov	eax, -100				; ffffff9cH
	pop	ebp

; 781  : }

	add	esp, 24					; 00000018H
	ret	0
?GetUnitedNationsPriority@CvGrandStrategyAI@@QAEHXZ ENDP ; CvGrandStrategyAI::GetUnitedNationsPriority
_TEXT	ENDS
PUBLIC	?GetSpaceshipPriority@CvGrandStrategyAI@@QAEHXZ	; CvGrandStrategyAI::GetSpaceshipPriority
EXTRN	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z:PROC ; CvTeam::getProjectCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpaceshipPriority@CvGrandStrategyAI@@QAEHXZ
_TEXT	SEGMENT
?GetSpaceshipPriority@CvGrandStrategyAI@@QAEHXZ PROC	; CvGrandStrategyAI::GetSpaceshipPriority, COMDAT
; _this$ = ecx

; 789  : {

	push	edi

; 790  : 	int iPriority = 0;
; 791  : 
; 792  : 	// If SS Victory isn't even available then don't bother with anything
; 793  : 	VictoryTypes eVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_SPACE_RACE", true);

	push	1
	mov	edi, ecx
	push	OFFSET $SG224485
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 794  : 	if(eVictory == NO_VICTORY || !GC.getGame().isVictoryValid(eVictory))

	cmp	eax, -1
	je	$LN3@GetSpacesh
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?isVictoryValid@CvGame@@QBE_NW4VictoryTypes@@@Z ; CvGame::isVictoryValid
	test	al, al
	je	$LN3@GetSpacesh
	push	esi

; 797  : 	}
; 798  : 
; 799  : 	int iFlavorScience =  m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_SCIENCE"));

	push	0
	push	OFFSET $SG224490
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor

; 800  : 
; 801  : 	// the later the game the greater the chance
; 802  : 	iPriority += m_pPlayer->GetCurrentEra() * iFlavorScience * 150 / 100;

	mov	ecx, DWORD PTR [edi]
	mov	esi, eax
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	mov	ecx, eax
	imul	ecx, esi
	imul	ecx, 150				; 00000096H
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	esi, edx

; 803  : 
; 804  : 	// if I already built the Apollo Program I am very likely to follow through
; 805  : 	ProjectTypes eApolloProgram = (ProjectTypes) GC.getInfoTypeForString("PROJECT_APOLLO_PROGRAM", true);

	push	1
	shr	esi, 31					; 0000001fH
	push	OFFSET $SG224493
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	add	esi, edx
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 806  : 	if(eApolloProgram != NO_PROJECT)

	cmp	eax, -1
	je	SHORT $LN1@GetSpacesh

; 807  : 	{
; 808  : 		if(GET_TEAM(m_pPlayer->getTeam()).getProjectCount(eApolloProgram) > 0)

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN13@GetSpacesh
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN14@GetSpacesh
$LN13@GetSpacesh:
	or	ecx, -1
$LN14@GetSpacesh:
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	test	eax, eax
	jle	SHORT $LN1@GetSpacesh

; 809  : 		{
; 810  : 			iPriority += /*150*/ GC.getAI_GS_SS_HAS_APOLLO_PROGRAM();

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1988
$LN1@GetSpacesh:

; 811  : 		}
; 812  : 	}
; 813  : 
; 814  : 	return iPriority;

	mov	eax, esi
	pop	esi
	pop	edi

; 815  : }

	ret	0
$LN3@GetSpacesh:

; 795  : 	{
; 796  : 		return -100;

	mov	eax, -100				; ffffff9cH
	pop	edi

; 815  : }

	ret	0
?GetSpaceshipPriority@CvGrandStrategyAI@@QAEHXZ ENDP	; CvGrandStrategyAI::GetSpaceshipPriority
_TEXT	ENDS
PUBLIC	?GetGuessOtherPlayerUnitedNationsPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@@Z ; CvGrandStrategyAI::GetGuessOtherPlayerUnitedNationsPriority
EXTRN	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsFriends
EXTRN	?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsAllies
; Function compile flags: /Ogtpy
;	COMDAT ?GetGuessOtherPlayerUnitedNationsPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iTheirCityStateFriends$ = -12				; size = 4
_iTheirCityStateAllies$ = -8				; size = 4
_iCityStatesAlive$ = -4					; size = 4
$T228747 = 8						; size = 4
_ePlayer$ = 8						; size = 4
?GetGuessOtherPlayerUnitedNationsPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@@Z PROC ; CvGrandStrategyAI::GetGuessOtherPlayerUnitedNationsPriority, COMDAT
; _this$ = ecx

; 1167 : {

	sub	esp, 12					; 0000000cH

; 1168 : 	VictoryTypes eVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_DIPLOMATIC", true);

	push	1
	push	OFFSET $SG224878
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1169 : 
; 1170 : 	// If UN Victory isn't even available then don't bother with anything
; 1171 : 	if(eVictory == NO_VICTORY)

	cmp	eax, -1
	jne	SHORT $LN8@GetGuessOt@3

; 1172 : 	{
; 1173 : 		return -100;

	mov	eax, -100				; ffffff9cH

; 1201 : 
; 1202 : 	return iPriority;
; 1203 : }

	add	esp, 12					; 0000000cH
	ret	4
$LN8@GetGuessOt@3:
	push	ebx
	push	ebp
	push	esi

; 1174 : 	}
; 1175 : 
; 1176 : 	int iTheirCityStateAllies = 0;

	xor	esi, esi

; 1177 : 	int iTheirCityStateFriends = 0;
; 1178 : 	int iCityStatesAlive = 0;

	xor	ebp, ebp
	push	edi
	mov	edi, DWORD PTR _ePlayer$[esp+24]
	mov	DWORD PTR _iTheirCityStateAllies$[esp+28], esi
	mov	DWORD PTR _iTheirCityStateFriends$[esp+28], esi
	mov	DWORD PTR _iCityStatesAlive$[esp+28], ebp

; 1179 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	xor	ebx, ebx
	npad	2
$LL7@GetGuessOt@3:

; 1180 : 	{
; 1181 : 		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 1182 : 
; 1183 : 		if (eLoopPlayer != ePlayer && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMinorCiv())

	cmp	ebx, edi
	je	SHORT $LN6@GetGuessOt@3
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN6@GetGuessOt@3
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN6@GetGuessOt@3

; 1186 : 			if (GET_PLAYER(eLoopPlayer).GetMinorCivAI()->IsAllies(ePlayer))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	push	edi
	inc	ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAllies
	test	al, al
	je	SHORT $LN3@GetGuessOt@3

; 1187 : 			{
; 1188 : 				iTheirCityStateAllies++;

	inc	DWORD PTR _iTheirCityStateAllies$[esp+28]
	jmp	SHORT $LN6@GetGuessOt@3
$LN3@GetGuessOt@3:

; 1189 : 			}
; 1190 : 			else if (GET_PLAYER(eLoopPlayer).GetMinorCivAI()->IsFriends(ePlayer))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]
	push	edi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al
	je	SHORT $LN6@GetGuessOt@3

; 1191 : 			{
; 1192 : 				iTheirCityStateFriends++;

	inc	DWORD PTR _iTheirCityStateFriends$[esp+28]
$LN6@GetGuessOt@3:

; 1179 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	add	esi, 63236				; 0000f704H
	inc	ebx
	cmp	esi, 3983868				; 003cc9fcH
	jl	SHORT $LL7@GetGuessOt@3
	pop	edi
	pop	esi

; 1184 : 		{
; 1185 : 			iCityStatesAlive++;

	mov	DWORD PTR _iCityStatesAlive$[esp+20], ebp

; 1193 : 			}
; 1194 : 		}
; 1195 : 	}
; 1196 : 	iCityStatesAlive = MAX(iCityStatesAlive, 1);

	cmp	ebp, 1
	pop	ebp
	mov	DWORD PTR $T228747[esp+12], 1
	pop	ebx
	lea	eax, DWORD PTR $T228747[esp+8]
	jl	SHORT $LN26@GetGuessOt@3
	lea	eax, DWORD PTR _iCityStatesAlive$[esp+12]
$LN26@GetGuessOt@3:
	mov	ecx, DWORD PTR [eax]

; 1197 : 
; 1198 : 	int iPriority = iTheirCityStateAllies + (iTheirCityStateFriends / 3);

	mov	eax, 1431655766				; 55555556H
	imul	DWORD PTR _iTheirCityStateFriends$[esp+12]
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	eax, DWORD PTR _iTheirCityStateAllies$[esp+12]

; 1199 : 	iPriority = iPriority * GC.getAI_GS_UN_SECURED_VOTE_MOD();

	imul	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1984

; 1200 : 	iPriority = iPriority / iCityStatesAlive;

	cdq
	idiv	ecx

; 1201 : 
; 1202 : 	return iPriority;
; 1203 : }

	add	esp, 12					; 0000000cH
	ret	4
?GetGuessOtherPlayerUnitedNationsPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvGrandStrategyAI::GetGuessOtherPlayerUnitedNationsPriority
_TEXT	ENDS
PUBLIC	?GetGuessOtherPlayerSpaceshipPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@H@Z ; CvGrandStrategyAI::GetGuessOtherPlayerSpaceshipPriority
EXTRN	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ:PROC	; CvTeamTechs::GetNumTechsKnown
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetGuessOtherPlayerSpaceshipPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iWorldNumTechsAverage$ = 12				; size = 4
?GetGuessOtherPlayerSpaceshipPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@H@Z PROC ; CvGrandStrategyAI::GetGuessOtherPlayerSpaceshipPriority, COMDAT
; _this$ = ecx

; 1208 : 	VictoryTypes eVictory = (VictoryTypes) GC.getInfoTypeForString("VICTORY_SPACE_RACE", true);

	push	1
	push	OFFSET $SG224902
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1209 : 
; 1210 : 	// If SS Victory isn't even available then don't bother with anything
; 1211 : 	if(eVictory == NO_VICTORY)

	cmp	eax, -1
	jne	SHORT $LN4@GetGuessOt@4

; 1212 : 	{
; 1213 : 		return -100;

	mov	eax, -100				; ffffff9cH

; 1235 : 
; 1236 : 	return iSSPriority;
; 1237 : }

	ret	8
$LN4@GetGuessOt@4:

; 1214 : 	}
; 1215 : 
; 1216 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	push	esi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN13@GetGuessOt@4
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN14@GetGuessOt@4
$LN13@GetGuessOt@4:
	or	esi, -1
$LN14@GetGuessOt@4:

; 1217 : 
; 1218 : 	// If the player has the Apollo Program we're pretty sure he's going for the SS
; 1219 : 	ProjectTypes eApolloProgram = (ProjectTypes) GC.getInfoTypeForString("PROJECT_APOLLO_PROGRAM", true);

	push	1
	push	OFFSET $SG224907
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1220 : 	if(eApolloProgram != NO_PROJECT)

	cmp	eax, -1
	je	SHORT $LN2@GetGuessOt@4

; 1221 : 	{
; 1222 : 		if(GET_TEAM(eTeam).getProjectCount(eApolloProgram) > 0)

	mov	ecx, esi
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	test	eax, eax
	jle	SHORT $LN2@GetGuessOt@4

; 1223 : 		{
; 1224 : 			return /*150*/ GC.getAI_GS_SS_HAS_APOLLO_PROGRAM();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1988
	pop	esi

; 1235 : 
; 1236 : 	return iSSPriority;
; 1237 : }

	ret	8
$LN2@GetGuessOt@4:

; 1225 : 		}
; 1226 : 	}
; 1227 : 
; 1228 : 	int iNumTechs = GET_TEAM(eTeam).GetTeamTechs()->GetNumTechsKnown();

	imul	esi, 2980				; 00000ba4H
	add	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, esi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ	; CvTeamTechs::GetNumTechsKnown

; 1229 : 
; 1230 : 	// Don't divide by zero, okay?
; 1231 : 	if(iWorldNumTechsAverage == 0)

	mov	ecx, DWORD PTR _iWorldNumTechsAverage$[esp]
	test	ecx, ecx
	jne	SHORT $LN1@GetGuessOt@4

; 1232 : 		iWorldNumTechsAverage = 1;

	mov	ecx, 1
$LN1@GetGuessOt@4:

; 1233 : 
; 1234 : 	int iSSPriority = (iNumTechs - iWorldNumTechsAverage) * /*300*/ GC.getAI_GS_SS_TECH_PROGRESS_MOD() / iWorldNumTechsAverage;

	sub	eax, ecx
	imul	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1992
	cdq
	idiv	ecx
	pop	esi

; 1235 : 
; 1236 : 	return iSSPriority;
; 1237 : }

	ret	8
?GetGuessOtherPlayerSpaceshipPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@H@Z ENDP ; CvGrandStrategyAI::GetGuessOtherPlayerSpaceshipPriority
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@XZ ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@XZ PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@XZ ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@XZ ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@XZ PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@XZ ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::end
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@H$04$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,5,1,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@H$04$00$0BCJ@$0A@@@QAEIABH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@H$04$00$0BCJ@$0A@@@QAEIABH@Z PROC ; FStaticVector<int,5,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+32], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,5,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@H$04$00$0BCJ@$0A@@@QAEIABH@Z ENDP ; FStaticVector<int,5,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?clear@?$CvWeightedVector@H$04$00@@QAEXXZ	; CvWeightedVector<int,5,1>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?clear@?$CvWeightedVector@H$04$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$CvWeightedVector@H$04$00@@QAEXXZ PROC		; CvWeightedVector<int,5,1>::clear, COMDAT
; _this$ = ecx

; 116  : 		m_pItems.clear();

	mov	DWORD PTR [ecx+4], 0

; 117  : 	};

	ret	0
?clear@?$CvWeightedVector@H$04$00@@QAEXXZ ENDP		; CvWeightedVector<int,5,1>::clear
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvAIGrandStrategyXMLEntry@@@std@@YAPAPAVCvAIGrandStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvAIGrandStrategyXMLEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::~FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::~FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::~FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAEXPAPAVCvAIGrandStrategyXMLEntry@@0@Z ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAEXPAPAVCvAIGrandStrategyXMLEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAEXPAPAVCvAIGrandStrategyXMLEntry@@0@Z PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAEXPAPAVCvAIGrandStrategyXMLEntry@@0@Z ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize@2
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@2
	npad	6
$LL8@GrowSize@2:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@2

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@2

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@2
$LN34@GrowSize@2:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@2:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 5
	jbe	SHORT $LN16@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@2
$LN16@GrowSize@2:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 5
$LN15@GrowSize@2:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+52], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ; std::_Median<CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z PROC ; std::_Median<CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ; std::_Med3<CvWeightedVector<int,5,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ; std::_Med3<CvWeightedVector<int,5,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ; std::_Med3<CvWeightedVector<int,5,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ; std::_Med3<CvWeightedVector<int,5,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ; std::_Med3<CvWeightedVector<int,5,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ENDP ; std::_Median<CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	npad	3
$LL2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$04$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$04$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$04$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_
	push	ebx
	push	esi
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_
	npad	7
$LL22@Insertion_:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_
$LN21@Insertion_:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_
	pop	esi
	pop	ebx
$LN6@Insertion_:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$04$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$04$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$04$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$04$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$04$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@H$04$00@@QAE@XZ		; CvWeightedVector<int,5,1>::CvWeightedVector<int,5,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@H$04$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@H$04$00@@QAE@XZ PROC		; CvWeightedVector<int,5,1>::CvWeightedVector<int,5,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 5
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@H$04$00@@QAE@XZ ENDP		; CvWeightedVector<int,5,1>::CvWeightedVector<int,5,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@H$04$00@@QAE@XZ		; CvWeightedVector<int,5,1>::~CvWeightedVector<int,5,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@H$04$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@H$04$00@@QAE@XZ PROC		; CvWeightedVector<int,5,1>::~CvWeightedVector<int,5,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@H$04$00@@QAE@XZ ENDP		; CvWeightedVector<int,5,1>::~CvWeightedVector<int,5,1>
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@0@Z ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@0@Z PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@2@0@Z ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$04$00@@@Z ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$04$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$04$00@@@Z PROC ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+52], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::GrowSize
$LN1@push_back@2:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@2
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$04$00@@@Z ENDP ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z
_TEXT	SEGMENT
__Tmp$229472 = -24					; size = 8
__Tmp$229401 = -16					; size = 8
__Tmp$229427 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ; std::_Median<CvWeightedVector<int,5,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_
	npad	6
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$229401[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$229401[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$229427[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$229427[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_
$LN111@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$229472[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$229472[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$229472[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$229472[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::make_heap<CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z PROC ; std::make_heap<CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$04$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::pop_heap<CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::~vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::~vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::~vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEXXZ ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::clear
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@H$04$00@@QAEIABHH@Z ; CvWeightedVector<int,5,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@H$04$00@@QAEIABHH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@H$04$00@@QAEIABHH@Z PROC	; CvWeightedVector<int,5,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+52], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@3
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::GrowSize
$LN5@push_back@3:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@3
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@3:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@H$04$00@@QAEIABHH@Z ENDP	; CvWeightedVector<int,5,1>::push_back
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap
$LN24@Sort_heap:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??0CvAIGrandStrategyXMLEntries@@QAE@XZ		; CvAIGrandStrategyXMLEntries::CvAIGrandStrategyXMLEntries
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
;	COMDAT ??0CvAIGrandStrategyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvAIGrandStrategyXMLEntries@@QAE@XZ PROC		; CvAIGrandStrategyXMLEntries::CvAIGrandStrategyXMLEntries, COMDAT
; _this$ = ecx

; 91   : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 92   : 
; 93   : }

	ret	0
??0CvAIGrandStrategyXMLEntries@@QAE@XZ ENDP		; CvAIGrandStrategyXMLEntries::CvAIGrandStrategyXMLEntries
_TEXT	ENDS
PUBLIC	?DeleteArray@CvAIGrandStrategyXMLEntries@@QAEXXZ ; CvAIGrandStrategyXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteArray@CvAIGrandStrategyXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvAIGrandStrategyXMLEntries@@QAEXXZ PROC	; CvAIGrandStrategyXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 119  : {

	push	esi
	push	edi
	mov	edi, ecx

; 120  : 	for(std::vector<CvAIGrandStrategyXMLEntry*>::iterator it = m_paAIGrandStrategyEntries.begin(); it != m_paAIGrandStrategyEntries.end(); ++it)

	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@DeleteArra
	npad	4
$LL14@DeleteArra:

; 121  : 	{
; 122  : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@DeleteArra
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 123  : 	}
; 124  : 
; 125  : 	m_paAIGrandStrategyEntries.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@DeleteArra:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@DeleteArra:
	pop	edi
	pop	esi

; 126  : }

	ret	0
?DeleteArray@CvAIGrandStrategyXMLEntries@@QAEXXZ ENDP	; CvAIGrandStrategyXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::sort_heap<CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,5,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??1CvAIGrandStrategyXMLEntries@@QAE@XZ		; CvAIGrandStrategyXMLEntries::~CvAIGrandStrategyXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvAIGrandStrategyXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvAIGrandStrategyXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvAIGrandStrategyXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvAIGrandStrategyXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
xdata$x	ENDS
;	COMDAT ??1CvAIGrandStrategyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvAIGrandStrategyXMLEntries@@QAE@XZ PROC		; CvAIGrandStrategyXMLEntries::~CvAIGrandStrategyXMLEntries, COMDAT
; _this$ = ecx

; 97   : {

	push	-1
	push	__ehhandler$??1CvAIGrandStrategyXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 98   : 	DeleteArray();

	call	?DeleteArray@CvAIGrandStrategyXMLEntries@@QAEXXZ ; CvAIGrandStrategyXMLEntries::DeleteArray

; 99   : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvAIGrandS
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvAIGrandS:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvAIGrandStrategyXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::~vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >
__ehhandler$??1CvAIGrandStrategyXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvAIGrandStrategyXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvAIGrandStrategyXMLEntries@@QAE@XZ ENDP		; CvAIGrandStrategyXMLEntries::~CvAIGrandStrategyXMLEntries
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0H@Z ; std::_Sort<CvWeightedVector<int,5,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0H@Z
_TEXT	SEGMENT
__Mid$225474 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,5,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$225474[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$04$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,5,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$225474[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$225474[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0H@Z ; std::_Sort<CvWeightedVector<int,5,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0H@Z ; std::_Sort<CvWeightedVector<int,5,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$225474[esp+36]
$LN26@Sort:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN25@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$04$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,5,1>::WeightedElement *,CvWeightedVector<int,5,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,5,1>::WeightedElement *,int,CvWeightedVector<int,5,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,5,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,5,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ; std::sort<CvWeightedVector<int,5,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z PROC ; std::sort<CvWeightedVector<int,5,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0H@Z ; std::_Sort<CvWeightedVector<int,5,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0@Z ENDP ; std::sort<CvWeightedVector<int,5,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@H$04$00@@QAEXXZ	; CvWeightedVector<int,5,1>::SortItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@H$04$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@H$04$00@@QAEXXZ PROC	; CvWeightedVector<int,5,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0H@Z ; std::_Sort<CvWeightedVector<int,5,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@H$04$00@@QAEXXZ ENDP	; CvWeightedVector<int,5,1>::SortItems
_TEXT	ENDS
PUBLIC	?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ ; CvGrandStrategyAI::DoGuessOtherPlayersActiveGrandStrategy
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ$3
__ehfuncinfo$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
xdata$x	ENDS
;	COMDAT ?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ
_TEXT	SEGMENT
_elem$230798 = -196					; size = 8
_iPriority$ = -196					; size = 4
tv1327 = -188						; size = 4
_vGrandStrategyPrioritiesForLogging$ = -184		; size = 36
_iWorldTourismAverage$ = -148				; size = 4
_iWorldNumTechsAverage$ = -144				; size = 4
_iWorldMilitaryAverage$ = -140				; size = 4
_iWorldCultureAverage$ = -136				; size = 4
_pTeam$ = -132						; size = 4
_this$ = -128						; size = 4
_vGrandStrategyPriorities$ = -124			; size = 56
_strGrandStrategyName$ = -68				; size = 28
$T230388 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ PROC ; CvGrandStrategyAI::DoGuessOtherPlayersActiveGrandStrategy, COMDAT
; _this$ = ecx

; 933  : {

	push	-1
	push	__ehhandler$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 184				; 000000b8H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 934  : 	CvWeightedVector<int, 5, true> vGrandStrategyPriorities;

	xor	esi, esi
	mov	eax, 5
	lea	ecx, DWORD PTR _vGrandStrategyPriorities$[esp+224]
	mov	DWORD PTR _this$[esp+212], edi
	mov	DWORD PTR _vGrandStrategyPriorities$[esp+216], esi
	mov	DWORD PTR _vGrandStrategyPriorities$[esp+220], eax
	mov	DWORD PTR _vGrandStrategyPriorities$[esp+212], ecx

; 935  : 	FStaticVector< int, 5, true, c_eCiv5GameplayDLL >  vGrandStrategyPrioritiesForLogging;

	lea	edx, DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+224]
	mov	DWORD PTR __$EHRec$[esp+220], esi
	mov	DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+216], esi
	mov	DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+220], eax
	mov	DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+212], edx

; 936  : 
; 937  : 	GuessConfidenceTypes eGuessConfidence = NO_GUESS_CONFIDENCE_TYPE;
; 938  : 
; 939  : #ifdef AUI_WARNING_FIXES
; 940  : 	uint iGrandStrategiesLoop = 0;
; 941  : #else
; 942  : 	int iGrandStrategiesLoop = 0;
; 943  : #endif
; 944  : 	AIGrandStrategyTypes eGrandStrategy = NO_AIGRANDSTRATEGY;
; 945  : 	CvAIGrandStrategyXMLEntry* pGrandStrategy = 0;
; 946  : 	CvString strGrandStrategyName;

	lea	ecx, DWORD PTR _strGrandStrategyName$[esp+212]
	mov	BYTE PTR __$EHRec$[esp+220], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 947  : 
; 948  : 	CvTeam& pTeam = GET_TEAM(GetPlayer()->getTeam());

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+44]
	mov	BYTE PTR __$EHRec$[esp+220], 2
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN64@DoGuessOth
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN65@DoGuessOth
$LN64@DoGuessOth:
	or	eax, -1
$LN65@DoGuessOth:

; 949  : 
; 950  : 	int iMajorLoop = 0;
; 951  : 	PlayerTypes eMajor = NO_PLAYER;
; 952  : 
; 953  : 	int iPriority = 0;
; 954  : 
; 955  : 	// Establish world Military strength average
; 956  : 	int iWorldMilitaryAverage = GC.getGame().GetWorldMilitaryStrengthAverage(GetPlayer()->GetID(), true, true);

	mov	ecx, DWORD PTR [ecx+44]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	1
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _pTeam$[esp+224], eax
	mov	DWORD PTR _iPriority$[esp+224], esi
	call	?GetWorldMilitaryStrengthAverage@CvGame@@QAEHW4PlayerTypes@@_N1@Z ; CvGame::GetWorldMilitaryStrengthAverage

; 957  : 
; 958  : 	// Establish world culture and tourism averages
; 959  : 	int iNumPlayersAlive = 0;

	xor	edi, edi

; 960  : 	int iWorldCultureAverage = 0;

	xor	ebp, ebp
	mov	DWORD PTR _iWorldMilitaryAverage$[esp+212], eax

; 961  : 	int iWorldTourismAverage = 0;

	xor	ebx, ebx
	npad	4
$LL29@DoGuessOth:

; 962  : 	for(iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
; 963  : 	{
; 964  : 		eMajor = (PlayerTypes) iMajorLoop;
; 965  : 
; 966  : 		if(GET_PLAYER(eMajor).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN28@DoGuessOth

; 967  : 		{
; 968  : 			iWorldCultureAverage += GET_PLAYER(eMajor).GetJONSCultureEverGenerated();

	call	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ ; CvPlayer::GetJONSCultureEverGenerated

; 969  : 			iWorldTourismAverage += GET_PLAYER(eMajor).GetCulture()->GetTourism();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	add	ebp, eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetTourism@CvPlayerCulture@@QAEHXZ	; CvPlayerCulture::GetTourism
	add	ebx, eax

; 970  : 			iNumPlayersAlive++;

	inc	edi
$LN28@DoGuessOth:
	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL29@DoGuessOth

; 971  : 		}
; 972  : 	}
; 973  : 	iWorldCultureAverage /= iNumPlayersAlive;

	mov	eax, ebp
	cdq
	idiv	edi
	mov	DWORD PTR _iWorldCultureAverage$[esp+212], eax

; 974  : 	iWorldTourismAverage /= iNumPlayersAlive;

	mov	eax, ebx
	cdq
	idiv	edi

; 975  : 
; 976  : 	// Establish world Tech progress average
; 977  : 	iNumPlayersAlive = 0;

	xor	ebx, ebx

; 978  : 	int iWorldNumTechsAverage = 0;

	xor	edi, edi
	xor	esi, esi
	mov	DWORD PTR _iWorldTourismAverage$[esp+212], eax
	npad	10
$LL25@DoGuessOth:

; 979  : 	TeamTypes eTeam;
; 980  : 	for(int iTeamLoop = 0; iTeamLoop < MAX_MAJOR_CIVS; iTeamLoop++)	// Looping over all MAJOR teams
; 981  : 	{
; 982  : 		eTeam = (TeamTypes) iTeamLoop;
; 983  : 
; 984  : 		if(GET_TEAM(eTeam).isAlive())

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [esi+edx+12], 0
	lea	ecx, DWORD PTR [esi+edx]
	jle	SHORT $LN24@DoGuessOth

; 985  : 		{
; 986  : 			iWorldNumTechsAverage += GET_TEAM(eTeam).GetTeamTechs()->GetNumTechsKnown();

	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ	; CvTeamTechs::GetNumTechsKnown
	add	edi, eax

; 987  : 			iNumPlayersAlive++;

	inc	ebx
$LN24@DoGuessOth:
	add	esi, 2980				; 00000ba4H
	cmp	esi, 65560				; 00010018H
	jl	SHORT $LL25@DoGuessOth

; 988  : 		}
; 989  : 	}
; 990  : 	iWorldNumTechsAverage /= iNumPlayersAlive;

	mov	eax, edi
	cdq
	idiv	ebx

; 991  : 
; 992  : 	// Look at every Major we've met
; 993  : 	for(iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	xor	ebp, ebp
	xor	ebx, ebx
	xor	esi, esi
	mov	DWORD PTR tv1327[esp+212], esi
	mov	DWORD PTR _iWorldNumTechsAverage$[esp+212], eax
$LL21@DoGuessOth:

; 994  : 	{
; 995  : 		eMajor = (PlayerTypes) iMajorLoop;
; 996  : 
; 997  : 		if(GET_PLAYER(eMajor).isAlive() && iMajorLoop != GetPlayer()->GetID())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+ecx+2256], 0
	je	$LN20@DoGuessOth
	mov	edi, DWORD PTR _this$[esp+212]
	mov	eax, DWORD PTR [edi]
	cmp	ebp, DWORD PTR [eax+44]
	je	$LN20@DoGuessOth

; 998  : 		{
; 999  : 			if(pTeam.isHasMet(GET_PLAYER(eMajor).getTeam()))

	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN113@DoGuessOth
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN114@DoGuessOth
$LN113@DoGuessOth:
	or	eax, -1
$LN114@DoGuessOth:
	mov	ecx, DWORD PTR _pTeam$[esp+212]
	push	eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN20@DoGuessOth

; 1000 : 			{
; 1001 : 				for(iGrandStrategiesLoop = 0; iGrandStrategiesLoop < GetAIGrandStrategies()->GetNumAIGrandStrategies(); iGrandStrategiesLoop++)

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	xor	esi, esi
	test	ecx, -4					; fffffffcH
	jle	$LN274@DoGuessOth
	npad	10
$LL16@DoGuessOth:

; 1002 : 				{
; 1003 : 					eGrandStrategy = (AIGrandStrategyTypes) iGrandStrategiesLoop;
; 1004 : 					pGrandStrategy = GetAIGrandStrategies()->GetEntry(iGrandStrategiesLoop);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+esi*4]

; 1005 : 					strGrandStrategyName = (CvString) pGrandStrategy->GetType();

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	cmp	eax, ebx
	jne	SHORT $LN135@DoGuessOth
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN135@DoGuessOth:
	push	eax
	lea	ecx, DWORD PTR $T230388[esp+216]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T230388[esp+212]
	push	eax
	lea	ecx, DWORD PTR _strGrandStrategyName$[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 3
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230388[esp+212]
	mov	BYTE PTR __$EHRec$[esp+220], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1006 : 
; 1007 : 					if(strGrandStrategyName == "AIGRANDSTRATEGY_CONQUEST")

	lea	ecx, DWORD PTR _strGrandStrategyName$[esp+212]
	push	OFFSET $SG224811
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN13@DoGuessOth

; 1008 : 					{
; 1009 : 						iPriority = GetGuessOtherPlayerConquestPriority(eMajor, iWorldMilitaryAverage);

	mov	edx, DWORD PTR _iWorldMilitaryAverage$[esp+212]
	push	edx
	push	ebp
	mov	ecx, edi
	call	?GetGuessOtherPlayerConquestPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@H@Z ; CvGrandStrategyAI::GetGuessOtherPlayerConquestPriority
	jmp	SHORT $LN280@DoGuessOth
$LN13@DoGuessOth:

; 1010 : 					}
; 1011 : 					else if(strGrandStrategyName == "AIGRANDSTRATEGY_CULTURE")

	lea	eax, DWORD PTR _strGrandStrategyName$[esp+212]
	push	OFFSET $SG224814
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN11@DoGuessOth

; 1012 : 					{
; 1013 : 						iPriority = GetGuessOtherPlayerCulturePriority(eMajor, iWorldCultureAverage, iWorldTourismAverage);

	mov	ecx, DWORD PTR _iWorldTourismAverage$[esp+212]
	mov	edx, DWORD PTR _iWorldCultureAverage$[esp+212]
	push	ecx
	push	edx
	push	ebp
	mov	ecx, edi
	call	?GetGuessOtherPlayerCulturePriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@HH@Z ; CvGrandStrategyAI::GetGuessOtherPlayerCulturePriority
	jmp	SHORT $LN280@DoGuessOth
$LN11@DoGuessOth:

; 1014 : 					}
; 1015 : 					else if(strGrandStrategyName == "AIGRANDSTRATEGY_UNITED_NATIONS")

	lea	eax, DWORD PTR _strGrandStrategyName$[esp+212]
	push	OFFSET $SG224817
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN9@DoGuessOth

; 1016 : 					{
; 1017 : 						iPriority = GetGuessOtherPlayerUnitedNationsPriority(eMajor);

	push	ebp
	mov	ecx, edi
	call	?GetGuessOtherPlayerUnitedNationsPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@@Z ; CvGrandStrategyAI::GetGuessOtherPlayerUnitedNationsPriority
	jmp	SHORT $LN280@DoGuessOth
$LN9@DoGuessOth:

; 1018 : 					}
; 1019 : 					else if(strGrandStrategyName == "AIGRANDSTRATEGY_SPACESHIP")

	lea	ecx, DWORD PTR _strGrandStrategyName$[esp+212]
	push	OFFSET $SG224820
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN276@DoGuessOth

; 1020 : 					{
; 1021 : 						iPriority = GetGuessOtherPlayerSpaceshipPriority(eMajor, iWorldNumTechsAverage);

	mov	edx, DWORD PTR _iWorldNumTechsAverage$[esp+212]
	push	edx
	push	ebp
	mov	ecx, edi
	call	?GetGuessOtherPlayerSpaceshipPriority@CvGrandStrategyAI@@QAEHW4PlayerTypes@@H@Z ; CvGrandStrategyAI::GetGuessOtherPlayerSpaceshipPriority
$LN280@DoGuessOth:
	mov	DWORD PTR _iPriority$[esp+212], eax
$LN276@DoGuessOth:

; 1022 : 					}
; 1023 : 
; 1024 : 					vGrandStrategyPriorities.push_back(iGrandStrategiesLoop, iPriority);

	mov	eax, DWORD PTR _vGrandStrategyPriorities$[esp+220]
	mov	BYTE PTR _vGrandStrategyPriorities$[esp+264], 0
	cmp	DWORD PTR _vGrandStrategyPriorities$[esp+216], eax
	jne	SHORT $LN146@DoGuessOth
	push	eax
	lea	ecx, DWORD PTR _vGrandStrategyPriorities$[esp+216]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::GrowSize
$LN146@DoGuessOth:
	mov	eax, DWORD PTR _vGrandStrategyPriorities$[esp+216]
	mov	ecx, DWORD PTR _vGrandStrategyPriorities$[esp+212]
	lea	eax, DWORD PTR [ecx+eax*8]
	cmp	eax, ebx
	je	SHORT $LN149@DoGuessOth
	mov	edx, DWORD PTR _iPriority$[esp+212]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edx
$LN149@DoGuessOth:

; 1025 : 					vGrandStrategyPrioritiesForLogging.push_back(iPriority);

	mov	eax, DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+220]
	inc	DWORD PTR _vGrandStrategyPriorities$[esp+216]
	mov	BYTE PTR _vGrandStrategyPrioritiesForLogging$[esp+244], 0
	cmp	DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+216], eax
	jne	SHORT $LN156@DoGuessOth
	push	eax
	lea	ecx, DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+216]
	call	?GrowSize@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,5,1,297,0>::GrowSize
$LN156@DoGuessOth:
	mov	eax, DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+216]
	mov	ecx, DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+212]
	lea	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, ebx
	je	SHORT $LN159@DoGuessOth
	mov	edx, DWORD PTR _iPriority$[esp+212]
	mov	DWORD PTR [eax], edx
$LN159@DoGuessOth:
	inc	DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+216]
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	inc	esi
	sar	ecx, 2
	cmp	esi, ecx
	jl	$LL16@DoGuessOth
$LN274@DoGuessOth:

; 1026 : 				}
; 1027 : 
; 1028 : 				if(vGrandStrategyPriorities.size() > 0)

	mov	eax, DWORD PTR _vGrandStrategyPriorities$[esp+216]
	cmp	eax, ebx
	jle	$LN277@DoGuessOth

; 1029 : 				{
; 1030 : 					// Add "No Grand Strategy" in case we just don't have enough info to go on
; 1031 : 					iPriority = /*40*/ GC.getAI_GRAND_STRATEGY_GUESS_NO_CLUE_WEIGHT();
; 1032 : 
; 1033 : 					vGrandStrategyPriorities.push_back(NO_AIGRANDSTRATEGY, iPriority);

	mov	ecx, DWORD PTR _vGrandStrategyPriorities$[esp+220]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1904
	mov	BYTE PTR _vGrandStrategyPriorities$[esp+264], 0
	cmp	eax, ecx
	jne	SHORT $LN173@DoGuessOth
	push	ecx
	lea	ecx, DWORD PTR _vGrandStrategyPriorities$[esp+216]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$04$00@@$04$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,5,1>::WeightedElement,5,1,0,0>::GrowSize
$LN173@DoGuessOth:
	mov	edx, DWORD PTR _vGrandStrategyPriorities$[esp+212]
	mov	eax, DWORD PTR _vGrandStrategyPriorities$[esp+216]
	lea	eax, DWORD PTR [edx+eax*8]
	cmp	eax, ebx
	je	SHORT $LN176@DoGuessOth
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], esi
$LN176@DoGuessOth:

; 1034 : 					vGrandStrategyPrioritiesForLogging.push_back(iPriority);

	mov	eax, DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+220]
	inc	DWORD PTR _vGrandStrategyPriorities$[esp+216]
	mov	BYTE PTR _vGrandStrategyPrioritiesForLogging$[esp+244], 0
	cmp	DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+216], eax
	jne	SHORT $LN183@DoGuessOth
	push	eax
	lea	ecx, DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+216]
	call	?GrowSize@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,5,1,297,0>::GrowSize
$LN183@DoGuessOth:
	mov	ecx, DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+212]
	mov	edx, DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+216]
	lea	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, ebx
	je	SHORT $LN186@DoGuessOth
	mov	DWORD PTR [eax], esi
$LN186@DoGuessOth:

; 1035 : 
; 1036 : 					vGrandStrategyPriorities.SortItems();

	mov	ecx, DWORD PTR _vGrandStrategyPriorities$[esp+212]
	mov	eax, DWORD PTR _vGrandStrategyPriorities$[esp+216]
	inc	DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+216]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$04$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$04$00@@0H@Z ; std::_Sort<CvWeightedVector<int,5,1>::WeightedElement *,int>

; 1037 : 
; 1038 : 					eGrandStrategy = (AIGrandStrategyTypes) vGrandStrategyPriorities.GetElement(0);

	mov	eax, DWORD PTR _vGrandStrategyPriorities$[esp+224]
	mov	ecx, DWORD PTR [eax]

; 1039 : 					iPriority = vGrandStrategyPriorities.GetWeight(0);

	mov	edx, ecx
	mov	DWORD PTR _elem$230798[esp+224], edx
	mov	edx, DWORD PTR [eax+4]

; 1040 : 					eGuessConfidence = NO_GUESS_CONFIDENCE_TYPE;

	or	eax, -1
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iPriority$[esp+212], edx

; 1041 : 
; 1042 : 					// How confident are we in our Guess?
; 1043 : 					if(eGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	ecx, eax
	je	SHORT $LN2@DoGuessOth

; 1044 : 					{
; 1045 : 						if(iPriority >= /*120*/ GC.getAI_GRAND_STRATEGY_GUESS_POSITIVE_THRESHOLD())

	cmp	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1908
	jl	SHORT $LN4@DoGuessOth

; 1046 : 						{
; 1047 : 							eGuessConfidence = GUESS_CONFIDENCE_POSITIVE;

	mov	eax, 2
	jmp	SHORT $LN2@DoGuessOth
$LN4@DoGuessOth:

; 1048 : 						}
; 1049 : 						else if(iPriority >= /*70*/ GC.getAI_GRAND_STRATEGY_GUESS_LIKELY_THRESHOLD())

	xor	eax, eax
	cmp	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1912
	setge	al
$LN2@DoGuessOth:

; 1050 : 						{
; 1051 : 							eGuessConfidence = GUESS_CONFIDENCE_LIKELY;
; 1052 : 						}
; 1053 : 						else
; 1054 : 						{
; 1055 : 							eGuessConfidence = GUESS_CONFIDENCE_UNSURE;
; 1056 : 						}
; 1057 : 					}
; 1058 : 
; 1059 : 					SetGuessOtherPlayerActiveGrandStrategy(eMajor, eGrandStrategy, eGuessConfidence);

	mov	edx, DWORD PTR [edi+20]
	mov	DWORD PTR [edx+ebp*4], ecx
	mov	ecx, DWORD PTR [edi+24]

; 1060 : 
; 1061 : 					LogGuessOtherPlayerGrandStrategy(vGrandStrategyPrioritiesForLogging, eMajor);

	push	ebp
	lea	edx, DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+216]
	mov	DWORD PTR [ecx+ebp*4], eax
	push	edx
	mov	ecx, edi
	call	?LogGuessOtherPlayerGrandStrategy@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@W4PlayerTypes@@@Z ; CvGrandStrategyAI::LogGuessOtherPlayerGrandStrategy
$LN277@DoGuessOth:

; 1062 : 				}
; 1063 : 
; 1064 : 				vGrandStrategyPriorities.clear();
; 1065 : 				vGrandStrategyPrioritiesForLogging.clear();

	mov	esi, DWORD PTR tv1327[esp+212]
	mov	DWORD PTR _vGrandStrategyPriorities$[esp+216], ebx
	mov	DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+216], ebx
$LN20@DoGuessOth:
	add	esi, 63236				; 0000f704H
	inc	ebp
	cmp	esi, 1391192				; 00153a58H
	mov	DWORD PTR tv1327[esp+212], esi
	jl	$LL21@DoGuessOth

; 1066 : 			}
; 1067 : 		}
; 1068 : 	}
; 1069 : }

	lea	ecx, DWORD PTR _strGrandStrategyName$[esp+212]
	mov	BYTE PTR __$EHRec$[esp+220], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+212]
	pop	edi
	pop	esi
	lea	ecx, DWORD PTR _vGrandStrategyPrioritiesForLogging$[esp+216]
	pop	ebp
	mov	BYTE PTR __$EHRec$[esp+208], 0
	pop	ebx
	cmp	eax, ecx
	je	SHORT $LN237@DoGuessOth
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN237@DoGuessOth:
	mov	eax, DWORD PTR _vGrandStrategyPriorities$[esp+196]
	lea	edx, DWORD PTR _vGrandStrategyPriorities$[esp+208]
	mov	DWORD PTR __$EHRec$[esp+204], -1
	cmp	eax, edx
	je	SHORT $LN254@DoGuessOth
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN254@DoGuessOth:
	mov	ecx, DWORD PTR __$EHRec$[esp+196]
	mov	DWORD PTR fs:0, ecx
	add	esp, 196				; 000000c4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _vGrandStrategyPriorities$[ebp]
	jmp	??1?$CvWeightedVector@H$04$00@@QAE@XZ	; CvWeightedVector<int,5,1>::~CvWeightedVector<int,5,1>
__unwindfunclet$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _vGrandStrategyPrioritiesForLogging$[ebp]
	jmp	??1?$FStaticVector@H$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,5,1,297,0>::~FStaticVector<int,5,1,297,0>
__unwindfunclet$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strGrandStrategyName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T230388[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ ENDP ; CvGrandStrategyAI::DoGuessOtherPlayersActiveGrandStrategy
PUBLIC	?DoTurn@CvGrandStrategyAI@@QAEXXZ		; CvGrandStrategyAI::DoTurn
EXTRN	?SetSpecializationsDirty@CvCitySpecializationAI@@QAEXW4CitySpecializationUpdateType@@@Z:PROC ; CvCitySpecializationAI::SetSpecializationsDirty
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?DoTurn@CvGrandStrategyAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTurn@CvGrandStrategyAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTurn@CvGrandStrategyAI@@QAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTurn@CvGrandStrategyAI@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoTurn@CvGrandStrategyAI@@QAEXXZ$3
__ehfuncinfo$?DoTurn@CvGrandStrategyAI@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?DoTurn@CvGrandStrategyAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgrandstrategyai.cpp
xdata$x	ENDS
;	COMDAT ?DoTurn@CvGrandStrategyAI@@QAEXXZ
_TEXT	SEGMENT
_strGrandStrategyName$ = -140				; size = 28
$T230986 = -112						; size = 28
_viGrandStrategyChangeForLogging$ = -84			; size = 36
_viNumGrandStrategiesAdopted$ = -48			; size = 36
__$EHRec$ = -12						; size = 12
?DoTurn@CvGrandStrategyAI@@QAEXXZ PROC			; CvGrandStrategyAI::DoTurn, COMDAT
; _this$ = ecx

; 288  : {

	push	-1
	push	__ehhandler$?DoTurn@CvGrandStrategyAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 289  : 	DoGuessOtherPlayersActiveGrandStrategy();

	call	?DoGuessOtherPlayersActiveGrandStrategy@CvGrandStrategyAI@@QAEXXZ ; CvGrandStrategyAI::DoGuessOtherPlayersActiveGrandStrategy

; 290  : 
; 291  : #ifdef AUI_GS_FIX_NO_ACTIVE_GS_FOR_HUMANS
; 292  : 	if (GetPlayer()->isHuman())
; 293  : 		return;
; 294  : #endif
; 295  : 
; 296  : #ifdef AUI_WARNING_FIXES
; 297  : 	uint iGrandStrategiesLoop;
; 298  : #else
; 299  : 	int iGrandStrategiesLoop;
; 300  : #endif
; 301  : 	AIGrandStrategyTypes eGrandStrategy;
; 302  : 	CvAIGrandStrategyXMLEntry* pGrandStrategy;
; 303  : 	CvString strGrandStrategyName;

	lea	ecx, DWORD PTR _strGrandStrategyName$[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 304  : 
; 305  : 	// Loop through all GrandStrategies to set their Priorities
; 306  : 	for(iGrandStrategiesLoop = 0; iGrandStrategiesLoop < GetAIGrandStrategies()->GetNumAIGrandStrategies(); iGrandStrategiesLoop++)

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+164], esi
	test	ecx, -4					; fffffffcH
	jle	$LN31@DoTurn
	mov	ebx, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
$LL234@DoTurn:

; 307  : 	{
; 308  : 		eGrandStrategy = (AIGrandStrategyTypes) iGrandStrategiesLoop;
; 309  : 		pGrandStrategy = GetAIGrandStrategies()->GetEntry(iGrandStrategiesLoop);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+esi*4]

; 310  : 		strGrandStrategyName = (CvString) pGrandStrategy->GetType();

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	jne	SHORT $LN60@DoTurn
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN60@DoTurn:
	push	eax
	lea	ecx, DWORD PTR $T230986[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T230986[esp+156]
	push	eax
	lea	ecx, DWORD PTR _strGrandStrategyName$[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 1
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230986[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 311  : 
; 312  : 		// Base Priority looks at Personality Flavors (0 - 10) and multiplies * the Flavors attached to a Grand Strategy (0-10),
; 313  : 		// so expect a number between 0 and 100 back from this
; 314  : 		int iPriority = GetBaseGrandStrategyPriority(eGrandStrategy);

	push	esi
	mov	ecx, edi
	call	?GetBaseGrandStrategyPriority@CvGrandStrategyAI@@QAEHW4AIGrandStrategyTypes@@@Z ; CvGrandStrategyAI::GetBaseGrandStrategyPriority

; 315  : 
; 316  : 		if(strGrandStrategyName == "AIGRANDSTRATEGY_CONQUEST")

	lea	ecx, DWORD PTR _strGrandStrategyName$[esp+156]
	push	OFFSET $SG224198
	push	ecx
	mov	ebp, eax
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN30@DoTurn

; 317  : 		{
; 318  : 			iPriority += GetConquestPriority();

	mov	ecx, edi
	call	?GetConquestPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetConquestPriority
	jmp	SHORT $LN238@DoTurn
$LN30@DoTurn:

; 319  : 		}
; 320  : 		else if(strGrandStrategyName == "AIGRANDSTRATEGY_CULTURE")

	lea	edx, DWORD PTR _strGrandStrategyName$[esp+156]
	push	OFFSET $SG224201
	push	edx
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN28@DoTurn

; 321  : 		{
; 322  : 			iPriority += GetCulturePriority();

	mov	ecx, edi
	call	?GetCulturePriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetCulturePriority
	jmp	SHORT $LN238@DoTurn
$LN28@DoTurn:

; 323  : 		}
; 324  : 		else if(strGrandStrategyName == "AIGRANDSTRATEGY_UNITED_NATIONS")

	lea	eax, DWORD PTR _strGrandStrategyName$[esp+156]
	push	OFFSET $SG224204
	push	eax
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN26@DoTurn

; 325  : 		{
; 326  : 			iPriority += GetUnitedNationsPriority();

	mov	ecx, edi
	call	?GetUnitedNationsPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetUnitedNationsPriority
	jmp	SHORT $LN238@DoTurn
$LN26@DoTurn:

; 327  : 		}
; 328  : 		else if(strGrandStrategyName == "AIGRANDSTRATEGY_SPACESHIP")

	lea	ecx, DWORD PTR _strGrandStrategyName$[esp+156]
	push	OFFSET $SG224207
	push	ecx
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN24@DoTurn

; 329  : 		{
; 330  : 			iPriority += GetSpaceshipPriority();

	mov	ecx, edi
	call	?GetSpaceshipPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetSpaceshipPriority
$LN238@DoTurn:
	add	ebp, eax
$LN24@DoTurn:

; 331  : 		}
; 332  : 
; 333  : 		// Random element
; 334  : 		iPriority += GC.getGame().getJonRandNum(/*50*/ GC.getAI_GS_RAND_ROLL(), "Grand Strategy AI: GS rand roll.");

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1896
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG224208
	push	edx
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	ebp, eax

; 335  : 
; 336  : 		// Give a boost to the current strategy so that small fluctuation doesn't cause a big change
; 337  : 		if(GetActiveGrandStrategy() == eGrandStrategy && GetActiveGrandStrategy() != NO_AIGRANDSTRATEGY)

	mov	eax, DWORD PTR [edi+12]
	cmp	eax, esi
	jne	SHORT $LN23@DoTurn
	cmp	eax, -1
	je	SHORT $LN23@DoTurn

; 338  : 		{
; 339  : 			iPriority += /*50*/ GC.getAI_GRAND_STRATEGY_CURRENT_STRATEGY_WEIGHT();

	add	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1900
$LN23@DoTurn:

; 340  : 		}
; 341  : 
; 342  : 		SetGrandStrategyPriority(eGrandStrategy, iPriority);

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [eax+esi*4], ebp
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	inc	esi
	sar	ecx, 2
	cmp	esi, ecx
	jl	$LL234@DoTurn
$LN31@DoTurn:

; 343  : 	}
; 344  : 
; 345  : 	// Now look at what we think the other players in the game are up to - we might have an opportunity to capitalize somewhere
; 346  : 	int iNumPlayersAliveAndMet = 0;

	xor	ebx, ebx
	xor	esi, esi
	npad	6
$LL22@DoTurn:

; 351  : 	{
; 352  : 		if(GET_PLAYER((PlayerTypes) iMajorLoop).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	je	SHORT $LN21@DoTurn

; 353  : 		{
; 354  : 			if(GET_TEAM(GetPlayer()->getTeam()).isHasMet(GET_PLAYER((PlayerTypes) iMajorLoop).getTeam()))

	mov	eax, DWORD PTR [esi+eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN91@DoTurn
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN92@DoTurn
$LN91@DoTurn:
	or	ecx, -1
$LN92@DoTurn:
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN102@DoTurn
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN103@DoTurn
$LN102@DoTurn:
	or	eax, -1
$LN103@DoTurn:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN21@DoTurn

; 355  : 			{
; 356  : 				iNumPlayersAliveAndMet++;

	inc	ebx
$LN21@DoTurn:

; 347  : 
; 348  : 	int iMajorLoop;
; 349  : 
; 350  : 	for(iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL22@DoTurn

; 357  : 			}
; 358  : 		}
; 359  : 	}
; 360  : 
; 361  : 	FStaticVector< int, 5, true, c_eCiv5GameplayDLL > viNumGrandStrategiesAdopted;

	mov	edx, 5
	lea	eax, DWORD PTR _viNumGrandStrategiesAdopted$[esp+168]
	mov	DWORD PTR _viNumGrandStrategiesAdopted$[esp+160], 0
	mov	DWORD PTR _viNumGrandStrategiesAdopted$[esp+164], edx
	mov	DWORD PTR _viNumGrandStrategiesAdopted$[esp+156], eax

; 362  : 	int iNumPlayers;
; 363  : 
; 364  : 	// Init vector
; 365  : 	for(iGrandStrategiesLoop = 0; iGrandStrategiesLoop < GetAIGrandStrategies()->GetNumAIGrandStrategies(); iGrandStrategiesLoop++)

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	xor	esi, esi
	mov	BYTE PTR __$EHRec$[esp+164], 2
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN15@DoTurn
	jmp	SHORT $LN17@DoTurn
	npad	5
$LL235@DoTurn:
	mov	edx, DWORD PTR _viNumGrandStrategiesAdopted$[esp+164]
$LN17@DoTurn:

; 366  : 	{
; 367  : 		iNumPlayers = 0;

	mov	eax, DWORD PTR [edi+20]
	xor	ebp, ebp
	lea	ecx, DWORD PTR [ebp+11]
	npad	4
$LL14@DoTurn:

; 371  : 		{
; 372  : 			if(GetGuessOtherPlayerActiveGrandStrategy((PlayerTypes) iMajorLoop) == (AIGrandStrategyTypes) iGrandStrategiesLoop)

	cmp	DWORD PTR [eax], esi
	jne	SHORT $LN13@DoTurn

; 373  : 			{
; 374  : 				iNumPlayers++;

	inc	ebp
$LN13@DoTurn:

; 371  : 		{
; 372  : 			if(GetGuessOtherPlayerActiveGrandStrategy((PlayerTypes) iMajorLoop) == (AIGrandStrategyTypes) iGrandStrategiesLoop)

	cmp	DWORD PTR [eax+4], esi
	jne	SHORT $LN230@DoTurn

; 373  : 			{
; 374  : 				iNumPlayers++;

	inc	ebp
$LN230@DoTurn:

; 366  : 	{
; 367  : 		iNumPlayers = 0;

	add	eax, 8

; 368  : 
; 369  : 		// Tally up how many players we think are pusuing each Grand Strategy
; 370  : 		for(iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	sub	ecx, 1
	jne	SHORT $LL14@DoTurn

; 375  : 			}
; 376  : 		}
; 377  : 
; 378  : 		viNumGrandStrategiesAdopted.push_back(iNumPlayers);

	mov	BYTE PTR _viNumGrandStrategiesAdopted$[esp+188], cl
	cmp	DWORD PTR _viNumGrandStrategiesAdopted$[esp+160], edx
	jne	SHORT $LN125@DoTurn
	push	edx
	lea	ecx, DWORD PTR _viNumGrandStrategiesAdopted$[esp+160]
	call	?GrowSize@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,5,1,297,0>::GrowSize
$LN125@DoTurn:
	mov	edx, DWORD PTR _viNumGrandStrategiesAdopted$[esp+156]
	mov	eax, DWORD PTR _viNumGrandStrategiesAdopted$[esp+160]
	lea	eax, DWORD PTR [edx+eax*4]
	test	eax, eax
	je	SHORT $LN128@DoTurn
	mov	DWORD PTR [eax], ebp
$LN128@DoTurn:
	inc	DWORD PTR _viNumGrandStrategiesAdopted$[esp+160]
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	inc	esi
	sar	ecx, 2
	cmp	esi, ecx
	jl	SHORT $LL235@DoTurn
$LN15@DoTurn:

; 379  : 	}
; 380  : 
; 381  : 	FStaticVector< int, 5, true, c_eCiv5GameplayDLL > viGrandStrategyChangeForLogging;

	xor	ebp, ebp
	lea	edx, DWORD PTR _viGrandStrategyChangeForLogging$[esp+168]
	mov	DWORD PTR _viGrandStrategyChangeForLogging$[esp+160], ebp
	mov	DWORD PTR _viGrandStrategyChangeForLogging$[esp+164], 5
	mov	DWORD PTR _viGrandStrategyChangeForLogging$[esp+156], edx

; 382  : 
; 383  : 	int iChange;
; 384  : 
; 385  : 	// Now modify our preferences based on how many people are going for stuff
; 386  : 	for(iGrandStrategiesLoop = 0; iGrandStrategiesLoop < GetAIGrandStrategies()->GetNumAIGrandStrategies(); iGrandStrategiesLoop++)

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR __$EHRec$[esp+164], 3
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN8@DoTurn
	npad	1
$LL10@DoTurn:
	mov	edx, DWORD PTR [edi+16]

; 387  : 	{
; 388  : 		eGrandStrategy = (AIGrandStrategyTypes) iGrandStrategiesLoop;
; 389  : 		// If EVERYONE else we know is also going for this Grand Strategy, reduce our Priority by 50%
; 390  : 		iChange = GetGrandStrategyPriority(eGrandStrategy) * /*50*/ GC.getAI_GRAND_STRATEGY_OTHER_PLAYERS_GS_MULTIPLIER();
; 391  : 		iChange = iChange * viNumGrandStrategiesAdopted[eGrandStrategy] / iNumPlayersAliveAndMet;
; 392  : 		iChange /= 100;

	mov	eax, DWORD PTR _viNumGrandStrategiesAdopted$[esp+156]
	mov	eax, DWORD PTR [eax+ebp*4]
	lea	ecx, DWORD PTR [edx+ebp*4]
	mov	edx, DWORD PTR [ecx]
	imul	eax, edx
	imul	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1916
	cdq
	idiv	ebx
	mov	edx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 393  : 
; 394  : 		ChangeGrandStrategyPriority(eGrandStrategy, -iChange);

	neg	esi
	je	SHORT $LN152@DoTurn
	add	DWORD PTR [ecx], esi
$LN152@DoTurn:

; 395  : 
; 396  : 		viGrandStrategyChangeForLogging.push_back(-iChange);

	mov	eax, DWORD PTR _viGrandStrategyChangeForLogging$[esp+164]
	mov	BYTE PTR _viGrandStrategyChangeForLogging$[esp+188], 0
	cmp	DWORD PTR _viGrandStrategyChangeForLogging$[esp+160], eax
	jne	SHORT $LN155@DoTurn
	push	eax
	lea	ecx, DWORD PTR _viGrandStrategyChangeForLogging$[esp+160]
	call	?GrowSize@?$FStaticVector@H$04$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,5,1,297,0>::GrowSize
$LN155@DoTurn:
	mov	ecx, DWORD PTR _viGrandStrategyChangeForLogging$[esp+156]
	mov	edx, DWORD PTR _viGrandStrategyChangeForLogging$[esp+160]
	lea	eax, DWORD PTR [ecx+edx*4]
	test	eax, eax
	je	SHORT $LN158@DoTurn
	mov	DWORD PTR [eax], esi
$LN158@DoTurn:
	inc	DWORD PTR _viGrandStrategyChangeForLogging$[esp+160]
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	inc	ebp
	sar	ecx, 2
	cmp	ebp, ecx
	jl	SHORT $LL10@DoTurn
$LN8@DoTurn:

; 397  : 	}
; 398  : 
; 399  : 	ChangeNumTurnsSinceActiveSet(1);

	inc	DWORD PTR [edi+8]

; 400  : 
; 401  : 	// Now see which Grand Strategy should be active, based on who has the highest Priority right now
; 402  : 	// Grand Strategy must be run for at least 10 turns
; 403  : 	if(GetActiveGrandStrategy() == NO_AIGRANDSTRATEGY || GetNumTurnsSinceActiveSet() >= /*10*/ GC.getAI_GRAND_STRATEGY_NUM_TURNS_STRATEGY_MUST_BE_ACTIVE())

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+8]
	cmp	eax, -1
	je	SHORT $LN6@DoTurn
	cmp	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1892
	jl	SHORT $LN236@DoTurn
$LN6@DoTurn:

; 404  : 	{
; 405  : 		int iBestPriority = -1;
; 406  : 		int iPriority;
; 407  : 
; 408  : 		AIGrandStrategyTypes eBestGrandStrategy = NO_AIGRANDSTRATEGY;
; 409  : 
; 410  : 		for(iGrandStrategiesLoop = 0; iGrandStrategiesLoop < GetAIGrandStrategies()->GetNumAIGrandStrategies(); iGrandStrategiesLoop++)

	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	or	ebp, -1
	or	ebx, ebp
	xor	eax, eax
	test	edx, -4					; fffffffcH
	jle	SHORT $LN3@DoTurn
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [edi+16]
	sar	edx, 2
	npad	2
$LL5@DoTurn:

; 411  : 		{
; 412  : 			eGrandStrategy = (AIGrandStrategyTypes) iGrandStrategiesLoop;
; 413  : 
; 414  : 			iPriority = GetGrandStrategyPriority(eGrandStrategy);

	mov	ecx, DWORD PTR [esi]

; 415  : 
; 416  : 			if(iPriority > iBestPriority)

	cmp	ecx, ebp
	jle	SHORT $LN4@DoTurn

; 417  : 			{
; 418  : 				iBestPriority = iPriority;

	mov	ebp, ecx

; 419  : 				eBestGrandStrategy = eGrandStrategy;

	mov	ebx, eax
$LN4@DoTurn:
	inc	eax
	add	esi, 4
	cmp	eax, edx
	jl	SHORT $LL5@DoTurn
$LN3@DoTurn:

; 420  : 			}
; 421  : 		}
; 422  : 
; 423  : 		if(eBestGrandStrategy != GetActiveGrandStrategy())

	cmp	ebx, DWORD PTR [edi+12]
	je	SHORT $LN236@DoTurn

; 424  : 		{
; 425  : 			SetActiveGrandStrategy(eBestGrandStrategy);

	cmp	ebx, -1
	je	SHORT $LN233@DoTurn
	mov	DWORD PTR [edi+12], ebx
	mov	DWORD PTR [edi+8], 0
$LN233@DoTurn:

; 426  : 			m_pPlayer->GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_NEW_GRAND_STRATEGY);

	mov	ecx, DWORD PTR [edi]
	push	0
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?SetSpecializationsDirty@CvCitySpecializationAI@@QAEXW4CitySpecializationUpdateType@@@Z ; CvCitySpecializationAI::SetSpecializationsDirty
$LN236@DoTurn:

; 427  : 		}
; 428  : 	}
; 429  : 
; 430  : 	LogGrandStrategies(viGrandStrategyChangeForLogging);

	lea	eax, DWORD PTR _viGrandStrategyChangeForLogging$[esp+156]
	push	eax
	mov	ecx, edi
	call	?LogGrandStrategies@CvGrandStrategyAI@@AAEXABV?$FStaticVector@H$04$00$0BCJ@$0A@@@@Z ; CvGrandStrategyAI::LogGrandStrategies

; 431  : }

	mov	eax, DWORD PTR _viGrandStrategyChangeForLogging$[esp+156]
	pop	edi
	pop	esi
	lea	ecx, DWORD PTR _viGrandStrategyChangeForLogging$[esp+160]
	pop	ebp
	mov	BYTE PTR __$EHRec$[esp+152], 2
	pop	ebx
	cmp	eax, ecx
	je	SHORT $LN188@DoTurn
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN188@DoTurn:
	mov	eax, DWORD PTR _viNumGrandStrategiesAdopted$[esp+140]
	lea	edx, DWORD PTR _viNumGrandStrategiesAdopted$[esp+152]
	mov	BYTE PTR __$EHRec$[esp+148], 0
	cmp	eax, edx
	je	SHORT $LN202@DoTurn
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN202@DoTurn:
	lea	ecx, DWORD PTR _strGrandStrategyName$[esp+140]
	mov	DWORD PTR __$EHRec$[esp+148], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+140]
	mov	DWORD PTR fs:0, ecx
	add	esp, 140				; 0000008cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTurn@CvGrandStrategyAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strGrandStrategyName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvGrandStrategyAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR $T230986[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvGrandStrategyAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _viNumGrandStrategiesAdopted$[ebp]
	jmp	??1?$FStaticVector@H$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,5,1,297,0>::~FStaticVector<int,5,1,297,0>
__unwindfunclet$?DoTurn@CvGrandStrategyAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR _viGrandStrategyChangeForLogging$[ebp]
	jmp	??1?$FStaticVector@H$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,5,1,297,0>::~FStaticVector<int,5,1,297,0>
__ehhandler$?DoTurn@CvGrandStrategyAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoTurn@CvGrandStrategyAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTurn@CvGrandStrategyAI@@QAEXXZ ENDP			; CvGrandStrategyAI::DoTurn
END
