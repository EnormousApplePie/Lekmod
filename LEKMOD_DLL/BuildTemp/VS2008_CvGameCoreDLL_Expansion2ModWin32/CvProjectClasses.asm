; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvProjectClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG218129 DB	'MaxGlobalInstances', 00H
	ORG $+1
$SG218130 DB	'MaxTeamInstances', 00H
	ORG $+3
$SG218131 DB	'Cost', 00H
	ORG $+3
$SG218132 DB	'NukeInterception', 00H
	ORG $+3
$SG218133 DB	'CultureBranchesRequired', 00H
$SG218134 DB	'TechShare', 00H
	ORG $+2
$SG218135 DB	'VictoryDelayPercent', 00H
$SG218136 DB	'Spaceship', 00H
	ORG $+2
$SG218137 DB	'AllowsNukes', 00H
$SG218138 DB	'MovieDefineTag', 00H
	ORG $+1
$SG218140 DB	'VictoryPrereq', 00H
	ORG $+2
$SG218142 DB	'TechPrereq', 00H
	ORG $+1
$SG218144 DB	'EveryoneSpecialUnit', 00H
$SG218146 DB	'CreateSound', 00H
$SG218148 DB	'AnyonePrereqProject', 00H
$SG218150 DB	'Quantity', 00H
	ORG $+3
$SG218151 DB	'ProjectType', 00H
$SG218152 DB	'ResourceType', 00H
	ORG $+3
$SG218153 DB	'Project_ResourceQuantityRequirements', 00H
	ORG $+3
$SG218154 DB	'Resources', 00H
	ORG $+2
$SG218156 DB	'Victories', 00H
	ORG $+6
$SG218169 DB	'select VictoryType, Threshold, MinThreshold from Project'
	DB	'_VictoryThresholds where ProjectType = ''%s'';', 00H
	ORG $+3
$SG218175 DB	'VictoryType', 00H
$SG218178 DB	'Threshold', 00H
	ORG $+2
$SG218180 DB	'MinThreshold', 00H
	ORG $+3
$SG218181 DB	'ProjectType', 00H
$SG218182 DB	'Project_Flavors', 00H
$SG218183 DB	'AmountNeeded', 00H
	ORG $+3
$SG218184 DB	'ProjectType', 00H
$SG218185 DB	'PrereqProjectType', 00H
	ORG $+2
$SG218186 DB	'Project_Prereqs', 00H
$SG218187 DB	'Projects', 00H
CONST	ENDS
PUBLIC	?GetVictoryPrereq@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetVictoryPrereq
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvprojectclasses.cpp
;	COMDAT ?GetVictoryPrereq@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
?GetVictoryPrereq@CvProjectEntry@@QBEHXZ PROC		; CvProjectEntry::GetVictoryPrereq, COMDAT
; _this$ = ecx

; 105  : 	return m_iVictoryPrereq;

	mov	eax, DWORD PTR [ecx+260]

; 106  : }

	ret	0
?GetVictoryPrereq@CvProjectEntry@@QBEHXZ ENDP		; CvProjectEntry::GetVictoryPrereq
_TEXT	ENDS
PUBLIC	?GetTechPrereq@CvProjectEntry@@QBEHXZ		; CvProjectEntry::GetTechPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechPrereq@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTechPrereq@CvProjectEntry@@QBEHXZ PROC		; CvProjectEntry::GetTechPrereq, COMDAT
; _this$ = ecx

; 111  : 	return m_iTechPrereq;

	mov	eax, DWORD PTR [ecx+264]

; 112  : }

	ret	0
?GetTechPrereq@CvProjectEntry@@QBEHXZ ENDP		; CvProjectEntry::GetTechPrereq
_TEXT	ENDS
PUBLIC	?GetAnyoneProjectPrereq@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetAnyoneProjectPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?GetAnyoneProjectPrereq@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAnyoneProjectPrereq@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetAnyoneProjectPrereq, COMDAT
; _this$ = ecx

; 117  : 	return m_iAnyoneProjectPrereq;

	mov	eax, DWORD PTR [ecx+268]

; 118  : }

	ret	0
?GetAnyoneProjectPrereq@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetAnyoneProjectPrereq
_TEXT	ENDS
PUBLIC	?SetAnyoneProjectPrereq@CvProjectEntry@@QAEXH@Z	; CvProjectEntry::SetAnyoneProjectPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?SetAnyoneProjectPrereq@CvProjectEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetAnyoneProjectPrereq@CvProjectEntry@@QAEXH@Z PROC	; CvProjectEntry::SetAnyoneProjectPrereq, COMDAT
; _this$ = ecx

; 123  : 	m_iAnyoneProjectPrereq = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+268], eax

; 124  : }

	ret	4
?SetAnyoneProjectPrereq@CvProjectEntry@@QAEXH@Z ENDP	; CvProjectEntry::SetAnyoneProjectPrereq
_TEXT	ENDS
PUBLIC	?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetMaxGlobalInstances
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetMaxGlobalInstances, COMDAT
; _this$ = ecx

; 129  : 	return m_iMaxGlobalInstances;

	mov	eax, DWORD PTR [ecx+272]

; 130  : }

	ret	0
?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetMaxGlobalInstances
_TEXT	ENDS
PUBLIC	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetMaxTeamInstances
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetMaxTeamInstances, COMDAT
; _this$ = ecx

; 135  : 	return m_iMaxTeamInstances;

	mov	eax, DWORD PTR [ecx+276]

; 136  : }

	ret	0
?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetMaxTeamInstances
_TEXT	ENDS
PUBLIC	?GetProductionCost@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetProductionCost
; Function compile flags: /Ogtpy
;	COMDAT ?GetProductionCost@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
?GetProductionCost@CvProjectEntry@@QBEHXZ PROC		; CvProjectEntry::GetProductionCost, COMDAT
; _this$ = ecx

; 141  : 	return m_iProductionCost;

	mov	eax, DWORD PTR [ecx+280]

; 142  : }

	ret	0
?GetProductionCost@CvProjectEntry@@QBEHXZ ENDP		; CvProjectEntry::GetProductionCost
_TEXT	ENDS
PUBLIC	?GetNukeInterception@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetNukeInterception
; Function compile flags: /Ogtpy
;	COMDAT ?GetNukeInterception@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNukeInterception@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetNukeInterception, COMDAT
; _this$ = ecx

; 147  : 	return m_iNukeInterception;

	mov	eax, DWORD PTR [ecx+284]

; 148  : }

	ret	0
?GetNukeInterception@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetNukeInterception
_TEXT	ENDS
PUBLIC	?GetCultureBranchesRequired@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetCultureBranchesRequired
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureBranchesRequired@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureBranchesRequired@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetCultureBranchesRequired, COMDAT
; _this$ = ecx

; 153  : 	return m_iCultureBranchesRequired;

	mov	eax, DWORD PTR [ecx+288]

; 154  : }

	ret	0
?GetCultureBranchesRequired@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetCultureBranchesRequired
_TEXT	ENDS
PUBLIC	?GetTechShare@CvProjectEntry@@QBEHXZ		; CvProjectEntry::GetTechShare
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechShare@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTechShare@CvProjectEntry@@QBEHXZ PROC		; CvProjectEntry::GetTechShare, COMDAT
; _this$ = ecx

; 159  : 	return m_iTechShare;

	mov	eax, DWORD PTR [ecx+292]

; 160  : }

	ret	0
?GetTechShare@CvProjectEntry@@QBEHXZ ENDP		; CvProjectEntry::GetTechShare
_TEXT	ENDS
PUBLIC	?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetEveryoneSpecialUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetEveryoneSpecialUnit, COMDAT
; _this$ = ecx

; 165  : 	return m_iEveryoneSpecialUnit;

	mov	eax, DWORD PTR [ecx+296]

; 166  : }

	ret	0
?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetEveryoneSpecialUnit
_TEXT	ENDS
PUBLIC	?GetVictoryDelayPercent@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetVictoryDelayPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetVictoryDelayPercent@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
?GetVictoryDelayPercent@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetVictoryDelayPercent, COMDAT
; _this$ = ecx

; 171  : 	return m_iVictoryDelayPercent;

	mov	eax, DWORD PTR [ecx+300]

; 172  : }

	ret	0
?GetVictoryDelayPercent@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetVictoryDelayPercent
_TEXT	ENDS
PUBLIC	?IsSpaceship@CvProjectEntry@@QBE_NXZ		; CvProjectEntry::IsSpaceship
; Function compile flags: /Ogtpy
;	COMDAT ?IsSpaceship@CvProjectEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsSpaceship@CvProjectEntry@@QBE_NXZ PROC		; CvProjectEntry::IsSpaceship, COMDAT
; _this$ = ecx

; 191  : 	return m_bSpaceship;

	mov	al, BYTE PTR [ecx+304]

; 192  : }

	ret	0
?IsSpaceship@CvProjectEntry@@QBE_NXZ ENDP		; CvProjectEntry::IsSpaceship
_TEXT	ENDS
PUBLIC	?IsAllowsNukes@CvProjectEntry@@QBE_NXZ		; CvProjectEntry::IsAllowsNukes
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsNukes@CvProjectEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsNukes@CvProjectEntry@@QBE_NXZ PROC		; CvProjectEntry::IsAllowsNukes, COMDAT
; _this$ = ecx

; 197  : 	return m_bAllowsNukes;

	mov	al, BYTE PTR [ecx+305]

; 198  : }

	ret	0
?IsAllowsNukes@CvProjectEntry@@QBE_NXZ ENDP		; CvProjectEntry::IsAllowsNukes
_TEXT	ENDS
PUBLIC	?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetResourceQuantityRequirement
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z PROC ; CvProjectEntry::GetResourceQuantityRequirement, COMDAT
; _this$ = ecx

; 229  : {

	push	esi

; 230  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 231  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 232  : 
; 233  : 	if(i > -1 && i < GC.getNumResourceInfos() && m_piResourceQuantityRequirements)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetResourc
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetResourc
	mov	eax, DWORD PTR [edi+364]
	test	eax, eax
	je	SHORT $LN1@GetResourc

; 234  : #endif
; 235  : 	{
; 236  : 		return  m_piResourceQuantityRequirements[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 240  : }

	ret	4
$LN1@GetResourc:
	pop	edi

; 237  : 	}
; 238  : 
; 239  : 	return -1;

	or	eax, -1
	pop	esi

; 240  : }

	ret	4
?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z ENDP ; CvProjectEntry::GetResourceQuantityRequirement
_TEXT	ENDS
PUBLIC	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z	; CvProjectEntry::GetVictoryThreshold
EXTRN	?getNumVictoryInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumVictoryInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z PROC	; CvProjectEntry::GetVictoryThreshold, COMDAT
; _this$ = ecx

; 251  : {

	push	esi

; 252  : 	CvAssertMsg(i < GC.getNumVictoryInfos(), "Index out of bounds");
; 253  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 254  : 
; 255  : 	if(i > -1 && i < GC.getNumVictoryInfos() && m_piVictoryThreshold)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetVictory
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetVictory
	mov	eax, DWORD PTR [edi+368]
	test	eax, eax
	je	SHORT $LN1@GetVictory

; 256  : #endif
; 257  : 	{
; 258  : 		return  m_piVictoryThreshold[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 262  : }

	ret	4
$LN1@GetVictory:
	pop	edi

; 259  : 	}
; 260  : 
; 261  : 	return -1;

	or	eax, -1
	pop	esi

; 262  : }

	ret	4
?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z ENDP	; CvProjectEntry::GetVictoryThreshold
_TEXT	ENDS
PUBLIC	?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z	; CvProjectEntry::GetVictoryMinThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z PROC	; CvProjectEntry::GetVictoryMinThreshold, COMDAT
; _this$ = ecx

; 273  : {

	push	esi

; 274  : 	CvAssertMsg(i < GC.getNumVictoryInfos(), "Index out of bounds");
; 275  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 276  : 
; 277  : 	if(i > -1 && i < GC.getNumVictoryInfos())

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN2@GetVictory@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	cmp	esi, eax
	jge	SHORT $LN2@GetVictory@2

; 278  : #endif
; 279  : 	{
; 280  : 		if(m_piVictoryMinThreshold && m_piVictoryMinThreshold[i] != 0)

	mov	eax, DWORD PTR [edi+372]
	test	eax, eax
	je	SHORT $LN1@GetVictory@2
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax

; 281  : 		{
; 282  : 			return m_piVictoryMinThreshold[i];

	jne	SHORT $LN3@GetVictory@2
$LN1@GetVictory@2:

; 283  : 		}
; 284  : 
; 285  : 		return GetVictoryThreshold(i);

	push	esi
	mov	ecx, edi
	call	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryThreshold
	pop	edi
	pop	esi

; 289  : }

	ret	4
$LN2@GetVictory@2:

; 286  : 	}
; 287  : 
; 288  : 	return 0;

	xor	eax, eax
$LN3@GetVictory@2:
	pop	edi
	pop	esi

; 289  : }

	ret	4
?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z ENDP	; CvProjectEntry::GetVictoryMinThreshold
_TEXT	ENDS
PUBLIC	?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z	; CvProjectEntry::GetProjectsNeeded
EXTRN	?getNumProjectInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumProjectInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z PROC		; CvProjectEntry::GetProjectsNeeded, COMDAT
; _this$ = ecx

; 300  : {

	push	esi

; 301  : 	CvAssertMsg(i < GC.getNumProjectInfos(), "Index out of bounds");
; 302  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 303  : 
; 304  : 	if(i > -1 && i < GC.getNumProjectInfos() && m_piProjectsNeeded)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetProject
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetProject
	mov	eax, DWORD PTR [edi+376]
	test	eax, eax
	je	SHORT $LN1@GetProject

; 305  : #endif
; 306  : 	{
; 307  : 		return m_piProjectsNeeded[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 311  : }

	ret	4
$LN1@GetProject:
	pop	edi

; 308  : 	}
; 309  : 
; 310  : 	return 0;

	xor	eax, eax
	pop	esi

; 311  : }

	ret	4
?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z ENDP		; CvProjectEntry::GetProjectsNeeded
_TEXT	ENDS
PUBLIC	?GetProjectEntries@CvProjectXMLEntries@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ ; CvProjectXMLEntries::GetProjectEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetProjectEntries@CvProjectXMLEntries@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetProjectEntries@CvProjectXMLEntries@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ PROC ; CvProjectXMLEntries::GetProjectEntries, COMDAT
; _this$ = ecx

; 330  : {

	mov	eax, ecx

; 331  : 	return m_paProjectEntries;
; 332  : }

	ret	0
?GetProjectEntries@CvProjectXMLEntries@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ ENDP ; CvProjectXMLEntries::GetProjectEntries
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEIXZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAPAVCvProjectEntry@@I@Z ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAPAVCvProjectEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAPAVCvProjectEntry@@I@Z PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAPAVCvProjectEntry@@I@Z ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvProjectEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvProjectEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvProjectEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvProjectEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvProjectEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvProjectEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvProjectEntry@@@std@@QAE@XZ	; std::allocator<CvProjectEntry *>::allocator<CvProjectEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvProjectEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvProjectEntry@@@std@@QAE@XZ PROC	; std::allocator<CvProjectEntry *>::allocator<CvProjectEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvProjectEntry@@@std@@QAE@XZ ENDP	; std::allocator<CvProjectEntry *>::allocator<CvProjectEntry *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEABQAVCvProjectEntry@@XZ ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEABQAVCvProjectEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEABQAVCvProjectEntry@@XZ PROC ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEABQAVCvProjectEntry@@XZ ENDP ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator==
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE@V?$allocator@PAVCvProjectEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvProjectEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvProjectEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE@V?$allocator@PAVCvProjectEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE@V?$allocator@PAVCvProjectEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvProjectEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvProjectEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE@V?$allocator@PAVCvProjectEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvProjectEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvProjectEntry *> >
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvProjectEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvProjectEntry *>::allocator<CvProjectEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvProjectEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvProjectEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvProjectEntry *>::allocator<CvProjectEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvProjectEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvProjectEntry *>::allocator<CvProjectEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvProjectEntry@@@std@@QAEXPAPAVCvProjectEntry@@I@Z ; std::allocator<CvProjectEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvProjectEntry@@@std@@QAEXPAPAVCvProjectEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvProjectEntry@@@std@@QAEXPAPAVCvProjectEntry@@I@Z PROC ; std::allocator<CvProjectEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvProjectEntry@@@std@@QAEXPAPAVCvProjectEntry@@I@Z ENDP ; std::allocator<CvProjectEntry *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@PAPAVCvProjectEntry@@@Z ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@PAPAVCvProjectEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@PAPAVCvProjectEntry@@@Z PROC ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@PAPAVCvProjectEntry@@@Z ENDP ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvProjectEntry@@@std@@QBEIXZ ; std::allocator<CvProjectEntry *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvProjectEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvProjectEntry@@@std@@QBEIXZ PROC ; std::allocator<CvProjectEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvProjectEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvProjectEntry *>::max_size
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ		; sprintf_s<512>
EXTRN	__imp__vsprintf_s:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ PROC		; sprintf_s<512>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	mov	ecx, DWORD PTR __Format$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	ecx
	push	512					; 00000200H
	push	edx
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	ret	0
??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ ENDP		; sprintf_s<512>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvProjectEntry@@@std@@YAPAPAVCvProjectEntry@@IPAPAV1@@Z ; std::_Allocate<CvProjectEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvProjectEntry@@@std@@YAPAPAVCvProjectEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T219096 = -12						; size = 12
$T219101 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvProjectEntry@@@std@@YAPAPAVCvProjectEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvProjectEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T219101[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T219096[esp+16]
	mov	DWORD PTR $T219101[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T219096[esp+16]
	push	ecx
	mov	DWORD PTR $T219096[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvProjectEntry@@@std@@YAPAPAVCvProjectEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvProjectEntry *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvProjectEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvProjectEntry@@0@Z ; std::_Iter_random<CvProjectEntry * *,CvProjectEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAPAVCvProjectEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvProjectEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvProjectEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvProjectEntry@@0@Z PROC ; std::_Iter_random<CvProjectEntry * *,CvProjectEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvProjectEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvProjectEntry@@0@Z ENDP ; std::_Iter_random<CvProjectEntry * *,CvProjectEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvProjectEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvProjectEntry@@0@Z ; std::_Ptr_cat<CvProjectEntry * *,CvProjectEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvProjectEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvProjectEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvProjectEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvProjectEntry@@0@Z PROC ; std::_Ptr_cat<CvProjectEntry * *,CvProjectEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvProjectEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvProjectEntry@@0@Z ENDP ; std::_Ptr_cat<CvProjectEntry * *,CvProjectEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvProjectEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvProjectEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvProjectEntry * *,CvProjectEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvProjectEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvProjectEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvProjectEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvProjectEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvProjectEntry * *,CvProjectEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvProjectEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvProjectEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvProjectEntry * *,CvProjectEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvProjectEntry@@@std@@@std@@YAXPAPAVCvProjectEntry@@0AAV?$allocator@PAVCvProjectEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvProjectEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvProjectEntry@@@std@@@std@@YAXPAPAVCvProjectEntry@@0AAV?$allocator@PAVCvProjectEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvProjectEntry@@@std@@@std@@YAXPAPAVCvProjectEntry@@0AAV?$allocator@PAVCvProjectEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvProjectEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvProjectEntry@@@std@@@std@@YAXPAPAVCvProjectEntry@@0AAV?$allocator@PAVCvProjectEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvProjectEntry *> >
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getNumFlavorTypes@CvGlobals@@QAEHXZ		; CvGlobals::getNumFlavorTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getNumFlavorTypes@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFlavorTypes@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFlavorTypes, COMDAT
; _this$ = ecx

; 804  : 		return m_iNumFlavorTypes;

	mov	eax, DWORD PTR [ecx+1764]

; 805  : 	}

	ret	0
?getNumFlavorTypes@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFlavorTypes
_TEXT	ENDS
PUBLIC	?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ; CvGlobals::GetGameDatabase
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ
_TEXT	SEGMENT
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ PROC ; CvGlobals::GetGameDatabase, COMDAT
; _this$ = ecx

; 9792 : 	return m_pGameDatabase;

	mov	eax, DWORD PTR [ecx+912]

; 9793 : }

	ret	0
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ENDP ; CvGlobals::GetGameDatabase
_TEXT	ENDS
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	esi

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	mov	esi, DWORD PTR _count$[esp]
	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 126  : 	if(iDefault == 0)

	mov	edx, DWORD PTR _iDefault$[esp+4]
	mov	ecx, DWORD PTR _pArray$[esp+4]
	add	esp, 4
	mov	DWORD PTR [ecx], eax
	test	edx, edx
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	lea	ecx, DWORD PTR [esi*4]
	push	ecx
	push	edx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
$LN5@Initialize:

; 129  : 	}
; 130  : 	else
; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	xor	eax, eax
	test	esi, esi
	jbe	SHORT $LN1@Initialize
	push	edi
	npad	5
$LL3@Initialize:

; 133  : 			pArray[i] = iDefault;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edi+eax*4], edx
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL3@Initialize
	pop	edi
$LN1@Initialize:
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvProjectEntry@@6B@				; CvProjectEntry::`vftable'
PUBLIC	??1CvProjectEntry@@QAE@XZ			; CvProjectEntry::~CvProjectEntry
PUBLIC	??_R4CvProjectEntry@@6B@			; CvProjectEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvProjectEntry@@@8			; CvProjectEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvProjectEntry@@8				; CvProjectEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvProjectEntry@@8				; CvProjectEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvProjectEntry@@8			; CvProjectEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvProjectEntry::CacheResults
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_R2CvBaseInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvProjectEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvProjectEntry@@8 DD FLAT:??_R0?AVCvProjectEntry@@@8 ; CvProjectEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvProjectEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvProjectEntry@@8
rdata$r	SEGMENT
??_R2CvProjectEntry@@8 DD FLAT:??_R1A@?0A@EA@CvProjectEntry@@8 ; CvProjectEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvProjectEntry@@8
rdata$r	SEGMENT
??_R3CvProjectEntry@@8 DD 00H				; CvProjectEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvProjectEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvProjectEntry@@@8
_DATA	SEGMENT
??_R0?AVCvProjectEntry@@@8 DD FLAT:??_7type_info@@6B@	; CvProjectEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvProjectEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvProjectEntry@@6B@
rdata$r	SEGMENT
??_R4CvProjectEntry@@6B@ DD 00H				; CvProjectEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvProjectEntry@@@8
	DD	FLAT:??_R3CvProjectEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvProjectEntry@@6B@
CONST	SEGMENT
??_7CvProjectEntry@@6B@ DD FLAT:??_R4CvProjectEntry@@6B@ ; CvProjectEntry::`vftable'
	DD	FLAT:?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvProjectEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvProjectEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvProjectEntry@@QAE@XZ$1
__ehfuncinfo$??1CvProjectEntry@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvProjectEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvprojectclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvProjectEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvProjectEntry@@QAE@XZ PROC				; CvProjectEntry::~CvProjectEntry, COMDAT
; _this$ = ecx

; 25   : {

	push	-1
	push	__ehhandler$??1CvProjectEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvProjectEntry@@6B@

; 26   : 	SAFE_DELETE_ARRAY(m_piResourceQuantityRequirements);

	mov	eax, DWORD PTR [esi+364]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 1
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+364], ebx

; 27   : 	SAFE_DELETE_ARRAY(m_piVictoryThreshold);

	mov	eax, DWORD PTR [esi+368]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+368], ebx

; 28   : 	SAFE_DELETE_ARRAY(m_piVictoryMinThreshold);

	mov	eax, DWORD PTR [esi+372]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+372], ebx

; 29   : 	SAFE_DELETE_ARRAY(m_piProjectsNeeded);

	mov	eax, DWORD PTR [esi+376]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+376], ebx

; 30   : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	eax, DWORD PTR [esi+380]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 20					; 00000014H

; 31   : }

	lea	ecx, DWORD PTR [esi+336]
	mov	DWORD PTR [esi+380], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+308]
	mov	BYTE PTR __$EHRec$[esp+32], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvProjectEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvProjectEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 308				; 00000134H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvProjectEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvProjectEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvProjectEntry@@QAE@XZ ENDP				; CvProjectEntry::~CvProjectEntry
PUBLIC	?GetFlavorValue@CvProjectEntry@@QBEHH@Z		; CvProjectEntry::GetFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlavorValue@CvProjectEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFlavorValue@CvProjectEntry@@QBEHH@Z PROC		; CvProjectEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 177  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 178  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 179  : 
; 180  : 	if(i > -1 && i < GC.getNumFlavorTypes() && m_piFlavorValue)

	mov	edx, DWORD PTR _i$[esp-4]
	cmp	edx, -1
	jle	SHORT $LN1@GetFlavorV
	cmp	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jge	SHORT $LN1@GetFlavorV
	mov	eax, DWORD PTR [ecx+380]
	test	eax, eax
	je	SHORT $LN1@GetFlavorV

; 181  : 	{
; 182  : 		return  m_piFlavorValue[i];

	mov	eax, DWORD PTR [eax+edx*4]

; 186  : }

	ret	4
$LN1@GetFlavorV:

; 183  : 	}
; 184  : 
; 185  : 	return 0;

	xor	eax, eax

; 186  : }

	ret	4
?GetFlavorValue@CvProjectEntry@@QBEHH@Z ENDP		; CvProjectEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?GetMovieArtDef@CvProjectEntry@@QBEPBDXZ	; CvProjectEntry::GetMovieArtDef
; Function compile flags: /Ogtpy
;	COMDAT ?GetMovieArtDef@CvProjectEntry@@QBEPBDXZ
_TEXT	SEGMENT
?GetMovieArtDef@CvProjectEntry@@QBEPBDXZ PROC		; CvProjectEntry::GetMovieArtDef, COMDAT
; _this$ = ecx

; 203  : 	return m_strMovieArtDef;

	add	ecx, 336				; 00000150H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetMovieArtDef@CvProjectEntry@@QBEPBDXZ ENDP		; CvProjectEntry::GetMovieArtDef
_TEXT	ENDS
PUBLIC	?GetCreateSound@CvProjectEntry@@QBEPBDXZ	; CvProjectEntry::GetCreateSound
; Function compile flags: /Ogtpy
;	COMDAT ?GetCreateSound@CvProjectEntry@@QBEPBDXZ
_TEXT	SEGMENT
?GetCreateSound@CvProjectEntry@@QBEPBDXZ PROC		; CvProjectEntry::GetCreateSound, COMDAT
; _this$ = ecx

; 209  : 	return m_strCreateSound;

	add	ecx, 308				; 00000134H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCreateSound@CvProjectEntry@@QBEPBDXZ ENDP		; CvProjectEntry::GetCreateSound
_TEXT	ENDS
PUBLIC	?SetCreateSound@CvProjectEntry@@QAEXPBD@Z	; CvProjectEntry::SetCreateSound
; Function compile flags: /Ogtpy
;	COMDAT ?SetCreateSound@CvProjectEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?SetCreateSound@CvProjectEntry@@QAEXPBD@Z PROC		; CvProjectEntry::SetCreateSound, COMDAT
; _this$ = ecx

; 215  : 	m_strCreateSound = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 308				; 00000134H
	test	eax, eax
	je	SHORT $LN4@SetCreateS
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@SetCreateS:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 216  : }

	ret	4
?SetCreateSound@CvProjectEntry@@QAEXPBD@Z ENDP		; CvProjectEntry::SetCreateSound
_TEXT	ENDS
PUBLIC	?GetNumProjects@CvProjectXMLEntries@@QAEHXZ	; CvProjectXMLEntries::GetNumProjects
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumProjects@CvProjectXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumProjects@CvProjectXMLEntries@@QAEHXZ PROC	; CvProjectXMLEntries::GetNumProjects, COMDAT
; _this$ = ecx

; 341  : 	return m_paProjectEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 342  : }

	ret	0
?GetNumProjects@CvProjectXMLEntries@@QAEHXZ ENDP	; CvProjectXMLEntries::GetNumProjects
_TEXT	ENDS
PUBLIC	?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z ; CvProjectXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z PROC ; CvProjectXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 362  : 	return m_paProjectEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 363  : }

	ret	4
?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z ENDP ; CvProjectXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEAAPAVCvProjectEntry@@XZ ; std::_Vector_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEAAPAVCvProjectEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEAAPAVCvProjectEntry@@XZ PROC ; std::_Vector_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEAAPAVCvProjectEntry@@XZ ENDP ; std::_Vector_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE@V?$allocator@PAVCvProjectEntry@@@1@@Z ; std::_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE@V?$allocator@PAVCvProjectEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE@V?$allocator@PAVCvProjectEntry@@@1@@Z PROC ; std::_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE@V?$allocator@PAVCvProjectEntry@@@1@@Z ENDP ; std::_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@PAPAVCvProjectEntry@@@Z ; std::_Vector_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Vector_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@PAPAVCvProjectEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@PAPAVCvProjectEntry@@@Z PROC ; std::_Vector_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Vector_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@PAPAVCvProjectEntry@@@Z ENDP ; std::_Vector_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Vector_iterator<CvProjectEntry *,std::allocator<CvProjectEntry *> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@@Z ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@@Z PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@@Z ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEIXZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::max_size
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T219435 = -80						; size = 28
$T219434 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T219435[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T219434[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T219435[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T219434[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T219434[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T219434[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T219434[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T219435[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T219434[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Xlen
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvProjectEntry@@@std@@QAEPAPAVCvProjectEntry@@I@Z ; std::allocator<CvProjectEntry *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvProjectEntry@@@std@@QAEPAPAVCvProjectEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvProjectEntry@@@std@@QAEPAPAVCvProjectEntry@@I@Z PROC ; std::allocator<CvProjectEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvProjectEntry@@@std@@YAPAPAVCvProjectEntry@@IPAPAV1@@Z ; std::_Allocate<CvProjectEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvProjectEntry@@@std@@QAEPAPAVCvProjectEntry@@I@Z ENDP ; std::allocator<CvProjectEntry *>::allocate
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvProjectEntry@@PAPAV1@@stdext@@YAPAPAVCvProjectEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvProjectEntry * *,CvProjectEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvProjectEntry@@PAPAV1@@stdext@@YAPAPAVCvProjectEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvProjectEntry@@PAPAV1@@stdext@@YAPAPAVCvProjectEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvProjectEntry * *,CvProjectEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvProjectEntry@@PAPAV1@@stdext@@YAPAPAVCvProjectEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvProjectEntry * *,CvProjectEntry * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvProjectEntry@@@std@@@std@@YAXPAPAVCvProjectEntry@@0AAV?$allocator@PAVCvProjectEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvProjectEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvProjectEntry@@@std@@@std@@YAXPAPAVCvProjectEntry@@0AAV?$allocator@PAVCvProjectEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvProjectEntry@@@std@@@std@@YAXPAPAVCvProjectEntry@@0AAV?$allocator@PAVCvProjectEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvProjectEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvProjectEntry@@@std@@@std@@YAXPAPAVCvProjectEntry@@0AAV?$allocator@PAVCvProjectEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvProjectEntry *> >
_TEXT	ENDS
PUBLIC	??_GCvProjectEntry@@QAEPAXI@Z			; CvProjectEntry::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvProjectEntry@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvProjectEntry@@QAEPAXI@Z PROC			; CvProjectEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvProjectEntry@@QAE@XZ		; CvProjectEntry::~CvProjectEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvProjectEntry@@QAEPAXI@Z ENDP			; CvProjectEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CvProjectEntry@@QAE@XZ			; CvProjectEntry::CvProjectEntry
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??0CvProjectEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvProjectEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvProjectEntry@@QAE@XZ$1
__ehfuncinfo$??0CvProjectEntry@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvProjectEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvprojectclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvProjectEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvProjectEntry@@QAE@XZ PROC				; CvProjectEntry::CvProjectEntry, COMDAT
; _this$ = ecx

; 21   : {

	push	-1
	push	__ehhandler$??0CvProjectEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	edi, edi
	lea	ecx, DWORD PTR [esi+308]
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	DWORD PTR [esi], OFFSET ??_7CvProjectEntry@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+336]
	mov	BYTE PTR __$EHRec$[esp+32], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 22   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+364], edi
	mov	DWORD PTR [esi+368], edi
	mov	DWORD PTR [esi+372], edi
	mov	DWORD PTR [esi+376], edi
	mov	DWORD PTR [esi+380], edi
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvProjectEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvProjectEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 308				; 00000134H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvProjectEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvProjectEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvProjectEntry@@QAE@XZ ENDP				; CvProjectEntry::CvProjectEntry
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	__imp_??1Results@Database@@UAE@XZ:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z:PROC
EXTRN	__imp_??0Results@Database@@QAE@PBD@Z:PROC
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
__ehfuncinfo$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvprojectclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
tv419 = -596						; size = 4
_iThreshold$218177 = -596				; size = 4
_szProjectType$ = -592					; size = 4
_kDBResults$218162 = -588				; size = 64
_szQuery$218163 = -524					; size = 512
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvProjectEntry::CacheResults, COMDAT
; _this$ = ecx

; 34   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 35   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 584				; 00000248H
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+600]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	je	$LN5@CacheResul
$LN4@CacheResul:
	push	ebx
	push	ebp

; 36   : 		return false;
; 37   : 
; 38   : 	m_iMaxGlobalInstances = kResults.GetInt("MaxGlobalInstances");

	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG218129
	mov	ecx, edi
	call	ebp

; 39   : 	m_iMaxTeamInstances = kResults.GetInt("MaxTeamInstances");

	push	OFFSET $SG218130
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebp

; 40   : 	m_iProductionCost = kResults.GetInt("Cost");

	push	OFFSET $SG218131
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebp

; 41   : 	m_iNukeInterception = kResults.GetInt("NukeInterception");

	push	OFFSET $SG218132
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebp

; 42   : 	m_iCultureBranchesRequired = kResults.GetInt("CultureBranchesRequired");

	push	OFFSET $SG218133
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebp

; 43   : 	m_iTechShare = kResults.GetInt("TechShare");

	push	OFFSET $SG218134
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebp

; 44   : 	m_iVictoryDelayPercent = kResults.GetInt("VictoryDelayPercent");

	push	OFFSET $SG218135
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebp

; 45   : 
; 46   : 	m_bSpaceship = kResults.GetBool("Spaceship");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG218136
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebx

; 47   : 	m_bAllowsNukes = kResults.GetBool("AllowsNukes");

	push	OFFSET $SG218137
	mov	ecx, edi
	mov	BYTE PTR [esi+304], al
	call	ebx

; 48   : 
; 49   : 	m_strMovieArtDef = kResults.GetText("MovieDefineTag");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG218138
	mov	ecx, edi
	mov	BYTE PTR [esi+305], al
	call	ebx
	lea	ecx, DWORD PTR [esi+336]
	test	eax, eax
	je	SHORT $LN9@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN8@CacheResul
$LN9@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN8@CacheResul:

; 50   : 
; 51   : 	const char* szVictoryPrereq = kResults.GetText("VictoryPrereq");

	push	OFFSET $SG218140
	mov	ecx, edi
	call	ebx

; 52   : 	m_iVictoryPrereq = GC.getInfoTypeForString(szVictoryPrereq, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 53   : 
; 54   : 	const char* szTechPrereq = kResults.GetText("TechPrereq");

	push	OFFSET $SG218142
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 55   : 	m_iTechPrereq = GC.getInfoTypeForString(szTechPrereq, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 56   : 
; 57   : 	const char* szEveryoneSpecialUnit = kResults.GetText("EveryoneSpecialUnit");

	push	OFFSET $SG218144
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 58   : 	m_iEveryoneSpecialUnit = GC.getInfoTypeForString(szEveryoneSpecialUnit, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 59   : 
; 60   : 	const char* szCreateSound = kResults.GetText("CreateSound");

	push	OFFSET $SG218146
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebx

; 61   : 	SetCreateSound(szCreateSound);

	lea	ecx, DWORD PTR [esi+308]
	test	eax, eax
	je	SHORT $LN15@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN14@CacheResul
$LN15@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN14@CacheResul:

; 62   : 
; 63   : 	const char* szAnyonePrereqProject = kResults.GetText("AnyonePrereqProject");

	push	OFFSET $SG218148
	mov	ecx, edi
	call	ebx

; 64   : 	m_iAnyoneProjectPrereq = GC.getInfoTypeForString(szAnyonePrereqProject, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 65   : 
; 66   : 	//Arrays
; 67   : 	const char* szProjectType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+268], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 68   : 	kUtility.PopulateArrayByValue(m_piResourceQuantityRequirements, "Resources", "Project_ResourceQuantityRequirements", "ResourceType", "ProjectType", szProjectType, "Quantity");

	mov	edi, DWORD PTR _kUtility$[esp+608]
	push	0
	push	0
	push	OFFSET $SG218150
	push	eax
	push	OFFSET $SG218151
	push	OFFSET $SG218152
	push	OFFSET $SG218153
	push	OFFSET $SG218154
	lea	ecx, DWORD PTR [esi+364]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _szProjectType$[esp+648], eax
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 69   : 
; 70   : 	//Victory Thresholds
; 71   : 	{
; 72   : 		const int iNumVictories = kUtility.MaxRows("Victories");

	push	OFFSET $SG218156
	mov	ecx, edi
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 73   : 
; 74   : 		kUtility.InitializeArray(m_piVictoryThreshold, iNumVictories);

	xor	ecx, ecx
	mov	edi, eax
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+368], eax
	mov	DWORD PTR tv419[esp+628], ecx
	call	_memset

; 75   : 		kUtility.InitializeArray(m_piVictoryMinThreshold, iNumVictories);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR tv419[esp+632]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+372], eax
	call	_memset
	add	esp, 32					; 00000020H

; 76   : 
; 77   : 		Database::Results kDBResults;

	push	0
	lea	ecx, DWORD PTR _kDBResults$218162[esp+616]
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z

; 78   : 		char szQuery[512] = {0};

	push	511					; 000001ffH
	lea	edx, DWORD PTR _szQuery$218163[esp+617]
	push	0
	push	edx
	mov	DWORD PTR __$EHRec$[esp+632], 0
	mov	BYTE PTR _szQuery$218163[esp+624], 0
	call	_memset

; 79   : 		sprintf_s(szQuery, "select VictoryType, Threshold, MinThreshold from Project_VictoryThresholds where ProjectType = '%s';", szProjectType);

	mov	edi, DWORD PTR _szProjectType$[esp+624]
	push	edi
	lea	eax, DWORD PTR _szQuery$218163[esp+628]
	push	OFFSET $SG218169
	push	eax
	call	??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ	; sprintf_s<512>
	add	esp, 24					; 00000018H

; 80   : 		if(DB.Execute(kDBResults, szQuery))

	push	-1
	lea	ecx, DWORD PTR _szQuery$218163[esp+616]
	push	ecx
	lea	edx, DWORD PTR _kDBResults$218162[esp+620]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	push	edx
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z
	test	al, al
	je	SHORT $LN1@CacheResul

; 81   : 		{
; 82   : 			while(kDBResults.Step())

	lea	ecx, DWORD PTR _kDBResults$218162[esp+612]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN1@CacheResul
$LL2@CacheResul:

; 83   : 			{
; 84   : 				const char* szVictoryType = kDBResults.GetText("VictoryType");

	push	OFFSET $SG218175
	lea	ecx, DWORD PTR _kDBResults$218162[esp+616]
	call	ebx

; 85   : 				const int idx = GC.getInfoTypeForString(szVictoryType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 86   : 
; 87   : 				const int iThreshold = kDBResults.GetInt("Threshold");

	push	OFFSET $SG218178
	lea	ecx, DWORD PTR _kDBResults$218162[esp+616]
	mov	edi, eax
	call	ebp

; 88   : 				const int iMinThreshold = kDBResults.GetInt("MinThreshold");

	push	OFFSET $SG218180
	lea	ecx, DWORD PTR _kDBResults$218162[esp+616]
	mov	DWORD PTR _iThreshold$218177[esp+616], eax
	call	ebp

; 89   : 
; 90   : 				m_piVictoryThreshold[idx] = iThreshold;

	mov	ecx, DWORD PTR [esi+368]
	mov	edx, DWORD PTR _iThreshold$218177[esp+612]
	mov	DWORD PTR [ecx+edi*4], edx

; 91   : 				m_piVictoryMinThreshold[idx] = iMinThreshold;

	mov	ecx, DWORD PTR [esi+372]
	mov	DWORD PTR [ecx+edi*4], eax
	lea	ecx, DWORD PTR _kDBResults$218162[esp+612]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL2@CacheResul

; 81   : 		{
; 82   : 			while(kDBResults.Step())

	mov	edi, DWORD PTR _szProjectType$[esp+612]
$LN1@CacheResul:

; 92   : 			}
; 93   : 		}
; 94   : 	}

	lea	ecx, DWORD PTR _kDBResults$218162[esp+612]
	mov	DWORD PTR __$EHRec$[esp+620], -1
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ

; 95   : 
; 96   : 	kUtility.SetFlavors(m_piFlavorValue, "Project_Flavors", "ProjectType", szProjectType);

	mov	ebx, DWORD PTR _kUtility$[esp+608]
	push	0
	push	edi
	push	OFFSET $SG218181
	push	OFFSET $SG218182
	lea	edx, DWORD PTR [esi+380]
	push	edx
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 97   : 	kUtility.PopulateArrayByValue(m_piProjectsNeeded, "Projects", "Project_Prereqs", "PrereqProjectType", "ProjectType", szProjectType, "AmountNeeded");

	push	0
	push	0
	push	OFFSET $SG218183
	push	edi
	push	OFFSET $SG218184
	push	OFFSET $SG218185
	push	OFFSET $SG218186
	push	OFFSET $SG218187
	add	esi, 376				; 00000178H
	push	esi
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue
	pop	ebp

; 98   : 
; 99   : 	return true;

	mov	al, 1
	pop	ebx
$LN5@CacheResul:

; 100  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+604]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 596				; 00000254H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _kDBResults$218162[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvProjectEntry::CacheResults
PUBLIC	?begin@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@XZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@XZ PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@XZ ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@XZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@XZ PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@XZ ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvProjectEntry@@@std@@YAPAPAVCvProjectEntry@@IPAPAV1@@Z ; std::_Allocate<CvProjectEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXPAPAVCvProjectEntry@@0@Z ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXPAPAVCvProjectEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXPAPAVCvProjectEntry@@0@Z PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXPAPAVCvProjectEntry@@0@Z ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvProjectEntry@@@@YAXAAPAVCvProjectEntry@@@Z ; SAFE_DELETE<CvProjectEntry>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvProjectEntry@@@@YAXAAPAVCvProjectEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvProjectEntry@@@@YAXAAPAVCvProjectEntry@@@Z PROC ; SAFE_DELETE<CvProjectEntry>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET
	mov	ecx, esi
	call	??1CvProjectEntry@@QAE@XZ		; CvProjectEntry::~CvProjectEntry
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvProjectEntry@@@@YAXAAPAVCvProjectEntry@@@Z ENDP ; SAFE_DELETE<CvProjectEntry>
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@0@Z ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@0@Z PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@0@Z ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXXZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEXXZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::clear
_TEXT	ENDS
PUBLIC	??0CvProjectXMLEntries@@QAE@XZ			; CvProjectXMLEntries::CvProjectXMLEntries
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvprojectclasses.cpp
;	COMDAT ??0CvProjectXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvProjectXMLEntries@@QAE@XZ PROC			; CvProjectXMLEntries::CvProjectXMLEntries, COMDAT
; _this$ = ecx

; 318  : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 319  : 
; 320  : }

	ret	0
??0CvProjectXMLEntries@@QAE@XZ ENDP			; CvProjectXMLEntries::CvProjectXMLEntries
_TEXT	ENDS
PUBLIC	?DeleteArray@CvProjectXMLEntries@@QAEXXZ	; CvProjectXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteArray@CvProjectXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvProjectXMLEntries@@QAEXXZ PROC		; CvProjectXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 346  : {

	push	ebx
	mov	ebx, ecx
	push	esi

; 347  : 	for(std::vector<CvProjectEntry*>::iterator it = m_paProjectEntries.begin(); it != m_paProjectEntries.end(); ++it)

	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@DeleteArra
	npad	3
$LL14@DeleteArra:

; 348  : 	{
; 349  : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@DeleteArra
	mov	ecx, edi
	call	??1CvProjectEntry@@QAE@XZ		; CvProjectEntry::~CvProjectEntry
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 350  : 	}
; 351  : 
; 352  : 	m_paProjectEntries.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN51@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN76@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN76@DeleteArra:
	mov	DWORD PTR [ebx+8], edi
$LN51@DeleteArra:
	pop	edi
	pop	esi
	pop	ebx

; 353  : }

	ret	0
?DeleteArray@CvProjectXMLEntries@@QAEXXZ ENDP		; CvProjectXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	??1CvProjectXMLEntries@@QAE@XZ			; CvProjectXMLEntries::~CvProjectXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvProjectXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvProjectXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvProjectXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvProjectXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvprojectclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvProjectXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvProjectXMLEntries@@QAE@XZ PROC			; CvProjectXMLEntries::~CvProjectXMLEntries, COMDAT
; _this$ = ecx

; 324  : {

	push	-1
	push	__ehhandler$??1CvProjectXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 325  : 	DeleteArray();

	call	?DeleteArray@CvProjectXMLEntries@@QAEXXZ ; CvProjectXMLEntries::DeleteArray

; 326  : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvProjectX
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvProjectX:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvProjectXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >
__ehhandler$??1CvProjectXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvProjectXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvProjectXMLEntries@@QAE@XZ ENDP			; CvProjectXMLEntries::~CvProjectXMLEntries
END
