; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	s:\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvBuildingProductionAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG217571 DB	'LOAD ERROR: Building Type not found', 00H
$SG217634 DB	'%03d, ', 00H
	ORG $+1
$SG217638 DB	', ', 00H
	ORG $+1
$SG217639 DB	', ', 00H
	ORG $+1
$SG217649 DB	'Building, %s, %d', 00H
CONST	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 131  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@XZ ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@XZ PROC ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@XZ ENDP ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@XZ ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@XZ PROC ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@XZ ENDP ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$0IH@$00@@QAE@XZ ; CvWeightedVector<int,135,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$0IH@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@H$0IH@$00@@QAE@XZ PROC ; CvWeightedVector<int,135,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@H$0IH@$00@@QAE@XZ ENDP ; CvWeightedVector<int,135,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@ DB 's:\lekmod_d'
	DB	'll\fireplace\include\fireworks\FFastVector.h', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 135				; 00000087H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 135			; 00000087H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$0IH@$00@@QAE@ABU01@@Z ; CvWeightedVector<int,135,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$0IH@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@H$0IH@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<int,135,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@H$0IH@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<int,135,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@H$0IH@$00@@QBE_NABU01@@Z ; CvWeightedVector<int,135,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MWeightedElement@?$CvWeightedVector@H$0IH@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@H$0IH@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<int,135,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@H$0IH@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<int,135,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::pair<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>::pair<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z PROC ; std::pair<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>::pair<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ENDP ; std::pair<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>::pair<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z ; std::_Dist_type<CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::swap<CvWeightedVector<int,135,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z PROC ; std::swap<CvWeightedVector<int,135,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ENDP ; std::swap<CvWeightedVector<int,135,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap
	npad	1
$LL3@Push_heap:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::_Iter_random<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?StringData@FStringAData@FStringA@@QAEPADXZ	; FStringA::FStringAData::StringData
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ?StringData@FStringAData@FStringA@@QAEPADXZ
_TEXT	SEGMENT
?StringData@FStringAData@FStringA@@QAEPADXZ PROC	; FStringA::FStringAData::StringData, COMDAT
; _this$ = ecx

; 1067 : 	return ( ( LPSTR )( this + 1 ) );

	lea	eax, DWORD PTR [ecx+12]

; 1068 : }

	ret	0
?StringData@FStringAData@FStringA@@QAEPADXZ ENDP	; FStringA::FStringAData::StringData
_TEXT	ENDS
PUBLIC	?GetData@FStringA@@IBEPAUFStringAData@1@XZ	; FStringA::GetData
; Function compile flags: /Ogtpy
;	COMDAT ?GetData@FStringA@@IBEPAUFStringAData@1@XZ
_TEXT	SEGMENT
?GetData@FStringA@@IBEPAUFStringAData@1@XZ PROC		; FStringA::GetData, COMDAT
; _this$ = ecx

; 1077 : 	assert( m_pszString != NULL );
; 1078 : 
; 1079 : 	return ( ( ( FStringAData* )m_pszString ) - 1 );

	mov	eax, DWORD PTR [ecx]
	sub	eax, 12					; 0000000cH

; 1080 : }

	ret	0
?GetData@FStringA@@IBEPAUFStringAData@1@XZ ENDP		; FStringA::GetData
_TEXT	ENDS
PUBLIC	?Init@FStringA@@IAEXXZ				; FStringA::Init
EXTRN	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ:PROC ; FStringA_GetStringInitData
; Function compile flags: /Ogtpy
;	COMDAT ?Init@FStringA@@IAEXXZ
_TEXT	SEGMENT
?Init@FStringA@@IAEXXZ PROC				; FStringA::Init, COMDAT
; _this$ = ecx

; 1084 : {

	push	esi
	mov	esi, ecx

; 1085 : #ifdef		_NDS
; 1086 : 	static int strEmpty[] = { FIXED, 0 };	// Empty string
; 1087 : 
; 1088 : 	m_pszString = (LPSTR)&strEmpty[1];
; 1089 : #else	//	_NDS
; 1090 : 	m_pszString = FStringA_GetStringInitData()->StringData();

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [esi], eax
	pop	esi

; 1091 : #endif	//	_NDS
; 1092 : }

	ret	0
?Init@FStringA@@IAEXXZ ENDP				; FStringA::Init
_TEXT	ENDS
PUBLIC	?Release@FStringA@@IAEXPAUFStringAData@1@@Z	; FStringA::Release
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
;	COMDAT ?Release@FStringA@@IAEXPAUFStringAData@1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Release@FStringA@@IAEXPAUFStringAData@1@@Z PROC	; FStringA::Release, COMDAT
; _this$ = ecx

; 1105 : {

	push	esi

; 1106 : 	FSTRING_CHECK_BUFFER;
; 1107 : 	if ( pkData && ( pkData != FStringA_GetStringInitData() ) && !pkData->m_bFixed )

	mov	esi, DWORD PTR _pkData$[esp]
	test	esi, esi
	je	SHORT $LN1@Release
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN1@Release
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN1@Release

; 1108 : 	{
; 1109 : #ifdef		ENABLE_FSTRING_STATS
; 1110 : 		extern uint g_uiFStringBytesCurrent;
; 1111 : 		g_uiFStringBytesCurrent -= sizeof ( FStringAData ) + ( sizeof ( char ) * pkData->m_iAllocLength + 1 );
; 1112 : #endif	//	ENABLE_FSTRING_STATS
; 1113 : 
; 1114 : 		// Free any memory associated with the string
; 1115 : 		delete [] ( byte* )pkData;

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@Release:
	pop	esi

; 1116 : 	}
; 1117 : }

	ret	4
?Release@FStringA@@IAEXPAUFStringAData@1@@Z ENDP	; FStringA::Release
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::CvString, COMDAT
; _this$ = ecx

; 26   : 	CvString(const std::string& s): std::string(s) {}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?GetDescription@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescription
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetDescription@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescription@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescription, COMDAT
; _this$ = ecx

; 64   : 		return m_strDescription.c_str();

	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescription@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescription
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@H$0IH@$00@@QBEABHI@Z ; CvWeightedVector<int,135,1>::GetElement
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@H$0IH@$00@@QBEABHI@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@H$0IH@$00@@QBEABHI@Z PROC ; CvWeightedVector<int,135,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@H$0IH@$00@@QBEABHI@Z ENDP ; CvWeightedVector<int,135,1>::GetElement
_TEXT	ENDS
PUBLIC	?GetWeight@?$CvWeightedVector@H$0IH@$00@@QBEHI@Z ; CvWeightedVector<int,135,1>::GetWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeight@?$CvWeightedVector@H$0IH@$00@@QBEHI@Z
_TEXT	SEGMENT
_elem$ = -8						; size = 8
_iIndex$ = 8						; size = 4
?GetWeight@?$CvWeightedVector@H$0IH@$00@@QBEHI@Z PROC	; CvWeightedVector<int,135,1>::GetWeight, COMDAT
; _this$ = ecx

; 70   : 	{

	sub	esp, 8

; 71   : 		WeightedElement elem;
; 72   : 		assert(iIndex < m_pItems.size());
; 73   : 		elem = m_pItems[iIndex];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp+4]
	mov	edx, DWORD PTR [eax+ecx*8]

; 74   : 		return elem.m_iWeight;

	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$[esp+8], edx

; 75   : 	}

	add	esp, 8
	ret	4
?GetWeight@?$CvWeightedVector@H$0IH@$00@@QBEHI@Z ENDP	; CvWeightedVector<int,135,1>::GetWeight
_TEXT	ENDS
PUBLIC	?IncreaseWeight@?$CvWeightedVector@H$0IH@$00@@QAEXIH@Z ; CvWeightedVector<int,135,1>::IncreaseWeight
; Function compile flags: /Ogtpy
;	COMDAT ?IncreaseWeight@?$CvWeightedVector@H$0IH@$00@@QAEXIH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?IncreaseWeight@?$CvWeightedVector@H$0IH@$00@@QAEXIH@Z PROC ; CvWeightedVector<int,135,1>::IncreaseWeight, COMDAT
; _this$ = ecx

; 78   : 		m_pItems[iIndex].m_iWeight += iWeight;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	mov	edx, DWORD PTR _iWeight$[esp-4]
	add	DWORD PTR [eax+ecx*8+4], edx
	lea	eax, DWORD PTR [eax+ecx*8+4]

; 79   : 		CvAssertMsg(m_pItems[iIndex].m_iWeight >= 0, "Weight should not be negative.");
; 80   : 	}

	ret	8
?IncreaseWeight@?$CvWeightedVector@H$0IH@$00@@QAEXIH@Z ENDP ; CvWeightedVector<int,135,1>::IncreaseWeight
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@H$0IH@$00@@QAEHXZ	; CvWeightedVector<int,135,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@H$0IH@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@H$0IH@$00@@QAEHXZ PROC		; CvWeightedVector<int,135,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@H$0IH@$00@@QAEHXZ ENDP		; CvWeightedVector<int,135,1>::size
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 135			; 00000087H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEXXZ ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEXXZ PROC ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$00@@QAEXXZ ENDP ; BaseVector<CvWeightedVector<int,135,1>::WeightedElement,1>::clear
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::Free
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::iter_swap<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ; std::_Med3<CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea
	npad	7
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea
$LN14@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_
	push	esi
$LL8@unchecked_:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_
	pop	esi
$LN7@unchecked_:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??0FStringA@@QAE@XZ				; FStringA::FStringA
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ??0FStringA@@QAE@XZ
_TEXT	SEGMENT
??0FStringA@@QAE@XZ PROC				; FStringA::FStringA, COMDAT
; _this$ = ecx

; 85   : {

	push	esi
	mov	esi, ecx

; 86   : 	Init();

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [esi], eax

; 87   : }

	mov	eax, esi
	pop	esi
	ret	0
??0FStringA@@QAE@XZ ENDP				; FStringA::FStringA
_TEXT	ENDS
PUBLIC	?Release@FStringA@@QAEXXZ			; FStringA::Release
; Function compile flags: /Ogtpy
;	COMDAT ?Release@FStringA@@QAEXXZ
_TEXT	SEGMENT
?Release@FStringA@@QAEXXZ PROC				; FStringA::Release, COMDAT
; _this$ = ecx

; 1096 : {

	push	esi
	push	edi
	mov	edi, ecx

; 1097 : 	Release( GetData() );

	mov	esi, DWORD PTR [edi]
	sub	esi, 12					; 0000000cH
	je	SHORT $LN5@Release@2
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN5@Release@2
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN5@Release@2
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@Release@2:

; 1098 : 	m_pszString = NULL;

	mov	DWORD PTR [edi], 0

; 1099 : 	Init();

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi

; 1100 : }

	ret	0
?Release@FStringA@@QAEXXZ ENDP				; FStringA::Release
_TEXT	ENDS
PUBLIC	?SetFixedBuffer@FStringA@@QAEXPAUFStringAData@1@@Z ; FStringA::SetFixedBuffer
; Function compile flags: /Ogtpy
;	COMDAT ?SetFixedBuffer@FStringA@@QAEXPAUFStringAData@1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?SetFixedBuffer@FStringA@@QAEXPAUFStringAData@1@@Z PROC	; FStringA::SetFixedBuffer, COMDAT
; _this$ = ecx

; 1122 : {

	push	ebx

; 1123 : 	assert( pkData != NULL );
; 1124 : 	if(!pkData) return;

	mov	ebx, DWORD PTR _pkData$[esp]
	push	edi
	mov	edi, ecx
	test	ebx, ebx
	je	SHORT $LN2@SetFixedBu
	push	esi

; 1125 : 	assert( pkData->m_bFixed == 1 );
; 1126 : 	assert( pkData->m_iAllocLength > 0 );
; 1127 : 	Release();

	mov	esi, DWORD PTR [edi]
	sub	esi, 12					; 0000000cH
	je	SHORT $LN8@SetFixedBu
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN8@SetFixedBu
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN8@SetFixedBu
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@SetFixedBu:
	mov	DWORD PTR [edi], 0
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData

; 1128 : 	m_pszString = pkData->StringData();

	add	ebx, 12					; 0000000cH
	mov	DWORD PTR [edi], ebx
	pop	esi
$LN2@SetFixedBu:
	pop	edi
	pop	ebx

; 1129 : }

	ret	4
?SetFixedBuffer@FStringA@@QAEXPAUFStringAData@1@@Z ENDP	; FStringA::SetFixedBuffer
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?Write@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z ; CvBuildingProductionAI::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ:PROC ; CvBuildingXMLEntries::GetNumBuildings
EXTRN	?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvCityBuildings::GetBuildings
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvbuildingproductionai.cpp
;	COMDAT ?Write@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -16					; size = 4
$T218827 = -12						; size = 4
_elem$218843 = -8					; size = 8
$T218828 = -8						; size = 4
_iNumBuildings$217579 = 8				; size = 4
_kStream$ = 8						; size = 4
?Write@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z PROC ; CvBuildingProductionAI::Write, COMDAT
; _this$ = ecx

; 107  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 108  : 	CvAssertMsg(m_pCityBuildings != NULL, "Building Production AI init failure: city buildings are NULL");
; 109  : 
; 110  : 	// Current version number
; 111  : 	uint uiVersion = 1;
; 112  : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiVersion$[esp+24]
	mov	ebx, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+28], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 113  : 
; 114  : 	if(m_pCityBuildings)

	mov	ecx, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	SHORT $LN3@Write
	push	esi

; 115  : 	{
; 116  : 		int iNumBuildings = m_pCityBuildings->GetBuildings()->GetNumBuildings();

	call	?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ ; CvCityBuildings::GetBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings

; 117  : 		kStream << iNumBuildings;

	lea	ecx, DWORD PTR _iNumBuildings$217579[esp+24]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _iNumBuildings$217579[esp+28], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 118  : 
; 119  : 		// Loop through writing each entry
; 120  : 		for(int iI = 0; iI < iNumBuildings; iI++)

	xor	esi, esi
	cmp	DWORD PTR _iNumBuildings$217579[esp+24], esi
	jle	SHORT $LN25@Write
	npad	5
$LL5@Write:

; 121  : 		{
; 122  : 			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
; 123  : 			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 124  : 			if(pkBuildingInfo)

	test	eax, eax
	je	SHORT $LN2@Write

; 125  : 			{
; 126  : 				CvInfosSerializationHelper::WriteHashed(kStream, pkBuildingInfo);

	push	eax
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed

; 127  : 				kStream << m_BuildingAIWeights.GetWeight(iI);

	mov	eax, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR [eax+esi*8+4]
	mov	DWORD PTR $T218827[esp+36], eax
	add	esp, 8
	lea	eax, DWORD PTR $T218827[esp+28]
	mov	DWORD PTR _elem$218843[esp+28], edx
	push	eax

; 128  : 			}
; 129  : 			else

	jmp	SHORT $LN26@Write
$LN2@Write:

; 130  : 			{
; 131  : 				kStream << (int)0;

	lea	ecx, DWORD PTR $T218828[esp+28]
	mov	DWORD PTR $T218828[esp+28], 0
	push	ecx
$LN26@Write:
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	esi
	cmp	esi, DWORD PTR _iNumBuildings$217579[esp+24]
	jl	SHORT $LL5@Write
$LN25@Write:
	pop	esi
$LN3@Write:
	pop	edi
	pop	ebx

; 132  : 			}
; 133  : 		}
; 134  : 	}
; 135  : }

	add	esp, 16					; 00000010H
	ret	4
?Write@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z ENDP ; CvBuildingProductionAI::Write
_TEXT	ENDS
PUBLIC	?AddFlavorWeights@CvBuildingProductionAI@@QAEXW4FlavorTypes@@H@Z ; CvBuildingProductionAI::AddFlavorWeights
EXTRN	?GetFlavorValue@CvBuildingEntry@@QBEHH@Z:PROC	; CvBuildingEntry::GetFlavorValue
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?AddFlavorWeights@CvBuildingProductionAI@@QAEXW4FlavorTypes@@H@Z
_TEXT	SEGMENT
_pkBuildings$ = -4					; size = 4
_eFlavor$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?AddFlavorWeights@CvBuildingProductionAI@@QAEXW4FlavorTypes@@H@Z PROC ; CvBuildingProductionAI::AddFlavorWeights, COMDAT
; _this$ = ecx

; 139  : {

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 140  : #ifdef AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS
; 141  : 	CvPlayer* pPlayer = m_pCity->GetPlayer();
; 142  : 	CvPlayerPolicies* pPlayerPolicies = NULL;
; 143  : 	if (pPlayer)
; 144  : 		pPlayerPolicies = pPlayer->GetPlayerPolicies();
; 145  : #endif
; 146  : #ifdef AUI_BELIEF_BUILDING_CLASS_FLAVOR_MODIFIERS
; 147  : 	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(m_pCity->GetCityReligions()->GetReligiousMajority(), m_pCity->getOwner());
; 148  : #endif
; 149  : 	CvBuildingXMLEntries* pkBuildings = m_pCityBuildings->GetBuildings();

	mov	ecx, DWORD PTR [edi+4]
	call	?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ ; CvCityBuildings::GetBuildings

; 150  : 
; 151  : 	// Loop through all buildings
; 152  : #ifdef AUI_WARNING_FIXES
; 153  : 	for (uint iBuilding = 0; iBuilding < m_pCityBuildings->GetBuildings()->GetNumBuildings(); iBuilding++)
; 154  : #else
; 155  : 	for(int iBuilding = 0; iBuilding < m_pCityBuildings->GetBuildings()->GetNumBuildings(); iBuilding++)

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR _pkBuildings$[esp+12], eax
	xor	esi, esi
	call	?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ ; CvCityBuildings::GetBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	test	eax, eax
	jle	SHORT $LN2@AddFlavorW
	push	ebx
	mov	ebx, DWORD PTR _iWeight$[esp+12]
	push	ebp
	mov	ebp, DWORD PTR _eFlavor$[esp+16]
$LL4@AddFlavorW:

; 156  : #endif
; 157  : 	{
; 158  : 		CvBuildingEntry* entry = pkBuildings->GetEntry(iBuilding);

	mov	ecx, DWORD PTR _pkBuildings$[esp+20]
	push	esi
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry

; 159  : 		if(entry)

	test	eax, eax
	je	SHORT $LN3@AddFlavorW

; 160  : 		{
; 161  : 			// Set its weight by looking at building's weight for this flavor and using iWeight multiplier passed in
; 162  : #if defined(AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS) || defined(AUI_BELIEF_BUILDING_CLASS_FLAVOR_MODIFIERS) || defined(AUI_BUILDING_PRODUCTION_AI_LUA_FLAVOR_WEIGHTS) || defined(AUI_BUILDING_PRODUCTION_AI_CONSIDER_FREE_STUFF)
; 163  : 			int iFlavorValue = entry->GetFlavorValue(eFlavor);
; 164  : #endif
; 165  : #ifdef AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS
; 166  : 			if (pPlayerPolicies)
; 167  : 			{
; 168  : 				for (int iI = 0; iI < GC.getNumPolicyInfos(); iI++)
; 169  : 				{
; 170  : 					PolicyTypes ePolicy = static_cast<PolicyTypes>(iI);
; 171  : 					CvPolicyEntry* pPolicy = GC.getPolicyInfo(ePolicy);
; 172  : 					if (pPolicy && pPlayerPolicies->HasPolicy(ePolicy))
; 173  : 					{
; 174  : 						iFlavorValue += pPolicy->GetBuildingClassFlavorChanges(entry->GetBuildingClassType(), eFlavor);
; 175  : 					}
; 176  : 				}
; 177  : 			}
; 178  : #endif
; 179  : #ifdef AUI_BELIEF_BUILDING_CLASS_FLAVOR_MODIFIERS
; 180  : 			if (pReligion)
; 181  : 			{
; 182  : 				pReligion->m_Beliefs.GetBuildingClassFlavorChange(static_cast<BuildingClassTypes>(entry->GetBuildingClassType()), eFlavor);
; 183  : 			}
; 184  : #endif
; 185  : #ifdef AUI_BUILDING_PRODUCTION_AI_CONSIDER_FREE_STUFF
; 186  : #ifdef AUI_WARNING_FIXES
; 187  : 			for (uint iI = 0; iI < GC.getNumUnitInfos(); iI++)
; 188  : #else
; 189  : 			for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
; 190  : #endif
; 191  : 			{
; 192  : 				int iNumFreeUnits = entry->GetNumFreeUnits(iI);
; 193  : 				if (iNumFreeUnits > 0)
; 194  : 				{
; 195  : 					iFlavorValue += iNumFreeUnits * m_pCity->GetCityStrategyAI()->GetUnitProductionAI()->GetWeight((UnitTypes)iI);
; 196  : 				}
; 197  : 			}
; 198  : #endif
; 199  : #if defined(AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS) || defined(AUI_BELIEF_BUILDING_CLASS_FLAVOR_MODIFIERS) || defined(AUI_BUILDING_PRODUCTION_AI_LUA_FLAVOR_WEIGHTS) || defined(AUI_BUILDING_PRODUCTION_AI_CONSIDER_FREE_STUFF)
; 200  : 			m_BuildingAIWeights.IncreaseWeight(iBuilding, iFlavorValue * iWeight);
; 201  : #else
; 202  : 			m_BuildingAIWeights.IncreaseWeight(iBuilding, entry->GetFlavorValue(eFlavor) * iWeight);

	push	ebp
	mov	ecx, eax
	call	?GetFlavorValue@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetFlavorValue
	imul	eax, ebx
	mov	ecx, DWORD PTR [edi+8]
	add	DWORD PTR [ecx+esi*8+4], eax
	lea	ecx, DWORD PTR [ecx+esi*8+4]
$LN3@AddFlavorW:
	mov	ecx, DWORD PTR [edi+4]
	inc	esi
	call	?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ ; CvCityBuildings::GetBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	esi, eax
	jl	SHORT $LL4@AddFlavorW
	pop	ebp
	pop	ebx
$LN2@AddFlavorW:
	pop	edi
	pop	esi

; 203  : #endif
; 204  : 		}
; 205  : 	}
; 206  : }

	pop	ecx
	ret	8
?AddFlavorWeights@CvBuildingProductionAI@@QAEXW4FlavorTypes@@H@Z ENDP ; CvBuildingProductionAI::AddFlavorWeights
_TEXT	ENDS
PUBLIC	?GetWeight@CvBuildingProductionAI@@QAEHW4BuildingTypes@@@Z ; CvBuildingProductionAI::GetWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeight@CvBuildingProductionAI@@QAEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_elem$218884 = -8					; size = 8
_eBuilding$ = 8						; size = 4
?GetWeight@CvBuildingProductionAI@@QAEHW4BuildingTypes@@@Z PROC ; CvBuildingProductionAI::GetWeight, COMDAT
; _this$ = ecx

; 210  : {

	sub	esp, 8

; 211  : #ifdef AUI_BUILDING_PRODUCTION_AI_CONSIDER_FREE_STUFF
; 212  : 	CvBuildingXMLEntries* pkBuildings = m_pCityBuildings->GetBuildings();
; 213  : 	int iWeight = m_BuildingAIWeights.GetWeight(eBuilding);
; 214  : 	CvBuildingEntry* entry = pkBuildings->GetEntry(eBuilding);
; 215  : 	if (entry)
; 216  : 	{
; 217  : 		CvPlayer* pPlayer = m_pCity->GetPlayer();
; 218  : 		int iLoop = 0;
; 219  : 
; 220  : 		BuildingTypes eFreeBuildingThisCity = static_cast<BuildingTypes>(entry->GetFreeBuildingThisCity());
; 221  : 		if (eFreeBuildingThisCity != NO_BUILDING)
; 222  : 		{
; 223  : 			if (m_pCityBuildings->GetNumBuilding(eFreeBuildingThisCity) == 0)
; 224  : 				iWeight += m_BuildingAIWeights.GetWeight(eFreeBuildingThisCity);
; 225  : 		}
; 226  : 
; 227  : 		BuildingClassTypes eFreeBuildingClassAllCities = static_cast<BuildingClassTypes>(entry->GetFreeBuildingClass());
; 228  : 		if (eFreeBuildingClassAllCities != NO_BUILDINGCLASS)
; 229  : 		{
; 230  : 			BuildingTypes eFreeBuilding = static_cast<BuildingTypes>(m_pCity->getCivilizationInfo().getCivilizationBuildings(eFreeBuildingClassAllCities));
; 231  : 			for (CvCity* pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))
; 232  : 			{
; 233  : 				if (pLoopCity->GetCityBuildings()->GetNumBuilding(eFreeBuilding) == 0)
; 234  : 					iWeight += pLoopCity->GetCityStrategyAI()->GetBuildingProductionAI()->GetWeight(eFreeBuilding);
; 235  : 			}
; 236  : 		}
; 237  : 
; 238  : #ifdef AUI_WARNING_FIXES
; 239  : 		for (uint iI = 0; iI < GC.getNumUnitInfos(); iI++)
; 240  : #else
; 241  : 		for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
; 242  : #endif
; 243  : 		{
; 244  : 			int iNumFreeUnits = entry->GetNumFreeUnits(iI);
; 245  : 			if (iNumFreeUnits > 0)
; 246  : 			{
; 247  : 				iWeight += iNumFreeUnits * m_pCity->GetCityStrategyAI()->GetUnitProductionAI()->GetWeight((UnitTypes)iI);
; 248  : 			}
; 249  : 		}
; 250  : 
; 251  : 		if (entry->GetInstantMilitaryIncrease())
; 252  : 		{
; 253  : 			FFastVector<UnitTypes, true, c_eCiv5GameplayDLL> aExtraUnits;
; 254  : 			for (CvUnit* pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))
; 255  : 			{
; 256  : 				if (pLoopUnit->getDomainType() == DOMAIN_LAND && pLoopUnit->IsCombatUnit())
; 257  : 				{
; 258  : 					UnitTypes eCurrentUnitType = pLoopUnit->getUnitType();
; 259  : 
; 260  : 					// check for duplicate unit
; 261  : 					bool bAddUnit = true;
; 262  : 					for (uint ui = 0; ui < aExtraUnits.size(); ui++)
; 263  : 					{
; 264  : 						if (aExtraUnits[ui] == eCurrentUnitType)
; 265  : 						{
; 266  : 							bAddUnit = false;
; 267  : 							break;
; 268  : 						}
; 269  : 					}
; 270  : 					if (bAddUnit)
; 271  : 					{
; 272  : 						aExtraUnits.push_back(eCurrentUnitType);
; 273  : 					}
; 274  : 				}
; 275  : 			}
; 276  : 			for (uint ui = 0; ui < aExtraUnits.size(); ui++)
; 277  : 			{
; 278  : 				iWeight += m_pCity->GetCityStrategyAI()->GetUnitProductionAI()->GetWeight(aExtraUnits[ui]);
; 279  : 			}
; 280  : 		}
; 281  : 	}
; 282  : 	return iWeight;
; 283  : #else
; 284  : 	return m_BuildingAIWeights.GetWeight(eBuilding);

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _eBuilding$[esp+4]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$218884[esp+8], edx

; 285  : #endif
; 286  : }

	add	esp, 8
	ret	4
?GetWeight@CvBuildingProductionAI@@QAEHW4BuildingTypes@@@Z ENDP ; CvBuildingProductionAI::GetWeight
_TEXT	ENDS
PUBLIC	?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ ; CvBuildingProductionAI::LogPossibleBuilds
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z:PROC ; CvCityStrategyAI::GetLogFileName
EXTRN	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ:PROC ; CvCity::GetCityStrategyAI
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$6
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$9
	DD	07H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$9
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvbuildingproductionai.cpp
xdata$x	ENDS
;	COMDAT ?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ
_TEXT	SEGMENT
_iI$217642 = -224					; size = 4
_pGameBuildings$217640 = -220				; size = 4
_strTemp$217648 = -216					; size = 28
$T218895 = -216						; size = 28
_strOutBuf$217650 = -188				; size = 28
$T218896 = -188						; size = 28
_strBaseString$217633 = -160				; size = 28
_playerName$217628 = -132				; size = 28
_cityName$217629 = -104					; size = 28
$T218897 = -76						; size = 28
$T218894 = -76						; size = 28
_elem$218977 = -48					; size = 8
$T218893 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ PROC	; CvBuildingProductionAI::LogPossibleBuilds, COMDAT
; _this$ = ecx

; 332  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 212				; 000000d4H
	push	esi
	mov	esi, ecx

; 333  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@LogPossibl
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@LogPossibl

; 334  : 	{
; 335  : 		// Find the name of this civ and city
; 336  : 		CvString playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	test	eax, eax
	jne	SHORT $LN28@LogPossibl
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN28@LogPossibl:
	push	ebx
	push	ebp
	push	edi
	push	eax
	lea	ecx, DWORD PTR _playerName$217628[esp+244]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 337  : 		CvString cityName = m_pCity->getName();

	lea	ecx, DWORD PTR _cityName$217629[esp+240]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[esp+252], 0
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	BYTE PTR __$EHRec$[esp+248], 1

; 338  : 
; 339  : 		// Open the log file
; 340  : 		FILogFile* pLog = LOGFILEMGR.GetLog(m_pCity->GetCityStrategyAI()->GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	edx, DWORD PTR _cityName$217629[esp+240]
	mov	edi, eax
	push	edx
	lea	eax, DWORD PTR _playerName$217628[esp+244]
	push	eax
	lea	ecx, DWORD PTR $T218893[esp+248]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+248], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [edi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, edi
	call	eax
	lea	ecx, DWORD PTR $T218893[esp+240]
	mov	ebp, eax
	mov	BYTE PTR __$EHRec$[esp+248], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 341  : 
; 342  : 		// Get the leading info for this line
; 343  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$217633[esp+240]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 344  : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR __$EHRec$[esp+248], 3
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$217633[esp+244]
	push	OFFSET $SG217634
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 345  : 		strBaseString += playerName + ", " + cityName + ", ";

	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG217639
	lea	edx, DWORD PTR _playerName$217628[esp+256]
	push	edx
	lea	eax, DWORD PTR $T218894[esp+260]
	push	eax
	call	edi
	lea	ecx, DWORD PTR _cityName$217629[esp+264]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T218895[esp+272]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+284], 4
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	push	OFFSET $SG217638
	push	eax
	lea	eax, DWORD PTR $T218896[esp+284]
	mov	bl, 5
	push	eax
	mov	BYTE PTR __$EHRec$[esp+296], bl
	call	edi
	add	esp, 48					; 00000030H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$217633[esp+244]
	mov	BYTE PTR __$EHRec$[esp+252], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T218896[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T218895[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T218894[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 346  : 
; 347  : 		// Dump out the weight of each buildable item
; 348  : 		CvBuildingXMLEntries* pGameBuildings = GC.GetGameBuildings();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	mov	DWORD PTR _pGameBuildings$217640[esp+240], ecx

; 349  : 		if(pGameBuildings != NULL)

	test	ecx, ecx
	je	$LN2@LogPossibl

; 350  : 		{
; 351  : 			for(int iI = 0; iI < m_Buildables.size(); iI++)

	cmp	DWORD PTR [esi+1108], 0
	mov	DWORD PTR _iI$217642[esp+240], 0
	jle	$LN2@LogPossibl
	jmp	SHORT $LN4@LogPossibl
	npad	8
$LL81@LogPossibl:
	mov	ecx, DWORD PTR _pGameBuildings$217640[esp+240]
$LN4@LogPossibl:
	mov	edi, DWORD PTR _iI$217642[esp+240]
	mov	eax, DWORD PTR [esi+1104]
	add	edi, edi
	add	edi, edi
	add	edi, edi

; 352  : 			{
; 353  : 				CvBuildingEntry* pBuildingEntry = pGameBuildings->GetEntry(m_Buildables.GetElement(iI));;

	mov	edx, DWORD PTR [eax+edi]
	add	eax, edi
	push	edx
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	ebx, eax

; 354  : 				if(pBuildingEntry != NULL)

	test	ebx, ebx
	je	$LN3@LogPossibl

; 355  : 				{
; 356  : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217648[esp+240]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 357  : 					strTemp.Format("Building, %s, %d", pBuildingEntry->GetDescription(), m_Buildables.GetWeight(iI));

	mov	eax, DWORD PTR [esi+1104]
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [edi+eax+4]
	mov	DWORD PTR _elem$218977[esp+240], ecx
	push	eax
	lea	ecx, DWORD PTR [ebx+36]
	mov	BYTE PTR __$EHRec$[esp+252], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strTemp$217648[esp+248]
	push	OFFSET $SG217649
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 358  : 					CvString strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$217648[esp+256]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$217633[esp+260]
	push	ecx
	lea	edx, DWORD PTR $T218897[esp+264]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$217650[esp+244]
	mov	BYTE PTR __$EHRec$[esp+252], 8
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	ecx, DWORD PTR $T218897[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 10		; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 359  : 					pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$217650[esp+240]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebp
	call	edx
	add	esp, 8

; 360  : 				}

	lea	ecx, DWORD PTR _strOutBuf$217650[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$217648[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@LogPossibl:
	mov	eax, DWORD PTR _iI$217642[esp+240]
	inc	eax
	cmp	eax, DWORD PTR [esi+1108]
	mov	DWORD PTR _iI$217642[esp+240], eax
	jl	$LL81@LogPossibl
$LN2@LogPossibl:

; 361  : 			}
; 362  : 		}
; 363  : 	}

	lea	ecx, DWORD PTR _strBaseString$217633[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _cityName$217629[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$217628[esp+240]
	mov	DWORD PTR __$EHRec$[esp+248], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	ebp
	pop	ebx
$LN6@LogPossibl:

; 364  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+228]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 224				; 000000e0H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _playerName$217628[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _cityName$217629[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR $T218893[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strBaseString$217633[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T218894[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T218895[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$6:
	lea	ecx, DWORD PTR $T218896[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$7:
	lea	ecx, DWORD PTR _strTemp$217648[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$8:
	lea	ecx, DWORD PTR $T218897[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ$9:
	lea	ecx, DWORD PTR _strOutBuf$217650[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ ENDP	; CvBuildingProductionAI::LogPossibleBuilds
PUBLIC	?clear@?$CvWeightedVector@H$0IH@$00@@QAEXXZ	; CvWeightedVector<int,135,1>::clear
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?clear@?$CvWeightedVector@H$0IH@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$CvWeightedVector@H$0IH@$00@@QAEXXZ PROC	; CvWeightedVector<int,135,1>::clear, COMDAT
; _this$ = ecx

; 116  : 		m_pItems.clear();

	mov	DWORD PTR [ecx+4], 0

; 117  : 	};

	ret	0
?clear@?$CvWeightedVector@H$0IH@$00@@QAEXXZ ENDP	; CvWeightedVector<int,135,1>::clear
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::~FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::~FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::~FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN34@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 135				; 00000087H
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize
$LN16@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 135			; 00000087H
$LN15@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+1092], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z ; FStringA::FStringAFixedBuffer<64>::FStringAFixedBuffer<64>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z PROC ; FStringA::FStringAFixedBuffer<64>::FStringAFixedBuffer<64>, COMDAT
; _this$ = ecx

; 58   : {

	push	ebx
	push	ebp

; 59   : 	assert( nLENGTH > 0 );
; 60   : 	m_kStringData.m_bLocked = 0;
; 61   : 	m_kStringData.m_bFixed = 1;
; 62   : 	m_kStringData.m_iAllocLength = nLENGTH;
; 63   : 	m_kStringData.m_iDataLength = 0;
; 64   : 	m_szStringBuffer[ 0 ] = 0;
; 65   : 	str.SetFixedBuffer( &m_kStringData );

	mov	ebp, DWORD PTR _str$[esp+4]
	push	esi
	mov	esi, ecx
	xor	eax, eax
	mov	ecx, 1
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	mov	WORD PTR [esi+8], ax
	mov	WORD PTR [esi+10], cx
	mov	DWORD PTR [esi], 64			; 00000040H
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [ebx], al
	mov	edi, DWORD PTR [ebp]
	sub	edi, 12					; 0000000cH
	je	SHORT $LN19@FStringAFi
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	edi, eax
	je	SHORT $LN19@FStringAFi
	cmp	WORD PTR [edi+10], 0
	jne	SHORT $LN19@FStringAFi
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN19@FStringAFi:
	mov	DWORD PTR [ebp], 0
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	pop	edi

; 66   : }

	mov	eax, esi
	pop	esi
	mov	DWORD PTR [ebp], ebx
	pop	ebp
	pop	ebx
	ret	4
??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z ENDP ; FStringA::FStringAFixedBuffer<64>::FStringAFixedBuffer<64>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ; std::_Median<CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z PROC ; std::_Median<CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ; std::_Med3<CvWeightedVector<int,135,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ; std::_Med3<CvWeightedVector<int,135,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ; std::_Med3<CvWeightedVector<int,135,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ; std::_Med3<CvWeightedVector<int,135,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ; std::_Med3<CvWeightedVector<int,135,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	npad	3
$LL2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_
	push	ebx
	push	esi
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_
	npad	7
$LL22@Insertion_:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_
$LN21@Insertion_:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_
	pop	esi
	pop	ebx
$LN6@Insertion_:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??1FStringA@@QAE@XZ				; FStringA::~FStringA
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ??1FStringA@@QAE@XZ
_TEXT	SEGMENT
??1FStringA@@QAE@XZ PROC				; FStringA::~FStringA, COMDAT
; _this$ = ecx

; 151  : {

	push	esi
	push	edi
	mov	edi, ecx

; 152  : 	Release();

	mov	esi, DWORD PTR [edi]
	sub	esi, 12					; 0000000cH
	je	SHORT $LN7@FStringA
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN7@FStringA
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN7@FStringA
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@FStringA:
	mov	DWORD PTR [edi], 0
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi

; 153  : }

	ret	0
??1FStringA@@QAE@XZ ENDP				; FStringA::~FStringA
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@H$0IH@$00@@QAE@XZ		; CvWeightedVector<int,135,1>::CvWeightedVector<int,135,1>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@H$0IH@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@H$0IH@$00@@QAE@XZ PROC		; CvWeightedVector<int,135,1>::CvWeightedVector<int,135,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 135			; 00000087H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@H$0IH@$00@@QAE@XZ ENDP		; CvWeightedVector<int,135,1>::CvWeightedVector<int,135,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@H$0IH@$00@@QAE@XZ		; CvWeightedVector<int,135,1>::~CvWeightedVector<int,135,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@H$0IH@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@H$0IH@$00@@QAE@XZ PROC		; CvWeightedVector<int,135,1>::~CvWeightedVector<int,135,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@H$0IH@$00@@QAE@XZ ENDP		; CvWeightedVector<int,135,1>::~CvWeightedVector<int,135,1>
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::push_back
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z PROC ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+1092], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z
_TEXT	SEGMENT
__Tmp$219501 = -24					; size = 8
__Tmp$219430 = -16					; size = 8
__Tmp$219456 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ; std::_Median<CvWeightedVector<int,135,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_
	npad	6
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$219430[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$219430[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$219456[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$219456[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_
$LN111@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$219501[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$219501[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$219501[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$219501[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::make_heap<CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::pop_heap<CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z ; CvBuildingProductionAI::CvBuildingProductionAI
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z$0
__ehfuncinfo$??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvbuildingproductionai.cpp
xdata$x	ENDS
;	COMDAT ??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pCity$ = 8						; size = 4
_pCityBuildings$ = 12					; size = 4
??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z PROC ; CvBuildingProductionAI::CvBuildingProductionAI, COMDAT
; _this$ = ecx

; 20   : {

	push	-1
	push	__ehhandler$??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	edx, DWORD PTR _pCityBuildings$[esp+12]
	mov	eax, ecx
	mov	ecx, DWORD PTR _pCity$[esp+12]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	lea	ecx, DWORD PTR [eax+20]
	mov	edx, 135				; 00000087H
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+8], ecx
	lea	ecx, DWORD PTR [eax+1116]
	mov	DWORD PTR [eax+1104], ecx

; 21   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR [eax+1108], 0
	mov	DWORD PTR [eax+1112], edx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$CvWeightedVector@H$0IH@$00@@QAE@XZ	; CvWeightedVector<int,135,1>::~CvWeightedVector<int,135,1>
__ehhandler$??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvBuildingProductionAI@@QAE@PAVCvCity@@PAVCvCityBuildings@@@Z ENDP ; CvBuildingProductionAI::CvBuildingProductionAI
PUBLIC	??1CvBuildingProductionAI@@QAE@XZ		; CvBuildingProductionAI::~CvBuildingProductionAI
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvBuildingProductionAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBuildingProductionAI@@QAE@XZ$0
__ehfuncinfo$??1CvBuildingProductionAI@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvBuildingProductionAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvbuildingproductionai.cpp
xdata$x	ENDS
;	COMDAT ??1CvBuildingProductionAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBuildingProductionAI@@QAE@XZ PROC			; CvBuildingProductionAI::~CvBuildingProductionAI, COMDAT
; _this$ = ecx

; 25   : {

	push	-1
	push	__ehhandler$??1CvBuildingProductionAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi

; 26   : }

	mov	eax, DWORD PTR [esi+1104]
	lea	ecx, DWORD PTR [esi+1116]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	cmp	eax, ecx
	je	SHORT $LN10@CvBuilding
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN10@CvBuilding:
	mov	eax, DWORD PTR [esi+8]
	add	esi, 20					; 00000014H
	cmp	eax, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	pop	esi
	je	SHORT $LN27@CvBuilding
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN27@CvBuilding:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBuildingProductionAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$CvWeightedVector@H$0IH@$00@@QAE@XZ	; CvWeightedVector<int,135,1>::~CvWeightedVector<int,135,1>
__ehhandler$??1CvBuildingProductionAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBuildingProductionAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBuildingProductionAI@@QAE@XZ ENDP			; CvBuildingProductionAI::~CvBuildingProductionAI
PUBLIC	?push_back@?$CvWeightedVector@H$0IH@$00@@QAEIABHH@Z ; CvWeightedVector<int,135,1>::push_back
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@H$0IH@$00@@QAEIABHH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@H$0IH@$00@@QAEIABHH@Z PROC ; CvWeightedVector<int,135,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+1092], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@2
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::GrowSize
$LN5@push_back@2:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@2
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@2:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@H$0IH@$00@@QAEIABHH@Z ENDP ; CvWeightedVector<int,135,1>::push_back
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap
$LN24@Sort_heap:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?Reset@CvBuildingProductionAI@@QAEXXZ		; CvBuildingProductionAI::Reset
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvbuildingproductionai.cpp
;	COMDAT ?Reset@CvBuildingProductionAI@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvBuildingProductionAI@@QAEXXZ PROC		; CvBuildingProductionAI::Reset, COMDAT
; _this$ = ecx

; 30   : {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 31   : 	CvAssertMsg(m_pCityBuildings != NULL, "Building Production AI init failure: city buildings are NULL");
; 32   : 
; 33   : 	m_BuildingAIWeights.clear();

	xor	ebx, ebx
	mov	DWORD PTR [ebp+12], ebx

; 34   : 
; 35   : 	// Loop through reading each one and add an entry with 0 weight to our vector
; 36   : 	if(m_pCityBuildings)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, ebx
	je	SHORT $LN1@Reset
	push	edi

; 37   : 	{
; 38   : #ifdef AUI_WARNING_FIXES
; 39   : 		for (uint i = 0; i < m_pCityBuildings->GetBuildings()->GetNumBuildings(); i++)
; 40   : #else
; 41   : 		for(int i = 0; i < m_pCityBuildings->GetBuildings()->GetNumBuildings(); i++)

	xor	edi, edi
	call	?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ ; CvCityBuildings::GetBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	test	eax, eax
	jle	SHORT $LN33@Reset
	push	esi
	lea	esi, DWORD PTR [ebp+8]
	npad	9
$LL3@Reset:

; 42   : #endif
; 43   : 		{
; 44   : 			m_BuildingAIWeights.push_back(i, 0);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+1092], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN21@Reset
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::GrowSize
$LN21@Reset:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	cmp	eax, ebx
	je	SHORT $LN24@Reset
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebx
$LN24@Reset:
	inc	DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ebp+4]
	inc	edi
	call	?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ ; CvCityBuildings::GetBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	edi, eax
	jl	SHORT $LL3@Reset
	pop	esi
$LN33@Reset:
	pop	edi
$LN1@Reset:
	pop	ebp
	pop	ebx

; 45   : 		}
; 46   : 	}
; 47   : }

	ret	0
?Reset@CvBuildingProductionAI@@QAEXXZ ENDP		; CvBuildingProductionAI::Reset
_TEXT	ENDS
PUBLIC	?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z ; CvBuildingProductionAI::Read
EXTRN	?LogMessage@CvGlobals@@QAEXPBD@Z:PROC		; CvGlobals::LogMessage
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fstringa.inl
xdata$x	SEGMENT
__unwindtable$?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z$1
__ehfuncinfo$?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvbuildingproductionai.cpp
xdata$x	ENDS
;	COMDAT ?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_bValid$217564 = -137					; size = 1
_sTemp$217544 = -136					; size = 4
_iI$217560 = -132					; size = 4
_iNumEntries$217543 = -128				; size = 4
_iWeight$217567 = -124					; size = 4
_uiVersion$ = -120					; size = 4
_szError$217570 = -116					; size = 28
_FStringFixedBuffer_sTemp$217558 = -88			; size = 76
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z PROC ; CvBuildingProductionAI::Read, COMDAT
; _this$ = ecx

; 51   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	ebp
	push	esi

; 52   : 	// Version number to maintain backwards compatibility
; 53   : 	uint uiVersion;
; 54   : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp+152]
	mov	ebp, ecx
	mov	ecx, DWORD PTR _kStream$[esp+148]
	push	eax
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 55   : 
; 56   : 	// Reset vector
; 57   : 	m_BuildingAIWeights.clear();

	xor	ebx, ebx
	lea	esi, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], ebx

; 58   : 
; 59   : 	// Loop through reading each one and adding it to our vector
; 60   : 	if(m_pCityBuildings)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, ebx
	je	$LN12@Read
	push	edi

; 61   : 	{
; 62   : #ifdef AUI_WARNING_FIXES
; 63   : 		for (uint i = 0; i < m_pCityBuildings->GetBuildings()->GetNumBuildings(); i++)
; 64   : #else
; 65   : 		for(int i = 0; i < m_pCityBuildings->GetBuildings()->GetNumBuildings(); i++)

	xor	edi, edi
	call	?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ ; CvCityBuildings::GetBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	test	eax, eax
	jle	SHORT $LN9@Read
	npad	9
$LL11@Read:

; 66   : #endif
; 67   : 		{
; 68   : 			m_BuildingAIWeights.push_back(i, 0);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+1092], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN33@Read
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::GrowSize
$LN33@Read:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	cmp	eax, ebx
	je	SHORT $LN36@Read
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebx
$LN36@Read:
	inc	DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ebp+4]
	inc	edi
	call	?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ ; CvCityBuildings::GetBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	edi, eax
	jl	SHORT $LL11@Read
$LN9@Read:

; 69   : 		}
; 70   : 
; 71   : 		int iNumEntries;
; 72   : 		FStringFixedBuffer(sTemp, 64);

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _sTemp$217544[esp+156], eax
	xor	ecx, ecx
	lea	edi, DWORD PTR [eax-12]
	mov	edx, 1
	mov	DWORD PTR __$EHRec$[esp+164], ebx
	mov	WORD PTR _FStringFixedBuffer_sTemp$217558[esp+164], cx
	mov	WORD PTR _FStringFixedBuffer_sTemp$217558[esp+166], dx
	mov	DWORD PTR _FStringFixedBuffer_sTemp$217558[esp+156], 64 ; 00000040H
	mov	DWORD PTR _FStringFixedBuffer_sTemp$217558[esp+160], ebx
	mov	BYTE PTR _FStringFixedBuffer_sTemp$217558[esp+168], bl
	cmp	edi, ebx
	je	SHORT $LN58@Read
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	edi, eax
	je	SHORT $LN58@Read
	cmp	WORD PTR [edi+10], bx
	jne	SHORT $LN58@Read
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN58@Read:
	mov	DWORD PTR _sTemp$217544[esp+156], ebx
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData

; 73   : 		int iType;
; 74   : 
; 75   : 		kStream >> iNumEntries;

	mov	ebp, DWORD PTR _kStream$[esp+152]
	lea	ecx, DWORD PTR _iNumEntries$217543[esp+156]
	lea	eax, DWORD PTR _FStringFixedBuffer_sTemp$217558[esp+168]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR _sTemp$217544[esp+160], eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 76   : 
; 77   : 		for(int iI = 0; iI < iNumEntries; iI++)

	cmp	DWORD PTR _iNumEntries$217543[esp+156], ebx
	mov	DWORD PTR _iI$217560[esp+156], ebx
	jle	$LN100@Read
$LL8@Read:

; 78   : 		{
; 79   : 			bool bValid = true;
; 80   : 			iType = CvInfosSerializationHelper::ReadHashed(kStream, &bValid);

	lea	edx, DWORD PTR _bValid$217564[esp+156]
	push	edx
	push	ebp
	mov	BYTE PTR _bValid$217564[esp+164], 1
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	edi, eax
	add	esp, 8

; 81   : 			if(iType != -1 || !bValid)

	cmp	edi, -1
	jne	SHORT $LN4@Read
	cmp	BYTE PTR _bValid$217564[esp+156], bl
	jne	SHORT $LN7@Read
$LN4@Read:

; 82   : 			{
; 83   : 				int iWeight;
; 84   : 				kStream >> iWeight;

	lea	eax, DWORD PTR _iWeight$217567[esp+156]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 85   : 				if(iType != -1)

	cmp	edi, -1
	je	SHORT $LN3@Read

; 86   : 				{
; 87   : 					m_BuildingAIWeights.IncreaseWeight(iType, iWeight);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _iWeight$217567[esp+156]
	add	DWORD PTR [ecx+edi*8+4], edx
	lea	eax, DWORD PTR [ecx+edi*8+4]

; 88   : 				}
; 89   : 				else

	jmp	SHORT $LN7@Read
$LN3@Read:

; 90   : 				{
; 91   : 					CvString szError;

	lea	ecx, DWORD PTR _szError$217570[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 92   : 					szError.Format("LOAD ERROR: Building Type not found");

	lea	eax, DWORD PTR _szError$217570[esp+156]
	push	OFFSET $SG217571
	push	eax
	mov	BYTE PTR __$EHRec$[esp+172], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 93   : 					GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$217570[esp+156]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 94   : 					CvAssertMsg(false, szError);
; 95   : 				}

	lea	ecx, DWORD PTR _szError$217570[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@Read:
	mov	eax, DWORD PTR _iI$217560[esp+156]
	inc	eax
	cmp	eax, DWORD PTR _iNumEntries$217543[esp+156]
	mov	DWORD PTR _iI$217560[esp+156], eax
	jl	$LL8@Read
$LN100@Read:

; 96   : 			}
; 97   : 		}
; 98   : 	}

	mov	DWORD PTR __$EHRec$[esp+164], -1
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	lea	ecx, DWORD PTR _FStringFixedBuffer_sTemp$217558[esp+156]
	pop	edi
	cmp	ecx, eax
	je	SHORT $LN89@Read
	cmp	WORD PTR _FStringFixedBuffer_sTemp$217558[esp+162], bx
	jne	SHORT $LN89@Read
	mov	edx, ecx
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN89@Read:
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
$LN12@Read:

; 99   : 	else
; 100  : 	{
; 101  : 		CvAssertMsg(m_pCityBuildings != NULL, "Building Production AI init failure: city buildings are NULL");
; 102  : 	}
; 103  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+152]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 140				; 0000008cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _sTemp$217544[ebp]
	jmp	??1FStringA@@QAE@XZ			; FStringA::~FStringA
__unwindfunclet$?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z$1:
	lea	ecx, DWORD PTR _szError$217570[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Read@CvBuildingProductionAI@@QAEXAAVFDataStream@@@Z ENDP ; CvBuildingProductionAI::Read
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::sort_heap<CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,135,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,135,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0H@Z
_TEXT	SEGMENT
__Mid$217806 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,135,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$217806[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,135,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$217806[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$217806[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,135,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,135,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$217806[esp+36]
$LN26@Sort:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN25@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,135,1>::WeightedElement *,CvWeightedVector<int,135,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,135,1>::WeightedElement *,int,CvWeightedVector<int,135,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,135,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,135,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ; std::sort<CvWeightedVector<int,135,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z PROC ; std::sort<CvWeightedVector<int,135,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,135,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0@Z ENDP ; std::sort<CvWeightedVector<int,135,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@H$0IH@$00@@QAEXXZ	; CvWeightedVector<int,135,1>::SortItems
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@H$0IH@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@H$0IH@$00@@QAEXXZ PROC	; CvWeightedVector<int,135,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,135,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@H$0IH@$00@@QAEXXZ ENDP	; CvWeightedVector<int,135,1>::SortItems
_TEXT	ENDS
PUBLIC	?RecommendBuilding@CvBuildingProductionAI@@QAE?AW4BuildingTypes@@XZ ; CvBuildingProductionAI::RecommendBuilding
EXTRN	?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z:PROC ; CityStrategyAIHelpers::ReweightByTurnsLeft
EXTRN	?getProductionTurnsLeft@CvCity@@QBEHW4BuildingTypes@@H@Z:PROC ; CvCity::getProductionTurnsLeft
EXTRN	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z:PROC ; CvCity::canConstruct
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvbuildingproductionai.cpp
;	COMDAT ?RecommendBuilding@CvBuildingProductionAI@@QAE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
_elem$220381 = -8					; size = 8
?RecommendBuilding@CvBuildingProductionAI@@QAE?AW4BuildingTypes@@XZ PROC ; CvBuildingProductionAI::RecommendBuilding, COMDAT
; _this$ = ecx

; 290  : {

	sub	esp, 8
	push	ebp
	push	edi
	mov	ebp, ecx

; 291  : #ifdef AUI_WARNING_FIXES
; 292  : 	uint iBldgLoop;
; 293  : #else
; 294  : 	int iBldgLoop;
; 295  : #endif
; 296  : 	int iWeight;
; 297  : 	int iTurnsLeft;
; 298  : 
; 299  : 	// Reset list of all the possible buildings
; 300  : 	m_Buildables.clear();

	xor	edi, edi

; 301  : 
; 302  : 	// Loop through adding the available buildings
; 303  : 	for(iBldgLoop = 0; iBldgLoop < GC.GetGameBuildings()->GetNumBuildings(); iBldgLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [ebp+1108], edi
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	test	eax, eax
	jle	$LN4@RecommendB
	push	ebx
	push	esi
	npad	6
$LL58@RecommendB:

; 304  : 	{
; 305  : 		// Make sure this building can be built now
; 306  : 		if(m_pCity->canConstruct((BuildingTypes)iBldgLoop))

	mov	ecx, DWORD PTR [ebp]
	push	0
	push	0
	push	0
	push	0
	push	edi
	call	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z ; CvCity::canConstruct
	test	al, al
	je	SHORT $LN5@RecommendB

; 307  : 		{
; 308  : 			// Update weight based on turns to construct
; 309  : 			iTurnsLeft = m_pCity->getProductionTurnsLeft((BuildingTypes) iBldgLoop, 0);

	mov	ecx, DWORD PTR [ebp]
	push	0
	push	edi
	call	?getProductionTurnsLeft@CvCity@@QBEHW4BuildingTypes@@H@Z ; CvCity::getProductionTurnsLeft

; 310  : 			iWeight = CityStrategyAIHelpers::ReweightByTurnsLeft(m_BuildingAIWeights.GetWeight((BuildingTypes)iBldgLoop), iTurnsLeft);

	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ecx+edi*8]
	mov	ecx, DWORD PTR [ecx+edi*8+4]
	push	eax
	push	ecx
	mov	DWORD PTR _elem$220381[esp+32], edx

; 311  : 			m_Buildables.push_back(iBldgLoop, iWeight);

	lea	esi, DWORD PTR [ebp+1104]
	call	?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z ; CityStrategyAIHelpers::ReweightByTurnsLeft
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+8]
	add	esp, 8
	mov	BYTE PTR [esi+1092], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN29@RecommendB
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0IH@$00@@$0IH@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,135,1>::WeightedElement,135,1,0,0>::GrowSize
$LN29@RecommendB:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN32@RecommendB
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebx
$LN32@RecommendB:
	inc	DWORD PTR [esi+4]
$LN5@RecommendB:

; 301  : 
; 302  : 	// Loop through adding the available buildings
; 303  : 	for(iBldgLoop = 0; iBldgLoop < GC.GetGameBuildings()->GetNumBuildings(); iBldgLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	edi, eax
	jl	$LL58@RecommendB
	pop	esi
	pop	ebx
$LN4@RecommendB:

; 312  : 		}
; 313  : 	}
; 314  : 
; 315  : 	// Sort items and grab the first one
; 316  : 	if(m_Buildables.size() > 0)

	cmp	DWORD PTR [ebp+1108], 0
	jle	SHORT $LN2@RecommendB

; 317  : 	{
; 318  : 		m_Buildables.SortItems();

	mov	eax, DWORD PTR [ebp+1104]
	mov	edx, DWORD PTR [ebp+1108]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0IH@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,135,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 319  : 		LogPossibleBuilds();

	mov	ecx, ebp
	call	?LogPossibleBuilds@CvBuildingProductionAI@@QAEXXZ ; CvBuildingProductionAI::LogPossibleBuilds

; 320  : 		return (BuildingTypes)m_Buildables.GetElement(0);

	mov	eax, DWORD PTR [ebp+1104]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	ebp

; 327  : 	}
; 328  : }

	add	esp, 8
	ret	0
$LN2@RecommendB:
	pop	edi

; 321  : 	}
; 322  : 
; 323  : 	// Unless we didn't find any
; 324  : 	else
; 325  : 	{
; 326  : 		return NO_BUILDING;

	or	eax, -1
	pop	ebp

; 327  : 	}
; 328  : }

	add	esp, 8
	ret	0
?RecommendBuilding@CvBuildingProductionAI@@QAE?AW4BuildingTypes@@XZ ENDP ; CvBuildingProductionAI::RecommendBuilding
_TEXT	ENDS
END
