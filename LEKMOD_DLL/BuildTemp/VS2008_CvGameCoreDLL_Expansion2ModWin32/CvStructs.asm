; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvStructs.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?GetID@VoteSelectionData@@QBEHXZ		; VoteSelectionData::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvstructs.cpp
;	COMDAT ?GetID@VoteSelectionData@@QBEHXZ
_TEXT	SEGMENT
?GetID@VoteSelectionData@@QBEHXZ PROC			; VoteSelectionData::GetID, COMDAT
; _this$ = ecx

; 25   : 	return iId;

	mov	eax, DWORD PTR [ecx]

; 26   : }

	ret	0
?GetID@VoteSelectionData@@QBEHXZ ENDP			; VoteSelectionData::GetID
_TEXT	ENDS
PUBLIC	?SetID@VoteSelectionData@@QAEXH@Z		; VoteSelectionData::SetID
; Function compile flags: /Ogtpy
;	COMDAT ?SetID@VoteSelectionData@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetID@VoteSelectionData@@QAEXH@Z PROC			; VoteSelectionData::SetID, COMDAT
; _this$ = ecx

; 30   : 	iId = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx], eax

; 31   : }

	ret	4
?SetID@VoteSelectionData@@QAEXH@Z ENDP			; VoteSelectionData::SetID
_TEXT	ENDS
PUBLIC	?GetID@VoteTriggeredData@@QBEHXZ		; VoteTriggeredData::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@VoteTriggeredData@@QBEHXZ
_TEXT	SEGMENT
?GetID@VoteTriggeredData@@QBEHXZ PROC			; VoteTriggeredData::GetID, COMDAT
; _this$ = ecx

; 87   : 	return iId;

	mov	eax, DWORD PTR [ecx]

; 88   : }

	ret	0
?GetID@VoteTriggeredData@@QBEHXZ ENDP			; VoteTriggeredData::GetID
_TEXT	ENDS
PUBLIC	?SetID@VoteTriggeredData@@QAEXH@Z		; VoteTriggeredData::SetID
; Function compile flags: /Ogtpy
;	COMDAT ?SetID@VoteTriggeredData@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetID@VoteTriggeredData@@QAEXH@Z PROC			; VoteTriggeredData::SetID, COMDAT
; _this$ = ecx

; 92   : 	iId = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx], eax

; 93   : }

	ret	4
?SetID@VoteTriggeredData@@QAEXH@Z ENDP			; VoteTriggeredData::SetID
_TEXT	ENDS
PUBLIC	?checkBattleUnitType@@YAXW4BattleUnitTypes@@@Z	; checkBattleUnitType
; Function compile flags: /Ogtpy
;	COMDAT ?checkBattleUnitType@@YAXW4BattleUnitTypes@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?checkBattleUnitType@@YAXW4BattleUnitTypes@@@Z PROC	; checkBattleUnitType, COMDAT

; 175  : #endif
; 176  : }

	ret	0
?checkBattleUnitType@@YAXW4BattleUnitTypes@@@Z ENDP	; checkBattleUnitType
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	edi
	mov	edi, DWORD PTR ___n$[esp]
	sub	edi, 1
	js	SHORT $LN1@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR ___s$[esp+8]
	push	esi
	mov	esi, DWORD PTR ___t$[esp+12]
	npad	7
$LL2@vector:
	mov	ecx, esi
	call	ebx
	add	esi, ebp
	sub	edi, 1
	jns	SHORT $LL2@vector
	pop	esi
	pop	ebp
	pop	ebx
$LN1@vector:
	pop	edi
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??4CvCombatInfo@@QAEAAV0@ABV0@@Z		; CvCombatInfo::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvCombatInfo@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
tv883 = -4						; size = 4
tv387 = 8						; size = 4
_rhs$ = 8						; size = 4
??4CvCombatInfo@@QAEAAV0@ABV0@@Z PROC			; CvCombatInfo::operator=, COMDAT
; _this$ = ecx

; 210  : {

	push	ecx
	mov	eax, ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 211  : 	m_pTargetPlot = rhs.m_pTargetPlot;

	mov	edi, DWORD PTR _rhs$[esp+16]
	mov	ecx, DWORD PTR [edi+24]
	mov	DWORD PTR [eax+24], ecx

; 212  : 	m_bAttackerAdvances = rhs.m_bAttackerAdvances;

	movzx	edx, BYTE PTR [edi+28]
	mov	BYTE PTR [eax+28], dl

; 213  : 	m_bAttackIsRanged = rhs.m_bAttackIsRanged;

	movzx	ecx, BYTE PTR [edi+29]
	mov	BYTE PTR [eax+29], cl

; 214  : 	m_bAttackIsBombingMission = rhs.m_bAttackIsBombingMission;

	movzx	edx, BYTE PTR [edi+30]
	mov	BYTE PTR [eax+30], dl

; 215  : 	m_bAttackIsAirSweep = rhs.m_bAttackIsAirSweep;

	movzx	ecx, BYTE PTR [edi+31]
	mov	BYTE PTR [eax+31], cl

; 216  : 	m_bDefenderCaptured = rhs.m_bDefenderCaptured;

	movzx	edx, BYTE PTR [edi+33]
	mov	BYTE PTR [eax+33], dl

; 217  : 	m_bDefenderRetaliates = rhs.m_bDefenderRetaliates;

	movzx	ecx, BYTE PTR [edi+32]
	mov	BYTE PTR [eax+32], cl

; 218  : 	m_iNuclearDamageLevel = rhs.m_iNuclearDamageLevel;

	mov	edx, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+36], edx

; 219  : 	m_bVisualize = rhs.m_bVisualize;

	movzx	ecx, BYTE PTR [edi+106]
	mov	BYTE PTR [eax+106], cl

; 220  : 	m_bAttackedAdvancedVis = rhs.m_bAttackedAdvancedVis;

	movzx	edx, BYTE PTR [edi+107]
	mov	BYTE PTR [eax+107], dl
	lea	ecx, DWORD PTR [edi+103]

; 221  : 
; 222  : 	for(int i=0; i<BATTLE_UNIT_COUNT; i++)

	mov	edx, edi
	mov	DWORD PTR tv387[esp+16], ecx
	lea	ebp, DWORD PTR [eax+100]
	lea	esi, DWORD PTR [edi+64]
	lea	ecx, DWORD PTR [eax+40]
	sub	edx, eax
	mov	DWORD PTR tv883[esp+20], 3
	npad	5
$LL6@operator:

; 223  : 	{
; 224  : 		m_pUnits[i] = rhs.m_pUnits[i];

	mov	ebx, DWORD PTR [esi-64]
	mov	DWORD PTR [ecx-40], ebx

; 225  : 
; 226  : 		m_iFinalDamage[i] = rhs.m_iFinalDamage[i];

	mov	ebx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [ecx], ebx

; 227  : 		m_iDamageInflicted[i] = rhs.m_iDamageInflicted[i];

	mov	ebx, DWORD PTR [esi-12]
	mov	DWORD PTR [ecx+12], ebx

; 228  : 		m_iFearDamageInflicted[i] = rhs.m_iFearDamageInflicted[i];

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+24], ebx

; 229  : 
; 230  : 		m_iExperienceChange[i] = rhs.m_iExperienceChange[i];

	mov	ebx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+36], ebx

; 231  : 		m_iMaxExperienceAllowed[i] = rhs.m_iMaxExperienceAllowed[i];

	mov	ebx, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+48], ebx

; 232  : 		m_bInBorders[i] = rhs.m_bInBorders[i];

	movzx	ebx, BYTE PTR [edx+ebp]
	mov	BYTE PTR [ebp], bl

; 233  : 		m_bUpdateGlobal[i] = rhs.m_bUpdateGlobal[i];

	mov	ebx, DWORD PTR tv387[esp+16]
	movzx	ebx, BYTE PTR [ebx]
	inc	DWORD PTR tv387[esp+16]
	mov	BYTE PTR [ebp+3], bl
	add	ecx, 4
	add	esi, 4
	inc	ebp
	sub	DWORD PTR tv883[esp+20], 1
	jne	SHORT $LL6@operator

; 234  : 	}
; 235  : 
; 236  : 	m_iDamageMemberCount = rhs.m_iDamageMemberCount;

	mov	edi, DWORD PTR [edi+216]

; 237  : 	for(int i=0; i<m_iDamageMemberCount; ++i)

	xor	ebp, ebp
	mov	DWORD PTR [eax+216], edi
	test	edi, edi
	jle	SHORT $LN1@operator

; 234  : 	}
; 235  : 
; 236  : 	m_iDamageMemberCount = rhs.m_iDamageMemberCount;

	lea	ebx, DWORD PTR [eax+220]
	npad	3
$LL3@operator:

; 238  : 	{
; 239  : 		m_kDamageMembers[i] = rhs.m_kDamageMembers[i];

	lea	esi, DWORD PTR [ebx+edx]
	mov	edi, ebx
	mov	ecx, 9
	inc	ebp
	rep movsd
	add	ebx, 36					; 00000024H
	cmp	ebp, DWORD PTR [eax+216]
	jl	SHORT $LL3@operator
$LN1@operator:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 240  : 	}
; 241  : 	return (*this);
; 242  : }

	pop	ecx
	ret	4
??4CvCombatInfo@@QAEAAV0@ABV0@@Z ENDP			; CvCombatInfo::operator=
_TEXT	ENDS
PUBLIC	?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getUnit
; Function compile flags: /Ogtpy
;	COMDAT ?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z PROC ; CvCombatInfo::getUnit, COMDAT
; _this$ = ecx

; 247  : 	checkBattleUnitType(unitType);
; 248  : 	return m_pUnits[unitType];

	mov	eax, DWORD PTR _unitType$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4]

; 249  : }

	ret	4
?getUnit@CvCombatInfo@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ENDP ; CvCombatInfo::getUnit
_TEXT	ENDS
PUBLIC	?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvCombatInfo::setUnit
; Function compile flags: /Ogtpy
;	COMDAT ?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
_unit$ = 12						; size = 4
?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z PROC ; CvCombatInfo::setUnit, COMDAT
; _this$ = ecx

; 252  : 	checkBattleUnitType(unitType);
; 253  : 	m_pUnits[unitType] = unit;

	mov	eax, DWORD PTR _unit$[esp-4]
	mov	edx, DWORD PTR _unitType$[esp-4]
	mov	DWORD PTR [ecx+edx*4], eax

; 254  : }

	ret	8
?setUnit@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ENDP ; CvCombatInfo::setUnit
_TEXT	ENDS
PUBLIC	?setCity@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvCity@@@Z ; CvCombatInfo::setCity
; Function compile flags: /Ogtpy
;	COMDAT ?setCity@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
_pkCity$ = 12						; size = 4
?setCity@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvCity@@@Z PROC ; CvCombatInfo::setCity, COMDAT
; _this$ = ecx

; 271  : 	checkBattleUnitType(unitType);
; 272  : 	m_pCities[unitType] = pkCity;

	mov	eax, DWORD PTR _pkCity$[esp-4]
	mov	edx, DWORD PTR _unitType$[esp-4]
	mov	DWORD PTR [ecx+edx*4+12], eax

; 273  : }

	ret	8
?setCity@CvCombatInfo@@QAEXW4BattleUnitTypes@@PAVCvCity@@@Z ENDP ; CvCombatInfo::setCity
_TEXT	ENDS
PUBLIC	?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ		; CvCombatInfo::getPlot
; Function compile flags: /Ogtpy
;	COMDAT ?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ PROC		; CvCombatInfo::getPlot, COMDAT
; _this$ = ecx

; 277  : 	return m_pTargetPlot;

	mov	eax, DWORD PTR [ecx+24]

; 278  : }

	ret	0
?getPlot@CvCombatInfo@@QBEPAVCvPlot@@XZ ENDP		; CvCombatInfo::getPlot
_TEXT	ENDS
PUBLIC	?setPlot@CvCombatInfo@@QAEXPAVCvPlot@@@Z	; CvCombatInfo::setPlot
; Function compile flags: /Ogtpy
;	COMDAT ?setPlot@CvCombatInfo@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_plot$ = 8						; size = 4
?setPlot@CvCombatInfo@@QAEXPAVCvPlot@@@Z PROC		; CvCombatInfo::setPlot, COMDAT
; _this$ = ecx

; 281  : 	m_pTargetPlot = plot;

	mov	eax, DWORD PTR _plot$[esp-4]
	mov	DWORD PTR [ecx+24], eax

; 282  : }

	ret	4
?setPlot@CvCombatInfo@@QAEXPAVCvPlot@@@Z ENDP		; CvCombatInfo::setPlot
_TEXT	ENDS
PUBLIC	?getAttackerAdvances@CvCombatInfo@@QBE_NXZ	; CvCombatInfo::getAttackerAdvances
; Function compile flags: /Ogtpy
;	COMDAT ?getAttackerAdvances@CvCombatInfo@@QBE_NXZ
_TEXT	SEGMENT
?getAttackerAdvances@CvCombatInfo@@QBE_NXZ PROC		; CvCombatInfo::getAttackerAdvances, COMDAT
; _this$ = ecx

; 286  : 	return m_bAttackerAdvances;

	mov	al, BYTE PTR [ecx+28]

; 287  : }

	ret	0
?getAttackerAdvances@CvCombatInfo@@QBE_NXZ ENDP		; CvCombatInfo::getAttackerAdvances
_TEXT	ENDS
PUBLIC	?setAttackerAdvances@CvCombatInfo@@QAEX_N@Z	; CvCombatInfo::setAttackerAdvances
; Function compile flags: /Ogtpy
;	COMDAT ?setAttackerAdvances@CvCombatInfo@@QAEX_N@Z
_TEXT	SEGMENT
_bAdvance$ = 8						; size = 1
?setAttackerAdvances@CvCombatInfo@@QAEX_N@Z PROC	; CvCombatInfo::setAttackerAdvances, COMDAT
; _this$ = ecx

; 291  : 	m_bAttackerAdvances = bAdvance;

	mov	al, BYTE PTR _bAdvance$[esp-4]
	mov	BYTE PTR [ecx+28], al

; 292  : }

	ret	4
?setAttackerAdvances@CvCombatInfo@@QAEX_N@Z ENDP	; CvCombatInfo::setAttackerAdvances
_TEXT	ENDS
PUBLIC	?getDefenderRetaliates@CvCombatInfo@@QBE_NXZ	; CvCombatInfo::getDefenderRetaliates
; Function compile flags: /Ogtpy
;	COMDAT ?getDefenderRetaliates@CvCombatInfo@@QBE_NXZ
_TEXT	SEGMENT
?getDefenderRetaliates@CvCombatInfo@@QBE_NXZ PROC	; CvCombatInfo::getDefenderRetaliates, COMDAT
; _this$ = ecx

; 296  : 	return m_bDefenderRetaliates;

	mov	al, BYTE PTR [ecx+32]

; 297  : }

	ret	0
?getDefenderRetaliates@CvCombatInfo@@QBE_NXZ ENDP	; CvCombatInfo::getDefenderRetaliates
_TEXT	ENDS
PUBLIC	?setDefenderRetaliates@CvCombatInfo@@QAEX_N@Z	; CvCombatInfo::setDefenderRetaliates
; Function compile flags: /Ogtpy
;	COMDAT ?setDefenderRetaliates@CvCombatInfo@@QAEX_N@Z
_TEXT	SEGMENT
_bDefenderRetaliates$ = 8				; size = 1
?setDefenderRetaliates@CvCombatInfo@@QAEX_N@Z PROC	; CvCombatInfo::setDefenderRetaliates, COMDAT
; _this$ = ecx

; 301  : 	m_bDefenderRetaliates = bDefenderRetaliates;

	mov	al, BYTE PTR _bDefenderRetaliates$[esp-4]
	mov	BYTE PTR [ecx+32], al

; 302  : }

	ret	4
?setDefenderRetaliates@CvCombatInfo@@QAEX_N@Z ENDP	; CvCombatInfo::setDefenderRetaliates
_TEXT	ENDS
PUBLIC	?setAttackIsRanged@CvCombatInfo@@QAEX_N@Z	; CvCombatInfo::setAttackIsRanged
; Function compile flags: /Ogtpy
;	COMDAT ?setAttackIsRanged@CvCombatInfo@@QAEX_N@Z
_TEXT	SEGMENT
_bRanged$ = 8						; size = 1
?setAttackIsRanged@CvCombatInfo@@QAEX_N@Z PROC		; CvCombatInfo::setAttackIsRanged, COMDAT
; _this$ = ecx

; 306  : 	m_bAttackIsRanged = bRanged;

	mov	al, BYTE PTR _bRanged$[esp-4]
	mov	BYTE PTR [ecx+29], al

; 307  : }

	ret	4
?setAttackIsRanged@CvCombatInfo@@QAEX_N@Z ENDP		; CvCombatInfo::setAttackIsRanged
_TEXT	ENDS
PUBLIC	?getAttackIsRanged@CvCombatInfo@@QBE_NXZ	; CvCombatInfo::getAttackIsRanged
; Function compile flags: /Ogtpy
;	COMDAT ?getAttackIsRanged@CvCombatInfo@@QBE_NXZ
_TEXT	SEGMENT
?getAttackIsRanged@CvCombatInfo@@QBE_NXZ PROC		; CvCombatInfo::getAttackIsRanged, COMDAT
; _this$ = ecx

; 311  : 	return m_bAttackIsRanged;

	mov	al, BYTE PTR [ecx+29]

; 312  : }

	ret	0
?getAttackIsRanged@CvCombatInfo@@QBE_NXZ ENDP		; CvCombatInfo::getAttackIsRanged
_TEXT	ENDS
PUBLIC	?setAttackIsBombingMission@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setAttackIsBombingMission
; Function compile flags: /Ogtpy
;	COMDAT ?setAttackIsBombingMission@CvCombatInfo@@QAEX_N@Z
_TEXT	SEGMENT
_bBombingMission$ = 8					; size = 1
?setAttackIsBombingMission@CvCombatInfo@@QAEX_N@Z PROC	; CvCombatInfo::setAttackIsBombingMission, COMDAT
; _this$ = ecx

; 316  : 	m_bAttackIsBombingMission = bBombingMission;

	mov	al, BYTE PTR _bBombingMission$[esp-4]
	mov	BYTE PTR [ecx+30], al

; 317  : }

	ret	4
?setAttackIsBombingMission@CvCombatInfo@@QAEX_N@Z ENDP	; CvCombatInfo::setAttackIsBombingMission
_TEXT	ENDS
PUBLIC	?getAttackIsBombingMission@CvCombatInfo@@QBE_NXZ ; CvCombatInfo::getAttackIsBombingMission
; Function compile flags: /Ogtpy
;	COMDAT ?getAttackIsBombingMission@CvCombatInfo@@QBE_NXZ
_TEXT	SEGMENT
?getAttackIsBombingMission@CvCombatInfo@@QBE_NXZ PROC	; CvCombatInfo::getAttackIsBombingMission, COMDAT
; _this$ = ecx

; 321  : 	return m_bAttackIsBombingMission;

	mov	al, BYTE PTR [ecx+30]

; 322  : }

	ret	0
?getAttackIsBombingMission@CvCombatInfo@@QBE_NXZ ENDP	; CvCombatInfo::getAttackIsBombingMission
_TEXT	ENDS
PUBLIC	?setAttackIsAirSweep@CvCombatInfo@@QAEX_N@Z	; CvCombatInfo::setAttackIsAirSweep
; Function compile flags: /Ogtpy
;	COMDAT ?setAttackIsAirSweep@CvCombatInfo@@QAEX_N@Z
_TEXT	SEGMENT
_bAirSweep$ = 8						; size = 1
?setAttackIsAirSweep@CvCombatInfo@@QAEX_N@Z PROC	; CvCombatInfo::setAttackIsAirSweep, COMDAT
; _this$ = ecx

; 326  : 	m_bAttackIsAirSweep = bAirSweep;

	mov	al, BYTE PTR _bAirSweep$[esp-4]
	mov	BYTE PTR [ecx+31], al

; 327  : }

	ret	4
?setAttackIsAirSweep@CvCombatInfo@@QAEX_N@Z ENDP	; CvCombatInfo::setAttackIsAirSweep
_TEXT	ENDS
PUBLIC	?getAttackIsAirSweep@CvCombatInfo@@QBE_NXZ	; CvCombatInfo::getAttackIsAirSweep
; Function compile flags: /Ogtpy
;	COMDAT ?getAttackIsAirSweep@CvCombatInfo@@QBE_NXZ
_TEXT	SEGMENT
?getAttackIsAirSweep@CvCombatInfo@@QBE_NXZ PROC		; CvCombatInfo::getAttackIsAirSweep, COMDAT
; _this$ = ecx

; 331  : 	return m_bAttackIsAirSweep;

	mov	al, BYTE PTR [ecx+31]

; 332  : }

	ret	0
?getAttackIsAirSweep@CvCombatInfo@@QBE_NXZ ENDP		; CvCombatInfo::getAttackIsAirSweep
_TEXT	ENDS
PUBLIC	?setDefenderCaptured@CvCombatInfo@@QAEX_N@Z	; CvCombatInfo::setDefenderCaptured
; Function compile flags: /Ogtpy
;	COMDAT ?setDefenderCaptured@CvCombatInfo@@QAEX_N@Z
_TEXT	SEGMENT
_bDefenderCaptured$ = 8					; size = 1
?setDefenderCaptured@CvCombatInfo@@QAEX_N@Z PROC	; CvCombatInfo::setDefenderCaptured, COMDAT
; _this$ = ecx

; 336  : 	m_bDefenderCaptured = bDefenderCaptured;

	mov	al, BYTE PTR _bDefenderCaptured$[esp-4]
	mov	BYTE PTR [ecx+33], al

; 337  : }

	ret	4
?setDefenderCaptured@CvCombatInfo@@QAEX_N@Z ENDP	; CvCombatInfo::setDefenderCaptured
_TEXT	ENDS
PUBLIC	?getDefenderCaptured@CvCombatInfo@@QBE_NXZ	; CvCombatInfo::getDefenderCaptured
; Function compile flags: /Ogtpy
;	COMDAT ?getDefenderCaptured@CvCombatInfo@@QBE_NXZ
_TEXT	SEGMENT
?getDefenderCaptured@CvCombatInfo@@QBE_NXZ PROC		; CvCombatInfo::getDefenderCaptured, COMDAT
; _this$ = ecx

; 341  : 	return m_bDefenderCaptured;

	mov	al, BYTE PTR [ecx+33]

; 342  : }

	ret	0
?getDefenderCaptured@CvCombatInfo@@QBE_NXZ ENDP		; CvCombatInfo::getDefenderCaptured
_TEXT	ENDS
PUBLIC	?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getDamageInflicted
; Function compile flags: /Ogtpy
;	COMDAT ?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z PROC ; CvCombatInfo::getDamageInflicted, COMDAT
; _this$ = ecx

; 346  : 	checkBattleUnitType(unitType);
; 347  : 	return m_iDamageInflicted[unitType];

	mov	eax, DWORD PTR _unitType$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+52]

; 348  : }

	ret	4
?getDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ENDP ; CvCombatInfo::getDamageInflicted
_TEXT	ENDS
PUBLIC	?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setDamageInflicted
; Function compile flags: /Ogtpy
;	COMDAT ?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
_iDamage$ = 12						; size = 4
?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z PROC ; CvCombatInfo::setDamageInflicted, COMDAT
; _this$ = ecx

; 351  : 	checkBattleUnitType(unitType);
; 352  : 	m_iDamageInflicted[unitType] = iDamage;

	mov	eax, DWORD PTR _iDamage$[esp-4]
	mov	edx, DWORD PTR _unitType$[esp-4]
	mov	DWORD PTR [ecx+edx*4+52], eax

; 353  : }

	ret	8
?setDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ENDP ; CvCombatInfo::setDamageInflicted
_TEXT	ENDS
PUBLIC	?getFinalDamage@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getFinalDamage
; Function compile flags: /Ogtpy
;	COMDAT ?getFinalDamage@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?getFinalDamage@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z PROC ; CvCombatInfo::getFinalDamage, COMDAT
; _this$ = ecx

; 357  : 	checkBattleUnitType(unitType);
; 358  : 	return m_iFinalDamage[unitType];

	mov	eax, DWORD PTR _unitType$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+40]

; 359  : }

	ret	4
?getFinalDamage@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ENDP ; CvCombatInfo::getFinalDamage
_TEXT	ENDS
PUBLIC	?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFinalDamage
; Function compile flags: /Ogtpy
;	COMDAT ?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
_iFinalDamage$ = 12					; size = 4
?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z PROC ; CvCombatInfo::setFinalDamage, COMDAT
; _this$ = ecx

; 362  : 	checkBattleUnitType(unitType);
; 363  : 	m_iFinalDamage[unitType] = iFinalDamage;

	mov	eax, DWORD PTR _iFinalDamage$[esp-4]
	mov	edx, DWORD PTR _unitType$[esp-4]
	mov	DWORD PTR [ecx+edx*4+40], eax

; 364  : }

	ret	8
?setFinalDamage@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ENDP ; CvCombatInfo::setFinalDamage
_TEXT	ENDS
PUBLIC	?getFearDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getFearDamageInflicted
; Function compile flags: /Ogtpy
;	COMDAT ?getFearDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?getFearDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z PROC ; CvCombatInfo::getFearDamageInflicted, COMDAT
; _this$ = ecx

; 369  : 	checkBattleUnitType(unitType);
; 370  : 	return m_iFearDamageInflicted[unitType];

	mov	eax, DWORD PTR _unitType$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+64]

; 371  : }

	ret	4
?getFearDamageInflicted@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ENDP ; CvCombatInfo::getFearDamageInflicted
_TEXT	ENDS
PUBLIC	?setFearDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setFearDamageInflicted
; Function compile flags: /Ogtpy
;	COMDAT ?setFearDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
_iDamage$ = 12						; size = 4
?setFearDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z PROC ; CvCombatInfo::setFearDamageInflicted, COMDAT
; _this$ = ecx

; 374  : 	checkBattleUnitType(unitType);
; 375  : 	m_iFearDamageInflicted[unitType] = iDamage;

	mov	eax, DWORD PTR _iDamage$[esp-4]
	mov	edx, DWORD PTR _unitType$[esp-4]
	mov	DWORD PTR [ecx+edx*4+64], eax

; 376  : }

	ret	8
?setFearDamageInflicted@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ENDP ; CvCombatInfo::setFearDamageInflicted
_TEXT	ENDS
PUBLIC	?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getExperience
; Function compile flags: /Ogtpy
;	COMDAT ?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z PROC ; CvCombatInfo::getExperience, COMDAT
; _this$ = ecx

; 380  : 	checkBattleUnitType(unitType);
; 381  : 	return m_iExperienceChange[unitType];

	mov	eax, DWORD PTR _unitType$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+76]

; 382  : }

	ret	4
?getExperience@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ENDP ; CvCombatInfo::getExperience
_TEXT	ENDS
PUBLIC	?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setExperience
; Function compile flags: /Ogtpy
;	COMDAT ?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
_iExperience$ = 12					; size = 4
?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z PROC ; CvCombatInfo::setExperience, COMDAT
; _this$ = ecx

; 385  : 	checkBattleUnitType(unitType);
; 386  : 	m_iExperienceChange[unitType] = iExperience;

	mov	eax, DWORD PTR _iExperience$[esp-4]
	mov	edx, DWORD PTR _unitType$[esp-4]
	mov	DWORD PTR [ecx+edx*4+76], eax

; 387  : }

	ret	8
?setExperience@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ENDP ; CvCombatInfo::setExperience
_TEXT	ENDS
PUBLIC	?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ; CvCombatInfo::getMaxExperienceAllowed
; Function compile flags: /Ogtpy
;	COMDAT ?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z PROC ; CvCombatInfo::getMaxExperienceAllowed, COMDAT
; _this$ = ecx

; 391  : 	checkBattleUnitType(unitType);
; 392  : 	return m_iMaxExperienceAllowed[unitType];

	mov	eax, DWORD PTR _unitType$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+88]

; 393  : }

	ret	4
?getMaxExperienceAllowed@CvCombatInfo@@QBEHW4BattleUnitTypes@@@Z ENDP ; CvCombatInfo::getMaxExperienceAllowed
_TEXT	ENDS
PUBLIC	?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ; CvCombatInfo::setMaxExperienceAllowed
; Function compile flags: /Ogtpy
;	COMDAT ?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
_iMaxExperience$ = 12					; size = 4
?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z PROC ; CvCombatInfo::setMaxExperienceAllowed, COMDAT
; _this$ = ecx

; 396  : 	checkBattleUnitType(unitType);
; 397  : 	m_iMaxExperienceAllowed[unitType] = iMaxExperience;

	mov	eax, DWORD PTR _iMaxExperience$[esp-4]
	mov	edx, DWORD PTR _unitType$[esp-4]
	mov	DWORD PTR [ecx+edx*4+88], eax

; 398  : }

	ret	8
?setMaxExperienceAllowed@CvCombatInfo@@QAEXW4BattleUnitTypes@@H@Z ENDP ; CvCombatInfo::setMaxExperienceAllowed
_TEXT	ENDS
PUBLIC	?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getInBorders
; Function compile flags: /Ogtpy
;	COMDAT ?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z PROC ; CvCombatInfo::getInBorders, COMDAT
; _this$ = ecx

; 402  : 	checkBattleUnitType(unitType);
; 403  : 	return m_bInBorders[unitType];

	mov	eax, DWORD PTR _unitType$[esp-4]
	mov	al, BYTE PTR [eax+ecx+100]

; 404  : }

	ret	4
?getInBorders@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ENDP ; CvCombatInfo::getInBorders
_TEXT	ENDS
PUBLIC	?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setInBorders
; Function compile flags: /Ogtpy
;	COMDAT ?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
_bInBorders$ = 12					; size = 1
?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z PROC ; CvCombatInfo::setInBorders, COMDAT
; _this$ = ecx

; 407  : 	checkBattleUnitType(unitType);
; 408  : 	m_bInBorders[unitType] = bInBorders;

	mov	al, BYTE PTR _bInBorders$[esp-4]
	mov	edx, DWORD PTR _unitType$[esp-4]
	mov	BYTE PTR [edx+ecx+100], al

; 409  : }

	ret	8
?setInBorders@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ENDP ; CvCombatInfo::setInBorders
_TEXT	ENDS
PUBLIC	?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ; CvCombatInfo::getUpdateGlobal
; Function compile flags: /Ogtpy
;	COMDAT ?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z PROC ; CvCombatInfo::getUpdateGlobal, COMDAT
; _this$ = ecx

; 413  : 	checkBattleUnitType(unitType);
; 414  : 	return m_bUpdateGlobal[unitType];

	mov	eax, DWORD PTR _unitType$[esp-4]
	mov	al, BYTE PTR [eax+ecx+103]

; 415  : }

	ret	4
?getUpdateGlobal@CvCombatInfo@@QBE_NW4BattleUnitTypes@@@Z ENDP ; CvCombatInfo::getUpdateGlobal
_TEXT	ENDS
PUBLIC	?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ; CvCombatInfo::setUpdateGlobal
; Function compile flags: /Ogtpy
;	COMDAT ?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
_bUpdateGlobal$ = 12					; size = 1
?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z PROC ; CvCombatInfo::setUpdateGlobal, COMDAT
; _this$ = ecx

; 418  : 	checkBattleUnitType(unitType);
; 419  : 	m_bUpdateGlobal[unitType] = bUpdateGlobal;

	mov	al, BYTE PTR _bUpdateGlobal$[esp-4]
	mov	edx, DWORD PTR _unitType$[esp-4]
	mov	BYTE PTR [edx+ecx+103], al

; 420  : }

	ret	8
?setUpdateGlobal@CvCombatInfo@@QAEXW4BattleUnitTypes@@_N@Z ENDP ; CvCombatInfo::setUpdateGlobal
_TEXT	ENDS
PUBLIC	?getVisualizeCombat@CvCombatInfo@@QBE_NXZ	; CvCombatInfo::getVisualizeCombat
; Function compile flags: /Ogtpy
;	COMDAT ?getVisualizeCombat@CvCombatInfo@@QBE_NXZ
_TEXT	SEGMENT
?getVisualizeCombat@CvCombatInfo@@QBE_NXZ PROC		; CvCombatInfo::getVisualizeCombat, COMDAT
; _this$ = ecx

; 424  : 	return m_bVisualize;

	mov	al, BYTE PTR [ecx+106]

; 425  : }

	ret	0
?getVisualizeCombat@CvCombatInfo@@QBE_NXZ ENDP		; CvCombatInfo::getVisualizeCombat
_TEXT	ENDS
PUBLIC	?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z	; CvCombatInfo::setVisualizeCombat
; Function compile flags: /Ogtpy
;	COMDAT ?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z
_TEXT	SEGMENT
_bVisualize$ = 8					; size = 1
?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z PROC		; CvCombatInfo::setVisualizeCombat, COMDAT
; _this$ = ecx

; 429  : 	m_bVisualize = bVisualize;

	mov	al, BYTE PTR _bVisualize$[esp-4]
	mov	BYTE PTR [ecx+106], al

; 430  : }

	ret	4
?setVisualizeCombat@CvCombatInfo@@QAEX_N@Z ENDP		; CvCombatInfo::setVisualizeCombat
_TEXT	ENDS
PUBLIC	?getAttackerAdvancedVisualization@CvCombatInfo@@QBE_NXZ ; CvCombatInfo::getAttackerAdvancedVisualization
; Function compile flags: /Ogtpy
;	COMDAT ?getAttackerAdvancedVisualization@CvCombatInfo@@QBE_NXZ
_TEXT	SEGMENT
?getAttackerAdvancedVisualization@CvCombatInfo@@QBE_NXZ PROC ; CvCombatInfo::getAttackerAdvancedVisualization, COMDAT
; _this$ = ecx

; 434  : 	return m_bAttackedAdvancedVis;

	mov	al, BYTE PTR [ecx+107]

; 435  : }

	ret	0
?getAttackerAdvancedVisualization@CvCombatInfo@@QBE_NXZ ENDP ; CvCombatInfo::getAttackerAdvancedVisualization
_TEXT	ENDS
PUBLIC	?setAttackerAdvancedVisualization@CvCombatInfo@@QAEX_N@Z ; CvCombatInfo::setAttackerAdvancedVisualization
; Function compile flags: /Ogtpy
;	COMDAT ?setAttackerAdvancedVisualization@CvCombatInfo@@QAEX_N@Z
_TEXT	SEGMENT
_bAdvance$ = 8						; size = 1
?setAttackerAdvancedVisualization@CvCombatInfo@@QAEX_N@Z PROC ; CvCombatInfo::setAttackerAdvancedVisualization, COMDAT
; _this$ = ecx

; 439  : 	m_bAttackedAdvancedVis = bAdvance;

	mov	al, BYTE PTR _bAdvance$[esp-4]
	mov	BYTE PTR [ecx+107], al

; 440  : }

	ret	4
?setAttackerAdvancedVisualization@CvCombatInfo@@QAEX_N@Z ENDP ; CvCombatInfo::setAttackerAdvancedVisualization
_TEXT	ENDS
PUBLIC	?getAttackIsNuclear@CvCombatInfo@@QBE_NXZ	; CvCombatInfo::getAttackIsNuclear
; Function compile flags: /Ogtpy
;	COMDAT ?getAttackIsNuclear@CvCombatInfo@@QBE_NXZ
_TEXT	SEGMENT
?getAttackIsNuclear@CvCombatInfo@@QBE_NXZ PROC		; CvCombatInfo::getAttackIsNuclear, COMDAT
; _this$ = ecx

; 444  : 	return m_iNuclearDamageLevel > 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx+36], eax
	setg	al

; 445  : }

	ret	0
?getAttackIsNuclear@CvCombatInfo@@QBE_NXZ ENDP		; CvCombatInfo::getAttackIsNuclear
_TEXT	ENDS
PUBLIC	?getAttackNuclearLevel@CvCombatInfo@@QBEHXZ	; CvCombatInfo::getAttackNuclearLevel
; Function compile flags: /Ogtpy
;	COMDAT ?getAttackNuclearLevel@CvCombatInfo@@QBEHXZ
_TEXT	SEGMENT
?getAttackNuclearLevel@CvCombatInfo@@QBEHXZ PROC	; CvCombatInfo::getAttackNuclearLevel, COMDAT
; _this$ = ecx

; 449  : 	return m_iNuclearDamageLevel;

	mov	eax, DWORD PTR [ecx+36]

; 450  : }

	ret	0
?getAttackNuclearLevel@CvCombatInfo@@QBEHXZ ENDP	; CvCombatInfo::getAttackNuclearLevel
_TEXT	ENDS
PUBLIC	?setAttackNuclearLevel@CvCombatInfo@@QAEXH@Z	; CvCombatInfo::setAttackNuclearLevel
; Function compile flags: /Ogtpy
;	COMDAT ?setAttackNuclearLevel@CvCombatInfo@@QAEXH@Z
_TEXT	SEGMENT
_iNuclearDamageLevel$ = 8				; size = 4
?setAttackNuclearLevel@CvCombatInfo@@QAEXH@Z PROC	; CvCombatInfo::setAttackNuclearLevel, COMDAT
; _this$ = ecx

; 454  : 	m_iNuclearDamageLevel = iNuclearDamageLevel;

	mov	eax, DWORD PTR _iNuclearDamageLevel$[esp-4]
	mov	DWORD PTR [ecx+36], eax

; 455  : }

	ret	4
?setAttackNuclearLevel@CvCombatInfo@@QAEXH@Z ENDP	; CvCombatInfo::setAttackNuclearLevel
_TEXT	ENDS
PUBLIC	?getCombatMember@CvCombatInfo@@QBEPBUCvCombatMemberEntry@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getCombatMember
; Function compile flags: /Ogtpy
;	COMDAT ?getCombatMember@CvCombatInfo@@QBEPBUCvCombatMemberEntry@@W4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?getCombatMember@CvCombatInfo@@QBEPBUCvCombatMemberEntry@@W4BattleUnitTypes@@@Z PROC ; CvCombatInfo::getCombatMember, COMDAT
; _this$ = ecx

; 459  : 	if((int)unitType < (int)BATTLE_UNIT_COUNT)

	mov	eax, DWORD PTR _unitType$[esp-4]
	cmp	eax, 3
	jge	SHORT $LN1@getCombatM

; 460  : 		return &m_kCombatMembers[unitType];

	lea	eax, DWORD PTR [eax+eax*8+27]
	lea	eax, DWORD PTR [ecx+eax*4]

; 462  : }

	ret	4
$LN1@getCombatM:

; 461  : 	return NULL;

	xor	eax, eax

; 462  : }

	ret	4
?getCombatMember@CvCombatInfo@@QBEPBUCvCombatMemberEntry@@W4BattleUnitTypes@@@Z ENDP ; CvCombatInfo::getCombatMember
_TEXT	ENDS
PUBLIC	?getDamageMembers@CvCombatInfo@@QAEPAUCvCombatMemberEntry@@XZ ; CvCombatInfo::getDamageMembers
; Function compile flags: /Ogtpy
;	COMDAT ?getDamageMembers@CvCombatInfo@@QAEPAUCvCombatMemberEntry@@XZ
_TEXT	SEGMENT
?getDamageMembers@CvCombatInfo@@QAEPAUCvCombatMemberEntry@@XZ PROC ; CvCombatInfo::getDamageMembers, COMDAT
; _this$ = ecx

; 466  : 	return &m_kDamageMembers[0];

	lea	eax, DWORD PTR [ecx+220]

; 467  : }

	ret	0
?getDamageMembers@CvCombatInfo@@QAEPAUCvCombatMemberEntry@@XZ ENDP ; CvCombatInfo::getDamageMembers
_TEXT	ENDS
PUBLIC	?getDamageMembers@CvCombatInfo@@QBEPBUCvCombatMemberEntry@@XZ ; CvCombatInfo::getDamageMembers
; Function compile flags: /Ogtpy
;	COMDAT ?getDamageMembers@CvCombatInfo@@QBEPBUCvCombatMemberEntry@@XZ
_TEXT	SEGMENT
?getDamageMembers@CvCombatInfo@@QBEPBUCvCombatMemberEntry@@XZ PROC ; CvCombatInfo::getDamageMembers, COMDAT
; _this$ = ecx

; 471  : 	return &m_kDamageMembers[0];

	lea	eax, DWORD PTR [ecx+220]

; 472  : }

	ret	0
?getDamageMembers@CvCombatInfo@@QBEPBUCvCombatMemberEntry@@XZ ENDP ; CvCombatInfo::getDamageMembers
_TEXT	ENDS
PUBLIC	?getDamageMemberCount@CvCombatInfo@@QBEHXZ	; CvCombatInfo::getDamageMemberCount
; Function compile flags: /Ogtpy
;	COMDAT ?getDamageMemberCount@CvCombatInfo@@QBEHXZ
_TEXT	SEGMENT
?getDamageMemberCount@CvCombatInfo@@QBEHXZ PROC		; CvCombatInfo::getDamageMemberCount, COMDAT
; _this$ = ecx

; 476  : 	return m_iDamageMemberCount;

	mov	eax, DWORD PTR [ecx+216]

; 477  : }

	ret	0
?getDamageMemberCount@CvCombatInfo@@QBEHXZ ENDP		; CvCombatInfo::getDamageMemberCount
_TEXT	ENDS
PUBLIC	?getMaxDamageMemberCount@CvCombatInfo@@QBEHXZ	; CvCombatInfo::getMaxDamageMemberCount
; Function compile flags: /Ogtpy
;	COMDAT ?getMaxDamageMemberCount@CvCombatInfo@@QBEHXZ
_TEXT	SEGMENT
?getMaxDamageMemberCount@CvCombatInfo@@QBEHXZ PROC	; CvCombatInfo::getMaxDamageMemberCount, COMDAT
; _this$ = ecx

; 481  : 	return MAX_DAMAGE_MEMBER_COUNT;

	mov	eax, 32					; 00000020H

; 482  : }

	ret	0
?getMaxDamageMemberCount@CvCombatInfo@@QBEHXZ ENDP	; CvCombatInfo::getMaxDamageMemberCount
_TEXT	ENDS
PUBLIC	??0CvMissionDefinition@@QAE@XZ			; CvMissionDefinition::CvMissionDefinition
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ??0CvMissionDefinition@@QAE@XZ
_TEXT	SEGMENT
??0CvMissionDefinition@@QAE@XZ PROC			; CvMissionDefinition::CvMissionDefinition, COMDAT
; _this$ = ecx

; 499  : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx

; 500  : 	for(int i=0; i<BATTLE_UNIT_COUNT; i++)
; 501  : 		m_aUnits[i] = NULL;

	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 502  : }

	ret	0
??0CvMissionDefinition@@QAE@XZ ENDP			; CvMissionDefinition::CvMissionDefinition
_TEXT	ENDS
PUBLIC	?getMissionType@CvMissionDefinition@@QBE?AW4MissionTypes@@XZ ; CvMissionDefinition::getMissionType
; Function compile flags: /Ogtpy
;	COMDAT ?getMissionType@CvMissionDefinition@@QBE?AW4MissionTypes@@XZ
_TEXT	SEGMENT
?getMissionType@CvMissionDefinition@@QBE?AW4MissionTypes@@XZ PROC ; CvMissionDefinition::getMissionType, COMDAT
; _this$ = ecx

; 506  : 	return m_eMissionType;

	mov	eax, DWORD PTR [ecx]

; 507  : }

	ret	0
?getMissionType@CvMissionDefinition@@QBE?AW4MissionTypes@@XZ ENDP ; CvMissionDefinition::getMissionType
_TEXT	ENDS
PUBLIC	?setMissionType@CvMissionDefinition@@QAEXW4MissionTypes@@@Z ; CvMissionDefinition::setMissionType
; Function compile flags: /Ogtpy
;	COMDAT ?setMissionType@CvMissionDefinition@@QAEXW4MissionTypes@@@Z
_TEXT	SEGMENT
_missionType$ = 8					; size = 4
?setMissionType@CvMissionDefinition@@QAEXW4MissionTypes@@@Z PROC ; CvMissionDefinition::setMissionType, COMDAT
; _this$ = ecx

; 511  : 	m_eMissionType = missionType;

	mov	eax, DWORD PTR _missionType$[esp-4]
	mov	DWORD PTR [ecx], eax

; 512  : }

	ret	4
?setMissionType@CvMissionDefinition@@QAEXW4MissionTypes@@@Z ENDP ; CvMissionDefinition::setMissionType
_TEXT	ENDS
PUBLIC	?getMissionTime@CvMissionDefinition@@QBEMXZ	; CvMissionDefinition::getMissionTime
; Function compile flags: /Ogtpy
;	COMDAT ?getMissionTime@CvMissionDefinition@@QBEMXZ
_TEXT	SEGMENT
?getMissionTime@CvMissionDefinition@@QBEMXZ PROC	; CvMissionDefinition::getMissionTime, COMDAT
; _this$ = ecx

; 516  : 	return m_fMissionTime;

	fld	DWORD PTR [ecx+16]

; 517  : }

	ret	0
?getMissionTime@CvMissionDefinition@@QBEMXZ ENDP	; CvMissionDefinition::getMissionTime
_TEXT	ENDS
PUBLIC	?setMissionTime@CvMissionDefinition@@QAEXM@Z	; CvMissionDefinition::setMissionTime
; Function compile flags: /Ogtpy
;	COMDAT ?setMissionTime@CvMissionDefinition@@QAEXM@Z
_TEXT	SEGMENT
_time$ = 8						; size = 4
?setMissionTime@CvMissionDefinition@@QAEXM@Z PROC	; CvMissionDefinition::setMissionTime, COMDAT
; _this$ = ecx

; 521  : 	m_fMissionTime = time;

	mov	eax, DWORD PTR _time$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 522  : }

	ret	4
?setMissionTime@CvMissionDefinition@@QAEXM@Z ENDP	; CvMissionDefinition::setMissionTime
_TEXT	ENDS
PUBLIC	?getUnit@CvMissionDefinition@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ; CvMissionDefinition::getUnit
; Function compile flags: /Ogtpy
;	COMDAT ?getUnit@CvMissionDefinition@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?getUnit@CvMissionDefinition@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z PROC ; CvMissionDefinition::getUnit, COMDAT
; _this$ = ecx

; 526  : 	checkBattleUnitType(unitType);
; 527  : 	return m_aUnits[unitType];

	mov	eax, DWORD PTR _unitType$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+4]

; 528  : }

	ret	4
?getUnit@CvMissionDefinition@@QBEPAVCvUnit@@W4BattleUnitTypes@@@Z ENDP ; CvMissionDefinition::getUnit
_TEXT	ENDS
PUBLIC	?setUnit@CvMissionDefinition@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ; CvMissionDefinition::setUnit
; Function compile flags: /Ogtpy
;	COMDAT ?setUnit@CvMissionDefinition@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
_unit$ = 12						; size = 4
?setUnit@CvMissionDefinition@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z PROC ; CvMissionDefinition::setUnit, COMDAT
; _this$ = ecx

; 532  : 	checkBattleUnitType(unitType);
; 533  : 	m_aUnits[unitType] = unit;

	mov	eax, DWORD PTR _unit$[esp-4]
	mov	edx, DWORD PTR _unitType$[esp-4]
	mov	DWORD PTR [ecx+edx*4+4], eax

; 534  : }

	ret	8
?setUnit@CvMissionDefinition@@QAEXW4BattleUnitTypes@@PAVCvUnit@@@Z ENDP ; CvMissionDefinition::setUnit
_TEXT	ENDS
PUBLIC	?getPlot@CvMissionDefinition@@QBEPBVCvPlot@@XZ	; CvMissionDefinition::getPlot
; Function compile flags: /Ogtpy
;	COMDAT ?getPlot@CvMissionDefinition@@QBEPBVCvPlot@@XZ
_TEXT	SEGMENT
?getPlot@CvMissionDefinition@@QBEPBVCvPlot@@XZ PROC	; CvMissionDefinition::getPlot, COMDAT
; _this$ = ecx

; 538  : 	return m_pPlot;

	mov	eax, DWORD PTR [ecx+20]

; 539  : }

	ret	0
?getPlot@CvMissionDefinition@@QBEPBVCvPlot@@XZ ENDP	; CvMissionDefinition::getPlot
_TEXT	ENDS
PUBLIC	?setPlot@CvMissionDefinition@@QAEXPBVCvPlot@@@Z	; CvMissionDefinition::setPlot
; Function compile flags: /Ogtpy
;	COMDAT ?setPlot@CvMissionDefinition@@QAEXPBVCvPlot@@@Z
_TEXT	SEGMENT
_plot$ = 8						; size = 4
?setPlot@CvMissionDefinition@@QAEXPBVCvPlot@@@Z PROC	; CvMissionDefinition::setPlot, COMDAT
; _this$ = ecx

; 543  : 	m_pPlot = plot;

	mov	eax, DWORD PTR _plot$[esp-4]
	mov	DWORD PTR [ecx+20], eax

; 544  : }

	ret	4
?setPlot@CvMissionDefinition@@QAEXPBVCvPlot@@@Z ENDP	; CvMissionDefinition::setPlot
_TEXT	ENDS
PUBLIC	?getSecondaryPlot@CvMissionDefinition@@QBEPBVCvPlot@@XZ ; CvMissionDefinition::getSecondaryPlot
; Function compile flags: /Ogtpy
;	COMDAT ?getSecondaryPlot@CvMissionDefinition@@QBEPBVCvPlot@@XZ
_TEXT	SEGMENT
?getSecondaryPlot@CvMissionDefinition@@QBEPBVCvPlot@@XZ PROC ; CvMissionDefinition::getSecondaryPlot, COMDAT
; _this$ = ecx

; 548  : 	return m_pSecondaryPlot;

	mov	eax, DWORD PTR [ecx+24]

; 549  : }

	ret	0
?getSecondaryPlot@CvMissionDefinition@@QBEPBVCvPlot@@XZ ENDP ; CvMissionDefinition::getSecondaryPlot
_TEXT	ENDS
PUBLIC	?setSecondaryPlot@CvMissionDefinition@@QAEXPBVCvPlot@@@Z ; CvMissionDefinition::setSecondaryPlot
; Function compile flags: /Ogtpy
;	COMDAT ?setSecondaryPlot@CvMissionDefinition@@QAEXPBVCvPlot@@@Z
_TEXT	SEGMENT
_plot$ = 8						; size = 4
?setSecondaryPlot@CvMissionDefinition@@QAEXPBVCvPlot@@@Z PROC ; CvMissionDefinition::setSecondaryPlot, COMDAT
; _this$ = ecx

; 553  : 	m_pSecondaryPlot = plot;

	mov	eax, DWORD PTR _plot$[esp-4]
	mov	DWORD PTR [ecx+24], eax

; 554  : }

	ret	4
?setSecondaryPlot@CvMissionDefinition@@QAEXPBVCvPlot@@@Z ENDP ; CvMissionDefinition::setSecondaryPlot
_TEXT	ENDS
PUBLIC	??0CvAirMissionDefinition@@QAE@XZ		; CvAirMissionDefinition::CvAirMissionDefinition
EXTRN	?getMISSION_AIRPATROL@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_AIRPATROL
; Function compile flags: /Ogtpy
;	COMDAT ??0CvAirMissionDefinition@@QAE@XZ
_TEXT	SEGMENT
??0CvAirMissionDefinition@@QAE@XZ PROC			; CvAirMissionDefinition::CvAirMissionDefinition, COMDAT
; _this$ = ecx

; 565  : {

	xor	eax, eax
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], -1
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax

; 566  : 	m_fMissionTime = 0.0f;

	mov	DWORD PTR [esi+16], eax

; 567  : 	m_eMissionType = CvTypes::getMISSION_AIRPATROL();

	call	?getMISSION_AIRPATROL@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_AIRPATROL
	mov	DWORD PTR [esi], eax

; 568  : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAirMissionDefinition@@QAE@XZ ENDP			; CvAirMissionDefinition::CvAirMissionDefinition
_TEXT	ENDS
PUBLIC	??0CvAirMissionDefinition@@QAE@ABV0@@Z		; CvAirMissionDefinition::CvAirMissionDefinition
; Function compile flags: /Ogtpy
;	COMDAT ??0CvAirMissionDefinition@@QAE@ABV0@@Z
_TEXT	SEGMENT
_kCopy$ = 8						; size = 4
??0CvAirMissionDefinition@@QAE@ABV0@@Z PROC		; CvAirMissionDefinition::CvAirMissionDefinition, COMDAT
; _this$ = ecx

; 576  : {

	mov	eax, ecx
	mov	DWORD PTR [eax], -1
	xor	ecx, ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 577  : 	m_fMissionTime = kCopy.m_fMissionTime;

	mov	ecx, DWORD PTR _kCopy$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 578  : 	m_eMissionType = kCopy.m_eMissionType;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 579  : 	m_pPlot = kCopy.m_pPlot;

	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 580  : 
; 581  : 	for(int i=0; i<BATTLE_UNIT_COUNT; i++)
; 582  : 	{
; 583  : 		m_aDamage[i] = kCopy.m_aDamage[i];

	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 584  : 		m_aUnits[i] = kCopy.m_aUnits[i];

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx

; 585  : 	}
; 586  : }

	ret	4
??0CvAirMissionDefinition@@QAE@ABV0@@Z ENDP		; CvAirMissionDefinition::CvAirMissionDefinition
_TEXT	ENDS
PUBLIC	?getDamage@CvAirMissionDefinition@@QBEHW4BattleUnitTypes@@@Z ; CvAirMissionDefinition::getDamage
; Function compile flags: /Ogtpy
;	COMDAT ?getDamage@CvAirMissionDefinition@@QBEHW4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?getDamage@CvAirMissionDefinition@@QBEHW4BattleUnitTypes@@@Z PROC ; CvAirMissionDefinition::getDamage, COMDAT
; _this$ = ecx

; 590  : 	checkBattleUnitType(unitType);
; 591  : 	return m_aDamage[unitType];

	mov	eax, DWORD PTR _unitType$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+28]

; 592  : }

	ret	4
?getDamage@CvAirMissionDefinition@@QBEHW4BattleUnitTypes@@@Z ENDP ; CvAirMissionDefinition::getDamage
_TEXT	ENDS
PUBLIC	?setDamage@CvAirMissionDefinition@@QAEXW4BattleUnitTypes@@H@Z ; CvAirMissionDefinition::setDamage
; Function compile flags: /Ogtpy
;	COMDAT ?setDamage@CvAirMissionDefinition@@QAEXW4BattleUnitTypes@@H@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
_damage$ = 12						; size = 4
?setDamage@CvAirMissionDefinition@@QAEXW4BattleUnitTypes@@H@Z PROC ; CvAirMissionDefinition::setDamage, COMDAT
; _this$ = ecx

; 596  : 	checkBattleUnitType(unitType);
; 597  : 	m_aDamage[unitType] = damage;

	mov	eax, DWORD PTR _damage$[esp-4]
	mov	edx, DWORD PTR _unitType$[esp-4]
	mov	DWORD PTR [ecx+edx*4+28], eax

; 598  : }

	ret	8
?setDamage@CvAirMissionDefinition@@QAEXW4BattleUnitTypes@@H@Z ENDP ; CvAirMissionDefinition::setDamage
_TEXT	ENDS
PUBLIC	?isDead@CvAirMissionDefinition@@QBE_NW4BattleUnitTypes@@@Z ; CvAirMissionDefinition::isDead
EXTRN	?GetMaxHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetMaxHitPoints
; Function compile flags: /Ogtpy
;	COMDAT ?isDead@CvAirMissionDefinition@@QBE_NW4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?isDead@CvAirMissionDefinition@@QBE_NW4BattleUnitTypes@@@Z PROC ; CvAirMissionDefinition::isDead, COMDAT
; _this$ = ecx

; 602  : 	checkBattleUnitType(unitType);
; 603  : 	CvAssertMsg(getUnit(unitType) != NULL, "[Jason] Invalid battle unit type.");
; 604  : 	if(getDamage(unitType) >= getUnit(unitType)->GetMaxHitPoints())

	mov	eax, DWORD PTR _unitType$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+eax*4+28]
	mov	ecx, DWORD PTR [ecx+eax*4+4]
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	cmp	esi, eax
	setge	al
	pop	esi

; 605  : 		return true;
; 606  : 	else
; 607  : 		return false;
; 608  : }

	ret	4
?isDead@CvAirMissionDefinition@@QBE_NW4BattleUnitTypes@@@Z ENDP ; CvAirMissionDefinition::isDead
_TEXT	ENDS
PUBLIC	?size@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEIXZ ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEIXZ PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 780903145				; 2e8ba2e9H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEIXZ ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::size
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEABUVoteSelectionSubData@@XZ ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEABUVoteSelectionSubData@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEABUVoteSelectionSubData@@XZ PROC ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEABUVoteSelectionSubData@@XZ ENDP ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 44			; 0000002cH

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator++
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEIXZ ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEIXZ PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 780903145				; 2e8ba2e9H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEIXZ ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::capacity
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE@PAUVoteSelectionSubData@@@Z ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE@PAUVoteSelectionSubData@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE@PAUVoteSelectionSubData@@@Z PROC ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE@PAUVoteSelectionSubData@@@Z ENDP ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator==
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 780903145				; 2e8ba2e9H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE@PAUVoteSelectionSubData@@@Z ; std::_Vector_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Vector_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE@PAUVoteSelectionSubData@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE@PAUVoteSelectionSubData@@@Z PROC ; std::_Vector_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Vector_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE@PAUVoteSelectionSubData@@@Z ENDP ; std::_Vector_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Vector_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	imul	ecx, 44					; 0000002cH
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator+=
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUVoteSelectionSubData@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUVoteSelectionSubData@@0@Z ; std::_Iter_random<VoteSelectionSubData *,VoteSelectionSubData *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUVoteSelectionSubData@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUVoteSelectionSubData@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUVoteSelectionSubData@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUVoteSelectionSubData@@0@Z PROC ; std::_Iter_random<VoteSelectionSubData *,VoteSelectionSubData *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUVoteSelectionSubData@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUVoteSelectionSubData@@0@Z ENDP ; std::_Iter_random<VoteSelectionSubData *,VoteSelectionSubData *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUVoteSelectionSubData@@@std@@YA?AU_Undefined_move_tag@0@ABQAUVoteSelectionSubData@@@Z ; std::_Move_cat<VoteSelectionSubData *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUVoteSelectionSubData@@@std@@YA?AU_Undefined_move_tag@0@ABQAUVoteSelectionSubData@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUVoteSelectionSubData@@@std@@YA?AU_Undefined_move_tag@0@ABQAUVoteSelectionSubData@@@Z PROC ; std::_Move_cat<VoteSelectionSubData *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUVoteSelectionSubData@@@std@@YA?AU_Undefined_move_tag@0@ABQAUVoteSelectionSubData@@@Z ENDP ; std::_Move_cat<VoteSelectionSubData *>
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??0CvCombatMemberEntry@@QAE@XZ			; CvCombatMemberEntry::CvCombatMemberEntry
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??0CvCombatMemberEntry@@QAE@XZ
_TEXT	SEGMENT
??0CvCombatMemberEntry@@QAE@XZ PROC			; CvCombatMemberEntry::CvCombatMemberEntry, COMDAT
; _this$ = ecx

; 101  : 	CvCombatMemberEntry() : m_ePlayer(NO_PLAYER), m_iID(-1), m_bfFlags(0), m_iDamage(0), m_iFinalDamage(0), m_iMaxHitPoints(0), m_eCombatType(NO_UNITCOMBAT), m_eEra(NO_ERA), m_iX(0), m_iY(0), m_uiWeaponType(0), m_fWeaponOption(0.f) {}

	mov	eax, ecx
	or	ecx, -1
	xor	edx, edx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	xor	ecx, ecx
	mov	WORD PTR [eax+8], dx
	mov	WORD PTR [eax+10], dx
	mov	WORD PTR [eax+12], dx
	mov	WORD PTR [eax+14], dx
	mov	WORD PTR [eax+16], dx
	mov	WORD PTR [eax+18], dx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	ret	0
??0CvCombatMemberEntry@@QAE@XZ ENDP			; CvCombatMemberEntry::CvCombatMemberEntry
_TEXT	ENDS
PUBLIC	??0VoteSelectionSubData@@QAE@XZ			; VoteSelectionSubData::VoteSelectionSubData
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvstructs.h
;	COMDAT ??0VoteSelectionSubData@@QAE@XZ
_TEXT	SEGMENT
??0VoteSelectionSubData@@QAE@XZ PROC			; VoteSelectionSubData::VoteSelectionSubData, COMDAT
; _this$ = ecx

; 69   : 	{

	push	esi
	mov	esi, ecx
	or	eax, -1
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 70   : 	}

	mov	eax, esi
	pop	esi
	ret	0
??0VoteSelectionSubData@@QAE@XZ ENDP			; VoteSelectionSubData::VoteSelectionSubData
_TEXT	ENDS
PUBLIC	??1VoteSelectionSubData@@QAE@XZ			; VoteSelectionSubData::~VoteSelectionSubData
; Function compile flags: /Ogtpy
;	COMDAT ??1VoteSelectionSubData@@QAE@XZ
_TEXT	SEGMENT
??1VoteSelectionSubData@@QAE@XZ PROC			; VoteSelectionSubData::~VoteSelectionSubData, COMDAT
; _this$ = ecx
	add	ecx, 16					; 00000010H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1VoteSelectionSubData@@QAE@XZ ENDP			; VoteSelectionSubData::~VoteSelectionSubData
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T219614 = -80						; size = 28
$T219613 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T219614[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T219613[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T219614[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T219613[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T219613[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T219613[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T219613[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T219614[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T219613[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UVoteSelectionSubData@@@std@@QAEXPAUVoteSelectionSubData@@I@Z ; std::allocator<VoteSelectionSubData>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@UVoteSelectionSubData@@@std@@QAEXPAUVoteSelectionSubData@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UVoteSelectionSubData@@@std@@QAEXPAUVoteSelectionSubData@@I@Z PROC ; std::allocator<VoteSelectionSubData>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UVoteSelectionSubData@@@std@@QAEXPAUVoteSelectionSubData@@I@Z ENDP ; std::allocator<VoteSelectionSubData>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T219658 = -80						; size = 28
$T219657 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T219658[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T219657[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T219658[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T219657[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T219657[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T219657[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T219657[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T219658[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T219657[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UVoteSelectionSubData@@@std@@QBEIXZ ; std::allocator<VoteSelectionSubData>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@UVoteSelectionSubData@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UVoteSelectionSubData@@@std@@QBEIXZ PROC ; std::allocator<VoteSelectionSubData>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 97612893				; 05d1745dH

; 167  : 		}

	ret	0
?max_size@?$allocator@UVoteSelectionSubData@@@std@@QBEIXZ ENDP ; std::allocator<VoteSelectionSubData>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@UVoteSelectionSubData@@@std@@YAPAUVoteSelectionSubData@@IPAU1@@Z ; std::_Allocate<VoteSelectionSubData>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@UVoteSelectionSubData@@@std@@YAPAUVoteSelectionSubData@@IPAU1@@Z
_TEXT	SEGMENT
$T219701 = -12						; size = 12
$T219705 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UVoteSelectionSubData@@@std@@YAPAUVoteSelectionSubData@@IPAU1@@Z PROC ; std::_Allocate<VoteSelectionSubData>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	imul	ecx, 44					; 0000002cH
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 44					; 0000002cH
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T219705[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T219701[esp+16]
	mov	DWORD PTR $T219705[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T219701[esp+16]
	push	ecx
	mov	DWORD PTR $T219701[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@UVoteSelectionSubData@@@std@@YAPAUVoteSelectionSubData@@IPAU1@@Z ENDP ; std::_Allocate<VoteSelectionSubData>
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T219711 = -12						; size = 12
$T219715 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T219715[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T219711[esp+16]
	mov	DWORD PTR $T219715[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T219711[esp+16]
	push	ecx
	mov	DWORD PTR $T219711[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ; FDataStream::operator>><CvString>
EXTRN	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z PROC ; FDataStream::operator>><CvString>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ENDP ; FDataStream::operator>><CvString>
_TEXT	ENDS
PUBLIC	??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ; FDataStream::operator<<<CvString>
EXTRN	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z PROC ; FDataStream::operator<<<CvString>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ENDP ; FDataStream::operator<<<CvString>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUVoteSelectionSubData@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUVoteSelectionSubData@@0@Z ; std::_Ptr_cat<VoteSelectionSubData *,VoteSelectionSubData *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAUVoteSelectionSubData@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUVoteSelectionSubData@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUVoteSelectionSubData@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUVoteSelectionSubData@@0@Z PROC ; std::_Ptr_cat<VoteSelectionSubData *,VoteSelectionSubData *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUVoteSelectionSubData@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUVoteSelectionSubData@@0@Z ENDP ; std::_Ptr_cat<VoteSelectionSubData *,VoteSelectionSubData *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
$T219778 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T219778[esp]
	sar	edx, 2
	push	eax
	mov	DWORD PTR $T219778[esp+4], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??_GVoteSelectionSubData@@QAEPAXI@Z		; VoteSelectionSubData::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GVoteSelectionSubData@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GVoteSelectionSubData@@QAEPAXI@Z PROC		; VoteSelectionSubData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+16]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GVoteSelectionSubData@@QAEPAXI@Z ENDP		; VoteSelectionSubData::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAEXABH@Z ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAEXABH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAEXABH@Z PROC ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	ecx, DWORD PTR [ecx]
	jmp	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
??R?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAEXABH@Z ENDP ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::operator()
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?read@VoteTriggeredData@@QAEXAAVFDataStream@@@Z	; VoteTriggeredData::read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4VoteTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4VoteSourceTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvstructs.cpp
;	COMDAT ?read@VoteTriggeredData@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?read@VoteTriggeredData@@QAEXAAVFDataStream@@@Z PROC	; VoteTriggeredData::read, COMDAT
; _this$ = ecx

; 96   : {

	push	esi
	push	edi

; 97   : 	// Version number to maintain backwards compatibility
; 98   : 	uint uiVersion;
; 99   : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiVersion$[esp+4]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 100  : 
; 101  : 	kStream >> iId;

	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 102  : 	kStream >> eVoteSource;

	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4VoteSourceTypes@@@Z ; operator>>

; 103  : 	kStream >> kVoteOption.eVote;

	lea	edx, DWORD PTR [esi+8]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4VoteTypes@@@Z ; operator>>

; 104  : 	kStream >> kVoteOption.ePlayer;

	lea	eax, DWORD PTR [esi+12]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 24					; 00000018H

; 105  : 	kStream >> kVoteOption.iCityId;

	lea	ecx, DWORD PTR [esi+16]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 106  : 	kStream >> kVoteOption.eOtherPlayer;

	lea	edx, DWORD PTR [esi+20]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 107  : 	kStream >> kVoteOption.strText;

	add	esi, 24					; 00000018H
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read
	pop	edi
	pop	esi

; 108  : }

	ret	4
?read@VoteTriggeredData@@QAEXAAVFDataStream@@@Z ENDP	; VoteTriggeredData::read
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUVoteTriggeredData@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUVoteTriggeredData@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUVoteTriggeredData@@@Z PROC ; operator>>, COMDAT

; 111  : 	writeTo.read(loadFrom);

	mov	ecx, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	esi
	call	?read@VoteTriggeredData@@QAEXAAVFDataStream@@@Z ; VoteTriggeredData::read

; 112  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 113  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUVoteTriggeredData@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	?write@VoteTriggeredData@@QBEXAAVFDataStream@@@Z ; VoteTriggeredData::write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4VoteTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4VoteSourceTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?write@VoteTriggeredData@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?write@VoteTriggeredData@@QBEXAAVFDataStream@@@Z PROC	; VoteTriggeredData::write, COMDAT
; _this$ = ecx

; 116  : {

	push	ecx
	push	esi
	push	edi

; 117  : 	// Current version number
; 118  : 	uint uiVersion = 1;
; 119  : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+16], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 120  : 
; 121  : 	kStream << iId;

	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 122  : 	kStream << eVoteSource;

	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4VoteSourceTypes@@@Z ; operator<<

; 123  : 	kStream << kVoteOption.eVote;

	lea	edx, DWORD PTR [esi+8]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4VoteTypes@@@Z ; operator<<

; 124  : 	kStream << kVoteOption.ePlayer;

	lea	eax, DWORD PTR [esi+12]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 24					; 00000018H

; 125  : 	kStream << kVoteOption.iCityId;

	lea	ecx, DWORD PTR [esi+16]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 126  : 	kStream << kVoteOption.eOtherPlayer;

	lea	edx, DWORD PTR [esi+20]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 127  : 	kStream << kVoteOption.strText;

	add	esi, 24					; 00000018H
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write
	pop	edi
	pop	esi

; 128  : }

	pop	ecx
	ret	4
?write@VoteTriggeredData@@QBEXAAVFDataStream@@@Z ENDP	; VoteTriggeredData::write
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUVoteTriggeredData@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUVoteTriggeredData@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUVoteTriggeredData@@@Z PROC ; operator<<, COMDAT

; 131  : 	readFrom.write(saveTo);

	mov	ecx, DWORD PTR _readFrom$[esp-4]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	esi
	call	?write@VoteTriggeredData@@QBEXAAVFDataStream@@@Z ; VoteTriggeredData::write

; 132  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 133  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUVoteTriggeredData@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUBuildingYieldChange@@@Z ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4YieldTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4BuildingClassTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUBuildingYieldChange@@@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUBuildingYieldChange@@@Z PROC ; operator>>, COMDAT

; 136  : {

	push	esi

; 137  : 	kStream >> writeTo.eBuildingClass;

	mov	esi, DWORD PTR _kStream$[esp]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+4]
	push	edi
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4BuildingClassTypes@@@Z ; operator>>

; 138  : 	kStream >> writeTo.eYield;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4YieldTypes@@@Z ; operator>>
	add	esp, 16					; 00000010H

; 139  : 	kStream >> writeTo.iChange;

	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi

; 140  : 	return kStream;

	mov	eax, esi
	pop	esi

; 141  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUBuildingYieldChange@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUBuildingYieldChange@@@Z ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4YieldTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4BuildingClassTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUBuildingYieldChange@@@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUBuildingYieldChange@@@Z PROC ; operator<<, COMDAT

; 144  : {

	push	esi

; 145  : 	kStream << readFrom.eBuildingClass;

	mov	esi, DWORD PTR _kStream$[esp]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+4]
	push	edi
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4BuildingClassTypes@@@Z ; operator<<

; 146  : 	kStream << readFrom.eYield;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4YieldTypes@@@Z ; operator<<
	add	esp, 16					; 00000010H

; 147  : 	kStream << readFrom.iChange;

	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi

; 148  : 	return kStream;

	mov	eax, esi
	pop	esi

; 149  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUBuildingYieldChange@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUBuildingGreatWork@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUBuildingGreatWork@@@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUBuildingGreatWork@@@Z PROC ; operator>>, COMDAT

; 152  : {

	push	esi

; 153  : 	kStream >> writeTo.eBuildingClass;

	mov	esi, DWORD PTR _kStream$[esp]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+4]
	push	edi
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4BuildingClassTypes@@@Z ; operator>>
	add	esp, 8

; 154  : 	kStream >> writeTo.iSlot;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 155  : 	kStream >> writeTo.iGreatWorkIndex;

	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi

; 156  : 	return kStream;

	mov	eax, esi
	pop	esi

; 157  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUBuildingGreatWork@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUBuildingGreatWork@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUBuildingGreatWork@@@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUBuildingGreatWork@@@Z PROC ; operator<<, COMDAT

; 160  : {

	push	esi

; 161  : 	kStream << readFrom.eBuildingClass;

	mov	esi, DWORD PTR _kStream$[esp]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+4]
	push	edi
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4BuildingClassTypes@@@Z ; operator<<
	add	esp, 8

; 162  : 	kStream << readFrom.iSlot;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 163  : 	kStream << readFrom.iGreatWorkIndex;

	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi

; 164  : 	return kStream;

	mov	eax, esi
	pop	esi

; 165  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUBuildingGreatWork@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??0CvCombatInfo@@QAE@XZ				; CvCombatInfo::CvCombatInfo
; Function compile flags: /Ogtpy
;	COMDAT ??0CvCombatInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvCombatInfo@@QAE@XZ PROC				; CvCombatInfo::CvCombatInfo, COMDAT
; _this$ = ecx

; 194  : {

	mov	eax, ecx
	mov	BYTE PTR [eax+32], 1
	xor	edx, edx
	mov	DWORD PTR [eax+24], edx
	mov	BYTE PTR [eax+28], dl
	mov	BYTE PTR [eax+29], dl
	mov	BYTE PTR [eax+30], dl
	mov	BYTE PTR [eax+31], dl
	mov	BYTE PTR [eax+33], dl
	mov	DWORD PTR [eax+36], edx
	mov	BYTE PTR [eax+106], dl
	mov	BYTE PTR [eax+107], dl
	push	esi
	or	esi, -1
	xor	ecx, ecx
	push	edi
	mov	WORD PTR [eax+116], cx
	mov	WORD PTR [eax+118], cx
	mov	WORD PTR [eax+120], cx
	mov	WORD PTR [eax+122], cx
	mov	WORD PTR [eax+124], cx
	mov	WORD PTR [eax+126], cx
	mov	WORD PTR [eax+152], cx
	mov	WORD PTR [eax+154], cx
	mov	WORD PTR [eax+156], cx
	mov	WORD PTR [eax+158], cx
	mov	WORD PTR [eax+160], cx
	mov	WORD PTR [eax+162], cx
	mov	WORD PTR [eax+188], cx
	mov	WORD PTR [eax+190], cx
	mov	WORD PTR [eax+192], cx
	mov	WORD PTR [eax+194], cx
	mov	WORD PTR [eax+196], cx
	mov	WORD PTR [eax+198], cx
	mov	DWORD PTR [eax+108], esi
	mov	DWORD PTR [eax+112], esi
	mov	DWORD PTR [eax+128], esi
	mov	DWORD PTR [eax+132], esi
	mov	DWORD PTR [eax+136], edx
	mov	DWORD PTR [eax+140], edx
	mov	DWORD PTR [eax+144], esi
	mov	DWORD PTR [eax+148], esi
	mov	DWORD PTR [eax+164], esi
	mov	DWORD PTR [eax+168], esi
	mov	DWORD PTR [eax+172], edx
	mov	DWORD PTR [eax+176], edx
	mov	DWORD PTR [eax+180], esi
	mov	DWORD PTR [eax+184], esi
	mov	DWORD PTR [eax+200], esi
	mov	DWORD PTR [eax+204], esi
	mov	DWORD PTR [eax+208], edx
	mov	DWORD PTR [eax+212], edx
	mov	DWORD PTR [eax+216], edx
	lea	ecx, DWORD PTR [eax+220]
	lea	edi, DWORD PTR [edx+31]
	push	ebx
	npad	4
$LL13@CvCombatIn:
	xor	ebx, ebx
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], esi
	mov	WORD PTR [ecx+8], bx
	mov	WORD PTR [ecx+10], bx
	mov	WORD PTR [ecx+12], bx
	mov	WORD PTR [ecx+14], bx
	mov	WORD PTR [ecx+16], bx
	mov	WORD PTR [ecx+18], bx
	mov	DWORD PTR [ecx+20], esi
	mov	DWORD PTR [ecx+24], esi
	mov	DWORD PTR [ecx+28], edx
	mov	DWORD PTR [ecx+32], edx
	add	ecx, 36					; 00000024H
	sub	edi, 1
	jns	SHORT $LL13@CvCombatIn

; 195  : 	for(int i=0; i<BATTLE_UNIT_COUNT; i++)

	lea	edi, DWORD PTR [ebx+3]
	lea	esi, DWORD PTR [eax+103]
	lea	ecx, DWORD PTR [eax+40]
	pop	ebx
	npad	3
$LL3@CvCombatIn:

; 196  : 	{
; 197  : 		m_pUnits[i] = NULL;

	mov	DWORD PTR [ecx-40], edx

; 198  : 		m_pCities[i] = NULL;

	mov	DWORD PTR [ecx-28], edx

; 199  : 		m_iFinalDamage[i] = 0;

	mov	DWORD PTR [ecx], edx

; 200  : 		m_iDamageInflicted[i] = 0;

	mov	DWORD PTR [ecx+12], edx

; 201  : 		m_iFearDamageInflicted[i] = 0;

	mov	DWORD PTR [ecx+24], edx

; 202  : 		m_iExperienceChange[i] = 0;

	mov	DWORD PTR [ecx+36], edx

; 203  : 		m_iMaxExperienceAllowed[i] = 0;

	mov	DWORD PTR [ecx+48], edx

; 204  : 		m_bInBorders[i] = false;

	mov	BYTE PTR [esi-3], dl

; 205  : 		m_bUpdateGlobal[i] = false;

	mov	BYTE PTR [esi], dl
	add	ecx, 4
	inc	esi
	sub	edi, 1
	jne	SHORT $LL3@CvCombatIn
	pop	edi
	pop	esi

; 206  : 	}
; 207  : }

	ret	0
??0CvCombatInfo@@QAE@XZ ENDP				; CvCombatInfo::CvCombatInfo
_TEXT	ENDS
PUBLIC	?getCity@CvCombatInfo@@QBEPAVCvCity@@W4BattleUnitTypes@@@Z ; CvCombatInfo::getCity
; Function compile flags: /Ogtpy
;	COMDAT ?getCity@CvCombatInfo@@QBEPAVCvCity@@W4BattleUnitTypes@@@Z
_TEXT	SEGMENT
_unitType$ = 8						; size = 4
?getCity@CvCombatInfo@@QBEPAVCvCity@@W4BattleUnitTypes@@@Z PROC ; CvCombatInfo::getCity, COMDAT
; _this$ = ecx

; 257  : {

	push	esi
	mov	esi, ecx

; 258  : 	checkBattleUnitType(unitType);
; 259  : 	if(m_pCities[unitType])

	mov	ecx, DWORD PTR _unitType$[esp]
	mov	eax, DWORD PTR [esi+ecx*4+12]
	test	eax, eax

; 260  : 		return m_pCities[unitType];

	jne	SHORT $LN5@getCity

; 261  : 	else if(unitType == BATTLE_UNIT_DEFENDER && m_pTargetPlot)

	cmp	ecx, 1
	jne	SHORT $LN1@getCity
	mov	ecx, DWORD PTR [esi+24]
	test	ecx, ecx
	je	SHORT $LN1@getCity

; 262  : 	{
; 263  : 		if(m_pTargetPlot->isCity())

	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al
	je	SHORT $LN1@getCity

; 264  : 			return m_pTargetPlot->getPlotCity();

	mov	ecx, DWORD PTR [esi+24]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	pop	esi

; 267  : }

	ret	4
$LN1@getCity:

; 265  : 	}
; 266  : 	return NULL;

	xor	eax, eax
$LN5@getCity:
	pop	esi

; 267  : }

	ret	4
?getCity@CvCombatInfo@@QBEPAVCvCity@@W4BattleUnitTypes@@@Z ENDP ; CvCombatInfo::getCity
_TEXT	ENDS
PUBLIC	?setDamageMemberCount@CvCombatInfo@@QAEXH@Z	; CvCombatInfo::setDamageMemberCount
; Function compile flags: /Ogtpy
;	COMDAT ?setDamageMemberCount@CvCombatInfo@@QAEXH@Z
_TEXT	SEGMENT
$T219962 = -4						; size = 4
_iDamageMemberCount$ = 8				; size = 4
?setDamageMemberCount@CvCombatInfo@@QAEXH@Z PROC	; CvCombatInfo::setDamageMemberCount, COMDAT
; _this$ = ecx

; 485  : {

	push	ecx

; 486  : 	CvAssertMsg(iDamageMemberCount >=0 && iDamageMemberCount <= MAX_DAMAGE_MEMBER_COUNT, "Invalid damage member count!");
; 487  : 	m_iDamageMemberCount = std::min(iDamageMemberCount, (int)MAX_DAMAGE_MEMBER_COUNT);

	mov	eax, 32					; 00000020H
	cmp	DWORD PTR _iDamageMemberCount$[esp], eax
	mov	DWORD PTR $T219962[esp+4], eax
	jle	SHORT $LN5@setDamageM
	lea	eax, DWORD PTR $T219962[esp+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+216], eax

; 488  : }

	pop	ecx
	ret	4

; 486  : 	CvAssertMsg(iDamageMemberCount >=0 && iDamageMemberCount <= MAX_DAMAGE_MEMBER_COUNT, "Invalid damage member count!");
; 487  : 	m_iDamageMemberCount = std::min(iDamageMemberCount, (int)MAX_DAMAGE_MEMBER_COUNT);

$LN5@setDamageM:
	lea	eax, DWORD PTR _iDamageMemberCount$[esp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+216], edx

; 488  : }

	pop	ecx
	ret	4
?setDamageMemberCount@CvCombatInfo@@QAEXH@Z ENDP	; CvCombatInfo::setDamageMemberCount
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUOrderData@@@Z	; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4OrderTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUOrderData@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUOrderData@@@Z PROC	; operator<<, COMDAT

; 639  : {

	push	esi

; 640  : 	saveTo << readFrom.eOrderType;

	mov	esi, DWORD PTR _saveTo$[esp]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+4]
	push	edi
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4OrderTypes@@@Z ; operator<<
	add	esp, 8

; 641  : 	saveTo << readFrom.iData1;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 642  : 	saveTo << readFrom.iData2;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 643  : 	saveTo << readFrom.bSave;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 644  : 	saveTo << readFrom.bRush;

	add	edi, 13					; 0000000dH
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	pop	edi

; 645  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 646  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUOrderData@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUOrderData@@@Z	; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4OrderTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUOrderData@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUOrderData@@@Z PROC	; operator>>, COMDAT

; 649  : {

	push	esi

; 650  : 	loadFrom >> writeTo.eOrderType;

	mov	esi, DWORD PTR _loadFrom$[esp]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+4]
	push	edi
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4OrderTypes@@@Z ; operator>>
	add	esp, 8

; 651  : 	loadFrom >> writeTo.iData1;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 652  : 	loadFrom >> writeTo.iData2;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 653  : 	loadFrom >> writeTo.bSave;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 654  : 	loadFrom >> writeTo.bRush;

	add	edi, 13					; 0000000dH
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	pop	edi

; 655  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 656  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUOrderData@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUPlotExtraCost@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUPlotExtraCost@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUPlotExtraCost@@@Z PROC	; operator<<, COMDAT

; 675  : {

	push	esi

; 676  : 	saveTo << readFrom.m_iX;

	mov	esi, DWORD PTR _saveTo$[esp]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 677  : 	saveTo << readFrom.m_iY;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 678  : 	saveTo << readFrom.m_iCost;

	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi

; 679  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 680  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUPlotExtraCost@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUPlotExtraCost@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUPlotExtraCost@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUPlotExtraCost@@@Z PROC	; operator>>, COMDAT

; 683  : {

	push	esi

; 684  : 	loadFrom >> writeTo.m_iX;

	mov	esi, DWORD PTR _loadFrom$[esp]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 685  : 	loadFrom >> writeTo.m_iY;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 686  : 	loadFrom >> writeTo.m_iCost;

	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi

; 687  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 688  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUPlotExtraCost@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUIDInfo@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUIDInfo@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUIDInfo@@@Z PROC		; operator<<, COMDAT

; 692  : {

	push	esi

; 693  : 	saveTo << readFrom.eOwner;

	mov	esi, DWORD PTR _saveTo$[esp]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+4]
	push	edi
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 694  : 	saveTo << readFrom.iID;

	add	edi, 4
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi

; 695  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 696  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUIDInfo@@@Z ENDP		; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUIDInfo@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUIDInfo@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUIDInfo@@@Z PROC		; operator>>, COMDAT

; 699  : {

	push	esi

; 700  : 	loadFrom >> writeTo.eOwner;

	mov	esi, DWORD PTR _loadFrom$[esp]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+4]
	push	edi
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 701  : 	loadFrom >> writeTo.iID;

	add	edi, 4
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi

; 702  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 703  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUIDInfo@@@Z ENDP		; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUMissionData@@@Z	; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4MissionTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUMissionData@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUMissionData@@@Z PROC	; operator<<, COMDAT

; 706  : {

	push	esi

; 707  : 	saveTo << readFrom.eMissionType;

	mov	esi, DWORD PTR _saveTo$[esp]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+4]
	push	edi
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4MissionTypes@@@Z ; operator<<
	add	esp, 8

; 708  : 	saveTo << readFrom.iData1;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 709  : 	saveTo << readFrom.iData2;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 710  : 	saveTo << readFrom.iFlags;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 711  : 	saveTo << readFrom.iPushTurn;

	add	edi, 16					; 00000010H
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi

; 712  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 713  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUMissionData@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUMissionData@@@Z	; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4MissionTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUMissionData@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUMissionData@@@Z PROC	; operator>>, COMDAT

; 715  : {

	push	esi

; 716  : 	loadFrom >> writeTo.eMissionType;

	mov	esi, DWORD PTR _loadFrom$[esp]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+4]
	push	edi
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4MissionTypes@@@Z ; operator>>
	add	esp, 8

; 717  : 	loadFrom >> writeTo.iData1;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 718  : 	loadFrom >> writeTo.iData2;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 719  : 	loadFrom >> writeTo.iFlags;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 720  : 	loadFrom >> writeTo.iPushTurn;

	add	edi, 16					; 00000010H
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi

; 721  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 722  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUMissionData@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	?begin@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator!=
_TEXT	ENDS
PUBLIC	?end@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@XZ ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::begin
_TEXT	ENDS
PUBLIC	??0VoteSelectionSubData@@QAE@ABU0@@Z		; VoteSelectionSubData::VoteSelectionSubData
; Function compile flags: /Ogtpy
;	COMDAT ??0VoteSelectionSubData@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0VoteSelectionSubData@@QAE@ABU0@@Z PROC		; VoteSelectionSubData::VoteSelectionSubData, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], ecx
	mov	edx, DWORD PTR [eax+12]
	add	eax, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+12], edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0VoteSelectionSubData@@QAE@ABU0@@Z ENDP		; VoteSelectionSubData::VoteSelectionSubData
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	imul	ecx, 44					; 0000002cH
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator+=
_TEXT	ENDS
PUBLIC	??4VoteSelectionSubData@@QAEAAU0@ABU0@@Z	; VoteSelectionSubData::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4VoteSelectionSubData@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4VoteSelectionSubData@@QAEAAU0@ABU0@@Z PROC		; VoteSelectionSubData::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], ecx
	mov	edx, DWORD PTR [eax+12]
	add	eax, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+12], edx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4VoteSelectionSubData@@QAEAAU0@ABU0@@Z ENDP		; VoteSelectionSubData::operator=
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUVoteSelectionSubData@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<VoteSelectionSubData *,VoteSelectionSubData *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUVoteSelectionSubData@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUVoteSelectionSubData@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<VoteSelectionSubData *,VoteSelectionSubData *,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	ebx, esi
	je	SHORT $LN11@Copy_backw@2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	eax, DWORD PTR [esi-44]
	sub	esi, 44					; 0000002cH
	sub	edi, 44					; 0000002cH
	mov	DWORD PTR [edi], eax
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], ecx
	mov	edx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+8], edx
	mov	eax, DWORD PTR [esi+12]
	push	ecx
	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+12], eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL2@Copy_backw@2

; 2677 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
$LN11@Copy_backw@2:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUVoteSelectionSubData@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<VoteSelectionSubData *,VoteSelectionSubData *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z ; std::_Construct<VoteSelectionSubData,VoteSelectionSubData>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
xdata$x	SEGMENT
__unwindtable$??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z
_TEXT	SEGMENT
$T220153 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z PROC ; std::_Construct<VoteSelectionSubData,VoteSelectionSubData>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T220153[esp+16], eax
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp+12]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	add	ecx, 16					; 00000010H
	push	ecx
	lea	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN3@Construct:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T220153[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z ENDP ; std::_Construct<VoteSelectionSubData,VoteSelectionSubData>
PUBLIC	?max_size@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEIXZ ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEIXZ PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 97612893				; 05d1745dH

; 732  : 		}

	ret	0
?max_size@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBEIXZ ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UVoteSelectionSubData@@@std@@QAEPAUVoteSelectionSubData@@I@Z ; std::allocator<VoteSelectionSubData>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UVoteSelectionSubData@@@std@@QAEPAUVoteSelectionSubData@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UVoteSelectionSubData@@@std@@QAEPAUVoteSelectionSubData@@I@Z PROC ; std::allocator<VoteSelectionSubData>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UVoteSelectionSubData@@@std@@YAPAUVoteSelectionSubData@@IPAU1@@Z ; std::_Allocate<VoteSelectionSubData>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UVoteSelectionSubData@@@std@@QAEPAUVoteSelectionSubData@@I@Z ENDP ; std::allocator<VoteSelectionSubData>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@V?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<int,std::allocator<int> >,SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@V?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@V?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<int,std::allocator<int> >,SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	esi

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	esi, DWORD PTR __First$[esp]
	push	edi

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edi, DWORD PTR __Last$[esp+4]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, edi
	je	SHORT $LN1@for_each
	npad	2
$LL6@for_each:

; 29   : 		_Func(*_ChkFirst);

	mov	ecx, DWORD PTR __Func$[esp+4]
	push	esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	cmp	esi, edi
	jne	SHORT $LL6@for_each
$LN1@for_each:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@V?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<int,std::allocator<int> >,SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const > >
_TEXT	ENDS
PUBLIC	??$_Destroy@UVoteSelectionSubData@@@std@@YAXPAUVoteSelectionSubData@@@Z ; std::_Destroy<VoteSelectionSubData>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UVoteSelectionSubData@@@std@@YAXPAUVoteSelectionSubData@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UVoteSelectionSubData@@@std@@YAXPAUVoteSelectionSubData@@@Z PROC ; std::_Destroy<VoteSelectionSubData>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	add	ecx, 16					; 00000010H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??$_Destroy@UVoteSelectionSubData@@@std@@YAXPAUVoteSelectionSubData@@@Z ENDP ; std::_Destroy<VoteSelectionSubData>
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?write@VoteSelectionData@@QBEXAAVFDataStream@@@Z ; VoteSelectionData::write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvstructs.cpp
;	COMDAT ?write@VoteSelectionData@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T220378 = 8						; size = 4
_kStream$ = 8						; size = 4
?write@VoteSelectionData@@QBEXAAVFDataStream@@@Z PROC	; VoteSelectionData::write, COMDAT
; _this$ = ecx

; 62   : {

	push	ecx
	push	ebx
	push	esi
	push	edi

; 63   : 	// Current version number
; 64   : 	uint uiVersion = 1;
; 65   : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	mov	ebx, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+20], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 66   : 
; 67   : 	kStream << iId;

	push	ebx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 68   : 	kStream << eVoteSource;

	lea	ecx, DWORD PTR [ebx+4]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4VoteSourceTypes@@@Z ; operator<<

; 69   : 	kStream << aVoteOptions.size();

	mov	ecx, DWORD PTR [ebx+16]
	sub	ecx, DWORD PTR [ebx+12]
	mov	eax, 780903145				; 2e8ba2e9H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	add	esp, 8
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T220378[esp+12]
	add	eax, edx
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T220378[esp+16], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 70   : 	for(std::vector<VoteSelectionSubData>::const_iterator it = aVoteOptions.begin(); it != aVoteOptions.end(); ++it)

	mov	esi, DWORD PTR [ebx+12]
	cmp	esi, DWORD PTR [ebx+16]
	je	SHORT $LN1@write
$LL18@write:

; 71   : 	{
; 72   : 		kStream << (*it).eVote;

	push	esi
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4VoteTypes@@@Z ; operator<<
	lea	edx, DWORD PTR [esi+4]

; 73   : 		kStream << (*it).ePlayer;

	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR [esi+8]

; 74   : 		kStream << (*it).iCityId;

	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	ecx, DWORD PTR [esi+12]

; 75   : 		kStream << (*it).eOtherPlayer;

	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8
	lea	edx, DWORD PTR [esi+16]

; 76   : 		kStream << (*it).strText;

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write
	add	esi, 44					; 0000002cH
	cmp	esi, DWORD PTR [ebx+16]
	jne	SHORT $LL18@write
$LN1@write:
	pop	edi
	pop	esi
	pop	ebx

; 77   : 	}
; 78   : }

	pop	ecx
	ret	4
?write@VoteSelectionData@@QBEXAAVFDataStream@@@Z ENDP	; VoteSelectionData::write
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUVoteSelectionData@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUVoteSelectionData@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUVoteSelectionData@@@Z PROC ; operator<<, COMDAT

; 81   : 	readFrom.write(saveTo);

	mov	ecx, DWORD PTR _readFrom$[esp-4]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	esi
	call	?write@VoteSelectionData@@QBEXAAVFDataStream@@@Z ; VoteSelectionData::write

; 82   : 	return saveTo;

	mov	eax, esi
	pop	esi

; 83   : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUVoteSelectionData@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	imul	edx, 44					; 0000002cH
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::operator+
_TEXT	ENDS
PUBLIC	??$_Fill@PAUVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@0ABU1@@Z ; std::_Fill<VoteSelectionSubData *,VoteSelectionSubData>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAUVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@0ABU1@@Z PROC ; std::_Fill<VoteSelectionSubData *,VoteSelectionSubData>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	ebp, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebp
	je	SHORT $LN1@Fill@2
	push	ebx
	push	edi
	mov	edi, DWORD PTR __Val$[esp+12]
	lea	ebx, DWORD PTR [edi+16]
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	push	ebx
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+12], eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 44					; 0000002cH
	cmp	esi, ebp
	jne	SHORT $LL3@Fill@2
	pop	edi
	pop	ebx
$LN1@Fill@2:
	pop	esi
	pop	ebp

; 3160 : 	}

	ret	0
??$_Fill@PAUVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@0ABU1@@Z ENDP ; std::_Fill<VoteSelectionSubData *,VoteSelectionSubData>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUVoteSelectionSubData@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUVoteSelectionSubData@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<VoteSelectionSubData *,VoteSelectionSubData *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAUVoteSelectionSubData@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUVoteSelectionSubData@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T220478 = -4						; size = 1
__Cat$220483 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUVoteSelectionSubData@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUVoteSelectionSubData@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<VoteSelectionSubData *,VoteSelectionSubData *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __First_dest_cat$[esp]
	mov	BYTE PTR $T220478[esp+4], 0
	mov	eax, DWORD PTR $T220478[esp+4]
	mov	ecx, DWORD PTR __Cat$220483[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAUVoteSelectionSubData@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<VoteSelectionSubData *,VoteSelectionSubData *,std::random_access_iterator_tag>

; 2755 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Move_backward_opt@PAUVoteSelectionSubData@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUVoteSelectionSubData@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<VoteSelectionSubData *,VoteSelectionSubData *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UVoteSelectionSubData@@@std@@QAEXPAUVoteSelectionSubData@@ABU3@@Z ; std::allocator<VoteSelectionSubData>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@UVoteSelectionSubData@@@std@@QAEXPAUVoteSelectionSubData@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UVoteSelectionSubData@@@std@@QAEXPAUVoteSelectionSubData@@ABU3@@Z PROC ; std::allocator<VoteSelectionSubData>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	eax
	push	ecx
	call	??$_Construct@UVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@ABU1@@Z ; std::_Construct<VoteSelectionSubData,VoteSelectionSubData>
	add	esp, 8

; 156  : 		}

	ret	8
?construct@?$allocator@UVoteSelectionSubData@@@std@@QAEXPAUVoteSelectionSubData@@ABU3@@Z ENDP ; std::allocator<VoteSelectionSubData>::construct
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator<<<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T220542 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; operator<<<int>, COMDAT

; 198  : {

	push	ebx

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	ebx, DWORD PTR _saveTo$[esp]
	push	esi
	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	push	edi
	lea	ecx, DWORD PTR $T220542[esp+8]
	sar	eax, 2
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T220542[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	edi, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	cmp	esi, edi
	je	SHORT $LN36@operator@2
	npad	2
$LL22@operator@2:
	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	cmp	esi, edi
	jne	SHORT $LL22@operator@2
$LN36@operator@2:
	pop	edi
	pop	esi

; 200  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 201  : }

	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UVoteSelectionSubData@@@std@@QAEXPAUVoteSelectionSubData@@@Z ; std::allocator<VoteSelectionSubData>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UVoteSelectionSubData@@@std@@QAEXPAUVoteSelectionSubData@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UVoteSelectionSubData@@@std@@QAEXPAUVoteSelectionSubData@@@Z PROC ; std::allocator<VoteSelectionSubData>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	add	ecx, 16					; 00000010H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 161  : 		}

	ret	4
?destroy@?$allocator@UVoteSelectionSubData@@@std@@QAEXPAUVoteSelectionSubData@@@Z ENDP ; std::allocator<VoteSelectionSubData>::destroy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUPlotExtraYield@@@Z ; operator<<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvstructs.cpp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUPlotExtraYield@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUPlotExtraYield@@@Z PROC	; operator<<, COMDAT

; 659  : {

	push	esi

; 660  : 	saveTo << readFrom.m_iX;

	mov	esi, DWORD PTR _saveTo$[esp]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 661  : 	saveTo << readFrom.m_iY;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 662  : 	saveTo << readFrom.m_aeExtraYield;

	add	edi, 8
	push	edi
	push	esi
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator<<<int>
	add	esp, 8
	pop	edi

; 663  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 664  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUPlotExtraYield@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??$fill@PAUVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@0ABU1@@Z ; std::fill<VoteSelectionSubData *,VoteSelectionSubData>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@0ABU1@@Z PROC ; std::fill<VoteSelectionSubData *,VoteSelectionSubData>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	jmp	??$_Fill@PAUVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@0ABU1@@Z ; std::_Fill<VoteSelectionSubData *,VoteSelectionSubData>
??$fill@PAUVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@0ABU1@@Z ENDP ; std::fill<VoteSelectionSubData *,VoteSelectionSubData>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUVoteSelectionSubData@@PAU1@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00@Z ; stdext::_Unchecked_move_backward<VoteSelectionSubData *,VoteSelectionSubData *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAUVoteSelectionSubData@@PAU1@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00@Z
_TEXT	SEGMENT
$T220809 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$220813 = 16					; size = 1
$T220791 = 16						; size = 1
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUVoteSelectionSubData@@PAU1@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<VoteSelectionSubData *,VoteSelectionSubData *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$220813[esp]
	mov	edx, DWORD PTR $T220791[esp]
	mov	BYTE PTR $T220809[esp+4], 0
	mov	eax, DWORD PTR $T220809[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAUVoteSelectionSubData@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<VoteSelectionSubData *,VoteSelectionSubData *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAUVoteSelectionSubData@@PAU1@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<VoteSelectionSubData *,VoteSelectionSubData *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<VoteSelectionSubData *,unsigned int,VoteSelectionSubData,std::allocator<VoteSelectionSubData> >
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$7
__unwindtable$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T220865 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$220862 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<VoteSelectionSubData *,unsigned int,VoteSelectionSubData,std::allocator<VoteSelectionSubData> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN

	mov	ebx, DWORD PTR __Count$[ebp]
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	push	edi
	mov	edi, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LL6@Uninit_fil:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	test	ebx, ebx
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$220862[ebp], esi
	mov	DWORD PTR $T220865[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN18@Uninit_fil
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	lea	edx, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR [esi+16]
	push	edx
	mov	DWORD PTR [esi+12], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN18@Uninit_fil:
	dec	ebx
	add	esi, 44					; 0000002cH
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil
__catch$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil
$LL3@Uninit_fil:
	lea	ecx, DWORD PTR [esi+16]

; 407  : 		_Al.destroy(_Next);

	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 44					; 0000002cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN48@Uninit_fil:
$LN4@Uninit_fil:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@Uninit_fil:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$220862[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220865[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<VoteSelectionSubData *,unsigned int,VoteSelectionSubData,std::allocator<VoteSelectionSubData> >
PUBLIC	??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$7
__unwindtable$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T220975 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Vptr$220972 = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_cop@2:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$220972[ebp], esi
	mov	DWORD PTR $T220975[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@2
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	lea	edx, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR [esi+16]
	push	edx
	mov	DWORD PTR [esi+12], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN18@Uninit_cop@2:
	add	esi, 44					; 0000002cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 44					; 0000002cH
	jmp	SHORT $LL6@Uninit_cop@2
__catch$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@2
	npad	2
$LL3@Uninit_cop@2:
	lea	ecx, DWORD PTR [esi+16]

; 134  : 		_Al.destroy(_Next);

	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 44					; 0000002cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN48@Uninit_cop@2:
$LN4@Uninit_cop@2:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@Uninit_cop@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$220972[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220975[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@0AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<VoteSelectionSubData> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@0AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@0AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<VoteSelectionSubData> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra
	npad	2
$LL3@Destroy_ra:
	lea	ecx, DWORD PTR [esi+16]

; 234  : 		_Al.destroy(_First);

	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 44					; 0000002cH
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra
$LN1@Destroy_ra:
	pop	edi
	pop	esi

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@0AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<VoteSelectionSubData> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@2
	pop	esi
$LN9@Uninit_fil@2:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@stdext@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<VoteSelectionSubData *,unsigned int,VoteSelectionSubData,std::allocator<VoteSelectionSubData> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@stdext@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@std@@@Z
_TEXT	SEGMENT
$T221277 = -4						; size = 1
__Cat$221282 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@stdext@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<VoteSelectionSubData *,unsigned int,VoteSelectionSubData,std::allocator<VoteSelectionSubData> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T221277[esp+4], 0
	mov	eax, DWORD PTR $T221277[esp+4]
	mov	ecx, DWORD PTR __Cat$221282[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<VoteSelectionSubData *,unsigned int,VoteSelectionSubData,std::allocator<VoteSelectionSubData> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@stdext@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<VoteSelectionSubData *,unsigned int,VoteSelectionSubData,std::allocator<VoteSelectionSubData> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@std@@@Z ; stdext::unchecked_uninitialized_copy<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@std@@@Z
_TEXT	SEGMENT
$T221286 = -4						; size = 1
__Cat$221291 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T221286[esp+4], 0
	mov	eax, DWORD PTR $T221286[esp+4]
	mov	ecx, DWORD PTR __Cat$221291[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@0AAV?$allocator@UVoteSelectionSubData@@@0@@Z ; std::_Destroy_range<std::allocator<VoteSelectionSubData> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@0AAV?$allocator@UVoteSelectionSubData@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@0AAV?$allocator@UVoteSelectionSubData@@@0@@Z PROC ; std::_Destroy_range<std::allocator<VoteSelectionSubData> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	esi

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@2
	npad	2
$LL7@Destroy_ra@2:
	lea	ecx, DWORD PTR [esi+16]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 44					; 0000002cH
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@2
$LN5@Destroy_ra@2:
	pop	edi
	pop	esi

; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@0AAV?$allocator@UVoteSelectionSubData@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<VoteSelectionSubData> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@4
	pop	esi
$LN13@unchecked_@4:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEPAUVoteSelectionSubData@@PAU3@IABU3@@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEPAUVoteSelectionSubData@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T221688 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$221692 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEPAUVoteSelectionSubData@@PAU3@IABU3@@Z PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$221692[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T221688[esp+12], 0
	mov	eax, DWORD PTR $T221688[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<VoteSelectionSubData *,unsigned int,VoteSelectionSubData,std::allocator<VoteSelectionSubData> >

; 1255 : 		return (_Ptr + _Count);

	mov	eax, esi
	imul	eax, 44					; 0000002cH
	add	esp, 24					; 00000018H
	add	eax, edi
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEPAUVoteSelectionSubData@@PAU3@IABU3@@Z ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@U_Undefined_move_tag@3@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@U_Undefined_move_tag@3@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T221705 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$221709 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@U_Undefined_move_tag@3@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$221709[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T221705[esp+4], 0
	mov	eax, DWORD PTR $T221705[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@U_Undefined_move_tag@3@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXPAUVoteSelectionSubData@@0@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXPAUVoteSelectionSubData@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXPAUVoteSelectionSubData@@0@Z PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN7@Destroy
	npad	2
$LL9@Destroy:
	lea	ecx, DWORD PTR [esi+16]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 44					; 0000002cH
	cmp	esi, edi
	jne	SHORT $LL9@Destroy
$LN7@Destroy:
	pop	edi
	pop	esi

; 1120 : 		}

	ret	8
?_Destroy@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXPAUVoteSelectionSubData@@0@Z ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$215406 = 16					; size = 4
__Tmp$215396 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$215396[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215396[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215396[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$215406[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@std@@@Z
_TEXT	SEGMENT
$T222027 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$222030 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$222030[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T222027[esp+4], 0
	mov	eax, DWORD PTR $T222027[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??$_Umove@PAUVoteSelectionSubData@@@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEPAUVoteSelectionSubData@@PAU2@00@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Umove<VoteSelectionSubData *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAUVoteSelectionSubData@@@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEPAUVoteSelectionSubData@@PAU2@00@Z
_TEXT	SEGMENT
$T222144 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$222147 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUVoteSelectionSubData@@@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEPAUVoteSelectionSubData@@PAU2@00@Z PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Umove<VoteSelectionSubData *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$222147[esp]
	mov	BYTE PTR $T222144[esp+4], 0
	mov	eax, DWORD PTR $T222144[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUVoteSelectionSubData@@@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEPAUVoteSelectionSubData@@PAU2@00@Z ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Umove<VoteSelectionSubData *>
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back
	xor	eax, eax
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Insert_n
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z$2
__catchsym$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z$10
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z$11
__unwindtable$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z
_TEXT	SEGMENT
__Tmp$218480 = -120					; size = 44
__Tmp$218470 = -76					; size = 44
_this$ = -32						; size = 4
__Whereoff$218456 = -28					; size = 4
__Ncopied$218457 = -24					; size = 4
__Newvec$218455 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$222606 = 8					; size = 1
__Cat$222534 = 8					; size = 1
__Where$ = 8						; size = 4
tv559 = 12						; size = 4
__Count$ = 12						; size = 4
$T222602 = 16						; size = 1
$T222530 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	eax, eax
	jne	SHORT $LN31@Insert_n@2
	xor	ebx, ebx
	jmp	SHORT $LN32@Insert_n@2
$LN31@Insert_n@2:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, 780903145				; 2e8ba2e9H
	imul	ecx
	sar	edx, 3
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
$LN32@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@2

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, ecx
	sub	edx, DWORD PTR [esi+4]
	mov	eax, 780903145				; 2e8ba2e9H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, 97612893				; 05d1745dH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@KAXXZ ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Xlen
$LN107@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ebx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ebx
	shr	eax, 1
	mov	ecx, 97612893				; 05d1745dH
	sub	ecx, eax
	cmp	ecx, ebx
	jae	SHORT $LN17@Insert_n@2
	xor	ebx, ebx
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ebx, eax
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ebx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	ebx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ebx
	call	??$_Allocate@UVoteSelectionSubData@@@std@@YAPAUVoteSelectionSubData@@IPAU1@@Z ; std::_Allocate<VoteSelectionSubData>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 780903145				; 2e8ba2e9H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Whereoff$218456[ebp], eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	imul	eax, 44					; 0000002cH
	xor	edx, edx
	add	esp, 8
	mov	DWORD PTR __Ncopied$218457[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+12], edx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	add	eax, ecx
	push	edi
	mov	DWORD PTR __Newvec$218455[ebp], ecx
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEPAUVoteSelectionSubData@@PAU3@IABU3@@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$222534[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T222530[ebp], 0
	mov	ecx, DWORD PTR $T222530[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$218455[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	mov	DWORD PTR __Ncopied$218457[ebp], 1
	call	??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$218456[ebp]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR __Newvec$218455[ebp]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T222602[ebp], 0
	mov	edx, DWORD PTR $T222602[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$222606[ebp]
	push	edx
	push	esi
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$218457[ebp], 2
	call	??$_Uninit_copy@PAUVoteSelectionSubData@@PAU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAPAUVoteSelectionSubData@@PAU1@00AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<VoteSelectionSubData *,VoteSelectionSubData *,std::allocator<VoteSelectionSubData> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
	mov	eax, 780903145				; 2e8ba2e9H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	esp, 24					; 00000018H
	add	edi, eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1195 : 			if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $LN83@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	push	edx
	push	ecx
	mov	ecx, esi
	call	?_Destroy@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXPAUVoteSelectionSubData@@0@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN83@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Newvec$218455[ebp]
	imul	ebx, 44					; 0000002cH

; 1206 : 			_Mylast = _Newvec + _Count;

	imul	edi, 44					; 0000002cH
	add	ebx, eax
	add	edi, eax
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+8], edi

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$218457[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$218456[ebp]
	mov	edi, DWORD PTR __Newvec$218455[ebp]
	jle	SHORT $LN7@Insert_n@2
	mov	ecx, esi
	imul	ecx, 44					; 0000002cH
	add	ecx, edi
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	push	edi
	call	?_Destroy@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXPAUVoteSelectionSubData@@0@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Destroy
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [esi+edx]
	imul	esi, 44					; 0000002cH
	imul	eax, 44					; 0000002cH
	add	eax, edi
	push	eax
	add	esi, edi
	push	esi
	call	?_Destroy@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXPAUVoteSelectionSubData@@0@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Destroy
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN108@Insert_n@2:
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, 780903145				; 2e8ba2e9H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ecx, edi
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$218470[ebp]
	call	??0VoteSelectionSubData@@QAE@ABU0@@Z

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR [esi+8]
	mov	ebx, edi
	imul	ebx, 44					; 0000002cH
	lea	ecx, DWORD PTR [ebx+eax]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAUVoteSelectionSubData@@@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEPAUVoteSelectionSubData@@PAU2@00@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Umove<VoteSelectionSubData *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, ecx
	sub	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR __Tmp$218470[ebp]
	push	eax
	mov	eax, 780903145				; 2e8ba2e9H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEPAUVoteSelectionSubData@@PAU3@IABU3@@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$218470[ebp]
	push	ecx
	sub	esi, ebx
	push	esi
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Fill@PAUVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@0ABU1@@Z ; std::_Fill<VoteSelectionSubData *,VoteSelectionSubData>
	add	esp, 12					; 0000000cH

; 1232 : 			}

	lea	ecx, DWORD PTR __Tmp$218470[ebp+16]

; 1233 : 		else

	jmp	SHORT $LN106@Insert_n@2
__catch$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, 44					; 0000002cH
	mov	edx, DWORD PTR [ecx+8]
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXPAUVoteSelectionSubData@@0@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN109@Insert_n@2:
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$218480[ebp]
	call	??0VoteSelectionSubData@@QAE@ABU0@@Z

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	imul	edi, 44					; 0000002cH
	mov	ebx, DWORD PTR [esi+8]
	push	ebx
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv559[ebp], eax
	call	??$_Umove@PAUVoteSelectionSubData@@@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEPAUVoteSelectionSubData@@PAU2@00@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Umove<VoteSelectionSubData *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv559[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAUVoteSelectionSubData@@PAU1@@stdext@@YAPAUVoteSelectionSubData@@PAU1@00@Z ; stdext::_Unchecked_move_backward<VoteSelectionSubData *,VoteSelectionSubData *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$218480[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	edi, eax
	push	edi
	push	eax
	call	??$_Fill@PAUVoteSelectionSubData@@U1@@std@@YAXPAUVoteSelectionSubData@@0ABU1@@Z ; std::_Fill<VoteSelectionSubData *,VoteSelectionSubData>
	add	esp, 24					; 00000018H

; 1249 : 			}

	lea	ecx, DWORD PTR __Tmp$218480[ebp+16]
$LN106@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@Insert_n@2:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN105@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$218470[ebp]
	jmp	??1VoteSelectionSubData@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$218480[ebp]
	jmp	??1VoteSelectionSubData@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Insert_n
PUBLIC	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_v$214336 = -4						; size = 4
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >, COMDAT

; 83   : {

	push	ecx
	push	ebx
	push	esi

; 84   : 	container.clear();

	mov	esi, DWORD PTR _container$[esp+8]
	mov	ecx, DWORD PTR [esi+8]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	cmp	edi, ecx
	je	SHORT $LN20@SerializeT
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebx, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN45@SerializeT
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN45@SerializeT:
	mov	DWORD PTR [esi+8], ebx
$LN20@SerializeT:

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	edi, DWORD PTR _loadFrom$[esp+12]
	lea	eax, DWORD PTR _count$[esp+12]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _count$[esp+16], 0
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	xor	ebx, ebx
	cmp	DWORD PTR _count$[esp+12], ebx
	jbe	SHORT $LN1@SerializeT
	push	ebp
$LL117@SerializeT:

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	ecx, DWORD PTR _v$214336[esp+20]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 92   : 		container.push_back(v);

	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	jne	SHORT $LN60@SerializeT
	xor	eax, eax
	jmp	SHORT $LN61@SerializeT
$LN60@SerializeT:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
$LN61@SerializeT:
	mov	ecx, DWORD PTR [esi+8]
	mov	ebp, ecx
	sub	ebp, edx
	sar	ebp, 2
	cmp	ebp, eax
	jae	SHORT $LN53@SerializeT
	mov	edx, DWORD PTR _v$214336[esp+20]
	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	mov	DWORD PTR [esi+8], ecx
	jmp	SHORT $LN2@SerializeT
$LN53@SerializeT:
	lea	eax, DWORD PTR _v$214336[esp+20]
	push	eax
	push	1
	push	ecx
	mov	ecx, esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
$LN2@SerializeT:
	inc	ebx
	cmp	ebx, DWORD PTR _count$[esp+16]
	jb	SHORT $LL117@SerializeT
	pop	ebp
$LN1@SerializeT:
	pop	edi
	pop	esi
	pop	ebx

; 93   : 	}
; 94   : }

	pop	ecx
	ret	0
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	?insert@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@V?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@ABUVoteSelectionSubData@@@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@V?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@ABUVoteSelectionSubData@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@V?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@ABUVoteSelectionSubData@@@Z PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 780903145				; 2e8ba2e9H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 780903145				; 2e8ba2e9H
	imul	ecx
	sar	edx, 3
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@IAEXV?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@IABUVoteSelectionSubData@@@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::_Insert_n

; 878  : 		return (begin() + _Off);

	imul	esi, 44					; 0000002cH
	add	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@V?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@ABUVoteSelectionSubData@@@Z ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::insert
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; operator>><int>, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUPlotExtraYield@@@Z ; operator>>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvstructs.cpp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUPlotExtraYield@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUPlotExtraYield@@@Z PROC	; operator>>, COMDAT

; 667  : {

	push	esi

; 668  : 	loadFrom >> writeTo.m_iX;

	mov	esi, DWORD PTR _loadFrom$[esp]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 669  : 	loadFrom >> writeTo.m_iY;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 670  : 	loadFrom >> writeTo.m_aeExtraYield;

	add	edi, 8
	push	edi
	push	esi
	call	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
	add	esp, 8
	pop	edi

; 671  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 672  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUPlotExtraYield@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEXABUVoteSelectionSubData@@@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEXABUVoteSelectionSubData@@@Z
_TEXT	SEGMENT
$T223325 = -4						; size = 1
__Cat$223329 = 8					; size = 1
$T223296 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEXABUVoteSelectionSubData@@@Z PROC ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@2
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@2
$LN9@push_back@2:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 780903145				; 2e8ba2e9H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@2:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 780903145				; 2e8ba2e9H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$223329[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T223325[esp+16], 0
	mov	ecx, DWORD PTR $T223325[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUVoteSelectionSubData@@IU1@V?$allocator@UVoteSelectionSubData@@@std@@@std@@YAXPAUVoteSelectionSubData@@IABU1@AAV?$allocator@UVoteSelectionSubData@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<VoteSelectionSubData *,unsigned int,VoteSelectionSubData,std::allocator<VoteSelectionSubData> >
	add	esp, 24					; 00000018H
	add	edi, 44					; 0000002cH
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@2:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T223296[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAE?AV?$_Vector_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@V?$_Vector_const_iterator@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@2@ABUVoteSelectionSubData@@@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEXABUVoteSelectionSubData@@@Z ENDP ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::push_back
_TEXT	ENDS
PUBLIC	?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z	; VoteSelectionData::read
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z$0
__ehfuncinfo$?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvstructs.cpp
xdata$x	ENDS
;	COMDAT ?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -60					; size = 4
_kData$217774 = -56					; size = 44
__$EHRec$ = -12						; size = 12
_iSize$ = 8						; size = 4
_kStream$ = 8						; size = 4
?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z PROC	; VoteSelectionData::read, COMDAT
; _this$ = ecx

; 34   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi

; 35   : 	// Version number to maintain backwards compatibility
; 36   : 	uint uiVersion;
; 37   : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+64]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+72]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 38   : 
; 39   : 	kStream >> iId;

	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 40   : 	kStream >> eVoteSource;

	lea	ecx, DWORD PTR [edi+4]
	push	ecx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4VoteSourceTypes@@@Z ; operator>>
	add	esp, 8

; 41   : 	size_t iSize;
; 42   : 	kStream >> iSize;

	lea	edx, DWORD PTR _iSize$[esp+68]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 43   : 	size_t i = 0;
; 44   : 	for(i = 0; i < iSize; ++i)

	xor	ebx, ebx
	cmp	DWORD PTR _iSize$[esp+68], ebx
	jbe	$LN1@read
	push	ebp
	lea	ebp, DWORD PTR [edi+8]
	or	edi, -1
$LL3@read:

; 45   : 	{
; 46   : 		VoteSelectionSubData kData;

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _kData$217774[esp+96]
	mov	DWORD PTR _kData$217774[esp+80], edi
	mov	DWORD PTR _kData$217774[esp+84], edi
	mov	DWORD PTR _kData$217774[esp+88], edi
	mov	DWORD PTR _kData$217774[esp+92], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 47   : 		kStream >> kData.eVote;

	lea	eax, DWORD PTR _kData$217774[esp+76]
	push	eax
	push	esi
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	??5@YAAAVFDataStream@@AAV0@AAW4VoteTypes@@@Z ; operator>>

; 48   : 		kStream >> kData.ePlayer;

	lea	ecx, DWORD PTR _kData$217774[esp+88]
	push	ecx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 16					; 00000010H

; 49   : 		kStream >> kData.iCityId;

	lea	edx, DWORD PTR _kData$217774[esp+84]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 50   : 		kStream >> kData.eOtherPlayer;

	lea	eax, DWORD PTR _kData$217774[esp+88]
	push	eax
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 51   : 		kStream >> kData.strText;

	lea	ecx, DWORD PTR _kData$217774[esp+92]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 52   : 		aVoteOptions.push_back(kData);

	lea	edx, DWORD PTR _kData$217774[esp+76]
	push	edx
	mov	ecx, ebp
	call	?push_back@?$vector@UVoteSelectionSubData@@V?$allocator@UVoteSelectionSubData@@@std@@@std@@QAEXABUVoteSelectionSubData@@@Z ; std::vector<VoteSelectionSubData,std::allocator<VoteSelectionSubData> >::push_back

; 53   : 	}

	lea	ecx, DWORD PTR _kData$217774[esp+92]
	mov	DWORD PTR __$EHRec$[esp+84], edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	inc	ebx
	cmp	ebx, DWORD PTR _iSize$[esp+72]
	jb	$LL3@read
	pop	ebp
$LN1@read:

; 54   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 60					; 0000003cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _kData$217774[ebp]
	jmp	??1VoteSelectionSubData@@QAE@XZ
__ehhandler$?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z ENDP	; VoteSelectionData::read
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUVoteSelectionData@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUVoteSelectionData@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUVoteSelectionData@@@Z PROC ; operator>>, COMDAT

; 57   : 	writeTo.read(loadFrom);

	mov	ecx, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	esi
	call	?read@VoteSelectionData@@QAEXAAVFDataStream@@@Z ; VoteSelectionData::read

; 58   : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 59   : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUVoteSelectionData@@@Z ENDP ; operator>>
_TEXT	ENDS
END
