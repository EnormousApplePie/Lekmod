; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvCityCitizens.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG225437 DB	'ECONOMICAISTRATEGY_LOSING_MONEY', 00H
$SG225446 DB	'AIGRANDSTRATEGY_CULTURE', 00H
$SG226122 DB	'UNITCLASS_SCIENTIST', 00H
$SG226126 DB	'UNITCLASS_WRITER', 00H
	ORG $+3
$SG226131 DB	'UNITCLASS_ARTIST', 00H
	ORG $+3
$SG226136 DB	'UNITCLASS_MUSICIAN', 00H
	ORG $+1
$SG226143 DB	'UNITCLASS_MERCHANT', 00H
	ORG $+1
$SG226147 DB	'UNITCLASS_ENGINEER', 00H
	ORG $+1
$SG226390 DB	'UNITCLASS_WRITER', 00H
	ORG $+3
$SG226393 DB	'UNITCLASS_ARTIST', 00H
	ORG $+3
$SG226396 DB	'UNITCLASS_MUSICIAN', 00H
	ORG $+1
$SG226399 DB	'UNITCLASS_SCIENTIST', 00H
$SG226402 DB	'UNITCLASS_ENGINEER', 00H
	ORG $+1
$SG226405 DB	'UNITCLASS_MERCHANT', 00H
	ORG $+1
$SG226427 DB	'UNITCLASS_WRITER', 00H
	ORG $+3
$SG226430 DB	'UNITCLASS_ARTIST', 00H
	ORG $+3
$SG226433 DB	'UNITCLASS_MUSICIAN', 00H
	ORG $+1
$SG226436 DB	'UNITCLASS_SCIENTIST', 00H
$SG226439 DB	'UNITCLASS_ENGINEER', 00H
	ORG $+1
$SG226442 DB	'UNITCLASS_MERCHANT', 00H
	ORG $+1
$SG226445 DB	'UNITCLASS_PROPHET', 00H
	ORG $+2
$SG226457 DB	'UNIT_ARTIST', 00H
$SG226461 DB	'TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER', 00H
$SG226464 DB	'TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	??0CvCityCitizens@@QAE@XZ			; CvCityCitizens::CvCityCitizens
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitycitizens.cpp
;	COMDAT ??0CvCityCitizens@@QAE@XZ
_TEXT	SEGMENT
??0CvCityCitizens@@QAE@XZ PROC				; CvCityCitizens::CvCityCitizens, COMDAT
; _this$ = ecx

; 33   : {

	mov	eax, ecx

; 34   : #endif
; 35   : 	m_aiSpecialistCounts = NULL;

	xor	ecx, ecx
	mov	DWORD PTR [eax+108], ecx

; 36   : 	m_aiSpecialistGreatPersonProgressTimes100 = NULL;

	mov	DWORD PTR [eax+112], ecx

; 37   : 	m_aiNumSpecialistsInBuilding = NULL;

	mov	DWORD PTR [eax+116], ecx

; 38   : 	m_aiNumForcedSpecialistsInBuilding = NULL;

	mov	DWORD PTR [eax+120], ecx

; 39   : 	m_piBuildingGreatPeopleRateChanges = NULL;

	mov	DWORD PTR [eax+124], ecx

; 40   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 41   : 	m_aiCachedGPChangeT100ForThisTurn = NULL;
; 42   : #endif
; 43   : }

	ret	0
??0CvCityCitizens@@QAE@XZ ENDP				; CvCityCitizens::CvCityCitizens
_TEXT	ENDS
PUBLIC	?Reset@CvCityCitizens@@QAEXXZ			; CvCityCitizens::Reset
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?getNumSpecialistInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumSpecialistInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvCityCitizens@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvCityCitizens@@QAEXXZ PROC			; CvCityCitizens::Reset, COMDAT
; _this$ = ecx

; 81   : {

	push	ebx

; 82   : 	m_bAutomated = false;

	xor	ebx, ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	BYTE PTR [esi+4], bl

; 83   : 	m_bNoAutoAssignSpecialists = false;

	mov	BYTE PTR [esi+5], bl

; 84   : 	m_iNumUnassignedCitizens = 0;

	mov	DWORD PTR [esi+8], ebx

; 85   : 	m_iNumCitizensWorkingPlots = 0;

	mov	DWORD PTR [esi+12], ebx

; 86   : 	m_iNumForcedWorkingPlots = 0;

	mov	DWORD PTR [esi+16], ebx

; 87   : 
; 88   : 	m_eCityAIFocusTypes = NO_CITY_AI_FOCUS_TYPE;

	mov	DWORD PTR [esi+20], -1
	lea	eax, DWORD PTR [esi+62]
	mov	ecx, 37					; 00000025H
$LL18@Reset:

; 89   : 
; 90   : #ifdef AUI_WARNING_FIXES
; 91   : 	uint iI;
; 92   : #else
; 93   : 	int iI;
; 94   : #endif
; 95   : 
; 96   : 	CvAssertMsg((0 < NUM_CITY_PLOTS),  "NUM_CITY_PLOTS is not greater than zero but an array is being allocated in CvCityCitizens::reset");
; 97   : 	for(iI = 0; iI < NUM_CITY_PLOTS; iI++)
; 98   : 	{
; 99   : 		m_pabWorkingPlot[iI] = false;

	mov	BYTE PTR [eax-37], bl

; 100  : 		m_pabForcedWorkingPlot[iI] = false;

	mov	BYTE PTR [eax], bl
	inc	eax
	sub	ecx, 1
	jne	SHORT $LL18@Reset

; 101  : 	}
; 102  : 
; 103  : 	m_iNumDefaultSpecialists = 0;
; 104  : 	m_iNumForcedDefaultSpecialists = 0;
; 105  : 
; 106  : 	CvAssertMsg(m_aiSpecialistCounts==NULL, "about to leak memory, CvCityCitizens::m_aiSpecialistCounts");
; 107  : #ifdef AUI_WARNING_FIXES
; 108  : 	SAFE_DELETE_ARRAY(m_aiSpecialistCounts);
; 109  : #endif
; 110  : 	m_aiSpecialistCounts = FNEW(int[GC.getNumSpecialistInfos()], c_eCiv5GameplayDLL, 0);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+100], ebx
	mov	DWORD PTR [esi+104], ebx
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 111  : 	for(iI = 0; iI < GC.getNumSpecialistInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+108], eax
	xor	edi, edi
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	test	eax, eax
	jle	SHORT $LN13@Reset
	npad	4
$LL15@Reset:

; 112  : 	{
; 113  : 		m_aiSpecialistCounts[iI] = 0;

	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [eax+edi*4], ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	cmp	edi, eax
	jl	SHORT $LL15@Reset
$LN13@Reset:

; 114  : 	}
; 115  : 
; 116  : 	CvAssertMsg(m_aiSpecialistGreatPersonProgressTimes100==NULL, "about to leak memory, CvCityCitizens::m_aiSpecialistGreatPersonProgressTimes100");
; 117  : #ifdef AUI_WARNING_FIXES
; 118  : 	SAFE_DELETE_ARRAY(m_aiSpecialistGreatPersonProgressTimes100);
; 119  : #endif
; 120  : 	m_aiSpecialistGreatPersonProgressTimes100 = FNEW(int[GC.getNumSpecialistInfos()], c_eCiv5GameplayDLL, 0);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 121  : 	for(iI = 0; iI < GC.getNumSpecialistInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+112], eax
	xor	edi, edi
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	test	eax, eax
	jle	SHORT $LN10@Reset
	npad	5
$LL12@Reset:

; 122  : 	{
; 123  : 		m_aiSpecialistGreatPersonProgressTimes100[iI] = 0;

	mov	eax, DWORD PTR [esi+112]
	mov	DWORD PTR [eax+edi*4], ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	cmp	edi, eax
	jl	SHORT $LL12@Reset
$LN10@Reset:

; 124  : 	}
; 125  : 
; 126  : 	CvAssertMsg(m_aiNumSpecialistsInBuilding==NULL, "about to leak memory, CvCityCitizens::m_aiNumSpecialistsInBuilding");
; 127  : #ifdef AUI_WARNING_FIXES
; 128  : 	SAFE_DELETE_ARRAY(m_aiNumSpecialistsInBuilding);
; 129  : #endif
; 130  : 	m_aiNumSpecialistsInBuilding = FNEW(int[GC.getNumBuildingInfos()], c_eCiv5GameplayDLL, 0);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 131  : 	for(iI = 0; iI < GC.getNumBuildingInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+116], eax
	xor	edi, edi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	SHORT $LN7@Reset
	npad	5
$LL9@Reset:

; 132  : 	{
; 133  : 		m_aiNumSpecialistsInBuilding[iI] = 0;

	mov	eax, DWORD PTR [esi+116]
	mov	DWORD PTR [eax+edi*4], ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	edi, eax
	jl	SHORT $LL9@Reset
$LN7@Reset:

; 134  : 	}
; 135  : 
; 136  : 	CvAssertMsg(m_aiNumForcedSpecialistsInBuilding==NULL, "about to leak memory, CvCityCitizens::m_aiNumForcedSpecialistsInBuilding");
; 137  : #ifdef AUI_WARNING_FIXES
; 138  : 	SAFE_DELETE_ARRAY(m_aiNumForcedSpecialistsInBuilding);
; 139  : #endif
; 140  : 	m_aiNumForcedSpecialistsInBuilding = FNEW(int[GC.getNumBuildingInfos()], c_eCiv5GameplayDLL, 0);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 141  : 	for(iI = 0; iI < GC.getNumBuildingInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+120], eax
	xor	edi, edi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	SHORT $LN4@Reset
	npad	5
$LL6@Reset:

; 142  : 	{
; 143  : 		m_aiNumForcedSpecialistsInBuilding[iI] = 0;

	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [eax+edi*4], ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	edi, eax
	jl	SHORT $LL6@Reset
$LN4@Reset:

; 144  : 	}
; 145  : 
; 146  : 	CvAssertMsg(m_piBuildingGreatPeopleRateChanges==NULL, "about to leak memory, CvCityCitizens::m_piBuildingGreatPeopleRateChanges");
; 147  : #ifdef AUI_WARNING_FIXES
; 148  : 	SAFE_DELETE_ARRAY(m_piBuildingGreatPeopleRateChanges);
; 149  : #endif
; 150  : 	m_piBuildingGreatPeopleRateChanges = FNEW(int[GC.getNumSpecialistInfos()], c_eCiv5GameplayDLL, 0);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 151  : 	for(iI = 0; iI < GC.getNumSpecialistInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+124], eax
	xor	edi, edi
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	test	eax, eax
	jle	SHORT $LN33@Reset
	npad	5
$LL3@Reset:

; 152  : 	{
; 153  : 		m_piBuildingGreatPeopleRateChanges[iI] = 0;

	mov	eax, DWORD PTR [esi+124]
	mov	DWORD PTR [eax+edi*4], ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	cmp	edi, eax
	jl	SHORT $LL3@Reset
$LN33@Reset:
	pop	edi

; 154  : 	}
; 155  : 
; 156  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 157  : 	SAFE_DELETE_ARRAY(m_aiCachedGPChangeT100ForThisTurn);
; 158  : 	m_aiCachedGPChangeT100ForThisTurn = FNEW(int[GC.getNumSpecialistInfos()], c_eCiv5GameplayDLL, 0);
; 159  : 	for (iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
; 160  : 	{
; 161  : 		m_aiCachedGPChangeT100ForThisTurn[iI] = 0;
; 162  : 	}
; 163  : #endif
; 164  : 
; 165  : 	m_bForceAvoidGrowth = false;

	mov	BYTE PTR [esi+24], bl
	pop	esi
	pop	ebx

; 166  : #ifdef AUI_CITIZENS_FOOD_PRODUCTION_TRIAL_RUN_THEN_SELF_CONSISTENCY
; 167  : 	m_bIgnoreFoodProduction = true;
; 168  : #endif
; 169  : }

	ret	0
?Reset@CvCityCitizens@@QAEXXZ ENDP			; CvCityCitizens::Reset
_TEXT	ENDS
PUBLIC	?GetCity@CvCityCitizens@@QAEPAVCvCity@@XZ	; CvCityCitizens::GetCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetCity@CvCityCitizens@@QAEPAVCvCity@@XZ
_TEXT	SEGMENT
?GetCity@CvCityCitizens@@QAEPAVCvCity@@XZ PROC		; CvCityCitizens::GetCity, COMDAT
; _this$ = ecx

; 242  : 	return m_pCity;

	mov	eax, DWORD PTR [ecx]

; 243  : }

	ret	0
?GetCity@CvCityCitizens@@QAEPAVCvCity@@XZ ENDP		; CvCityCitizens::GetCity
_TEXT	ENDS
PUBLIC	?GetTeam@CvCityCitizens@@QBE?AW4TeamTypes@@XZ	; CvCityCitizens::GetTeam
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?GetTeam@CvCityCitizens@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?GetTeam@CvCityCitizens@@QBE?AW4TeamTypes@@XZ PROC	; CvCityCitizens::GetTeam, COMDAT
; _this$ = ecx

; 264  : 	return m_pCity->getTeam();

	mov	ecx, DWORD PTR [ecx]
	jmp	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
?GetTeam@CvCityCitizens@@QBE?AW4TeamTypes@@XZ ENDP	; CvCityCitizens::GetTeam
_TEXT	ENDS
PUBLIC	?IsAutomated@CvCityCitizens@@QBE_NXZ		; CvCityCitizens::IsAutomated
; Function compile flags: /Ogtpy
;	COMDAT ?IsAutomated@CvCityCitizens@@QBE_NXZ
_TEXT	SEGMENT
?IsAutomated@CvCityCitizens@@QBE_NXZ PROC		; CvCityCitizens::IsAutomated, COMDAT
; _this$ = ecx

; 731  : 	return m_bAutomated;

	mov	al, BYTE PTR [ecx+4]

; 732  : }

	ret	0
?IsAutomated@CvCityCitizens@@QBE_NXZ ENDP		; CvCityCitizens::IsAutomated
_TEXT	ENDS
PUBLIC	?SetAutomated@CvCityCitizens@@QAEX_N@Z		; CvCityCitizens::SetAutomated
; Function compile flags: /Ogtpy
;	COMDAT ?SetAutomated@CvCityCitizens@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetAutomated@CvCityCitizens@@QAEX_N@Z PROC		; CvCityCitizens::SetAutomated, COMDAT
; _this$ = ecx

; 737  : 	m_bAutomated = bValue;

	mov	al, BYTE PTR _bValue$[esp-4]
	mov	BYTE PTR [ecx+4], al

; 738  : }

	ret	4
?SetAutomated@CvCityCitizens@@QAEX_N@Z ENDP		; CvCityCitizens::SetAutomated
_TEXT	ENDS
PUBLIC	?IsNoAutoAssignSpecialists@CvCityCitizens@@QBE_NXZ ; CvCityCitizens::IsNoAutoAssignSpecialists
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoAutoAssignSpecialists@CvCityCitizens@@QBE_NXZ
_TEXT	SEGMENT
?IsNoAutoAssignSpecialists@CvCityCitizens@@QBE_NXZ PROC	; CvCityCitizens::IsNoAutoAssignSpecialists, COMDAT
; _this$ = ecx

; 743  : 	return m_bNoAutoAssignSpecialists;

	mov	al, BYTE PTR [ecx+5]

; 744  : }

	ret	0
?IsNoAutoAssignSpecialists@CvCityCitizens@@QBE_NXZ ENDP	; CvCityCitizens::IsNoAutoAssignSpecialists
_TEXT	ENDS
PUBLIC	?IsForcedAvoidGrowth@CvCityCitizens@@QAE_NXZ	; CvCityCitizens::IsForcedAvoidGrowth
; Function compile flags: /Ogtpy
;	COMDAT ?IsForcedAvoidGrowth@CvCityCitizens@@QAE_NXZ
_TEXT	SEGMENT
?IsForcedAvoidGrowth@CvCityCitizens@@QAE_NXZ PROC	; CvCityCitizens::IsForcedAvoidGrowth, COMDAT
; _this$ = ecx

; 839  : 	return m_bForceAvoidGrowth;

	mov	al, BYTE PTR [ecx+24]

; 840  : }

	ret	0
?IsForcedAvoidGrowth@CvCityCitizens@@QAE_NXZ ENDP	; CvCityCitizens::IsForcedAvoidGrowth
_TEXT	ENDS
PUBLIC	?GetFocusType@CvCityCitizens@@QBE?AW4CityAIFocusTypes@@XZ ; CvCityCitizens::GetFocusType
; Function compile flags: /Ogtpy
;	COMDAT ?GetFocusType@CvCityCitizens@@QBE?AW4CityAIFocusTypes@@XZ
_TEXT	SEGMENT
?GetFocusType@CvCityCitizens@@QBE?AW4CityAIFocusTypes@@XZ PROC ; CvCityCitizens::GetFocusType, COMDAT
; _this$ = ecx

; 854  : 	return m_eCityAIFocusTypes;

	mov	eax, DWORD PTR [ecx+20]

; 855  : }

	ret	0
?GetFocusType@CvCityCitizens@@QBE?AW4CityAIFocusTypes@@XZ ENDP ; CvCityCitizens::GetFocusType
_TEXT	ENDS
PUBLIC	?GetNumUnassignedCitizens@CvCityCitizens@@QBEHXZ ; CvCityCitizens::GetNumUnassignedCitizens
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumUnassignedCitizens@CvCityCitizens@@QBEHXZ
_TEXT	SEGMENT
?GetNumUnassignedCitizens@CvCityCitizens@@QBEHXZ PROC	; CvCityCitizens::GetNumUnassignedCitizens, COMDAT
; _this$ = ecx

; 1861 : 	return m_iNumUnassignedCitizens;

	mov	eax, DWORD PTR [ecx+8]

; 1862 : }

	ret	0
?GetNumUnassignedCitizens@CvCityCitizens@@QBEHXZ ENDP	; CvCityCitizens::GetNumUnassignedCitizens
_TEXT	ENDS
PUBLIC	?ChangeNumUnassignedCitizens@CvCityCitizens@@QAEXH@Z ; CvCityCitizens::ChangeNumUnassignedCitizens
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumUnassignedCitizens@CvCityCitizens@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeNumUnassignedCitizens@CvCityCitizens@@QAEXH@Z PROC ; CvCityCitizens::ChangeNumUnassignedCitizens, COMDAT
; _this$ = ecx

; 1867 : 	m_iNumUnassignedCitizens += iChange;

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+8], eax

; 1868 : 	CvAssert(m_iNumUnassignedCitizens >= 0);
; 1869 : }

	ret	4
?ChangeNumUnassignedCitizens@CvCityCitizens@@QAEXH@Z ENDP ; CvCityCitizens::ChangeNumUnassignedCitizens
_TEXT	ENDS
PUBLIC	?GetNumCitizensWorkingPlots@CvCityCitizens@@QBEHXZ ; CvCityCitizens::GetNumCitizensWorkingPlots
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCitizensWorkingPlots@CvCityCitizens@@QBEHXZ
_TEXT	SEGMENT
?GetNumCitizensWorkingPlots@CvCityCitizens@@QBEHXZ PROC	; CvCityCitizens::GetNumCitizensWorkingPlots, COMDAT
; _this$ = ecx

; 1874 : 	return m_iNumCitizensWorkingPlots;

	mov	eax, DWORD PTR [ecx+12]

; 1875 : }

	ret	0
?GetNumCitizensWorkingPlots@CvCityCitizens@@QBEHXZ ENDP	; CvCityCitizens::GetNumCitizensWorkingPlots
_TEXT	ENDS
PUBLIC	?ChangeNumCitizensWorkingPlots@CvCityCitizens@@QAEXH@Z ; CvCityCitizens::ChangeNumCitizensWorkingPlots
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumCitizensWorkingPlots@CvCityCitizens@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeNumCitizensWorkingPlots@CvCityCitizens@@QAEXH@Z PROC ; CvCityCitizens::ChangeNumCitizensWorkingPlots, COMDAT
; _this$ = ecx

; 1880 : 	m_iNumCitizensWorkingPlots += iChange;

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+12], eax

; 1881 : }

	ret	4
?ChangeNumCitizensWorkingPlots@CvCityCitizens@@QAEXH@Z ENDP ; CvCityCitizens::ChangeNumCitizensWorkingPlots
_TEXT	ENDS
PUBLIC	?GetNumForcedWorkingPlots@CvCityCitizens@@QBEHXZ ; CvCityCitizens::GetNumForcedWorkingPlots
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumForcedWorkingPlots@CvCityCitizens@@QBEHXZ
_TEXT	SEGMENT
?GetNumForcedWorkingPlots@CvCityCitizens@@QBEHXZ PROC	; CvCityCitizens::GetNumForcedWorkingPlots, COMDAT
; _this$ = ecx

; 2645 : #ifdef AUI_CITIZENS_FIX_LOCKED_TILES_BLOCKED
; 2646 : 	return m_iNumForcedWorkingPlots + GetNumForcedWorkingPlotsBlocked();
; 2647 : #else
; 2648 : 	return m_iNumForcedWorkingPlots;

	mov	eax, DWORD PTR [ecx+16]

; 2649 : #endif
; 2650 : }

	ret	0
?GetNumForcedWorkingPlots@CvCityCitizens@@QBEHXZ ENDP	; CvCityCitizens::GetNumForcedWorkingPlots
_TEXT	ENDS
PUBLIC	?ChangeNumForcedWorkingPlots@CvCityCitizens@@QAEXH@Z ; CvCityCitizens::ChangeNumForcedWorkingPlots
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumForcedWorkingPlots@CvCityCitizens@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeNumForcedWorkingPlots@CvCityCitizens@@QAEXH@Z PROC ; CvCityCitizens::ChangeNumForcedWorkingPlots, COMDAT
; _this$ = ecx

; 2655 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@ChangeNumF

; 2656 : 	{
; 2657 : 		m_iNumForcedWorkingPlots += iChange;

	add	DWORD PTR [ecx+16], eax
$LN1@ChangeNumF:

; 2658 : 	}
; 2659 : }

	ret	4
?ChangeNumForcedWorkingPlots@CvCityCitizens@@QAEXH@Z ENDP ; CvCityCitizens::ChangeNumForcedWorkingPlots
_TEXT	ENDS
PUBLIC	?GetCityIndexFromPlot@CvCityCitizens@@QBEHPBVCvPlot@@@Z ; CvCityCitizens::GetCityIndexFromPlot
EXTRN	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z:PROC	; plotCityXY
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityIndexFromPlot@CvCityCitizens@@QBEHPBVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?GetCityIndexFromPlot@CvCityCitizens@@QBEHPBVCvPlot@@@Z PROC ; CvCityCitizens::GetCityIndexFromPlot, COMDAT
; _this$ = ecx

; 2906 : 	return plotCityXY(m_pCity, pPlot);

	mov	eax, DWORD PTR _pPlot$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	ecx
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	add	esp, 8

; 2907 : }

	ret	4
?GetCityIndexFromPlot@CvCityCitizens@@QBEHPBVCvPlot@@@Z ENDP ; CvCityCitizens::GetCityIndexFromPlot
_TEXT	ENDS
PUBLIC	?GetNumSpecialistsAllowedByBuilding@CvCityCitizens@@QAEHABVCvBuildingEntry@@@Z ; CvCityCitizens::GetNumSpecialistsAllowedByBuilding
EXTRN	?GetSpecialistCount@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetSpecialistCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumSpecialistsAllowedByBuilding@CvCityCitizens@@QAEHABVCvBuildingEntry@@@Z
_TEXT	SEGMENT
_kBuilding$ = 8						; size = 4
?GetNumSpecialistsAllowedByBuilding@CvCityCitizens@@QAEHABVCvBuildingEntry@@@Z PROC ; CvCityCitizens::GetNumSpecialistsAllowedByBuilding, COMDAT
; _this$ = ecx

; 3152 : 	return kBuilding.GetSpecialistCount();

	mov	ecx, DWORD PTR _kBuilding$[esp-4]
	call	?GetSpecialistCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistCount

; 3153 : }

	ret	4
?GetNumSpecialistsAllowedByBuilding@CvCityCitizens@@QAEHABVCvBuildingEntry@@@Z ENDP ; CvCityCitizens::GetNumSpecialistsAllowedByBuilding
_TEXT	ENDS
PUBLIC	?GetNumDefaultSpecialists@CvCityCitizens@@QBEHXZ ; CvCityCitizens::GetNumDefaultSpecialists
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumDefaultSpecialists@CvCityCitizens@@QBEHXZ
_TEXT	SEGMENT
?GetNumDefaultSpecialists@CvCityCitizens@@QBEHXZ PROC	; CvCityCitizens::GetNumDefaultSpecialists, COMDAT
; _this$ = ecx

; 3447 : 	return m_iNumDefaultSpecialists;

	mov	eax, DWORD PTR [ecx+100]

; 3448 : }

	ret	0
?GetNumDefaultSpecialists@CvCityCitizens@@QBEHXZ ENDP	; CvCityCitizens::GetNumDefaultSpecialists
_TEXT	ENDS
PUBLIC	?GetNumForcedDefaultSpecialists@CvCityCitizens@@QBEHXZ ; CvCityCitizens::GetNumForcedDefaultSpecialists
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumForcedDefaultSpecialists@CvCityCitizens@@QBEHXZ
_TEXT	SEGMENT
?GetNumForcedDefaultSpecialists@CvCityCitizens@@QBEHXZ PROC ; CvCityCitizens::GetNumForcedDefaultSpecialists, COMDAT
; _this$ = ecx

; 3466 : 	return m_iNumForcedDefaultSpecialists;

	mov	eax, DWORD PTR [ecx+104]

; 3467 : }

	ret	0
?GetNumForcedDefaultSpecialists@CvCityCitizens@@QBEHXZ ENDP ; CvCityCitizens::GetNumForcedDefaultSpecialists
_TEXT	ENDS
PUBLIC	?ChangeNumForcedDefaultSpecialists@CvCityCitizens@@QAEXH@Z ; CvCityCitizens::ChangeNumForcedDefaultSpecialists
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumForcedDefaultSpecialists@CvCityCitizens@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeNumForcedDefaultSpecialists@CvCityCitizens@@QAEXH@Z PROC ; CvCityCitizens::ChangeNumForcedDefaultSpecialists, COMDAT
; _this$ = ecx

; 3472 : 	m_iNumForcedDefaultSpecialists += iChange;

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+104], eax

; 3473 : }

	ret	4
?ChangeNumForcedDefaultSpecialists@CvCityCitizens@@QAEXH@Z ENDP ; CvCityCitizens::ChangeNumForcedDefaultSpecialists
_TEXT	ENDS
PUBLIC	?GetSpecialistCount@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z ; CvCityCitizens::GetSpecialistCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistCount@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetSpecialistCount@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z PROC ; CvCityCitizens::GetSpecialistCount, COMDAT
; _this$ = ecx

; 3478 : 	CvAssert(eIndex > -1);
; 3479 : 	CvAssert(eIndex < GC.getNumSpecialistInfos());
; 3480 : 
; 3481 : 	return m_aiSpecialistCounts[eIndex];

	mov	eax, DWORD PTR [ecx+108]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3482 : }

	ret	4
?GetSpecialistCount@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z ENDP ; CvCityCitizens::GetSpecialistCount
_TEXT	ENDS
PUBLIC	?GetBuildingGreatPeopleRateChanges@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z ; CvCityCitizens::GetBuildingGreatPeopleRateChanges
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingGreatPeopleRateChanges@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z
_TEXT	SEGMENT
_eSpecialist$ = 8					; size = 4
?GetBuildingGreatPeopleRateChanges@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z PROC ; CvCityCitizens::GetBuildingGreatPeopleRateChanges, COMDAT
; _this$ = ecx

; 3510 : 	CvAssert(eSpecialist > -1);
; 3511 : 	CvAssert(eSpecialist < GC.getNumSpecialistInfos());
; 3512 : 
; 3513 : 	return m_piBuildingGreatPeopleRateChanges[eSpecialist];

	mov	eax, DWORD PTR [ecx+124]
	mov	ecx, DWORD PTR _eSpecialist$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3514 : }

	ret	4
?GetBuildingGreatPeopleRateChanges@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z ENDP ; CvCityCitizens::GetBuildingGreatPeopleRateChanges
_TEXT	ENDS
PUBLIC	?ChangeBuildingGreatPeopleRateChanges@CvCityCitizens@@QAEXW4SpecialistTypes@@H@Z ; CvCityCitizens::ChangeBuildingGreatPeopleRateChanges
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeBuildingGreatPeopleRateChanges@CvCityCitizens@@QAEXW4SpecialistTypes@@H@Z
_TEXT	SEGMENT
_eSpecialist$ = 8					; size = 4
_iChange$ = 12						; size = 4
?ChangeBuildingGreatPeopleRateChanges@CvCityCitizens@@QAEXW4SpecialistTypes@@H@Z PROC ; CvCityCitizens::ChangeBuildingGreatPeopleRateChanges, COMDAT
; _this$ = ecx

; 3519 : 	CvAssert(eSpecialist > -1);
; 3520 : 	CvAssert(eSpecialist < GC.getNumSpecialistInfos());
; 3521 : 
; 3522 : 	m_piBuildingGreatPeopleRateChanges[eSpecialist] += iChange;

	mov	eax, DWORD PTR [ecx+124]
	mov	ecx, DWORD PTR _eSpecialist$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]

; 3523 : }

	ret	8
?ChangeBuildingGreatPeopleRateChanges@CvCityCitizens@@QAEXW4SpecialistTypes@@H@Z ENDP ; CvCityCitizens::ChangeBuildingGreatPeopleRateChanges
_TEXT	ENDS
PUBLIC	?GetSpecialistGreatPersonProgressTimes100@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z ; CvCityCitizens::GetSpecialistGreatPersonProgressTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistGreatPersonProgressTimes100@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetSpecialistGreatPersonProgressTimes100@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z PROC ; CvCityCitizens::GetSpecialistGreatPersonProgressTimes100, COMDAT
; _this$ = ecx

; 3537 : 	CvAssert(eIndex > -1);
; 3538 : 	CvAssert(eIndex < GC.getNumSpecialistInfos());
; 3539 : 
; 3540 : 	return m_aiSpecialistGreatPersonProgressTimes100[eIndex];

	mov	eax, DWORD PTR [ecx+112]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3541 : }

	ret	4
?GetSpecialistGreatPersonProgressTimes100@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z ENDP ; CvCityCitizens::GetSpecialistGreatPersonProgressTimes100
_TEXT	ENDS
PUBLIC	?ChangeSpecialistGreatPersonProgressTimes100@CvCityCitizens@@QAEXW4SpecialistTypes@@H@Z ; CvCityCitizens::ChangeSpecialistGreatPersonProgressTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeSpecialistGreatPersonProgressTimes100@CvCityCitizens@@QAEXW4SpecialistTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeSpecialistGreatPersonProgressTimes100@CvCityCitizens@@QAEXW4SpecialistTypes@@H@Z PROC ; CvCityCitizens::ChangeSpecialistGreatPersonProgressTimes100, COMDAT
; _this$ = ecx

; 3546 : 	CvAssert(eIndex > -1);
; 3547 : 	CvAssert(eIndex < GC.getNumSpecialistInfos());
; 3548 : 
; 3549 : 	m_aiSpecialistGreatPersonProgressTimes100[eIndex] += iChange;

	mov	eax, DWORD PTR [ecx+112]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]

; 3550 : }

	ret	8
?ChangeSpecialistGreatPersonProgressTimes100@CvCityCitizens@@QAEXW4SpecialistTypes@@H@Z ENDP ; CvCityCitizens::ChangeSpecialistGreatPersonProgressTimes100
_TEXT	ENDS
PUBLIC	?DoResetSpecialistGreatPersonProgressTimes100@CvCityCitizens@@QAEXW4SpecialistTypes@@@Z ; CvCityCitizens::DoResetSpecialistGreatPersonProgressTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?DoResetSpecialistGreatPersonProgressTimes100@CvCityCitizens@@QAEXW4SpecialistTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?DoResetSpecialistGreatPersonProgressTimes100@CvCityCitizens@@QAEXW4SpecialistTypes@@@Z PROC ; CvCityCitizens::DoResetSpecialistGreatPersonProgressTimes100, COMDAT
; _this$ = ecx

; 3555 : 	CvAssert(eIndex > -1);
; 3556 : 	CvAssert(eIndex < GC.getNumSpecialistInfos());
; 3557 : 
; 3558 : 	m_aiSpecialistGreatPersonProgressTimes100[eIndex] = 0;

	mov	eax, DWORD PTR [ecx+112]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	DWORD PTR [eax+ecx*4], 0

; 3559 : }

	ret	4
?DoResetSpecialistGreatPersonProgressTimes100@CvCityCitizens@@QAEXW4SpecialistTypes@@@Z ENDP ; CvCityCitizens::DoResetSpecialistGreatPersonProgressTimes100
_TEXT	ENDS
PUBLIC	?GetNumSpecialistsInBuilding@CvCityCitizens@@QBEHW4BuildingTypes@@@Z ; CvCityCitizens::GetNumSpecialistsInBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumSpecialistsInBuilding@CvCityCitizens@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eBuilding$ = 8						; size = 4
?GetNumSpecialistsInBuilding@CvCityCitizens@@QBEHW4BuildingTypes@@@Z PROC ; CvCityCitizens::GetNumSpecialistsInBuilding, COMDAT
; _this$ = ecx

; 3564 : 	CvAssert(eBuilding > -1);
; 3565 : 	CvAssert(eBuilding < GC.getNumBuildingInfos());
; 3566 : 
; 3567 : 	return m_aiNumSpecialistsInBuilding[eBuilding];

	mov	eax, DWORD PTR [ecx+116]
	mov	ecx, DWORD PTR _eBuilding$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3568 : }

	ret	4
?GetNumSpecialistsInBuilding@CvCityCitizens@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityCitizens::GetNumSpecialistsInBuilding
_TEXT	ENDS
PUBLIC	?GetNumForcedSpecialistsInBuilding@CvCityCitizens@@QBEHW4BuildingTypes@@@Z ; CvCityCitizens::GetNumForcedSpecialistsInBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumForcedSpecialistsInBuilding@CvCityCitizens@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eBuilding$ = 8						; size = 4
?GetNumForcedSpecialistsInBuilding@CvCityCitizens@@QBEHW4BuildingTypes@@@Z PROC ; CvCityCitizens::GetNumForcedSpecialistsInBuilding, COMDAT
; _this$ = ecx

; 3573 : 	CvAssert(eBuilding > -1);
; 3574 : 	CvAssert(eBuilding < GC.getNumBuildingInfos());
; 3575 : 
; 3576 : 	return m_aiNumForcedSpecialistsInBuilding[eBuilding];

	mov	eax, DWORD PTR [ecx+120]
	mov	ecx, DWORD PTR _eBuilding$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3577 : }

	ret	4
?GetNumForcedSpecialistsInBuilding@CvCityCitizens@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityCitizens::GetNumForcedSpecialistsInBuilding
_TEXT	ENDS
PUBLIC	?DoClearForcedSpecialists@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoClearForcedSpecialists
EXTRN	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?DoClearForcedSpecialists@CvCityCitizens@@QAEXXZ
_TEXT	SEGMENT
?DoClearForcedSpecialists@CvCityCitizens@@QAEXXZ PROC	; CvCityCitizens::DoClearForcedSpecialists, COMDAT
; _this$ = ecx

; 3581 : {

	push	esi
	push	edi
	mov	edi, ecx

; 3582 : 	// Loop through all Buildings
; 3583 : 	BuildingTypes eBuilding;
; 3584 : #ifdef AUI_WARNING_FIXES
; 3585 : 	for (uint iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
; 3586 : #else
; 3587 : 	for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	SHORT $LN2@DoClearFor
$LL4@DoClearFor:

; 3588 : #endif
; 3589 : 	{
; 3590 : 		eBuilding = (BuildingTypes) iBuildingLoop;
; 3591 : 
; 3592 : 		// Have this Building in the City?
; 3593 : 		if(GetCity()->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN3@DoClearFor

; 3594 : 		{
; 3595 : 			m_aiNumForcedSpecialistsInBuilding[eBuilding] = 0;

	mov	eax, DWORD PTR [edi+120]
	mov	DWORD PTR [eax+esi*4], 0
$LN3@DoClearFor:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	SHORT $LL4@DoClearFor
$LN2@DoClearFor:
	pop	edi
	pop	esi

; 3596 : 		}
; 3597 : 	}
; 3598 : }

	ret	0
?DoClearForcedSpecialists@CvCityCitizens@@QAEXXZ ENDP	; CvCityCitizens::DoClearForcedSpecialists
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z PROC ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z ENDP ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ ; std::auto_ptr<ICvCity1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ PROC ; std::auto_ptr<ICvCity1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ ENDP ; std::auto_ptr<ICvCity1>::get
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ; std::auto_ptr_ref<ICvCity1>::auto_ptr_ref<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z PROC ; std::auto_ptr_ref<ICvCity1>::auto_ptr_ref<ICvCity1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ENDP ; std::auto_ptr_ref<ICvCity1>::auto_ptr_ref<ICvCity1>
_TEXT	ENDS
PUBLIC	??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z ; CvPopupInfo::CvPopupInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z
_TEXT	SEGMENT
_buttonPopupType$ = 8					; size = 4
_data1$ = 12						; size = 4
_data2$ = 16						; size = 4
_data3$ = 20						; size = 4
_flags$ = 24						; size = 4
_option1$ = 28						; size = 1
_option2$ = 32						; size = 1
??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z PROC	; CvPopupInfo::CvPopupInfo, COMDAT
; _this$ = ecx

; 119  : 	{

	mov	edx, DWORD PTR _data2$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _data1$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _data3$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _flags$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	cl, BYTE PTR _option1$[esp-4]
	mov	DWORD PTR [eax+12], edx
	mov	dl, BYTE PTR _option2$[esp-4]
	mov	BYTE PTR [eax+16], cl
	mov	ecx, DWORD PTR _buttonPopupType$[esp-4]
	mov	BYTE PTR [eax+17], dl
	mov	DWORD PTR [eax+20], ecx

; 120  : 		//Nothing
; 121  : 		szText[0] = 0;

	mov	BYTE PTR [eax+24], 0

; 122  : 	}

	ret	28					; 0000001cH
??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z ENDP	; CvPopupInfo::CvPopupInfo
_TEXT	ENDS
PUBLIC	??3ICvUnknown@@SGXPAX@Z				; ICvUnknown::operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??3ICvUnknown@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3ICvUnknown@@SGXPAX@Z PROC				; ICvUnknown::operator delete, COMDAT

; 310  : 		if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@operator

; 311  : 		{
; 312  : 			ICvUnknown* inst = (ICvUnknown*)(p);
; 313  : 			inst->Destroy();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[esp-4], eax
	jmp	edx
$LN1@operator:

; 314  : 		}
; 315  : 	}

	ret	4
??3ICvUnknown@@SGXPAX@Z ENDP				; ICvUnknown::operator delete
_TEXT	ENDS
PUBLIC	?GetReligionData@CvUnit@@QBEPAVCvUnitReligion@@XZ ; CvUnit::GetReligionData
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?GetReligionData@CvUnit@@QBEPAVCvUnitReligion@@XZ
_TEXT	SEGMENT
?GetReligionData@CvUnit@@QBEPAVCvUnitReligion@@XZ PROC	; CvUnit::GetReligionData, COMDAT
; _this$ = ecx

; 1317 : 		return m_pReligion;

	mov	eax, DWORD PTR [ecx+1888]

; 1318 : 	};

	ret	0
?GetReligionData@CvUnit@@QBEPAVCvUnitReligion@@XZ ENDP	; CvUnit::GetReligionData
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getAI_CITIZEN_VALUE_FOOD@CvGlobals@@QAEHXZ	; CvGlobals::getAI_CITIZEN_VALUE_FOOD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITIZEN_VALUE_FOOD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITIZEN_VALUE_FOOD@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_CITIZEN_VALUE_FOOD, COMDAT
; _this$ = ecx

; 1441 : 		return m_iAI_CITIZEN_VALUE_FOOD;

	mov	eax, DWORD PTR [ecx+2376]

; 1442 : 	}

	ret	0
?getAI_CITIZEN_VALUE_FOOD@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_CITIZEN_VALUE_FOOD
_TEXT	ENDS
PUBLIC	?getAI_CITIZEN_VALUE_PRODUCTION@CvGlobals@@QAEHXZ ; CvGlobals::getAI_CITIZEN_VALUE_PRODUCTION
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITIZEN_VALUE_PRODUCTION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITIZEN_VALUE_PRODUCTION@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_CITIZEN_VALUE_PRODUCTION, COMDAT
; _this$ = ecx

; 1445 : 		return m_iAI_CITIZEN_VALUE_PRODUCTION;

	mov	eax, DWORD PTR [ecx+2380]

; 1446 : 	}

	ret	0
?getAI_CITIZEN_VALUE_PRODUCTION@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_CITIZEN_VALUE_PRODUCTION
_TEXT	ENDS
PUBLIC	?getAI_CITIZEN_VALUE_GOLD@CvGlobals@@QAEHXZ	; CvGlobals::getAI_CITIZEN_VALUE_GOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITIZEN_VALUE_GOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITIZEN_VALUE_GOLD@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_CITIZEN_VALUE_GOLD, COMDAT
; _this$ = ecx

; 1449 : 		return m_iAI_CITIZEN_VALUE_GOLD;

	mov	eax, DWORD PTR [ecx+2384]

; 1450 : 	}

	ret	0
?getAI_CITIZEN_VALUE_GOLD@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_CITIZEN_VALUE_GOLD
_TEXT	ENDS
PUBLIC	?getAI_CITIZEN_VALUE_SCIENCE@CvGlobals@@QAEHXZ	; CvGlobals::getAI_CITIZEN_VALUE_SCIENCE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITIZEN_VALUE_SCIENCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITIZEN_VALUE_SCIENCE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_CITIZEN_VALUE_SCIENCE, COMDAT
; _this$ = ecx

; 1453 : 		return m_iAI_CITIZEN_VALUE_SCIENCE;

	mov	eax, DWORD PTR [ecx+2388]

; 1454 : 	}

	ret	0
?getAI_CITIZEN_VALUE_SCIENCE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_CITIZEN_VALUE_SCIENCE
_TEXT	ENDS
PUBLIC	?getAI_CITIZEN_VALUE_CULTURE@CvGlobals@@QAEHXZ	; CvGlobals::getAI_CITIZEN_VALUE_CULTURE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITIZEN_VALUE_CULTURE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITIZEN_VALUE_CULTURE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_CITIZEN_VALUE_CULTURE, COMDAT
; _this$ = ecx

; 1457 : 		return m_iAI_CITIZEN_VALUE_CULTURE;

	mov	eax, DWORD PTR [ecx+2392]

; 1458 : 	}

	ret	0
?getAI_CITIZEN_VALUE_CULTURE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_CITIZEN_VALUE_CULTURE
_TEXT	ENDS
PUBLIC	?getAI_CITIZEN_VALUE_FAITH@CvGlobals@@QAEHXZ	; CvGlobals::getAI_CITIZEN_VALUE_FAITH
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_CITIZEN_VALUE_FAITH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_CITIZEN_VALUE_FAITH@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_CITIZEN_VALUE_FAITH, COMDAT
; _this$ = ecx

; 1461 : 		return m_iAI_CITIZEN_VALUE_FAITH;

	mov	eax, DWORD PTR [ecx+2396]

; 1462 : 	}

	ret	0
?getAI_CITIZEN_VALUE_FAITH@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_CITIZEN_VALUE_FAITH
_TEXT	ENDS
PUBLIC	?getNAVAL_PLOT_BLOCKADE_RANGE@CvGlobals@@QAEHXZ	; CvGlobals::getNAVAL_PLOT_BLOCKADE_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getNAVAL_PLOT_BLOCKADE_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNAVAL_PLOT_BLOCKADE_RANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNAVAL_PLOT_BLOCKADE_RANGE, COMDAT
; _this$ = ecx

; 5248 : 		return m_iNAVAL_PLOT_BLOCKADE_RANGE;

	mov	eax, DWORD PTR [ecx+6172]

; 5249 : 	}

	ret	0
?getNAVAL_PLOT_BLOCKADE_RANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNAVAL_PLOT_BLOCKADE_RANGE
_TEXT	ENDS
PUBLIC	?getMAX_SPECIALISTS_FROM_BUILDING@CvGlobals@@QAEHXZ ; CvGlobals::getMAX_SPECIALISTS_FROM_BUILDING
; Function compile flags: /Ogtpy
;	COMDAT ?getMAX_SPECIALISTS_FROM_BUILDING@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAX_SPECIALISTS_FROM_BUILDING@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMAX_SPECIALISTS_FROM_BUILDING, COMDAT
; _this$ = ecx

; 6176 : 		return m_iMAX_SPECIALISTS_FROM_BUILDING;

	mov	eax, DWORD PTR [ecx+7100]

; 6177 : 	}

	ret	0
?getMAX_SPECIALISTS_FROM_BUILDING@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMAX_SPECIALISTS_FROM_BUILDING
_TEXT	ENDS
PUBLIC	?getGREAT_PERSON_THRESHOLD_BASE@CvGlobals@@QAEHXZ ; CvGlobals::getGREAT_PERSON_THRESHOLD_BASE
; Function compile flags: /Ogtpy
;	COMDAT ?getGREAT_PERSON_THRESHOLD_BASE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getGREAT_PERSON_THRESHOLD_BASE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getGREAT_PERSON_THRESHOLD_BASE, COMDAT
; _this$ = ecx

; 6180 : 		return m_iGREAT_PERSON_THRESHOLD_BASE;

	mov	eax, DWORD PTR [ecx+7104]

; 6181 : 	}

	ret	0
?getGREAT_PERSON_THRESHOLD_BASE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getGREAT_PERSON_THRESHOLD_BASE
_TEXT	ENDS
PUBLIC	?getGREAT_PERSON_THRESHOLD_INCREASE@CvGlobals@@QAEHXZ ; CvGlobals::getGREAT_PERSON_THRESHOLD_INCREASE
; Function compile flags: /Ogtpy
;	COMDAT ?getGREAT_PERSON_THRESHOLD_INCREASE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getGREAT_PERSON_THRESHOLD_INCREASE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getGREAT_PERSON_THRESHOLD_INCREASE, COMDAT
; _this$ = ecx

; 6184 : 		return m_iGREAT_PERSON_THRESHOLD_INCREASE;

	mov	eax, DWORD PTR [ecx+7108]

; 6185 : 	}

	ret	0
?getGREAT_PERSON_THRESHOLD_INCREASE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getGREAT_PERSON_THRESHOLD_INCREASE
_TEXT	ENDS
PUBLIC	?getDEFAULT_SPECIALIST@CvGlobals@@QAEHXZ	; CvGlobals::getDEFAULT_SPECIALIST
; Function compile flags: /Ogtpy
;	COMDAT ?getDEFAULT_SPECIALIST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getDEFAULT_SPECIALIST@CvGlobals@@QAEHXZ PROC		; CvGlobals::getDEFAULT_SPECIALIST, COMDAT
; _this$ = ecx

; 7203 : 		return m_iDEFAULT_SPECIALIST;

	mov	eax, DWORD PTR [ecx+8420]

; 7204 : 	}

	ret	0
?getDEFAULT_SPECIALIST@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getDEFAULT_SPECIALIST
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7748 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8600]

; 7749 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?GetGoldenAgeGreatArtistRateModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetGoldenAgeGreatArtistRateModifier
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetGoldenAgeGreatArtistRateModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeGreatArtistRateModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetGoldenAgeGreatArtistRateModifier, COMDAT
; _this$ = ecx

; 597  : 		return m_iGoldenAgeGreatArtistRateModifier;

	mov	eax, DWORD PTR [ecx+188]

; 598  : 	};

	ret	0
?GetGoldenAgeGreatArtistRateModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetGoldenAgeGreatArtistRateModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeGreatMusicianRateModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetGoldenAgeGreatMusicianRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeGreatMusicianRateModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeGreatMusicianRateModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetGoldenAgeGreatMusicianRateModifier, COMDAT
; _this$ = ecx

; 601  : 		return m_iGoldenAgeGreatMusicianRateModifier;

	mov	eax, DWORD PTR [ecx+192]

; 602  : 	};

	ret	0
?GetGoldenAgeGreatMusicianRateModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetGoldenAgeGreatMusicianRateModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeGreatWriterRateModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetGoldenAgeGreatWriterRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeGreatWriterRateModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeGreatWriterRateModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetGoldenAgeGreatWriterRateModifier, COMDAT
; _this$ = ecx

; 605  : 		return m_iGoldenAgeGreatWriterRateModifier;

	mov	eax, DWORD PTR [ecx+196]

; 606  : 	};

	ret	0
?GetGoldenAgeGreatWriterRateModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetGoldenAgeGreatWriterRateModifier
_TEXT	ENDS
PUBLIC	?SetReligion@CvUnitReligion@@QAEXW4ReligionTypes@@@Z ; CvUnitReligion::SetReligion
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvreligionclasses.h
;	COMDAT ?SetReligion@CvUnitReligion@@QAEXW4ReligionTypes@@@Z
_TEXT	SEGMENT
_eReligion$ = 8						; size = 4
?SetReligion@CvUnitReligion@@QAEXW4ReligionTypes@@@Z PROC ; CvUnitReligion::SetReligion, COMDAT
; _this$ = ecx

; 499  : 		m_eReligion = eReligion;

	mov	eax, DWORD PTR _eReligion$[esp-4]
	mov	DWORD PTR [ecx], eax

; 500  : 	};

	ret	4
?SetReligion@CvUnitReligion@@QAEXW4ReligionTypes@@@Z ENDP ; CvUnitReligion::SetReligion
_TEXT	ENDS
PUBLIC	?SetReligiousStrength@CvUnitReligion@@QAEXH@Z	; CvUnitReligion::SetReligiousStrength
; Function compile flags: /Ogtpy
;	COMDAT ?SetReligiousStrength@CvUnitReligion@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetReligiousStrength@CvUnitReligion@@QAEXH@Z PROC	; CvUnitReligion::SetReligiousStrength, COMDAT
; _this$ = ecx

; 507  : 		m_iStrength = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 508  : 	};

	ret	4
?SetReligiousStrength@CvUnitReligion@@QAEXH@Z ENDP	; CvUnitReligion::SetReligiousStrength
_TEXT	ENDS
PUBLIC	?SetSpreadsLeft@CvUnitReligion@@QAEXH@Z		; CvUnitReligion::SetSpreadsLeft
; Function compile flags: /Ogtpy
;	COMDAT ?SetSpreadsLeft@CvUnitReligion@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetSpreadsLeft@CvUnitReligion@@QAEXH@Z PROC		; CvUnitReligion::SetSpreadsLeft, COMDAT
; _this$ = ecx

; 515  : 		m_iSpreadsLeft = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 516  : 	};

	ret	4
?SetSpreadsLeft@CvUnitReligion@@QAEXH@Z ENDP		; CvUnitReligion::SetSpreadsLeft
_TEXT	ENDS
PUBLIC	?GetSpecialization@CvCityStrategyAI@@QBE?AW4CitySpecializationTypes@@XZ ; CvCityStrategyAI::GetSpecialization
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitystrategyai.h
;	COMDAT ?GetSpecialization@CvCityStrategyAI@@QBE?AW4CitySpecializationTypes@@XZ
_TEXT	SEGMENT
?GetSpecialization@CvCityStrategyAI@@QBE?AW4CitySpecializationTypes@@XZ PROC ; CvCityStrategyAI::GetSpecialization, COMDAT
; _this$ = ecx

; 162  : 		return m_eSpecialization;

	mov	eax, DWORD PTR [ecx+20]

; 163  : 	};

	ret	0
?GetSpecialization@CvCityStrategyAI@@QBE?AW4CitySpecializationTypes@@XZ ENDP ; CvCityStrategyAI::GetSpecialization
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDY$ = -12						; size = 4
tv320 = -8						; size = 4
tv357 = -4						; size = 4
_iX1$ = 8						; size = 4
_iDX$ = 12						; size = 4
_iY1$ = 12						; size = 4
$T227148 = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	sub	esp, 12					; 0000000cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	ecx, DWORD PTR _iX2$[esp+8]
	sub	ecx, DWORD PTR _iX1$[esp+8]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edi+4056], 0
	mov	edx, DWORD PTR [edi+4020]
	mov	DWORD PTR tv320[esp+28], ecx
	je	SHORT $LN18@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN20@plotDistan
	sub	ecx, edx
	jmp	SHORT $LN18@plotDistan
$LN20@plotDistan:
	neg	eax
	cmp	ecx, eax
	jge	SHORT $LN18@plotDistan
	add	ecx, edx
$LN18@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ebp, DWORD PTR _iY2$[esp+24]
	sub	ebp, DWORD PTR _iY1$[esp+24]
	cmp	BYTE PTR [edi+4057], 0
	mov	eax, DWORD PTR [edi+4024]
	je	SHORT $LN32@plotDistan
	mov	edx, eax
	shr	edx, 1
	cmp	ebp, edx
	jle	SHORT $LN34@plotDistan
	mov	ebx, ebp
	sub	ebx, eax
	mov	DWORD PTR $T227148[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN34@plotDistan:
	neg	edx
	cmp	ebp, edx
	jge	SHORT $LN32@plotDistan
	lea	ebx, DWORD PTR [eax+ebp]
	mov	DWORD PTR $T227148[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN32@plotDistan:
	mov	ebx, ebp
	mov	DWORD PTR $T227148[esp+24], ebp
$LN36@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx

; 149  : 
; 150  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 151  : 	const CvMap& kMap = GC.getMap();
; 152  : 	// equidistant column joint fix (on X-wrapped maps):
; 153  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (iDY % 2 != 0) && ((iY1 % 2 == 0) == (iWrappedDX > (kMap.getGridWidth() >> 2))))

	cmp	BYTE PTR [edi+4056], 0
	mov	DWORD PTR _iDY$[esp+28], esi
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+4020]
	xor	ebx, edx
	sub	ebx, edx
	cmp	ebx, eax
	jne	SHORT $LN73@plotDistan
	mov	edx, esi
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN79@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN79@plotDistan:
	je	SHORT $LN73@plotDistan
	sar	eax, 2
	xor	edx, edx
	cmp	ecx, eax
	mov	eax, DWORD PTR _iY1$[esp+24]
	setg	dl
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN80@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN80@plotDistan:

; 154  : 	{
; 155  : 		iWrappedDX *= -1;  // change polarity

	mov	ebx, DWORD PTR $T227148[esp+24]
	neg	eax
	sbb	eax, eax
	inc	eax
	cmp	eax, edx
	jne	SHORT $LN5@plotDistan
	neg	ecx
	jmp	SHORT $LN5@plotDistan
$LN73@plotDistan:
	mov	ebx, DWORD PTR $T227148[esp+24]
$LN5@plotDistan:

; 156  : 	}
; 157  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (abs(iWrappedDY) < abs(iY2 - iY1)) && (iDY % 2 == 0) && (iX2 - iX1 < 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, DWORD PTR [edi+4020]
	jne	SHORT $LN75@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN75@plotDistan
	mov	edx, DWORD PTR _iDY$[esp+28]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN81@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN81@plotDistan:
	jne	SHORT $LN75@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jge	SHORT $LN75@plotDistan

; 158  : 	{
; 159  : 		iWrappedDX *= -1;  // change polarity

	neg	ecx
$LN75@plotDistan:

; 160  : 	}
; 161  : 	// special case when map is toroidal AND map height is odd
; 162  : 	// TODO works but ugly
; 163  : 	if ((kMap.isWrapX()) && (kMap.getGridHeight() % 2 != 0) && (iY1 % 2 == kMap.getGridWidth() % 2) && (iY2 % 2 == 0) &&
; 164  : 		(abs(iWrappedDY) < abs(iY2 - iY1)) && (abs(iX2 - iX1) == kMap.getGridWidth() / 2 + ((kMap.getGridWidth() % 2 == 1) && (iX2 - iX1 > 0)) ? 1 : 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	mov	eax, DWORD PTR [edi+4024]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN82@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN82@plotDistan:
	je	$LN77@plotDistan
	mov	edi, DWORD PTR [edi+4020]
	mov	DWORD PTR tv357[esp+28], edi
	and	edi, -2147483647			; 80000001H
	jns	SHORT $LN83@plotDistan
	dec	edi
	or	edi, -2					; fffffffeH
	inc	edi
$LN83@plotDistan:
	mov	edx, DWORD PTR _iY1$[esp+24]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN84@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN84@plotDistan:
	cmp	edx, edi
	jne	SHORT $LN77@plotDistan
	mov	eax, DWORD PTR _iY2$[esp+24]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN85@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN85@plotDistan:
	jne	SHORT $LN77@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN77@plotDistan
	cmp	edi, 1
	jne	SHORT $LN76@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jle	SHORT $LN76@plotDistan
	mov	esi, edi
	jmp	SHORT $LN9@plotDistan
$LN76@plotDistan:
	xor	esi, esi
$LN9@plotDistan:
	mov	eax, DWORD PTR tv320[esp+28]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR tv357[esp+28]
	xor	edi, edx
	sub	edi, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, esi
	cmp	edi, eax
	jne	SHORT $LN77@plotDistan

; 165  : 	{
; 166  : 		iWrappedDX -= (iWrappedDX > 0) - (iWrappedDX < 0);  // decrease regardless of polarity

	xor	edx, edx
	test	ecx, ecx
	setl	dl
	xor	eax, eax
	test	ecx, ecx
	setg	al
	sub	edx, eax
	add	ecx, edx
$LN77@plotDistan:

; 167  : 	}
; 168  : #endif
; 169  : 
; 170  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 171  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	mov	eax, DWORD PTR _iY1$[esp+24]
	test	eax, eax
	jge	SHORT $LN88@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN88@plotDistan:
	mov	edi, DWORD PTR _iX1$[esp+24]

; 172  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	edx, DWORD PTR _iY1$[esp+24]
	sar	eax, 1
	mov	esi, edi
	sub	esi, eax
	lea	eax, DWORD PTR [ebx+edx]
	test	eax, eax
	jge	SHORT $LN89@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN89@plotDistan:
	sar	eax, 1
	sub	ecx, eax
	add	ecx, edi

; 173  : 
; 174  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 175  : 	// obvious bug
; 176  : 	iDX = abs(iHX2 - iHX1);

	sub	ecx, esi
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 177  : #else
; 178  : 	iDX = abs(dxWrap(iHX2 - iHX1));
; 179  : #endif
; 180  : 
; 181  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 182  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 183  : #else
; 184  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp+12], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 185  : #endif
; 186  : 	{
; 187  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp+12]
	add	eax, edx

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN2@plotDistan:

; 188  : 	}
; 189  : 	else
; 190  : 	{
; 191  : #ifdef NQM_FAST_COMP
; 192  : 		return (MAX(iDX, iDY));
; 193  : #else
; 194  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp+12]
	lea	eax, DWORD PTR _iDY$[esp+12]
	jl	SHORT $LN71@plotDistan
	lea	eax, DWORD PTR _iDX$[esp+8]
$LN71@plotDistan:
	mov	eax, DWORD PTR [eax]

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?Init@CvCityCitizens@@QAEXPAVCvCity@@@Z		; CvCityCitizens::Init
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitycitizens.cpp
;	COMDAT ?Init@CvCityCitizens@@QAEXPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?Init@CvCityCitizens@@QAEXPAVCvCity@@@Z PROC		; CvCityCitizens::Init, COMDAT
; _this$ = ecx

; 54   : 	m_pCity = pCity;

	mov	eax, DWORD PTR _pCity$[esp-4]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], eax

; 55   : 
; 56   : 	// Clear variables
; 57   : 	Reset();

	call	?Reset@CvCityCitizens@@QAEXXZ		; CvCityCitizens::Reset

; 58   : 
; 59   : 	m_bInited = true;

	mov	BYTE PTR [esi+128], 1
	pop	esi

; 60   : }

	ret	4
?Init@CvCityCitizens@@QAEXPAVCvCity@@@Z ENDP		; CvCityCitizens::Init
_TEXT	ENDS
PUBLIC	?Uninit@CvCityCitizens@@QAEXXZ			; CvCityCitizens::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvCityCitizens@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvCityCitizens@@QAEXXZ PROC			; CvCityCitizens::Uninit, COMDAT
; _this$ = ecx

; 64   : {

	push	ebx
	push	esi
	mov	esi, ecx

; 65   : 	if(m_bInited)

	xor	ebx, ebx
	cmp	BYTE PTR [esi+128], bl
	je	SHORT $LN14@Uninit

; 66   : 	{
; 67   : 		SAFE_DELETE_ARRAY(m_aiSpecialistCounts);

	mov	eax, DWORD PTR [esi+108]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+108], ebx

; 68   : 		SAFE_DELETE_ARRAY(m_aiSpecialistGreatPersonProgressTimes100);

	mov	ecx, DWORD PTR [esi+112]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+112], ebx

; 69   : 		SAFE_DELETE_ARRAY(m_aiNumSpecialistsInBuilding);

	mov	edx, DWORD PTR [esi+116]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+116], ebx

; 70   : 		SAFE_DELETE_ARRAY(m_aiNumForcedSpecialistsInBuilding);

	mov	eax, DWORD PTR [esi+120]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+120], ebx

; 71   : 		SAFE_DELETE_ARRAY(m_piBuildingGreatPeopleRateChanges);

	mov	ecx, DWORD PTR [esi+124]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esi+124], ebx
$LN14@Uninit:

; 72   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 73   : 		SAFE_DELETE_ARRAY(m_aiCachedGPChangeT100ForThisTurn);
; 74   : #endif
; 75   : 	}
; 76   : 	m_bInited = false;

	mov	BYTE PTR [esi+128], bl
	pop	esi
	pop	ebx

; 77   : }

	ret	0
?Uninit@CvCityCitizens@@QAEXXZ ENDP			; CvCityCitizens::Uninit
_TEXT	ENDS
PUBLIC	?IsBetterThanDefaultSpecialist@CvCityCitizens@@QAE_NW4SpecialistTypes@@@Z ; CvCityCitizens::IsBetterThanDefaultSpecialist
EXTRN	?isHalfSpecialistFood@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::isHalfSpecialistFood
EXTRN	?isHalfSpecialistUnhappiness@CvPlayer@@QBE_NXZ:PROC ; CvPlayer::isHalfSpecialistUnhappiness
EXTRN	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ:PROC	; CvCity::GetPlayer
EXTRN	?getYieldChange@CvSpecialistInfo@@QBEHH@Z:PROC	; CvSpecialistInfo::getYieldChange
EXTRN	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z:PROC ; CvGlobals::getSpecialistInfo
; Function compile flags: /Ogtpy
;	COMDAT ?IsBetterThanDefaultSpecialist@CvCityCitizens@@QAE_NW4SpecialistTypes@@@Z
_TEXT	SEGMENT
_eSpecialist$ = 8					; size = 4
?IsBetterThanDefaultSpecialist@CvCityCitizens@@QAE_NW4SpecialistTypes@@@Z PROC ; CvCityCitizens::IsBetterThanDefaultSpecialist, COMDAT
; _this$ = ecx

; 1798 : 	CvSpecialistInfo* pSpecialistInfo = GC.getSpecialistInfo(eSpecialist);

	mov	eax, DWORD PTR _eSpecialist$[esp-4]
	push	ebp
	push	edi
	mov	ebp, ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo
	mov	edi, eax

; 1799 : 	CvAssertMsg(pSpecialistInfo, "Invalid specialist type when assigning citizens. Please send Anton your save file and version.");
; 1800 : 	if(!pSpecialistInfo) return false; // Assumes that default specialist will work out

	test	edi, edi
	jne	SHORT $LN16@IsBetterTh
	pop	edi
	xor	al, al
	pop	ebp

; 1855 : }

	ret	4
$LN16@IsBetterTh:

; 1801 : 
; 1802 : 	SpecialistTypes eDefaultSpecialist = (SpecialistTypes) GC.getDEFAULT_SPECIALIST();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8420
	push	ebx

; 1803 : 	CvSpecialistInfo* pDefaultSpecialistInfo = GC.getSpecialistInfo(eDefaultSpecialist);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo
	mov	ebx, eax

; 1804 : 	CvAssertMsg(pDefaultSpecialistInfo, "Invalid default specialist type when assigning citizens. Please send Anton your save file and version.");
; 1805 : 	if(!pDefaultSpecialistInfo) return false;

	test	ebx, ebx
	jne	SHORT $LN15@IsBetterTh
	pop	ebx
	pop	edi
	xor	al, al
	pop	ebp

; 1855 : }

	ret	4
$LN15@IsBetterTh:

; 1806 : 
; 1807 : 	//antonjs: consider: deficient yield
; 1808 : 
; 1809 : 	CityAIFocusTypes eFocus = GetFocusType();

	mov	eax, DWORD PTR [ebp+20]
	push	esi

; 1810 : 	YieldTypes eYield = NO_YIELD;
; 1811 : 	switch (eFocus)

	cmp	eax, 8
	ja	SHORT $LN4@IsBetterTh
	jmp	DWORD PTR $LN26@IsBetterTh[eax*4]
$LN12@IsBetterTh:

; 1812 : 	{
; 1813 : 	case CITY_AI_FOCUS_TYPE_FOOD:
; 1814 : 		eYield = YIELD_FOOD;

	xor	esi, esi
$LN3@IsBetterTh:

; 1845 : 
; 1846 : 	int iSpecialistYield = pSpecialistInfo->getYieldChange(eYield);

	push	esi
	mov	ecx, edi
	call	?getYieldChange@CvSpecialistInfo@@QBEHH@Z ; CvSpecialistInfo::getYieldChange

; 1847 : 	int iDefaultSpecialistYield = pDefaultSpecialistInfo->getYieldChange(eYield);

	push	esi
	mov	ecx, ebx
	mov	edi, eax
	call	?getYieldChange@CvSpecialistInfo@@QBEHH@Z ; CvSpecialistInfo::getYieldChange

; 1848 : 
; 1849 : 	if (m_pCity->GetPlayer()->isHalfSpecialistUnhappiness() || m_pCity->GetPlayer()->isHalfSpecialistFood())

	mov	ecx, DWORD PTR [ebp]
	mov	esi, eax
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?isHalfSpecialistUnhappiness@CvPlayer@@QBE_NXZ ; CvPlayer::isHalfSpecialistUnhappiness
	test	al, al
	jne	SHORT $LN1@IsBetterTh
	mov	ecx, DWORD PTR [ebp]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?isHalfSpecialistFood@CvPlayer@@QBE_NXZ	; CvPlayer::isHalfSpecialistFood
	test	al, al
	je	SHORT $LN2@IsBetterTh
$LN1@IsBetterTh:

; 1850 : 	{
; 1851 : 		iSpecialistYield *= 2;

	add	edi, edi
$LN2@IsBetterTh:

; 1852 : 	}
; 1853 : 
; 1854 : 	return (iSpecialistYield >= iDefaultSpecialistYield); // Unless default Specialist has strictly more, this Specialist is better

	xor	eax, eax
	cmp	edi, esi
	pop	esi
	pop	ebx
	pop	edi
	setge	al
	pop	ebp

; 1855 : }

	ret	4
$LN11@IsBetterTh:

; 1815 : 		break;
; 1816 : 	case CITY_AI_FOCUS_TYPE_PRODUCTION:
; 1817 : 		eYield = YIELD_PRODUCTION;

	mov	esi, 1

; 1818 : 		break;

	jmp	SHORT $LN3@IsBetterTh
$LN10@IsBetterTh:

; 1819 : 	case CITY_AI_FOCUS_TYPE_GOLD:
; 1820 : 		eYield = YIELD_GOLD;

	mov	esi, 2

; 1821 : 		break;

	jmp	SHORT $LN3@IsBetterTh
$LN8@IsBetterTh:

; 1822 : 	case CITY_AI_FOCUS_TYPE_GREAT_PEOPLE:
; 1823 : 		eYield = NO_YIELD;
; 1824 : 		break;
; 1825 : 	case CITY_AI_FOCUS_TYPE_SCIENCE:
; 1826 : 		eYield = YIELD_SCIENCE;

	mov	esi, 3

; 1827 : 		break;

	jmp	SHORT $LN3@IsBetterTh
$LN7@IsBetterTh:

; 1828 : 	case CITY_AI_FOCUS_TYPE_CULTURE:
; 1829 : 		eYield = YIELD_CULTURE;

	mov	esi, 4

; 1830 : 		break;

	jmp	SHORT $LN3@IsBetterTh
$LN5@IsBetterTh:

; 1831 : 	case CITY_AI_FOCUS_TYPE_PROD_GROWTH:
; 1832 : 	case CITY_AI_FOCUS_TYPE_GOLD_GROWTH:
; 1833 : 		eYield = YIELD_FOOD;
; 1834 : 		break;
; 1835 : 	case CITY_AI_FOCUS_TYPE_FAITH:
; 1836 : 		eYield = YIELD_FAITH;

	mov	esi, 5

; 1837 : 		break;

	jmp	SHORT $LN3@IsBetterTh
$LN4@IsBetterTh:
	pop	esi
	pop	ebx
	pop	edi

; 1838 : 	default:
; 1839 : 		eYield = NO_YIELD;
; 1840 : 		break;
; 1841 : 	}
; 1842 : 
; 1843 : 	if (eYield == NO_YIELD)
; 1844 : 		return true;

	mov	al, 1
	pop	ebp

; 1855 : }

	ret	4
	npad	1
$LN26@IsBetterTh:
	DD	$LN12@IsBetterTh
	DD	$LN11@IsBetterTh
	DD	$LN10@IsBetterTh
	DD	$LN4@IsBetterTh
	DD	$LN8@IsBetterTh
	DD	$LN7@IsBetterTh
	DD	$LN12@IsBetterTh
	DD	$LN12@IsBetterTh
	DD	$LN5@IsBetterTh
?IsBetterThanDefaultSpecialist@CvCityCitizens@@QAE_NW4SpecialistTypes@@@Z ENDP ; CvCityCitizens::IsBetterThanDefaultSpecialist
_TEXT	ENDS
PUBLIC	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
; Function compile flags: /Ogtpy
;	COMDAT ?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z PROC	; CvCityCitizens::IsWorkingPlot, COMDAT
; _this$ = ecx

; 2320 : 	int iIndex;
; 2321 : 
; 2322 : 	iIndex = GetCityIndexFromPlot(pPlot);

	mov	eax, DWORD PTR _pPlot$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	add	esp, 8

; 2323 : 
; 2324 : 	if(iIndex != -1)

	cmp	eax, -1
	je	SHORT $LN1@IsWorkingP

; 2325 : 	{
; 2326 : 		return m_pabWorkingPlot[iIndex];

	mov	al, BYTE PTR [eax+esi+25]
	pop	esi

; 2330 : }

	ret	4
$LN1@IsWorkingP:

; 2327 : 	}
; 2328 : 
; 2329 : 	return false;

	xor	al, al
	pop	esi

; 2330 : }

	ret	4
?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ENDP	; CvCityCitizens::IsWorkingPlot
_TEXT	ENDS
PUBLIC	?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z ; CvCityCitizens::SetWorkingPlot
EXTRN	?isCitySelected@CvCity@@QAE_NXZ:PROC		; CvCity::isCitySelected
EXTRN	?ChangeBaseYieldRateFromTerrain@CvCity@@QAEXW4YieldTypes@@H@Z:PROC ; CvCity::ChangeBaseYieldRateFromTerrain
EXTRN	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z:PROC	; CvPlot::getYield
; Function compile flags: /Ogtpy
;	COMDAT ?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
_bUseUnassignedPool$ = 16				; size = 1
?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z PROC ; CvCityCitizens::SetWorkingPlot, COMDAT
; _this$ = ecx

; 2334 : {

	push	ebx

; 2335 : 	int iI;
; 2336 : 
; 2337 : 	int iIndex = GetCityIndexFromPlot(pPlot);

	mov	ebx, DWORD PTR _pPlot$[esp]
	push	esi
	push	edi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	push	ebx
	push	eax
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY

; 2338 : 
; 2339 : 	CvAssertMsg(iIndex >= 0, "iIndex expected to be >= 0");
; 2340 : 	CvAssertMsg(iIndex < NUM_CITY_PLOTS, "iIndex expected to be < NUM_CITY_PLOTS");
; 2341 : 
; 2342 : 	if(IsWorkingPlot(pPlot) != bNewValue && iIndex >= 0 && iIndex < NUM_CITY_PLOTS)

	mov	ecx, DWORD PTR [esi]
	push	ebx
	push	ecx
	mov	edi, eax
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	or	edx, -1
	add	esp, 16					; 00000010H
	cmp	eax, edx
	je	SHORT $LN21@SetWorking
	mov	al, BYTE PTR [eax+esi+25]
	jmp	SHORT $LN22@SetWorking
$LN21@SetWorking:
	xor	al, al
$LN22@SetWorking:
	mov	cl, BYTE PTR _bNewValue$[esp+8]
	cmp	al, cl
	je	$LN16@SetWorking
	cmp	edi, 36					; 00000024H
	ja	$LN16@SetWorking

; 2343 : 	{
; 2344 : 		m_pabWorkingPlot[iIndex] = bNewValue;

	mov	BYTE PTR [edi+esi+25], cl

; 2345 : 
; 2346 : 		// Don't look at the center Plot of a City, because we always work it for free
; 2347 : 		if(iIndex != CITY_HOME_PLOT)

	test	edi, edi
	je	SHORT $LN52@SetWorking

; 2348 : 		{
; 2349 : 			// Alter the count of Plots being worked by Citizens
; 2350 : 			if(bNewValue)

	test	cl, cl
	je	SHORT $LN14@SetWorking

; 2351 : 			{
; 2352 : 				ChangeNumCitizensWorkingPlots(1);

	inc	DWORD PTR [esi+12]

; 2353 : 
; 2354 : 				if(bUseUnassignedPool)

	cmp	BYTE PTR _bUseUnassignedPool$[esp+8], 0
	je	SHORT $LN52@SetWorking

; 2355 : 				{
; 2356 : 					ChangeNumUnassignedCitizens(-1);

	add	DWORD PTR [esi+8], edx

; 2357 : 				}
; 2358 : 			}
; 2359 : 			else

	jmp	SHORT $LN52@SetWorking
$LN14@SetWorking:

; 2360 : 			{
; 2361 : 				ChangeNumCitizensWorkingPlots(-1);

	add	DWORD PTR [esi+12], edx

; 2362 : 
; 2363 : 				if(bUseUnassignedPool)

	cmp	BYTE PTR _bUseUnassignedPool$[esp+8], 0
	je	SHORT $LN52@SetWorking

; 2364 : 				{
; 2365 : 					ChangeNumUnassignedCitizens(1);

	inc	DWORD PTR [esi+8]
$LN52@SetWorking:

; 2366 : 				}
; 2367 : 			}
; 2368 : 		}
; 2369 : 
; 2370 : 		if(pPlot != NULL)

	test	ebx, ebx
	je	SHORT $LN2@SetWorking
	push	ebp

; 2371 : 		{
; 2372 : 			// investigate later
; 2373 : 			//CvAssertMsg(pPlot->getWorkingCity() == GetCity(), "WorkingCity is expected to be this");
; 2374 : 
; 2375 : 			// Now working pPlot
; 2376 : 			if(IsWorkingPlot(pPlot))

	push	ebx
	mov	ecx, esi
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot

; 2377 : 			{
; 2378 : 				//if (iIndex != CITY_HOME_PLOT)
; 2379 : 				//{
; 2380 : 				//	GetCity()->changeWorkingPopulation(1);
; 2381 : 				//}
; 2382 : 
; 2383 : 				for(iI = 0; iI < NUM_YIELD_TYPES; iI++)

	xor	edi, edi
	test	al, al
	je	SHORT $LL4@SetWorking
	npad	1
$LL8@SetWorking:

; 2384 : 				{
; 2385 : 					GetCity()->ChangeBaseYieldRateFromTerrain(((YieldTypes)iI), pPlot->getYield((YieldTypes)iI));

	mov	ebp, DWORD PTR [esi]
	push	edi
	mov	ecx, ebx
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	push	eax
	push	edi
	mov	ecx, ebp
	call	?ChangeBaseYieldRateFromTerrain@CvCity@@QAEXW4YieldTypes@@H@Z ; CvCity::ChangeBaseYieldRateFromTerrain
	inc	edi
	cmp	edi, 6
	jl	SHORT $LL8@SetWorking

; 2386 : 				}
; 2387 : 			}
; 2388 : 			// No longer working pPlot
; 2389 : 			else

	jmp	SHORT $LN54@SetWorking
	npad	5
$LL4@SetWorking:

; 2390 : 			{
; 2391 : 				//if (iIndex != CITY_HOME_PLOT)
; 2392 : 				//{
; 2393 : 				//	GetCity()->changeWorkingPopulation(-1);
; 2394 : 				//}
; 2395 : 
; 2396 : 				for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
; 2397 : 				{
; 2398 : 					GetCity()->ChangeBaseYieldRateFromTerrain(((YieldTypes)iI), -pPlot->getYield((YieldTypes)iI));

	mov	ebp, DWORD PTR [esi]
	push	edi
	mov	ecx, ebx
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	neg	eax
	push	eax
	push	edi
	mov	ecx, ebp
	call	?ChangeBaseYieldRateFromTerrain@CvCity@@QAEXW4YieldTypes@@H@Z ; CvCity::ChangeBaseYieldRateFromTerrain
	inc	edi
	cmp	edi, 6
	jl	SHORT $LL4@SetWorking
$LN54@SetWorking:
	pop	ebp
$LN2@SetWorking:

; 2399 : 				}
; 2400 : 			}
; 2401 : 		}
; 2402 : 
; 2403 : 		if(GetCity()->isCitySelected())

	mov	ecx, DWORD PTR [esi]
	call	?isCitySelected@CvCity@@QAE_NXZ		; CvCity::isCitySelected
	test	al, al
	je	SHORT $LN53@SetWorking

; 2404 : 		{
; 2405 : 			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	18					; 00000012H
	call	eax

; 2406 : 			//GC.GetEngineUserInterface()->setDirty(InfoPane_DIRTY_BIT, true );
; 2407 : 			GC.GetEngineUserInterface()->setDirty(CityScreen_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	21					; 00000015H
	call	eax

; 2408 : 			GC.GetEngineUserInterface()->setDirty(ColoredPlots_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	24					; 00000018H
	call	eax
$LN53@SetWorking:

; 2409 : 		}
; 2410 : 
; 2411 : 		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	18					; 00000012H
	call	eax
$LN16@SetWorking:
	pop	edi
	pop	esi
	pop	ebx

; 2412 : 	}
; 2413 : }

	ret	12					; 0000000cH
?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z ENDP ; CvCityCitizens::SetWorkingPlot
_TEXT	ENDS
PUBLIC	?IsForcedWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsForcedWorkingPlot
; Function compile flags: /Ogtpy
;	COMDAT ?IsForcedWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?IsForcedWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z PROC ; CvCityCitizens::IsForcedWorkingPlot, COMDAT
; _this$ = ecx

; 2545 : 	int iIndex;
; 2546 : 
; 2547 : 	iIndex = GetCityIndexFromPlot(pPlot);

	mov	eax, DWORD PTR _pPlot$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	add	esp, 8

; 2548 : 
; 2549 : 	if(iIndex != -1)

	cmp	eax, -1
	je	SHORT $LN1@IsForcedWo

; 2550 : 	{
; 2551 : 		return m_pabForcedWorkingPlot[iIndex];

	mov	al, BYTE PTR [eax+esi+62]
	pop	esi

; 2555 : }

	ret	4
$LN1@IsForcedWo:

; 2552 : 	}
; 2553 : 
; 2554 : 	return false;

	xor	al, al
	pop	esi

; 2555 : }

	ret	4
?IsForcedWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ENDP ; CvCityCitizens::IsForcedWorkingPlot
_TEXT	ENDS
PUBLIC	?IsCanAddSpecialistToBuilding@CvCityCitizens@@QAE_NW4BuildingTypes@@@Z ; CvCityCitizens::IsCanAddSpecialistToBuilding
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?IsCanAddSpecialistToBuilding@CvCityCitizens@@QAE_NW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eBuilding$ = 8						; size = 4
?IsCanAddSpecialistToBuilding@CvCityCitizens@@QAE_NW4BuildingTypes@@@Z PROC ; CvCityCitizens::IsCanAddSpecialistToBuilding, COMDAT
; _this$ = ecx

; 3162 : 	CvAssert(eBuilding > -1);
; 3163 : 	CvAssert(eBuilding < GC.getNumBuildingInfos());
; 3164 : #ifdef AUI_WARNING_FIXES
; 3165 : 	CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);
; 3166 : 	if (!pBuildingInfo)
; 3167 : 		return false;
; 3168 : #endif
; 3169 : 
; 3170 : 	int iNumSpecialistsAssigned = GetNumSpecialistsInBuilding(eBuilding);

	mov	eax, DWORD PTR [ecx+116]

; 3171 : 
; 3172 : 	if(iNumSpecialistsAssigned < GetCity()->getPopulation() &&	// Limit based on Pop of City
; 3173 : #ifdef AUI_WARNING_FIXES
; 3174 : 		iNumSpecialistsAssigned < pBuildingInfo->GetSpecialistCount() &&				// Limit for this particular Building
; 3175 : #else
; 3176 : 	        iNumSpecialistsAssigned < GC.getBuildingInfo(eBuilding)->GetSpecialistCount() &&				// Limit for this particular Building
; 3177 : #endif
; 3178 : 	        iNumSpecialistsAssigned < GC.getMAX_SPECIALISTS_FROM_BUILDING())	// Overall Limit

	mov	ecx, DWORD PTR [ecx]
	push	esi
	push	edi
	mov	edi, DWORD PTR _eBuilding$[esp+4]
	mov	esi, DWORD PTR [eax+edi*4]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	esi, eax
	jge	SHORT $LN1@IsCanAddSp
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ecx, eax
	call	?GetSpecialistCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistCount
	cmp	esi, eax
	jge	SHORT $LN1@IsCanAddSp
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7100
	jge	SHORT $LN1@IsCanAddSp
	pop	edi

; 3179 : 	{
; 3180 : 		return true;

	mov	al, 1
	pop	esi

; 3184 : }

	ret	4
$LN1@IsCanAddSp:
	pop	edi

; 3181 : 	}
; 3182 : 
; 3183 : 	return false;

	xor	al, al
	pop	esi

; 3184 : }

	ret	4
?IsCanAddSpecialistToBuilding@CvCityCitizens@@QAE_NW4BuildingTypes@@@Z ENDP ; CvCityCitizens::IsCanAddSpecialistToBuilding
_TEXT	ENDS
PUBLIC	?ChangeNumDefaultSpecialists@CvCityCitizens@@QAEXH@Z ; CvCityCitizens::ChangeNumDefaultSpecialists
EXTRN	?processSpecialist@CvCity@@QAEXW4SpecialistTypes@@H@Z:PROC ; CvCity::processSpecialist
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumDefaultSpecialists@CvCityCitizens@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeNumDefaultSpecialists@CvCityCitizens@@QAEXH@Z PROC ; CvCityCitizens::ChangeNumDefaultSpecialists, COMDAT
; _this$ = ecx

; 3452 : {

	push	esi
	push	edi

; 3453 : 	m_iNumDefaultSpecialists += iChange;

	mov	edi, DWORD PTR _iChange$[esp+4]
	mov	esi, ecx
	add	DWORD PTR [esi+100], edi

; 3454 : 
; 3455 : 	SpecialistTypes eSpecialist = (SpecialistTypes) GC.getDEFAULT_SPECIALIST();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8420

; 3456 : 	m_aiSpecialistCounts[eSpecialist] += iChange;

	mov	ecx, DWORD PTR [esi+108]
	add	DWORD PTR [ecx+eax*4], edi
	lea	ecx, DWORD PTR [ecx+eax*4]

; 3457 : 
; 3458 : 	GetCity()->processSpecialist(eSpecialist, iChange);

	mov	ecx, DWORD PTR [esi]
	push	edi
	push	eax
	call	?processSpecialist@CvCity@@QAEXW4SpecialistTypes@@H@Z ; CvCity::processSpecialist

; 3459 : 
; 3460 : 	ChangeNumUnassignedCitizens(-iChange);

	sub	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 3461 : }

	ret	4
?ChangeNumDefaultSpecialists@CvCityCitizens@@QAEXH@Z ENDP ; CvCityCitizens::ChangeNumDefaultSpecialists
_TEXT	ENDS
PUBLIC	?GetTotalSpecialistCount@CvCityCitizens@@QBEHXZ	; CvCityCitizens::GetTotalSpecialistCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetTotalSpecialistCount@CvCityCitizens@@QBEHXZ
_TEXT	SEGMENT
?GetTotalSpecialistCount@CvCityCitizens@@QBEHXZ PROC	; CvCityCitizens::GetTotalSpecialistCount, COMDAT
; _this$ = ecx

; 3486 : {

	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 3487 : 	int iNumSpecialists = 0;
; 3488 : 	SpecialistTypes eSpecialist;
; 3489 : 
; 3490 : #ifdef AUI_WARNING_FIXES
; 3491 : 	for (uint iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
; 3492 : #else
; 3493 : 	for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	xor	esi, esi
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	test	eax, eax
	jle	SHORT $LN13@GetTotalSp
$LL4@GetTotalSp:

; 3494 : #endif
; 3495 : 	{
; 3496 : 		eSpecialist = (SpecialistTypes) iSpecialistLoop;
; 3497 : 
; 3498 : 		if (eSpecialist != (SpecialistTypes) GC.getDEFAULT_SPECIALIST())

	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8420
	je	SHORT $LN3@GetTotalSp

; 3499 : 		{
; 3500 : 			iNumSpecialists += GetSpecialistCount(eSpecialist);

	mov	eax, DWORD PTR [ebx+108]
	add	edi, DWORD PTR [eax+esi*4]
$LN3@GetTotalSp:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	cmp	esi, eax
	jl	SHORT $LL4@GetTotalSp
$LN13@GetTotalSp:

; 3501 : 		}
; 3502 : 	}
; 3503 : 
; 3504 : 	return iNumSpecialists;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3505 : }

	ret	0
?GetTotalSpecialistCount@CvCityCitizens@@QBEHXZ ENDP	; CvCityCitizens::GetTotalSpecialistCount
_TEXT	ENDS
PUBLIC	?GetSpecialistGreatPersonProgress@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z ; CvCityCitizens::GetSpecialistGreatPersonProgress
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistGreatPersonProgress@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetSpecialistGreatPersonProgress@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z PROC ; CvCityCitizens::GetSpecialistGreatPersonProgress, COMDAT
; _this$ = ecx

; 3528 : 	CvAssert(eIndex > -1);
; 3529 : 	CvAssert(eIndex < GC.getNumSpecialistInfos());
; 3530 : 
; 3531 : 	return GetSpecialistGreatPersonProgressTimes100(eIndex) / 100;

	mov	eax, DWORD PTR [ecx+112]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 3532 : }

	ret	4
?GetSpecialistGreatPersonProgress@CvCityCitizens@@QBEHW4SpecialistTypes@@@Z ENDP ; CvCityCitizens::GetSpecialistGreatPersonProgress
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	??$?5_N$0CF@@@YAAAVFDataStream@@AAV0@AAY0CF@_N@Z ; operator>><bool,37>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N$0CF@@@YAAAVFDataStream@@AAV0@AAY0CF@_N@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5_N$0CF@@@YAAAVFDataStream@@AAV0@AAY0CF@_N@Z PROC	; operator>><bool,37>, COMDAT

; 234  : {

	push	ebx

; 235  : 	size_t i = 0;
; 236  : 	for(i = 0; i < count; ++i)

	mov	ebx, DWORD PTR _writeTo$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _loadFrom$[esp+8]
	xor	esi, esi
	npad	3
$LL3@operator@2:

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	esi
	cmp	esi, 37					; 00000025H
	jb	SHORT $LL3@operator@2

; 239  : 	}
; 240  : 	return loadFrom;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 241  : }

	ret	0
??$?5_N$0CF@@@YAAAVFDataStream@@AAV0@AAY0CF@_N@Z ENDP	; operator>><bool,37>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_bValid$226489 = -13					; size = 1
_uiNumEntries$ = -12					; size = 4
_tValue$226492 = -8					; size = 4
_tValue$226497 = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiNumEntries$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+24], ebx
	jbe	SHORT $LN5@ReadHashed
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+24]
	push	esi
$LL7@ReadHashed:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$226489[esp+32]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$226492[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	eax, DWORD PTR _tValue$226492[esp+32]
	mov	ecx, DWORD PTR _paArray$[esp+28]
	mov	DWORD PTR [ecx+esi*4], eax

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$226489[esp+32], 0
	jne	SHORT $LN6@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$226497[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN6@ReadHashed:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+32]
	jb	SHORT $LL7@ReadHashed
	pop	esi
	pop	ebp
$LN5@ReadHashed:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 16					; 00000010H
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
_TEXT	ENDS
PUBLIC	??$?6_N$0CF@@@YAAAVFDataStream@@AAV0@AAY0CF@$$CB_N@Z ; operator<<<bool,37>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6_N$0CF@@@YAAAVFDataStream@@AAV0@AAY0CF@$$CB_N@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6_N$0CF@@@YAAAVFDataStream@@AAV0@AAY0CF@$$CB_N@Z PROC ; operator<<<bool,37>, COMDAT

; 223  : {

	push	ebx

; 224  : 	size_t i = 0;
; 225  : 	for(i = 0; i < count; ++i)

	mov	ebx, DWORD PTR _readFrom$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+8]
	xor	esi, esi
	npad	3
$LL3@operator@3:

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	esi
	cmp	esi, 37					; 00000025H
	jb	SHORT $LL3@operator@3

; 228  : 	}
; 229  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 230  : }

	ret	0
??$?6_N$0CF@@@YAAAVFDataStream@@AAV0@AAY0CF@$$CB_N@Z ENDP ; operator<<<bool,37>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4SpecialistTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum SpecialistTypes,int>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4SpecialistTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4SpecialistTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4SpecialistTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum SpecialistTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4SpecialistTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe
	pop	edi
$LN2@WriteHashe:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4SpecialistTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum SpecialistTypes,int>
_TEXT	ENDS
PUBLIC	??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ ; std::auto_ptr<ICvCity1>::operator<ICvCity1> std::auto_ptr_ref<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ PROC ; std::auto_ptr<ICvCity1>::operator<ICvCity1> std::auto_ptr_ref<ICvCity1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ ENDP ; std::auto_ptr<ICvCity1>::operator<ICvCity1> std::auto_ptr_ref<ICvCity1>
_TEXT	ENDS
PUBLIC	?GetID@CvCity@@QBEHXZ				; CvCity::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?GetID@CvCity@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvCity@@QBEHXZ PROC				; CvCity::GetID, COMDAT
; _this$ = ecx

; 331  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+120]

; 332  : 	}

	ret	0
?GetID@CvCity@@QBEHXZ ENDP				; CvCity::GetID
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 239  : 	// convert the start coord to hex-space coordinates
; 240  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 241  : 
; 242  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 243  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 244  : 
; 245  : 	// convert from hex-space coordinates to the storage array
; 246  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 249  : }

	ret	0

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 249  : }

	ret	0

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 249  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	??1CvCityCitizens@@QAE@XZ			; CvCityCitizens::~CvCityCitizens
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitycitizens.cpp
;	COMDAT ??1CvCityCitizens@@QAE@XZ
_TEXT	SEGMENT
??1CvCityCitizens@@QAE@XZ PROC				; CvCityCitizens::~CvCityCitizens, COMDAT
; _this$ = ecx

; 48   : 	Uninit();

	jmp	?Uninit@CvCityCitizens@@QAEXXZ		; CvCityCitizens::Uninit
??1CvCityCitizens@@QAE@XZ ENDP				; CvCityCitizens::~CvCityCitizens
_TEXT	ENDS
PUBLIC	?Read@CvCityCitizens@@QAEXAAVFDataStream@@@Z	; CvCityCitizens::Read
EXTRN	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z:PROC ; BuildingArrayHelpers::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4CityAIFocusTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvCityCitizens@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvCityCitizens@@QAEXAAVFDataStream@@@Z PROC	; CvCityCitizens::Read, COMDAT
; _this$ = ecx

; 173  : {

	push	ebx
	push	esi
	push	edi

; 174  : 	// Version number to maintain backwards compatibility
; 175  : 	uint uiVersion;
; 176  : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _uiVersion$[esp+8]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 177  : 
; 178  : 	kStream >> m_bAutomated;

	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 179  : 	kStream >> m_bNoAutoAssignSpecialists;

	lea	edx, DWORD PTR [esi+5]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 180  : 	kStream >> m_iNumUnassignedCitizens;

	lea	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 181  : 	kStream >> m_iNumCitizensWorkingPlots;

	lea	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 182  : 	kStream >> m_iNumForcedWorkingPlots;

	lea	edx, DWORD PTR [esi+16]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 183  : 
; 184  : 	kStream >> m_eCityAIFocusTypes;

	lea	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4CityAIFocusTypes@@@Z ; operator>>
	add	esp, 8

; 185  : 
; 186  : 	kStream >> 	m_bForceAvoidGrowth;

	lea	ecx, DWORD PTR [esi+24]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 187  : 
; 188  : 	kStream >> m_pabWorkingPlot;

	xor	ebx, ebx
$LL19@Read:
	lea	edx, DWORD PTR [esi+ebx+25]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	ebx
	cmp	ebx, 37					; 00000025H
	jb	SHORT $LL19@Read

; 189  : 	kStream >> m_pabForcedWorkingPlot;

	xor	ebx, ebx
	npad	6
$LL26@Read:
	lea	eax, DWORD PTR [esi+ebx+62]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	ebx
	cmp	ebx, 37					; 00000025H
	jb	SHORT $LL26@Read

; 190  : 
; 191  : 	kStream >> m_iNumDefaultSpecialists;

	lea	ecx, DWORD PTR [esi+100]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 192  : 	kStream >> m_iNumForcedDefaultSpecialists;

	lea	edx, DWORD PTR [esi+104]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 193  : 
; 194  : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_aiSpecialistCounts, GC.getNumSpecialistInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	push	eax
	mov	eax, DWORD PTR [esi+108]
	push	eax
	push	edi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 195  : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_aiSpecialistGreatPersonProgressTimes100, GC.getNumSpecialistInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	mov	ecx, DWORD PTR [esi+112]
	push	eax
	push	ecx
	push	edi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>

; 196  : 
; 197  : 	BuildingArrayHelpers::Read(kStream, m_aiNumSpecialistsInBuilding);

	mov	edx, DWORD PTR [esi+116]
	push	edx
	push	edi
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read

; 198  : 	BuildingArrayHelpers::Read(kStream, m_aiNumForcedSpecialistsInBuilding);

	mov	eax, DWORD PTR [esi+120]
	push	eax
	push	edi
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read
	add	esp, 28					; 0000001cH

; 199  : 
; 200  : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_piBuildingGreatPeopleRateChanges, GC.getNumSpecialistInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	mov	ecx, DWORD PTR [esi+124]
	push	eax
	push	ecx
	push	edi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 201  : }

	ret	4
?Read@CvCityCitizens@@QAEXAAVFDataStream@@@Z ENDP	; CvCityCitizens::Read
_TEXT	ENDS
PUBLIC	?Write@CvCityCitizens@@QAEXAAVFDataStream@@@Z	; CvCityCitizens::Write
EXTRN	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z:PROC ; BuildingArrayHelpers::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4CityAIFocusTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvCityCitizens@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvCityCitizens@@QAEXAAVFDataStream@@@Z PROC	; CvCityCitizens::Write, COMDAT
; _this$ = ecx

; 205  : {

	push	ecx
	push	ebx
	push	esi
	push	edi

; 206  : 	// Current version number
; 207  : 	uint uiVersion = 1;
; 208  : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+20], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 209  : 
; 210  : 	kStream << m_bAutomated;

	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 211  : 	kStream << m_bNoAutoAssignSpecialists;

	lea	edx, DWORD PTR [esi+5]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 212  : 	kStream << m_iNumUnassignedCitizens;

	lea	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 213  : 	kStream << m_iNumCitizensWorkingPlots;

	lea	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 214  : 	kStream << m_iNumForcedWorkingPlots;

	lea	edx, DWORD PTR [esi+16]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 215  : 
; 216  : 	kStream << m_eCityAIFocusTypes;

	lea	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4CityAIFocusTypes@@@Z ; operator<<
	add	esp, 8

; 217  : 
; 218  : 	kStream << 	m_bForceAvoidGrowth;

	lea	ecx, DWORD PTR [esi+24]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 219  : 
; 220  : 	kStream << m_pabWorkingPlot;

	xor	ebx, ebx
	npad	1
$LL19@Write:
	lea	edx, DWORD PTR [esi+ebx+25]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, 37					; 00000025H
	jb	SHORT $LL19@Write

; 221  : 	kStream << m_pabForcedWorkingPlot;

	xor	ebx, ebx
$LL26@Write:
	lea	eax, DWORD PTR [esi+ebx+62]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, 37					; 00000025H
	jb	SHORT $LL26@Write

; 222  : 
; 223  : 	kStream << m_iNumDefaultSpecialists;

	lea	ecx, DWORD PTR [esi+100]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 224  : 	kStream << m_iNumForcedDefaultSpecialists;

	lea	edx, DWORD PTR [esi+104]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 225  : 
; 226  : 	CvInfosSerializationHelper::WriteHashedDataArray<SpecialistTypes, int>(kStream, m_aiSpecialistCounts, GC.getNumSpecialistInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	push	eax
	mov	eax, DWORD PTR [esi+108]
	push	eax
	push	edi
	call	??$WriteHashedDataArray@W4SpecialistTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum SpecialistTypes,int>
	add	esp, 12					; 0000000cH

; 227  : 	CvInfosSerializationHelper::WriteHashedDataArray<SpecialistTypes, int>(kStream, m_aiSpecialistGreatPersonProgressTimes100, GC.getNumSpecialistInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	mov	ecx, DWORD PTR [esi+112]
	push	eax
	push	ecx
	push	edi
	call	??$WriteHashedDataArray@W4SpecialistTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum SpecialistTypes,int>
	add	esp, 12					; 0000000cH

; 228  : 
; 229  : 	BuildingArrayHelpers::Write(kStream, m_aiNumSpecialistsInBuilding, GC.getNumBuildingInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	mov	edx, DWORD PTR [esi+116]
	push	eax
	push	edx
	push	edi
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 230  : 	BuildingArrayHelpers::Write(kStream, m_aiNumForcedSpecialistsInBuilding, GC.getNumBuildingInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	push	eax
	mov	eax, DWORD PTR [esi+120]
	push	eax
	push	edi
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 	CvInfosSerializationHelper::WriteHashedDataArray<SpecialistTypes, int>(kStream, m_piBuildingGreatPeopleRateChanges, GC.getNumSpecialistInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	mov	ecx, DWORD PTR [esi+124]
	push	eax
	push	ecx
	push	edi
	call	??$WriteHashedDataArray@W4SpecialistTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum SpecialistTypes,int>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 233  : }

	pop	ecx
	ret	4
?Write@CvCityCitizens@@QAEXAAVFDataStream@@@Z ENDP	; CvCityCitizens::Write
_TEXT	ENDS
PUBLIC	?GetOwner@CvCityCitizens@@QBE?AW4PlayerTypes@@XZ ; CvCityCitizens::GetOwner
; Function compile flags: /Ogtpy
;	COMDAT ?GetOwner@CvCityCitizens@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetOwner@CvCityCitizens@@QBE?AW4PlayerTypes@@XZ PROC	; CvCityCitizens::GetOwner, COMDAT
; _this$ = ecx

; 258  : 	return m_pCity->getOwner();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+84]

; 259  : }

	ret	0
?GetOwner@CvCityCitizens@@QBE?AW4PlayerTypes@@XZ ENDP	; CvCityCitizens::GetOwner
_TEXT	ENDS
PUBLIC	?IsPlotBlockaded@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsPlotBlockaded
EXTRN	?HasAlliedUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z:PROC ; CvPlot::HasAlliedUnit
EXTRN	?IsActualEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z:PROC ; CvPlot::IsActualEnemyUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsPlotBlockaded@CvCityCitizens@@QBE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_iBlockadeDistance$ = -24				; size = 4
_iDX$ = -20						; size = 4
_iClosestAllyDistance$ = -16				; size = 4
_iClosestEnemyDistance$ = -12				; size = 4
_ePlayer$ = -8						; size = 4
tv229 = -4						; size = 4
_iDY$ = 8						; size = 4
_pPlot$ = 8						; size = 4
?IsPlotBlockaded@CvCityCitizens@@QBE_NPAVCvPlot@@@Z PROC ; CvCityCitizens::IsPlotBlockaded, COMDAT
; _this$ = ecx

; 2704 : {

	sub	esp, 24					; 00000018H

; 2705 : 	// See if there are any enemy boats near us that are blockading this plot
; 2706 : 	int iBlockadeDistance = /*2*/ GC.getNAVAL_PLOT_BLOCKADE_RANGE();
; 2707 : 	int iDX, iDY;
; 2708 : 	CvPlot* pNearbyPlot;
; 2709 : #ifdef AUI_CITY_CITIZENS_COUNTERBLOCKADE
; 2710 : 	int iClosestEnemyDistance = MAX_INT;
; 2711 : 	int iClosestAllyDistance = MAX_INT - 1;
; 2712 : 	int iLoopDistance = 0;
; 2713 : #endif
; 2714 : 
; 2715 : 	PlayerTypes ePlayer = m_pCity->getOwner();

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6172
	mov	DWORD PTR _ePlayer$[esp+24], ecx

; 2716 : 
; 2717 : 	// Might be a better way to do this that'd be slightly less CPU-intensive
; 2718 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2719 : 	int iMaxDX;
; 2720 : 	for (iDY = -iBlockadeDistance; iDY <= iBlockadeDistance; iDY++)
; 2721 : 	{
; 2722 : 		iMaxDX = iBlockadeDistance - MAX(0, iDY);
; 2723 : 		for (iDX = -iBlockadeDistance - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2724 : #else
; 2725 : 	for(iDX = -(iBlockadeDistance); iDX <= iBlockadeDistance; iDX++)

	mov	ecx, edx
	neg	ecx
	mov	eax, ecx
	cmp	eax, edx
	mov	DWORD PTR _iBlockadeDistance$[esp+24], edx
	mov	DWORD PTR _iClosestEnemyDistance$[esp+24], 2147483647 ; 7fffffffH
	mov	DWORD PTR _iClosestAllyDistance$[esp+24], 2147483646 ; 7ffffffeH
	mov	DWORD PTR tv229[esp+24], ecx
	mov	DWORD PTR _iDX$[esp+24], ecx
	jg	$LN11@IsPlotBloc
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _pPlot$[esp+36]
$LL13@IsPlotBloc:

; 2726 : 	{
; 2727 : 		for(iDY = -(iBlockadeDistance); iDY <= iBlockadeDistance; iDY++)

	cmp	ecx, edx
	mov	DWORD PTR _iDY$[esp+36], ecx
	jg	$LN12@IsPlotBloc
	jmp	SHORT $LN10@IsPlotBloc
$LL60@IsPlotBloc:
	mov	ecx, DWORD PTR _iDY$[esp+36]
$LN10@IsPlotBloc:

; 2728 : #endif
; 2729 : 		{
; 2730 : 			pNearbyPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);

	movsx	ebp, WORD PTR [edi+2]
	movsx	ebx, WORD PTR [edi]
	push	ecx
	push	eax
	push	ebp
	push	ebx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	esi, eax
	add	esp, 16					; 00000010H

; 2731 : 
; 2732 : 			if(pNearbyPlot != NULL)

	test	esi, esi
	je	$LN9@IsPlotBloc

; 2733 : 			{
; 2734 : 				// Must be water in the same Area
; 2735 : 				if(pNearbyPlot->isWater() && pNearbyPlot->getArea() == pPlot->getArea())

	cmp	BYTE PTR [esi+5], 3
	jne	$LN9@IsPlotBloc
	mov	edx, DWORD PTR [esi+356]
	cmp	edx, DWORD PTR [edi+356]
	jne	$LN9@IsPlotBloc

; 2736 : 				{
; 2737 : #ifndef AUI_HEXSPACE_DX_LOOPS
; 2738 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 2739 : 					if (hexDistance(iDX, iDY) <= iBlockadeDistance)
; 2740 : #else
; 2741 : 					if(plotDistance(pNearbyPlot->getX(), pNearbyPlot->getY(), pPlot->getX(), pPlot->getY()) <= iBlockadeDistance)

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	ebp
	push	ebx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iBlockadeDistance$[esp+40]
	jg	SHORT $LN9@IsPlotBloc

; 2742 : #endif
; 2743 : #endif
; 2744 : 					{
; 2745 : 						// Enemy boat within range to blockade our plot?
; 2746 : 						if(pNearbyPlot->IsActualEnemyUnit(ePlayer))

	mov	ebx, DWORD PTR _ePlayer$[esp+40]
	push	1
	push	ebx
	mov	ecx, esi
	call	?IsActualEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ; CvPlot::IsActualEnemyUnit
	test	al, al
	je	SHORT $LN3@IsPlotBloc

; 2747 : 						{
; 2748 : #ifdef AUI_CITY_CITIZENS_COUNTERBLOCKADE
; 2749 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2750 : 							iLoopDistance = hexDistance(iDX, iDY);
; 2751 : #else
; 2752 : 							iLoopDistance = plotDistance(pPlot->getX(), pPlot->getY(), pNearbyPlot->getX(), pNearbyPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	movsx	ecx, WORD PTR [edi+2]
	push	edx
	movsx	edx, WORD PTR [edi]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 2753 : #endif
; 2754 : 							if (iLoopDistance < iClosestEnemyDistance)

	cmp	eax, DWORD PTR _iClosestEnemyDistance$[esp+40]
	jge	SHORT $LN3@IsPlotBloc

; 2755 : 								iClosestEnemyDistance = iLoopDistance;

	mov	DWORD PTR _iClosestEnemyDistance$[esp+40], eax
$LN3@IsPlotBloc:

; 2756 : 						}
; 2757 : 
; 2758 : 						if (pNearbyPlot->HasAlliedUnit(ePlayer))

	push	1
	push	ebx
	mov	ecx, esi
	call	?HasAlliedUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ; CvPlot::HasAlliedUnit
	test	al, al
	je	SHORT $LN9@IsPlotBloc

; 2759 : 						{
; 2760 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2761 : 							iLoopDistance = hexDistance(iDX, iDY);
; 2762 : #else
; 2763 : 							iLoopDistance = plotDistance(pPlot->getX(), pPlot->getY(), pNearbyPlot->getX(), pNearbyPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	movsx	edx, WORD PTR [edi+2]
	push	eax
	movsx	eax, WORD PTR [edi]
	push	ecx
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 2764 : #endif
; 2765 : 							if (iLoopDistance < iClosestAllyDistance)

	cmp	eax, DWORD PTR _iClosestAllyDistance$[esp+40]
	jge	SHORT $LN9@IsPlotBloc

; 2766 : 								iClosestAllyDistance = iLoopDistance;

	mov	DWORD PTR _iClosestAllyDistance$[esp+40], eax
$LN9@IsPlotBloc:

; 2726 : 	{
; 2727 : 		for(iDY = -(iBlockadeDistance); iDY <= iBlockadeDistance; iDY++)

	mov	eax, DWORD PTR _iDY$[esp+36]
	inc	eax
	cmp	eax, DWORD PTR _iBlockadeDistance$[esp+40]
	mov	DWORD PTR _iDY$[esp+36], eax
	mov	eax, DWORD PTR _iDX$[esp+40]
	jle	$LL60@IsPlotBloc
	mov	edx, DWORD PTR _iBlockadeDistance$[esp+40]
	mov	ecx, DWORD PTR tv229[esp+40]
$LN12@IsPlotBloc:
	inc	eax
	cmp	eax, edx
	mov	DWORD PTR _iDX$[esp+40], eax
	jle	$LL13@IsPlotBloc
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN11@IsPlotBloc:

; 2767 : #else
; 2768 : 							return true;
; 2769 : #endif
; 2770 : 						}
; 2771 : 					}
; 2772 : 				}
; 2773 : 			}
; 2774 : 		}
; 2775 : 	}
; 2776 : #ifdef AUI_CITY_CITIZENS_COUNTERBLOCKADE
; 2777 : 	return iClosestEnemyDistance < iClosestAllyDistance;

	mov	ecx, DWORD PTR _iClosestAllyDistance$[esp+24]
	xor	eax, eax
	cmp	DWORD PTR _iClosestEnemyDistance$[esp+24], ecx
	setl	al

; 2778 : #else
; 2779 : 	return false;
; 2780 : #endif
; 2781 : }

	add	esp, 24					; 00000018H
	ret	4
?IsPlotBlockaded@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ENDP ; CvCityCitizens::IsPlotBlockaded
_TEXT	ENDS
PUBLIC	?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z ; CvCityCitizens::GetCityPlotFromIndex
EXTRN	?plotCity@@YAPAVCvPlot@@HHH@Z:PROC		; plotCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z PROC ; CvCityCitizens::GetCityPlotFromIndex, COMDAT
; _this$ = ecx

; 2913 : 	return plotCity(m_pCity->getX(), m_pCity->getY(), iIndex);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _iIndex$[esp-4]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	edx
	push	ecx
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH

; 2914 : }

	ret	4
?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z ENDP ; CvCityCitizens::GetCityPlotFromIndex
_TEXT	ENDS
PUBLIC	?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z ; CvCityCitizens::DoRemoveSpecialistFromBuilding
EXTRN	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z:PROC ; CvGlobals::WrapCityPointer
EXTRN	?changePopulation@CvCity@@QAEXH_N@Z:PROC	; CvCity::changePopulation
EXTRN	?UpdateReligion@CvCity@@QAEXW4ReligionTypes@@@Z:PROC ; CvCity::UpdateReligion
EXTRN	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ:PROC ; CvCityReligions::GetReligiousMajority
EXTRN	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ:PROC ; CvCity::GetCityReligions
EXTRN	?GetSpecialistType@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetSpecialistType
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z$1
__ehfuncinfo$?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitycitizens.cpp
xdata$x	ENDS
;	COMDAT ?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_eBuilding$ = 8						; size = 4
$T227948 = 12						; size = 4
_bForced$ = 12						; size = 1
_pCity$226268 = 16					; size = 4
_bEliminatePopulation$ = 16				; size = 1
?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z PROC ; CvCityCitizens::DoRemoveSpecialistFromBuilding, COMDAT
; _this$ = ecx

; 3254 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	push	edi

; 3255 : 	CvAssert(eBuilding > -1);
; 3256 : 	CvAssert(eBuilding < GC.getNumBuildingInfos());
; 3257 : 
; 3258 : 	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	mov	edi, DWORD PTR _eBuilding$[esp+16]
	mov	esi, ecx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 3259 : 	if(pkBuildingInfo == NULL)

	test	eax, eax
	je	$LN49@DoRemoveSp

; 3260 : 	{
; 3261 : 		return;
; 3262 : 	}
; 3263 : 
; 3264 : 	SpecialistTypes eSpecialist = (SpecialistTypes) pkBuildingInfo->GetSpecialistType();

	mov	ecx, eax
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType

; 3265 : 
; 3266 : 	int iNumSpecialistsAssigned = GetNumSpecialistsInBuilding(eBuilding);

	mov	ecx, DWORD PTR [esi+116]

; 3267 : 
; 3268 : 	// Need at least 1 assigned to remove
; 3269 : 	if(iNumSpecialistsAssigned > 0)

	cmp	DWORD PTR [ecx+edi*4], 0
	jle	$LN49@DoRemoveSp

; 3270 : 	{
; 3271 : 		// Decrease count for the whole city
; 3272 : 		m_aiSpecialistCounts[eSpecialist]--;

	mov	edx, DWORD PTR [esi+108]
	dec	DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [edx+eax*4]

; 3273 : 		m_aiNumSpecialistsInBuilding[eBuilding]--;

	mov	ecx, DWORD PTR [esi+116]
	dec	DWORD PTR [ecx+edi*4]

; 3274 : 
; 3275 : 		if(bForced)

	cmp	BYTE PTR _bForced$[esp+16], 0
	lea	ecx, DWORD PTR [ecx+edi*4]
	je	SHORT $LN3@DoRemoveSp

; 3276 : 		{
; 3277 : 			m_aiNumForcedSpecialistsInBuilding[eBuilding]--;

	mov	edx, DWORD PTR [esi+120]
	dec	DWORD PTR [edx+edi*4]
	lea	ecx, DWORD PTR [edx+edi*4]
$LN3@DoRemoveSp:

; 3278 : 		}
; 3279 : 
; 3280 : 		GetCity()->processSpecialist(eSpecialist, -1);

	mov	ecx, DWORD PTR [esi]
	push	-1
	push	eax
	call	?processSpecialist@CvCity@@QAEXW4SpecialistTypes@@H@Z ; CvCity::processSpecialist

; 3281 : 		GetCity()->UpdateReligion(GetCity()->GetCityReligions()->GetReligiousMajority());

	mov	edi, DWORD PTR [esi]
	mov	ecx, edi
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ ; CvCityReligions::GetReligiousMajority
	push	eax
	mov	ecx, edi
	call	?UpdateReligion@CvCity@@QAEXW4ReligionTypes@@@Z ; CvCity::UpdateReligion

; 3282 : 
; 3283 : 		// Do we kill this population or reassign him?
; 3284 : 		if(bEliminatePopulation)

	cmp	BYTE PTR _bEliminatePopulation$[esp+16], 0
	je	SHORT $LN2@DoRemoveSp

; 3285 : 		{
; 3286 : 			GetCity()->changePopulation(-1, /*bReassignPop*/ false);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	-1
	call	?changePopulation@CvCity@@QAEXH_N@Z	; CvCity::changePopulation

; 3287 : 		}
; 3288 : 		else

	jmp	SHORT $LN20@DoRemoveSp
$LN2@DoRemoveSp:

; 3289 : 		{
; 3290 : 			ChangeNumUnassignedCitizens(1);

	inc	DWORD PTR [esi+8]
$LN20@DoRemoveSp:

; 3291 : 		}
; 3292 : 
; 3293 : #ifdef AUI_WARNING_FIXES
; 3294 : 		ICvUserInterface2* pkIFace = GC.GetEngineUserInterface();
; 3295 : 		pkIFace->setDirty(GameData_DIRTY_BIT, true);
; 3296 : 		pkIFace->setDirty(CityInfo_DIRTY_BIT, true);
; 3297 : 		//pkIFace->setDirty(InfoPane_DIRTY_BIT, true );
; 3298 : 		pkIFace->setDirty(CityScreen_DIRTY_BIT, true);
; 3299 : 		pkIFace->setDirty(ColoredPlots_DIRTY_BIT, true);
; 3300 : 
; 3301 : 		auto_ptr<ICvCity1> pCity = GC.WrapCityPointer(GetCity());
; 3302 : 
; 3303 : 		pkIFace->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_SPECIALISTS);
; 3304 : #else
; 3305 : 		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	11					; 0000000bH
	call	edx

; 3306 : 		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	18					; 00000012H
	call	edx

; 3307 : 		//GC.GetEngineUserInterface()->setDirty(InfoPane_DIRTY_BIT, true );
; 3308 : 		GC.GetEngineUserInterface()->setDirty(CityScreen_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	21					; 00000015H
	call	edx

; 3309 : 		GC.GetEngineUserInterface()->setDirty(ColoredPlots_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	24					; 00000018H
	call	edx

; 3310 : 
; 3311 : 		auto_ptr<ICvCity1> pCity = GC.WrapCityPointer(GetCity());

	mov	esi, DWORD PTR [esi]
	push	esi
	lea	eax, DWORD PTR $T227948[esp+20]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z ; CvGlobals::WrapCityPointer
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pCity$226268[esp+16], esi
	mov	eax, DWORD PTR $T227948[esp+16]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	test	eax, eax
	je	SHORT $LN40@DoRemoveSp
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN40@DoRemoveSp:

; 3312 : 
; 3313 : 		GC.GetEngineUserInterface()->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_SPECIALISTS);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+440]
	push	1
	push	esi
	call	edx

; 3314 : #endif
; 3315 : 	}

	mov	DWORD PTR __$EHRec$[esp+28], -1
	test	esi, esi
	je	SHORT $LN49@DoRemoveSp
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	call	ecx
$LN49@DoRemoveSp:

; 3316 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z$1:
	lea	ecx, DWORD PTR _pCity$226268[ebp-4]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__ehhandler$?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z ENDP ; CvCityCitizens::DoRemoveSpecialistFromBuilding
PUBLIC	?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z ; CvCityCitizens::DoRemoveAllSpecialistsFromBuilding
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z$1
__ehfuncinfo$?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitycitizens.cpp
xdata$x	ENDS
;	COMDAT ?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z
_TEXT	SEGMENT
tv160 = -24						; size = 4
$T228057 = -20						; size = 4
_pCity$226288 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eBuilding$ = 8						; size = 4
_bEliminatePopulation$ = 12				; size = 1
?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z PROC ; CvCityCitizens::DoRemoveAllSpecialistsFromBuilding, COMDAT
; _this$ = ecx

; 3323 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 3324 : 	CvAssert(eBuilding > -1);
; 3325 : 	CvAssert(eBuilding < GC.getNumBuildingInfos());
; 3326 : 
; 3327 : 	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	mov	edi, DWORD PTR _eBuilding$[esp+28]
	mov	esi, ecx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 3328 : 	if(pkBuildingInfo == NULL)

	test	eax, eax
	je	$LN3@DoRemoveAl
	push	ebp

; 3329 : 	{
; 3330 : 		return;
; 3331 : 	}
; 3332 : 
; 3333 : 	SpecialistTypes eSpecialist = (SpecialistTypes) pkBuildingInfo->GetSpecialistType();

	mov	ecx, eax
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType

; 3334 : 	int iNumSpecialists = GetNumSpecialistsInBuilding(eBuilding);
; 3335 : 
; 3336 : 	m_aiNumForcedSpecialistsInBuilding[eBuilding] = 0;

	mov	ecx, DWORD PTR [esi+120]
	mov	ebp, eax
	mov	eax, DWORD PTR [esi+116]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [ecx+edi*4], 0

; 3337 : 
; 3338 : 	// Pick the worst to remove
; 3339 : 	for(int iAssignedLoop = 0; iAssignedLoop < iNumSpecialists; iAssignedLoop++)

	test	eax, eax
	jle	$LN51@DoRemoveAl

; 3329 : 	{
; 3330 : 		return;
; 3331 : 	}
; 3332 : 
; 3333 : 	SpecialistTypes eSpecialist = (SpecialistTypes) pkBuildingInfo->GetSpecialistType();

	mov	DWORD PTR tv160[esp+36], eax
	jmp	SHORT $LN5@DoRemoveAl
	npad	5
$LL49@DoRemoveAl:
	mov	edi, DWORD PTR _eBuilding$[esp+32]
$LN5@DoRemoveAl:

; 3340 : 	{
; 3341 : 		// Decrease count for the whole city
; 3342 : 		m_aiSpecialistCounts[eSpecialist]--;

	mov	edx, DWORD PTR [esi+108]
	dec	DWORD PTR [edx+ebp*4]
	lea	eax, DWORD PTR [edx+ebp*4]

; 3343 : 		m_aiNumSpecialistsInBuilding[eBuilding]--;

	mov	eax, DWORD PTR [esi+116]
	dec	DWORD PTR [eax+edi*4]

; 3344 : 		GetCity()->processSpecialist(eSpecialist, -1);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edi*4]
	push	-1
	push	ebp
	call	?processSpecialist@CvCity@@QAEXW4SpecialistTypes@@H@Z ; CvCity::processSpecialist

; 3345 : 
; 3346 : 		// Do we kill this population or reassign him?
; 3347 : 		if(bEliminatePopulation)

	cmp	BYTE PTR _bEliminatePopulation$[esp+32], 0
	je	SHORT $LN2@DoRemoveAl

; 3348 : 		{
; 3349 : 			GetCity()->changePopulation(-1, /*bReassignPop*/ false);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	-1
	call	?changePopulation@CvCity@@QAEXH_N@Z	; CvCity::changePopulation

; 3350 : 		}
; 3351 : 		else

	jmp	SHORT $LN17@DoRemoveAl
$LN2@DoRemoveAl:

; 3352 : 		{
; 3353 : 			ChangeNumUnassignedCitizens(1);

	inc	DWORD PTR [esi+8]
$LN17@DoRemoveAl:

; 3354 : 		}
; 3355 : 
; 3356 : #ifdef AUI_WARNING_FIXES
; 3357 : 		ICvUserInterface2* pkIFace = GC.GetEngineUserInterface();
; 3358 : 		pkIFace->setDirty(CityInfo_DIRTY_BIT, true);
; 3359 : 		//pkIFace->setDirty(InfoPane_DIRTY_BIT, true );
; 3360 : 		pkIFace->setDirty(CityScreen_DIRTY_BIT, true);
; 3361 : 		pkIFace->setDirty(ColoredPlots_DIRTY_BIT, true);
; 3362 : 
; 3363 : 		auto_ptr<ICvCity1> pCity = GC.WrapCityPointer(GetCity());
; 3364 : 		pkIFace->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_SPECIALISTS);
; 3365 : #else
; 3366 : 		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	18					; 00000012H
	call	eax

; 3367 : 		//GC.GetEngineUserInterface()->setDirty(InfoPane_DIRTY_BIT, true );
; 3368 : 		GC.GetEngineUserInterface()->setDirty(CityScreen_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	21					; 00000015H
	call	eax

; 3369 : 		GC.GetEngineUserInterface()->setDirty(ColoredPlots_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	24					; 00000018H
	call	eax

; 3370 : 
; 3371 : 		auto_ptr<ICvCity1> pCity = GC.WrapCityPointer(GetCity());

	mov	eax, DWORD PTR [esi]
	push	eax
	lea	ecx, DWORD PTR $T228057[esp+40]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z ; CvGlobals::WrapCityPointer
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pCity$226288[esp+36], edi
	mov	eax, DWORD PTR $T228057[esp+36]
	mov	DWORD PTR __$EHRec$[esp+44], 0
	test	eax, eax
	je	SHORT $LN35@DoRemoveAl
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN35@DoRemoveAl:

; 3372 : 		GC.GetEngineUserInterface()->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_SPECIALISTS);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+440]
	push	1
	push	edi
	call	eax

; 3373 : #endif
; 3374 : 	}

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	edi, edi
	je	SHORT $LN4@DoRemoveAl
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx
$LN4@DoRemoveAl:

; 3337 : 
; 3338 : 	// Pick the worst to remove
; 3339 : 	for(int iAssignedLoop = 0; iAssignedLoop < iNumSpecialists; iAssignedLoop++)

	sub	DWORD PTR tv160[esp+36], 1
	jne	$LL49@DoRemoveAl
$LN51@DoRemoveAl:
	pop	ebp
$LN3@DoRemoveAl:

; 3375 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _pCity$226288[ebp]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__ehhandler$?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z ENDP ; CvCityCitizens::DoRemoveAllSpecialistsFromBuilding
PUBLIC	?DoRemoveWorstSpecialist@CvCityCitizens@@QAE_NW4SpecialistTypes@@W4BuildingTypes@@@Z ; CvCityCitizens::DoRemoveWorstSpecialist
; Function compile flags: /Ogtpy
;	COMDAT ?DoRemoveWorstSpecialist@CvCityCitizens@@QAE_NW4SpecialistTypes@@W4BuildingTypes@@@Z
_TEXT	SEGMENT
_eDontChangeSpecialist$ = 8				; size = 4
_eDontRemoveFromBuilding$ = 12				; size = 4
?DoRemoveWorstSpecialist@CvCityCitizens@@QAE_NW4SpecialistTypes@@W4BuildingTypes@@@Z PROC ; CvCityCitizens::DoRemoveWorstSpecialist, COMDAT
; _this$ = ecx

; 3380 : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 3381 : #ifdef AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST
; 3382 : 	BuildingTypes eWorstBuilding = NO_BUILDING;
; 3383 : 	int iWorstSpecialistScore = MAX_INT;
; 3384 : 	int iLoopSpecialistScore = 0;
; 3385 : #endif
; 3386 : #ifdef AUI_WARNING_FIXES
; 3387 : 	for (uint iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
; 3388 : #else
; 3389 : 	for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	SHORT $LN5@DoRemoveWo
	mov	ebx, DWORD PTR _eDontRemoveFromBuilding$[esp+12]
	mov	ebp, DWORD PTR _eDontChangeSpecialist$[esp+12]
	npad	2
$LL7@DoRemoveWo:

; 3390 : #endif
; 3391 : 	{
; 3392 : 		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
; 3393 : 
; 3394 : 		if(eBuilding == eDontRemoveFromBuilding)

	cmp	esi, ebx
	je	SHORT $LN6@DoRemoveWo

; 3395 : 		{
; 3396 : 			continue;
; 3397 : 		}
; 3398 : 
; 3399 : 		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 3400 : 		if(pkBuildingInfo == NULL)

	test	eax, eax
	je	SHORT $LN6@DoRemoveWo

; 3401 : 		{
; 3402 : 			continue;
; 3403 : 		}
; 3404 : 
; 3405 : 		// We might not be allowed to change this Building's Specialists
; 3406 : 		if(eDontChangeSpecialist == pkBuildingInfo->GetSpecialistType())

	mov	ecx, eax
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType
	cmp	ebp, eax
	je	SHORT $LN6@DoRemoveWo

; 3407 : 		{
; 3408 : 			continue;
; 3409 : 		}
; 3410 : 
; 3411 : 		if(GetNumSpecialistsInBuilding(eBuilding) > 0)

	mov	eax, DWORD PTR [edi+116]
	cmp	DWORD PTR [eax+esi*4], 0
	jg	SHORT $LN13@DoRemoveWo
$LN6@DoRemoveWo:

; 3381 : #ifdef AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST
; 3382 : 	BuildingTypes eWorstBuilding = NO_BUILDING;
; 3383 : 	int iWorstSpecialistScore = MAX_INT;
; 3384 : 	int iLoopSpecialistScore = 0;
; 3385 : #endif
; 3386 : #ifdef AUI_WARNING_FIXES
; 3387 : 	for (uint iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
; 3388 : #else
; 3389 : 	for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	SHORT $LL7@DoRemoveWo
$LN5@DoRemoveWo:
	pop	edi
	pop	esi
	pop	ebp

; 3428 : #endif
; 3429 : 		}
; 3430 : 	}
; 3431 : 
; 3432 : #ifdef AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST
; 3433 : 	if (eWorstBuilding != NO_BUILDING)
; 3434 : 	{
; 3435 : 		DoRemoveSpecialistFromBuilding(eWorstBuilding, false);
; 3436 : 
; 3437 : 		return true;
; 3438 : 	}
; 3439 : #endif
; 3440 : 
; 3441 : 	return false;

	xor	al, al
	pop	ebx

; 3442 : }

	ret	8
$LN13@DoRemoveWo:

; 3412 : 		{
; 3413 : #ifdef AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST
; 3414 : #ifdef AUI_CITIZENS_UNHARDCODE_SPECIALIST_VALUE_HAPPINESS
; 3415 : 			iLoopSpecialistScore = GetSpecialistValue((SpecialistTypes)pkBuildingInfo->GetSpecialistType(), true);
; 3416 : #else
; 3417 : 			iLoopSpecialistScore = GetSpecialistValue((SpecialistTypes)pkBuildingInfo->GetSpecialistType());
; 3418 : #endif
; 3419 : 			if (iLoopSpecialistScore < iWorstSpecialistScore)
; 3420 : 			{
; 3421 : 				iWorstSpecialistScore = iLoopSpecialistScore;
; 3422 : 				eWorstBuilding = eBuilding;
; 3423 : 			}
; 3424 : #else
; 3425 : 			DoRemoveSpecialistFromBuilding(eBuilding, true);

	push	0
	push	1
	push	esi
	mov	ecx, edi
	call	?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z ; CvCityCitizens::DoRemoveSpecialistFromBuilding
	pop	edi
	pop	esi
	pop	ebp

; 3426 : 
; 3427 : 			return true;

	mov	al, 1
	pop	ebx

; 3442 : }

	ret	8
?DoRemoveWorstSpecialist@CvCityCitizens@@QAE_NW4SpecialistTypes@@W4BuildingTypes@@@Z ENDP ; CvCityCitizens::DoRemoveWorstSpecialist
_TEXT	ENDS
PUBLIC	?GetSpecialistUpgradeThreshold@CvCityCitizens@@QAEHW4UnitClassTypes@@@Z ; CvCityCitizens::GetSpecialistUpgradeThreshold
EXTRN	?getGreatPeoplePercent@CvEraInfo@@QBEHXZ:PROC	; CvEraInfo::getGreatPeoplePercent
EXTRN	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ:PROC ; CvGame::getStartEraInfo
EXTRN	?getGreatPeoplePercent@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getGreatPeoplePercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?getGreatPeopleCreated@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getGreatPeopleCreated
EXTRN	?getGreatMerchantsCreated@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getGreatMerchantsCreated
EXTRN	?getGreatEngineersCreated@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getGreatEngineersCreated
EXTRN	?getGreatScientistsCreated@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatScientistsCreated
EXTRN	?getGreatMusiciansCreated@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getGreatMusiciansCreated
EXTRN	?getGreatArtistsCreated@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getGreatArtistsCreated
EXTRN	?getGreatWritersCreated@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getGreatWritersCreated
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistUpgradeThreshold@CvCityCitizens@@QAEHW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_eUnitClass$ = 8					; size = 4
?GetSpecialistUpgradeThreshold@CvCityCitizens@@QAEHW4UnitClassTypes@@@Z PROC ; CvCityCitizens::GetSpecialistUpgradeThreshold, COMDAT
; _this$ = ecx

; 3606 : {

	push	ebx

; 3607 : 	int iThreshold = /*100*/ GC.getGREAT_PERSON_THRESHOLD_BASE();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7104
	push	esi
	push	edi

; 3608 : 	int iNumCreated;
; 3609 : 
; 3610 : 	if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_WRITER", true))

	push	1
	mov	edi, ecx
	push	OFFSET $SG226390
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, DWORD PTR _eUnitClass$[esp+8]
	cmp	esi, eax
	jne	SHORT $LN12@GetSpecial

; 3611 : 	{
; 3612 : 		iNumCreated = GET_PLAYER(GetCity()->getOwner()).getGreatWritersCreated();

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatWritersCreated@CvPlayer@@QBEHXZ ; CvPlayer::getGreatWritersCreated
	jmp	$LN79@GetSpecial
$LN12@GetSpecial:

; 3613 : 	}
; 3614 : 	else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_ARTIST", true))

	push	1
	push	OFFSET $SG226393
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN10@GetSpecial

; 3615 : 	{
; 3616 : 		iNumCreated = GET_PLAYER(GetCity()->getOwner()).getGreatArtistsCreated();

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatArtistsCreated@CvPlayer@@QBEHXZ ; CvPlayer::getGreatArtistsCreated
	jmp	$LN79@GetSpecial
$LN10@GetSpecial:

; 3617 : 	}
; 3618 : 	else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_MUSICIAN", true))

	push	1
	push	OFFSET $SG226396
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN8@GetSpecial

; 3619 : 	{
; 3620 : 		iNumCreated = GET_PLAYER(GetCity()->getOwner()).getGreatMusiciansCreated();

	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatMusiciansCreated@CvPlayer@@QBEHXZ ; CvPlayer::getGreatMusiciansCreated
	jmp	$LN79@GetSpecial
$LN8@GetSpecial:

; 3621 : 	}
; 3622 : 	// GJS: begin separation of great people types
; 3623 : 	else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_SCIENTIST", true))

	push	1
	push	OFFSET $SG226399
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN6@GetSpecial

; 3624 : 	{
; 3625 : 		iNumCreated = GET_PLAYER(GetCity()->getOwner()).getGreatScientistsCreated();

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatScientistsCreated@CvPlayer@@QBEHXZ ; CvPlayer::getGreatScientistsCreated
	jmp	SHORT $LN79@GetSpecial
$LN6@GetSpecial:

; 3626 : 	}
; 3627 : 	else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_ENGINEER", true))

	push	1
	push	OFFSET $SG226402
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN4@GetSpecial

; 3628 : 	{
; 3629 : 		iNumCreated = GET_PLAYER(GetCity()->getOwner()).getGreatEngineersCreated();

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatEngineersCreated@CvPlayer@@QBEHXZ ; CvPlayer::getGreatEngineersCreated
	jmp	SHORT $LN79@GetSpecial
$LN4@GetSpecial:

; 3630 : 	}
; 3631 : 	else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_MERCHANT", true))

	push	1
	push	OFFSET $SG226405
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN2@GetSpecial

; 3632 : 	{
; 3633 : 		iNumCreated = GET_PLAYER(GetCity()->getOwner()).getGreatMerchantsCreated();

	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatMerchantsCreated@CvPlayer@@QBEHXZ ; CvPlayer::getGreatMerchantsCreated

; 3634 : 	}
; 3635 : 	// GJS: end separation of great people types
; 3636 : 	else

	jmp	SHORT $LN79@GetSpecial
$LN2@GetSpecial:

; 3637 : 	{
; 3638 : 		iNumCreated = GET_PLAYER(GetCity()->getOwner()).getGreatPeopleCreated();

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatPeopleCreated@CvPlayer@@QBEHXZ	; CvPlayer::getGreatPeopleCreated
$LN79@GetSpecial:

; 3639 : 	}
; 3640 : 
; 3641 : 	// Increase threshold based on how many GP have already been spawned
; 3642 : 	iThreshold += (/*50*/ GC.getGREAT_PERSON_THRESHOLD_INCREASE() * iNumCreated);
; 3643 : 
; 3644 : 	// Game Speed mod
; 3645 : 	iThreshold *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7108
	mov	edi, eax
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getGreatPeoplePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getGreatPeoplePercent
	imul	esi, edi
	mov	ecx, eax
	add	esi, ebx
	imul	ecx, esi

; 3646 : 	iThreshold /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 3647 : 
; 3648 : 	// Start era mod
; 3649 : 	iThreshold *= GC.getGame().getStartEraInfo().getGreatPeoplePercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ ; CvGame::getStartEraInfo
	mov	ecx, eax
	call	?getGreatPeoplePercent@CvEraInfo@@QBEHXZ ; CvEraInfo::getGreatPeoplePercent
	mov	ecx, eax
	imul	ecx, esi

; 3650 : 	iThreshold /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	pop	edi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	esi
	add	eax, edx
	pop	ebx

; 3651 : 
; 3652 : 	return iThreshold;
; 3653 : }

	ret	4
?GetSpecialistUpgradeThreshold@CvCityCitizens@@QAEHW4UnitClassTypes@@@Z ENDP ; CvCityCitizens::GetSpecialistUpgradeThreshold
_TEXT	ENDS
PUBLIC	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z ; CvCityCitizens::DoSpawnGreatPerson
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?addFreeUnit@CvPlayer@@QAEPAVCvPlot@@W4UnitTypes@@W4UnitAITypes@@@Z:PROC ; CvPlayer::addFreeUnit
EXTRN	?IsWarHero@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsWarHero
EXTRN	?SetResearchBulbAmount@CvUnit@@QAEXH@Z:PROC	; CvUnit::SetResearchBulbAmount
EXTRN	?GetScienceYieldFromPreviousTurns@CvPlayer@@QAEHHH@Z:PROC ; CvPlayer::GetScienceYieldFromPreviousTurns
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?GetBaseBeakersTurnsToCount@CvUnitEntry@@QBEHXZ:PROC ; CvUnitEntry::GetBaseBeakersTurnsToCount
EXTRN	?SetTourismBlastStrength@CvUnit@@QAEXH@Z:PROC	; CvUnit::SetTourismBlastStrength
EXTRN	?GetTourismBlastStrength@CvPlayerCulture@@QAEHH@Z:PROC ; CvPlayerCulture::GetTourismBlastStrength
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?GetOneShotTourism@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetOneShotTourism
EXTRN	?GetReligiousStrength@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetReligiousStrength
EXTRN	?GetReligionSpreads@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetReligionSpreads
EXTRN	?GetReligionCreatedByPlayer@CvPlayerReligions@@QBE?AW4ReligionTypes@@XZ:PROC ; CvPlayerReligions::GetReligionCreatedByPlayer
EXTRN	?IsFoundReligion@CvUnitEntry@@QBE_NXZ:PROC	; CvUnitEntry::IsFoundReligion
EXTRN	?ChangeNumProphetsSpawned@CvPlayerReligions@@QAEXH@Z:PROC ; CvPlayerReligions::ChangeNumProphetsSpawned
EXTRN	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ:PROC ; CvPlayer::GetReligions
EXTRN	?incrementGreatPeopleCreated@CvPlayer@@QAEXXZ:PROC ; CvPlayer::incrementGreatPeopleCreated
EXTRN	?incrementGreatProphetsCreated@CvPlayer@@QAEXXZ:PROC ; CvPlayer::incrementGreatProphetsCreated
EXTRN	?incrementGreatMerchantsCreated@CvPlayer@@QAEXXZ:PROC ; CvPlayer::incrementGreatMerchantsCreated
EXTRN	?incrementGreatEngineersCreated@CvPlayer@@QAEXXZ:PROC ; CvPlayer::incrementGreatEngineersCreated
EXTRN	?incrementGreatScientistsCreated@CvPlayer@@QAEXXZ:PROC ; CvPlayer::incrementGreatScientistsCreated
EXTRN	?incrementGreatMusiciansCreated@CvPlayer@@QAEXXZ:PROC ; CvPlayer::incrementGreatMusiciansCreated
EXTRN	?incrementGreatArtistsCreated@CvPlayer@@QAEXXZ:PROC ; CvPlayer::incrementGreatArtistsCreated
EXTRN	?incrementGreatWritersCreated@CvPlayer@@QAEXXZ:PROC ; CvPlayer::incrementGreatWritersCreated
EXTRN	?GetUnitClassType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetUnitClassType
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
EXTRN	?setXY@CvUnit@@QAEXHH_N0000@Z:PROC		; CvUnit::setXY
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?GetGreatAdmiralSpawnPlot@CvPlayer@@QAEPAVCvPlot@@PAVCvUnit@@@Z:PROC ; CvPlayer::GetGreatAdmiralSpawnPlot
EXTRN	?incrementGreatAdmiralsCreated@CvPlayer@@QAEXXZ:PROC ; CvPlayer::incrementGreatAdmiralsCreated
EXTRN	?IsGreatAdmiral@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsGreatAdmiral
EXTRN	?incrementGreatGeneralsCreated@CvPlayer@@QAEXXZ:PROC ; CvPlayer::incrementGreatGeneralsCreated
EXTRN	?IsGreatGeneral@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsGreatGeneral
EXTRN	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z:PROC ; CvPlayer::initUnit
EXTRN	?isNetworkMultiPlayer@CvGame@@QBE_NXZ:PROC	; CvGame::isNetworkMultiPlayer
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
xdata$x	SEGMENT
__unwindtable$?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z$1
__ehfuncinfo$?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitycitizens.cpp
xdata$x	ENDS
;	COMDAT ?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z
_TEXT	SEGMENT
_this$ = -712						; size = 4
_strSummary$226462 = -708				; size = 80
_strText$226459 = -628					; size = 80
_kPopupInfo$226416 = -548				; size = 536
__$EHRec$ = -12						; size = 12
_eUnit$ = 8						; size = 4
_bIncrementCount$ = 12					; size = 1
_bCountAsProphet$ = 16					; size = 1
?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z PROC ; CvCityCitizens::DoSpawnGreatPerson, COMDAT
; _this$ = ecx

; 3657 : {

	push	-1
	push	__ehhandler$?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 700				; 000002bcH
	push	ebx

; 3658 : 	CvAssert(eUnit != NO_UNIT);
; 3659 : 
; 3660 : 	if (eUnit == NO_UNIT)

	mov	ebx, DWORD PTR _eUnit$[esp+712]
	push	ebp
	mov	ebp, ecx
	mov	DWORD PTR _this$[esp+720], ebp
	cmp	ebx, -1
	je	$LN1@DoSpawnGre

; 3661 : 		return;	// Better than crashing.
; 3662 : 
; 3663 : 	// If it's the active player then show the popup
; 3664 : 	if(GetCity()->getOwner() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	mov	esi, DWORD PTR [eax+84]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN122@DoSpawnGre

; 3665 : 	{
; 3666 : 		// Don't show in MP
; 3667 : 		if(!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().IsOption(GAMEOPTION_SIMULTANEOUS_TURNS)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	test	al, al
	jne	SHORT $LN122@DoSpawnGre

; 3668 : 		{
; 3669 : 			CvPopupInfo kPopupInfo(BUTTONPOPUP_GREAT_PERSON_REWARD, eUnit, GetCity()->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+120]

; 3670 : 			GC.GetEngineUserInterface()->AddPopup(kPopupInfo);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	DWORD PTR _kPopupInfo$226416[esp+728], eax
	mov	DWORD PTR _kPopupInfo$226416[esp+724], ebx
	mov	DWORD PTR _kPopupInfo$226416[esp+732], -1
	mov	DWORD PTR _kPopupInfo$226416[esp+736], 0
	mov	BYTE PTR _kPopupInfo$226416[esp+740], 0
	mov	BYTE PTR _kPopupInfo$226416[esp+741], 0
	mov	DWORD PTR _kPopupInfo$226416[esp+744], 60 ; 0000003cH
	mov	BYTE PTR _kPopupInfo$226416[esp+748], 0
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+180]
	lea	edx, DWORD PTR _kPopupInfo$226416[esp+724]
	push	edx
	call	eax
$LN122@DoSpawnGre:

; 3671 : 		}
; 3672 : 	}
; 3673 : 
; 3674 : 	CvPlayer& kPlayer = GET_PLAYER(GetCity()->getOwner());

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ecx+84]
	push	edi
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3675 : 	CvUnit* newUnit = kPlayer.initUnit(eUnit, GetCity()->getX(), GetCity()->getY());

	push	0
	push	0
	push	1
	push	0
	push	-1
	mov	edi, eax
	mov	eax, DWORD PTR [ecx+108]
	mov	ecx, DWORD PTR [ecx+96]
	push	-1
	push	eax
	push	ecx
	push	ebx
	mov	ecx, edi
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit

; 3676 : #ifdef AUI_DLLNETMESSAGEHANDLER_FIX_RESPAWN_PROPHET_IF_BEATEN_TO_LAST_RELIGION
; 3677 : 	if (bSpawnWithNoExpendedTrigger)
; 3678 : 		newUnit->SetIgnoreExpended(true);
; 3679 : #endif
; 3680 : 
; 3681 : 	// Bump up the count
; 3682 : 	if(bIncrementCount && !bCountAsProphet)

	cmp	BYTE PTR _bIncrementCount$[esp+724], 0
	mov	esi, eax
	je	$LN8@DoSpawnGre
	cmp	BYTE PTR _bCountAsProphet$[esp+724], 0
	jne	$LN121@DoSpawnGre

; 3683 : 	{
; 3684 : 		if(newUnit->IsGreatGeneral())

	mov	ecx, esi
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	test	al, al
	je	SHORT $LN26@DoSpawnGre

; 3685 : 		{
; 3686 : 			kPlayer.incrementGreatGeneralsCreated();

	mov	ecx, edi
	call	?incrementGreatGeneralsCreated@CvPlayer@@QAEXXZ ; CvPlayer::incrementGreatGeneralsCreated
	jmp	$LN125@DoSpawnGre
$LN26@DoSpawnGre:

; 3687 : 		}
; 3688 : 		else if(newUnit->IsGreatAdmiral())

	mov	ecx, esi
	call	?IsGreatAdmiral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatAdmiral
	test	al, al
	je	SHORT $LN24@DoSpawnGre

; 3689 : 		{
; 3690 : 			kPlayer.incrementGreatAdmiralsCreated();

	mov	ecx, edi
	call	?incrementGreatAdmiralsCreated@CvPlayer@@QAEXXZ ; CvPlayer::incrementGreatAdmiralsCreated

; 3691 : 			CvPlot *pSpawnPlot = kPlayer.GetGreatAdmiralSpawnPlot(newUnit);

	push	esi
	mov	ecx, edi
	call	?GetGreatAdmiralSpawnPlot@CvPlayer@@QAEPAVCvPlot@@PAVCvUnit@@@Z ; CvPlayer::GetGreatAdmiralSpawnPlot

; 3692 : 			if (newUnit->plot() != pSpawnPlot)

	mov	ecx, esi
	mov	ebx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	je	$LN125@DoSpawnGre

; 3693 : 			{
; 3694 : 				newUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());

	movsx	ecx, WORD PTR [ebx+2]
	movsx	edx, WORD PTR [ebx]
	push	0
	push	0
	push	0
	push	1
	push	0
	push	ecx
	push	edx
	mov	ecx, esi
	call	?setXY@CvUnit@@QAEXHH_N0000@Z		; CvUnit::setXY

; 3695 : 			}
; 3696 : 		}

	jmp	$LN125@DoSpawnGre
$LN24@DoSpawnGre:

; 3697 : 		else if (newUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_WRITER"))

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitClassType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitClassType
	push	0
	push	OFFSET $SG226427
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebx, eax
	jne	SHORT $LN21@DoSpawnGre

; 3698 : 		{
; 3699 : 			kPlayer.incrementGreatWritersCreated();

	mov	ecx, edi
	call	?incrementGreatWritersCreated@CvPlayer@@QAEXXZ ; CvPlayer::incrementGreatWritersCreated
	jmp	$LN125@DoSpawnGre
$LN21@DoSpawnGre:

; 3700 : 		}							
; 3701 : 		else if (newUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitClassType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitClassType
	push	0
	push	OFFSET $SG226430
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebx, eax
	jne	SHORT $LN19@DoSpawnGre

; 3702 : 		{
; 3703 : 			kPlayer.incrementGreatArtistsCreated();

	mov	ecx, edi
	call	?incrementGreatArtistsCreated@CvPlayer@@QAEXXZ ; CvPlayer::incrementGreatArtistsCreated
	jmp	$LN125@DoSpawnGre
$LN19@DoSpawnGre:

; 3704 : 		}							
; 3705 : 		else if (newUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitClassType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitClassType
	push	0
	push	OFFSET $SG226433
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebx, eax
	jne	SHORT $LN17@DoSpawnGre

; 3706 : 		{
; 3707 : 			kPlayer.incrementGreatMusiciansCreated();

	mov	ecx, edi
	call	?incrementGreatMusiciansCreated@CvPlayer@@QAEXXZ ; CvPlayer::incrementGreatMusiciansCreated
	jmp	$LN125@DoSpawnGre
$LN17@DoSpawnGre:

; 3708 : 		}		
; 3709 : 		// GJS: Start separation of great people
; 3710 : 		else if (newUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitClassType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitClassType
	push	0
	push	OFFSET $SG226436
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebx, eax
	jne	SHORT $LN15@DoSpawnGre

; 3711 : 		{
; 3712 : 			kPlayer.incrementGreatScientistsCreated();

	mov	ecx, edi
	call	?incrementGreatScientistsCreated@CvPlayer@@QAEXXZ ; CvPlayer::incrementGreatScientistsCreated
	jmp	$LN125@DoSpawnGre
$LN15@DoSpawnGre:

; 3713 : 		}
; 3714 : 		else if (newUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitClassType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitClassType
	push	0
	push	OFFSET $SG226439
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebx, eax
	jne	SHORT $LN13@DoSpawnGre

; 3715 : 		{
; 3716 : 			kPlayer.incrementGreatEngineersCreated();

	mov	ecx, edi
	call	?incrementGreatEngineersCreated@CvPlayer@@QAEXXZ ; CvPlayer::incrementGreatEngineersCreated
	jmp	SHORT $LN125@DoSpawnGre
$LN13@DoSpawnGre:

; 3717 : 		}
; 3718 : 		else if (newUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitClassType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitClassType
	push	0
	push	OFFSET $SG226442
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebx, eax
	jne	SHORT $LN11@DoSpawnGre

; 3719 : 		{
; 3720 : 			kPlayer.incrementGreatMerchantsCreated();

	mov	ecx, edi
	call	?incrementGreatMerchantsCreated@CvPlayer@@QAEXXZ ; CvPlayer::incrementGreatMerchantsCreated
	jmp	SHORT $LN125@DoSpawnGre
$LN11@DoSpawnGre:

; 3721 : 		}
; 3722 : 		else if (newUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_PROPHET"))

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitClassType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitClassType
	push	0
	push	OFFSET $SG226445
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3723 : 		{
; 3724 : 			kPlayer.incrementGreatProphetsCreated();

	mov	ecx, edi
	cmp	ebx, eax
	jne	SHORT $LN9@DoSpawnGre
	call	?incrementGreatProphetsCreated@CvPlayer@@QAEXXZ ; CvPlayer::incrementGreatProphetsCreated

; 3725 : 		}
; 3726 : 		// GJS: End separation of great people
; 3727 : 		else

	jmp	SHORT $LN125@DoSpawnGre
$LN9@DoSpawnGre:

; 3728 : 		{
; 3729 : 			kPlayer.incrementGreatPeopleCreated();

	call	?incrementGreatPeopleCreated@CvPlayer@@QAEXXZ ; CvPlayer::incrementGreatPeopleCreated

; 3730 : 		}
; 3731 : 	}
; 3732 : 
; 3733 : 	// NQMP GJS: In order to make "free" Great Prophets truly free, had to remove the 2nd half of the check below, left it commented out though in case I screw something up.
; 3734 : 	if(bCountAsProphet)// || newUnit->getUnitInfo().IsFoundReligion())

	jmp	SHORT $LN125@DoSpawnGre
$LN8@DoSpawnGre:
	cmp	BYTE PTR _bCountAsProphet$[esp+724], 0
	je	SHORT $LN125@DoSpawnGre
$LN121@DoSpawnGre:

; 3735 : 	{
; 3736 : 		kPlayer.GetReligions()->ChangeNumProphetsSpawned(1);

	push	1
	mov	ecx, edi
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?ChangeNumProphetsSpawned@CvPlayerReligions@@QAEXH@Z ; CvPlayerReligions::ChangeNumProphetsSpawned
$LN125@DoSpawnGre:

; 3737 : 	}
; 3738 : 
; 3739 : 	// Setup prophet properly
; 3740 : 	if(newUnit->getUnitInfo().IsFoundReligion())

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?IsFoundReligion@CvUnitEntry@@QBE_NXZ	; CvUnitEntry::IsFoundReligion
	test	al, al
	je	SHORT $LN89@DoSpawnGre

; 3741 : 	{
; 3742 : 		ReligionTypes eReligion = kPlayer.GetReligions()->GetReligionCreatedByPlayer();

	mov	ecx, edi
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?GetReligionCreatedByPlayer@CvPlayerReligions@@QBE?AW4ReligionTypes@@XZ ; CvPlayerReligions::GetReligionCreatedByPlayer

; 3743 : 		int iReligionSpreads = newUnit->getUnitInfo().GetReligionSpreads();

	mov	ecx, esi
	mov	ebx, eax
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetReligionSpreads@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetReligionSpreads

; 3744 : 		int iReligiousStrength = newUnit->getUnitInfo().GetReligiousStrength();

	mov	ecx, esi
	mov	ebp, eax
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetReligiousStrength@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetReligiousStrength

; 3745 : 		if(iReligionSpreads > 0 && eReligion > RELIGION_PANTHEON)

	test	ebp, ebp
	jle	SHORT $LN124@DoSpawnGre
	test	ebx, ebx
	jle	SHORT $LN124@DoSpawnGre

; 3746 : 		{
; 3747 : 			newUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);

	mov	ecx, DWORD PTR [esi+1888]
	mov	DWORD PTR [ecx+8], ebp

; 3748 : 			newUnit->GetReligionData()->SetReligiousStrength(iReligiousStrength);

	mov	ecx, DWORD PTR [esi+1888]
	mov	DWORD PTR [ecx+4], eax

; 3749 : 			newUnit->GetReligionData()->SetReligion(eReligion);

	mov	eax, DWORD PTR [esi+1888]
	mov	DWORD PTR [eax], ebx
$LN124@DoSpawnGre:
	mov	ebp, DWORD PTR _this$[esp+728]
$LN89@DoSpawnGre:

; 3750 : 		}
; 3751 : 	}
; 3752 : 
; 3753 : 	if (newUnit->getUnitInfo().GetOneShotTourism() > 0)

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetOneShotTourism@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetOneShotTourism
	test	eax, eax
	jle	SHORT $LN4@DoSpawnGre

; 3754 : 	{
; 3755 : 		newUnit->SetTourismBlastStrength(kPlayer.GetCulture()->GetTourismBlastStrength(newUnit->getUnitInfo().GetOneShotTourism()));

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetOneShotTourism@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetOneShotTourism
	push	eax
	mov	ecx, edi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetTourismBlastStrength@CvPlayerCulture@@QAEHH@Z ; CvPlayerCulture::GetTourismBlastStrength
	push	eax
	mov	ecx, esi
	call	?SetTourismBlastStrength@CvUnit@@QAEXH@Z ; CvUnit::SetTourismBlastStrength
$LN4@DoSpawnGre:

; 3756 : 	}
; 3757 : 
; 3758 : 	// GJS: Great Scientists now bulb for science at point of birth, not current science 
; 3759 : 	if (newUnit->getUnitInfo().GetBaseBeakersTurnsToCount() > 0)

	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetBaseBeakersTurnsToCount@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetBaseBeakersTurnsToCount
	test	eax, eax
	jle	SHORT $LN3@DoSpawnGre

; 3760 : 	{
; 3761 : 		newUnit->SetResearchBulbAmount(kPlayer.GetScienceYieldFromPreviousTurns(GC.getGame().getGameTurn(), newUnit->getUnitInfo().GetBaseBeakersTurnsToCount()));

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetBaseBeakersTurnsToCount@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetBaseBeakersTurnsToCount
	push	eax
	mov	ecx, ebx
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	mov	ecx, edi
	call	?GetScienceYieldFromPreviousTurns@CvPlayer@@QAEHHH@Z ; CvPlayer::GetScienceYieldFromPreviousTurns
	push	eax
	mov	ecx, esi
	call	?SetResearchBulbAmount@CvUnit@@QAEXH@Z	; CvUnit::SetResearchBulbAmount
$LN3@DoSpawnGre:

; 3762 : 	}
; 3763 : 
; 3764 : #ifdef NQ_WAR_HERO
; 3765 : 	if (newUnit->IsGreatGeneral() && kPlayer.IsWarHero())

	mov	ecx, esi
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	test	al, al
	je	SHORT $LN126@DoSpawnGre
	mov	ecx, edi
	call	?IsWarHero@CvPlayer@@QBE_NXZ		; CvPlayer::IsWarHero
	test	al, al
	je	SHORT $LN126@DoSpawnGre

; 3766 : 	{
; 3767 : 		kPlayer.addFreeUnit((UnitTypes)GC.getInfoTypeForString("UNIT_ARTIST"));

	push	-1
	push	0
	push	OFFSET $SG226457
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, edi
	call	?addFreeUnit@CvPlayer@@QAEPAVCvPlot@@W4UnitTypes@@W4UnitAITypes@@@Z ; CvPlayer::addFreeUnit
$LN126@DoSpawnGre:

; 3768 : 	}
; 3769 : #endif
; 3770 : 
; 3771 : 	// Notification
; 3772 : 	if(GET_PLAYER(GetOwner()).GetNotifications())

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN129@DoSpawnGre

; 3773 : 	{
; 3774 : 		Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	ecx, DWORD PTR _strText$226459[esp+728]
	push	OFFSET $SG226461
	push	ecx
	call	esi

; 3775 : 		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON");

	lea	edx, DWORD PTR _strSummary$226462[esp+736]
	push	OFFSET $SG226464
	push	edx
	mov	DWORD PTR __$EHRec$[esp+752], 0
	call	esi
	add	esp, 16					; 00000010H

; 3776 : 		GET_PLAYER(GetOwner()).GetNotifications()->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, strText.toUTF8(), strSummary.toUTF8(), GetCity()->getX(), GetCity()->getY(), eUnit);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR [eax+96]
	mov	eax, DWORD PTR [eax+84]
	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	-1
	mov	esi, eax
	mov	eax, DWORD PTR _eUnit$[esp+728]
	push	eax
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _strSummary$226462[esp+744]
	mov	BYTE PTR __$EHRec$[esp+752], 1
	call	edi
	push	eax
	lea	ecx, DWORD PTR _strText$226459[esp+748]
	call	edi
	push	eax
	push	-2083717098				; 83cd0016H
	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3777 : 	}

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$226462[esp+728]
	mov	BYTE PTR __$EHRec$[esp+736], 0
	call	esi
	lea	ecx, DWORD PTR _strText$226459[esp+728]
	mov	DWORD PTR __$EHRec$[esp+736], -1
	call	esi
$LN129@DoSpawnGre:
	pop	edi
	pop	esi
$LN1@DoSpawnGre:

; 3778 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+720]
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 712				; 000002c8H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z$0:
	lea	ecx, DWORD PTR _strText$226459[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z$1:
	lea	ecx, DWORD PTR _strSummary$226462[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z ENDP ; CvCityCitizens::DoSpawnGreatPerson
PUBLIC	?GetPlayer@CvCityCitizens@@QAEPAVCvPlayer@@XZ	; CvCityCitizens::GetPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayer@CvCityCitizens@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
?GetPlayer@CvCityCitizens@@QAEPAVCvPlayer@@XZ PROC	; CvCityCitizens::GetPlayer, COMDAT
; _this$ = ecx

; 252  : 	return &GET_PLAYER(GetOwner());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 253  : }

	ret	0
?GetPlayer@CvCityCitizens@@QAEPAVCvPlayer@@XZ ENDP	; CvCityCitizens::GetPlayer
_TEXT	ENDS
PUBLIC	?IsAvoidGrowth@CvCityCitizens@@QAE_NXZ		; CvCityCitizens::IsAvoidGrowth
EXTRN	?GetExcessHappiness@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetExcessHappiness
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
; Function compile flags: /Ogtpy
;	COMDAT ?IsAvoidGrowth@CvCityCitizens@@QAE_NXZ
_TEXT	SEGMENT
?IsAvoidGrowth@CvCityCitizens@@QAE_NXZ PROC		; CvCityCitizens::IsAvoidGrowth, COMDAT
; _this$ = ecx

; 769  : {

	push	esi
	mov	esi, ecx

; 770  : #ifndef AUI_CITIZENS_FIX_AVOID_GROWTH_FLAG_NOT_IGNORED_IF_NO_HAPPINESS
; 771  : 	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	19					; 00000013H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	SHORT $LN2@IsAvoidGro

; 772  : 	{
; 773  : 		return false;

	xor	al, al
	pop	esi

; 831  : }

	ret	0
$LN2@IsAvoidGro:

; 774  : 	}
; 775  : #endif
; 776  : 
; 777  : #ifdef AUI_CITIZENS_FIX_FORCED_AVOID_GROWTH_ONLY_WHEN_GROWING_LOWERS_HAPPINESS
; 778  : 	if (GetPlayer()->GetExcessHappiness() <= 0)
; 779  : 	{
; 780  : 		int iPopulation = m_pCity->getPopulation();
; 781  : 		int iLocalHappinessCap = iPopulation;
; 782  : 
; 783  : 		// India has unique way to compute local happiness cap
; 784  : 		if (GetPlayer()->GetPlayerTraits()->GetCityUnhappinessModifier() != 0)
; 785  : 		{
; 786  : 			// 0.67 per population, rounded up
; 787  : 			iLocalHappinessCap = (iLocalHappinessCap * 20) + 15;
; 788  : 			iLocalHappinessCap /= 30;
; 789  : 		}
; 790  : 		// Growing would not be covered by local happiness
; 791  : 		if (m_pCity->GetLocalHappiness() < iLocalHappinessCap)
; 792  : 		{
; 793  : 			int iHappinessPerXPopulation = GetPlayer()->GetHappinessPerXPopulation();
; 794  : 			// Growing would not be covered by happiness per X population
; 795  : 			if (iHappinessPerXPopulation == 0 || m_pCity->IsPuppet() || (iPopulation + 1) / iHappinessPerXPopulation <= iPopulation / iHappinessPerXPopulation)
; 796  : 			{
; 797  : 				// Growing would not be covered by reduced unhappiness from population
; 798  : 				bool bHasSpecialistSlot = false;
; 799  : #ifdef AUI_WARNING_FIXES
; 800  : 				for (uint iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
; 801  : #else
; 802  : 				for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
; 803  : #endif
; 804  : 				{
; 805  : 					const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
; 806  : 					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
; 807  : 					if (pkBuildingInfo)
; 808  : 					{
; 809  : 						if (GetCity()->GetCityBuildings()->GetNumBuilding(eBuilding) > 0 && IsCanAddSpecialistToBuilding(eBuilding))
; 810  : 						{
; 811  : 							bHasSpecialistSlot = true;
; 812  : 							break;
; 813  : 						}
; 814  : 					}
; 815  : 				}
; 816  : 				if ((GetPlayer()->GetUnhappinessFromCityPopulation() + GetPlayer()->GetUnhappinessFromOccupiedCities()) / 100 <
; 817  : 					(GetPlayer()->GetUnhappinessFromCityPopulation(NULL, NULL, m_pCity, (bHasSpecialistSlot ? m_pCity : NULL))
; 818  : 						+ GetPlayer()->GetUnhappinessFromOccupiedCities(NULL, NULL, m_pCity, (bHasSpecialistSlot ? m_pCity : NULL))) / 100)
; 819  : 					return true;
; 820  : 			}
; 821  : 		}
; 822  : 	}
; 823  : #elif !defined(AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS)
; 824  : 	if(GetPlayer()->GetExcessHappiness() < 0)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	test	eax, eax

; 825  : 	{
; 826  : 		return true;

	mov	al, 1
	jl	SHORT $LN3@IsAvoidGro

; 827  : 	}
; 828  : #endif
; 829  : 
; 830  : 	return IsForcedAvoidGrowth();

	mov	al, BYTE PTR [esi+24]
$LN3@IsAvoidGro:
	pop	esi

; 831  : }

	ret	0
?IsAvoidGrowth@CvCityCitizens@@QAE_NXZ ENDP		; CvCityCitizens::IsAvoidGrowth
_TEXT	ENDS
PUBLIC	?IsAIWantSpecialistRightNow@CvCityCitizens@@QAE_NXZ ; CvCityCitizens::IsAIWantSpecialistRightNow
EXTRN	?GetSpecialistYieldChange@CvPlayerTraits@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z:PROC ; CvPlayerTraits::GetSpecialistYieldChange
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?getSpecialistExtraYield@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::getSpecialistExtraYield
EXTRN	?getCulturePerTurn@CvSpecialistInfo@@QBEHXZ:PROC ; CvSpecialistInfo::getCulturePerTurn
EXTRN	?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z:PROC ; CvCityStrategyAI::IsYieldDeficient
EXTRN	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ:PROC ; CvCity::GetCityStrategyAI
EXTRN	?foodConsumption@CvCity@@QBEH_NH@Z:PROC		; CvCity::foodConsumption
EXTRN	?getYieldRate@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRate
; Function compile flags: /Ogtpy
;	COMDAT ?IsAIWantSpecialistRightNow@CvCityCitizens@@QAE_NXZ
_TEXT	SEGMENT
?IsAIWantSpecialistRightNow@CvCityCitizens@@QAE_NXZ PROC ; CvCityCitizens::IsAIWantSpecialistRightNow, COMDAT
; _this$ = ecx

; 874  : {

	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx

; 875  : 	int iWeight = 100;
; 876  : 
; 877  : 	// If the City is Size 1 or 2 then we probably don't want Specialists
; 878  : 	if(m_pCity->getPopulation() < 3)

	mov	ecx, DWORD PTR [ebx]
	push	edi
	mov	ebp, 100				; 00000064H
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 3
	jge	SHORT $LN92@IsAIWantSp

; 879  : 	{
; 880  : 		iWeight /= 2;

	mov	ebp, 50					; 00000032H
$LN92@IsAIWantSp:

; 881  : 	}
; 882  : 
; 883  : 	int iFoodPerTurn = m_pCity->getYieldRate(YIELD_FOOD, false);

	mov	ecx, DWORD PTR [ebx]
	push	0
	push	0
	call	?getYieldRate@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRate

; 884  : 	int iFoodEatenPerTurn = m_pCity->foodConsumption();

	mov	ecx, DWORD PTR [ebx]
	push	0
	push	0
	mov	esi, eax
	call	?foodConsumption@CvCity@@QBEH_NH@Z	; CvCity::foodConsumption

; 885  : 	int iSurplusFood = iFoodPerTurn - iFoodEatenPerTurn;

	sub	esi, eax

; 886  : 
; 887  : 	CityAIFocusTypes eFocusType = GetFocusType();

	mov	edi, DWORD PTR [ebx+20]

; 888  : 
; 889  : 	// Don't want specialists until we've met our food needs
; 890  : 	if(iSurplusFood < 0)

	jns	SHORT $LN91@IsAIWantSp
	pop	edi
	pop	esi
	pop	ebp

; 891  : 	{
; 892  : 		return false;

	xor	al, al
	pop	ebx

; 1194 : 	{
; 1195 : 		return true;
; 1196 : 	}
; 1197 : 
; 1198 : 	return false;
; 1199 : }

	ret	0
$LN91@IsAIWantSp:

; 893  : 	}
; 894  : 	else if(IsAvoidGrowth() && (eFocusType == NO_CITY_AI_FOCUS_TYPE || eFocusType == CITY_AI_FOCUS_TYPE_GREAT_PEOPLE))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	19					; 00000013H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	jne	SHORT $LN211@IsAIWantSp
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	test	eax, eax
	jl	SHORT $LN208@IsAIWantSp
	cmp	BYTE PTR [ebx+24], 0
	je	SHORT $LN211@IsAIWantSp
$LN208@IsAIWantSp:
	cmp	edi, -1
	je	SHORT $LN88@IsAIWantSp
	cmp	edi, 3
	jne	SHORT $LN211@IsAIWantSp
$LN88@IsAIWantSp:

; 895  : 	{
; 896  : 		iWeight *= 2;

	add	ebp, ebp
	jmp	SHORT $LN83@IsAIWantSp
$LN211@IsAIWantSp:

; 897  : 	}
; 898  : 	else if(iSurplusFood <= 2)

	cmp	esi, 2
	jg	SHORT $LN207@IsAIWantSp

; 899  : 	{
; 900  : 		iWeight /= 2;

	mov	eax, ebp
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ebp, eax
	jmp	SHORT $LN83@IsAIWantSp
$LN207@IsAIWantSp:

; 901  : 	}
; 902  : 	else if(iSurplusFood > 2)
; 903  : 	{
; 904  : 		if(eFocusType == NO_CITY_AI_FOCUS_TYPE || eFocusType == CITY_AI_FOCUS_TYPE_GREAT_PEOPLE || eFocusType == CITY_AI_FOCUS_TYPE_PROD_GROWTH)

	cmp	edi, -1
	je	SHORT $LN82@IsAIWantSp
	cmp	edi, 3
	je	SHORT $LN82@IsAIWantSp
	cmp	edi, 6
	jne	SHORT $LN83@IsAIWantSp
$LN82@IsAIWantSp:

; 905  : 		{
; 906  : 			iWeight *= 100 + (20 * (iSurplusFood - 4));
; 907  : 			iWeight /= 100;

	lea	eax, DWORD PTR [esi+1]
	imul	eax, ebp
	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	ebp, ecx
$LN83@IsAIWantSp:

; 908  : 		}
; 909  : 	}
; 910  : 
; 911  : 	// If we're deficient in Production then we're less likely to want Specialists
; 912  : 	if(m_pCity->GetCityStrategyAI()->IsYieldDeficient(YIELD_PRODUCTION))

	mov	ecx, DWORD PTR [ebx]
	push	1
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?IsYieldDeficient@CvCityStrategyAI@@QAE_NW4YieldTypes@@@Z ; CvCityStrategyAI::IsYieldDeficient
	test	al, al
	je	SHORT $LN81@IsAIWantSp

; 913  : 	{
; 914  : 		iWeight *= 50;

	mov	ecx, ebp
	imul	ecx, 50					; 00000032H

; 915  : 		iWeight /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebp, eax
	jmp	SHORT $LN212@IsAIWantSp
$LN81@IsAIWantSp:

; 916  : 	}
; 917  : 	// if we've got some slackers in town (since they provide Production)
; 918  : 	else if(GetNumDefaultSpecialists() > 0 && eFocusType != CITY_AI_FOCUS_TYPE_PRODUCTION && eFocusType != CITY_AI_FOCUS_TYPE_PROD_GROWTH)

	cmp	DWORD PTR [ebx+100], 0
	jle	SHORT $LN212@IsAIWantSp
	cmp	edi, 1
	je	SHORT $LN212@IsAIWantSp
	cmp	edi, 6
	je	SHORT $LN212@IsAIWantSp

; 919  : 	{
; 920  : 		iWeight *= 150;

	mov	ecx, ebp
	imul	ecx, 150				; 00000096H

; 921  : 		iWeight /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	ebp, ecx
$LN212@IsAIWantSp:

; 922  : 	}
; 923  : 
; 924  : 	// Someone told this AI it should be focused on something that is usually gotten from specialists
; 925  : 	if(eFocusType == CITY_AI_FOCUS_TYPE_GREAT_PEOPLE)

	cmp	edi, 3
	jne	SHORT $LN78@IsAIWantSp

; 926  : 	{
; 927  : 		// Loop through all Buildings
; 928  : 		BuildingTypes eBuilding;
; 929  : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN8@IsAIWantSp
$LL77@IsAIWantSp:

; 930  : 		{
; 931  : 			eBuilding = (BuildingTypes) iBuildingLoop;
; 932  : 
; 933  : 			// Have this Building in the City?
; 934  : 			if(m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN76@IsAIWantSp

; 935  : 			{
; 936  : 				// Can't add more than the max
; 937  : 				if(IsCanAddSpecialistToBuilding(eBuilding))

	mov	edx, DWORD PTR [ebx+116]
	mov	ecx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [edx+esi*4]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	edi, eax
	jge	SHORT $LN76@IsAIWantSp
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ecx, eax
	call	?GetSpecialistCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistCount
	cmp	edi, eax
	jge	SHORT $LN76@IsAIWantSp
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7100
	jl	$LN198@IsAIWantSp
$LN76@IsAIWantSp:

; 926  : 	{
; 927  : 		// Loop through all Buildings
; 928  : 		BuildingTypes eBuilding;
; 929  : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	SHORT $LL77@IsAIWantSp

; 938  : 				{
; 939  : 					iWeight *= 3;
; 940  : 					break;
; 941  : 				}
; 942  : 			}
; 943  : 		}
; 944  : 	}
; 945  : 	else if(eFocusType == CITY_AI_FOCUS_TYPE_CULTURE)

	jmp	$LN8@IsAIWantSp
$LN78@IsAIWantSp:
	cmp	edi, 5
	jne	SHORT $LN71@IsAIWantSp

; 946  : 	{
; 947  : 		// Loop through all Buildings
; 948  : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN8@IsAIWantSp
$LL70@IsAIWantSp:

; 949  : 		{
; 950  : 			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
; 951  : 			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 952  : 			if(pkBuildingInfo)

	test	edi, edi
	je	SHORT $LN69@IsAIWantSp

; 953  : 			{
; 954  : 				// Have this Building in the City?
; 955  : 				if(m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN69@IsAIWantSp

; 956  : 				{
; 957  : 					// Can't add more than the max
; 958  : 					if(IsCanAddSpecialistToBuilding(eBuilding))

	push	esi
	mov	ecx, ebx
	call	?IsCanAddSpecialistToBuilding@CvCityCitizens@@QAE_NW4BuildingTypes@@@Z ; CvCityCitizens::IsCanAddSpecialistToBuilding
	test	al, al
	je	SHORT $LN69@IsAIWantSp

; 959  : 					{
; 960  : 						const SpecialistTypes eSpecialist = (SpecialistTypes) pkBuildingInfo->GetSpecialistType();

	mov	ecx, edi
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType

; 961  : 						CvSpecialistInfo* pSpecialistInfo = GC.getSpecialistInfo(eSpecialist);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo

; 962  : 						if(pSpecialistInfo && pSpecialistInfo->getCulturePerTurn() > 0)

	test	eax, eax
	je	SHORT $LN69@IsAIWantSp
	mov	ecx, eax
	call	?getCulturePerTurn@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getCulturePerTurn
	test	eax, eax
	jg	$LN198@IsAIWantSp
$LN69@IsAIWantSp:

; 946  : 	{
; 947  : 		// Loop through all Buildings
; 948  : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	SHORT $LL70@IsAIWantSp

; 963  : 						{
; 964  : 							iWeight *= 3;
; 965  : 							break;
; 966  : 						}
; 967  : 					}
; 968  : 				}
; 969  : 			}
; 970  : 		}
; 971  : 	}
; 972  : 	else if(eFocusType == CITY_AI_FOCUS_TYPE_SCIENCE)

	jmp	$LN8@IsAIWantSp
$LN71@IsAIWantSp:
	cmp	edi, 4
	jne	$LN62@IsAIWantSp

; 973  : 	{
; 974  : 		// Loop through all Buildings
; 975  : 		BuildingTypes eBuilding;
; 976  : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN8@IsAIWantSp
	npad	5
$LL61@IsAIWantSp:

; 977  : 		{
; 978  : 			eBuilding = (BuildingTypes) iBuildingLoop;
; 979  : 
; 980  : 			// Have this Building in the City?
; 981  : 			if(m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	$LN60@IsAIWantSp

; 982  : 			{
; 983  : 				// Can't add more than the max
; 984  : 				if(IsCanAddSpecialistToBuilding(eBuilding))

	push	esi
	mov	ecx, ebx
	call	?IsCanAddSpecialistToBuilding@CvCityCitizens@@QAE_NW4BuildingTypes@@@Z ; CvCityCitizens::IsCanAddSpecialistToBuilding
	test	al, al
	je	$LN60@IsAIWantSp

; 985  : 				{
; 986  : 					SpecialistTypes eSpecialist = (SpecialistTypes) GC.getBuildingInfo(eBuilding)->GetSpecialistType();

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ecx, eax
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType
	mov	edi, eax

; 987  : 					CvSpecialistInfo* pSpecialistInfo = GC.getSpecialistInfo(eSpecialist);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo

; 988  : 					if(pSpecialistInfo && pSpecialistInfo->getYieldChange(YIELD_SCIENCE) > 0)

	test	eax, eax
	je	SHORT $LN56@IsAIWantSp
	push	3
	mov	ecx, eax
	call	?getYieldChange@CvSpecialistInfo@@QBEHH@Z ; CvSpecialistInfo::getYieldChange
	test	eax, eax
	jle	SHORT $LN56@IsAIWantSp

; 989  : 					{
; 990  : 						iWeight *= 3;

	lea	ebp, DWORD PTR [ebp+ebp*2]
$LN56@IsAIWantSp:

; 991  : 					}
; 992  : 
; 993  : 					if(GetPlayer()->getSpecialistExtraYield(YIELD_SCIENCE) > 0)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	3
	call	?getSpecialistExtraYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getSpecialistExtraYield
	test	eax, eax
	jle	SHORT $LN55@IsAIWantSp

; 994  : 					{
; 995  : 						iWeight *= 3;

	lea	ebp, DWORD PTR [ebp+ebp*2]
$LN55@IsAIWantSp:

; 996  : 					}
; 997  : 
; 998  : 					if(GetPlayer()->GetPlayerTraits()->GetSpecialistYieldChange(eSpecialist, YIELD_SCIENCE) > 0)

	mov	ecx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	3
	push	edi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetSpecialistYieldChange@CvPlayerTraits@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetSpecialistYieldChange
	test	eax, eax
	jle	SHORT $LN60@IsAIWantSp

; 999  : 					{
; 1000 : 						iWeight *= 3;

	lea	ebp, DWORD PTR [ebp+ebp*2]
$LN60@IsAIWantSp:

; 973  : 	{
; 974  : 		// Loop through all Buildings
; 975  : 		BuildingTypes eBuilding;
; 976  : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	$LL61@IsAIWantSp

; 1001 : 					}
; 1002 : #ifdef LEK_TRAIT_SPECIALIST_YIELD_MAX_ONE
; 1003 : 					if(GetPlayer()->GetPlayerTraits()->GetAnySpecificSpecialistYieldChange(eSpecialist, YIELD_SCIENCE) > 0)
; 1004 : 					{
; 1005 : 						iWeight *= 3;
; 1006 : 					}
; 1007 : #endif
; 1008 : 				}
; 1009 : 			}
; 1010 : 		}
; 1011 : 	}
; 1012 : 	else if(eFocusType == CITY_AI_FOCUS_TYPE_PRODUCTION)

	jmp	$LN8@IsAIWantSp
$LN62@IsAIWantSp:
	cmp	edi, 1
	jne	$LN52@IsAIWantSp

; 1013 : 	{
; 1014 : 		// Loop through all Buildings
; 1015 : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN8@IsAIWantSp
	npad	8
$LL51@IsAIWantSp:

; 1016 : 		{
; 1017 : 			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
; 1018 : 			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	esi, eax

; 1019 : 			if(pkBuildingInfo)

	test	esi, esi
	je	$LN50@IsAIWantSp

; 1020 : 			{
; 1021 : 				// Have this Building in the City?
; 1022 : 				if(m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	$LN50@IsAIWantSp

; 1023 : 				{
; 1024 : 					// Can't add more than the max
; 1025 : 					if(IsCanAddSpecialistToBuilding(eBuilding))

	push	edi
	mov	ecx, ebx
	call	?IsCanAddSpecialistToBuilding@CvCityCitizens@@QAE_NW4BuildingTypes@@@Z ; CvCityCitizens::IsCanAddSpecialistToBuilding
	test	al, al
	je	$LN50@IsAIWantSp

; 1026 : 					{
; 1027 : 						SpecialistTypes eSpecialist = (SpecialistTypes) pkBuildingInfo->GetSpecialistType();

	mov	ecx, esi
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType
	mov	esi, eax

; 1028 : 						CvSpecialistInfo* pSpecialistInfo = GC.getSpecialistInfo(eSpecialist);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo

; 1029 : 						if(NULL != pSpecialistInfo && pSpecialistInfo->getYieldChange(YIELD_PRODUCTION) > 0)

	test	eax, eax
	je	SHORT $LN45@IsAIWantSp
	push	1
	mov	ecx, eax
	call	?getYieldChange@CvSpecialistInfo@@QBEHH@Z ; CvSpecialistInfo::getYieldChange
	test	eax, eax
	jle	SHORT $LN45@IsAIWantSp

; 1030 : 						{
; 1031 : 							iWeight *= 150;

	mov	ecx, ebp
	imul	ecx, 150				; 00000096H

; 1032 : 							iWeight /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebp, eax
$LN45@IsAIWantSp:

; 1033 : 						}
; 1034 : 
; 1035 : 						if(GetPlayer()->getSpecialistExtraYield(YIELD_PRODUCTION) > 0)

	mov	ecx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	call	?getSpecialistExtraYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getSpecialistExtraYield
	test	eax, eax
	jle	SHORT $LN44@IsAIWantSp

; 1036 : 						{
; 1037 : 							iWeight *= 2;

	add	ebp, ebp
$LN44@IsAIWantSp:

; 1038 : 						}
; 1039 : 
; 1040 : 						if(GetPlayer()->GetPlayerTraits()->GetSpecialistYieldChange(eSpecialist, YIELD_PRODUCTION) > 0)

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	push	esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetSpecialistYieldChange@CvPlayerTraits@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetSpecialistYieldChange
	test	eax, eax
	jle	SHORT $LN50@IsAIWantSp

; 1041 : 						{
; 1042 : 							iWeight *= 2;

	add	ebp, ebp
$LN50@IsAIWantSp:

; 1013 : 	{
; 1014 : 		// Loop through all Buildings
; 1015 : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	edi, eax
	jl	$LL51@IsAIWantSp

; 1043 : 						}
; 1044 : #ifdef LEK_TRAIT_SPECIALIST_YIELD_MAX_ONE
; 1045 : 						if(GetPlayer()->GetPlayerTraits()->GetAnySpecificSpecialistYieldChange(eSpecialist, YIELD_PRODUCTION) > 0)
; 1046 : 						{
; 1047 : 							iWeight *= 2;
; 1048 : 						}
; 1049 : #endif
; 1050 : 					}
; 1051 : 				}
; 1052 : 			}
; 1053 : 		}
; 1054 : 	}
; 1055 : 	else if(eFocusType == CITY_AI_FOCUS_TYPE_GOLD)

	jmp	$LN8@IsAIWantSp
$LN52@IsAIWantSp:
	cmp	edi, 2
	jne	SHORT $LN41@IsAIWantSp

; 1056 : 	{
; 1057 : 		// Loop through all Buildings
; 1058 : 		BuildingTypes eBuilding;
; 1059 : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN8@IsAIWantSp
$LL40@IsAIWantSp:

; 1060 : 		{
; 1061 : 			eBuilding = (BuildingTypes) iBuildingLoop;
; 1062 : 
; 1063 : 			// Have this Building in the City?
; 1064 : 			if(m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN39@IsAIWantSp

; 1065 : 			{
; 1066 : 				// Can't add more than the max
; 1067 : 				if(IsCanAddSpecialistToBuilding(eBuilding))

	push	esi
	mov	ecx, ebx
	call	?IsCanAddSpecialistToBuilding@CvCityCitizens@@QAE_NW4BuildingTypes@@@Z ; CvCityCitizens::IsCanAddSpecialistToBuilding
	test	al, al
	je	SHORT $LN39@IsAIWantSp

; 1068 : 				{
; 1069 : 					SpecialistTypes eSpecialist = (SpecialistTypes) GC.getBuildingInfo(eBuilding)->GetSpecialistType();

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ecx, eax
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType

; 1070 : 					CvSpecialistInfo* pSpecialistInfo = GC.getSpecialistInfo(eSpecialist);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo

; 1071 : 					if(pSpecialistInfo && pSpecialistInfo->getYieldChange(YIELD_GOLD) > 0)

	test	eax, eax
	je	SHORT $LN39@IsAIWantSp
	push	2
	mov	ecx, eax
	call	?getYieldChange@CvSpecialistInfo@@QBEHH@Z ; CvSpecialistInfo::getYieldChange
	test	eax, eax
	jg	$LN197@IsAIWantSp
$LN39@IsAIWantSp:

; 1056 : 	{
; 1057 : 		// Loop through all Buildings
; 1058 : 		BuildingTypes eBuilding;
; 1059 : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	SHORT $LL40@IsAIWantSp

; 1174 : 						if(pSpecialistInfo && pSpecialistInfo->getYieldChange(YIELD_FAITH) > 0)

	jmp	$LN8@IsAIWantSp
$LN41@IsAIWantSp:

; 1072 : 					{
; 1073 : 						iWeight *= 150;
; 1074 : 						iWeight /= 100;
; 1075 : 						break;
; 1076 : 					}
; 1077 : 				}
; 1078 : 			}
; 1079 : 		}
; 1080 : 	}
; 1081 : 	else if(eFocusType == CITY_AI_FOCUS_TYPE_FOOD)

	test	edi, edi
	jne	SHORT $LN33@IsAIWantSp

; 1082 : 	{
; 1083 : 		iWeight *= 50;

	mov	ecx, ebp
	imul	ecx, 50					; 00000032H

; 1084 : 		iWeight /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	ebp, ecx
	jmp	$LN8@IsAIWantSp
$LN33@IsAIWantSp:

; 1085 : 	}
; 1086 : 	else if(eFocusType == CITY_AI_FOCUS_TYPE_PROD_GROWTH)

	cmp	edi, 6
	jne	$LN31@IsAIWantSp

; 1087 : 	{
; 1088 : 		// Loop through all Buildings
; 1089 : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN8@IsAIWantSp
$LL30@IsAIWantSp:

; 1090 : 		{
; 1091 : 			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
; 1092 : 			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 1093 : 			if(pkBuildingInfo)

	test	edi, edi
	je	SHORT $LN29@IsAIWantSp

; 1094 : 			{
; 1095 : 				// Have this Building in the City?
; 1096 : 				if(m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN29@IsAIWantSp

; 1097 : 				{
; 1098 : 					// Can't add more than the max
; 1099 : 					if(IsCanAddSpecialistToBuilding(eBuilding))

	push	esi
	mov	ecx, ebx
	call	?IsCanAddSpecialistToBuilding@CvCityCitizens@@QAE_NW4BuildingTypes@@@Z ; CvCityCitizens::IsCanAddSpecialistToBuilding
	test	al, al
	je	SHORT $LN29@IsAIWantSp

; 1100 : 					{
; 1101 : 						SpecialistTypes eSpecialist = (SpecialistTypes) pkBuildingInfo->GetSpecialistType();

	mov	ecx, edi
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType

; 1102 : 						CvSpecialistInfo* pSpecialistInfo = GC.getSpecialistInfo(eSpecialist);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo

; 1103 : 						if(pSpecialistInfo && pSpecialistInfo->getYieldChange(YIELD_PRODUCTION) > 0)

	test	eax, eax
	je	SHORT $LN29@IsAIWantSp
	push	1
	mov	ecx, eax
	call	?getYieldChange@CvSpecialistInfo@@QBEHH@Z ; CvSpecialistInfo::getYieldChange
	test	eax, eax
	jg	SHORT $LN197@IsAIWantSp
$LN29@IsAIWantSp:

; 1087 : 	{
; 1088 : 		// Loop through all Buildings
; 1089 : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	SHORT $LL30@IsAIWantSp

; 1174 : 						if(pSpecialistInfo && pSpecialistInfo->getYieldChange(YIELD_FAITH) > 0)

	jmp	$LN8@IsAIWantSp
$LN197@IsAIWantSp:

; 1104 : 						{
; 1105 : 							iWeight *= 150;

	mov	ecx, ebp
	imul	ecx, 150				; 00000096H

; 1106 : 							iWeight /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebp, eax

; 1107 : 							break;
; 1108 : 						}
; 1109 : 					}
; 1110 : 				}
; 1111 : 			}
; 1112 : 		}
; 1113 : 	}
; 1114 : 	else if(eFocusType == CITY_AI_FOCUS_TYPE_GOLD_GROWTH)

	jmp	$LN8@IsAIWantSp
$LN31@IsAIWantSp:
	cmp	edi, 7
	jne	$LN22@IsAIWantSp

; 1115 : 	{
; 1116 : 		// Loop through all Buildings
; 1117 : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN8@IsAIWantSp
	npad	8
$LL21@IsAIWantSp:

; 1118 : 		{
; 1119 : 			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
; 1120 : 			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	esi, eax

; 1121 : 			if(pkBuildingInfo)

	test	esi, esi
	je	$LN20@IsAIWantSp

; 1122 : 			{
; 1123 : 				// Have this Building in the City?
; 1124 : 				if(m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	$LN20@IsAIWantSp

; 1125 : 				{
; 1126 : 					// Can't add more than the max
; 1127 : 					if(IsCanAddSpecialistToBuilding(eBuilding))

	push	edi
	mov	ecx, ebx
	call	?IsCanAddSpecialistToBuilding@CvCityCitizens@@QAE_NW4BuildingTypes@@@Z ; CvCityCitizens::IsCanAddSpecialistToBuilding
	test	al, al
	je	$LN20@IsAIWantSp

; 1128 : 					{
; 1129 : 						SpecialistTypes eSpecialist = (SpecialistTypes) pkBuildingInfo->GetSpecialistType();

	mov	ecx, esi
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType
	mov	esi, eax

; 1130 : 						CvSpecialistInfo* pSpecialistInfo = GC.getSpecialistInfo(eSpecialist);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo

; 1131 : 						if(pSpecialistInfo && pSpecialistInfo->getYieldChange(YIELD_GOLD) > 0)

	test	eax, eax
	je	SHORT $LN15@IsAIWantSp
	push	2
	mov	ecx, eax
	call	?getYieldChange@CvSpecialistInfo@@QBEHH@Z ; CvSpecialistInfo::getYieldChange
	test	eax, eax
	jle	SHORT $LN15@IsAIWantSp

; 1132 : 						{
; 1133 : 							iWeight *= 150;

	mov	ecx, ebp
	imul	ecx, 150				; 00000096H

; 1134 : 							iWeight /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	ebp, ecx
$LN15@IsAIWantSp:

; 1135 : 						}
; 1136 : 
; 1137 : 						if(GetPlayer()->getSpecialistExtraYield(YIELD_GOLD) > 0)

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	2
	call	?getSpecialistExtraYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getSpecialistExtraYield
	test	eax, eax
	jle	SHORT $LN14@IsAIWantSp

; 1138 : 						{
; 1139 : 							iWeight *= 2;

	add	ebp, ebp
$LN14@IsAIWantSp:

; 1140 : 						}
; 1141 : 
; 1142 : 						if(GetPlayer()->GetPlayerTraits()->GetSpecialistYieldChange(eSpecialist, YIELD_GOLD) > 0)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	2
	push	esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetSpecialistYieldChange@CvPlayerTraits@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetSpecialistYieldChange
	test	eax, eax
	jle	SHORT $LN20@IsAIWantSp

; 1143 : 						{
; 1144 : 							iWeight *= 2;

	add	ebp, ebp
$LN20@IsAIWantSp:

; 1115 : 	{
; 1116 : 		// Loop through all Buildings
; 1117 : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	edi, eax
	jl	$LL21@IsAIWantSp

; 1145 : 						}
; 1146 : #ifdef LEK_TRAIT_SPECIALIST_YIELD_MAX_ONE
; 1147 : 						if(GetPlayer()->GetPlayerTraits()->GetAnySpecificSpecialistYieldChange(eSpecialist, YIELD_GOLD) > 0)
; 1148 : 						{
; 1149 : 							iWeight *= 2;
; 1150 : 						}
; 1151 : #endif
; 1152 : 					}
; 1153 : 				}
; 1154 : 			}
; 1155 : 		}
; 1156 : 	}
; 1157 : 	else if(eFocusType == CITY_AI_FOCUS_TYPE_FAITH)

	jmp	$LN8@IsAIWantSp
$LN22@IsAIWantSp:
	cmp	edi, 8
	jne	$LN8@IsAIWantSp

; 1158 : 	{
; 1159 : 		// Loop through all Buildings
; 1160 : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	SHORT $LN8@IsAIWantSp
$LL10@IsAIWantSp:

; 1161 : 		{
; 1162 : 			const BuildingTypes eBuilding = (BuildingTypes) iBuildingLoop;
; 1163 : 			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 1164 : 			if(pkBuildingInfo)

	test	edi, edi
	je	SHORT $LN9@IsAIWantSp

; 1165 : 			{
; 1166 : 				// Have this Building in the City?
; 1167 : 				if(m_pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN9@IsAIWantSp

; 1168 : 				{
; 1169 : 					// Can't add more than the max
; 1170 : 					if(IsCanAddSpecialistToBuilding(eBuilding))

	push	esi
	mov	ecx, ebx
	call	?IsCanAddSpecialistToBuilding@CvCityCitizens@@QAE_NW4BuildingTypes@@@Z ; CvCityCitizens::IsCanAddSpecialistToBuilding
	test	al, al
	je	SHORT $LN9@IsAIWantSp

; 1171 : 					{
; 1172 : 						const SpecialistTypes eSpecialist = (SpecialistTypes) pkBuildingInfo->GetSpecialistType();

	mov	ecx, edi
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType

; 1173 : 						CvSpecialistInfo* pSpecialistInfo = GC.getSpecialistInfo(eSpecialist);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo

; 1174 : 						if(pSpecialistInfo && pSpecialistInfo->getYieldChange(YIELD_FAITH) > 0)

	test	eax, eax
	je	SHORT $LN9@IsAIWantSp
	push	5
	mov	ecx, eax
	call	?getYieldChange@CvSpecialistInfo@@QBEHH@Z ; CvSpecialistInfo::getYieldChange
	test	eax, eax
	jg	SHORT $LN198@IsAIWantSp
$LN9@IsAIWantSp:

; 1158 : 	{
; 1159 : 		// Loop through all Buildings
; 1160 : 		for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	SHORT $LL10@IsAIWantSp

; 1174 : 						if(pSpecialistInfo && pSpecialistInfo->getYieldChange(YIELD_FAITH) > 0)

	jmp	SHORT $LN8@IsAIWantSp
$LN198@IsAIWantSp:

; 1175 : 						{
; 1176 : 							iWeight *= 3;

	lea	ebp, DWORD PTR [ebp+ebp*2]
$LN8@IsAIWantSp:

; 1177 : 							break;
; 1178 : 						}
; 1179 : 					}
; 1180 : 				}
; 1181 : 			}
; 1182 : 		}
; 1183 : 	}
; 1184 : 
; 1185 : 	// specialists are cheaper somehow
; 1186 : 	if (m_pCity->GetPlayer()->isHalfSpecialistUnhappiness() || m_pCity->GetPlayer()->isHalfSpecialistFood())

	mov	ecx, DWORD PTR [ebx]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?isHalfSpecialistUnhappiness@CvPlayer@@QBE_NXZ ; CvPlayer::isHalfSpecialistUnhappiness
	test	al, al
	jne	SHORT $LN2@IsAIWantSp
	mov	ecx, DWORD PTR [ebx]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?isHalfSpecialistFood@CvPlayer@@QBE_NXZ	; CvPlayer::isHalfSpecialistFood
	test	al, al
	je	SHORT $LN3@IsAIWantSp
$LN2@IsAIWantSp:

; 1187 : 	{
; 1188 : 		iWeight *= 150;

	mov	ecx, ebp
	imul	ecx, 150				; 00000096H

; 1189 : 		iWeight /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	ebp, ecx
$LN3@IsAIWantSp:
	pop	edi
	pop	esi

; 1190 : 	}
; 1191 : 
; 1192 : 	// Does the AI want it enough?
; 1193 : 	if(iWeight >= 150)

	cmp	ebp, 150				; 00000096H
	pop	ebp
	setge	al
	pop	ebx

; 1194 : 	{
; 1195 : 		return true;
; 1196 : 	}
; 1197 : 
; 1198 : 	return false;
; 1199 : }

	ret	0
?IsAIWantSpecialistRightNow@CvCityCitizens@@QAE_NXZ ENDP ; CvCityCitizens::IsAIWantSpecialistRightNow
_TEXT	ENDS
PUBLIC	?GetSpecialistValue@CvCityCitizens@@QAEHW4SpecialistTypes@@@Z ; CvCityCitizens::GetSpecialistValue
EXTRN	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRateTimes100
EXTRN	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsEmpireUnhappy
EXTRN	?getGreatPeopleRateChange@CvSpecialistInfo@@QBEHXZ:PROC ; CvSpecialistInfo::getGreatPeopleRateChange
EXTRN	?GetCultureFromSpecialist@CvCity@@QBEHW4SpecialistTypes@@@Z:PROC ; CvCity::GetCultureFromSpecialist
EXTRN	?specialistYield@CvPlayer@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z:PROC ; CvPlayer::specialistYield
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistValue@CvCityCitizens@@QAEHW4SpecialistTypes@@@Z
_TEXT	SEGMENT
_iGoldYieldValue$ = -24					; size = 4
_iProductionYieldValue$ = -20				; size = 4
_iGPPYieldValue$ = -16					; size = 4
_pSpecialistInfo$ = -16					; size = 4
_iCultureYieldValue$ = -12				; size = 4
_iScienceYieldValue$ = -8				; size = 4
$T228881 = -4						; size = 4
_iExcessFoodTimes100$ = -4				; size = 4
tv498 = 8						; size = 4
$T228901 = 8						; size = 4
$T228897 = 8						; size = 4
$T228893 = 8						; size = 4
$T228889 = 8						; size = 4
$T228885 = 8						; size = 4
_bAvoidGrowth$ = 8					; size = 1
_iFoodConsumptionBonus$ = 8				; size = 4
_eSpecialist$ = 8					; size = 4
?GetSpecialistValue@CvCityCitizens@@QAEHW4SpecialistTypes@@@Z PROC ; CvCityCitizens::GetSpecialistValue, COMDAT
; _this$ = ecx

; 1304 : {

	sub	esp, 24					; 00000018H
	push	ebp
	push	edi

; 1305 : 
; 1306 : 	CvSpecialistInfo* pSpecialistInfo = GC.getSpecialistInfo(eSpecialist);

	mov	edi, DWORD PTR _eSpecialist$[esp+28]
	mov	ebp, ecx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo
	mov	DWORD PTR _pSpecialistInfo$[esp+32], eax

; 1307 : 	if (pSpecialistInfo == NULL)

	test	eax, eax
	jne	SHORT $LN30@GetSpecial@2
	pop	edi
	pop	ebp

; 1788 : }

	add	esp, 24					; 00000018H
	ret	4
$LN30@GetSpecial@2:

; 1308 : 	{
; 1309 : 		//This function should NEVER be called with an invalid specialist info type.
; 1310 : 		CvAssert(pSpecialistInfo);
; 1311 : 		return 0;
; 1312 : 	}
; 1313 : 
; 1314 : 	int iValue = 0;
; 1315 : 
; 1316 : 	CvPlayer* pPlayer = m_pCity->GetPlayer();

	mov	ecx, DWORD PTR [ebp]
	push	ebx
	push	esi
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	esi, eax

; 1317 : 
; 1318 : 	// factor in the fact that specialists may need less food
; 1319 : #ifdef AUI_CITIZENS_FIX_SPECIALIST_VALUE_HALF_FOOD_CONSUMPTION
; 1320 : 	int iFoodConsumptionBonus = (pPlayer->isHalfSpecialistFood() && eSpecialist != (SpecialistTypes)GC.getDEFAULT_SPECIALIST()) ? GC.getFOOD_CONSUMPTION_PER_POPULATION() / 2 : 0;
; 1321 : #else
; 1322 : 	int iFoodConsumptionBonus = (pPlayer->isHalfSpecialistFood()) ? 1 : 0;

	mov	ecx, esi
	call	?isHalfSpecialistFood@CvPlayer@@QBE_NXZ	; CvPlayer::isHalfSpecialistFood

; 1323 : #endif
; 1324 : 
; 1325 : #ifdef AUI_CITIZENS_GET_SPECIALIST_VALUE_ACCOUNT_FOR_GURUSHIP
; 1326 : 	const CvReligion* pReligion = NULL;
; 1327 : 	const CvBeliefEntry* pSecondaryBelief = NULL;
; 1328 : 	ReligionTypes eMajority = m_pCity->GetCityReligions()->GetReligiousMajority();
; 1329 : 	if (eMajority != NO_RELIGION && GetTotalSpecialistCount() == (bForRemoval ? 1 : 0))
; 1330 : 	{
; 1331 : 		pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, GetPlayer()->GetID());
; 1332 : 		BeliefTypes eSecondaryPantheon = m_pCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();
; 1333 : 		if (eSecondaryPantheon != NO_BELIEF)
; 1334 : 			pSecondaryBelief = GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon);
; 1335 : 	}
; 1336 : #endif
; 1337 : 
; 1338 : 	// Yield Values
; 1339 : #ifdef AUI_CITIZENS_GET_VALUE_SPLIT_EXCESS_FOOD_MUTLIPLIER
; 1340 : 	int iFoodYieldValue = /*12*/ GC.getAI_CITIZEN_VALUE_FOOD();
; 1341 : #else
; 1342 : 	int iFoodYieldValue = (GC.getAI_CITIZEN_VALUE_FOOD() * (pPlayer->specialistYield(eSpecialist, YIELD_FOOD) + iFoodConsumptionBonus));

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2376
	xor	ecx, ecx
	test	al, al
	setne	cl
	push	0
	push	edi
	mov	DWORD PTR $T228881[esp+48], edx
	mov	DWORD PTR _iFoodConsumptionBonus$[esp+44], ecx
	mov	ecx, esi
	call	?specialistYield@CvPlayer@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvPlayer::specialistYield
	mov	ebx, eax
	add	ebx, DWORD PTR _iFoodConsumptionBonus$[esp+36]

; 1343 : #endif
; 1344 : 	int iProductionYieldValue = (GC.getAI_CITIZEN_VALUE_PRODUCTION() * pPlayer->specialistYield(eSpecialist, YIELD_PRODUCTION));

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2380
	imul	ebx, DWORD PTR $T228881[esp+40]
	push	1
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T228885[esp+44], eax
	call	?specialistYield@CvPlayer@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvPlayer::specialistYield
	imul	eax, DWORD PTR $T228885[esp+36]

; 1345 : #ifdef AUI_CITIZENS_GOLD_YIELD_COUNTS_AS_SCIENCE_WHEN_IN_DEFICIT
; 1346 : 	int iGoldYieldValue = (pPlayer->specialistYield(eSpecialist, YIELD_GOLD));
; 1347 : 	int iScienceYieldValue = (pPlayer->specialistYield(eSpecialist, YIELD_SCIENCE));
; 1348 : #else
; 1349 : 	int iGoldYieldValue = (GC.getAI_CITIZEN_VALUE_GOLD() * pPlayer->specialistYield(eSpecialist, YIELD_GOLD));

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2384
	push	2
	mov	DWORD PTR $T228889[esp+40], ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _iProductionYieldValue$[esp+48], eax
	call	?specialistYield@CvPlayer@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvPlayer::specialistYield
	imul	eax, DWORD PTR $T228889[esp+36]

; 1350 : 	int iScienceYieldValue = (GC.getAI_CITIZEN_VALUE_SCIENCE() * pPlayer->specialistYield(eSpecialist, YIELD_SCIENCE));

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2388
	push	3
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _iGoldYieldValue$[esp+48], eax
	mov	DWORD PTR $T228893[esp+44], edx
	call	?specialistYield@CvPlayer@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvPlayer::specialistYield
	imul	eax, DWORD PTR $T228893[esp+36]

; 1351 : #endif
; 1352 : 	int iCultureYieldValue = (GC.getAI_CITIZEN_VALUE_CULTURE() * m_pCity->GetCultureFromSpecialist(eSpecialist)); 

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR _iScienceYieldValue$[esp+40], eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2392
	push	edi
	mov	DWORD PTR $T228897[esp+40], eax
	call	?GetCultureFromSpecialist@CvCity@@QBEHW4SpecialistTypes@@@Z ; CvCity::GetCultureFromSpecialist
	imul	eax, DWORD PTR $T228897[esp+36]

; 1353 : 	int iFaithYieldValue = (GC.getAI_CITIZEN_VALUE_FAITH() * pPlayer->specialistYield(eSpecialist, YIELD_FAITH));

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2396
	push	5
	mov	DWORD PTR $T228901[esp+40], ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _iCultureYieldValue$[esp+48], eax
	call	?specialistYield@CvPlayer@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvPlayer::specialistYield

; 1354 : #ifdef AUI_CITIZENS_GET_SPECIALIST_VALUE_ACCOUNT_FOR_GURUSHIP
; 1355 : 	if (pReligion)
; 1356 : 	{
; 1357 : 		iProductionYieldValue += GC.getAI_CITIZEN_VALUE_PRODUCTION() * pReligion->m_Beliefs.GetYieldChangeAnySpecialist(YIELD_PRODUCTION);
; 1358 : #ifdef AUI_CITIZENS_GOLD_YIELD_COUNTS_AS_SCIENCE_WHEN_IN_DEFICIT
; 1359 : 		iGoldYieldValue += pReligion->m_Beliefs.GetYieldChangeAnySpecialist(YIELD_GOLD);
; 1360 : 		iScienceYieldValue += pReligion->m_Beliefs.GetYieldChangeAnySpecialist(YIELD_SCIENCE);
; 1361 : #else
; 1362 : 		iGoldYieldValue += GC.getAI_CITIZEN_VALUE_GOLD() * pReligion->m_Beliefs.GetYieldChangeAnySpecialist(YIELD_GOLD);
; 1363 : 		iScienceYieldValue += GC.getAI_CITIZEN_VALUE_SCIENCE() * pReligion->m_Beliefs.GetYieldChangeAnySpecialist(YIELD_SCIENCE);
; 1364 : #endif
; 1365 : 		iCultureYieldValue += GC.getAI_CITIZEN_VALUE_CULTURE() * pReligion->m_Beliefs.GetYieldChangeAnySpecialist(YIELD_CULTURE);
; 1366 : 		iFaithYieldValue += GC.getAI_CITIZEN_VALUE_FAITH() * pReligion->m_Beliefs.GetYieldChangeAnySpecialist(YIELD_FAITH);
; 1367 : 	}
; 1368 : 	if (pSecondaryBelief)
; 1369 : 	{
; 1370 : 		iProductionYieldValue += GC.getAI_CITIZEN_VALUE_PRODUCTION() * pSecondaryBelief->GetYieldChangeAnySpecialist(YIELD_PRODUCTION);
; 1371 : #ifdef AUI_CITIZENS_GOLD_YIELD_COUNTS_AS_SCIENCE_WHEN_IN_DEFICIT
; 1372 : 		iGoldYieldValue += pSecondaryBelief->GetYieldChangeAnySpecialist(YIELD_GOLD);
; 1373 : 		iScienceYieldValue += pSecondaryBelief->GetYieldChangeAnySpecialist(YIELD_SCIENCE);
; 1374 : #else
; 1375 : 		iGoldYieldValue += GC.getAI_CITIZEN_VALUE_GOLD() * pSecondaryBelief->GetYieldChangeAnySpecialist(YIELD_GOLD);
; 1376 : 		iScienceYieldValue += GC.getAI_CITIZEN_VALUE_SCIENCE() * pSecondaryBelief->GetYieldChangeAnySpecialist(YIELD_SCIENCE);
; 1377 : #endif
; 1378 : 		iCultureYieldValue += GC.getAI_CITIZEN_VALUE_CULTURE() * pSecondaryBelief->GetYieldChangeAnySpecialist(YIELD_CULTURE);
; 1379 : 		iFaithYieldValue += GC.getAI_CITIZEN_VALUE_FAITH() * pSecondaryBelief->GetYieldChangeAnySpecialist(YIELD_FAITH);
; 1380 : 	}
; 1381 : #endif
; 1382 : 	int iGPPYieldValue = pSpecialistInfo->getGreatPeopleRateChange() * 3; // TODO: un-hardcode this

	mov	ecx, DWORD PTR _pSpecialistInfo$[esp+40]
	mov	edi, eax
	imul	edi, DWORD PTR $T228901[esp+36]
	call	?getGreatPeopleRateChange@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleRateChange

; 1383 : #ifdef AUI_CITIZENS_UNHARDCODE_SPECIALIST_VALUE_HAPPINESS
; 1384 : 	int iHappinessYieldValue = 0;
; 1385 : 	int iExtraUnhappinessT100 = 0;
; 1386 : 	if (pPlayer->isHalfSpecialistUnhappiness() && eSpecialist != (SpecialistTypes)GC.getDEFAULT_SPECIALIST())
; 1387 : 	{
; 1388 : 		iExtraUnhappinessT100 = -GC.getUNHAPPINESS_PER_POPULATION() * 50;
; 1389 : 		// To account for rounding up of halved unhappiness
; 1390 : 		if ((GetTotalSpecialistCount() % 2 == 0) != bForRemoval)
; 1391 : 			iExtraUnhappinessT100 *= 2;
; 1392 : 		if (pPlayer->GetCapitalUnhappinessMod() != 0 && m_pCity->isCapital())
; 1393 : 		{
; 1394 : 			iExtraUnhappinessT100 *= (100 + pPlayer->GetCapitalUnhappinessMod());
; 1395 : 			iExtraUnhappinessT100 /= 100;
; 1396 : 		}
; 1397 : 		iExtraUnhappinessT100 *= (100 + pPlayer->GetUnhappinessMod());
; 1398 : 		iExtraUnhappinessT100 /= 100;
; 1399 : 		iExtraUnhappinessT100 *= (100 + pPlayer->GetPlayerTraits()->GetPopulationUnhappinessModifier());
; 1400 : 		iExtraUnhappinessT100 /= 100;
; 1401 : 		// Handicap mod
; 1402 : 		iExtraUnhappinessT100 *= pPlayer->getHandicapInfo().getPopulationUnhappinessMod();
; 1403 : 		iExtraUnhappinessT100 /= 100;
; 1404 : 
; 1405 : 		// The more happiness we have, the less it's worth
; 1406 : 		// Numbers below are based on Primitive function of f = 2^(1-(Empire Happiness)/10) -> F = -20/ln(2) * 2^(-(Empire Happiness)/10)
; 1407 : 		double dHappinessPre = double(pPlayer->GetExcessHappiness());
; 1408 : 		if (bForRemoval)
; 1409 : 			dHappinessPre += double(iExtraUnhappinessT100) / 100.0;
; 1410 : 		double dHappinessPost = dHappinessPre - double(iExtraUnhappinessT100) / 100.0;
; 1411 : 		double dHappinessYieldValuePre = pow(2.0, dHappinessPre / -10.0) * -20 / M_LN2;
; 1412 : 		double dHappinessYieldValuePost = pow(2.0, dHappinessPost / -10.0) * -20 / M_LN2;
; 1413 : 		iHappinessYieldValue = int(AUI_CITIZENS_UNHARDCODE_SPECIALIST_VALUE_HAPPINESS * (dHappinessYieldValuePost - dHappinessYieldValuePre) + 0.5);
; 1414 : 
; 1415 : 		iHappinessYieldValue *= -iExtraUnhappinessT100;
; 1416 : 		iHappinessYieldValue /= 100;
; 1417 : 		if (bForRemoval)
; 1418 : 			iExtraUnhappinessT100 *= -1;
; 1419 : 	}
; 1420 : #else
; 1421 : 	int iHappinessYieldValue = (m_pCity->GetPlayer()->isHalfSpecialistUnhappiness()) ? 5 : 0; // TODO: un-hardcode this

	mov	ecx, DWORD PTR [ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _iGPPYieldValue$[esp+40], edx
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?isHalfSpecialistUnhappiness@CvPlayer@@QBE_NXZ ; CvPlayer::isHalfSpecialistUnhappiness

; 1422 : 	iHappinessYieldValue = m_pCity->GetPlayer()->IsEmpireUnhappy() ? iHappinessYieldValue * 2 : iHappinessYieldValue; // TODO: un-hardcode this

	mov	ecx, DWORD PTR [ebp]
	movzx	esi, al
	neg	esi
	sbb	esi, esi
	and	esi, 5
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	test	al, al
	je	SHORT $LN33@GetSpecial@2
	add	esi, esi
$LN33@GetSpecial@2:

; 1423 : #endif
; 1424 : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_YIELD_RATE_MODIFIERS
; 1425 : #ifdef AUI_CITIZENS_CONSIDER_HAPPINESS_VALUE_ON_OTHER_YIELDS
; 1426 : #ifndef AUI_CITIZENS_GET_VALUE_SPLIT_EXCESS_FOOD_MUTLIPLIER
; 1427 : 	iFoodYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_FOOD, 0, NULL, -iExtraUnhappinessT100 / 100);
; 1428 : #endif
; 1429 : 	iProductionYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_PRODUCTION, 0, NULL, -iExtraUnhappinessT100 / 100);
; 1430 : 	iGoldYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_GOLD, 0, NULL, -iExtraUnhappinessT100 / 100);
; 1431 : 	iScienceYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_SCIENCE, 0, NULL, -iExtraUnhappinessT100 / 100);
; 1432 : 	iCultureYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_CULTURE, 0, NULL, -iExtraUnhappinessT100 / 100);
; 1433 : 	iFaithYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_FAITH, 0, NULL, -iExtraUnhappinessT100 / 100);
; 1434 : #else
; 1435 : #ifndef AUI_CITIZENS_GET_VALUE_SPLIT_EXCESS_FOOD_MUTLIPLIER
; 1436 : 	iFoodYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_FOOD);
; 1437 : #endif
; 1438 : 	iProductionYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_PRODUCTION);
; 1439 : 	iGoldYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_GOLD);
; 1440 : 	iScienceYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_SCIENCE);
; 1441 : 	iCultureYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_CULTURE);
; 1442 : 	iFaithYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_FAITH);
; 1443 : #endif
; 1444 : 
; 1445 : #ifndef AUI_CITIZENS_UNHARDCODE_SPECIALIST_VALUE_GREAT_PERSON_POINTS
; 1446 : 	int iGPPModifier = 100 + pPlayer->getGreatPeopleRateModifier() + GetCity()->getGreatPeopleRateModifier();
; 1447 : 	UnitClassTypes eGPUnitClass = (UnitClassTypes)pSpecialistInfo->getGreatPeopleUnitClass();
; 1448 : 	if (eGPUnitClass != NO_UNITCLASS)
; 1449 : 	{
; 1450 : 		if (eGPUnitClass == (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_WRITER", true))
; 1451 : 		{
; 1452 : 			iGPPModifier += pPlayer->getGreatWriterRateModifier();
; 1453 : 		}
; 1454 : 		else if (eGPUnitClass == (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_ARTIST", true))
; 1455 : 		{
; 1456 : 			iGPPModifier += pPlayer->getGreatArtistRateModifier();
; 1457 : 		}
; 1458 : 		else if (eGPUnitClass == (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_MUSICIAN", true))
; 1459 : 		{
; 1460 : 			iGPPModifier += pPlayer->getGreatMusicianRateModifier();
; 1461 : 		}
; 1462 : 		else if (eGPUnitClass == (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_SCIENTIST", true))
; 1463 : 		{
; 1464 : 			iGPPModifier += pPlayer->getGreatScientistRateModifier();
; 1465 : 		}
; 1466 : 		else if (eGPUnitClass == (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_MERCHANT", true))
; 1467 : 		{
; 1468 : 			iGPPModifier += pPlayer->getGreatMerchantRateModifier();
; 1469 : 		}
; 1470 : 		else if (eGPUnitClass == (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_ENGINEER", true))
; 1471 : 		{
; 1472 : 			iGPPModifier += pPlayer->getGreatEngineerRateModifier();
; 1473 : 		}
; 1474 : 		else if (eGPUnitClass == (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_GENERAL", true))
; 1475 : 		{
; 1476 : 			iGPPModifier += pPlayer->getGreatGeneralRateModifier();
; 1477 : 		}
; 1478 : 		else if (eGPUnitClass == (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_ADMIRAL", true))
; 1479 : 		{
; 1480 : 			iGPPModifier += pPlayer->getGreatAdmiralRateModifier();
; 1481 : 		}
; 1482 : 	}
; 1483 : 	iGPPYieldValue *= iGPPModifier;
; 1484 : #endif
; 1485 : #endif
; 1486 : #ifdef AUI_CITIZENS_GOLD_YIELD_COUNTS_AS_SCIENCE_WHEN_IN_DEFICIT
; 1487 : 	int iCurrentScienceLoss = -GetPlayer()->calculateGoldRateTimes100() - GetPlayer()->GetTreasury()->GetGoldTimes100();
; 1488 : 	if (bForRemoval)
; 1489 : 		iCurrentScienceLoss += iGoldYieldValue;
; 1490 : 	if (iCurrentScienceLoss > 0)
; 1491 : 	{
; 1492 : 		int iGoldToScienceT100 = MIN(iGoldYieldValue, iCurrentScienceLoss);
; 1493 : 		iGoldYieldValue -= iGoldToScienceT100;
; 1494 : 		iScienceYieldValue += iGoldToScienceT100;
; 1495 : 	}
; 1496 : 	iGoldYieldValue *= GC.getAI_CITIZEN_VALUE_GOLD();
; 1497 : 	iScienceYieldValue *= GC.getAI_CITIZEN_VALUE_SCIENCE();
; 1498 : #endif
; 1499 : 
; 1500 : 	// How much surplus food are we making?
; 1501 : 	int iExcessFoodTimes100 = m_pCity->getYieldRateTimes100(YIELD_FOOD, false) - (m_pCity->foodConsumption() * 100);

	mov	ecx, DWORD PTR [ebp]
	push	0
	push	0
	call	?foodConsumption@CvCity@@QBEH_NH@Z	; CvCity::foodConsumption
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR [ebp]
	push	0
	push	0
	mov	DWORD PTR tv498[esp+44], eax
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	sub	eax, DWORD PTR tv498[esp+36]

; 1502 : #if defined(AUI_CITIZENS_GET_VALUE_SPLIT_EXCESS_FOOD_MUTLIPLIER) || defined(AUI_CITIZENS_GET_VALUE_ALTER_FOOD_VALUE_IF_FOOD_PRODUCTION) || defined(AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS)
; 1503 : 	int iSpecialistBaseFoodYield = pPlayer->specialistYield(eSpecialist, YIELD_FOOD);
; 1504 : #ifdef AUI_CITIZENS_GET_SPECIALIST_VALUE_ACCOUNT_FOR_GURUSHIP
; 1505 : 	if (pReligion)
; 1506 : 		iSpecialistBaseFoodYield += pReligion->m_Beliefs.GetYieldChangeAnySpecialist(YIELD_FOOD) * 100;
; 1507 : 	if (pSecondaryBelief)
; 1508 : 		iSpecialistBaseFoodYield += pSecondaryBelief->GetYieldChangeAnySpecialist(YIELD_FOOD) * 100;
; 1509 : #endif
; 1510 : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_YIELD_RATE_MODIFIERS
; 1511 : #ifdef AUI_CITIZENS_CONSIDER_HAPPINESS_VALUE_ON_OTHER_YIELDS
; 1512 : 	iSpecialistBaseFoodYield *= m_pCity->getBaseYieldRateModifier(YIELD_FOOD, 0, NULL, -iExtraUnhappinessT100 / 100);
; 1513 : #else
; 1514 : 	iSpecialistBaseFoodYield *= m_pCity->getBaseYieldRateModifier(YIELD_FOOD);
; 1515 : #endif
; 1516 : #endif
; 1517 : 	if (bForRemoval)
; 1518 : 		iExcessFoodTimes100 -= iSpecialistBaseFoodYield + iFoodConsumptionBonus;
; 1519 : 	int iExcessFoodWithPlotTimes100 = iSpecialistBaseFoodYield + iExcessFoodTimes100 + iFoodConsumptionBonus;
; 1520 : #endif
; 1521 : #ifdef AUI_CITIZENS_CONSIDER_HAPPINESS_VALUE_ON_OTHER_YIELDS
; 1522 : 	// Excess Food bit is to make sure we don't starve to death trying to allocate specialists when we're unhappy
; 1523 : 	if (iExcessFoodWithPlotTimes100 >= 0 && (pPlayer->GetExcessHappiness() - iExtraUnhappinessT100 / 100 >= 0) != (pPlayer->GetExcessHappiness() >= 0))
; 1524 : 	{
; 1525 : 		int iBonusScience = GetPlayer()->GetScienceFromHappinessTimes100(true);
; 1526 : 		if (pPlayer->GetExcessHappiness() >= 0)
; 1527 : 			iBonusScience *= -1;
; 1528 : 		iScienceYieldValue += GC.getAI_CITIZEN_VALUE_SCIENCE() * iBonusScience / GetPlayer()->getNumCities();
; 1529 : 	}
; 1530 : 	// Happiness to culture already multiplied by 100
; 1531 : 	if (pPlayer->GetExcessHappiness() + -iExtraUnhappinessT100 / 100 >= 0)
; 1532 : 		iCultureYieldValue += GC.getAI_CITIZEN_VALUE_CULTURE() * (-iExtraUnhappinessT100 / 100) * GetPlayer()->getHappinessToCulture();
; 1533 : #endif
; 1534 : 
; 1535 : 	bool bAvoidGrowth = IsAvoidGrowth();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	19					; 00000013H
	mov	DWORD PTR _iExcessFoodTimes100$[esp+44], eax
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	SHORT $LN48@GetSpecial@2
	mov	BYTE PTR _bAvoidGrowth$[esp+36], 0
	jmp	SHORT $LN49@GetSpecial@2
$LN48@GetSpecial@2:
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	test	eax, eax
	jge	SHORT $LN47@GetSpecial@2
	mov	BYTE PTR _bAvoidGrowth$[esp+36], 1
	jmp	SHORT $LN49@GetSpecial@2
$LN47@GetSpecial@2:
	mov	cl, BYTE PTR [ebp+24]
	mov	BYTE PTR _bAvoidGrowth$[esp+36], cl
$LN49@GetSpecial@2:

; 1536 : 
; 1537 : 	// City Focus
; 1538 : 	CityAIFocusTypes eFocus = GetFocusType();

	mov	ecx, DWORD PTR [ebp+20]

; 1539 : 	if(eFocus == CITY_AI_FOCUS_TYPE_FOOD)

	test	ecx, ecx
	jne	SHORT $LN29@GetSpecial@2

; 1540 : 		iFoodYieldValue *= 3;

	lea	ebx, DWORD PTR [ebx+ebx*2]
	jmp	$LN67@GetSpecial@2
$LN29@GetSpecial@2:

; 1541 : 	else if(eFocus == CITY_AI_FOCUS_TYPE_PRODUCTION)

	cmp	ecx, 1
	jne	SHORT $LN27@GetSpecial@2

; 1542 : 		iProductionYieldValue *= 3;

	mov	eax, DWORD PTR _iProductionYieldValue$[esp+40]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _iProductionYieldValue$[esp+40], edx
	jmp	SHORT $LN67@GetSpecial@2
$LN27@GetSpecial@2:

; 1543 : 	else if(eFocus == CITY_AI_FOCUS_TYPE_GOLD)

	cmp	ecx, 2
	jne	SHORT $LN25@GetSpecial@2

; 1544 : 		iGoldYieldValue *= 3;

	mov	eax, DWORD PTR _iGoldYieldValue$[esp+40]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _iGoldYieldValue$[esp+40], eax
	jmp	SHORT $LN67@GetSpecial@2
$LN25@GetSpecial@2:

; 1545 : 	else if(eFocus == CITY_AI_FOCUS_TYPE_SCIENCE)

	cmp	ecx, 4
	jne	SHORT $LN23@GetSpecial@2

; 1546 : 		iScienceYieldValue *= 3;

	mov	eax, DWORD PTR _iScienceYieldValue$[esp+40]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _iScienceYieldValue$[esp+40], edx
	jmp	SHORT $LN67@GetSpecial@2
$LN23@GetSpecial@2:

; 1547 : 	else if(eFocus == CITY_AI_FOCUS_TYPE_CULTURE)

	cmp	ecx, 5
	jne	SHORT $LN21@GetSpecial@2

; 1548 : 		iCultureYieldValue *= 3;

	mov	eax, DWORD PTR _iCultureYieldValue$[esp+40]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _iCultureYieldValue$[esp+40], eax
	jmp	SHORT $LN67@GetSpecial@2
$LN21@GetSpecial@2:

; 1549 : 	else if(eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH)

	cmp	ecx, 7
	jne	SHORT $LN19@GetSpecial@2

; 1550 : 	{
; 1551 : 		iFoodYieldValue *= 2;
; 1552 : 		iGoldYieldValue *= 2;

	mov	edx, DWORD PTR _iGoldYieldValue$[esp+40]
	lea	eax, DWORD PTR [edx+edx]
	add	ebx, ebx
	mov	DWORD PTR _iGoldYieldValue$[esp+40], eax
	jmp	SHORT $LN67@GetSpecial@2
$LN19@GetSpecial@2:

; 1553 : 	}
; 1554 : 	else if(eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH)

	cmp	ecx, 6
	jne	SHORT $LN17@GetSpecial@2

; 1555 : 	{
; 1556 : 		iFoodYieldValue *= 2;
; 1557 : 		iProductionYieldValue *= 2;

	mov	edx, DWORD PTR _iProductionYieldValue$[esp+40]
	lea	eax, DWORD PTR [edx+edx]
	add	ebx, ebx
	mov	DWORD PTR _iProductionYieldValue$[esp+40], eax
	jmp	SHORT $LN67@GetSpecial@2
$LN17@GetSpecial@2:

; 1558 : 	}
; 1559 : 	else if(eFocus == CITY_AI_FOCUS_TYPE_FAITH)

	cmp	ecx, 8
	jne	SHORT $LN15@GetSpecial@2

; 1560 : 	{
; 1561 : 		iFaithYieldValue *= 3;

	lea	edi, DWORD PTR [edi+edi*2]
	jmp	SHORT $LN67@GetSpecial@2
$LN15@GetSpecial@2:

; 1562 : 	}
; 1563 : 	else if(eFocus == CITY_AI_FOCUS_TYPE_GREAT_PEOPLE)

	cmp	ecx, 3
	jne	SHORT $LN67@GetSpecial@2

; 1564 : 	{
; 1565 : 		iGPPYieldValue *= 3;

	mov	eax, DWORD PTR _iGPPYieldValue$[esp+40]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _iGPPYieldValue$[esp+40], edx
$LN67@GetSpecial@2:

; 1566 : 	}
; 1567 : 
; 1568 : #ifdef AUI_CITIZENS_GET_VALUE_ALTER_FOOD_VALUE_IF_FOOD_PRODUCTION
; 1569 : #ifdef AUI_CITIZENS_FOOD_PRODUCTION_TRIAL_RUN_THEN_SELF_CONSISTENCY
; 1570 : 	if (!getIgnoreFoodProduction() && m_pCity->isFoodProduction())
; 1571 : #else
; 1572 : 	if (m_pCity->isFoodProduction())
; 1573 : #endif
; 1574 : 	{
; 1575 : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 1576 : #ifdef AUI_CITIZENS_CONSIDER_HAPPINESS_VALUE_ON_OTHER_YIELDS
; 1577 : 		iFoodYieldValue = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodWithPlotTimes100, -iExtraUnhappinessT100 / 100) - m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodTimes100, -iExtraUnhappinessT100 / 100);
; 1578 : 		int iDummy = m_pCity->GetFoodProduction(iExcessFoodTimes100 / 100);
; 1579 : 		int iCurrProdFromFood = m_pCity->foodDifference(true, &iDummy, -iExtraUnhappinessT100 / 100);
; 1580 : 		iDummy = m_pCity->GetFoodProduction(iExcessFoodWithPlotTimes100 / 100);
; 1581 : 		int iProdFromFoodWithTile = m_pCity->foodDifference(true, &iDummy, -iExtraUnhappinessT100 / 100);
; 1582 : #else
; 1583 : 		iFoodYieldValue = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodWithPlotTimes100) - m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodTimes100);
; 1584 : 		int iDummy = m_pCity->GetFoodProduction(iExcessFoodTimes100 / 100);
; 1585 : 		int iCurrProdFromFood = m_pCity->foodDifference(true, &iDummy);
; 1586 : 		iDummy = m_pCity->GetFoodProduction(iExcessFoodWithPlotTimes100 / 100);
; 1587 : 		int iProdFromFoodWithTile = m_pCity->foodDifference(true, &iDummy);
; 1588 : #endif
; 1589 : #ifndef AUI_CITIZENS_GET_VALUE_CONSIDER_YIELD_RATE_MODIFIERS
; 1590 : 		iFoodYieldValue /= 100;
; 1591 : #endif
; 1592 : #else
; 1593 : 		iFoodYieldValue = iExcessFoodWithPlotTimes100 - iExcessFoodTimes100;
; 1594 : 		int iCurrProdFromFood = m_pCity->GetFoodProduction(iExcessFoodTimes100 / 100);
; 1595 : 		int iProdFromFoodWithTile = m_pCity->GetFoodProduction(iExcessFoodWithPlotTimes100 / 100);
; 1596 : #endif
; 1597 : 		iProductionYieldValue += (iProdFromFoodWithTile - iCurrProdFromFood) * GC.getAI_CITIZEN_VALUE_PRODUCTION() * (eFocus == CITY_AI_FOCUS_TYPE_PRODUCTION ? 3 : 1);
; 1598 : 	}
; 1599 : 	else
; 1600 : #endif
; 1601 : 	// Food can be worth less if we don't want to grow
; 1602 : 	if(iExcessFoodTimes100 >= 0 && bAvoidGrowth)

	mov	eax, DWORD PTR _iExcessFoodTimes100$[esp+40]
	test	eax, eax
	jl	SHORT $LN70@GetSpecial@2
	cmp	BYTE PTR _bAvoidGrowth$[esp+36], 0
	je	SHORT $LN70@GetSpecial@2

; 1603 : 	{
; 1604 : #ifdef AUI_CITIZENS_AVOID_GROWTH_STILL_VALUES_EXCESS_FOOD
; 1605 : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 1606 : #ifdef AUI_CITIZENS_CONSIDER_HAPPINESS_VALUE_ON_OTHER_YIELDS
; 1607 : 		iExcessFoodTimes100 = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodTimes100, -iExtraUnhappinessT100 / 100);
; 1608 : 		iExcessFoodWithPlotTimes100 = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodWithPlotTimes100, -iExtraUnhappinessT100 / 100);
; 1609 : #else
; 1610 : 		iExcessFoodTimes100 = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodTimes100);
; 1611 : 		iExcessFoodWithPlotTimes100 = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodWithPlotTimes100);
; 1612 : #endif
; 1613 : #endif
; 1614 : 		iFoodYieldValue = iExcessFoodWithPlotTimes100 - iExcessFoodTimes100;
; 1615 : #ifndef AUI_CITIZENS_GET_VALUE_CONSIDER_YIELD_RATE_MODIFIERS
; 1616 : 		iFoodYieldValue /= 100;
; 1617 : #endif
; 1618 : #else
; 1619 : 		// If we at least have enough Food to feed everyone, zero out the value of additional food
; 1620 : 		iFoodYieldValue = 0;

	xor	ebx, ebx

; 1621 : #endif
; 1622 : 	}
; 1623 : 	// We want to grow here
; 1624 : 	else

	jmp	SHORT $LN69@GetSpecial@2
$LN70@GetSpecial@2:

; 1625 : 	{
; 1626 : #ifdef AUI_CITIZENS_GET_VALUE_SPLIT_EXCESS_FOOD_MUTLIPLIER
; 1627 : 		iFoodYieldValue *= 8;
; 1628 : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 1629 : #ifdef AUI_CITIZENS_CONSIDER_HAPPINESS_VALUE_ON_OTHER_YIELDS
; 1630 : 		iExcessFoodTimes100 = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodTimes100, -iExtraUnhappinessT100 / 100);
; 1631 : 		iExcessFoodWithPlotTimes100 = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodWithPlotTimes100, -iExtraUnhappinessT100 / 100);
; 1632 : #else
; 1633 : 		iExcessFoodTimes100 = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodTimes100);
; 1634 : 		iExcessFoodWithPlotTimes100 = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodWithPlotTimes100);
; 1635 : #endif
; 1636 : #endif
; 1637 : #ifdef AUI_CITIZENS_AVOID_GROWTH_STILL_VALUES_EXCESS_FOOD
; 1638 : 		int iExcessFoodYieldValue = 1;
; 1639 : #else
; 1640 : 		int iExcessFoodYieldValue = 0;
; 1641 : #endif
; 1642 : 		int iTargetFoodT100 = 0;
; 1643 : 		if (!bAvoidGrowth)
; 1644 : 		{
; 1645 : 			iExcessFoodYieldValue = iFoodYieldValue / 16;
; 1646 : #ifdef AUI_CITIZENS_LOW_POPULATION_CITIES_USE_2MIN_NOT_4X_FOOD
; 1647 : 			if (eFocus == NO_CITY_AI_FOCUS_TYPE || eFocus == CITY_AI_FOCUS_TYPE_FOOD || eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH
; 1648 : 				|| eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH || m_pCity->getPopulation() < 2)
; 1649 : #else
; 1650 : 			if (eFocus == NO_CITY_AI_FOCUS_TYPE || eFocus == CITY_AI_FOCUS_TYPE_FOOD || eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH || eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH)
; 1651 : #endif
; 1652 : 			{
; 1653 : 				iTargetFoodT100 = 100 * GC.getFOOD_CONSUMPTION_PER_POPULATION();
; 1654 : 			}
; 1655 : #ifdef AUI_CITIZENS_PUPPET_STILL_WANTS_GROWTH
; 1656 : 			else if (m_pCity->IsPuppet())
; 1657 : 				iTargetFoodT100 = 50 * GC.getFOOD_CONSUMPTION_PER_POPULATION();
; 1658 : #endif
; 1659 : 		}
; 1660 : 
; 1661 : 		int iNonExcessFoodPlotYieldT100 = iExcessFoodWithPlotTimes100 - iExcessFoodTimes100;
; 1662 : 		int iExcessFoodPlotYieldT100 = iNonExcessFoodPlotYieldT100;
; 1663 : 		if (iExcessFoodWithPlotTimes100 <= iTargetFoodT100)
; 1664 : 		{
; 1665 : 			iExcessFoodPlotYieldT100 = 0;
; 1666 : 		}
; 1667 : 		else if (iExcessFoodTimes100 >= iTargetFoodT100)
; 1668 : 		{
; 1669 : 			iNonExcessFoodPlotYieldT100 = 0;
; 1670 : 		}
; 1671 : 		else
; 1672 : 		{
; 1673 : 			iNonExcessFoodPlotYieldT100 = iTargetFoodT100 - iExcessFoodTimes100;
; 1674 : 			iExcessFoodPlotYieldT100 = iExcessFoodWithPlotTimes100 - iTargetFoodT100;
; 1675 : 		}
; 1676 : 
; 1677 : 		iFoodYieldValue *= iNonExcessFoodPlotYieldT100;
; 1678 : 		iFoodYieldValue += (iExcessFoodPlotYieldT100 * iExcessFoodYieldValue);
; 1679 : #ifndef AUI_CITIZENS_GET_VALUE_CONSIDER_YIELD_RATE_MODIFIERS
; 1680 : 		iFoodYieldValue /= 100;
; 1681 : #endif
; 1682 : #else
; 1683 : 		// If we have a non-default and non-food focus, only worry about getting to 0 food
; 1684 : #ifdef AUI_CITIZENS_LOW_POPULATION_CITIES_USE_2MIN_NOT_4X_FOOD
; 1685 : 		if (eFocus != NO_CITY_AI_FOCUS_TYPE && eFocus != CITY_AI_FOCUS_TYPE_FOOD && eFocus != CITY_AI_FOCUS_TYPE_PROD_GROWTH && eFocus != CITY_AI_FOCUS_TYPE_GOLD_GROWTH && m_pCity->getPopulation() >= 5)
; 1686 : #else
; 1687 : 		if(eFocus != NO_CITY_AI_FOCUS_TYPE && eFocus != CITY_AI_FOCUS_TYPE_FOOD && eFocus != CITY_AI_FOCUS_TYPE_PROD_GROWTH && eFocus != CITY_AI_FOCUS_TYPE_GOLD_GROWTH)

	cmp	ecx, -1
	je	SHORT $LN10@GetSpecial@2
	test	ecx, ecx
	je	SHORT $LN10@GetSpecial@2
	cmp	ecx, 6
	je	SHORT $LN10@GetSpecial@2
	cmp	ecx, 7
	je	SHORT $LN10@GetSpecial@2

; 1688 : #endif
; 1689 : 		{
; 1690 : 			int iFoodT100NeededFor0 = -iExcessFoodTimes100;

	neg	eax

; 1691 : 
; 1692 : 			if(iFoodT100NeededFor0 > 0)

	test	eax, eax
	jle	SHORT $LN9@GetSpecial@2

; 1693 : 			{
; 1694 : 				iFoodYieldValue *= 8;

	add	ebx, ebx
	add	ebx, ebx
	add	ebx, ebx

; 1695 : 			}
; 1696 : 			else

	jmp	SHORT $LN69@GetSpecial@2
$LN10@GetSpecial@2:

; 1697 : 			{
; 1698 : 				iFoodYieldValue /= 2;
; 1699 : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 1700 : 				int iExtraFoodValueT100 = (m_pCity->foodDifferenceTimes100(true, NULL, true, iExcessFoodWithPlotTimes100 - iExcessFoodTimes100) -
; 1701 : 					(iExcessFoodWithPlotTimes100 - iExcessFoodTimes100)) * /*12*/ GC.getAI_CITIZEN_VALUE_FOOD();
; 1702 : 				if (eFocus == CITY_AI_FOCUS_TYPE_FOOD)
; 1703 : 					iExtraFoodValueT100 *= 3;
; 1704 : 				else if (eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH || eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH)
; 1705 : 					iExtraFoodValueT100 *= 2;
; 1706 : 				iFoodYieldValue += iExtraFoodValueT100 / 200;
; 1707 : #endif
; 1708 : 			}
; 1709 : 		}
; 1710 : 		// If our surplus is not at least 2, really emphasize food plots
; 1711 : 		else if(!bAvoidGrowth)

	cmp	BYTE PTR _bAvoidGrowth$[esp+36], 0
	jne	SHORT $LN69@GetSpecial@2

; 1712 : 		{
; 1713 : #ifdef AUI_CITIZENS_FIX_SPECIALIST_VALUE_HALF_FOOD_CONSUMPTION
; 1714 : 			int iFoodT100NeededFor2 = 100 * GC.getFOOD_CONSUMPTION_PER_POPULATION() - iExcessFoodTimes100;
; 1715 : #else
; 1716 : 			int iFoodT100NeededFor2 = 200 - iExcessFoodTimes100;

	mov	eax, 200				; 000000c8H
	sub	eax, DWORD PTR _iExcessFoodTimes100$[esp+40]

; 1717 : #endif
; 1718 : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 1719 : 			int iExtraFoodValueT100 = (m_pCity->foodDifferenceTimes100(true, NULL, true, iExcessFoodWithPlotTimes100 - iExcessFoodTimes100) -
; 1720 : 				(iExcessFoodWithPlotTimes100 - iExcessFoodTimes100)) * /*12*/ GC.getAI_CITIZEN_VALUE_FOOD();
; 1721 : 			if (eFocus == CITY_AI_FOCUS_TYPE_FOOD)
; 1722 : 				iExtraFoodValueT100 *= 3;
; 1723 : 			else if (eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH || eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH)
; 1724 : 				iExtraFoodValueT100 *= 2;
; 1725 : #endif
; 1726 : 
; 1727 : 			if(iFoodT100NeededFor2 > 0)

	test	eax, eax
	jle	SHORT $LN5@GetSpecial@2

; 1728 : 			{
; 1729 : 				iFoodYieldValue *= 8;

	add	ebx, ebx
	add	ebx, ebx
	add	ebx, ebx
	jmp	SHORT $LN69@GetSpecial@2
$LN5@GetSpecial@2:

; 1730 : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 1731 : 				iExtraFoodValueT100 = 0;
; 1732 : 				iExtraFoodValueT100 += (m_pCity->foodDifferenceTimes100(true, NULL, true, MIN(iExcessFoodWithPlotTimes100, 100 * GC.getFOOD_CONSUMPTION_PER_POPULATION())) -
; 1733 : 					MIN(iExcessFoodWithPlotTimes100, 100 * GC.getFOOD_CONSUMPTION_PER_POPULATION())) * 8 * /*12*/ GC.getAI_CITIZEN_VALUE_FOOD();
; 1734 : 				if (eFocus == CITY_AI_FOCUS_TYPE_FOOD)
; 1735 : 					iExtraFoodValueT100 *= 3;
; 1736 : 				else if (eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH || eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH)
; 1737 : 					iExtraFoodValueT100 *= 2;
; 1738 : 				iFoodYieldValue += iExtraFoodValueT100 / 100;
; 1739 : #endif
; 1740 : 			}
; 1741 : 			else if (eFocus != CITY_AI_FOCUS_TYPE_FOOD)

	test	ecx, ecx
	je	SHORT $LN69@GetSpecial@2
$LN9@GetSpecial@2:

; 1742 : 			{
; 1743 : 				iFoodYieldValue /= 2;

	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ebx, eax
$LN69@GetSpecial@2:

; 1744 : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 1745 : 				iFoodYieldValue += iExtraFoodValueT100 / 200;
; 1746 : 			}
; 1747 : 			else
; 1748 : 			{
; 1749 : 				iFoodYieldValue += iExtraFoodValueT100 / 100;
; 1750 : #endif
; 1751 : 			}
; 1752 : 		}
; 1753 : #ifdef AUI_CITIZENS_FIX_GET_VALUE_FOOD_YIELD_VALUE_WHEN_STARVATION_WITH_AVOID_GROWTH
; 1754 : 		// Food focus and negative food, but with avoid growth enabled for some reason
; 1755 : 		else
; 1756 : 		{
; 1757 : 			iFoodYieldValue *= 8;
; 1758 : 		}
; 1759 : #endif
; 1760 : #endif
; 1761 : 	}
; 1762 : 
; 1763 : #ifndef AUI_CITIZENS_LOW_POPULATION_CITIES_USE_2MIN_NOT_4X_FOOD
; 1764 : 	if((eFocus == NO_CITY_AI_FOCUS_TYPE || eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH || eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH) && !bAvoidGrowth && m_pCity->getPopulation() < 5)

	cmp	ecx, -1
	je	SHORT $LN1@GetSpecial@2
	cmp	ecx, 6
	je	SHORT $LN1@GetSpecial@2
	cmp	ecx, 7
	jne	SHORT $LN68@GetSpecial@2
$LN1@GetSpecial@2:
	cmp	BYTE PTR _bAvoidGrowth$[esp+36], 0
	jne	SHORT $LN68@GetSpecial@2
	mov	ecx, DWORD PTR [ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 5
	jge	SHORT $LN68@GetSpecial@2

; 1765 : 	{
; 1766 : 		iFoodYieldValue *= 4;

	add	ebx, ebx
	add	ebx, ebx
$LN68@GetSpecial@2:
	mov	ecx, DWORD PTR _iGPPYieldValue$[esp+40]
	lea	eax, DWORD PTR [esi+ecx]

; 1767 : 	}
; 1768 : #endif
; 1769 : 
; 1770 : 	iValue += iFoodYieldValue;
; 1771 : 	iValue += iProductionYieldValue;
; 1772 : 	iValue += iGoldYieldValue;
; 1773 : 	iValue += iScienceYieldValue;
; 1774 : 	iValue += iCultureYieldValue;
; 1775 : 	iValue += iFaithYieldValue;
; 1776 : #ifndef AUI_CITIZENS_UNHARDCODE_SPECIALIST_VALUE_GREAT_PERSON_POINTS
; 1777 : 	iValue += iGPPYieldValue;
; 1778 : #endif
; 1779 : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_YIELD_RATE_MODIFIERS
; 1780 : 	iValue /= 100;
; 1781 : #endif
; 1782 : #ifdef AUI_CITIZENS_UNHARDCODE_SPECIALIST_VALUE_GREAT_PERSON_POINTS
; 1783 : 	iValue += iGPPYieldValue;
; 1784 : #endif
; 1785 : 	iValue += iHappinessYieldValue;
; 1786 : 
; 1787 : 	return iValue;

	add	eax, edi
	add	eax, DWORD PTR _iCultureYieldValue$[esp+40]
	pop	esi
	add	eax, DWORD PTR _iScienceYieldValue$[esp+36]
	add	eax, DWORD PTR _iGoldYieldValue$[esp+36]
	add	eax, DWORD PTR _iProductionYieldValue$[esp+36]
	add	eax, ebx
	pop	ebx
	pop	edi
	pop	ebp

; 1788 : }

	add	esp, 24					; 00000018H
	ret	4
?GetSpecialistValue@CvCityCitizens@@QAEHW4SpecialistTypes@@@Z ENDP ; CvCityCitizens::GetSpecialistValue
_TEXT	ENDS
PUBLIC	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z	; CvCityCitizens::IsCanWork
EXTRN	?hasYield@CvPlot@@QBE_NXZ:PROC			; CvPlot::hasYield
EXTRN	?isWaterWork@CvTeam@@QBE_NXZ:PROC		; CvTeam::isWaterWork
EXTRN	?plotCheck@CvPlot@@QAEPAVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z:PROC ; CvPlot::plotCheck
EXTRN	?PUF_canSiege@@YA_NPBVCvUnit@@HH@Z:PROC		; PUF_canSiege
EXTRN	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ:PROC	; CvPlot::getWorkingCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z PROC	; CvCityCitizens::IsCanWork, COMDAT
; _this$ = ecx

; 2663 : {

	push	ebx
	push	esi
	push	edi

; 2664 : 	if(pPlot->getWorkingCity() != m_pCity)

	mov	edi, DWORD PTR _pPlot$[esp+8]
	mov	ebx, ecx
	mov	esi, DWORD PTR [ebx]
	mov	ecx, edi
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	cmp	eax, esi
	je	SHORT $LN6@IsCanWork
$LN21@IsCanWork:
	pop	edi
	pop	esi

; 2665 : 	{
; 2666 : 		return false;

	xor	al, al
	pop	ebx

; 2691 : 	{
; 2692 : 		return false;
; 2693 : 	}
; 2694 : 
; 2695 : 	return true;
; 2696 : }

	ret	4
$LN6@IsCanWork:

; 2667 : 	}
; 2668 : 
; 2669 : 	CvAssertMsg(GetCityIndexFromPlot(pPlot) != -1, "GetCityIndexFromPlot(pPlot) is expected to be assigned (not -1)");
; 2670 : 
; 2671 : 	if(pPlot->plotCheck(PUF_canSiege, GetOwner()) != NULL)

	mov	esi, DWORD PTR [esi+84]
	push	-1
	push	-1
	push	0
	push	-1
	push	-1
	push	-1
	push	esi
	push	OFFSET ?PUF_canSiege@@YA_NPBVCvUnit@@HH@Z ; PUF_canSiege
	mov	ecx, edi
	call	?plotCheck@CvPlot@@QAEPAVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCheck
	test	eax, eax

; 2672 : 	{
; 2673 : 		return false;

	jne	SHORT $LN21@IsCanWork

; 2674 : 	}
; 2675 : 
; 2676 : 	if(pPlot->isWater())

	cmp	BYTE PTR [edi+5], 3
	jne	SHORT $LN3@IsCanWork

; 2677 : 	{
; 2678 : 		if(!(GET_TEAM(GetTeam()).isWaterWork()))

	mov	ecx, DWORD PTR [ebx]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?isWaterWork@CvTeam@@QBE_NXZ		; CvTeam::isWaterWork
	test	al, al

; 2679 : 		{
; 2680 : 			return false;

	je	SHORT $LN21@IsCanWork
$LN3@IsCanWork:

; 2681 : 		}
; 2682 : 
; 2683 : 	}
; 2684 : 
; 2685 : 	if(!pPlot->hasYield())

	mov	ecx, edi
	call	?hasYield@CvPlot@@QBE_NXZ		; CvPlot::hasYield
	test	al, al

; 2686 : 	{
; 2687 : 		return false;

	je	SHORT $LN21@IsCanWork

; 2688 : 	}
; 2689 : 
; 2690 : 	if(IsPlotBlockaded(pPlot))

	push	edi
	mov	ecx, ebx
	call	?IsPlotBlockaded@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsPlotBlockaded
	pop	edi
	test	al, al
	pop	esi
	sete	al
	pop	ebx

; 2691 : 	{
; 2692 : 		return false;
; 2693 : 	}
; 2694 : 
; 2695 : 	return true;
; 2696 : }

	ret	4
?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ENDP	; CvCityCitizens::IsCanWork
_TEXT	ENDS
PUBLIC	?IsAnyPlotBlockaded@CvCityCitizens@@QBE_NXZ	; CvCityCitizens::IsAnyPlotBlockaded
; Function compile flags: /Ogtpy
;	COMDAT ?IsAnyPlotBlockaded@CvCityCitizens@@QBE_NXZ
_TEXT	SEGMENT
?IsAnyPlotBlockaded@CvCityCitizens@@QBE_NXZ PROC	; CvCityCitizens::IsAnyPlotBlockaded, COMDAT
; _this$ = ecx

; 2785 : {

	push	esi
	push	edi
	mov	edi, ecx

; 2786 : 	CvPlot* pLoopPlot;
; 2787 : 
; 2788 : 	// Look at all workable Plots
; 2789 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	xor	esi, esi
$LL6@IsAnyPlotB:

; 2790 : 	{
; 2791 : 		if(iPlotLoop != CITY_HOME_PLOT)

	test	esi, esi
	je	SHORT $LN5@IsAnyPlotB

; 2792 : 		{
; 2793 : 			pLoopPlot = GetCityPlotFromIndex(iPlotLoop);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	esi
	push	ecx
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH

; 2794 : 
; 2795 : 			if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN5@IsAnyPlotB

; 2796 : 			{
; 2797 : 				if(IsPlotBlockaded(pLoopPlot))

	push	eax
	mov	ecx, edi
	call	?IsPlotBlockaded@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsPlotBlockaded
	test	al, al
	jne	SHORT $LN20@IsAnyPlotB
$LN5@IsAnyPlotB:

; 2786 : 	CvPlot* pLoopPlot;
; 2787 : 
; 2788 : 	// Look at all workable Plots
; 2789 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	inc	esi
	cmp	esi, 37					; 00000025H
	jl	SHORT $LL6@IsAnyPlotB
	pop	edi

; 2800 : 				}
; 2801 : 			}
; 2802 : 		}
; 2803 : 	}
; 2804 : 
; 2805 : 	return false;

	xor	al, al
	pop	esi

; 2806 : }

	ret	0
$LN20@IsAnyPlotB:
	pop	edi

; 2798 : 				{
; 2799 : 					return true;

	mov	al, 1
	pop	esi

; 2806 : }

	ret	0
?IsAnyPlotBlockaded@CvCityCitizens@@QBE_NXZ ENDP	; CvCityCitizens::IsAnyPlotBlockaded
_TEXT	ENDS
PUBLIC	?DoSpecialists@CvCityCitizens@@QAEXXZ		; CvCityCitizens::DoSpecialists
EXTRN	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationUnits
EXTRN	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z:PROC ; CvGlobals::getCivilizationInfo
EXTRN	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvCity::getCivilizationType
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?getGreatEngineerRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatEngineerRateModifier
EXTRN	?getGreatMerchantRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatMerchantRateModifier
EXTRN	?getGreatMusicianRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatMusicianRateModifier
EXTRN	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::calculateTotalYield
EXTRN	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z:PROC ; CvPlayerPolicies::GetNumericModifier
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?getGreatArtistRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatArtistRateModifier
EXTRN	?getGreatWriterRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatWriterRateModifier
EXTRN	?isGoldenAge@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isGoldenAge
EXTRN	?getGreatScientistRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatScientistRateModifier
EXTRN	?getGreatPeopleRateModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getGreatPeopleRateModifier
EXTRN	?getGreatPeopleRateModifier@CvCity@@QBEHXZ:PROC	; CvCity::getGreatPeopleRateModifier
EXTRN	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ:PROC ; CvSpecialistInfo::getGreatPeopleUnitClass
; Function compile flags: /Ogtpy
;	COMDAT ?DoSpecialists@CvCityCitizens@@QAEXXZ
_TEXT	SEGMENT
tv701 = -12						; size = 4
_iSpecialistLoop$226108 = -12				; size = 4
_iGPPChange$ = -8					; size = 4
_iGPThreshold$226116 = -4				; size = 4
?DoSpecialists@CvCityCitizens@@QAEXXZ PROC		; CvCityCitizens::DoSpecialists, COMDAT
; _this$ = ecx

; 3019 : {

	sub	esp, 12					; 0000000cH
	push	ebp
	push	esi
	mov	esi, ecx

; 3020 : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3021 : 	int iGPPChange;
; 3022 : 	int iCount;
; 3023 : 	int iMod;
; 3024 : #endif
; 3025 : #ifdef AUI_WARNING_FIXES
; 3026 : 	for (uint iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
; 3027 : #else
; 3028 : 	for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)

	xor	ebp, ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iSpecialistLoop$226108[esp+20], ebp
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	test	eax, eax
	jle	$LN22@DoSpeciali
	push	ebx
	push	edi
$LL215@DoSpeciali:

; 3029 : #endif
; 3030 : 	{
; 3031 : 		const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
; 3032 : 		CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo
	mov	ebx, eax

; 3033 : 		if(pkSpecialistInfo)

	test	ebx, ebx
	je	$LN23@DoSpeciali

; 3034 : 		{
; 3035 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3036 : 			UnitClassTypes eGPUnitClassType = (UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass();
; 3037 : 			if (eGPUnitClassType != NO_UNITCLASS)
; 3038 : 			{
; 3039 : 				ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, getCachedGPChangeT100ForThisTurn(eSpecialist));
; 3040 : 
; 3041 : 				int iGPThreshold = GetSpecialistUpgradeThreshold(eGPUnitClassType);
; 3042 : #else
; 3043 : 			int iGPThreshold = GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());

	mov	ecx, ebx
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	push	eax
	mov	ecx, esi
	call	?GetSpecialistUpgradeThreshold@CvCityCitizens@@QAEHW4UnitClassTypes@@@Z ; CvCityCitizens::GetSpecialistUpgradeThreshold

; 3044 : 
; 3045 : 			// Does this Specialist spawn a GP?
; 3046 : 			if(pkSpecialistInfo->getGreatPeopleUnitClass() != NO_UNITCLASS)

	mov	ecx, ebx
	mov	DWORD PTR _iGPThreshold$226116[esp+28], eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, -1
	je	$LN23@DoSpeciali

; 3047 : 			{
; 3048 : 				iCount = GetSpecialistCount(eSpecialist);

	mov	eax, DWORD PTR [esi+108]
	mov	edi, DWORD PTR [eax+ebp*4]

; 3049 : 
; 3050 : 				// GPP from Specialists
; 3051 : 				iGPPChange = pkSpecialistInfo->getGreatPeopleRateChange() * iCount * 100;

	mov	ecx, ebx
	call	?getGreatPeopleRateChange@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleRateChange
	imul	eax, edi

; 3052 : 
; 3053 : 				// GPP from Buildings
; 3054 : 				iGPPChange += GetBuildingGreatPeopleRateChanges(eSpecialist) * 100;

	mov	ecx, DWORD PTR [esi+124]
	imul	eax, 100				; 00000064H
	mov	edx, DWORD PTR [ecx+ebp*4]
	imul	edx, 100				; 00000064H
	add	eax, edx
	mov	DWORD PTR _iGPPChange$[esp+28], eax

; 3055 : 
; 3056 : 				if(iGPPChange > 0)

	test	eax, eax
	jle	$LN211@DoSpeciali

; 3057 : 				{
; 3058 : 					iMod = 0;
; 3059 : 
; 3060 : 					// City mod
; 3061 : 					iMod += GetCity()->getGreatPeopleRateModifier();

	mov	ecx, DWORD PTR [esi]
	call	?getGreatPeopleRateModifier@CvCity@@QBEHXZ ; CvCity::getGreatPeopleRateModifier
	mov	edi, eax

; 3062 : 
; 3063 : 					// Player mod
; 3064 : 					iMod += GetPlayer()->getGreatPeopleRateModifier();

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatPeopleRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatPeopleRateModifier

; 3065 : 
; 3066 : 					// Player and Golden Age mods to this specific class
; 3067 : 					if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))

	push	0
	push	OFFSET $SG226122
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	add	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, ebx
	mov	ebp, eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, ebp
	jne	SHORT $LN18@DoSpeciali

; 3068 : 					{
; 3069 : 						iMod += GetPlayer()->getGreatScientistRateModifier();

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatScientistRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatScientistRateModifier
	jmp	$LN216@DoSpeciali
$LN18@DoSpeciali:

; 3070 : 					}
; 3071 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))

	push	0
	push	OFFSET $SG226126
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, ebx
	mov	ebp, eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, ebp
	jne	SHORT $LN16@DoSpeciali

; 3072 : 					{ 
; 3073 : 						if (GetPlayer()->isGoldenAge())

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	test	al, al
	je	SHORT $LN15@DoSpeciali

; 3074 : 						{
; 3075 : 							iMod += GetPlayer()->GetPlayerTraits()->GetGoldenAgeGreatWriterRateModifier();

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	edi, DWORD PTR [eax+196]
$LN15@DoSpeciali:

; 3076 : 						}
; 3077 : 						iMod += GetPlayer()->getGreatWriterRateModifier();

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatWriterRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatWriterRateModifier
	jmp	$LN216@DoSpeciali
$LN16@DoSpeciali:

; 3078 : 					}
; 3079 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))

	push	0
	push	OFFSET $SG226131
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, ebx
	mov	ebp, eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, ebp
	jne	SHORT $LN13@DoSpeciali

; 3080 : 					{
; 3081 : 						if (GetPlayer()->isGoldenAge())

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	test	al, al
	je	SHORT $LN12@DoSpeciali

; 3082 : 						{
; 3083 : 							iMod += GetPlayer()->GetPlayerTraits()->GetGoldenAgeGreatArtistRateModifier();

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	edi, DWORD PTR [eax+188]
$LN12@DoSpeciali:

; 3084 : 						}
; 3085 : 						iMod += GetPlayer()->getGreatArtistRateModifier();

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatArtistRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatArtistRateModifier
	jmp	$LN216@DoSpeciali
$LN13@DoSpeciali:

; 3086 : 					}
; 3087 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))

	push	0
	push	OFFSET $SG226136
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, ebx
	mov	ebp, eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, ebp
	jne	$LN10@DoSpeciali

; 3088 : 					{
; 3089 : 						if (GetPlayer()->isGoldenAge())

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	test	al, al
	je	SHORT $LN9@DoSpeciali

; 3090 : 						{
; 3091 : 							iMod += GetPlayer()->GetPlayerTraits()->GetGoldenAgeGreatMusicianRateModifier();

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	edi, DWORD PTR [eax+192]
$LN9@DoSpeciali:

; 3092 : 						}
; 3093 : #ifdef NQ_PRODUCTION_TO_GREAT_MUSICIANS_MODIFIER_FROM_POLICIES
; 3094 : 						int iProductionToGreatMusiciansModifier = GetPlayer()->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_PRODUCTION_TO_GREAT_MUSICIANS_MODIFIER);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	47					; 0000002fH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	ebp, eax

; 3095 : 						if (iProductionToGreatMusiciansModifier > 0)

	test	ebp, ebp
	jle	SHORT $LN209@DoSpeciali

; 3096 : 						{
; 3097 : 							iMod += GetPlayer()->calculateTotalYield(YIELD_PRODUCTION) * iProductionToGreatMusiciansModifier / 100;

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	call	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::calculateTotalYield
	mov	ecx, eax
	imul	ecx, ebp
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	edi, eax
$LN209@DoSpeciali:

; 3098 : 						}
; 3099 : #endif
; 3100 : 						iMod += GetPlayer()->getGreatMusicianRateModifier();

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatMusicianRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatMusicianRateModifier
	jmp	SHORT $LN216@DoSpeciali
$LN10@DoSpeciali:

; 3101 : 					}
; 3102 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))

	push	0
	push	OFFSET $SG226143
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, ebx
	mov	ebp, eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, ebp
	jne	SHORT $LN6@DoSpeciali

; 3103 : 					{
; 3104 : 						iMod += GetPlayer()->getGreatMerchantRateModifier();

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatMerchantRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatMerchantRateModifier
	jmp	SHORT $LN216@DoSpeciali
$LN6@DoSpeciali:

; 3105 : 					}
; 3106 : 					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))

	push	0
	push	OFFSET $SG226147
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, ebx
	mov	ebp, eax
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
	cmp	eax, ebp
	jne	SHORT $LN210@DoSpeciali

; 3107 : 					{
; 3108 : 						iMod += GetPlayer()->getGreatEngineerRateModifier();

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getGreatEngineerRateModifier@CvPlayer@@QBEHXZ ; CvPlayer::getGreatEngineerRateModifier
$LN216@DoSpeciali:
	add	edi, eax
$LN210@DoSpeciali:

; 3020 : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3021 : 	int iGPPChange;
; 3022 : 	int iCount;
; 3023 : 	int iMod;
; 3024 : #endif
; 3025 : #ifdef AUI_WARNING_FIXES
; 3026 : 	for (uint iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
; 3027 : #else
; 3028 : 	for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)

	mov	ecx, DWORD PTR [esi+112]
	mov	ebp, DWORD PTR _iSpecialistLoop$226108[esp+28]
	lea	edx, DWORD PTR [ecx+ebp*4]

; 3109 : 					}
; 3110 : 
; 3111 : 					// Apply mod
; 3112 : 					iGPPChange *= (100 + iMod);

	lea	ecx, DWORD PTR [edi+100]
	imul	ecx, DWORD PTR _iGPPChange$[esp+28]
	mov	DWORD PTR tv701[esp+28], edx

; 3113 : 					iGPPChange /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 3114 : 
; 3115 : 					ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPPChange);

	mov	eax, DWORD PTR tv701[esp+28]
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx
$LN211@DoSpeciali:

; 3116 : 				}
; 3117 : #endif
; 3118 : 
; 3119 : 				// Enough to spawn a GP?
; 3120 : 				if(GetSpecialistGreatPersonProgress(eSpecialist) >= iGPThreshold)

	mov	edx, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR [edx+ebp*4]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, DWORD PTR _iGPThreshold$226116[esp+28]
	jl	SHORT $LN23@DoSpeciali

; 3121 : 				{
; 3122 : 					// No Minors
; 3123 : 					if(!GET_PLAYER(GetCity()->getOwner()).isMinorCiv())

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN23@DoSpeciali

; 3124 : 					{
; 3125 : 						// Reset progress on this Specialist
; 3126 : 						DoResetSpecialistGreatPersonProgressTimes100(eSpecialist);

	mov	edx, DWORD PTR [esi+112]

; 3127 : 
; 3128 : 						// Now... actually create the GP!
; 3129 : 						const UnitClassTypes eUnitClass = (UnitClassTypes) pkSpecialistInfo->getGreatPeopleUnitClass();

	mov	ecx, ebx
	mov	DWORD PTR [edx+ebp*4], 0
	call	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass

; 3130 : 						const CivilizationTypes eCivilization = GetCity()->getCivilizationType();

	mov	ecx, DWORD PTR [esi]
	mov	edi, eax
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType

; 3131 : 						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(eCivilization);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo

; 3132 : 						if(pCivilizationInfo != NULL)

	test	eax, eax
	je	SHORT $LN23@DoSpeciali

; 3133 : 						{
; 3134 : 							UnitTypes eUnit = (UnitTypes) pCivilizationInfo->getCivilizationUnits(eUnitClass);

	push	edi
	mov	ecx, eax
	call	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits

; 3135 : 
; 3136 : 							DoSpawnGreatPerson(eUnit, true, false);

	push	0
	push	1
	push	eax
	mov	ecx, esi
	call	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z ; CvCityCitizens::DoSpawnGreatPerson
$LN23@DoSpeciali:
	inc	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iSpecialistLoop$226108[esp+28], ebp
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	cmp	ebp, eax
	jl	$LL215@DoSpeciali
	pop	edi
	pop	ebx
$LN22@DoSpeciali:
	pop	esi
	pop	ebp

; 3137 : 						}
; 3138 : 					}
; 3139 : 				}
; 3140 : 			}
; 3141 : 		}
; 3142 : 	}
; 3143 : }

	add	esp, 12					; 0000000cH
	ret	0
?DoSpecialists@CvCityCitizens@@QAEXXZ ENDP		; CvCityCitizens::DoSpecialists
_TEXT	ENDS
PUBLIC	?DoFoundCity@CvCityCitizens@@QAEXXZ		; CvCityCitizens::DoFoundCity
; Function compile flags: /Ogtpy
;	COMDAT ?DoFoundCity@CvCityCitizens@@QAEXXZ
_TEXT	SEGMENT
_bWorkPlot$225409 = -4					; size = 1
?DoFoundCity@CvCityCitizens@@QAEXXZ PROC		; CvCityCitizens::DoFoundCity, COMDAT
; _this$ = ecx

; 269  : {

	push	ecx
	push	esi
	mov	esi, ecx

; 270  : 	// always work the home plot (center)
; 271  : 	CvPlot* pHomePlot = GetCityPlotFromIndex(CITY_HOME_PLOT);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	edi
	push	0
	push	ecx
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 272  : 	if(pHomePlot != NULL)

	test	edi, edi
	je	SHORT $LN1@DoFoundCit

; 273  : 	{
; 274  : 		bool bWorkPlot = IsCanWork(pHomePlot);

	push	edi
	mov	ecx, esi
	call	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsCanWork
	mov	BYTE PTR _bWorkPlot$225409[esp+12], al

; 275  : 		SetWorkingPlot(pHomePlot, bWorkPlot, /*bUseUnassignedPool*/ false);

	mov	eax, DWORD PTR _bWorkPlot$225409[esp+12]
	push	0
	push	eax
	push	edi
	mov	ecx, esi
	call	?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z ; CvCityCitizens::SetWorkingPlot
$LN1@DoFoundCit:
	pop	edi
	pop	esi

; 276  : 	}
; 277  : }

	pop	ecx
	ret	0
?DoFoundCity@CvCityCitizens@@QAEXXZ ENDP		; CvCityCitizens::DoFoundCity
_TEXT	ENDS
PUBLIC	?GetPlotValue@CvCityCitizens@@QAEHPAVCvPlot@@_N@Z ; CvCityCitizens::GetPlotValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotValue@CvCityCitizens@@QAEHPAVCvPlot@@_N@Z
_TEXT	SEGMENT
_iProductionYieldValue$ = -16				; size = 4
_iFaithYieldValue$ = -12				; size = 4
_iCultureYieldValue$ = -8				; size = 4
_iScienceYieldValue$ = -4				; size = 4
_iGoldYieldValue$ = 8					; size = 4
_pPlot$ = 8						; size = 4
_bUseAllowGrowthFlag$ = 12				; size = 1
?GetPlotValue@CvCityCitizens@@QAEHPAVCvPlot@@_N@Z PROC	; CvCityCitizens::GetPlotValue, COMDAT
; _this$ = ecx

; 450  : {

	sub	esp, 16					; 00000010H
	push	ebx

; 451  : 	int iValue = 0;
; 452  : 
; 453  : 	// Yield Values
; 454  : #ifdef AUI_CITIZENS_GET_VALUE_SPLIT_EXCESS_FOOD_MUTLIPLIER
; 455  : 	int iFoodYieldValue = /*12*/ GC.getAI_CITIZEN_VALUE_FOOD();
; 456  : #else
; 457  : 	int iFoodYieldValue = (/*12*/ GC.getAI_CITIZEN_VALUE_FOOD() * pPlot->getYield(YIELD_FOOD));

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2376
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pPlot$[esp+24]
	push	edi
	mov	ebp, ecx
	push	0
	mov	ecx, esi
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	mov	edi, eax
	imul	edi, ebx

; 458  : #endif
; 459  : 	int iProductionYieldValue = (/*8*/ GC.getAI_CITIZEN_VALUE_PRODUCTION() * pPlot->getYield(YIELD_PRODUCTION));

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2380
	push	1
	mov	ecx, esi
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	imul	eax, ebx

; 460  : #ifdef AUI_CITIZENS_GOLD_YIELD_COUNTS_AS_SCIENCE_WHEN_IN_DEFICIT
; 461  : 	int iGoldYieldValue = (pPlot->getYield(YIELD_GOLD));
; 462  : 	int iScienceYieldValue = (pPlot->getYield(YIELD_SCIENCE));
; 463  : #else
; 464  : 	int iGoldYieldValue = (/*10*/ GC.getAI_CITIZEN_VALUE_GOLD() * pPlot->getYield(YIELD_GOLD));

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2384
	push	2
	mov	ecx, esi
	mov	DWORD PTR _iProductionYieldValue$[esp+36], eax
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	imul	eax, ebx

; 465  : 	int iScienceYieldValue = (/*6*/ GC.getAI_CITIZEN_VALUE_SCIENCE() * pPlot->getYield(YIELD_SCIENCE));

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2388
	push	3
	mov	ecx, esi
	mov	DWORD PTR _iGoldYieldValue$[esp+32], eax
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	imul	eax, ebx

; 466  : #endif
; 467  : 	int iCultureYieldValue = (GC.getAI_CITIZEN_VALUE_CULTURE() * pPlot->getYield(YIELD_CULTURE));

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2392
	push	4
	mov	ecx, esi
	mov	DWORD PTR _iScienceYieldValue$[esp+36], eax
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	imul	eax, ebx

; 468  : 	int iFaithYieldValue = (GC.getAI_CITIZEN_VALUE_FAITH() * pPlot->getYield(YIELD_FAITH));

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2396
	push	5
	mov	ecx, esi
	mov	DWORD PTR _iCultureYieldValue$[esp+36], eax
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	imul	eax, ebx

; 469  : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_YIELD_RATE_MODIFIERS
; 470  : #ifndef AUI_CITIZENS_GET_VALUE_SPLIT_EXCESS_FOOD_MUTLIPLIER
; 471  : 	iFoodYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_FOOD);
; 472  : #endif
; 473  : 	iProductionYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_PRODUCTION);
; 474  : 	iGoldYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_GOLD);
; 475  : 	iScienceYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_SCIENCE);
; 476  : 	iCultureYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_CULTURE);
; 477  : 	iFaithYieldValue *= m_pCity->getBaseYieldRateModifier(YIELD_FAITH);
; 478  : #endif
; 479  : #ifdef AUI_CITIZENS_GOLD_YIELD_COUNTS_AS_SCIENCE_WHEN_IN_DEFICIT
; 480  : 	int iCurrentScienceLoss = -GetPlayer()->calculateGoldRateTimes100() - GetPlayer()->GetTreasury()->GetGoldTimes100();
; 481  : 	if (IsWorkingPlot(pPlot))
; 482  : 		iCurrentScienceLoss += iGoldYieldValue;
; 483  : 	if (iCurrentScienceLoss > 0)
; 484  : 	{
; 485  : 		int iGoldToScienceT100 = MIN(iGoldYieldValue, iCurrentScienceLoss);
; 486  : 		iGoldYieldValue -= iGoldToScienceT100;
; 487  : 		iScienceYieldValue += iGoldToScienceT100;
; 488  : 	}
; 489  : 	iGoldYieldValue *= GC.getAI_CITIZEN_VALUE_GOLD();
; 490  : 	iScienceYieldValue *= GC.getAI_CITIZEN_VALUE_SCIENCE();
; 491  : #endif
; 492  : 
; 493  : 	// How much surplus food are we making?
; 494  : 	int iExcessFoodTimes100 = m_pCity->getYieldRateTimes100(YIELD_FOOD, false) - (m_pCity->foodConsumption() * 100);

	mov	ecx, DWORD PTR [ebp]
	push	0
	push	0
	mov	DWORD PTR _iFaithYieldValue$[esp+40], eax
	call	?foodConsumption@CvCity@@QBEH_NH@Z	; CvCity::foodConsumption
	mov	ecx, DWORD PTR [ebp]
	push	0
	mov	esi, eax
	push	0
	imul	esi, 100				; 00000064H
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100

; 495  : #if defined(AUI_CITIZENS_GET_VALUE_SPLIT_EXCESS_FOOD_MUTLIPLIER) || defined(AUI_CITIZENS_GET_VALUE_ALTER_FOOD_VALUE_IF_FOOD_PRODUCTION) || defined(AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS)
; 496  : 	int iExcessFoodWithPlotTimes100 = iExcessFoodTimes100;
; 497  : 	if (IsWorkingPlot(pPlot))
; 498  : 		iExcessFoodTimes100 -= pPlot->getYield(YIELD_FOOD) * m_pCity->getBaseYieldRateModifier(YIELD_FOOD);
; 499  : 	else
; 500  : 		iExcessFoodWithPlotTimes100 += pPlot->getYield(YIELD_FOOD) * m_pCity->getBaseYieldRateModifier(YIELD_FOOD);
; 501  : #endif
; 502  : 
; 503  : 	bool bAvoidGrowth = IsAvoidGrowth();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, eax
	push	19					; 00000013H
	sub	ebx, esi
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	SHORT $LN43@GetPlotVal
	xor	cl, cl
	jmp	SHORT $LN44@GetPlotVal
$LN43@GetPlotVal:
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	mov	cl, 1
	test	eax, eax
	jl	SHORT $LN44@GetPlotVal
	mov	cl, BYTE PTR [ebp+24]
$LN44@GetPlotVal:

; 504  : 
; 505  : 	// City Focus
; 506  : 	CityAIFocusTypes eFocus = GetFocusType();

	mov	esi, DWORD PTR [ebp+20]

; 507  : 	if(eFocus == CITY_AI_FOCUS_TYPE_FOOD)

	test	esi, esi
	jne	SHORT $LN27@GetPlotVal

; 508  : 		iFoodYieldValue *= 3;

	lea	edi, DWORD PTR [edi+edi*2]
	jmp	$LN62@GetPlotVal
$LN27@GetPlotVal:

; 509  : 	else if(eFocus == CITY_AI_FOCUS_TYPE_PRODUCTION)

	cmp	esi, 1
	jne	SHORT $LN25@GetPlotVal

; 510  : 		iProductionYieldValue *= 3;

	mov	eax, DWORD PTR _iProductionYieldValue$[esp+32]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _iProductionYieldValue$[esp+32], edx
	jmp	SHORT $LN62@GetPlotVal
$LN25@GetPlotVal:

; 511  : 	else if(eFocus == CITY_AI_FOCUS_TYPE_GOLD)

	cmp	esi, 2
	jne	SHORT $LN23@GetPlotVal

; 512  : 		iGoldYieldValue *= 3;

	mov	eax, DWORD PTR _iGoldYieldValue$[esp+28]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _iGoldYieldValue$[esp+28], eax
	jmp	SHORT $LN62@GetPlotVal
$LN23@GetPlotVal:

; 513  : 	else if(eFocus == CITY_AI_FOCUS_TYPE_SCIENCE)

	cmp	esi, 4
	jne	SHORT $LN21@GetPlotVal

; 514  : 		iScienceYieldValue *= 3;

	mov	eax, DWORD PTR _iScienceYieldValue$[esp+32]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _iScienceYieldValue$[esp+32], edx
	jmp	SHORT $LN62@GetPlotVal
$LN21@GetPlotVal:

; 515  : 	else if(eFocus == CITY_AI_FOCUS_TYPE_CULTURE)

	cmp	esi, 5
	jne	SHORT $LN19@GetPlotVal

; 516  : 		iCultureYieldValue *= 3;

	mov	eax, DWORD PTR _iCultureYieldValue$[esp+32]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _iCultureYieldValue$[esp+32], eax
	jmp	SHORT $LN62@GetPlotVal
$LN19@GetPlotVal:

; 517  : 	else if(eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH)

	cmp	esi, 7
	jne	SHORT $LN17@GetPlotVal

; 518  : 	{
; 519  : 		iFoodYieldValue *= 2;
; 520  : 		iGoldYieldValue *= 2;

	mov	edx, DWORD PTR _iGoldYieldValue$[esp+28]
	lea	eax, DWORD PTR [edx+edx]
	add	edi, edi
	mov	DWORD PTR _iGoldYieldValue$[esp+28], eax
	jmp	SHORT $LN62@GetPlotVal
$LN17@GetPlotVal:

; 521  : 	}
; 522  : 	else if(eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH)

	cmp	esi, 6
	jne	SHORT $LN15@GetPlotVal

; 523  : 	{
; 524  : 		iFoodYieldValue *= 2;
; 525  : 		iProductionYieldValue *= 2;

	mov	edx, DWORD PTR _iProductionYieldValue$[esp+32]
	lea	eax, DWORD PTR [edx+edx]
	add	edi, edi
	mov	DWORD PTR _iProductionYieldValue$[esp+32], eax
	jmp	SHORT $LN62@GetPlotVal
$LN15@GetPlotVal:

; 526  : 	}
; 527  : 	else if(eFocus == CITY_AI_FOCUS_TYPE_FAITH)

	cmp	esi, 8
	jne	SHORT $LN62@GetPlotVal

; 528  : 	{
; 529  : 		iFaithYieldValue *= 3;

	mov	eax, DWORD PTR _iFaithYieldValue$[esp+32]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _iFaithYieldValue$[esp+32], edx
$LN62@GetPlotVal:

; 530  : 	}
; 531  : 
; 532  : #ifdef AUI_CITIZENS_GET_VALUE_ALTER_FOOD_VALUE_IF_FOOD_PRODUCTION
; 533  : #ifdef AUI_CITIZENS_FOOD_PRODUCTION_TRIAL_RUN_THEN_SELF_CONSISTENCY
; 534  : 	if (!getIgnoreFoodProduction() && m_pCity->isFoodProduction())
; 535  : #else
; 536  : 	if (m_pCity->isFoodProduction())
; 537  : #endif
; 538  : 	{
; 539  : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 540  : 		iFoodYieldValue = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodWithPlotTimes100) - m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodTimes100);
; 541  : 		int iDummy = m_pCity->GetFoodProduction(iExcessFoodTimes100 / 100);
; 542  : 		int iCurrProdFromFood = m_pCity->foodDifference(true, &iDummy);
; 543  : 		iDummy = m_pCity->GetFoodProduction(iExcessFoodWithPlotTimes100 / 100);
; 544  : 		int iProdFromFoodWithTile = m_pCity->foodDifference(true, &iDummy);
; 545  : #ifndef AUI_CITIZENS_GET_VALUE_CONSIDER_YIELD_RATE_MODIFIERS
; 546  : 		iFoodYieldValue /= 100;
; 547  : #endif
; 548  : #else
; 549  : 		iFoodYieldValue = iExcessFoodWithPlotTimes100 - iExcessFoodTimes100;
; 550  : 		int iCurrProdFromFood = m_pCity->GetFoodProduction(iExcessFoodTimes100 / 100);
; 551  : 		int iProdFromFoodWithTile = m_pCity->GetFoodProduction(iExcessFoodWithPlotTimes100 / 100);
; 552  : #endif
; 553  : 		iProductionYieldValue += (iProdFromFoodWithTile - iCurrProdFromFood) * GC.getAI_CITIZEN_VALUE_PRODUCTION() * (eFocus == CITY_AI_FOCUS_TYPE_PRODUCTION ? 3 : 1);
; 554  : 	}
; 555  : 	else
; 556  : #endif
; 557  : 	// Food can be worth less if we don't want to grow
; 558  : 	if(bUseAllowGrowthFlag && iExcessFoodTimes100 >= 0 && bAvoidGrowth)

	cmp	BYTE PTR _bUseAllowGrowthFlag$[esp+28], 0
	je	SHORT $LN12@GetPlotVal
	test	ebx, ebx
	jl	SHORT $LN12@GetPlotVal
	test	cl, cl
	je	SHORT $LN12@GetPlotVal

; 559  : 	{
; 560  : 		// If we at least have enough Food to feed everyone, zero out the value of additional food
; 561  : #ifdef AUI_CITIZENS_AVOID_GROWTH_STILL_VALUES_EXCESS_FOOD
; 562  : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 563  : 		iExcessFoodTimes100 = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodTimes100);
; 564  : 		iExcessFoodWithPlotTimes100 = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodWithPlotTimes100);
; 565  : #endif
; 566  : 		iFoodYieldValue = iExcessFoodWithPlotTimes100 - iExcessFoodTimes100;
; 567  : #ifndef AUI_CITIZENS_GET_VALUE_CONSIDER_YIELD_RATE_MODIFIERS
; 568  : 		iFoodYieldValue /= 100;
; 569  : #endif
; 570  : #else
; 571  : 		iFoodYieldValue = 0;

	xor	edi, edi

; 572  : #endif
; 573  : 	}
; 574  : 	// We want to grow here
; 575  : 	else

	jmp	SHORT $LN3@GetPlotVal
$LN12@GetPlotVal:

; 576  : 	{
; 577  : #ifdef AUI_CITIZENS_GET_VALUE_SPLIT_EXCESS_FOOD_MUTLIPLIER
; 578  : 		iFoodYieldValue *= 8;
; 579  : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 580  : 		iExcessFoodTimes100 = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodTimes100);
; 581  : 		iExcessFoodWithPlotTimes100 = m_pCity->foodDifferenceTimes100(true, NULL, &iExcessFoodWithPlotTimes100);
; 582  : #endif
; 583  : #ifdef AUI_CITIZENS_AVOID_GROWTH_STILL_VALUES_EXCESS_FOOD
; 584  : 		int iExcessFoodYieldValue = 1;
; 585  : #else
; 586  : 		int iExcessFoodYieldValue = 0;
; 587  : #endif
; 588  : 		int iTargetFoodT100 = 0;
; 589  : 		if (!bUseAllowGrowthFlag || !bAvoidGrowth)
; 590  : 		{
; 591  : 			iExcessFoodYieldValue = iFoodYieldValue / 16;
; 592  : #ifdef AUI_CITIZENS_LOW_POPULATION_CITIES_USE_2MIN_NOT_4X_FOOD
; 593  : 			if (eFocus == NO_CITY_AI_FOCUS_TYPE || eFocus == CITY_AI_FOCUS_TYPE_FOOD || eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH
; 594  : 				|| eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH || m_pCity->getPopulation() < 2)
; 595  : #else
; 596  : 			if (eFocus == NO_CITY_AI_FOCUS_TYPE || eFocus == CITY_AI_FOCUS_TYPE_FOOD || eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH || eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH)
; 597  : #endif
; 598  : 			{
; 599  : 				iTargetFoodT100 = 100 * GC.getFOOD_CONSUMPTION_PER_POPULATION();
; 600  : 			}
; 601  : #ifdef AUI_CITIZENS_PUPPET_STILL_WANTS_GROWTH
; 602  : 			else if (m_pCity->IsPuppet())
; 603  : 				iTargetFoodT100 = 50 * GC.getFOOD_CONSUMPTION_PER_POPULATION();
; 604  : #endif
; 605  : 		}
; 606  : 
; 607  : 		int iNonExcessFoodPlotYieldT100 = iExcessFoodWithPlotTimes100 - iExcessFoodTimes100;
; 608  : 		int iExcessFoodPlotYieldT100 = iNonExcessFoodPlotYieldT100;
; 609  : 		if (iExcessFoodWithPlotTimes100 <= iTargetFoodT100)
; 610  : 		{
; 611  : 			iExcessFoodPlotYieldT100 = 0;
; 612  : 		}
; 613  : 		else if (iExcessFoodTimes100 >= iTargetFoodT100)
; 614  : 		{
; 615  : 			iNonExcessFoodPlotYieldT100 = 0;
; 616  : 		}
; 617  : 		else
; 618  : 		{
; 619  : 			iNonExcessFoodPlotYieldT100 = iTargetFoodT100 - iExcessFoodTimes100;
; 620  : 			iExcessFoodPlotYieldT100 = iExcessFoodWithPlotTimes100 - iTargetFoodT100;
; 621  : 		}
; 622  : 
; 623  : 		iFoodYieldValue *= iNonExcessFoodPlotYieldT100;
; 624  : 		iFoodYieldValue += (iExcessFoodPlotYieldT100 * iExcessFoodYieldValue);
; 625  : #ifndef AUI_CITIZENS_GET_VALUE_CONSIDER_YIELD_RATE_MODIFIERS
; 626  : 		iFoodYieldValue /= 100;
; 627  : #endif
; 628  : #else
; 629  : 		// If we have a non-default and non-food focus, only worry about getting to 0 food
; 630  : #ifdef AUI_CITIZENS_LOW_POPULATION_CITIES_USE_2MIN_NOT_4X_FOOD
; 631  : 		if (eFocus != NO_CITY_AI_FOCUS_TYPE && eFocus != CITY_AI_FOCUS_TYPE_FOOD && eFocus != CITY_AI_FOCUS_TYPE_PROD_GROWTH && eFocus != CITY_AI_FOCUS_TYPE_GOLD_GROWTH && m_pCity->getPopulation() >= 5)
; 632  : #else
; 633  : 		if(eFocus != NO_CITY_AI_FOCUS_TYPE && eFocus != CITY_AI_FOCUS_TYPE_FOOD && eFocus != CITY_AI_FOCUS_TYPE_PROD_GROWTH && eFocus != CITY_AI_FOCUS_TYPE_GOLD_GROWTH)

	cmp	esi, -1
	je	SHORT $LN10@GetPlotVal
	test	esi, esi
	je	SHORT $LN10@GetPlotVal
	cmp	esi, 6
	je	SHORT $LN10@GetPlotVal
	cmp	esi, 7
	je	SHORT $LN10@GetPlotVal

; 634  : #endif
; 635  : 		{
; 636  : 			int iFoodT100NeededFor0 = -iExcessFoodTimes100;

	neg	ebx

; 637  : 
; 638  : 			if(iFoodT100NeededFor0 > 0)

	test	ebx, ebx
	jle	SHORT $LN9@GetPlotVal

; 639  : 			{
; 640  : 				iFoodYieldValue *= 8;

	add	edi, edi
	add	edi, edi
	add	edi, edi

; 641  : 			}
; 642  : 			else

	jmp	SHORT $LN3@GetPlotVal
$LN10@GetPlotVal:

; 643  : 			{
; 644  : 				iFoodYieldValue /= 2;
; 645  : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 646  : 				int iExtraFoodValueT100 = (m_pCity->foodDifferenceTimes100(true, NULL, true, iExcessFoodWithPlotTimes100 - iExcessFoodTimes100) -
; 647  : 					(iExcessFoodWithPlotTimes100 - iExcessFoodTimes100)) * /*12*/ GC.getAI_CITIZEN_VALUE_FOOD();
; 648  : 				if (eFocus == CITY_AI_FOCUS_TYPE_FOOD)
; 649  : 					iExtraFoodValueT100 *= 3;
; 650  : 				else if (eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH || eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH)
; 651  : 					iExtraFoodValueT100 *= 2;
; 652  : 				iFoodYieldValue += iExtraFoodValueT100 / 200;
; 653  : #endif
; 654  : 			}
; 655  : 		}
; 656  : 		// If our surplus is not at least 2, really emphasize food plots
; 657  : 		else if(!bAvoidGrowth)

	test	cl, cl
	jne	SHORT $LN3@GetPlotVal

; 658  : 		{
; 659  : #ifdef AUI_CITIZENS_GET_VALUE_SPLIT_EXCESS_FOOD_MUTLIPLIER
; 660  : 			int iFoodT100NeededFor2 = 100 * GC.getFOOD_CONSUMPTION_PER_POPULATION() - iExcessFoodTimes100;
; 661  : #else
; 662  : 			int iFoodT100NeededFor2 = 200 - iExcessFoodTimes100;

	mov	eax, 200				; 000000c8H
	sub	eax, ebx

; 663  : #endif
; 664  : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 665  : 			int iExtraFoodValueT100 = (m_pCity->foodDifferenceTimes100(true, NULL, true, iExcessFoodWithPlotTimes100 - iExcessFoodTimes100) -
; 666  : 				(iExcessFoodWithPlotTimes100 - iExcessFoodTimes100)) * /*12*/ GC.getAI_CITIZEN_VALUE_FOOD();
; 667  : 			if (eFocus == CITY_AI_FOCUS_TYPE_FOOD)
; 668  : 				iExtraFoodValueT100 *= 3;
; 669  : 			else if (eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH || eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH)
; 670  : 				iExtraFoodValueT100 *= 2;
; 671  : #endif
; 672  : 
; 673  : 			if(iFoodT100NeededFor2 > 0)

	test	eax, eax
	jle	SHORT $LN5@GetPlotVal

; 674  : 			{
; 675  : 				iFoodYieldValue *= 8;

	add	edi, edi
	add	edi, edi
	add	edi, edi
	jmp	SHORT $LN3@GetPlotVal
$LN5@GetPlotVal:

; 676  : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 677  : 				iExtraFoodValueT100 = (m_pCity->foodDifferenceTimes100(true, NULL, true, MIN(iExcessFoodWithPlotTimes100, 100 * GC.getFOOD_CONSUMPTION_PER_POPULATION())) -
; 678  : 					MIN(iExcessFoodWithPlotTimes100, 100 * GC.getFOOD_CONSUMPTION_PER_POPULATION())) * 8 * /*12*/ GC.getAI_CITIZEN_VALUE_FOOD();
; 679  : 				if (eFocus == CITY_AI_FOCUS_TYPE_FOOD)
; 680  : 					iExtraFoodValueT100 *= 3;
; 681  : 				else if (eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH || eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH)
; 682  : 					iExtraFoodValueT100 *= 2;
; 683  : 				iFoodYieldValue += iExtraFoodValueT100 / 100;
; 684  : #endif
; 685  : 			}
; 686  : 			else if (eFocus != CITY_AI_FOCUS_TYPE_FOOD)

	test	esi, esi
	je	SHORT $LN3@GetPlotVal
$LN9@GetPlotVal:

; 687  : 			{
; 688  : 				iFoodYieldValue /= 2;

	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
$LN3@GetPlotVal:

; 689  : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_GROWTH_MODIFIERS
; 690  : 				iFoodYieldValue += iExtraFoodValueT100 / 200;
; 691  : 			}
; 692  : 			else
; 693  : 			{
; 694  : 				iFoodYieldValue += iExtraFoodValueT100 / 100;
; 695  : #endif
; 696  : 			}
; 697  : 		}
; 698  : #ifdef AUI_CITIZENS_FIX_GET_VALUE_FOOD_YIELD_VALUE_WHEN_STARVATION_WITH_AVOID_GROWTH
; 699  : 		// Food focus and negative food, but with avoid growth enabled for some reason
; 700  : 		else
; 701  : 		{
; 702  : 			iFoodYieldValue *= 8;
; 703  : 		}
; 704  : #endif
; 705  : #endif
; 706  : 	}
; 707  : 
; 708  : #ifndef AUI_CITIZENS_LOW_POPULATION_CITIES_USE_2MIN_NOT_4X_FOOD
; 709  : 	if((eFocus == NO_CITY_AI_FOCUS_TYPE || eFocus == CITY_AI_FOCUS_TYPE_PROD_GROWTH || eFocus == CITY_AI_FOCUS_TYPE_GOLD_GROWTH) && !bAvoidGrowth && m_pCity->getPopulation() < 5)

	cmp	esi, -1
	je	SHORT $LN1@GetPlotVal
	cmp	esi, 6
	je	SHORT $LN1@GetPlotVal
	cmp	esi, 7
	jne	SHORT $LN63@GetPlotVal
$LN1@GetPlotVal:
	test	cl, cl
	jne	SHORT $LN63@GetPlotVal
	mov	ecx, DWORD PTR [ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, 5
	jge	SHORT $LN63@GetPlotVal

; 710  : 	{
; 711  : 		iFoodYieldValue *= 4;

	add	edi, edi
	add	edi, edi
$LN63@GetPlotVal:
	mov	ecx, DWORD PTR _iFaithYieldValue$[esp+32]
	mov	edx, DWORD PTR _iCultureYieldValue$[esp+32]
	lea	eax, DWORD PTR [ecx+edx]

; 712  : 	}
; 713  : #endif
; 714  : 
; 715  : 	iValue += iFoodYieldValue;
; 716  : 	iValue += iProductionYieldValue;
; 717  : 	iValue += iGoldYieldValue;
; 718  : 	iValue += iScienceYieldValue;
; 719  : 	iValue += iCultureYieldValue;
; 720  : 	iValue += iFaithYieldValue;
; 721  : #ifdef AUI_CITIZENS_GET_VALUE_CONSIDER_YIELD_RATE_MODIFIERS
; 722  : 	iValue /= 100;
; 723  : #endif
; 724  : 
; 725  : 	return iValue;

	add	eax, DWORD PTR _iScienceYieldValue$[esp+32]
	add	eax, DWORD PTR _iGoldYieldValue$[esp+28]
	add	eax, DWORD PTR _iProductionYieldValue$[esp+32]
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 726  : }

	add	esp, 16					; 00000010H
	ret	8
?GetPlotValue@CvCityCitizens@@QAEHPAVCvPlot@@_N@Z ENDP	; CvCityCitizens::GetPlotValue
_TEXT	ENDS
PUBLIC	?GetAIBestSpecialistBuilding@CvCityCitizens@@QAE?AW4BuildingTypes@@AAH@Z ; CvCityCitizens::GetAIBestSpecialistBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetAIBestSpecialistBuilding@CvCityCitizens@@QAE?AW4BuildingTypes@@AAH@Z
_TEXT	SEGMENT
_iBestSpecialistValue$ = -12				; size = 4
_iBestUnmodifiedSpecialistValue$ = -8			; size = 4
_eBestBuilding$ = -4					; size = 4
_iSpecialistValue$ = 8					; size = 4
?GetAIBestSpecialistBuilding@CvCityCitizens@@QAE?AW4BuildingTypes@@AAH@Z PROC ; CvCityCitizens::GetAIBestSpecialistBuilding, COMDAT
; _this$ = ecx

; 1210 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1211 : 	BuildingTypes eBestBuilding = NO_BUILDING;

	or	edi, -1
	mov	ebp, ecx
	mov	esi, edi

; 1212 : 	int iBestSpecialistValue = -1;
; 1213 : #ifdef AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST
; 1214 : 	if (bGetWorst)
; 1215 : 		iBestSpecialistValue = MAX_INT;
; 1216 : #endif
; 1217 : #ifndef NQM_PRUNING
; 1218 : 	int iBestUnmodifiedSpecialistValue = -1;
; 1219 : #endif
; 1220 : 
; 1221 : 	SpecialistTypes eSpecialist;
; 1222 : 	int iValue;
; 1223 : 
; 1224 : 	// Loop through all Buildings
; 1225 : #ifdef AUI_WARNING_FIXES
; 1226 : 	for (uint iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
; 1227 : #else
; 1228 : 	for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eBestBuilding$[esp+28], esi
	mov	DWORD PTR _iBestSpecialistValue$[esp+28], edi
	mov	DWORD PTR _iBestUnmodifiedSpecialistValue$[esp+28], edi
	xor	ebx, ebx
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN26@GetAIBestS
	npad	2
$LL30@GetAIBestS:

; 1229 : #endif
; 1230 : 	{
; 1231 : 		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
; 1232 : 		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 1233 : 
; 1234 : 		if(pkBuildingInfo)

	test	edi, edi
	je	$LN6@GetAIBestS

; 1235 : 		{
; 1236 : 			// Have this Building in the City?
; 1237 : 			if(GetCity()->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [ebp]
	push	ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN6@GetAIBestS

; 1238 : 			{
; 1239 : 				// Can't add more than the max
; 1240 : #ifdef AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST
; 1241 : 				if ((!bIsWorked && IsCanAddSpecialistToBuilding(eBuilding)) || (bIsWorked &&  GetNumSpecialistsInBuilding(eBuilding) > 0))
; 1242 : #else
; 1243 : 				if(IsCanAddSpecialistToBuilding(eBuilding))

	mov	eax, DWORD PTR [ebp+116]
	mov	ecx, DWORD PTR [ebp]
	mov	esi, DWORD PTR [eax+ebx*4]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	esi, eax
	jge	SHORT $LN6@GetAIBestS
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ecx, eax
	call	?GetSpecialistCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistCount
	cmp	esi, eax
	jge	SHORT $LN6@GetAIBestS
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7100
	jge	SHORT $LN6@GetAIBestS

; 1244 : #endif
; 1245 : 				{
; 1246 : 					eSpecialist = (SpecialistTypes) pkBuildingInfo->GetSpecialistType();

	mov	ecx, edi
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType

; 1247 : #ifdef AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST
; 1248 : 					if (eSpecialist == eIgnoreSpecialist)
; 1249 : 						continue;
; 1250 : #endif
; 1251 : 
; 1252 : #ifdef AUI_CITIZENS_UNHARDCODE_SPECIALIST_VALUE_HAPPINESS
; 1253 : 					iValue = GetSpecialistValue(eSpecialist, bIsWorked);
; 1254 : #else
; 1255 : 					iValue = GetSpecialistValue(eSpecialist);

	push	eax
	mov	ecx, ebp
	call	?GetSpecialistValue@CvCityCitizens@@QAEHW4SpecialistTypes@@@Z ; CvCityCitizens::GetSpecialistValue

; 1256 : #endif
; 1257 : 
; 1258 : #ifndef NQM_PRUNING
; 1259 : 					// Add a bit more weight to a Building if it has more slots (10% per).  This will bias the AI to fill a single building over spreading Specialists out
; 1260 : 					int iTemp = ((GetNumSpecialistsAllowedByBuilding(*pkBuildingInfo) - 1) * iValue * 10);

	mov	ecx, edi
	mov	esi, eax
	call	?GetSpecialistCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistCount
	dec	eax
	imul	eax, esi

; 1261 : 					iTemp /= 100;

	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1262 : 					iValue += iTemp;

	add	esi, eax

; 1263 : #endif
; 1264 : 
; 1265 : #ifdef AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST
; 1266 : 					if (((iValue > iBestSpecialistValue) && !bGetWorst) || ((iValue < iBestSpecialistValue) && bGetWorst))
; 1267 : #else
; 1268 : 					if(iValue > iBestSpecialistValue)

	cmp	esi, DWORD PTR _iBestSpecialistValue$[esp+28]
	jle	SHORT $LN6@GetAIBestS

; 1269 : #endif
; 1270 : 					{
; 1271 : 						eBestBuilding = eBuilding;
; 1272 : 						iBestSpecialistValue = iValue;

	mov	DWORD PTR _iBestSpecialistValue$[esp+28], esi

; 1273 : #ifndef NQM_PRUNING
; 1274 : 						iBestUnmodifiedSpecialistValue = iValue - iTemp;

	sub	esi, eax
	mov	DWORD PTR _eBestBuilding$[esp+28], ebx
	mov	DWORD PTR _iBestUnmodifiedSpecialistValue$[esp+28], esi
$LN6@GetAIBestS:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	ebx, eax
	jl	$LL30@GetAIBestS

; 1275 : #endif
; 1276 : 					}
; 1277 : 				}
; 1278 : 			}
; 1279 : 		}
; 1280 : 	}
; 1281 : 
; 1282 : #if defined(NQM_PRUNING) && defined(AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST)
; 1283 : 	if (iSpecialistValue)
; 1284 : 		*iSpecialistValue = iBestSpecialistValue;
; 1285 : #elif defined(AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST)
; 1286 : 	if (iSpecialistValue)
; 1287 : 		*iSpecialistValue = iBestUnmodifiedSpecialistValue;
; 1288 : #elif defined(NQM_PRUNING)
; 1289 : 	iSpecialistValue = iBestSpecialistValue;
; 1290 : #else
; 1291 : 	iSpecialistValue = iBestUnmodifiedSpecialistValue;

	mov	ecx, DWORD PTR _iSpecialistValue$[esp+24]
	mov	edx, DWORD PTR _iBestUnmodifiedSpecialistValue$[esp+28]

; 1292 : #endif
; 1293 : 	return eBestBuilding;

	mov	eax, DWORD PTR _eBestBuilding$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx], edx
	pop	ebx

; 1294 : }

	add	esp, 12					; 0000000cH
	ret	4
$LN26@GetAIBestS:

; 1275 : #endif
; 1276 : 					}
; 1277 : 				}
; 1278 : 			}
; 1279 : 		}
; 1280 : 	}
; 1281 : 
; 1282 : #if defined(NQM_PRUNING) && defined(AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST)
; 1283 : 	if (iSpecialistValue)
; 1284 : 		*iSpecialistValue = iBestSpecialistValue;
; 1285 : #elif defined(AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST)
; 1286 : 	if (iSpecialistValue)
; 1287 : 		*iSpecialistValue = iBestUnmodifiedSpecialistValue;
; 1288 : #elif defined(NQM_PRUNING)
; 1289 : 	iSpecialistValue = iBestSpecialistValue;
; 1290 : #else
; 1291 : 	iSpecialistValue = iBestUnmodifiedSpecialistValue;

	mov	eax, DWORD PTR _iSpecialistValue$[esp+24]
	mov	DWORD PTR [eax], edi
	pop	edi

; 1292 : #endif
; 1293 : 	return eBestBuilding;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1294 : }

	add	esp, 12					; 0000000cH
	ret	4
?GetAIBestSpecialistBuilding@CvCityCitizens@@QAE?AW4BuildingTypes@@AAH@Z ENDP ; CvCityCitizens::GetAIBestSpecialistBuilding
_TEXT	ENDS
PUBLIC	?GetBestCityPlotWithValue@CvCityCitizens@@QAEPAVCvPlot@@AAH_N1@Z ; CvCityCitizens::GetBestCityPlotWithValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetBestCityPlotWithValue@CvCityCitizens@@QAEPAVCvPlot@@AAH_N1@Z
_TEXT	SEGMENT
_iBestPlotValue$ = -8					; size = 4
_iBestPlotID$ = -4					; size = 4
_iValue$ = 8						; size = 4
_bWantBest$ = 12					; size = 1
_bWantWorked$ = 16					; size = 1
?GetBestCityPlotWithValue@CvCityCitizens@@QAEPAVCvPlot@@AAH_N1@Z PROC ; CvCityCitizens::GetBestCityPlotWithValue, COMDAT
; _this$ = ecx

; 2107 : {

	sub	esp, 8
	push	ebx
	push	ebp

; 2108 : 	bool bPlotForceWorked;
; 2109 : 
; 2110 : 	int iBestPlotValue = -1;
; 2111 : 	int iBestPlotID = -1;
; 2112 : 
; 2113 : 	CvPlot* pLoopPlot;
; 2114 : 
; 2115 : 	// Look at all workable Plots
; 2116 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	mov	ebp, DWORD PTR _iValue$[esp+12]
	or	eax, -1
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _iBestPlotValue$[esp+24], eax
	mov	DWORD PTR _iBestPlotID$[esp+24], eax
	xor	ebx, ebx
	npad	6
$LL69@GetBestCit:

; 2117 : 	{
; 2118 : 		if(iPlotLoop != CITY_HOME_PLOT)

	test	ebx, ebx
	je	$LN17@GetBestCit

; 2119 : 		{
; 2120 : 			pLoopPlot = GetCityPlotFromIndex(iPlotLoop);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	ebx
	push	ecx
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 2121 : 
; 2122 : 			if(pLoopPlot != NULL)

	test	esi, esi
	je	$LN17@GetBestCit

; 2123 : 			{
; 2124 : 				// Is this a Plot this City controls?
; 2125 : 				if(pLoopPlot->getWorkingCity() != NULL && pLoopPlot->getWorkingCity()->GetID() == GetCity()->GetID())

	mov	ecx, esi
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	test	eax, eax
	je	$LN17@GetBestCit
	mov	ecx, esi
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+120]
	cmp	eax, DWORD PTR [ecx+120]
	jne	$LN17@GetBestCit

; 2126 : 				{
; 2127 : 					// Working the Plot and wanting to work it, or Not working it and wanting to find one to work?
; 2128 : 					if((IsWorkingPlot(pLoopPlot) && bWantWorked) ||
; 2129 : 					        (!IsWorkingPlot(pLoopPlot) && !bWantWorked))

	push	esi
	push	ecx
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN10@GetBestCit
	cmp	BYTE PTR [eax+edi+25], 0
	je	SHORT $LN10@GetBestCit
	cmp	BYTE PTR _bWantWorked$[esp+20], 0
	jne	SHORT $LN8@GetBestCit
$LN10@GetBestCit:
	mov	ecx, DWORD PTR [edi]
	push	esi
	push	ecx
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN66@GetBestCit
	cmp	BYTE PTR [eax+edi+25], 0
	jne	SHORT $LN17@GetBestCit
$LN66@GetBestCit:
	cmp	BYTE PTR _bWantWorked$[esp+20], 0
	jne	SHORT $LN17@GetBestCit

; 2130 : 					{
; 2131 : 						// Working the Plot or CAN work the Plot?
; 2132 : 						if(bWantWorked || IsCanWork(pLoopPlot))

	push	esi
	mov	ecx, edi
	call	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsCanWork
	test	al, al
	je	SHORT $LN17@GetBestCit
$LN8@GetBestCit:

; 2133 : 						{
; 2134 : #ifdef AUI_CITIZENS_REALLOCATE_CITIZENS_USES_SELF_CONSISTENCY
; 2135 : 							iValue = GetPlotValue(pLoopPlot, true);
; 2136 : #else
; 2137 : 							iValue = GetPlotValue(pLoopPlot, bWantBest);

	mov	edx, DWORD PTR _bWantBest$[esp+20]
	push	edx
	push	esi
	mov	ecx, edi
	call	?GetPlotValue@CvCityCitizens@@QAEHPAVCvPlot@@_N@Z ; CvCityCitizens::GetPlotValue

; 2138 : #endif
; 2139 : 
; 2140 : 							bPlotForceWorked = IsForcedWorkingPlot(pLoopPlot);

	push	esi
	mov	ecx, edi
	mov	DWORD PTR [ebp], eax
	call	?IsForcedWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsForcedWorkingPlot

; 2141 : 
; 2142 : 							if(bPlotForceWorked)

	test	al, al
	je	SHORT $LN67@GetBestCit

; 2143 : 							{
; 2144 : 								// Looking for best, unworked Plot: Forced plots are FIRST to be picked
; 2145 : 								if(bWantBest && !bWantWorked)

	cmp	BYTE PTR _bWantBest$[esp+20], 0
	je	SHORT $LN64@GetBestCit
	cmp	BYTE PTR _bWantWorked$[esp+20], 0
	jne	SHORT $LN67@GetBestCit

; 2146 : 								{
; 2147 : 									iValue += 10000;
; 2148 : 								}
; 2149 : 								// Looking for worst, worked Plot: Forced plots are LAST to be picked, so make it's value incredibly high
; 2150 : 								if(!bWantBest && bWantWorked)

	jmp	SHORT $LN70@GetBestCit
$LN64@GetBestCit:
	cmp	BYTE PTR _bWantWorked$[esp+20], 0
	je	SHORT $LN67@GetBestCit
$LN70@GetBestCit:

; 2151 : 								{
; 2152 : 									iValue += 10000;

	add	DWORD PTR [ebp], 10000			; 00002710H
$LN67@GetBestCit:

; 2153 : 								}
; 2154 : 							}
; 2155 : 
; 2156 : 							if(iBestPlotValue == -1 ||							// First Plot?
; 2157 : 							        (bWantBest && iValue > iBestPlotValue) ||		// Best Plot so far?
; 2158 : 							        (!bWantBest && iValue < iBestPlotValue))			// Worst Plot so far?

	mov	eax, DWORD PTR _iBestPlotValue$[esp+24]
	cmp	eax, -1
	je	SHORT $LN3@GetBestCit
	cmp	BYTE PTR _bWantBest$[esp+20], 0
	je	SHORT $LN63@GetBestCit
	cmp	DWORD PTR [ebp], eax
	jg	SHORT $LN3@GetBestCit
	jmp	SHORT $LN17@GetBestCit
$LN63@GetBestCit:
	cmp	DWORD PTR [ebp], eax
	jge	SHORT $LN17@GetBestCit
$LN3@GetBestCit:

; 2159 : 							{
; 2160 : 								iBestPlotValue = iValue;

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR _iBestPlotValue$[esp+24], eax

; 2161 : 								iBestPlotID = iPlotLoop;

	mov	DWORD PTR _iBestPlotID$[esp+24], ebx
$LN17@GetBestCit:
	inc	ebx
	cmp	ebx, 37					; 00000025H
	jl	$LL69@GetBestCit

; 2162 : 							}
; 2163 : 						}
; 2164 : 					}
; 2165 : 				}
; 2166 : 			}
; 2167 : 		}
; 2168 : 	}
; 2169 : 
; 2170 : 	// Passed in by reference
; 2171 : 	iValue = iBestPlotValue;

	mov	ecx, DWORD PTR _iBestPlotValue$[esp+24]
	mov	DWORD PTR [ebp], ecx

; 2172 : 
; 2173 : 	if(iBestPlotID == -1)

	mov	ecx, DWORD PTR _iBestPlotID$[esp+24]
	cmp	ecx, -1
	jne	SHORT $LN1@GetBestCit
	pop	edi
	pop	esi
	pop	ebp

; 2174 : 	{
; 2175 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 2179 : }

	add	esp, 8
	ret	12					; 0000000cH
$LN1@GetBestCit:

; 2176 : 	}
; 2177 : 
; 2178 : 	return GetCityPlotFromIndex(iBestPlotID);

	mov	edi, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+108]
	mov	edi, DWORD PTR [edi+96]
	push	ecx
	push	eax
	push	edi
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2179 : }

	add	esp, 8
	ret	12					; 0000000cH
?GetBestCityPlotWithValue@CvCityCitizens@@QAEPAVCvPlot@@AAH_N1@Z ENDP ; CvCityCitizens::GetBestCityPlotWithValue
_TEXT	ENDS
PUBLIC	?SetForcedWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N@Z ; CvCityCitizens::SetForcedWorkingPlot
PUBLIC	?DoDemoteWorstForcedWorkingPlot@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoDemoteWorstForcedWorkingPlot
; Function compile flags: /Ogtpy
;	COMDAT ?DoDemoteWorstForcedWorkingPlot@CvCityCitizens@@QAEXXZ
_TEXT	SEGMENT
_iBestPlotID$ = -4					; size = 4
?DoDemoteWorstForcedWorkingPlot@CvCityCitizens@@QAEXXZ PROC ; CvCityCitizens::DoDemoteWorstForcedWorkingPlot, COMDAT
; _this$ = ecx

; 2603 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 2604 : 	int iValue;
; 2605 : 
; 2606 : 	int iBestPlotValue = -1;

	or	ebp, -1
	push	edi
	mov	esi, ecx

; 2607 : 	int iBestPlotID = -1;

	mov	DWORD PTR _iBestPlotID$[esp+20], ebp

; 2608 : 
; 2609 : 	CvPlot* pLoopPlot;
; 2610 : 
; 2611 : 	// Look at all workable Plots
; 2612 : 	for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	xor	ebx, ebx
$LL73@DoDemoteWo:

; 2613 : 	{
; 2614 : 		if(iPlotLoop != CITY_HOME_PLOT)

	test	ebx, ebx
	je	SHORT $LN8@DoDemoteWo

; 2615 : 		{
; 2616 : 			pLoopPlot = GetCityPlotFromIndex(iPlotLoop);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	ebx
	push	ecx
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 2617 : 
; 2618 : 			if(pLoopPlot != NULL)

	test	edi, edi
	je	SHORT $LN8@DoDemoteWo

; 2619 : 			{
; 2620 : 				if(IsForcedWorkingPlot(pLoopPlot))

	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN8@DoDemoteWo
	cmp	BYTE PTR [eax+esi+62], 0
	je	SHORT $LN8@DoDemoteWo

; 2621 : 				{
; 2622 : 					iValue = GetPlotValue(pLoopPlot, false);

	push	0
	push	edi
	mov	ecx, esi
	call	?GetPlotValue@CvCityCitizens@@QAEHPAVCvPlot@@_N@Z ; CvCityCitizens::GetPlotValue

; 2623 : 
; 2624 : 					// First, or worst yet?
; 2625 : 					if(iBestPlotValue == -1 || iValue < iBestPlotValue)

	cmp	ebp, -1
	je	SHORT $LN2@DoDemoteWo
	cmp	eax, ebp
	jge	SHORT $LN8@DoDemoteWo
$LN2@DoDemoteWo:

; 2626 : 					{
; 2627 : 						iBestPlotValue = iValue;

	mov	ebp, eax

; 2628 : 						iBestPlotID = iPlotLoop;

	mov	DWORD PTR _iBestPlotID$[esp+20], ebx
$LN8@DoDemoteWo:
	inc	ebx
	cmp	ebx, 37					; 00000025H
	jl	SHORT $LL73@DoDemoteWo

; 2629 : 					}
; 2630 : 				}
; 2631 : 			}
; 2632 : 		}
; 2633 : 	}
; 2634 : 
; 2635 : 	if(iBestPlotID > -1)

	mov	edx, DWORD PTR _iBestPlotID$[esp+20]
	cmp	edx, -1
	jle	SHORT $LN1@DoDemoteWo

; 2636 : 	{
; 2637 : 		pLoopPlot = GetCityPlotFromIndex(iBestPlotID);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	edx
	push	ecx
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH

; 2638 : 		SetForcedWorkingPlot(pLoopPlot, false);

	push	0
	push	eax
	mov	ecx, esi
	call	?SetForcedWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N@Z ; CvCityCitizens::SetForcedWorkingPlot
$LN1@DoDemoteWo:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2639 : 	}
; 2640 : }

	pop	ecx
	ret	0
?DoDemoteWorstForcedWorkingPlot@CvCityCitizens@@QAEXXZ ENDP ; CvCityCitizens::DoDemoteWorstForcedWorkingPlot
_TEXT	ENDS
PUBLIC	?DoValidateForcedWorkingPlots@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoValidateForcedWorkingPlots
; Function compile flags: /Ogtpy
;	COMDAT ?DoValidateForcedWorkingPlots@CvCityCitizens@@QAEXXZ
_TEXT	SEGMENT
?DoValidateForcedWorkingPlots@CvCityCitizens@@QAEXXZ PROC ; CvCityCitizens::DoValidateForcedWorkingPlots, COMDAT
; _this$ = ecx

; 2589 : {

	push	esi
	mov	esi, ecx

; 2590 : 	int iNumForcedWorkingPlotsToDemote = GetNumForcedWorkingPlots() - GetNumCitizensWorkingPlots();

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]

; 2591 : 
; 2592 : 	if(iNumForcedWorkingPlotsToDemote > 0)

	test	eax, eax
	jle	SHORT $LN1@DoValidate
	push	edi

; 2593 : 	{
; 2594 : 		for(int iLoop = 0; iLoop < iNumForcedWorkingPlotsToDemote; iLoop++)

	mov	edi, eax
$LL3@DoValidate:

; 2595 : 		{
; 2596 : 			DoDemoteWorstForcedWorkingPlot();

	mov	ecx, esi
	call	?DoDemoteWorstForcedWorkingPlot@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoDemoteWorstForcedWorkingPlot
	sub	edi, 1
	jne	SHORT $LL3@DoValidate
	pop	edi
$LN1@DoValidate:
	pop	esi

; 2597 : 		}
; 2598 : 	}
; 2599 : }

	ret	0
?DoValidateForcedWorkingPlots@CvCityCitizens@@QAEXXZ ENDP ; CvCityCitizens::DoValidateForcedWorkingPlots
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?SetForcedWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetForcedWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N@Z PROC ; CvCityCitizens::SetForcedWorkingPlot, COMDAT
; _this$ = ecx

; 2559 : {

	push	ebx
	push	esi
	push	edi

; 2560 : 	int iIndex = GetCityIndexFromPlot(pPlot);

	mov	edi, DWORD PTR _pPlot$[esp+8]
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY

; 2561 : 
; 2562 : 	CvAssertMsg(iIndex >= 0, "iIndex expected to be >= 0");
; 2563 : 	CvAssertMsg(iIndex < NUM_CITY_PLOTS, "iIndex expected to be < NUM_CITY_PLOTS");
; 2564 : 
; 2565 : 	if(IsForcedWorkingPlot(pPlot) != bNewValue && iIndex >= 0 && iIndex < NUM_CITY_PLOTS)

	mov	ecx, DWORD PTR [esi]
	push	edi
	push	ecx
	mov	ebx, eax
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	add	esp, 16					; 00000010H
	cmp	eax, -1
	je	SHORT $LN9@SetForcedW
	mov	al, BYTE PTR [eax+esi+62]
	jmp	SHORT $LN10@SetForcedW
$LN9@SetForcedW:
	xor	al, al
$LN10@SetForcedW:
	mov	cl, BYTE PTR _bNewValue$[esp+8]
	cmp	al, cl
	je	SHORT $LN21@SetForcedW
	cmp	ebx, 36					; 00000024H
	ja	SHORT $LN21@SetForcedW

; 2566 : 	{
; 2567 : 		m_pabForcedWorkingPlot[iIndex] = bNewValue;

	mov	BYTE PTR [ebx+esi+62], cl

; 2568 : 
; 2569 : 		// Change the count of how many are forced
; 2570 : 		if(bNewValue)

	test	cl, cl
	je	SHORT $LN3@SetForcedW

; 2571 : 		{
; 2572 : 			ChangeNumForcedWorkingPlots(1);

	inc	DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+16]

; 2573 : 
; 2574 : 			// More forced plots than we have citizens working?  If so, then pick someone to lose their forced status
; 2575 : 			if(GetNumForcedWorkingPlots() > GetNumCitizensWorkingPlots())

	cmp	eax, DWORD PTR [esi+12]
	jle	SHORT $LN21@SetForcedW

; 2576 : 			{
; 2577 : 				DoValidateForcedWorkingPlots();

	mov	ecx, esi
	call	?DoValidateForcedWorkingPlots@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoValidateForcedWorkingPlots
	pop	edi
	pop	esi
	pop	ebx

; 2583 : 		}
; 2584 : 	}
; 2585 : }

	ret	8
$LN3@SetForcedW:

; 2578 : 			}
; 2579 : 		}
; 2580 : 		else
; 2581 : 		{
; 2582 : 			ChangeNumForcedWorkingPlots(-1);

	dec	DWORD PTR [esi+16]
$LN21@SetForcedW:
	pop	edi
	pop	esi
	pop	ebx

; 2583 : 		}
; 2584 : 	}
; 2585 : }

	ret	8
?SetForcedWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N@Z ENDP ; CvCityCitizens::SetForcedWorkingPlot
_TEXT	ENDS
PUBLIC	?DoRemoveWorstCitizen@CvCityCitizens@@QAE_N_NW4SpecialistTypes@@H@Z ; CvCityCitizens::DoRemoveWorstCitizen
; Function compile flags: /Ogtpy
;	COMDAT ?DoRemoveWorstCitizen@CvCityCitizens@@QAE_N_NW4SpecialistTypes@@H@Z
_TEXT	SEGMENT
_bRemoveForcedStatus$ = 8				; size = 1
_eDontChangeSpecialist$ = 12				; size = 4
_iWorstPlotValue$ = 16					; size = 4
_iCurrentCityPopulation$ = 16				; size = 4
?DoRemoveWorstCitizen@CvCityCitizens@@QAE_N_NW4SpecialistTypes@@H@Z PROC ; CvCityCitizens::DoRemoveWorstCitizen, COMDAT
; _this$ = ecx

; 2004 : {

	push	ebx

; 2005 : 	if (iCurrentCityPopulation == -1)

	mov	ebx, DWORD PTR _iCurrentCityPopulation$[esp]
	push	esi
	push	edi
	mov	esi, ecx
	cmp	ebx, -1
	jne	SHORT $LN10@DoRemoveWo@2

; 2006 : 	{
; 2007 : 		iCurrentCityPopulation = GetCity()->getPopulation();

	mov	ecx, DWORD PTR [esi]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	ebx, eax
$LN10@DoRemoveWo@2:

; 2008 : 	}
; 2009 : 
; 2010 : 	// Are all of our guys already not working Plots?
; 2011 : 	if(GetNumUnassignedCitizens() == GetCity()->getPopulation())

	mov	ecx, DWORD PTR [esi]
	mov	edi, DWORD PTR [esi+8]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	edi, eax
	jne	SHORT $LN9@DoRemoveWo@2
	pop	edi
	pop	esi

; 2012 : 	{
; 2013 : 		return false;

	xor	al, al
	pop	ebx

; 2096 : 		{
; 2097 : 			return true;
; 2098 : 		}
; 2099 : 	}
; 2100 : #endif
; 2101 : 
; 2102 : 	return false;
; 2103 : }

	ret	12					; 0000000cH
$LN9@DoRemoveWo@2:

; 2014 : 	}
; 2015 : 
; 2016 : #ifndef AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST
; 2017 : 	// Find default Specialist to pull off, if there is one
; 2018 : 	if(GetNumDefaultSpecialists() > 0)

	mov	eax, DWORD PTR [esi+100]
	test	eax, eax
	jle	SHORT $LN6@DoRemoveWo@2

; 2019 : 	{
; 2020 : 		// Do we either have unforced default specialists we can remove?
; 2021 : 		if(GetNumDefaultSpecialists() > GetNumForcedDefaultSpecialists())

	mov	ecx, DWORD PTR [esi+104]
	cmp	eax, ecx
	jle	SHORT $LN7@DoRemoveWo@2

; 2022 : 		{
; 2023 : 			ChangeNumDefaultSpecialists(-1);

	mov	ecx, DWORD PTR [esi+108]
	dec	eax
	mov	DWORD PTR [esi+100], eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8420
	dec	DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi]
	push	-1
	push	eax
	call	?processSpecialist@CvCity@@QAEXW4SpecialistTypes@@H@Z ; CvCity::processSpecialist
	inc	DWORD PTR [esi+8]
	pop	edi
	pop	esi

; 2024 : 			return true;

	mov	al, 1
	pop	ebx

; 2096 : 		{
; 2097 : 			return true;
; 2098 : 		}
; 2099 : 	}
; 2100 : #endif
; 2101 : 
; 2102 : 	return false;
; 2103 : }

	ret	12					; 0000000cH
$LN7@DoRemoveWo@2:

; 2025 : 		}
; 2026 : 		if(GetNumDefaultSpecialists() > iCurrentCityPopulation)

	cmp	eax, ebx
	jle	SHORT $LN6@DoRemoveWo@2

; 2027 : 		{
; 2028 : 			ChangeNumForcedDefaultSpecialists(-1);

	dec	ecx
	mov	DWORD PTR [esi+104], ecx

; 2029 : 			ChangeNumDefaultSpecialists(-1);

	push	-1
	mov	ecx, esi
	call	?ChangeNumDefaultSpecialists@CvCityCitizens@@QAEXH@Z ; CvCityCitizens::ChangeNumDefaultSpecialists
	pop	edi
	pop	esi

; 2030 : 			return true;

	mov	al, 1
	pop	ebx

; 2096 : 		{
; 2097 : 			return true;
; 2098 : 		}
; 2099 : 	}
; 2100 : #endif
; 2101 : 
; 2102 : 	return false;
; 2103 : }

	ret	12					; 0000000cH
$LN6@DoRemoveWo@2:

; 2031 : 		}
; 2032 : 	}
; 2033 : #endif
; 2034 : 
; 2035 : 	// No Default Specialists, remove a working Pop, if there is one
; 2036 : 	int iWorstPlotValue = 0;
; 2037 : 	CvPlot* pWorstPlot = GetBestCityPlotWithValue(iWorstPlotValue, /*bBest*/ false, /*bWorked*/ true);

	push	1
	push	0
	lea	edx, DWORD PTR _iWorstPlotValue$[esp+16]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR _iWorstPlotValue$[esp+20], 0
	call	?GetBestCityPlotWithValue@CvCityCitizens@@QAEPAVCvPlot@@AAH_N1@Z ; CvCityCitizens::GetBestCityPlotWithValue
	mov	edi, eax

; 2038 : 
; 2039 : #ifdef AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST
; 2040 : 	int iWorstSpecialistValue = 0;
; 2041 : 	BuildingTypes eWorstSpecialistBuilding = NO_BUILDING;
; 2042 : 	if (!IsNoAutoAssignSpecialists())
; 2043 : 	{
; 2044 : 		eWorstSpecialistBuilding = GetAIBestSpecialistBuilding(&iWorstSpecialistValue, true, true, eDontChangeSpecialist);
; 2045 : 	}
; 2046 : 
; 2047 : 	// Find default Specialist to pull off, if there is one
; 2048 : 	if (GetNumDefaultSpecialists() > 0)
; 2049 : 	{
; 2050 : 		int iDefaultSpecialistScore = GetSpecialistValue((SpecialistTypes)GC.getDEFAULT_SPECIALIST());
; 2051 : 		// Do we either have unforced default specialists we can remove?
; 2052 : 		if (GetNumDefaultSpecialists() > GetNumForcedDefaultSpecialists() && (eWorstSpecialistBuilding == NO_BUILDING || iDefaultSpecialistScore <= iWorstSpecialistValue) 
; 2053 : 			&& (pWorstPlot == NULL || iDefaultSpecialistScore <= iWorstPlotValue))
; 2054 : 		{
; 2055 : 			ChangeNumDefaultSpecialists(-1);
; 2056 : 			return true;
; 2057 : 		}
; 2058 : 		if (GetNumDefaultSpecialists() > iCurrentCityPopulation && (eWorstSpecialistBuilding == NO_BUILDING || iDefaultSpecialistScore <= iWorstSpecialistValue)
; 2059 : 			&& (pWorstPlot == NULL || iDefaultSpecialistScore <= iWorstPlotValue))
; 2060 : 		{
; 2061 : 			ChangeNumForcedDefaultSpecialists(-1);
; 2062 : 			ChangeNumDefaultSpecialists(-1);
; 2063 : 			return true;
; 2064 : 		}
; 2065 : 	}
; 2066 : 
; 2067 : 	if (pWorstPlot != NULL && (eWorstSpecialistBuilding == NO_BUILDING || iWorstPlotValue < iWorstSpecialistValue))
; 2068 : #else
; 2069 : 	if(pWorstPlot != NULL)
; 2070 : #endif
; 2071 : 	{
; 2072 : 		SetWorkingPlot(pWorstPlot, false);

	mov	ecx, esi
	test	edi, edi
	je	SHORT $LN5@DoRemoveWo@2
	push	1
	push	0
	push	edi
	call	?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z ; CvCityCitizens::SetWorkingPlot

; 2073 : 
; 2074 : 		// If we were force-working this Plot, turn it off
; 2075 : 		if(bRemoveForcedStatus)

	cmp	BYTE PTR _bRemoveForcedStatus$[esp+8], 0
	je	SHORT $LN3@DoRemoveWo@2

; 2076 : 		{
; 2077 : 			if(IsForcedWorkingPlot(pWorstPlot))

	push	edi
	mov	ecx, esi
	call	?IsForcedWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsForcedWorkingPlot
	test	al, al
	je	SHORT $LN3@DoRemoveWo@2

; 2078 : 			{
; 2079 : 				SetForcedWorkingPlot(pWorstPlot, false);

	push	0
	push	edi
	mov	ecx, esi
	call	?SetForcedWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N@Z ; CvCityCitizens::SetForcedWorkingPlot
$LN3@DoRemoveWo@2:
	pop	edi
	pop	esi

; 2080 : 			}
; 2081 : 		}
; 2082 : 
; 2083 : 		return true;

	mov	al, 1
	pop	ebx

; 2096 : 		{
; 2097 : 			return true;
; 2098 : 		}
; 2099 : 	}
; 2100 : #endif
; 2101 : 
; 2102 : 	return false;
; 2103 : }

	ret	12					; 0000000cH
$LN5@DoRemoveWo@2:

; 2084 : 	}
; 2085 : 	// Have to resort to pulling away a good Specialist
; 2086 : #ifdef AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST
; 2087 : 	else if (eWorstSpecialistBuilding != NO_BUILDING)
; 2088 : 	{
; 2089 : 		DoRemoveSpecialistFromBuilding(eWorstSpecialistBuilding, false);
; 2090 : 		return true;
; 2091 : 	}
; 2092 : #else
; 2093 : 	else
; 2094 : 	{
; 2095 : 		if(DoRemoveWorstSpecialist(eDontChangeSpecialist))

	mov	eax, DWORD PTR _eDontChangeSpecialist$[esp+8]
	push	-1
	push	eax
	call	?DoRemoveWorstSpecialist@CvCityCitizens@@QAE_NW4SpecialistTypes@@W4BuildingTypes@@@Z ; CvCityCitizens::DoRemoveWorstSpecialist
	pop	edi
	test	al, al
	pop	esi
	setne	al
	pop	ebx

; 2096 : 		{
; 2097 : 			return true;
; 2098 : 		}
; 2099 : 	}
; 2100 : #endif
; 2101 : 
; 2102 : 	return false;
; 2103 : }

	ret	12					; 0000000cH
?DoRemoveWorstCitizen@CvCityCitizens@@QAE_N_NW4SpecialistTypes@@H@Z ENDP ; CvCityCitizens::DoRemoveWorstCitizen
_TEXT	ENDS
PUBLIC	?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z ; CvCityCitizens::DoAddSpecialistToBuilding
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z$1
__ehfuncinfo$?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitycitizens.cpp
xdata$x	ENDS
;	COMDAT ?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pCity$226232 = 8					; size = 4
_eBuilding$ = 8						; size = 4
$T230072 = 12						; size = 4
_bForced$ = 12						; size = 1
?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z PROC ; CvCityCitizens::DoAddSpecialistToBuilding, COMDAT
; _this$ = ecx

; 3188 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	ebp

; 3189 : 	CvAssert(eBuilding > -1);
; 3190 : 	CvAssert(eBuilding < GC.getNumBuildingInfos());
; 3191 : 
; 3192 : 	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	mov	ebp, DWORD PTR _eBuilding$[esp+16]
	push	esi
	push	edi
	mov	edi, ecx
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 3193 : 	if(pkBuildingInfo == NULL)

	test	eax, eax
	je	$LN57@DoAddSpeci

; 3194 : 	{
; 3195 : 		return;
; 3196 : 	}
; 3197 : 
; 3198 : 	SpecialistTypes eSpecialist = (SpecialistTypes) pkBuildingInfo->GetSpecialistType();

	mov	ecx, eax
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType

; 3199 : 
; 3200 : 	// Can't add more than the max
; 3201 : 	if(IsCanAddSpecialistToBuilding(eBuilding))

	mov	ecx, DWORD PTR [edi]
	mov	esi, eax
	mov	eax, DWORD PTR [edi+116]
	mov	ebx, DWORD PTR [eax+ebp*4]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	ebx, eax
	jge	$LN57@DoAddSpeci
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ecx, eax
	call	?GetSpecialistCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistCount
	cmp	ebx, eax
	jge	$LN57@DoAddSpeci
	cmp	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7100
	jge	$LN57@DoAddSpeci

; 3202 : 	{
; 3203 : 		// If we're force-assigning a specialist, then we can reduce the count on forced default specialists
; 3204 : 		if(bForced)

	cmp	BYTE PTR _bForced$[esp+24], 0
	je	SHORT $LN61@DoAddSpeci

; 3205 : 		{
; 3206 : 			if(GetNumForcedDefaultSpecialists() > 0)

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jle	SHORT $LN61@DoAddSpeci

; 3207 : 				ChangeNumForcedDefaultSpecialists(-1);

	dec	eax
	mov	DWORD PTR [edi+104], eax
$LN61@DoAddSpeci:

; 3208 : 		}
; 3209 : 
; 3210 : 		// If we don't already have an Unassigned Citizen to turn into a Specialist, find one from somewhere
; 3211 : 		if(GetNumUnassignedCitizens() == 0)

	mov	eax, DWORD PTR [edi+8]
	or	ebx, -1
	test	eax, eax
	jne	SHORT $LN62@DoAddSpeci

; 3212 : 		{
; 3213 : 			DoRemoveWorstCitizen(true, /*Don't remove this type*/ eSpecialist);

	push	ebx
	push	esi
	push	1
	mov	ecx, edi
	call	?DoRemoveWorstCitizen@CvCityCitizens@@QAE_N_NW4SpecialistTypes@@H@Z ; CvCityCitizens::DoRemoveWorstCitizen

; 3214 : 			if(GetNumUnassignedCitizens() == 0)

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN62@DoAddSpeci

; 3215 : 			{
; 3216 : 				// Still nobody, all the citizens may be assigned to the eSpecialist we are looking for, try again
; 3217 : 				if(!DoRemoveWorstSpecialist(NO_SPECIALIST, eBuilding))

	push	ebp
	push	ebx
	mov	ecx, edi
	call	?DoRemoveWorstSpecialist@CvCityCitizens@@QAE_NW4SpecialistTypes@@W4BuildingTypes@@@Z ; CvCityCitizens::DoRemoveWorstSpecialist
	test	al, al
	je	$LN57@DoAddSpeci
$LN62@DoAddSpeci:

; 3218 : 				{
; 3219 : 					return; // For some reason we can't do this, we must exit, else we will be going over the population count
; 3220 : 				}
; 3221 : 			}
; 3222 : 		}
; 3223 : 
; 3224 : 		// Increase count for the whole city
; 3225 : 		m_aiSpecialistCounts[eSpecialist]++;

	mov	ecx, DWORD PTR [edi+108]
	inc	DWORD PTR [ecx+esi*4]

; 3226 : 		m_aiNumSpecialistsInBuilding[eBuilding]++;

	mov	edx, DWORD PTR [edi+116]
	inc	DWORD PTR [edx+ebp*4]

; 3227 : 
; 3228 : 		if(bForced)

	cmp	BYTE PTR _bForced$[esp+24], 0
	lea	eax, DWORD PTR [ecx+esi*4]
	lea	eax, DWORD PTR [edx+ebp*4]
	je	SHORT $LN1@DoAddSpeci

; 3229 : 		{
; 3230 : 			m_aiNumForcedSpecialistsInBuilding[eBuilding]++;

	mov	eax, DWORD PTR [edi+120]
	inc	DWORD PTR [eax+ebp*4]
	lea	ebp, DWORD PTR [eax+ebp*4]
$LN1@DoAddSpeci:

; 3231 : 		}
; 3232 : 
; 3233 : 		GetCity()->processSpecialist(eSpecialist, 1);

	mov	ecx, DWORD PTR [edi]
	push	1
	push	esi
	call	?processSpecialist@CvCity@@QAEXW4SpecialistTypes@@H@Z ; CvCity::processSpecialist

; 3234 : 		GetCity()->UpdateReligion(GetCity()->GetCityReligions()->GetReligiousMajority());

	mov	esi, DWORD PTR [edi]
	mov	ecx, esi
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ ; CvCityReligions::GetReligiousMajority
	push	eax
	mov	ecx, esi
	call	?UpdateReligion@CvCity@@QAEXW4ReligionTypes@@@Z ; CvCity::UpdateReligion

; 3235 : 
; 3236 : 		ChangeNumUnassignedCitizens(-1);

	add	DWORD PTR [edi+8], ebx

; 3237 : 
; 3238 : 		ICvUserInterface2* pkIFace = GC.GetEngineUserInterface();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600

; 3239 : 		pkIFace->setDirty(GameData_DIRTY_BIT, true);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	mov	ecx, esi
	call	eax

; 3240 : 		pkIFace->setDirty(CityInfo_DIRTY_BIT, true);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	18					; 00000012H
	mov	ecx, esi
	call	eax

; 3241 : 		//pkIFace->setDirty(InfoPane_DIRTY_BIT, true );
; 3242 : 		pkIFace->setDirty(CityScreen_DIRTY_BIT, true);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	21					; 00000015H
	mov	ecx, esi
	call	eax

; 3243 : 		pkIFace->setDirty(ColoredPlots_DIRTY_BIT, true);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	24					; 00000018H
	mov	ecx, esi
	call	eax

; 3244 : 
; 3245 : 		CvCity* pkCity = GetCity();

	mov	edi, DWORD PTR [edi]

; 3246 : 		auto_ptr<ICvCity1> pCity = GC.WrapCityPointer(pkCity);

	push	edi
	lea	ecx, DWORD PTR $T230072[esp+28]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z ; CvGlobals::WrapCityPointer
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pCity$226232[esp+24], edi
	mov	eax, DWORD PTR $T230072[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	test	eax, eax
	je	SHORT $LN50@DoAddSpeci
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN50@DoAddSpeci:

; 3247 : 
; 3248 : 		pkIFace->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_SPECIALISTS);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+440]
	push	1
	push	edi
	mov	ecx, esi
	call	eax

; 3249 : 	}

	mov	DWORD PTR __$EHRec$[esp+36], ebx
	test	edi, edi
	je	SHORT $LN57@DoAddSpeci
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx
$LN57@DoAddSpeci:

; 3250 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _pCity$226232[ebp-4]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__ehhandler$?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z ENDP ; CvCityCitizens::DoAddSpecialistToBuilding
PUBLIC	?DoAddBestCitizenFromUnassigned@CvCityCitizens@@QAE_NXZ ; CvCityCitizens::DoAddBestCitizenFromUnassigned
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
; Function compile flags: /Ogtpy
;	COMDAT ?DoAddBestCitizenFromUnassigned@CvCityCitizens@@QAE_NXZ
_TEXT	SEGMENT
_iSpecialistValue$ = -8					; size = 4
_iBestPlotValue$ = -4					; size = 4
?DoAddBestCitizenFromUnassigned@CvCityCitizens@@QAE_NXZ PROC ; CvCityCitizens::DoAddBestCitizenFromUnassigned, COMDAT
; _this$ = ecx

; 1889 : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 1890 : 	// We only assign the unassigned here, folks
; 1891 : 	if (GetNumUnassignedCitizens() == 0)

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN15@DoAddBestC

; 1892 : 	{
; 1893 : 		return false;

	xor	al, al
	pop	esi

; 2000 : }

	add	esp, 8
	ret	0
$LN15@DoAddBestC:
	push	edi

; 1894 : 	}
; 1895 : 
; 1896 : 	// First Specialist Pass
; 1897 : 	int iSpecialistValue = 0;
; 1898 : 	BuildingTypes eBestSpecialistBuilding = NO_BUILDING;

	or	edi, -1

; 1899 : 	if (!IsNoAutoAssignSpecialists())

	cmp	BYTE PTR [esi+5], 0
	mov	DWORD PTR _iSpecialistValue$[esp+16], 0
	jne	SHORT $LN14@DoAddBestC

; 1900 : 	{
; 1901 : #ifdef AUI_CITIZENS_FIX_REMOVE_WORST_SPECIALIST_ACTUALLY_REMOVES_WORST
; 1902 : 		eBestSpecialistBuilding = GetAIBestSpecialistBuilding(&iSpecialistValue);
; 1903 : #else
; 1904 : 		eBestSpecialistBuilding = GetAIBestSpecialistBuilding(iSpecialistValue);

	lea	eax, DWORD PTR _iSpecialistValue$[esp+16]
	push	eax
	call	?GetAIBestSpecialistBuilding@CvCityCitizens@@QAE?AW4BuildingTypes@@AAH@Z ; CvCityCitizens::GetAIBestSpecialistBuilding
	mov	edi, eax
$LN14@DoAddBestC:
	push	ebx

; 1905 : #endif
; 1906 : 	}
; 1907 : 
; 1908 : #if defined(AUI_CITIZENS_IS_PLOT_BETTER_THAN_DEFAULT_SPECIALIST) || defined(AUI_CITIZENS_SELF_CONSISTENCY_CHECK)
; 1909 : 	int iDefaultSpecialistValue = GetSpecialistValue((SpecialistTypes)GC.getDEFAULT_SPECIALIST());
; 1910 : #endif
; 1911 : 
; 1912 : #ifdef AUI_CITIZENS_IS_BETTER_THAN_DEFAULT_SPECIALIST_USE_REGULAR_VALUES
; 1913 : 	bool bBetterThanSlacker = eBestSpecialistBuilding != NO_BUILDING && iSpecialistValue >= iDefaultSpecialistValue;
; 1914 : #else
; 1915 : 	bool bBetterThanSlacker = false;

	xor	bl, bl

; 1916 : 	if (eBestSpecialistBuilding != NO_BUILDING)

	cmp	edi, -1
	je	SHORT $LN11@DoAddBestC

; 1917 : 	{
; 1918 : 		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBestSpecialistBuilding);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 1919 : 		if(pkBuildingInfo)

	test	eax, eax
	je	SHORT $LN11@DoAddBestC

; 1920 : 		{
; 1921 : 			SpecialistTypes eSpecialist = (SpecialistTypes) pkBuildingInfo->GetSpecialistType();

	mov	ecx, eax
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType

; 1922 : 			// Must not be worse than a default Specialist for our focus!
; 1923 : 			if (IsBetterThanDefaultSpecialist(eSpecialist))

	push	eax
	mov	ecx, esi
	call	?IsBetterThanDefaultSpecialist@CvCityCitizens@@QAE_NW4SpecialistTypes@@@Z ; CvCityCitizens::IsBetterThanDefaultSpecialist
	test	al, al
	je	SHORT $LN11@DoAddBestC

; 1924 : 			{
; 1925 : 				bBetterThanSlacker = true;

	mov	bl, 1
$LN11@DoAddBestC:

; 1926 : 			}
; 1927 : 		}
; 1928 : 	}
; 1929 : #endif
; 1930 : 
; 1931 : 	int iBestPlotValue = 0;
; 1932 : 	CvPlot* pBestPlot = GetBestCityPlotWithValue(iBestPlotValue, /*bBest*/ true, /*bWorked*/ false);

	push	0
	push	1
	lea	ecx, DWORD PTR _iBestPlotValue$[esp+28]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _iBestPlotValue$[esp+32], 0
	call	?GetBestCityPlotWithValue@CvCityCitizens@@QAEPAVCvPlot@@AAH_N1@Z ; CvCityCitizens::GetBestCityPlotWithValue

; 1933 : 
; 1934 : 	bool bSpecialistBetterThanPlot = (eBestSpecialistBuilding != NO_BUILDING && iSpecialistValue >= iBestPlotValue);

	cmp	edi, -1
	je	SHORT $LN50@DoAddBestC
	mov	edx, DWORD PTR _iSpecialistValue$[esp+20]
	cmp	edx, DWORD PTR _iBestPlotValue$[esp+20]

; 1935 : 
; 1936 : 	// Is there a Specialist we can assign?
; 1937 : 	if (bSpecialistBetterThanPlot && bBetterThanSlacker)

	jl	SHORT $LN50@DoAddBestC
	test	bl, bl
	je	SHORT $LN8@DoAddBestC
$LN54@DoAddBestC:

; 1938 : 	{
; 1939 : 		DoAddSpecialistToBuilding(eBestSpecialistBuilding, /*bForced*/ false);

	push	0
	push	edi
	mov	ecx, esi
	call	?DoAddSpecialistToBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z ; CvCityCitizens::DoAddSpecialistToBuilding
	pop	ebx
	pop	edi

; 1940 : #ifdef AUI_CITIZENS_SELF_CONSISTENCY_CHECK
; 1941 : 		if (piBestScore)
; 1942 : 			*piBestScore = iSpecialistValue;
; 1943 : #endif
; 1944 : 		return true;

	mov	al, 1
	pop	esi

; 2000 : }

	add	esp, 8
	ret	0
$LN50@DoAddBestC:

; 1945 : 	}
; 1946 : 	// Found a Valid Plot to place a guy?
; 1947 : #ifdef AUI_CITIZENS_IS_PLOT_BETTER_THAN_DEFAULT_SPECIALIST
; 1948 : 	else if (pBestPlot != NULL && iBestPlotValue >= iDefaultSpecialistValue)
; 1949 : #else
; 1950 : 	else if (!bSpecialistBetterThanPlot && pBestPlot != NULL)

	test	eax, eax
	je	SHORT $LN8@DoAddBestC

; 1951 : #endif
; 1952 : 	{
; 1953 : 		// Now assign the guy to the best possible Plot
; 1954 : 		SetWorkingPlot(pBestPlot, true);

	push	1
	push	1
	push	eax
	mov	ecx, esi
	call	?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z ; CvCityCitizens::SetWorkingPlot
	pop	ebx
	pop	edi

; 1955 : #ifdef AUI_CITIZENS_SELF_CONSISTENCY_CHECK
; 1956 : 		if (piBestScore)
; 1957 : 			*piBestScore = iBestPlotValue;
; 1958 : #endif
; 1959 : 		return true;

	mov	al, 1
	pop	esi

; 2000 : }

	add	esp, 8
	ret	0
$LN8@DoAddBestC:

; 1960 : 	}
; 1961 : 	// No Valid Plots left - and no good specialists
; 1962 : 	else
; 1963 : 	{
; 1964 : #ifdef AUI_CITIZENS_SELF_CONSISTENCY_CHECK
; 1965 : 		if (piBestScore)
; 1966 : 			*piBestScore = iDefaultSpecialistValue;
; 1967 : #else
; 1968 : 		CvPlayer* pOwner = &GET_PLAYER(GetOwner());

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ecx, 63236				; 0000f704H
	add	ecx, edx

; 1969 : 		CvAssertMsg(pOwner, "Could not find owner of city when assigning citizens. Please send Anton your save file and version.");
; 1970 : 
; 1971 : 		// Assign a cool Specialist! Only do this for AI players, or humans who do not have manual specialist control set
; 1972 : 		if (pOwner)

	je	SHORT $LN1@DoAddBestC

; 1973 : 		{
; 1974 : 			if (!GET_PLAYER(GetOwner()).isHuman() || !IsNoAutoAssignSpecialists())

	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN4@DoAddBestC
	cmp	BYTE PTR [esi+5], 0
	jne	SHORT $LN1@DoAddBestC
$LN4@DoAddBestC:

; 1975 : 			{
; 1976 : 				BuildingTypes eBestBuilding = GetAIBestSpecialistBuilding(iSpecialistValue);

	lea	eax, DWORD PTR _iSpecialistValue$[esp+20]
	push	eax
	mov	ecx, esi
	call	?GetAIBestSpecialistBuilding@CvCityCitizens@@QAE?AW4BuildingTypes@@AAH@Z ; CvCityCitizens::GetAIBestSpecialistBuilding
	mov	edi, eax

; 1977 : 				if(eBestBuilding != NO_BUILDING)

	cmp	edi, -1
	je	SHORT $LN1@DoAddBestC

; 1978 : 				{
; 1979 : 					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBestBuilding);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 1980 : 					if(pkBuildingInfo)

	test	eax, eax
	je	SHORT $LN1@DoAddBestC

; 1981 : 					{
; 1982 : 						SpecialistTypes eSpecialist = (SpecialistTypes) pkBuildingInfo->GetSpecialistType();

	mov	ecx, eax
	call	?GetSpecialistType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistType

; 1983 : 						// Must not be worse than a default Specialist for our focus!
; 1984 : 						if (IsBetterThanDefaultSpecialist(eSpecialist))

	push	eax
	mov	ecx, esi
	call	?IsBetterThanDefaultSpecialist@CvCityCitizens@@QAE_NW4SpecialistTypes@@@Z ; CvCityCitizens::IsBetterThanDefaultSpecialist
	test	al, al

; 1985 : 						{
; 1986 : 							DoAddSpecialistToBuilding(eBestBuilding, false);
; 1987 : 							return true;

	jne	$LN54@DoAddBestC
$LN1@DoAddBestC:

; 1988 : 						}
; 1989 : 					}
; 1990 : 				}
; 1991 : 			}
; 1992 : 		}
; 1993 : #endif
; 1994 : 
; 1995 : 		// Default Specialist if we can't do anything else
; 1996 : 		ChangeNumDefaultSpecialists(1);

	inc	DWORD PTR [esi+100]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8420
	mov	ecx, DWORD PTR [esi+108]
	inc	DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi]
	push	1
	push	eax
	call	?processSpecialist@CvCity@@QAEXW4SpecialistTypes@@H@Z ; CvCity::processSpecialist
	dec	DWORD PTR [esi+8]
	pop	ebx
	pop	edi

; 1997 : 	}
; 1998 : 
; 1999 : 	return false;

	xor	al, al
	pop	esi

; 2000 : }

	add	esp, 8
	ret	0
?DoAddBestCitizenFromUnassigned@CvCityCitizens@@QAE_NXZ ENDP ; CvCityCitizens::DoAddBestCitizenFromUnassigned
_TEXT	ENDS
PUBLIC	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ	; CvCityCitizens::DoReallocateCitizens
; Function compile flags: /Ogtpy
;	COMDAT ?DoReallocateCitizens@CvCityCitizens@@QAEXXZ
_TEXT	SEGMENT
?DoReallocateCitizens@CvCityCitizens@@QAEXXZ PROC	; CvCityCitizens::DoReallocateCitizens, COMDAT
; _this$ = ecx

; 2183 : {

	push	esi
	mov	esi, ecx

; 2184 : 	// Make sure we don't have more forced working plots than we have citizens working.  If so, clean it up before reallocating
; 2185 : 	DoValidateForcedWorkingPlots();

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	push	edi
	test	eax, eax
	jle	SHORT $LN19@DoRealloca
	mov	edi, eax
$LL21@DoRealloca:
	mov	ecx, esi
	call	?DoDemoteWorstForcedWorkingPlot@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoDemoteWorstForcedWorkingPlot
	sub	edi, 1
	jne	SHORT $LL21@DoRealloca
$LN19@DoRealloca:

; 2186 : 
; 2187 : 	// Remove all of the allocated guys
; 2188 : #ifdef AUI_CITIZENS_FIX_DO_REALLOCATE_CITIZENS_NO_COSTLY_PLOT_REMOVAL
; 2189 : 	CvPlot* pLoopPlot;
; 2190 : 	for (int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)
; 2191 : 	{
; 2192 : 		if (iPlotLoop != CITY_HOME_PLOT)
; 2193 : 		{
; 2194 : 			pLoopPlot = GetCityPlotFromIndex(iPlotLoop);
; 2195 : 
; 2196 : 			if (pLoopPlot != NULL)
; 2197 : 			{
; 2198 : 				if (pLoopPlot->getWorkingCity() != NULL && pLoopPlot->getWorkingCity()->GetID() == GetCity()->GetID())
; 2199 : 				{
; 2200 : 					SetWorkingPlot(pLoopPlot, false, true);
; 2201 : 				}
; 2202 : 			}
; 2203 : 		}
; 2204 : 	}
; 2205 : #else
; 2206 : 	int iNumCitizensToRemove = GetNumCitizensWorkingPlots();

	mov	edi, DWORD PTR [esi+12]

; 2207 : 	for(int iWorkerLoop = 0; iWorkerLoop < iNumCitizensToRemove; iWorkerLoop++)

	test	edi, edi
	jle	SHORT $LN14@DoRealloca
$LL16@DoRealloca:

; 2208 : 	{
; 2209 : 		DoRemoveWorstCitizen();

	push	-1
	push	-1
	push	0
	mov	ecx, esi
	call	?DoRemoveWorstCitizen@CvCityCitizens@@QAE_N_NW4SpecialistTypes@@H@Z ; CvCityCitizens::DoRemoveWorstCitizen
	sub	edi, 1
	jne	SHORT $LL16@DoRealloca
$LN14@DoRealloca:

; 2210 : 	}
; 2211 : #endif
; 2212 : 
; 2213 : 	int iSpecialistLoop;
; 2214 : 
; 2215 : #ifdef AUI_CITIZENS_FIX_DO_REALLOCATE_CITIZENS_OBEY_MANUAL_SPECIALIST_CONTROL
; 2216 : 	if (!IsNoAutoAssignSpecialists())
; 2217 : 	{
; 2218 : #endif
; 2219 : 	// Remove Non-Forced Specialists in Buildings
; 2220 : 	int iNumSpecialistsToRemove;
; 2221 : 	BuildingTypes eBuilding;
; 2222 : #ifdef AUI_WARNING_FIXES
; 2223 : 	for (uint iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
; 2224 : #else
; 2225 : 	for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	SHORT $LN11@DoRealloca
	push	ebx
$LL63@DoRealloca:

; 2226 : #endif
; 2227 : 	{
; 2228 : 		eBuilding = (BuildingTypes) iBuildingLoop;
; 2229 : 
; 2230 : 		// Have this Building in the City?
; 2231 : 		if(GetCity()->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN12@DoRealloca

; 2232 : 		{
; 2233 : 			iNumSpecialistsToRemove = GetNumSpecialistsInBuilding(eBuilding) - GetNumForcedSpecialistsInBuilding(eBuilding);	// Don't include Forced guys

	mov	edx, DWORD PTR [esi+116]
	mov	ecx, DWORD PTR [esi+120]
	mov	eax, DWORD PTR [edx+edi*4]
	sub	eax, DWORD PTR [ecx+edi*4]

; 2234 : 
; 2235 : 			// Loop through guys to remove (if there are any)
; 2236 : 			for(iSpecialistLoop = 0; iSpecialistLoop < iNumSpecialistsToRemove; iSpecialistLoop++)

	test	eax, eax
	jle	SHORT $LN12@DoRealloca

; 2232 : 		{
; 2233 : 			iNumSpecialistsToRemove = GetNumSpecialistsInBuilding(eBuilding) - GetNumForcedSpecialistsInBuilding(eBuilding);	// Don't include Forced guys

	mov	ebx, eax
	npad	5
$LL9@DoRealloca:

; 2237 : 			{
; 2238 : 				DoRemoveSpecialistFromBuilding(eBuilding, /*bForced*/ false);

	push	0
	push	0
	push	edi
	mov	ecx, esi
	call	?DoRemoveSpecialistFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N1@Z ; CvCityCitizens::DoRemoveSpecialistFromBuilding
	sub	ebx, 1
	jne	SHORT $LL9@DoRealloca
$LN12@DoRealloca:

; 2210 : 	}
; 2211 : #endif
; 2212 : 
; 2213 : 	int iSpecialistLoop;
; 2214 : 
; 2215 : #ifdef AUI_CITIZENS_FIX_DO_REALLOCATE_CITIZENS_OBEY_MANUAL_SPECIALIST_CONTROL
; 2216 : 	if (!IsNoAutoAssignSpecialists())
; 2217 : 	{
; 2218 : #endif
; 2219 : 	// Remove Non-Forced Specialists in Buildings
; 2220 : 	int iNumSpecialistsToRemove;
; 2221 : 	BuildingTypes eBuilding;
; 2222 : #ifdef AUI_WARNING_FIXES
; 2223 : 	for (uint iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
; 2224 : #else
; 2225 : 	for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	edi, eax
	jl	SHORT $LL63@DoRealloca
	pop	ebx
$LN11@DoRealloca:

; 2239 : 			}
; 2240 : 		}
; 2241 : 	}
; 2242 : #ifdef AUI_CITIZENS_FIX_DO_REALLOCATE_CITIZENS_OBEY_MANUAL_SPECIALIST_CONTROL
; 2243 : 	}
; 2244 : #endif
; 2245 : 
; 2246 : 	// Remove Default Specialists
; 2247 : 	int iNumDefaultsToRemove = GetNumDefaultSpecialists() - GetNumForcedDefaultSpecialists();

	mov	edi, DWORD PTR [esi+100]
	sub	edi, DWORD PTR [esi+104]

; 2248 : 	for(iSpecialistLoop = 0; iSpecialistLoop < iNumDefaultsToRemove; iSpecialistLoop++)

	test	edi, edi
	jle	SHORT $LN4@DoRealloca
	npad	5
$LL6@DoRealloca:

; 2249 : 	{
; 2250 : 		ChangeNumDefaultSpecialists(-1);

	dec	DWORD PTR [esi+100]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8420
	mov	ecx, DWORD PTR [esi+108]
	dec	DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi]
	push	-1
	push	eax
	call	?processSpecialist@CvCity@@QAEXW4SpecialistTypes@@H@Z ; CvCity::processSpecialist
	inc	DWORD PTR [esi+8]
	sub	edi, 1
	jne	SHORT $LL6@DoRealloca
$LN4@DoRealloca:

; 2251 : 	}
; 2252 : 
; 2253 : 	// Now put all of the unallocated guys back
; 2254 : 	int iNumToAllocate = GetNumUnassignedCitizens();

	mov	edi, DWORD PTR [esi+8]

; 2255 : 	for(int iUnallocatedLoop = 0; iUnallocatedLoop < iNumToAllocate; iUnallocatedLoop++)

	test	edi, edi
	jle	SHORT $LN1@DoRealloca
	npad	6
$LL3@DoRealloca:

; 2256 : 	{
; 2257 : 		DoAddBestCitizenFromUnassigned();

	mov	ecx, esi
	call	?DoAddBestCitizenFromUnassigned@CvCityCitizens@@QAE_NXZ ; CvCityCitizens::DoAddBestCitizenFromUnassigned
	sub	edi, 1
	jne	SHORT $LL3@DoRealloca
$LN1@DoRealloca:
	pop	edi
	pop	esi

; 2258 : 	}
; 2259 : 
; 2260 : #ifdef AUI_CITIZENS_REALLOCATE_CITIZENS_USES_SELF_CONSISTENCY
; 2261 : 	DoSelfConsistencyCheck();
; 2262 : #elif defined(AUI_CITIZENS_FIX_DO_REALLOCATE_CITIZENS_NO_COSTLY_PLOT_REMOVAL)
; 2263 : 	ICvUserInterface2* pkIFace = GC.GetEngineUserInterface();
; 2264 : 	pkIFace->setDirty(GameData_DIRTY_BIT, true);
; 2265 : 	pkIFace->setDirty(CityInfo_DIRTY_BIT, true);
; 2266 : 	//pkIFace->setDirty(InfoPane_DIRTY_BIT, true );
; 2267 : 	pkIFace->setDirty(CityScreen_DIRTY_BIT, true);
; 2268 : 	pkIFace->setDirty(ColoredPlots_DIRTY_BIT, true);
; 2269 : #endif
; 2270 : }

	ret	0
?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ENDP	; CvCityCitizens::DoReallocateCitizens
_TEXT	ENDS
PUBLIC	?DoAlterWorkingPlot@CvCityCitizens@@QAEXH@Z	; CvCityCitizens::DoAlterWorkingPlot
EXTRN	?setWorkingCityOverride@CvPlot@@QAEXPBVCvCity@@@Z:PROC ; CvPlot::setWorkingCityOverride
EXTRN	?IsPuppet@CvCity@@QBE_NXZ:PROC			; CvCity::IsPuppet
EXTRN	?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ:PROC ; CvPlot::getWorkingCityOverride
; Function compile flags: /Ogtpy
;	COMDAT ?DoAlterWorkingPlot@CvCityCitizens@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?DoAlterWorkingPlot@CvCityCitizens@@QAEXH@Z PROC	; CvCityCitizens::DoAlterWorkingPlot, COMDAT
; _this$ = ecx

; 2418 : 	CvAssertMsg(iIndex >= 0, "iIndex expected to be >= 0");
; 2419 : 	CvAssertMsg(iIndex < NUM_CITY_PLOTS, "iIndex expected to be < NUM_CITY_PLOTS");
; 2420 : 
; 2421 : 	// Clicking ON the city "resets" it to default setup
; 2422 : 	if(iIndex == CITY_HOME_PLOT)

	mov	edx, DWORD PTR _iIndex$[esp-4]
	push	esi
	push	edi
	mov	esi, ecx
	test	edx, edx
	jne	$LN21@DoAlterWor
	push	ebx
	push	ebp

; 2423 : 	{
; 2424 : 		CvPlot* pLoopPlot;
; 2425 : 
; 2426 : 		// If we've forced any plots to be worked, reset them to the normal state
; 2427 : 		for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	xor	ebx, ebx
$LL102@DoAlterWor:

; 2428 : 		{
; 2429 : 			if(iPlotLoop != CITY_HOME_PLOT)

	test	ebx, ebx
	je	SHORT $LN19@DoAlterWor

; 2430 : 			{
; 2431 : 				pLoopPlot = GetCityPlotFromIndex(iPlotLoop);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	ebx
	push	ecx
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 2432 : 
; 2433 : 				if(pLoopPlot != NULL)

	test	edi, edi
	je	SHORT $LN19@DoAlterWor

; 2434 : 				{
; 2435 : 					if(IsForcedWorkingPlot(pLoopPlot))

	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN19@DoAlterWor
	cmp	BYTE PTR [esi+eax+62], 0
	je	SHORT $LN19@DoAlterWor

; 2436 : 					{
; 2437 : 						SetForcedWorkingPlot(pLoopPlot, false);

	mov	ecx, DWORD PTR [esi]
	push	edi
	push	ecx
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	mov	edx, DWORD PTR [esi]
	push	edi
	push	edx
	mov	ebp, eax
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	add	esp, 16					; 00000010H
	cmp	eax, -1
	je	SHORT $LN19@DoAlterWor
	cmp	BYTE PTR [esi+eax+62], 0
	je	SHORT $LN19@DoAlterWor
	cmp	ebp, 36					; 00000024H
	ja	SHORT $LN19@DoAlterWor
	mov	BYTE PTR [esi+ebp+62], 0
	dec	DWORD PTR [esi+16]
$LN19@DoAlterWor:
	inc	ebx
	cmp	ebx, 37					; 00000025H
	jl	SHORT $LL102@DoAlterWor

; 2438 : 					}
; 2439 : 				}
; 2440 : 			}
; 2441 : 		}
; 2442 : 
; 2443 : 		// Reset Forced Default Specialists
; 2444 : 		ChangeNumForcedDefaultSpecialists(-GetNumForcedDefaultSpecialists());
; 2445 : 
; 2446 : 		DoReallocateCitizens();

	mov	ecx, esi
	mov	DWORD PTR [esi+104], 0
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 2528 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2529 : 				if (pOldWorkingCityOverride)
; 2530 : 					pOldWorkingCityOverride->GetCityCitizens()->DoSelfConsistencyCheck();
; 2531 : #endif
; 2532 : 			}
; 2533 : 		}
; 2534 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2535 : 		DoSelfConsistencyCheck();
; 2536 : #endif
; 2537 : 	}
; 2538 : }

	ret	4
$LN21@DoAlterWor:

; 2447 : 	}
; 2448 : 	else
; 2449 : 	{
; 2450 : 		CvPlot* pPlot = GetCityPlotFromIndex(iIndex);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	edx
	push	ecx
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 2451 : 
; 2452 : 		if(pPlot != NULL)

	test	edi, edi
	je	$LN3@DoAlterWor

; 2453 : 		{
; 2454 : 			if(IsCanWork(pPlot))

	push	edi
	mov	ecx, esi
	call	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsCanWork
	test	al, al
	je	$LN12@DoAlterWor

; 2455 : 			{
; 2456 : //				GetCity()->setCitizensAutomated(false);
; 2457 : 
; 2458 : 				// If we're already working the Plot, then take the guy off and turn him into a Default Specialist
; 2459 : 				if(IsWorkingPlot(pPlot))

	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN11@DoAlterWor
	cmp	BYTE PTR [eax+esi+25], 0
	je	SHORT $LN11@DoAlterWor

; 2460 : 				{
; 2461 : 					SetWorkingPlot(pPlot, false);

	push	1
	push	0
	push	edi
	mov	ecx, esi
	call	?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z ; CvCityCitizens::SetWorkingPlot

; 2462 : 					SetForcedWorkingPlot(pPlot, false);

	push	0
	push	edi
	mov	ecx, esi
	call	?SetForcedWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N@Z ; CvCityCitizens::SetForcedWorkingPlot

; 2463 : 					ChangeNumDefaultSpecialists(1);

	push	1
	mov	ecx, esi
	call	?ChangeNumDefaultSpecialists@CvCityCitizens@@QAEXH@Z ; CvCityCitizens::ChangeNumDefaultSpecialists

; 2464 : 					ChangeNumForcedDefaultSpecialists(1);

	inc	DWORD PTR [esi+104]
	pop	edi
	pop	esi

; 2528 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2529 : 				if (pOldWorkingCityOverride)
; 2530 : 					pOldWorkingCityOverride->GetCityCitizens()->DoSelfConsistencyCheck();
; 2531 : #endif
; 2532 : 			}
; 2533 : 		}
; 2534 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2535 : 		DoSelfConsistencyCheck();
; 2536 : #endif
; 2537 : 	}
; 2538 : }

	ret	4
$LN11@DoAlterWor:

; 2465 : 				}
; 2466 : 				// Player picked a new Plot to work
; 2467 : 				else
; 2468 : 				{
; 2469 : 					// Pull from the Default Specialist pool, if possible
; 2470 : 					if(GetNumDefaultSpecialists() > 0)

	cmp	DWORD PTR [esi+100], 0

; 2471 : 					{
; 2472 : 						ChangeNumDefaultSpecialists(-1);

	push	-1
	mov	ecx, esi
	jle	SHORT $LN9@DoAlterWor
	call	?ChangeNumDefaultSpecialists@CvCityCitizens@@QAEXH@Z ; CvCityCitizens::ChangeNumDefaultSpecialists

; 2473 : 						// Player is forcibly telling city to work a plot, so reduce count of forced default specialists
; 2474 : 						if(GetNumForcedDefaultSpecialists() > 0)

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jle	SHORT $LN87@DoAlterWor

; 2475 : 							ChangeNumForcedDefaultSpecialists(-1);

	dec	eax
	mov	DWORD PTR [esi+104], eax

; 2476 : 
; 2477 : 						SetWorkingPlot(pPlot, true);
; 2478 : 						SetForcedWorkingPlot(pPlot, true);
; 2479 : 					}
; 2480 : 					// No Default Specialists, so grab a better allocated guy
; 2481 : 					else

	jmp	SHORT $LN87@DoAlterWor
$LN9@DoAlterWor:

; 2482 : 					{
; 2483 : 						// Working Plot
; 2484 : 						if(DoRemoveWorstCitizen(true))

	push	-1
	push	1
	call	?DoRemoveWorstCitizen@CvCityCitizens@@QAE_N_NW4SpecialistTypes@@H@Z ; CvCityCitizens::DoRemoveWorstCitizen
	test	al, al
	je	SHORT $LN3@DoAlterWor

; 2475 : 							ChangeNumForcedDefaultSpecialists(-1);

$LN87@DoAlterWor:

; 2485 : 						{
; 2486 : 							SetWorkingPlot(pPlot, true);

	push	1
	push	1
	push	edi
	mov	ecx, esi
	call	?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z ; CvCityCitizens::SetWorkingPlot

; 2487 : 							SetForcedWorkingPlot(pPlot, true);

	push	1
	push	edi
	mov	ecx, esi
	call	?SetForcedWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N@Z ; CvCityCitizens::SetForcedWorkingPlot
	pop	edi
	pop	esi

; 2528 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2529 : 				if (pOldWorkingCityOverride)
; 2530 : 					pOldWorkingCityOverride->GetCityCitizens()->DoSelfConsistencyCheck();
; 2531 : #endif
; 2532 : 			}
; 2533 : 		}
; 2534 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2535 : 		DoSelfConsistencyCheck();
; 2536 : #endif
; 2537 : 	}
; 2538 : }

	ret	4
$LN12@DoAlterWor:

; 2488 : 							//ChangeNumUnassignedCitizens(-1);
; 2489 : 						}
; 2490 : 						// Good Specialist
; 2491 : 						else
; 2492 : 						{
; 2493 : 							CvAssert(false);
; 2494 : 						}
; 2495 : 					}
; 2496 : 					//if ((GetCity()->extraSpecialists() > 0) || GetCity()->AI_removeWorstCitizen())
; 2497 : 					//{
; 2498 : 					//	SetWorkingPlot(pPlot, true);
; 2499 : 					//}
; 2500 : 				}
; 2501 : 			}
; 2502 : 			// JON: Need to update this block to work with new system
; 2503 : #ifdef AUI_CITIZENS_FIX_LOCKED_TILES_BLOCKED
; 2504 : 			else if ((pPlot->getOwner() == GetOwner()) && pPlot->getWorkingCityOverride() != GetCity())
; 2505 : #else
; 2506 : 			else if(pPlot->getOwner() == GetOwner())

	movsx	ecx, BYTE PTR [edi+4]
	mov	edx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [edx+84]
	jne	SHORT $LN3@DoAlterWor

; 2507 : #endif
; 2508 : 			{
; 2509 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2510 : 				CvCity* pOldWorkingCityOverride = pPlot->getWorkingCityOverride();
; 2511 : 				if (pOldWorkingCityOverride != NULL)
; 2512 : 				{
; 2513 : 					if (pOldWorkingCityOverride->IsPuppet())
; 2514 : 					{
; 2515 : 						return;
; 2516 : #else
; 2517 : 				// Can't take away forced plots from puppet Cities
; 2518 : 				if(pPlot->getWorkingCityOverride() != NULL)

	mov	ecx, edi
	call	?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCityOverride
	test	eax, eax
	je	SHORT $LN1@DoAlterWor

; 2519 : 				{
; 2520 : 					if(pPlot->getWorkingCityOverride()->IsPuppet())

	mov	ecx, edi
	call	?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCityOverride
	mov	ecx, eax
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	test	al, al
	jne	SHORT $LN3@DoAlterWor
$LN1@DoAlterWor:

; 2521 : 					{
; 2522 : 						return;
; 2523 : #endif
; 2524 : 					}
; 2525 : 				}
; 2526 : 
; 2527 : 				pPlot->setWorkingCityOverride(GetCity());

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	ecx, edi
	call	?setWorkingCityOverride@CvPlot@@QAEXPBVCvCity@@@Z ; CvPlot::setWorkingCityOverride
$LN3@DoAlterWor:
	pop	edi
	pop	esi

; 2528 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2529 : 				if (pOldWorkingCityOverride)
; 2530 : 					pOldWorkingCityOverride->GetCityCitizens()->DoSelfConsistencyCheck();
; 2531 : #endif
; 2532 : 			}
; 2533 : 		}
; 2534 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2535 : 		DoSelfConsistencyCheck();
; 2536 : #endif
; 2537 : 	}
; 2538 : }

	ret	4
?DoAlterWorkingPlot@CvCityCitizens@@QAEXH@Z ENDP	; CvCityCitizens::DoAlterWorkingPlot
_TEXT	ENDS
PUBLIC	?DoVerifyWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@@Z ; CvCityCitizens::DoVerifyWorkingPlot
; Function compile flags: /Ogtpy
;	COMDAT ?DoVerifyWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?DoVerifyWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@@Z PROC ; CvCityCitizens::DoVerifyWorkingPlot, COMDAT
; _this$ = ecx

; 2846 : {

	push	esi
	push	edi

; 2847 : #endif
; 2848 : 	if(pPlot != NULL)

	mov	edi, DWORD PTR _pPlot$[esp+4]
	mov	esi, ecx
	test	edi, edi
	je	SHORT $LN1@DoVerifyWo

; 2849 : 	{
; 2850 : 		if(IsWorkingPlot(pPlot))

	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN1@DoVerifyWo
	cmp	BYTE PTR [eax+esi+25], 0
	je	SHORT $LN1@DoVerifyWo

; 2851 : 		{
; 2852 : 			if(!IsCanWork(pPlot))

	push	edi
	mov	ecx, esi
	call	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsCanWork
	test	al, al
	jne	SHORT $LN1@DoVerifyWo

; 2853 : 			{
; 2854 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2855 : 				bRet = true;
; 2856 : #endif
; 2857 : 				SetWorkingPlot(pPlot, false);

	push	1
	push	0
	push	edi
	mov	ecx, esi
	call	?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z ; CvCityCitizens::SetWorkingPlot

; 2858 : 				DoAddBestCitizenFromUnassigned();

	mov	ecx, esi
	call	?DoAddBestCitizenFromUnassigned@CvCityCitizens@@QAE_NXZ ; CvCityCitizens::DoAddBestCitizenFromUnassigned
$LN1@DoVerifyWo:
	pop	edi
	pop	esi

; 2859 : 			}
; 2860 : 		}
; 2861 : 	}
; 2862 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2863 : 	return bRet;
; 2864 : #endif
; 2865 : }

	ret	4
?DoVerifyWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@@Z ENDP ; CvCityCitizens::DoVerifyWorkingPlot
_TEXT	ENDS
PUBLIC	?DoVerifyWorkingPlots@CvCityCitizens@@QAEXXZ	; CvCityCitizens::DoVerifyWorkingPlots
; Function compile flags: /Ogtpy
;	COMDAT ?DoVerifyWorkingPlots@CvCityCitizens@@QAEXXZ
_TEXT	SEGMENT
?DoVerifyWorkingPlots@CvCityCitizens@@QAEXXZ PROC	; CvCityCitizens::DoVerifyWorkingPlots, COMDAT
; _this$ = ecx

; 2869 : {

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 2870 : 	int iI;
; 2871 : 	CvPlot* pPlot;
; 2872 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2873 : 	bool bDoSelfConsistency = false;
; 2874 : #endif
; 2875 : 
; 2876 : 	for(iI = 0; iI < NUM_CITY_PLOTS; iI++)

	xor	ebx, ebx
$LL3@DoVerifyWo@2:

; 2877 : 	{
; 2878 : 		pPlot = GetCityPlotFromIndex(iI);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	ebx
	push	ecx
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 2879 : 
; 2880 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2881 : 		bDoSelfConsistency = DoVerifyWorkingPlot(pPlot) || bDoSelfConsistency;
; 2882 : #else
; 2883 : 		DoVerifyWorkingPlot(pPlot);

	test	edi, edi
	je	SHORT $LN2@DoVerifyWo@2
	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	call	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ; plotCityXY
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN2@DoVerifyWo@2
	cmp	BYTE PTR [eax+esi+25], 0
	je	SHORT $LN2@DoVerifyWo@2
	push	edi
	mov	ecx, esi
	call	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsCanWork
	test	al, al
	jne	SHORT $LN2@DoVerifyWo@2
	push	1
	push	0
	push	edi
	mov	ecx, esi
	call	?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z ; CvCityCitizens::SetWorkingPlot
	mov	ecx, esi
	call	?DoAddBestCitizenFromUnassigned@CvCityCitizens@@QAE_NXZ ; CvCityCitizens::DoAddBestCitizenFromUnassigned
$LN2@DoVerifyWo@2:
	inc	ebx
	cmp	ebx, 37					; 00000025H
	jl	SHORT $LL3@DoVerifyWo@2
	pop	edi
	pop	esi
	pop	ebx

; 2884 : #endif
; 2885 : 	}
; 2886 : 
; 2887 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 2888 : 	if (bDoSelfConsistency)
; 2889 : 		DoSelfConsistencyCheck();
; 2890 : #endif
; 2891 : }

	ret	0
?DoVerifyWorkingPlots@CvCityCitizens@@QAEXXZ ENDP	; CvCityCitizens::DoVerifyWorkingPlots
_TEXT	ENDS
PUBLIC	?SetNoAutoAssignSpecialists@CvCityCitizens@@QAEX_N@Z ; CvCityCitizens::SetNoAutoAssignSpecialists
; Function compile flags: /Ogtpy
;	COMDAT ?SetNoAutoAssignSpecialists@CvCityCitizens@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetNoAutoAssignSpecialists@CvCityCitizens@@QAEX_N@Z PROC ; CvCityCitizens::SetNoAutoAssignSpecialists, COMDAT
; _this$ = ecx

; 749  : 	if(m_bNoAutoAssignSpecialists != bValue)

	mov	al, BYTE PTR _bValue$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	BYTE PTR [esi+5], al
	je	SHORT $LN2@SetNoAutoA

; 750  : 	{
; 751  : 		m_bNoAutoAssignSpecialists = bValue;

	mov	BYTE PTR [esi+5], al

; 752  : 
; 753  : 		// If we're giving the AI control clear all manually assigned Specialists
; 754  : 		if(!bValue)

	test	al, al
	jne	SHORT $LN1@SetNoAutoA

; 755  : 		{
; 756  : 			DoClearForcedSpecialists();

	call	?DoClearForcedSpecialists@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoClearForcedSpecialists
$LN1@SetNoAutoA:

; 757  : 		}
; 758  : 
; 759  : 		DoReallocateCitizens();

	mov	ecx, esi
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN2@SetNoAutoA:
	pop	esi

; 760  : 	}
; 761  : }

	ret	4
?SetNoAutoAssignSpecialists@CvCityCitizens@@QAEX_N@Z ENDP ; CvCityCitizens::SetNoAutoAssignSpecialists
_TEXT	ENDS
PUBLIC	?SetForcedAvoidGrowth@CvCityCitizens@@QAEX_N@Z	; CvCityCitizens::SetForcedAvoidGrowth
; Function compile flags: /Ogtpy
;	COMDAT ?SetForcedAvoidGrowth@CvCityCitizens@@QAEX_N@Z
_TEXT	SEGMENT
_bAvoidGrowth$ = 8					; size = 1
?SetForcedAvoidGrowth@CvCityCitizens@@QAEX_N@Z PROC	; CvCityCitizens::SetForcedAvoidGrowth, COMDAT
; _this$ = ecx

; 844  : 	if(m_bForceAvoidGrowth != bAvoidGrowth)

	mov	al, BYTE PTR _bAvoidGrowth$[esp-4]
	cmp	BYTE PTR [ecx+24], al
	je	SHORT $LN1@SetForcedA

; 845  : 	{
; 846  : 		m_bForceAvoidGrowth = bAvoidGrowth;

	mov	BYTE PTR [ecx+24], al

; 847  : 		DoReallocateCitizens();

	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN1@SetForcedA:

; 848  : 	}
; 849  : }

	ret	4
?SetForcedAvoidGrowth@CvCityCitizens@@QAEX_N@Z ENDP	; CvCityCitizens::SetForcedAvoidGrowth
_TEXT	ENDS
PUBLIC	?SetFocusType@CvCityCitizens@@QAEXW4CityAIFocusTypes@@@Z ; CvCityCitizens::SetFocusType
; Function compile flags: /Ogtpy
;	COMDAT ?SetFocusType@CvCityCitizens@@QAEXW4CityAIFocusTypes@@@Z
_TEXT	SEGMENT
_eFocus$ = 8						; size = 4
?SetFocusType@CvCityCitizens@@QAEXW4CityAIFocusTypes@@@Z PROC ; CvCityCitizens::SetFocusType, COMDAT
; _this$ = ecx

; 860  : 	FAssert(eFocus >= NO_CITY_AI_FOCUS_TYPE);
; 861  : 	FAssert(eFocus < NUM_CITY_AI_FOCUS_TYPES);
; 862  : 
; 863  : 	if(eFocus != m_eCityAIFocusTypes)

	mov	eax, DWORD PTR _eFocus$[esp-4]
	cmp	eax, DWORD PTR [ecx+20]
	je	SHORT $LN1@SetFocusTy

; 864  : 	{
; 865  : 		m_eCityAIFocusTypes = eFocus;

	mov	DWORD PTR [ecx+20], eax

; 866  : 		// Reallocate with our new focus
; 867  : 		DoReallocateCitizens();

	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN1@SetFocusTy:

; 868  : 	}
; 869  : }

	ret	4
?SetFocusType@CvCityCitizens@@QAEXW4CityAIFocusTypes@@@Z ENDP ; CvCityCitizens::SetFocusType
_TEXT	ENDS
PUBLIC	?DoTurn@CvCityCitizens@@QAEXXZ			; CvCityCitizens::DoTurn
EXTRN	?GetYieldType@CvCitySpecializationXMLEntry@@QBE?AW4YieldTypes@@XZ:PROC ; CvCitySpecializationXMLEntry::GetYieldType
EXTRN	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z:PROC ; CvGlobals::getCitySpecializationInfo
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z:PROC ; CvEconomicAI::IsUsingStrategy
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?GetWonderSpecialization@CvCitySpecializationAI@@QBE?AW4CitySpecializationTypes@@XZ:PROC ; CvCitySpecializationAI::GetWonderSpecialization
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
; Function compile flags: /Ogtpy
;	COMDAT ?DoTurn@CvCityCitizens@@QAEXXZ
_TEXT	SEGMENT
?DoTurn@CvCityCitizens@@QAEXXZ PROC			; CvCityCitizens::DoTurn, COMDAT
; _this$ = ecx

; 281  : {

	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 282  : 	AI_PERF_FORMAT("City-AI-perf.csv", ("CvCityCitizens::DoTurn, Turn %03d, %s, %s", GC.getGame().getElapsedGameTurns(), m_pCity->GetPlayer()->getCivilizationShortDescription(), m_pCity->getName().c_str()) );
; 283  : 	DoVerifyWorkingPlots();

	call	?DoVerifyWorkingPlots@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoVerifyWorkingPlots

; 284  : 
; 285  : 	CvPlayerAI& thisPlayer = GET_PLAYER(GetOwner());

	mov	ecx, DWORD PTR [esi]
	mov	ebp, DWORD PTR [ecx+84]
	imul	ebp, 63236				; 0000f704H
	add	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 286  : 
; 287  : 	if(m_pCity->IsPuppet())

	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	test	al, al
	je	$LN34@DoTurn

; 288  : 	{
; 289  : 		SetFocusType(CITY_AI_FOCUS_TYPE_GOLD);

	mov	ecx, 2
	cmp	DWORD PTR [esi+20], ecx
	je	SHORT $LN45@DoTurn
	mov	DWORD PTR [esi+20], ecx
	mov	ecx, esi
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN45@DoTurn:

; 290  : 		SetNoAutoAssignSpecialists(false);

	cmp	BYTE PTR [esi+5], 0
	je	SHORT $LN49@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+5], 0
	call	?DoClearForcedSpecialists@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoClearForcedSpecialists
	mov	ecx, esi
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN49@DoTurn:

; 291  : 		SetForcedAvoidGrowth(false);

	cmp	BYTE PTR [esi+24], 0
	je	SHORT $LN52@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+24], 0
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN52@DoTurn:

; 292  : #ifndef AUI_CITIZENS_PUPPET_STILL_WANTS_GROWTH
; 293  : 		int iExcessFoodTimes100 = m_pCity->getYieldRateTimes100(YIELD_FOOD, false) - (m_pCity->foodConsumption() * 100);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	call	?foodConsumption@CvCity@@QBEH_NH@Z	; CvCity::foodConsumption
	mov	ecx, DWORD PTR [esi]
	push	0
	mov	edi, eax
	push	0
	imul	edi, 100				; 00000064H
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	sub	eax, edi

; 294  : 		if(iExcessFoodTimes100 < 0)

	jns	$LN176@DoTurn

; 295  : 		{
; 296  : 			SetFocusType(NO_CITY_AI_FOCUS_TYPE);

	or	eax, -1
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN55@DoTurn
	mov	ecx, esi
	mov	DWORD PTR [esi+20], eax
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN55@DoTurn:

; 297  : 			//SetNoAutoAssignSpecialists(true);
; 298  : 			SetForcedAvoidGrowth(false);

	cmp	BYTE PTR [esi+24], 0
	je	$LN176@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+24], 0
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens

; 435  : 				}
; 436  : 			}
; 437  : 		}
; 438  : 	}
; 439  : 
; 440  : 	CvAssertMsg((GetNumCitizensWorkingPlots() + GetTotalSpecialistCount() + GetNumUnassignedCitizens()) <= GetCity()->getPopulation(), "Gameplay: More workers than population in the city.");
; 441  : 	DoReallocateCitizens();

	mov	ecx, esi
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
	pop	edi

; 442  : 	CvAssertMsg((GetNumCitizensWorkingPlots() + GetTotalSpecialistCount() + GetNumUnassignedCitizens()) <= GetCity()->getPopulation(), "Gameplay: More workers than population in the city.");
; 443  : 	DoSpecialists();

	mov	ecx, esi
	pop	esi
	pop	ebp
	jmp	?DoSpecialists@CvCityCitizens@@QAEXXZ	; CvCityCitizens::DoSpecialists
$LN34@DoTurn:

; 299  : 		}
; 300  : #endif
; 301  : 	}
; 302  : 	else if(!thisPlayer.isHuman())

	mov	ecx, ebp
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	$LN176@DoTurn
	push	ebx

; 303  : 	{
; 304  : 		CitySpecializationTypes eWonderSpecializationType = thisPlayer.GetCitySpecializationAI()->GetWonderSpecialization();

	mov	ecx, ebp
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?GetWonderSpecialization@CvCitySpecializationAI@@QBE?AW4CitySpecializationTypes@@XZ ; CvCitySpecializationAI::GetWonderSpecialization

; 305  : 
; 306  : 		if(GC.getGame().getGameTurn() % 8 == 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN183@DoTurn
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN183@DoTurn:
	jne	SHORT $LN73@DoTurn

; 307  : 		{
; 308  : 			SetFocusType(CITY_AI_FOCUS_TYPE_GOLD_GROWTH);

	mov	eax, 7
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN63@DoTurn
	mov	ecx, esi
	mov	DWORD PTR [esi+20], eax
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN63@DoTurn:

; 309  : 			SetNoAutoAssignSpecialists(true);

	cmp	BYTE PTR [esi+5], 1
	je	SHORT $LN67@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+5], 1
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN67@DoTurn:

; 310  : 			SetForcedAvoidGrowth(false);

	cmp	BYTE PTR [esi+24], 0
	je	SHORT $LN70@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+24], 0
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN70@DoTurn:

; 311  : 			int iExcessFoodTimes100 = m_pCity->getYieldRateTimes100(YIELD_FOOD, false) - (m_pCity->foodConsumption() * 100);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	call	?foodConsumption@CvCity@@QBEH_NH@Z	; CvCity::foodConsumption
	mov	ecx, DWORD PTR [esi]
	push	0
	mov	edi, eax
	push	0
	imul	edi, 100				; 00000064H
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	sub	eax, edi

; 312  : 			if(iExcessFoodTimes100 < 200)

	cmp	eax, 200				; 000000c8H
	jge	SHORT $LN73@DoTurn

; 313  : 			{
; 314  : 				SetFocusType(NO_CITY_AI_FOCUS_TYPE);

	or	eax, -1
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN73@DoTurn
	mov	ecx, esi
	mov	DWORD PTR [esi+20], eax
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN73@DoTurn:

; 315  : 				//SetNoAutoAssignSpecialists(true);
; 316  : 			}
; 317  : 		}
; 318  : 		if(m_pCity->isCapital() && !thisPlayer.isMinorCiv() && m_pCity->GetCityStrategyAI()->GetSpecialization() != eWonderSpecializationType)

	mov	ecx, DWORD PTR [esi]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	$LN28@DoTurn
	mov	ecx, ebp
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN28@DoTurn
	mov	ecx, DWORD PTR [esi]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	cmp	DWORD PTR [eax+20], ebx
	je	SHORT $LN28@DoTurn

; 319  : 		{
; 320  : 			SetFocusType(NO_CITY_AI_FOCUS_TYPE);

	or	eax, -1
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN78@DoTurn
	mov	ecx, esi
	mov	DWORD PTR [esi+20], eax
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN78@DoTurn:

; 321  : 			SetNoAutoAssignSpecialists(false);

	cmp	BYTE PTR [esi+5], 0
	je	SHORT $LN82@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+5], 0
	call	?DoClearForcedSpecialists@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoClearForcedSpecialists
	mov	ecx, esi
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN82@DoTurn:

; 322  : 			SetForcedAvoidGrowth(false);

	cmp	BYTE PTR [esi+24], 0
	je	SHORT $LN85@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+24], 0
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN85@DoTurn:

; 323  : 			int iExcessFoodTimes100 = m_pCity->getYieldRateTimes100(YIELD_FOOD, false) - (m_pCity->foodConsumption() * 100);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	call	?foodConsumption@CvCity@@QBEH_NH@Z	; CvCity::foodConsumption
	mov	ecx, DWORD PTR [esi]
	push	0
	mov	edi, eax
	push	0
	imul	edi, 100				; 00000064H
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	sub	eax, edi

; 324  : 			if(iExcessFoodTimes100 < 400)

	cmp	eax, 400				; 00000190H
	jge	$LN181@DoTurn
$LN187@DoTurn:

; 325  : 			{
; 326  : 				SetFocusType(CITY_AI_FOCUS_TYPE_FOOD);

	cmp	DWORD PTR [esi+20], 0
	je	$LN181@DoTurn
	mov	DWORD PTR [esi+20], 0

; 327  : 				//SetNoAutoAssignSpecialists(true);
; 328  : 			}
; 329  : 		}

	jmp	$LN185@DoTurn
$LN28@DoTurn:

; 330  : 		else if(m_pCity->GetCityStrategyAI()->GetSpecialization() == eWonderSpecializationType)

	mov	ecx, DWORD PTR [esi]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	cmp	DWORD PTR [eax+20], ebx
	jne	$LN25@DoTurn

; 331  : 		{
; 332  : 			SetFocusType(CITY_AI_FOCUS_TYPE_PRODUCTION);

	mov	eax, 1
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN93@DoTurn
	mov	ecx, esi
	mov	DWORD PTR [esi+20], eax
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN93@DoTurn:

; 333  : 			SetNoAutoAssignSpecialists(false);

	cmp	BYTE PTR [esi+5], 0
	je	SHORT $LN97@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+5], 0
	call	?DoClearForcedSpecialists@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoClearForcedSpecialists
	mov	ecx, esi
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN97@DoTurn:

; 334  : 			//SetForcedAvoidGrowth(true);
; 335  : 			int iExcessFoodTimes100;// = m_pCity->getYieldRateTimes100(YIELD_FOOD) - (m_pCity->foodConsumption() * 100);
; 336  : 			//if (iExcessFoodTimes100 < 200)
; 337  : 			//{
; 338  : 			SetForcedAvoidGrowth(false);

	cmp	BYTE PTR [esi+24], 0
	je	SHORT $LN100@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+24], 0
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN100@DoTurn:

; 339  : 			//}
; 340  : 			iExcessFoodTimes100 = m_pCity->getYieldRateTimes100(YIELD_FOOD, false) - (m_pCity->foodConsumption() * 100);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	call	?foodConsumption@CvCity@@QBEH_NH@Z	; CvCity::foodConsumption
	mov	ecx, DWORD PTR [esi]
	push	0
	mov	edi, eax
	push	0
	imul	edi, 100				; 00000064H
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	sub	eax, edi

; 341  : 			if(iExcessFoodTimes100 < 200)

	cmp	eax, 200				; 000000c8H
	jge	SHORT $LN106@DoTurn

; 342  : 			{
; 343  : 				SetFocusType(CITY_AI_FOCUS_TYPE_PROD_GROWTH);

	mov	eax, 6
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN103@DoTurn
	mov	ecx, esi
	mov	DWORD PTR [esi+20], eax
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN103@DoTurn:

; 344  : 				//SetNoAutoAssignSpecialists(true);
; 345  : 				SetForcedAvoidGrowth(false);

	cmp	BYTE PTR [esi+24], 0
	je	SHORT $LN106@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+24], 0
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN106@DoTurn:

; 346  : 			}
; 347  : 			iExcessFoodTimes100 = m_pCity->getYieldRateTimes100(YIELD_FOOD, false) - (m_pCity->foodConsumption() * 100);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	call	?foodConsumption@CvCity@@QBEH_NH@Z	; CvCity::foodConsumption
	mov	ecx, DWORD PTR [esi]
	push	0
	mov	edi, eax
	push	0
	imul	edi, 100				; 00000064H
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	sub	eax, edi

; 348  : 			if(iExcessFoodTimes100 < 200)

	cmp	eax, 200				; 000000c8H
	jge	$LN181@DoTurn

; 349  : 			{
; 350  : 				SetFocusType(NO_CITY_AI_FOCUS_TYPE);

	or	eax, -1
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN109@DoTurn
	mov	ecx, esi
	mov	DWORD PTR [esi+20], eax
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN109@DoTurn:

; 351  : 				//SetNoAutoAssignSpecialists(true);
; 352  : 				SetForcedAvoidGrowth(false);

	cmp	BYTE PTR [esi+24], 0
	je	$LN181@DoTurn
	mov	BYTE PTR [esi+24], 0

; 353  : 			}
; 354  : 		}

	jmp	$LN185@DoTurn
$LN25@DoTurn:

; 355  : 		else if(m_pCity->getPopulation() < 5)  // we want a balanced growth

	mov	ecx, DWORD PTR [esi]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	edi, 5
	cmp	eax, edi
	jge	SHORT $LN21@DoTurn

; 356  : 		{
; 357  : 			SetFocusType(NO_CITY_AI_FOCUS_TYPE);

	or	eax, -1
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN115@DoTurn
	mov	ecx, esi
	mov	DWORD PTR [esi+20], eax
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN115@DoTurn:

; 358  : 			//SetNoAutoAssignSpecialists(true);
; 359  : 			SetForcedAvoidGrowth(false);

	cmp	BYTE PTR [esi+24], 0
	je	$LN181@DoTurn
	mov	BYTE PTR [esi+24], 0

; 360  : 		}
; 361  : 		else

	jmp	$LN185@DoTurn
$LN21@DoTurn:

; 362  : 		{
; 363  : 			// Are we running at a deficit?
; 364  : 			EconomicAIStrategyTypes eStrategyLosingMoney = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_LOSING_MONEY", true);

	push	1
	push	OFFSET $SG225437
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 365  : 			bool bInDeficit = false;
; 366  : 			if (eStrategyLosingMoney != NO_ECONOMICAISTRATEGY)

	or	ebx, -1
	cmp	eax, ebx
	je	$LN18@DoTurn

; 367  : 			{
; 368  : 				bInDeficit = thisPlayer.GetEconomicAI()->IsUsingStrategy(eStrategyLosingMoney);

	push	eax
	mov	ecx, ebp
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy

; 369  : 			}
; 370  : 
; 371  : 			if(bInDeficit)

	test	al, al
	je	SHORT $LN18@DoTurn

; 372  : 			{
; 373  : 				SetFocusType(CITY_AI_FOCUS_TYPE_GOLD_GROWTH);

	mov	eax, 7
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN121@DoTurn
	mov	ecx, esi
	mov	DWORD PTR [esi+20], eax
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN121@DoTurn:

; 374  : 				SetNoAutoAssignSpecialists(false);

	cmp	BYTE PTR [esi+5], 0
	je	SHORT $LN125@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+5], 0
	call	?DoClearForcedSpecialists@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoClearForcedSpecialists
$LN191@DoTurn:
	mov	ecx, esi
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN125@DoTurn:

; 375  : 				SetForcedAvoidGrowth(false);

	cmp	BYTE PTR [esi+24], 0
	je	SHORT $LN128@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+24], 0
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN128@DoTurn:

; 376  : 				int iExcessFoodTimes100 = m_pCity->getYieldRateTimes100(YIELD_FOOD, false) - (m_pCity->foodConsumption() * 100);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	call	?foodConsumption@CvCity@@QBEH_NH@Z	; CvCity::foodConsumption
	mov	ecx, DWORD PTR [esi]
	push	0
	mov	edi, eax
	push	0
	imul	edi, 100				; 00000064H
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	sub	eax, edi

; 377  : 				if(iExcessFoodTimes100 < 200)

	cmp	eax, 200				; 000000c8H
	jge	$LN181@DoTurn

; 378  : 				{
; 379  : 					SetFocusType(NO_CITY_AI_FOCUS_TYPE);

	or	eax, -1
$LN189@DoTurn:
	cmp	DWORD PTR [esi+20], eax
	je	$LN181@DoTurn
	mov	DWORD PTR [esi+20], eax

; 380  : 					//SetNoAutoAssignSpecialists(true);
; 381  : 				}
; 382  : 			}

	jmp	$LN185@DoTurn
$LN18@DoTurn:

; 383  : 			else if(GC.getGame().getGameTurn() % 3 == 0 && thisPlayer.GetGrandStrategyAI()->GetActiveGrandStrategy() == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE"))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cdq
	mov	ecx, 3
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN179@DoTurn
	mov	ecx, ebp
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	push	0
	push	OFFSET $SG225446
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebp, eax
	jne	SHORT $LN179@DoTurn

; 384  : 			{
; 385  : 				SetFocusType(CITY_AI_FOCUS_TYPE_CULTURE);

	cmp	DWORD PTR [esi+20], edi
	je	SHORT $LN136@DoTurn
	mov	ecx, esi
	mov	DWORD PTR [esi+20], edi
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN136@DoTurn:

; 386  : 				SetNoAutoAssignSpecialists(true);

	cmp	BYTE PTR [esi+5], 1
	je	$LN125@DoTurn
	mov	BYTE PTR [esi+5], 1

; 387  : 				SetForcedAvoidGrowth(false);
; 388  : 				int iExcessFoodTimes100 = m_pCity->getYieldRateTimes100(YIELD_FOOD, false) - (m_pCity->foodConsumption() * 100);
; 389  : 				if(iExcessFoodTimes100 < 200)
; 390  : 				{
; 391  : 					SetFocusType(NO_CITY_AI_FOCUS_TYPE);
; 392  : 					//SetNoAutoAssignSpecialists(true);
; 393  : 				}
; 394  : 			}
; 395  : 			else // we aren't a small city, building a wonder, or going broke

	jmp	$LN191@DoTurn
$LN179@DoTurn:

; 396  : 			{
; 397  : 				SetNoAutoAssignSpecialists(false);

	cmp	BYTE PTR [esi+5], 0
	je	SHORT $LN150@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+5], 0
	call	?DoClearForcedSpecialists@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoClearForcedSpecialists
	mov	ecx, esi
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN150@DoTurn:

; 398  : 				SetForcedAvoidGrowth(false);

	cmp	BYTE PTR [esi+24], 0
	je	SHORT $LN153@DoTurn
	mov	ecx, esi
	mov	BYTE PTR [esi+24], 0
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN153@DoTurn:

; 399  : 				CitySpecializationTypes eSpecialization = m_pCity->GetCityStrategyAI()->GetSpecialization();

	mov	ecx, DWORD PTR [esi]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	eax, DWORD PTR [eax+20]

; 400  : 				if(eSpecialization != -1)

	cmp	eax, ebx
	je	SHORT $LN12@DoTurn

; 401  : 				{
; 402  : 					CvCitySpecializationXMLEntry* pCitySpecializationEntry =  GC.getCitySpecializationInfo(eSpecialization);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z ; CvGlobals::getCitySpecializationInfo

; 403  : 					if(pCitySpecializationEntry)

	test	eax, eax
	je	SHORT $LN12@DoTurn

; 404  : 					{
; 405  : 						YieldTypes eYield = pCitySpecializationEntry->GetYieldType();

	mov	ecx, eax
	call	?GetYieldType@CvCitySpecializationXMLEntry@@QBE?AW4YieldTypes@@XZ ; CvCitySpecializationXMLEntry::GetYieldType

; 406  : 						if(eYield == YIELD_FOOD)

	test	eax, eax

; 407  : 						{
; 408  : 							SetFocusType(CITY_AI_FOCUS_TYPE_FOOD);

	je	$LN187@DoTurn

; 409  : 						}
; 410  : 						else if(eYield == YIELD_PRODUCTION)

	cmp	eax, 1
	jne	SHORT $LN8@DoTurn

; 411  : 						{
; 412  : 							SetFocusType(CITY_AI_FOCUS_TYPE_PROD_GROWTH);

	mov	eax, 6
	jmp	$LN189@DoTurn
$LN8@DoTurn:

; 413  : 						}
; 414  : 						else if(eYield == YIELD_GOLD)

	mov	ecx, 2
	cmp	eax, ecx
	jne	SHORT $LN6@DoTurn

; 415  : 						{
; 416  : 							SetFocusType(CITY_AI_FOCUS_TYPE_GOLD);

	cmp	DWORD PTR [esi+20], ecx
	je	SHORT $LN181@DoTurn
	mov	DWORD PTR [esi+20], ecx
	jmp	SHORT $LN185@DoTurn
$LN6@DoTurn:

; 417  : 						}
; 418  : 						else if(eYield == YIELD_SCIENCE)

	cmp	eax, 3
	jne	SHORT $LN12@DoTurn

; 419  : 						{
; 420  : 							SetFocusType(CITY_AI_FOCUS_TYPE_SCIENCE);

	mov	eax, 4

; 421  : 						}
; 422  : 						else

	jmp	$LN189@DoTurn
$LN12@DoTurn:

; 423  : 						{
; 424  : 							SetFocusType(NO_CITY_AI_FOCUS_TYPE);
; 425  : 						}
; 426  : 					}
; 427  : 					else
; 428  : 					{
; 429  : 						SetFocusType(NO_CITY_AI_FOCUS_TYPE);
; 430  : 					}
; 431  : 				}
; 432  : 				else
; 433  : 				{
; 434  : 					SetFocusType(NO_CITY_AI_FOCUS_TYPE);

	cmp	DWORD PTR [esi+20], ebx
	je	SHORT $LN181@DoTurn
	mov	DWORD PTR [esi+20], ebx
$LN185@DoTurn:
	mov	ecx, esi
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
$LN181@DoTurn:
	pop	ebx
$LN176@DoTurn:

; 435  : 				}
; 436  : 			}
; 437  : 		}
; 438  : 	}
; 439  : 
; 440  : 	CvAssertMsg((GetNumCitizensWorkingPlots() + GetTotalSpecialistCount() + GetNumUnassignedCitizens()) <= GetCity()->getPopulation(), "Gameplay: More workers than population in the city.");
; 441  : 	DoReallocateCitizens();

	mov	ecx, esi
	call	?DoReallocateCitizens@CvCityCitizens@@QAEXXZ ; CvCityCitizens::DoReallocateCitizens
	pop	edi

; 442  : 	CvAssertMsg((GetNumCitizensWorkingPlots() + GetTotalSpecialistCount() + GetNumUnassignedCitizens()) <= GetCity()->getPopulation(), "Gameplay: More workers than population in the city.");
; 443  : 	DoSpecialists();

	mov	ecx, esi
	pop	esi
	pop	ebp
	jmp	?DoSpecialists@CvCityCitizens@@QAEXXZ	; CvCityCitizens::DoSpecialists
?DoTurn@CvCityCitizens@@QAEXXZ ENDP			; CvCityCitizens::DoTurn
_TEXT	ENDS
END
