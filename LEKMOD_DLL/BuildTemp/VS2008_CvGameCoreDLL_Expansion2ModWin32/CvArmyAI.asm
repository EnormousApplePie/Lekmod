; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	s:\Github\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvArmyAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	?GetID@CvArmyAI@@QAEHXZ				; CvArmyAI::GetID
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
;	COMDAT ?GetID@CvArmyAI@@QAEHXZ
_TEXT	SEGMENT
?GetID@CvArmyAI@@QAEHXZ PROC				; CvArmyAI::GetID, COMDAT
; _this$ = ecx

; 163  : 	return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 164  : }

	ret	0
?GetID@CvArmyAI@@QAEHXZ ENDP				; CvArmyAI::GetID
_TEXT	ENDS
PUBLIC	?SetID@CvArmyAI@@QAEXH@Z			; CvArmyAI::SetID
; Function compile flags: /Ogtpy
;	COMDAT ?SetID@CvArmyAI@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetID@CvArmyAI@@QAEXH@Z PROC				; CvArmyAI::SetID, COMDAT
; _this$ = ecx

; 169  : 	m_iID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 170  : }

	ret	4
?SetID@CvArmyAI@@QAEXH@Z ENDP				; CvArmyAI::SetID
_TEXT	ENDS
PUBLIC	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState
; Function compile flags: /Ogtpy
;	COMDAT ?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ
_TEXT	SEGMENT
?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ PROC	; CvArmyAI::GetArmyAIState, COMDAT
; _this$ = ecx

; 186  : 	return (ArmyAIState) m_eAIState;

	mov	eax, DWORD PTR [ecx+40]

; 187  : }

	ret	0
?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ENDP	; CvArmyAI::GetArmyAIState
_TEXT	ENDS
PUBLIC	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z	; CvArmyAI::SetArmyAIState
; Function compile flags: /Ogtpy
;	COMDAT ?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z
_TEXT	SEGMENT
_eNewArmyAIState$ = 8					; size = 4
?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z PROC	; CvArmyAI::SetArmyAIState, COMDAT
; _this$ = ecx

; 192  : 	m_eAIState = (int) eNewArmyAIState;

	mov	eax, DWORD PTR _eNewArmyAIState$[esp-4]
	mov	DWORD PTR [ecx+40], eax

; 193  : }

	ret	4
?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ENDP	; CvArmyAI::SetArmyAIState
_TEXT	ENDS
PUBLIC	?GetFormationIndex@CvArmyAI@@QBEHXZ		; CvArmyAI::GetFormationIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetFormationIndex@CvArmyAI@@QBEHXZ
_TEXT	SEGMENT
?GetFormationIndex@CvArmyAI@@QBEHXZ PROC		; CvArmyAI::GetFormationIndex, COMDAT
; _this$ = ecx

; 361  : 	return m_iFormationIndex;

	mov	eax, DWORD PTR [ecx+36]

; 362  : }

	ret	0
?GetFormationIndex@CvArmyAI@@QBEHXZ ENDP		; CvArmyAI::GetFormationIndex
_TEXT	ENDS
PUBLIC	?GetX@CvArmyAI@@QBEHXZ				; CvArmyAI::GetX
; Function compile flags: /Ogtpy
;	COMDAT ?GetX@CvArmyAI@@QBEHXZ
_TEXT	SEGMENT
?GetX@CvArmyAI@@QBEHXZ PROC				; CvArmyAI::GetX, COMDAT
; _this$ = ecx

; 548  : 	return m_iCurrentX;

	mov	eax, DWORD PTR [ecx+16]

; 549  : }

	ret	0
?GetX@CvArmyAI@@QBEHXZ ENDP				; CvArmyAI::GetX
_TEXT	ENDS
PUBLIC	?GetY@CvArmyAI@@QBEHXZ				; CvArmyAI::GetY
; Function compile flags: /Ogtpy
;	COMDAT ?GetY@CvArmyAI@@QBEHXZ
_TEXT	SEGMENT
?GetY@CvArmyAI@@QBEHXZ PROC				; CvArmyAI::GetY, COMDAT
; _this$ = ecx

; 554  : 	return m_iCurrentY;

	mov	eax, DWORD PTR [ecx+20]

; 555  : }

	ret	0
?GetY@CvArmyAI@@QBEHXZ ENDP				; CvArmyAI::GetY
_TEXT	ENDS
PUBLIC	?SetX@CvArmyAI@@QAEXH@Z				; CvArmyAI::SetX
; Function compile flags: /Ogtpy
;	COMDAT ?SetX@CvArmyAI@@QAEXH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
?SetX@CvArmyAI@@QAEXH@Z PROC				; CvArmyAI::SetX, COMDAT
; _this$ = ecx

; 560  : 	m_iCurrentX = iX;

	mov	eax, DWORD PTR _iX$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 561  : }

	ret	4
?SetX@CvArmyAI@@QAEXH@Z ENDP				; CvArmyAI::SetX
_TEXT	ENDS
PUBLIC	?SetY@CvArmyAI@@QAEXH@Z				; CvArmyAI::SetY
; Function compile flags: /Ogtpy
;	COMDAT ?SetY@CvArmyAI@@QAEXH@Z
_TEXT	SEGMENT
_iY$ = 8						; size = 4
?SetY@CvArmyAI@@QAEXH@Z PROC				; CvArmyAI::SetY, COMDAT
; _this$ = ecx

; 566  : 	m_iCurrentY = iY;

	mov	eax, DWORD PTR _iY$[esp-4]
	mov	DWORD PTR [ecx+20], eax

; 567  : }

	ret	4
?SetY@CvArmyAI@@QAEXH@Z ENDP				; CvArmyAI::SetY
_TEXT	ENDS
PUBLIC	?SetXY@CvArmyAI@@QAEXHH@Z			; CvArmyAI::SetXY
; Function compile flags: /Ogtpy
;	COMDAT ?SetXY@CvArmyAI@@QAEXHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?SetXY@CvArmyAI@@QAEXHH@Z PROC				; CvArmyAI::SetXY, COMDAT
; _this$ = ecx

; 572  : 	m_iCurrentX = iX;

	mov	eax, DWORD PTR _iX$[esp-4]

; 573  : 	m_iCurrentY = iY;

	mov	edx, DWORD PTR _iY$[esp-4]
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], edx

; 574  : }

	ret	8
?SetXY@CvArmyAI@@QAEXHH@Z ENDP				; CvArmyAI::SetXY
_TEXT	ENDS
PUBLIC	?GetDomainType@CvArmyAI@@QBE?AW4DomainTypes@@XZ	; CvArmyAI::GetDomainType
; Function compile flags: /Ogtpy
;	COMDAT ?GetDomainType@CvArmyAI@@QBE?AW4DomainTypes@@XZ
_TEXT	SEGMENT
?GetDomainType@CvArmyAI@@QBE?AW4DomainTypes@@XZ PROC	; CvArmyAI::GetDomainType, COMDAT
; _this$ = ecx

; 601  : 	return (DomainTypes) m_eDomainType;

	mov	eax, DWORD PTR [ecx+32]

; 602  : }

	ret	0
?GetDomainType@CvArmyAI@@QBE?AW4DomainTypes@@XZ ENDP	; CvArmyAI::GetDomainType
_TEXT	ENDS
PUBLIC	?SetDomainType@CvArmyAI@@QAEXW4DomainTypes@@@Z	; CvArmyAI::SetDomainType
; Function compile flags: /Ogtpy
;	COMDAT ?SetDomainType@CvArmyAI@@QAEXW4DomainTypes@@@Z
_TEXT	SEGMENT
_domainType$ = 8					; size = 4
?SetDomainType@CvArmyAI@@QAEXW4DomainTypes@@@Z PROC	; CvArmyAI::SetDomainType, COMDAT
; _this$ = ecx

; 607  : 	m_eDomainType = domainType;

	mov	eax, DWORD PTR _domainType$[esp-4]
	mov	DWORD PTR [ecx+32], eax

; 608  : }

	ret	4
?SetDomainType@CvArmyAI@@QAEXW4DomainTypes@@@Z ENDP	; CvArmyAI::SetDomainType
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	?GetGoalX@CvArmyAI@@QBEHXZ			; CvArmyAI::GetGoalX
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
;	COMDAT ?GetGoalX@CvArmyAI@@QBEHXZ
_TEXT	SEGMENT
?GetGoalX@CvArmyAI@@QBEHXZ PROC				; CvArmyAI::GetGoalX, COMDAT
; _this$ = ecx

; 656  : 	return m_iGoalX;

	mov	eax, DWORD PTR [ecx+24]

; 657  : }

	ret	0
?GetGoalX@CvArmyAI@@QBEHXZ ENDP				; CvArmyAI::GetGoalX
_TEXT	ENDS
PUBLIC	?GetGoalY@CvArmyAI@@QBEHXZ			; CvArmyAI::GetGoalY
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoalY@CvArmyAI@@QBEHXZ
_TEXT	SEGMENT
?GetGoalY@CvArmyAI@@QBEHXZ PROC				; CvArmyAI::GetGoalY, COMDAT
; _this$ = ecx

; 662  : 	return m_iGoalY;

	mov	eax, DWORD PTR [ecx+28]

; 663  : }

	ret	0
?GetGoalY@CvArmyAI@@QBEHXZ ENDP				; CvArmyAI::GetGoalY
_TEXT	ENDS
PUBLIC	?SetGoalXY@CvArmyAI@@QAEXHH@Z			; CvArmyAI::SetGoalXY
; Function compile flags: /Ogtpy
;	COMDAT ?SetGoalXY@CvArmyAI@@QAEXHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?SetGoalXY@CvArmyAI@@QAEXHH@Z PROC			; CvArmyAI::SetGoalXY, COMDAT
; _this$ = ecx

; 668  : 	m_iGoalX = iX;

	mov	eax, DWORD PTR _iX$[esp-4]

; 669  : 	m_iGoalY = iY;

	mov	edx, DWORD PTR _iY$[esp-4]
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], edx

; 670  : }

	ret	8
?SetGoalXY@CvArmyAI@@QAEXHH@Z ENDP			; CvArmyAI::SetGoalXY
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvArmyAI@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvArmyAI@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvArmyAI@@@Z PROC		; operator<<, COMDAT

; 872  : 	readFrom.write(saveTo);

	mov	ecx, DWORD PTR _readFrom$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	esi
	call	edx

; 873  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 874  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvArmyAI@@@Z ENDP		; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvArmyAI@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvArmyAI@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvArmyAI@@@Z PROC		; operator>>, COMDAT

; 878  : 	writeTo.read(loadFrom);

	mov	ecx, DWORD PTR _writeTo$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	esi
	call	edx

; 879  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 880  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvArmyAI@@@Z ENDP		; operator>>
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator bool, COMDAT
; _this$ = ecx

; 108  : 		return m_target != 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 109  : 	}

	ret	0
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator bool
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 215  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0

; 216  : 		OBJECT_HANDLE_STACK;
; 217  : 	}

	ret	0
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvArmyFormationSlot@@$00@@QBEABVCvArmyFormationSlot@@I@Z ; BaseVector<CvArmyFormationSlot,1>::operator[]
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@VCvArmyFormationSlot@@$00@@QBEABVCvArmyFormationSlot@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvArmyFormationSlot@@$00@@QBEABVCvArmyFormationSlot@@I@Z PROC ; BaseVector<CvArmyFormationSlot,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 137  : 	};

	ret	4
??A?$BaseVector@VCvArmyFormationSlot@@$00@@QBEABVCvArmyFormationSlot@@I@Z ENDP ; BaseVector<CvArmyFormationSlot,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvArmyFormationSlot@@$00@@QBEIXZ ; BaseVector<CvArmyFormationSlot,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvArmyFormationSlot@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvArmyFormationSlot@@$00@@QBEIXZ PROC ; BaseVector<CvArmyFormationSlot,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvArmyFormationSlot@@$00@@QBEIXZ ENDP ; BaseVector<CvArmyFormationSlot,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvArmyFormationSlot@@$00@@QAEPAVCvArmyFormationSlot@@XZ ; BaseVector<CvArmyFormationSlot,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvArmyFormationSlot@@$00@@QAEPAVCvArmyFormationSlot@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvArmyFormationSlot@@$00@@QAEPAVCvArmyFormationSlot@@XZ PROC ; BaseVector<CvArmyFormationSlot,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvArmyFormationSlot@@$00@@QAEPAVCvArmyFormationSlot@@XZ ENDP ; BaseVector<CvArmyFormationSlot,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvArmyFormationSlot@@$00@@QAEPAVCvArmyFormationSlot@@XZ ; BaseVector<CvArmyFormationSlot,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvArmyFormationSlot@@$00@@QAEPAVCvArmyFormationSlot@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvArmyFormationSlot@@$00@@QAEPAVCvArmyFormationSlot@@XZ PROC ; BaseVector<CvArmyFormationSlot,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvArmyFormationSlot@@$00@@QAEPAVCvArmyFormationSlot@@XZ ENDP ; BaseVector<CvArmyFormationSlot,1>::end
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEPAVCvArmyFormationSlot@@I@Z ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@ DB 's:\github\l'
	DB	'ekmod\lekmod_dll\fireplace\include\fireworks\FFastVector.h', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEPAVCvArmyFormationSlot@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEPAVCvArmyFormationSlot@@I@Z PROC ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 20					; 00000014H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi+edi*2]
	push	OFFSET ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 20			; 00000014H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEPAVCvArmyFormationSlot@@I@Z ENDP ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvArmyFormationSlot@@$00@@QAE@XZ ; BaseVector<CvArmyFormationSlot,1>::~BaseVector<CvArmyFormationSlot,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvArmyFormationSlot@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvArmyFormationSlot@@$00@@QAE@XZ PROC	; BaseVector<CvArmyFormationSlot,1>::~BaseVector<CvArmyFormationSlot,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvArmyFormationSlot@@$00@@QAE@XZ ENDP	; BaseVector<CvArmyFormationSlot,1>::~BaseVector<CvArmyFormationSlot,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvArmyFormationSlot@@$00@@IAE@XZ ; BaseVector<CvArmyFormationSlot,1>::BaseVector<CvArmyFormationSlot,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvArmyFormationSlot@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvArmyFormationSlot@@$00@@IAE@XZ PROC	; BaseVector<CvArmyFormationSlot,1>::BaseVector<CvArmyFormationSlot,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvArmyFormationSlot@@$00@@IAE@XZ ENDP	; BaseVector<CvArmyFormationSlot,1>::BaseVector<CvArmyFormationSlot,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvArmyFormationSlot@@$00@@IAEXPAVCvArmyFormationSlot@@I@Z ; BaseVector<CvArmyFormationSlot,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvArmyFormationSlot@@$00@@IAEXPAVCvArmyFormationSlot@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvArmyFormationSlot@@$00@@IAEXPAVCvArmyFormationSlot@@I@Z PROC ; BaseVector<CvArmyFormationSlot,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvArmyFormationSlot@@$00@@IAEXPAVCvArmyFormationSlot@@I@Z ENDP ; BaseVector<CvArmyFormationSlot,1>::Destroy
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	??0CvArmyFormationSlot@@QAE@XZ			; CvArmyFormationSlot::CvArmyFormationSlot
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.h
;	COMDAT ??0CvArmyFormationSlot@@QAE@XZ
_TEXT	SEGMENT
??0CvArmyFormationSlot@@QAE@XZ PROC			; CvArmyFormationSlot::CvArmyFormationSlot, COMDAT
; _this$ = ecx

; 32   : 	CvArmyFormationSlot()

	mov	eax, ecx

; 33   : 	{
; 34   : 		m_iUnitID = ARMY_NO_UNIT;

	mov	DWORD PTR [eax], -1

; 35   : 		m_iEstimatedTurnAtCheckpoint = ARMYSLOT_UNKNOWN_TURN_AT_CHECKPOINT;

	mov	DWORD PTR [eax+4], -1

; 36   : 		m_bStartedOnOperation = false;

	mov	DWORD PTR [eax+8], 0

; 37   : 	};

	ret	0
??0CvArmyFormationSlot@@QAE@XZ ENDP			; CvArmyFormationSlot::CvArmyFormationSlot
_TEXT	ENDS
PUBLIC	?GetUnitID@CvArmyFormationSlot@@QAEHXZ		; CvArmyFormationSlot::GetUnitID
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitID@CvArmyFormationSlot@@QAEHXZ
_TEXT	SEGMENT
?GetUnitID@CvArmyFormationSlot@@QAEHXZ PROC		; CvArmyFormationSlot::GetUnitID, COMDAT
; _this$ = ecx

; 41   : 		return m_iUnitID;

	mov	eax, DWORD PTR [ecx]

; 42   : 	};

	ret	0
?GetUnitID@CvArmyFormationSlot@@QAEHXZ ENDP		; CvArmyFormationSlot::GetUnitID
_TEXT	ENDS
PUBLIC	?SetUnitID@CvArmyFormationSlot@@QAEXH@Z		; CvArmyFormationSlot::SetUnitID
; Function compile flags: /Ogtpy
;	COMDAT ?SetUnitID@CvArmyFormationSlot@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetUnitID@CvArmyFormationSlot@@QAEXH@Z PROC		; CvArmyFormationSlot::SetUnitID, COMDAT
; _this$ = ecx

; 45   : 		m_iUnitID = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx], eax

; 46   : 	};

	ret	4
?SetUnitID@CvArmyFormationSlot@@QAEXH@Z ENDP		; CvArmyFormationSlot::SetUnitID
_TEXT	ENDS
PUBLIC	?SetTurnAtCheckpoint@CvArmyFormationSlot@@QAEXH@Z ; CvArmyFormationSlot::SetTurnAtCheckpoint
; Function compile flags: /Ogtpy
;	COMDAT ?SetTurnAtCheckpoint@CvArmyFormationSlot@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetTurnAtCheckpoint@CvArmyFormationSlot@@QAEXH@Z PROC	; CvArmyFormationSlot::SetTurnAtCheckpoint, COMDAT
; _this$ = ecx

; 53   : 		m_iEstimatedTurnAtCheckpoint = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 54   : 	};

	ret	4
?SetTurnAtCheckpoint@CvArmyFormationSlot@@QAEXH@Z ENDP	; CvArmyFormationSlot::SetTurnAtCheckpoint
_TEXT	ENDS
PUBLIC	?GetOwner@CvArmyAI@@QBE?AW4PlayerTypes@@XZ	; CvArmyAI::GetOwner
; Function compile flags: /Ogtpy
;	COMDAT ?GetOwner@CvArmyAI@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetOwner@CvArmyAI@@QBE?AW4PlayerTypes@@XZ PROC		; CvArmyAI::GetOwner, COMDAT
; _this$ = ecx

; 126  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+8]

; 127  : 	}

	ret	0
?GetOwner@CvArmyAI@@QBE?AW4PlayerTypes@@XZ ENDP		; CvArmyAI::GetOwner
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvArmyFormationSlot@@$00@@QAEAAVCvArmyFormationSlot@@I@Z ; BaseVector<CvArmyFormationSlot,1>::operator[]
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@VCvArmyFormationSlot@@$00@@QAEAAVCvArmyFormationSlot@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvArmyFormationSlot@@$00@@QAEAAVCvArmyFormationSlot@@I@Z PROC ; BaseVector<CvArmyFormationSlot,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvArmyFormationSlot@@$00@@QAEAAVCvArmyFormationSlot@@I@Z ENDP ; BaseVector<CvArmyFormationSlot,1>::operator[]
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovector.h
;	COMDAT ??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z PROC ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[], COMDAT
; _this$ = ecx

; 329  : 	return m_value[index];

	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR _index$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 330  : }

	ret	4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ENDP ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?GetNumFormationEntries@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumFormationEntries
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
;	COMDAT ?GetNumFormationEntries@CvArmyAI@@QBEHXZ
_TEXT	SEGMENT
?GetNumFormationEntries@CvArmyAI@@QBEHXZ PROC		; CvArmyAI::GetNumFormationEntries, COMDAT
; _this$ = ecx

; 393  : 	return m_FormationEntries.size();

	mov	eax, DWORD PTR [ecx+48]

; 394  : }

	ret	0
?GetNumFormationEntries@CvArmyAI@@QBEHXZ ENDP		; CvArmyAI::GetNumFormationEntries
_TEXT	ENDS
PUBLIC	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ		; CvArmyAI::GetNumSlotsFilled
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumSlotsFilled@CvArmyAI@@QBEHXZ
_TEXT	SEGMENT
?GetNumSlotsFilled@CvArmyAI@@QBEHXZ PROC		; CvArmyAI::GetNumSlotsFilled, COMDAT
; _this$ = ecx

; 398  : {

	mov	edx, DWORD PTR [ecx+48]

; 399  : 	int iRtnValue = 0;

	xor	eax, eax

; 400  : 
; 401  : 	for(unsigned int iI = 0; iI < m_FormationEntries.size(); iI++)

	test	edx, edx
	jbe	SHORT $LN2@GetNumSlot

; 399  : 	int iRtnValue = 0;

	mov	ecx, DWORD PTR [ecx+44]
	npad	4
$LL4@GetNumSlot:

; 402  : 	{
; 403  : 		if(m_FormationEntries[iI].m_iUnitID != ARMY_NO_UNIT)

	cmp	DWORD PTR [ecx], -1
	je	SHORT $LN3@GetNumSlot

; 404  : 		{
; 405  : 			iRtnValue++;

	inc	eax
$LN3@GetNumSlot:

; 400  : 
; 401  : 	for(unsigned int iI = 0; iI < m_FormationEntries.size(); iI++)

	add	ecx, 12					; 0000000cH
	sub	edx, 1
	jne	SHORT $LL4@GetNumSlot
$LN2@GetNumSlot:

; 406  : 		}
; 407  : 	}
; 408  : 	return iRtnValue;
; 409  : }

	ret	0
?GetNumSlotsFilled@CvArmyAI@@QBEHXZ ENDP		; CvArmyAI::GetNumSlotsFilled
_TEXT	ENDS
PUBLIC	?SetEstimatedTurn@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetEstimatedTurn
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
; Function compile flags: /Ogtpy
;	COMDAT ?SetEstimatedTurn@CvArmyAI@@QAEXHH@Z
_TEXT	SEGMENT
_iSlotID$ = 8						; size = 4
_iTurns$ = 12						; size = 4
?SetEstimatedTurn@CvArmyAI@@QAEXHH@Z PROC		; CvArmyAI::SetEstimatedTurn, COMDAT
; _this$ = ecx

; 413  : {

	push	esi

; 414  : 	int iTurnAtCheckpoint;
; 415  : 
; 416  : 	if(iTurns == ARMYSLOT_NOT_INCLUDING_IN_OPERATION || iTurns == ARMYSLOT_UNKNOWN_TURN_AT_CHECKPOINT)

	mov	esi, DWORD PTR _iTurns$[esp]
	push	edi
	mov	edi, ecx
	cmp	esi, -2					; fffffffeH
	je	SHORT $LN2@SetEstimat
	cmp	esi, -1
	je	SHORT $LN2@SetEstimat

; 417  : 	{
; 418  : 		iTurnAtCheckpoint = iTurns;
; 419  : 	}
; 420  : 	else
; 421  : 	{
; 422  : 		iTurnAtCheckpoint = GC.getGame().getGameTurn() + iTurns;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 423  : 	}
; 424  : 
; 425  : 	m_FormationEntries[iSlotID].SetTurnAtCheckpoint(iTurnAtCheckpoint);

	mov	ecx, DWORD PTR _iSlotID$[esp+4]
	mov	edx, DWORD PTR [edi+44]
	add	eax, esi
	lea	ecx, DWORD PTR [ecx+ecx*2]
	pop	edi
	mov	DWORD PTR [edx+ecx*4+4], eax
	pop	esi

; 426  : }

	ret	8
$LN2@SetEstimat:

; 423  : 	}
; 424  : 
; 425  : 	m_FormationEntries[iSlotID].SetTurnAtCheckpoint(iTurnAtCheckpoint);

	mov	ecx, DWORD PTR _iSlotID$[esp+4]
	mov	edx, DWORD PTR [edi+44]
	mov	eax, esi
	lea	ecx, DWORD PTR [ecx+ecx*2]
	pop	edi
	mov	DWORD PTR [edx+ecx*4+4], eax
	pop	esi

; 426  : }

	ret	8
?SetEstimatedTurn@CvArmyAI@@QAEXHH@Z ENDP		; CvArmyAI::SetEstimatedTurn
_TEXT	ENDS
PUBLIC	?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ	; CvArmyAI::GetTurnAtNextCheckpoint
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ
_TEXT	SEGMENT
?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ PROC		; CvArmyAI::GetTurnAtNextCheckpoint, COMDAT
; _this$ = ecx

; 430  : {

	push	esi
	push	edi
	mov	edi, DWORD PTR [ecx+48]

; 431  : 	int iRtnValue = ARMYSLOT_NOT_INCLUDING_IN_OPERATION;
; 432  : 
; 433  : 	for(unsigned int iI = 0; iI < m_FormationEntries.size(); iI++)

	xor	esi, esi
	mov	eax, -2					; fffffffeH
	test	edi, edi
	jbe	SHORT $LN7@GetTurnAtN
	mov	edx, DWORD PTR [ecx+44]
	add	edx, 4
$LL6@GetTurnAtN:

; 434  : 	{
; 435  : 		if(m_FormationEntries[iI].m_iEstimatedTurnAtCheckpoint == ARMYSLOT_UNKNOWN_TURN_AT_CHECKPOINT)

	mov	ecx, DWORD PTR [edx]
	cmp	ecx, -1
	je	SHORT $LN18@GetTurnAtN

; 438  : 		}
; 439  : 		else if(m_FormationEntries[iI].m_iEstimatedTurnAtCheckpoint > iRtnValue)

	cmp	ecx, eax
	jle	SHORT $LN5@GetTurnAtN

; 440  : 		{
; 441  : 			iRtnValue = m_FormationEntries[iI].m_iEstimatedTurnAtCheckpoint;

	mov	eax, ecx
$LN5@GetTurnAtN:

; 431  : 	int iRtnValue = ARMYSLOT_NOT_INCLUDING_IN_OPERATION;
; 432  : 
; 433  : 	for(unsigned int iI = 0; iI < m_FormationEntries.size(); iI++)

	inc	esi
	add	edx, 12					; 0000000cH
	cmp	esi, edi
	jb	SHORT $LL6@GetTurnAtN
	pop	edi
	pop	esi

; 442  : 		}
; 443  : 	}
; 444  : 
; 445  : 	return iRtnValue;
; 446  : }

	ret	0
$LN18@GetTurnAtN:

; 436  : 		{
; 437  : 			return ARMYSLOT_UNKNOWN_TURN_AT_CHECKPOINT;

	or	eax, -1
$LN7@GetTurnAtN:
	pop	edi
	pop	esi

; 442  : 		}
; 443  : 	}
; 444  : 
; 445  : 	return iRtnValue;
; 446  : }

	ret	0
?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ ENDP		; CvArmyAI::GetTurnAtNextCheckpoint
_TEXT	ENDS
PUBLIC	?GetUnitsOfType@CvArmyAI@@QBEHW4MultiunitPositionTypes@@@Z ; CvArmyAI::GetUnitsOfType
EXTRN	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z:PROC ; CvMultiUnitFormationInfo::getFormationSlotEntry
EXTRN	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z:PROC ; CvGlobals::getMultiUnitFormationInfo
EXTRN	?getMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::getMoves
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitsOfType@CvArmyAI@@QBEHW4MultiunitPositionTypes@@@Z
_TEXT	SEGMENT
_iRtnValue$ = -4					; size = 4
_ePosition$ = 8						; size = 4
?GetUnitsOfType@CvArmyAI@@QBEHW4MultiunitPositionTypes@@@Z PROC ; CvArmyAI::GetUnitsOfType, COMDAT
; _this$ = ecx

; 472  : {

	push	ecx
	push	esi

; 473  : 	int iRtnValue = 0;

	xor	eax, eax
	push	edi
	mov	esi, ecx

; 474  : 
; 475  : 	for(unsigned int iI = 0; iI < m_FormationEntries.size(); iI++)

	xor	edi, edi
	mov	DWORD PTR _iRtnValue$[esp+12], eax
	cmp	DWORD PTR [esi+48], eax
	jbe	SHORT $LN5@GetUnitsOf
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _ePosition$[esp+16]
	xor	ebx, ebx
	npad	6
$LL7@GetUnitsOf:

; 476  : 	{
; 477  : 		if(m_FormationEntries[iI].m_iUnitID != ARMY_NO_UNIT)

	mov	eax, DWORD PTR [esi+44]
	add	eax, ebx
	cmp	DWORD PTR [eax], -1
	je	SHORT $LN6@GetUnitsOf

; 478  : 		{
; 479  : 			CvUnit* pUnit = GET_PLAYER(m_eOwner).getUnit(m_FormationEntries[iI].m_iUnitID);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 480  : 			if(pUnit->getMoves() > 0)

	mov	ecx, eax
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jle	SHORT $LN6@GetUnitsOf

; 481  : 			{
; 482  : 				CvMultiUnitFormationInfo* thisFormation = GC.getMultiUnitFormationInfo(m_iFormationIndex);

	mov	eax, DWORD PTR [esi+36]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo

; 483  : 				if(thisFormation)

	test	eax, eax
	je	SHORT $LN6@GetUnitsOf

; 484  : 				{
; 485  : 					const CvFormationSlotEntry& thisSlotEntry = thisFormation->getFormationSlotEntry(iI);

	push	edi
	mov	ecx, eax
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry

; 486  : 					if(thisSlotEntry.m_ePositionType == ePosition)

	cmp	DWORD PTR [eax+8], ebp
	jne	SHORT $LN6@GetUnitsOf

; 487  : 					{
; 488  : 						iRtnValue++;

	inc	DWORD PTR _iRtnValue$[esp+20]
$LN6@GetUnitsOf:

; 474  : 
; 475  : 	for(unsigned int iI = 0; iI < m_FormationEntries.size(); iI++)

	inc	edi
	add	ebx, 12					; 0000000cH
	cmp	edi, DWORD PTR [esi+48]
	jb	SHORT $LL7@GetUnitsOf

; 489  : 					}
; 490  : 				}
; 491  : 			}
; 492  : 		}
; 493  : 	}
; 494  : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[esp+20]
	pop	ebp
	pop	ebx
$LN5@GetUnitsOf:
	pop	edi
	pop	esi

; 495  : }

	pop	ecx
	ret	4
?GetUnitsOfType@CvArmyAI@@QBEHW4MultiunitPositionTypes@@@Z ENDP ; CvArmyAI::GetUnitsOfType
_TEXT	ENDS
PUBLIC	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z	; CvArmyAI::SetGoalPlot
; Function compile flags: /Ogtpy
;	COMDAT ?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pGoalPlot$ = 8						; size = 4
?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z PROC		; CvArmyAI::SetGoalPlot, COMDAT
; _this$ = ecx

; 639  : 	CvAssertMsg(pGoalPlot, "Setting army goal to a NULL plot - please show Ed and send save.");
; 640  : 
; 641  : 	if(pGoalPlot)

	mov	eax, DWORD PTR _pGoalPlot$[esp-4]
	test	eax, eax
	je	SHORT $LN2@SetGoalPlo

; 642  : 	{
; 643  : 		m_iGoalX = pGoalPlot->getX();

	movsx	edx, WORD PTR [eax]
	mov	DWORD PTR [ecx+24], edx

; 644  : 		m_iGoalY = pGoalPlot->getY();

	movsx	eax, WORD PTR [eax+2]

; 649  : 		m_iGoalY = -1;

	mov	DWORD PTR [ecx+28], eax

; 650  : 	}
; 651  : }

	ret	4
$LN2@SetGoalPlo:

; 645  : 	}
; 646  : 	else
; 647  : 	{
; 648  : 		m_iGoalX = -1;

	or	eax, -1
	mov	DWORD PTR [ecx+24], eax

; 649  : 		m_iGoalY = -1;

	mov	DWORD PTR [ecx+28], eax

; 650  : 	}
; 651  : }

	ret	4
?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ENDP		; CvArmyAI::SetGoalPlot
_TEXT	ENDS
PUBLIC	?CanTacticalAIInterruptUnit@CvArmyAI@@QBE_NH@Z	; CvArmyAI::CanTacticalAIInterruptUnit
EXTRN	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z:PROC ; CvPlayer::getAIOperation
; Function compile flags: /Ogtpy
;	COMDAT ?CanTacticalAIInterruptUnit@CvArmyAI@@QBE_NH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?CanTacticalAIInterruptUnit@CvArmyAI@@QBE_NH@Z PROC	; CvArmyAI::CanTacticalAIInterruptUnit, COMDAT
; _this$ = ecx

; 735  : 	// If the operation is still assembling, by all means interrupt it
; 736  : 	if(m_eAIState == ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE ||
; 737  : 	        m_eAIState == ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP)

	mov	eax, DWORD PTR [ecx+40]
	test	eax, eax
	je	SHORT $LN3@CanTactica
	cmp	eax, 1
	je	SHORT $LN3@CanTactica

; 740  : 	}
; 741  : 
; 742  : 	if(m_eOwner >=0 && m_eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	jl	SHORT $LN1@CanTactica
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@CanTactica

; 743  : 	{
; 744  : 		CvAIOperation* op = GET_PLAYER(m_eOwner).getAIOperation(m_iOperationID);

	mov	ecx, DWORD PTR [ecx+12]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation

; 745  : 		if(op)

	test	eax, eax
	je	SHORT $LN1@CanTactica

; 746  : 		{
; 747  : 			return op->CanTacticalAIInterruptOperation();

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 751  : }

	ret	4
$LN1@CanTactica:

; 748  : 		}
; 749  : 	}
; 750  : 	return false;

	xor	al, al

; 751  : }

	ret	4
$LN3@CanTactica:

; 738  : 	{
; 739  : 		return true;

	mov	al, 1

; 751  : }

	ret	4
?CanTacticalAIInterruptUnit@CvArmyAI@@QBE_NH@Z ENDP	; CvArmyAI::CanTacticalAIInterruptUnit
_TEXT	ENDS
PUBLIC	?GetFirstUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetFirstUnitID
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstUnitID@CvArmyAI@@QAEHXZ
_TEXT	SEGMENT
?GetFirstUnitID@CvArmyAI@@QAEHXZ PROC			; CvArmyAI::GetFirstUnitID, COMDAT
; _this$ = ecx

; 756  : 	m_CurUnitIter = m_FormationEntries.begin();

	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [ecx+300], eax

; 757  : 
; 758  : 	if(m_CurUnitIter == m_FormationEntries.end())

	mov	edx, DWORD PTR [ecx+48]
	push	esi
	lea	edx, DWORD PTR [edx+edx*2]
	mov	esi, eax
	lea	edx, DWORD PTR [esi+edx*4]
	cmp	eax, edx

; 759  : 	{
; 760  : 		return ARMY_NO_UNIT;

	je	SHORT $LN2@GetFirstUn

; 761  : 	}
; 762  : 	else
; 763  : 	{
; 764  : 		// First entry could not be filled yet
; 765  : 		while(m_CurUnitIter != m_FormationEntries.end())

	mov	edx, DWORD PTR [ecx+48]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [esi+edx*4]
	cmp	eax, edx
	je	SHORT $LN2@GetFirstUn
	npad	10
$LL3@GetFirstUn:

; 766  : 		{
; 767  : 			if(m_CurUnitIter->GetUnitID() != ARMY_NO_UNIT)

	mov	eax, DWORD PTR [ecx+300]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN19@GetFirstUn

; 770  : 			}
; 771  : 			++m_CurUnitIter;

	add	eax, 12					; 0000000cH
	mov	DWORD PTR [ecx+300], eax
	mov	eax, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+300], eax
	jne	SHORT $LL3@GetFirstUn
$LN2@GetFirstUn:

; 772  : 		}
; 773  : 
; 774  : 		return ARMY_NO_UNIT;

	or	eax, -1
	pop	esi

; 775  : 	}
; 776  : }

	ret	0
$LN19@GetFirstUn:

; 768  : 			{
; 769  : 				return m_CurUnitIter->GetUnitID();

	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	pop	esi

; 775  : 	}
; 776  : }

	ret	0
?GetFirstUnitID@CvArmyAI@@QAEHXZ ENDP			; CvArmyAI::GetFirstUnitID
_TEXT	ENDS
PUBLIC	?GetNextUnitID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetNextUnitID
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextUnitID@CvArmyAI@@QAEHXZ
_TEXT	SEGMENT
?GetNextUnitID@CvArmyAI@@QAEHXZ PROC			; CvArmyAI::GetNextUnitID, COMDAT
; _this$ = ecx

; 781  : 	if(m_CurUnitIter != m_FormationEntries.end())

	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [ecx+300]
	push	esi
	mov	esi, DWORD PTR [ecx+44]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [esi+edx*4]
	cmp	eax, edx
	je	SHORT $LN4@GetNextUni

; 782  : 	{
; 783  : 		++m_CurUnitIter;

	add	eax, 12					; 0000000cH
	mov	DWORD PTR [ecx+300], eax

; 784  : 
; 785  : 		while(m_CurUnitIter != m_FormationEntries.end())

	mov	edx, DWORD PTR [ecx+48]
	mov	esi, DWORD PTR [ecx+44]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [esi+edx*4]
	cmp	eax, edx
	je	SHORT $LN4@GetNextUni
$LL3@GetNextUni:

; 786  : 		{
; 787  : 			if(m_CurUnitIter->GetUnitID() != ARMY_NO_UNIT)

	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN16@GetNextUni

; 790  : 			}
; 791  : 			++m_CurUnitIter;

	add	eax, 12					; 0000000cH
	mov	DWORD PTR [ecx+300], eax
	mov	edx, DWORD PTR [ecx+48]
	mov	esi, DWORD PTR [ecx+44]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [esi+edx*4]
	cmp	eax, edx
	jne	SHORT $LL3@GetNextUni
$LN4@GetNextUni:

; 792  : 		}
; 793  : 
; 794  : 		return ARMY_NO_UNIT;
; 795  : 	}
; 796  : 	return ARMY_NO_UNIT;

	or	eax, -1
	pop	esi

; 797  : }

	ret	0
$LN16@GetNextUni:

; 788  : 			{
; 789  : 				return m_CurUnitIter->GetUnitID();

	mov	eax, DWORD PTR [eax]
	pop	esi

; 797  : }

	ret	0
?GetNextUnitID@CvArmyAI@@QAEHXZ ENDP			; CvArmyAI::GetNextUnitID
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvArmyFormationSlot@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvArmyFormationSlot@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvArmyFormationSlot@@@Z PROC ; operator<<, COMDAT

; 883  : {

	push	esi

; 884  : 	saveTo << readFrom.m_iUnitID;

	mov	esi, DWORD PTR _saveTo$[esp]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 885  : 	saveTo << readFrom.m_iEstimatedTurnAtCheckpoint;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 886  : 	saveTo << readFrom.m_bStartedOnOperation;

	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi

; 887  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 888  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvArmyFormationSlot@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvArmyFormationSlot@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvArmyFormationSlot@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvArmyFormationSlot@@@Z PROC ; operator>>, COMDAT

; 891  : {

	push	esi

; 892  : 	loadFrom >> writeTo.m_iUnitID;

	mov	esi, DWORD PTR _loadFrom$[esp]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 893  : 	loadFrom >> writeTo.m_iEstimatedTurnAtCheckpoint;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 894  : 	loadFrom >> writeTo.m_bStartedOnOperation;

	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi

; 895  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 896  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvArmyFormationSlot@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 156  : 	{

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [esi+4], 0

; 157  : 		OBJECT_HANDLE_STACK;
; 158  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 159  : 		{
; 160  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 161  : 		}
; 162  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z	; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z PROC	; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 195  : 	{

	push	esi
	push	edi

; 196  : 		if(&rhs != this)

	mov	edi, DWORD PTR _rhs$[esp+4]
	mov	esi, ecx
	cmp	edi, esi
	je	SHORT $LN11@operator

; 197  : 		{
; 198  : 			OBJECT_HANDLE_STACK;
; 199  : 			if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@operator

; 200  : 			{
; 201  : 				const_cast<FObjectHandle *>(this)->m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@operator:

; 202  : 			}
; 203  : 			const_cast<FObjectHandle *>(this)->m_target = rhs.m_target;

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 204  : 			if(m_target)

	test	ecx, ecx
	je	SHORT $LN11@operator

; 205  : 			{
; 206  : 				const_cast<FObjectHandle *>(this)->m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@operator:
	pop	edi

; 207  : 			}
; 208  : 		}
; 209  : 		return *this;

	mov	eax, esi
	pop	esi

; 210  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z ENDP	; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 222  : 	{

	mov	eax, DWORD PTR _source$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	dl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], dl

; 223  : 		OBJECT_HANDLE_STACK;
; 224  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@3

; 225  : 		{
; 226  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@3:

; 227  : 		}
; 228  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::FStaticVector<CvArmyFormationSlot,20,1,297,0>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::FStaticVector<CvArmyFormationSlot,20,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 20			; 00000014H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::FStaticVector<CvArmyFormationSlot,20,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvArmyFormationSlot@@$00@@QAEXXZ ; BaseVector<CvArmyFormationSlot,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvArmyFormationSlot@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvArmyFormationSlot@@$00@@QAEXXZ PROC ; BaseVector<CvArmyFormationSlot,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvArmyFormationSlot@@$00@@QAEXXZ ENDP ; BaseVector<CvArmyFormationSlot,1>::clear
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEXPAVCvArmyFormationSlot@@I@Z ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEXPAVCvArmyFormationSlot@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEXPAVCvArmyFormationSlot@@I@Z PROC ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEXPAVCvArmyFormationSlot@@I@Z ENDP ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z ; CvUnit::isTerrainImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z PROC ; CvUnit::isTerrainImpassable, COMDAT
; _this$ = ecx

; 1125 : 		return m_terrainImpassableCount[eIndex] > 0;

	mov	eax, DWORD PTR [ecx+1996]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+edx*4], ecx
	setg	cl
	mov	al, cl

; 1126 : 	}

	ret	4
?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z ENDP ; CvUnit::isTerrainImpassable
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z	; CvMap::plotCheckInvalid
; Function compile flags: /Ogtpy
;	COMDAT ?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z PROC	; CvMap::plotCheckInvalid, COMDAT
; _this$ = ecx

; 282  : 	{

	push	esi

; 283  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	esi, DWORD PTR _iX$[esp]
	cmp	esi, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI
	mov	edx, DWORD PTR _iY$[esp]
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI

; 286  : 		}
; 287  : 		return &(m_pMapPlots[plotNum(iX, iY)]);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, edx
	add	eax, esi
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	pop	esi

; 288  : 	}

	ret	8
$LN1@plotCheckI:

; 284  : 		{
; 285  : 			return NULL;

	xor	eax, eax
	pop	esi

; 288  : 	}

	ret	8
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z ENDP	; CvMap::plotCheckInvalid
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 245  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	pop	esi

; 261  : }

	ret	0
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 261  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	?Uninit@CvArmyAI@@QAEXXZ			; CvArmyAI::Uninit
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
;	COMDAT ?Uninit@CvArmyAI@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvArmyAI@@QAEXXZ PROC				; CvArmyAI::Uninit, COMDAT
; _this$ = ecx

; 56   : 	m_FormationEntries.clear();

	mov	DWORD PTR [ecx+48], 0

; 57   : }

	ret	0
?Uninit@CvArmyAI@@QAEXXZ ENDP				; CvArmyAI::Uninit
_TEXT	ENDS
PUBLIC	?Reset@CvArmyAI@@QAEXHW4PlayerTypes@@H_N@Z	; CvArmyAI::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvArmyAI@@QAEXHW4PlayerTypes@@H_N@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_iOperationID$ = 16					; size = 4
___formal$ = 20						; size = 1
?Reset@CvArmyAI@@QAEXHW4PlayerTypes@@H_N@Z PROC		; CvArmyAI::Reset, COMDAT
; _this$ = ecx

; 62   : 	//--------------------------------
; 63   : 	// Uninit class
; 64   : 	Uninit();
; 65   : 
; 66   : 	m_iID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 67   : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _eOwner$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 68   : 	m_iOperationID = iOperationID;

	mov	eax, DWORD PTR _iOperationID$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 69   : 	m_iCurrentX = -1;

	or	eax, -1
	xor	edx, edx
	mov	DWORD PTR [ecx+16], eax

; 70   : 	m_iCurrentY = -1;

	mov	DWORD PTR [ecx+20], eax

; 71   : 	m_iGoalX = -1;

	mov	DWORD PTR [ecx+24], eax

; 72   : 	m_iGoalY = -1;

	mov	DWORD PTR [ecx+28], eax

; 73   : 	m_eDomainType = DOMAIN_LAND;

	mov	DWORD PTR [ecx+32], 2

; 74   : 	m_iFormationIndex = NO_MUFORMATION;

	mov	DWORD PTR [ecx+36], eax

; 75   : 	m_eAIState = NO_ARMYAISTATE;

	mov	DWORD PTR [ecx+40], eax

; 76   : 
; 77   : 	m_FormationEntries.clear();

	mov	DWORD PTR [ecx+48], edx

; 78   : }

	ret	16					; 00000010H
?Reset@CvArmyAI@@QAEXHW4PlayerTypes@@H_N@Z ENDP		; CvArmyAI::Reset
_TEXT	ENDS
PUBLIC	?Kill@CvArmyAI@@QAEXXZ				; CvArmyAI::Kill
EXTRN	?setArmyID@CvUnit@@QAEXH@Z:PROC			; CvUnit::setArmyID
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?Kill@CvArmyAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Kill@CvArmyAI@@QAEXXZ$0
__ehfuncinfo$?Kill@CvArmyAI@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Kill@CvArmyAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
xdata$x	ENDS
;	COMDAT ?Kill@CvArmyAI@@QAEXXZ
_TEXT	SEGMENT
_pThisUnit$217578 = -20					; size = 8
__$EHRec$ = -12						; size = 12
?Kill@CvArmyAI@@QAEXXZ PROC				; CvArmyAI::Kill, COMDAT
; _this$ = ecx

; 82   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Kill@CvArmyAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebp
	push	edi
	mov	ebp, ecx

; 83   : 	CvAssert(GetOwner() != NO_PLAYER);
; 84   : 	CvAssertMsg(GetID() != FFreeList::INVALID_INDEX, "GetID() is not expected to be equal with FFreeList::INVALID_INDEX");
; 85   : 
; 86   : 	int iUnitID;
; 87   : 	iUnitID = GetFirstUnitID();

	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	edi, eax

; 88   : 
; 89   : 	while(iUnitID != ARMY_NO_UNIT)

	cmp	edi, -1
	je	SHORT $LN34@Kill
	push	ebx
	push	esi
	xor	ebx, ebx
	npad	4
$LL3@Kill:

; 90   : 	{
; 91   : 		UnitHandle pThisUnit = GET_PLAYER(GetOwner()).getUnit(iUnitID);

	mov	eax, DWORD PTR [ebp+8]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	ecx, eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pThisUnit$217578[esp+36], esi
	mov	BYTE PTR _pThisUnit$217578[esp+40], bl
	cmp	esi, ebx
	je	SHORT $LN14@Kill
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN14@Kill:
	mov	DWORD PTR __$EHRec$[esp+44], ebx

; 92   : 		if(pThisUnit)

	cmp	esi, ebx
	je	SHORT $LN1@Kill

; 93   : 		{
; 94   : 			pThisUnit->setArmyID(FFreeList::INVALID_INDEX);

	push	-1
	mov	ecx, esi
	call	?setArmyID@CvUnit@@QAEXH@Z		; CvUnit::setArmyID
$LN1@Kill:

; 95   : 		}
; 96   : 		iUnitID = GetNextUnitID();

	mov	ecx, ebp
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	edi, eax

; 97   : 	}

	mov	DWORD PTR __$EHRec$[esp+44], -1
	cmp	esi, ebx
	je	SHORT $LN23@Kill
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@Kill:

; 88   : 
; 89   : 	while(iUnitID != ARMY_NO_UNIT)

	cmp	edi, -1
	jne	SHORT $LL3@Kill
	pop	esi

; 98   : 
; 99   : 	m_FormationEntries.clear();

	mov	DWORD PTR [ebp+48], ebx
	pop	ebx
	pop	edi
	pop	ebp

; 100  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
$LN34@Kill:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [ebp+48], 0
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Kill@CvArmyAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _pThisUnit$217578[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?Kill@CvArmyAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?Kill@CvArmyAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Kill@CvArmyAI@@QAEXXZ ENDP				; CvArmyAI::Kill
PUBLIC	?write@CvArmyAI@@UBEXAAVFDataStream@@@Z		; CvArmyAI::write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?write@CvArmyAI@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
tv224 = 8						; size = 4
$T219629 = 8						; size = 4
_kStream$ = 8						; size = 4
?write@CvArmyAI@@UBEXAAVFDataStream@@@Z PROC		; CvArmyAI::write, COMDAT
; _this$ = ecx

; 135  : {

	push	ecx
	push	ebp
	push	esi

; 136  : 	// Current version number
; 137  : 	uint uiVersion = 1;
; 138  : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+8]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+20], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 139  : 
; 140  : 	kStream << m_iID;

	lea	ecx, DWORD PTR [edi+4]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 141  : 	kStream << m_eOwner;

	lea	edx, DWORD PTR [edi+8]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 142  : 	kStream << m_iCurrentX;

	lea	eax, DWORD PTR [edi+16]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 143  : 	kStream << m_iCurrentY;

	lea	ecx, DWORD PTR [edi+20]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 144  : 	kStream << m_iGoalX;

	lea	edx, DWORD PTR [edi+24]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 145  : 	kStream << m_iGoalY;

	lea	eax, DWORD PTR [edi+28]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 146  : 	kStream << m_eDomainType;

	lea	ecx, DWORD PTR [edi+32]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 147  : 	kStream << m_iFormationIndex;

	lea	edx, DWORD PTR [edi+36]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 148  : 	kStream << m_eAIState;

	lea	eax, DWORD PTR [edi+40]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 149  : 	kStream << m_iOperationID;

	lea	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 150  : 
; 151  : 	kStream << (int)m_FormationEntries.size();

	mov	edx, DWORD PTR [edi+48]
	lea	eax, DWORD PTR $T219629[esp+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T219629[esp+16], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 152  : 	for(uint ui = 0; ui < m_FormationEntries.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [edi+48], ebp
	jbe	SHORT $LN1@write
	mov	DWORD PTR tv224[esp+12], ebp
	push	ebx
	npad	3
$LL44@write:

; 153  : 	{
; 154  : 		kStream << m_FormationEntries[ui];

	mov	ebx, DWORD PTR [edi+44]
	add	ebx, DWORD PTR tv224[esp+16]
	mov	ecx, esi
	push	ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	ecx, DWORD PTR [ebx+4]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 8
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	DWORD PTR tv224[esp+16], 12		; 0000000cH
	inc	ebp
	cmp	ebp, DWORD PTR [edi+48]
	jb	SHORT $LL44@write
	pop	ebx
$LN1@write:
	pop	edi
	pop	esi
	pop	ebp

; 155  : 	}
; 156  : }

	pop	ecx
	ret	4
?write@CvArmyAI@@UBEXAAVFDataStream@@@Z ENDP		; CvArmyAI::write
_TEXT	ENDS
PUBLIC	?GetTeam@CvArmyAI@@QBE?AW4TeamTypes@@XZ		; CvArmyAI::GetTeam
; Function compile flags: /Ogtpy
;	COMDAT ?GetTeam@CvArmyAI@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?GetTeam@CvArmyAI@@QBE?AW4TeamTypes@@XZ PROC		; CvArmyAI::GetTeam, COMDAT
; _this$ = ecx

; 175  : 	if(GetOwner() != NO_PLAYER)

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, -1
	je	SHORT $LN1@GetTeam

; 176  : 	{
; 177  : 		return GET_PLAYER(GetOwner()).getTeam();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@GetTeam
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]

; 181  : }

	ret	0
$LN1@GetTeam:

; 178  : 	}
; 179  : 
; 180  : 	return NO_TEAM;

	or	eax, -1

; 181  : }

	ret	0
?GetTeam@CvArmyAI@@QBE?AW4TeamTypes@@XZ ENDP		; CvArmyAI::GetTeam
_TEXT	ENDS
PUBLIC	?UpdateCheckpointTurns@CvArmyAI@@QAEXXZ		; CvArmyAI::UpdateCheckpointTurns
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateCheckpointTurns@CvArmyAI@@QAEXXZ
_TEXT	SEGMENT
_iI$217771 = -12					; size = 4
tv426 = -8						; size = 4
$T219737 = -4						; size = 4
_pUnit$217776 = -4					; size = 4
?UpdateCheckpointTurns@CvArmyAI@@QAEXXZ PROC		; CvArmyAI::UpdateCheckpointTurns, COMDAT
; _this$ = ecx

; 450  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	mov	ebx, ecx

; 451  : 	for(unsigned int iI = 0; iI < m_FormationEntries.size(); iI++)

	cmp	DWORD PTR [ebx+48], 0
	push	esi
	push	edi
	mov	DWORD PTR _iI$217771[esp+28], 0
	jbe	$LN4@UpdateChec
	mov	DWORD PTR tv426[esp+28], 0
$LL6@UpdateChec:

; 452  : 	{
; 453  : 		// No reestimate for units being built
; 454  : 		if(m_FormationEntries[iI].GetUnitID() != ARMY_NO_UNIT)

	mov	eax, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR tv426[esp+28]
	add	eax, ecx
	cmp	DWORD PTR [eax], -1
	je	$LN5@UpdateChec

; 455  : 		{
; 456  : 			CvUnit* pUnit = GET_PLAYER(m_eOwner).getUnit(m_FormationEntries[iI].GetUnitID());

	mov	ecx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 457  : 			CvPlot* pMusterPlot = GC.getMap().plot(GetX(), GetY());

	mov	ecx, DWORD PTR [ebx+20]
	mov	edx, eax
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _pUnit$217776[esp+28], edx
	cmp	eax, -2147483647			; 80000001H
	je	$LN28@UpdateChec
	cmp	ecx, -2147483647			; 80000001H
	je	$LN28@UpdateChec
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [edx+4056]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [esi+4020]
	test	dl, dl
	je	SHORT $LN38@UpdateChec
	test	eax, eax
	jge	SHORT $LN40@UpdateChec
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN42@UpdateChec
$LN40@UpdateChec:
	cmp	eax, esi
	jl	SHORT $LN38@UpdateChec
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN42@UpdateChec
$LN38@UpdateChec:
	mov	edi, eax
$LN42@UpdateChec:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN48@UpdateChec
	test	ecx, ecx
	jge	SHORT $LN50@UpdateChec
	mov	eax, ecx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN52@UpdateChec
$LN50@UpdateChec:
	cmp	ecx, ebp
	jl	SHORT $LN48@UpdateChec
	mov	eax, ecx
	cdq
	idiv	ebp
	jmp	SHORT $LN52@UpdateChec
$LN48@UpdateChec:
	mov	edx, ecx
$LN52@UpdateChec:
	test	edi, edi
	jl	SHORT $LN32@UpdateChec
	cmp	edi, esi
	jge	SHORT $LN32@UpdateChec
	test	edx, edx
	jl	SHORT $LN32@UpdateChec
	cmp	edx, ebp
	jge	SHORT $LN32@UpdateChec
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	esi, edx
	mov	edx, DWORD PTR _pUnit$217776[esp+28]
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [eax+4068]
	jmp	SHORT $LN30@UpdateChec
$LN32@UpdateChec:
	mov	edx, DWORD PTR _pUnit$217776[esp+28]
$LN28@UpdateChec:
	xor	esi, esi
$LN30@UpdateChec:

; 458  : 			if(pUnit && pMusterPlot)

	test	edx, edx
	je	SHORT $LN5@UpdateChec
	test	esi, esi
	je	SHORT $LN5@UpdateChec

; 459  : 			{
; 460  : 				int iTurnsToReachCheckpoint = TurnsToReachTarget(pUnit, pMusterPlot, true /*bReusePaths*/, true, true);

	push	1
	push	1
	push	1
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edx
	mov	DWORD PTR $T219737[esp+52], esp
	mov	DWORD PTR [eax], edx
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 461  : 				if(iTurnsToReachCheckpoint < MAX_INT)

	cmp	eax, 2147483647				; 7fffffffH
	jge	SHORT $LN5@UpdateChec

; 462  : 				{
; 463  : 					SetEstimatedTurn(iI, iTurnsToReachCheckpoint);

	mov	ecx, DWORD PTR _iI$217771[esp+28]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?SetEstimatedTurn@CvArmyAI@@QAEXHH@Z	; CvArmyAI::SetEstimatedTurn
$LN5@UpdateChec:
	mov	eax, DWORD PTR _iI$217771[esp+28]
	add	DWORD PTR tv426[esp+28], 12		; 0000000cH
	inc	eax
	mov	DWORD PTR _iI$217771[esp+28], eax
	cmp	eax, DWORD PTR [ebx+48]
	jb	$LL6@UpdateChec
$LN4@UpdateChec:

; 464  : 				}
; 465  : 			}
; 466  : 		}
; 467  : 	}
; 468  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
?UpdateCheckpointTurns@CvArmyAI@@QAEXXZ ENDP		; CvArmyAI::UpdateCheckpointTurns
_TEXT	ENDS
PUBLIC	?GetTotalPower@CvArmyAI@@QAEHXZ			; CvArmyAI::GetTotalPower
EXTRN	?GetPower@CvUnit@@QBEHXZ:PROC			; CvUnit::GetPower
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetTotalPower@CvArmyAI@@QAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTotalPower@CvArmyAI@@QAEHXZ$0
__ehfuncinfo$?GetTotalPower@CvArmyAI@@QAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetTotalPower@CvArmyAI@@QAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
xdata$x	ENDS
;	COMDAT ?GetTotalPower@CvArmyAI@@QAEHXZ
_TEXT	SEGMENT
_iRtnValue$ = -24					; size = 4
_pThisUnit$217820 = -20					; size = 8
__$EHRec$ = -12						; size = 12
?GetTotalPower@CvArmyAI@@QAEHXZ PROC			; CvArmyAI::GetTotalPower, COMDAT
; _this$ = ecx

; 525  : {

	push	-1
	push	__ehhandler$?GetTotalPower@CvArmyAI@@QAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 526  : 	int iRtnValue = 0;

	xor	esi, esi
	push	edi
	mov	ebp, ecx
	xor	ebx, ebx
	mov	DWORD PTR _iRtnValue$[esp+40], esi

; 527  : 	int iUnitID;
; 528  : 	iUnitID = GetFirstUnitID();

	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	edi, eax

; 529  : 
; 530  : 	while(iUnitID != ARMY_NO_UNIT)

	cmp	edi, -1
	je	$LN26@GetTotalPo
	npad	10
$LL3@GetTotalPo:

; 531  : 	{
; 532  : 		UnitHandle pThisUnit = GET_PLAYER(GetOwner()).getUnit(iUnitID);

	mov	eax, DWORD PTR [ebp+8]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	ecx, eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pThisUnit$217820[esp+40], esi
	mov	BYTE PTR _pThisUnit$217820[esp+44], bl
	cmp	esi, ebx
	je	SHORT $LN14@GetTotalPo
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN14@GetTotalPo:
	mov	DWORD PTR __$EHRec$[esp+48], ebx

; 533  : 		if(pThisUnit)

	cmp	esi, ebx
	je	SHORT $LN1@GetTotalPo

; 534  : 		{
; 535  : 			iRtnValue += pThisUnit->GetPower();

	mov	ecx, esi
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	add	DWORD PTR _iRtnValue$[esp+40], eax
$LN1@GetTotalPo:

; 536  : 		}
; 537  : 		iUnitID = GetNextUnitID();

	mov	ecx, ebp
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	edi, eax

; 538  : 	}

	mov	DWORD PTR __$EHRec$[esp+48], -1
	cmp	esi, ebx
	je	SHORT $LN23@GetTotalPo
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@GetTotalPo:

; 529  : 
; 530  : 	while(iUnitID != ARMY_NO_UNIT)

	cmp	edi, -1
	jne	SHORT $LL3@GetTotalPo

; 539  : 
; 540  : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[esp+40]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 541  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	0
$LN26@GetTotalPo:
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTotalPower@CvArmyAI@@QAEHXZ$0:
	lea	ecx, DWORD PTR _pThisUnit$217820[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetTotalPower@CvArmyAI@@QAEHXZ:
	mov	eax, OFFSET __ehfuncinfo$?GetTotalPower@CvArmyAI@@QAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTotalPower@CvArmyAI@@QAEHXZ ENDP			; CvArmyAI::GetTotalPower
PUBLIC	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ		; CvArmyAI::Plot
; Function compile flags: /Ogtpy
;	COMDAT ?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ PROC			; CvArmyAI::Plot, COMDAT
; _this$ = ecx

; 579  : 	return GC.getMap().plotCheckInvalid(m_iCurrentX, m_iCurrentY);

	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx+16]
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN5@Plot
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN5@Plot
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [esi+4020]
	imul	eax, edx
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [esi+4068]
	pop	esi

; 580  : }

	ret	0

; 579  : 	return GC.getMap().plotCheckInvalid(m_iCurrentX, m_iCurrentY);

$LN5@Plot:
	xor	eax, eax

; 580  : }

	ret	0
?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ ENDP			; CvArmyAI::Plot
_TEXT	ENDS
PUBLIC	?GetArea@CvArmyAI@@QBEHXZ			; CvArmyAI::GetArea
; Function compile flags: /Ogtpy
;	COMDAT ?GetArea@CvArmyAI@@QBEHXZ
_TEXT	SEGMENT
?GetArea@CvArmyAI@@QBEHXZ PROC				; CvArmyAI::GetArea, COMDAT
; _this$ = ecx

; 585  : 	// try to find what plot we are in
; 586  : 	CvPlot* pPlot = GC.getMap().plotCheckInvalid(m_iCurrentX, m_iCurrentY);

	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx+16]
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN2@GetArea
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN2@GetArea
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [esi+4020]
	imul	eax, edx
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [esi+4068]
	pop	esi

; 587  : 	if(pPlot != NULL)

	je	SHORT $LN2@GetArea

; 588  : 	{
; 589  : 		return pPlot->getArea();

	mov	eax, DWORD PTR [eax+356]

; 595  : 	}
; 596  : }

	ret	0
$LN2@GetArea:

; 590  : 	}
; 591  : 	else
; 592  : 	{
; 593  : 		// since there is no plot return the invalid index
; 594  : 		return FFreeList::INVALID_INDEX;

	or	eax, -1

; 595  : 	}
; 596  : }

	ret	0
?GetArea@CvArmyAI@@QBEHXZ ENDP				; CvArmyAI::GetArea
_TEXT	ENDS
PUBLIC	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ		; CvArmyAI::GetGoalPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ PROC		; CvArmyAI::GetGoalPlot, COMDAT
; _this$ = ecx

; 633  : 	return GC.getMap().plotCheckInvalid(m_iGoalX, m_iGoalY);

	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [ecx+24]
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN5@GetGoalPlo
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN5@GetGoalPlo
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [esi+4020]
	imul	eax, edx
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [esi+4068]
	pop	esi

; 634  : }

	ret	0

; 633  : 	return GC.getMap().plotCheckInvalid(m_iGoalX, m_iGoalY);

$LN5@GetGoalPlo:
	xor	eax, eax

; 634  : }

	ret	0
?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ ENDP		; CvArmyAI::GetGoalPlot
_TEXT	ENDS
PUBLIC	?AddUnit@CvArmyAI@@QAEXHH@Z			; CvArmyAI::AddUnit
EXTRN	?removeFromArmy@CvPlayer@@QAE_NHH@Z:PROC	; CvPlayer::removeFromArmy
EXTRN	?getArmyID@CvUnit@@QBEHXZ:PROC			; CvUnit::getArmyID
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?AddUnit@CvArmyAI@@QAEXHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddUnit@CvArmyAI@@QAEXHH@Z$0
__ehfuncinfo$?AddUnit@CvArmyAI@@QAEXHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddUnit@CvArmyAI@@QAEXHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
xdata$x	ENDS
;	COMDAT ?AddUnit@CvArmyAI@@QAEXHH@Z
_TEXT	SEGMENT
_pThisUnit$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
$T220028 = 8						; size = 4
_iUnitID$ = 8						; size = 4
_iSlotNum$ = 12						; size = 4
?AddUnit@CvArmyAI@@QAEXHH@Z PROC			; CvArmyAI::AddUnit, COMDAT
; _this$ = ecx

; 676  : {

	push	-1
	push	__ehhandler$?AddUnit@CvArmyAI@@QAEXHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 677  : 	CvAssertMsg(iUnitID != ARMY_NO_UNIT,"Expect unit to be non-NULL");
; 678  : 
; 679  : 	CvPlayer& thisPlayer = GET_PLAYER(m_eOwner);
; 680  : 	UnitHandle pThisUnit = thisPlayer.getUnit(iUnitID);

	mov	ebx, DWORD PTR _iUnitID$[esp+20]
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, DWORD PTR [esi+8]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	mov	ecx, edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebp, eax
	mov	DWORD PTR _pThisUnit$[esp+36], ebp
	mov	BYTE PTR _pThisUnit$[esp+40], 0
	test	ebp, ebp
	je	SHORT $LN12@AddUnit
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@AddUnit:

; 681  : 
; 682  : 	// remove this unit from an army if it is already in one
; 683  : 	thisPlayer.removeFromArmy(pThisUnit->getArmyID(), GetID());

	mov	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+48], 0
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	push	eax
	mov	ecx, edi
	call	?removeFromArmy@CvPlayer@@QAE_NHH@Z	; CvPlayer::removeFromArmy

; 684  : 
; 685  : 	m_FormationEntries[iSlotNum].SetUnitID(iUnitID);

	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR _iSlotNum$[esp+32]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax], ebx

; 686  : 	pThisUnit->setArmyID(GetID());

	mov	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, ebp
	call	?setArmyID@CvUnit@@QAEXH@Z		; CvUnit::setArmyID

; 687  : 
; 688  : 	// Finally, compute when we think this unit will arrive at the next checkpoint
; 689  : 	CvPlot* pMusterPlot = GC.getMap().plot(GetX(), GetY());

	mov	eax, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [esi+20]
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@AddUnit
	cmp	edi, -2147483647			; 80000001H
	je	$LN1@AddUnit
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	bl, BYTE PTR [edx+4056]
	mov	ecx, DWORD PTR [edx+4020]
	test	bl, bl
	je	SHORT $LN42@AddUnit
	test	eax, eax
	jge	SHORT $LN44@AddUnit
	cdq
	idiv	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ebx, ecx
	jmp	SHORT $LN46@AddUnit
$LN44@AddUnit:
	cmp	eax, ecx
	jl	SHORT $LN42@AddUnit
	cdq
	idiv	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN46@AddUnit
$LN42@AddUnit:
	mov	ebx, eax
$LN46@AddUnit:
	mov	al, BYTE PTR [edx+4057]
	mov	edx, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN52@AddUnit
	test	edi, edi
	jge	SHORT $LN54@AddUnit
	mov	eax, edi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edi, DWORD PTR [edi+4024]
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN56@AddUnit
$LN54@AddUnit:
	cmp	edi, edx
	jl	SHORT $LN52@AddUnit
	mov	eax, edi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cdq
	idiv	DWORD PTR [edi+4024]
	jmp	SHORT $LN56@AddUnit
$LN52@AddUnit:
	mov	edx, edi
$LN56@AddUnit:
	test	ebx, ebx
	jl	SHORT $LN1@AddUnit
	cmp	ebx, ecx
	jge	SHORT $LN1@AddUnit
	test	edx, edx
	jl	SHORT $LN1@AddUnit
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	edx, DWORD PTR [eax+4024]
	jge	SHORT $LN1@AddUnit
	imul	ecx, edx
	add	ecx, ebx
	imul	ecx, 484				; 000001e4H
	mov	edx, eax
	add	ecx, DWORD PTR [edx+4068]

; 690  : 	if(pMusterPlot)

	test	ecx, ecx
	je	SHORT $LN1@AddUnit

; 691  : 	{
; 692  : 		int iTurnsToReachCheckpoint = TurnsToReachTarget(pThisUnit, pMusterPlot, true /*bReusePaths*/, true, true);

	push	1
	push	1
	push	1
	push	ecx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T220028[esp+56], esp
	mov	DWORD PTR [eax], ebp
	mov	BYTE PTR [eax+4], 0
	test	ebp, ebp
	je	SHORT $LN73@AddUnit
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN73@AddUnit:
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 693  : 		if(iTurnsToReachCheckpoint < MAX_INT)

	cmp	eax, 2147483647				; 7fffffffH
	jge	SHORT $LN1@AddUnit

; 694  : 		{
; 695  : 			SetEstimatedTurn(iSlotNum, iTurnsToReachCheckpoint);

	push	eax
	mov	eax, DWORD PTR _iSlotNum$[esp+36]
	push	eax
	mov	ecx, esi
	call	?SetEstimatedTurn@CvArmyAI@@QAEXHH@Z	; CvArmyAI::SetEstimatedTurn
$LN1@AddUnit:

; 696  : 		}
; 697  : 	}
; 698  : }

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	ebp, ebp
	je	SHORT $LN78@AddUnit
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN78@AddUnit:
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddUnit@CvArmyAI@@QAEXHH@Z$0:
	lea	ecx, DWORD PTR _pThisUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?AddUnit@CvArmyAI@@QAEXHH@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddUnit@CvArmyAI@@QAEXHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddUnit@CvArmyAI@@QAEXHH@Z ENDP			; CvArmyAI::AddUnit
PUBLIC	?RemoveUnit@CvArmyAI@@QAE_NH@Z			; CvArmyAI::RemoveUnit
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?RemoveUnit@CvArmyAI@@QAE_NH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveUnit@CvArmyAI@@QAE_NH@Z$0
__ehfuncinfo$?RemoveUnit@CvArmyAI@@QAE_NH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RemoveUnit@CvArmyAI@@QAE_NH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
xdata$x	ENDS
;	COMDAT ?RemoveUnit@CvArmyAI@@QAE_NH@Z
_TEXT	SEGMENT
_iI$217908 = -36					; size = 4
_pThisUnit$217914 = -32					; size = 8
_slot$ = -24						; size = 12
__$EHRec$ = -12						; size = 12
_iUnitToRemoveID$ = 8					; size = 4
?RemoveUnit@CvArmyAI@@QAE_NH@Z PROC			; CvArmyAI::RemoveUnit, COMDAT
; _this$ = ecx

; 702  : {

	push	-1
	push	__ehhandler$?RemoveUnit@CvArmyAI@@QAE_NH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi

; 703  : 	bool bWasOneOrMoreRemoved = false;
; 704  : 	CvArmyFormationSlot slot;
; 705  : 
; 706  : 	for(int iI = 0; iI < (int)m_FormationEntries.size(); iI++)

	xor	ebp, ebp
	mov	esi, ecx
	xor	bl, bl
	cmp	DWORD PTR [esi+48], ebp
	mov	DWORD PTR _iI$217908[esp+48], ebp
	jle	$LN48@RemoveUnit
	push	edi
	npad	1
$LL6@RemoveUnit:

; 707  : 	{
; 708  : 		slot = m_FormationEntries[iI];

	mov	eax, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax+ebp+4]
	mov	ecx, DWORD PTR [eax+ebp]
	add	eax, ebp
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _slot$[esp+56], edx

; 709  : 		if(slot.GetUnitID() == iUnitToRemoveID)

	mov	edx, DWORD PTR _iUnitToRemoveID$[esp+48]
	mov	DWORD PTR _slot$[esp+60], eax
	cmp	ecx, edx
	jne	$LN5@RemoveUnit

; 710  : 		{
; 711  : 			UnitHandle pThisUnit = GET_PLAYER(GetOwner()).getUnit(iUnitToRemoveID);

	mov	eax, DWORD PTR [esi+8]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pThisUnit$217914[esp+52], edi
	mov	BYTE PTR _pThisUnit$217914[esp+56], 0
	test	edi, edi
	je	SHORT $LN25@RemoveUnit
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN25@RemoveUnit:
	mov	DWORD PTR __$EHRec$[esp+60], 0

; 712  : 			if(pThisUnit)

	test	edi, edi
	je	SHORT $LN49@RemoveUnit

; 713  : 			{
; 714  : 				// Clears unit's army ID and erase from formation entries
; 715  : 				pThisUnit->setArmyID(FFreeList::INVALID_INDEX);

	push	-1
	mov	ecx, edi
	call	?setArmyID@CvUnit@@QAEXH@Z		; CvUnit::setArmyID

; 716  : 				m_FormationEntries[iI].SetUnitID(ARMY_NO_UNIT);

	mov	eax, DWORD PTR [esi+44]
	add	eax, ebp
	mov	DWORD PTR [eax], -1

; 717  : 				bWasOneOrMoreRemoved = true;
; 718  : 
; 719  : 				// Tell the associate operation that a unit was lost
; 720  : 				CvAIOperation* pThisOperation = GET_PLAYER(GetOwner()).getAIOperation(m_iOperationID);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	mov	bl, 1
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation

; 721  : 				if(pThisOperation)

	test	eax, eax
	je	SHORT $LN49@RemoveUnit

; 722  : 				{
; 723  : 					pThisOperation->UnitWasRemoved(GetID(), iI);

	mov	ecx, DWORD PTR [esi+4]
	push	DWORD PTR _iI$217908[esp+52]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+116]
	call	eax
$LN49@RemoveUnit:

; 724  : 				}
; 725  : 			}
; 726  : 		}

	mov	DWORD PTR __$EHRec$[esp+60], -1
	test	edi, edi
	je	SHORT $LN5@RemoveUnit
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@RemoveUnit:
	mov	eax, DWORD PTR _iI$217908[esp+52]
	inc	eax
	add	ebp, 12					; 0000000cH
	cmp	eax, DWORD PTR [esi+48]
	mov	DWORD PTR _iI$217908[esp+52], eax
	jl	$LL6@RemoveUnit
	pop	edi
$LN48@RemoveUnit:

; 727  : 	}
; 728  : 
; 729  : 	return bWasOneOrMoreRemoved;
; 730  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 36					; 00000024H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RemoveUnit@CvArmyAI@@QAE_NH@Z$0:
	lea	ecx, DWORD PTR _pThisUnit$217914[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?RemoveUnit@CvArmyAI@@QAE_NH@Z:
	mov	eax, OFFSET __ehfuncinfo$?RemoveUnit@CvArmyAI@@QAE_NH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RemoveUnit@CvArmyAI@@QAE_NH@Z ENDP			; CvArmyAI::RemoveUnit
PUBLIC	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetFirstUnit
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ$1
__ehfuncinfo$?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
xdata$x	ENDS
;	COMDAT ?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ
_TEXT	SEGMENT
$T220292 = -24						; size = 4
$T220290 = -20						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ PROC ; CvArmyAI::GetFirstUnit, COMDAT
; _this$ = ecx

; 801  : {

	push	-1
	push	__ehhandler$?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T220292[esp+32], ebx
	push	edi

; 802  : 	UnitHandle pRtnValue;

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+32]
	mov	esi, ecx
	mov	DWORD PTR [edi], ebx
	mov	BYTE PTR [edi+4], bl

; 808  : 
; 809  : 		FAssertMsg(pRtnValue, "Bogus unit in army - tell Ed");
; 810  : 	}
; 811  : 
; 812  : 	return pRtnValue;

	mov	DWORD PTR __$EHRec$[esp+44], ebx
	mov	DWORD PTR $T220292[esp+36], 1
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	cmp	eax, -1
	je	SHORT $LN31@GetFirstUn@2
	mov	ecx, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR $T220290[esp+36], esi
	mov	BYTE PTR $T220290[esp+40], bl
	cmp	esi, ebx
	je	SHORT $LN14@GetFirstUn@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN14@GetFirstUn@2:
	lea	eax, DWORD PTR $T220290[esp+36]
	mov	DWORD PTR __$EHRec$[esp+44], 1
	cmp	eax, edi
	je	SHORT $LN23@GetFirstUn@2
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, ebx
	je	SHORT $LN21@GetFirstUn@2

; 803  : 
; 804  : 	int iUnitID = GetFirstUnitID();
; 805  : 	if(iUnitID != ARMY_NO_UNIT)
; 806  : 	{
; 807  : 		pRtnValue = UnitHandle(GET_PLAYER(m_eOwner).getUnit(iUnitID));

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN21@GetFirstUn@2:
	mov	DWORD PTR [edi], esi
	cmp	esi, ebx
	je	SHORT $LN23@GetFirstUn@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@GetFirstUn@2:
	mov	BYTE PTR __$EHRec$[esp+44], bl
	cmp	esi, ebx
	je	SHORT $LN31@GetFirstUn@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN31@GetFirstUn@2:

; 813  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ$0:
	mov	eax, DWORD PTR $T220292[ebp]
	and	eax, 1
	je	$LN5@GetFirstUn@2
	and	DWORD PTR $T220292[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
$LN5@GetFirstUn@2:
	ret	0
__unwindfunclet$?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ$1:
	lea	ecx, DWORD PTR $T220290[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ENDP ; CvArmyAI::GetFirstUnit
PUBLIC	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetNextUnit
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ$1
__ehfuncinfo$?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
xdata$x	ENDS
;	COMDAT ?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ
_TEXT	SEGMENT
$T220351 = -24						; size = 4
$T220349 = -20						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ PROC ; CvArmyAI::GetNextUnit, COMDAT
; _this$ = ecx

; 817  : {

	push	-1
	push	__ehhandler$?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T220351[esp+28], ebx
	push	edi

; 818  : 	UnitHandle pRtnValue;

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	DWORD PTR [edi], ebx
	mov	BYTE PTR [edi+4], bl

; 824  : 
; 825  : 		FAssertMsg(pRtnValue, "Bogus unit in army - tell Ed");
; 826  : 	}
; 827  : 
; 828  : 	return pRtnValue;

	mov	DWORD PTR __$EHRec$[esp+40], ebx
	mov	DWORD PTR $T220351[esp+32], 1
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	cmp	eax, -1
	je	SHORT $LN31@GetNextUni@2
	mov	ecx, DWORD PTR [ecx+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR $T220349[esp+36], esi
	mov	BYTE PTR $T220349[esp+40], bl
	cmp	esi, ebx
	je	SHORT $LN14@GetNextUni@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN14@GetNextUni@2:
	lea	eax, DWORD PTR $T220349[esp+36]
	mov	DWORD PTR __$EHRec$[esp+44], 1
	cmp	eax, edi
	je	SHORT $LN23@GetNextUni@2
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, ebx
	je	SHORT $LN21@GetNextUni@2

; 819  : 
; 820  : 	int iUnitID = GetNextUnitID();
; 821  : 	if(iUnitID != ARMY_NO_UNIT)
; 822  : 	{
; 823  : 		pRtnValue = UnitHandle(GET_PLAYER(m_eOwner).getUnit(iUnitID));

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN21@GetNextUni@2:
	mov	DWORD PTR [edi], esi
	cmp	esi, ebx
	je	SHORT $LN23@GetNextUni@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@GetNextUni@2:
	mov	BYTE PTR __$EHRec$[esp+44], bl
	cmp	esi, ebx
	je	SHORT $LN30@GetNextUni@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@GetNextUni@2:
	pop	esi

; 824  : 
; 825  : 		FAssertMsg(pRtnValue, "Bogus unit in army - tell Ed");
; 826  : 	}
; 827  : 
; 828  : 	return pRtnValue;

	mov	eax, edi
	pop	edi
	pop	ebx

; 829  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	4
$LN31@GetNextUni@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	eax, edi
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ$0:
	mov	eax, DWORD PTR $T220351[ebp]
	and	eax, 1
	je	$LN5@GetNextUni@2
	and	DWORD PTR $T220351[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
$LN5@GetNextUni@2:
	ret	0
__unwindfunclet$?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ$1:
	lea	ecx, DWORD PTR $T220349[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ENDP ; CvArmyAI::GetNextUnit
PUBLIC	?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z ; CvArmyAI::GetFirstUnitInDomain
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z$4
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
xdata$x	ENDS
;	COMDAT ?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z
_TEXT	SEGMENT
$T220415 = -40						; size = 4
_pCurrentUnit$ = -36					; size = 8
_pUnit$ = -28						; size = 8
$T220410 = -20						; size = 8
$T220409 = -20						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_eDomain$ = 12						; size = 4
?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z PROC ; CvArmyAI::GetFirstUnitInDomain, COMDAT
; _this$ = ecx

; 833  : {

	push	-1
	push	__ehhandler$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T220415[esp+52], ebx
	push	edi
	mov	ebp, ecx

; 834  : 	UnitHandle pUnit, pCurrentUnit;

	mov	DWORD PTR _pUnit$[esp+56], ebx
	mov	BYTE PTR _pUnit$[esp+60], bl
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+64], 1
	mov	DWORD PTR _pCurrentUnit$[esp+56], esi
	mov	BYTE PTR _pCurrentUnit$[esp+60], bl

; 835  : 
; 836  : 	pCurrentUnit = GetFirstUnit();

	lea	eax, DWORD PTR $T220409[esp+56]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+68], 2
	call	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetFirstUnit
	lea	ecx, DWORD PTR _pCurrentUnit$[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 3
	cmp	eax, ecx
	je	SHORT $LN25@GetFirstUn@3
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _pCurrentUnit$[esp+56], esi
	cmp	esi, ebx
	je	SHORT $LN25@GetFirstUn@3
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN25@GetFirstUn@3:
	mov	ecx, DWORD PTR $T220409[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 2
	cmp	ecx, ebx
	je	SHORT $LN86@GetFirstUn@3
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN86@GetFirstUn@3:

; 837  : 	while(pCurrentUnit)

	cmp	esi, ebx
	je	SHORT $LN4@GetFirstUn@3
$LL5@GetFirstUn@3:

; 838  : 	{
; 839  : 		if(pCurrentUnit->plot()->isWater() && eDomain == DOMAIN_SEA || !pCurrentUnit->plot()->isWater() && eDomain == DOMAIN_LAND)

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN87@GetFirstUn@3
	cmp	DWORD PTR _eDomain$[esp+52], ebx
	je	$LN2@GetFirstUn@3
$LN87@GetFirstUn@3:
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 3
	je	SHORT $LN3@GetFirstUn@3
	cmp	DWORD PTR _eDomain$[esp+52], 2
	je	$LN2@GetFirstUn@3
$LN3@GetFirstUn@3:

; 842  : 		}
; 843  : 		pCurrentUnit = GetNextUnit();

	lea	edx, DWORD PTR $T220410[esp+56]
	push	edx
	mov	ecx, ebp
	call	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetNextUnit
	mov	edi, eax
	lea	eax, DWORD PTR _pCurrentUnit$[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 4
	cmp	edi, eax
	je	SHORT $LN64@GetFirstUn@3
	cmp	esi, ebx
	je	SHORT $LN62@GetFirstUn@3
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN62@GetFirstUn@3:
	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR _pCurrentUnit$[esp+56], esi
	cmp	esi, ebx
	je	SHORT $LN64@GetFirstUn@3
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN64@GetFirstUn@3:
	mov	ecx, DWORD PTR $T220410[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 2
	cmp	ecx, ebx
	je	SHORT $LN69@GetFirstUn@3
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN69@GetFirstUn@3:

; 837  : 	while(pCurrentUnit)

	cmp	esi, ebx
	jne	SHORT $LL5@GetFirstUn@3
$LN4@GetFirstUn@3:

; 844  : 	}
; 845  : 
; 846  : 	return pUnit;

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+52]
	mov	DWORD PTR [edi], ebx
	mov	BYTE PTR [edi+4], bl
$LN91@GetFirstUn@3:
	mov	BYTE PTR __$EHRec$[esp+64], 1
	mov	DWORD PTR $T220415[esp+56], 1
	cmp	esi, ebx
	je	SHORT $LN79@GetFirstUn@3
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN79@GetFirstUn@3:

; 847  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
$LN2@GetFirstUn@3:

; 840  : 		{
; 841  : 			return pCurrentUnit;

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+52]
	mov	DWORD PTR [edi], esi
	mov	BYTE PTR [edi+4], bl
	cmp	esi, ebx
	je	SHORT $LN45@GetFirstUn@3
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN45@GetFirstUn@3:
	jmp	SHORT $LN91@GetFirstUn@3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z$1:
	lea	ecx, DWORD PTR _pCurrentUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z$2:
	lea	ecx, DWORD PTR $T220409[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z$4:
	lea	ecx, DWORD PTR $T220410[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z$3:
	mov	eax, DWORD PTR $T220415[ebp]
	and	eax, 1
	je	$LN12@GetFirstUn@3
	and	DWORD PTR $T220415[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
$LN12@GetFirstUn@3:
	ret	0
__ehhandler$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFirstUnitInDomain@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4DomainTypes@@@Z ENDP ; CvArmyAI::GetFirstUnitInDomain
PUBLIC	?DoDelayedDeath@CvArmyAI@@QAE_NXZ		; CvArmyAI::DoDelayedDeath
; Function compile flags: /Ogtpy
;	COMDAT ?DoDelayedDeath@CvArmyAI@@QAE_NXZ
_TEXT	SEGMENT
?DoDelayedDeath@CvArmyAI@@QAE_NXZ PROC			; CvArmyAI::DoDelayedDeath, COMDAT
; _this$ = ecx

; 860  : {

	mov	eax, DWORD PTR [ecx+48]
	push	esi

; 861  : 	if(GetNumSlotsFilled() == 0 && m_eAIState != ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE)

	xor	esi, esi
	test	eax, eax
	jbe	SHORT $LN16@DoDelayedD
	mov	edx, DWORD PTR [ecx+44]
	npad	3
$LL7@DoDelayedD:
	cmp	DWORD PTR [edx], -1
	je	SHORT $LN6@DoDelayedD
	inc	esi
$LN6@DoDelayedD:
	add	edx, 12					; 0000000cH
	sub	eax, 1
	jne	SHORT $LL7@DoDelayedD
	test	esi, esi
	jne	SHORT $LN1@DoDelayedD
$LN16@DoDelayedD:
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN1@DoDelayedD

; 862  : 	{
; 863  : 		Kill();

	call	?Kill@CvArmyAI@@QAEXXZ			; CvArmyAI::Kill

; 864  : 		return true;

	mov	al, 1
	pop	esi

; 868  : }

	ret	0
$LN1@DoDelayedD:

; 865  : 	}
; 866  : 
; 867  : 	return false;

	xor	al, al
	pop	esi

; 868  : }

	ret	0
?DoDelayedDeath@CvArmyAI@@QAE_NXZ ENDP			; CvArmyAI::DoDelayedDeath
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::~FStaticVector<CvArmyFormationSlot,20,1,297,0>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::~FStaticVector<CvArmyFormationSlot,20,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::~FStaticVector<CvArmyFormationSlot,20,1,297,0>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 20					; 00000014H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	lea	eax, DWORD PTR [ebp+ebp*2]
	push	OFFSET ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 20			; 00000014H
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*2]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+252], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	??_7CvArmyAI@@6B@				; CvArmyAI::`vftable'
PUBLIC	??0CvArmyAI@@QAE@XZ				; CvArmyAI::CvArmyAI
PUBLIC	??_R4CvArmyAI@@6B@				; CvArmyAI::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvArmyAI@@@8				; CvArmyAI `RTTI Type Descriptor'
PUBLIC	??_R3CvArmyAI@@8				; CvArmyAI::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvArmyAI@@8				; CvArmyAI::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvArmyAI@@8			; CvArmyAI::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?read@CvArmyAI@@UAEXAAVFDataStream@@@Z		; CvArmyAI::read
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECvArmyAI@@UAEPAXI@Z:PROC			; CvArmyAI::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvArmyAI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvArmyAI@@8 DD FLAT:??_R0?AVCvArmyAI@@@8	; CvArmyAI::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvArmyAI@@8
rdata$r	ENDS
;	COMDAT ??_R2CvArmyAI@@8
rdata$r	SEGMENT
??_R2CvArmyAI@@8 DD FLAT:??_R1A@?0A@EA@CvArmyAI@@8	; CvArmyAI::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvArmyAI@@8
rdata$r	SEGMENT
??_R3CvArmyAI@@8 DD 00H					; CvArmyAI::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvArmyAI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvArmyAI@@@8
_DATA	SEGMENT
??_R0?AVCvArmyAI@@@8 DD FLAT:??_7type_info@@6B@		; CvArmyAI `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvArmyAI@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvArmyAI@@6B@
rdata$r	SEGMENT
??_R4CvArmyAI@@6B@ DD 00H				; CvArmyAI::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvArmyAI@@@8
	DD	FLAT:??_R3CvArmyAI@@8
rdata$r	ENDS
;	COMDAT ??_7CvArmyAI@@6B@
CONST	SEGMENT
??_7CvArmyAI@@6B@ DD FLAT:??_R4CvArmyAI@@6B@		; CvArmyAI::`vftable'
	DD	FLAT:??_ECvArmyAI@@UAEPAXI@Z
	DD	FLAT:?read@CvArmyAI@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?write@CvArmyAI@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
CONST	ENDS
;	COMDAT ??0CvArmyAI@@QAE@XZ
_TEXT	SEGMENT
??0CvArmyAI@@QAE@XZ PROC				; CvArmyAI::CvArmyAI, COMDAT
; _this$ = ecx

; 31   : {

	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7CvArmyAI@@6B@
	mov	DWORD PTR [eax+52], 20			; 00000014H
	lea	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [eax+44], ecx

; 32   : #ifdef AUI_WARNING_FIXES
; 33   : 	Reset(0, NO_PLAYER, -1, true);
; 34   : #else
; 35   : 	Reset(0, NO_PLAYER, true);

	or	ecx, -1
	xor	edx, edx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], 1
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], 2
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+48], edx

; 36   : #endif
; 37   : }

	ret	0
??0CvArmyAI@@QAE@XZ ENDP				; CvArmyAI::CvArmyAI
_TEXT	ENDS
PUBLIC	??1CvArmyAI@@UAE@XZ				; CvArmyAI::~CvArmyAI
; Function compile flags: /Ogtpy
;	COMDAT ??1CvArmyAI@@UAE@XZ
_TEXT	SEGMENT
??1CvArmyAI@@UAE@XZ PROC				; CvArmyAI::~CvArmyAI, COMDAT
; _this$ = ecx

; 41   : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvArmyAI@@6B@

; 42   : 	Uninit();

	mov	DWORD PTR [ecx+48], 0

; 43   : }

	mov	eax, DWORD PTR [ecx+44]
	add	ecx, 56					; 00000038H
	cmp	eax, ecx
	je	SHORT $LN16@CvArmyAI
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN16@CvArmyAI:
	ret	0
??1CvArmyAI@@UAE@XZ ENDP				; CvArmyAI::~CvArmyAI
_TEXT	ENDS
PUBLIC	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z		; CvArmyAI::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_iOperationID$ = 16					; size = 4
?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z PROC		; CvArmyAI::Init, COMDAT
; _this$ = ecx

; 48   : 	//--------------------------------
; 49   : 	// Init saved data
; 50   : 	Reset(iID, eOwner, iOperationID);

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _eOwner$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _iOperationID$[esp-4]
	mov	DWORD PTR [ecx+12], eax
	or	eax, -1
	xor	edx, edx
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], eax
	mov	DWORD PTR [ecx+32], 2
	mov	DWORD PTR [ecx+36], eax
	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+48], edx

; 51   : }

	ret	12					; 0000000cH
?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z ENDP		; CvArmyAI::Init
_TEXT	ENDS
PUBLIC	?GetMovementRate@CvArmyAI@@QAEHXZ		; CvArmyAI::GetMovementRate
EXTRN	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z:PROC	; CvUnit::baseMoves
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetMovementRate@CvArmyAI@@QAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMovementRate@CvArmyAI@@QAEHXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMovementRate@CvArmyAI@@QAEHXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMovementRate@CvArmyAI@@QAEHXZ$2
__ehfuncinfo$?GetMovementRate@CvArmyAI@@QAEHXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetMovementRate@CvArmyAI@@QAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
xdata$x	ENDS
;	COMDAT ?GetMovementRate@CvArmyAI@@QAEHXZ
_TEXT	SEGMENT
_iTotalMovementAllowance$ = -40				; size = 4
_iMovementAverage$ = -36				; size = 4
_pUnit$ = -32						; size = 8
$T220913 = -24						; size = 8
$T220912 = -24						; size = 8
__$EHRec$ = -12						; size = 12
?GetMovementRate@CvArmyAI@@QAEHXZ PROC			; CvArmyAI::GetMovementRate, COMDAT
; _this$ = ecx

; 197  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?GetMovementRate@CvArmyAI@@QAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 198  : 	int iMovementAverage = 2;   // A reasonable default
; 199  : 	int iNumUnits = 0;

	xor	ebx, ebx

; 200  : 	int iTotalMovementAllowance = 0;
; 201  : 	UnitHandle pUnit;

	xor	esi, esi
	mov	DWORD PTR _iMovementAverage$[esp+56], 2
	mov	DWORD PTR _iTotalMovementAllowance$[esp+56], ebx
	mov	DWORD PTR _pUnit$[esp+56], esi
	mov	BYTE PTR _pUnit$[esp+60], bl

; 202  : 
; 203  : 	pUnit = GetFirstUnit();

	lea	eax, DWORD PTR $T220912[esp+56]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetFirstUnit
	lea	ecx, DWORD PTR _pUnit$[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 1
	cmp	eax, ecx
	je	SHORT $LN18@GetMovemen
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _pUnit$[esp+56], esi
	cmp	esi, ebx
	je	SHORT $LN18@GetMovemen
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN18@GetMovemen:
	mov	ecx, DWORD PTR $T220912[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 0
	cmp	ecx, ebx
	je	SHORT $LN48@GetMovemen
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN48@GetMovemen:

; 204  : 	while(pUnit)

	cmp	esi, ebx
	je	SHORT $LN1@GetMovemen
$LN3@GetMovemen:

; 205  : 	{
; 206  : 		iNumUnits++;
; 207  : 		iTotalMovementAllowance += pUnit->baseMoves();

	push	-1
	mov	ecx, esi
	inc	ebx
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	add	DWORD PTR _iTotalMovementAllowance$[esp+56], eax

; 208  : 		pUnit = GetNextUnit();

	lea	edx, DWORD PTR $T220913[esp+56]
	push	edx
	mov	ecx, ebp
	call	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetNextUnit
	mov	edi, eax
	lea	eax, DWORD PTR _pUnit$[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 2
	cmp	edi, eax
	je	SHORT $LN36@GetMovemen
	test	esi, esi
	je	SHORT $LN34@GetMovemen
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN34@GetMovemen:
	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR _pUnit$[esp+56], esi
	test	esi, esi
	je	SHORT $LN36@GetMovemen
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN36@GetMovemen:
	mov	ecx, DWORD PTR $T220913[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 0
	test	ecx, ecx
	je	SHORT $LN41@GetMovemen
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@GetMovemen:

; 204  : 	while(pUnit)

	test	esi, esi
	jne	SHORT $LN3@GetMovemen

; 209  : 	}
; 210  : 
; 211  : 	if(iNumUnits > 0)

	test	ebx, ebx
	jle	SHORT $LN1@GetMovemen

; 212  : 	{
; 213  : 		iMovementAverage = (iTotalMovementAllowance + (iNumUnits / 2)) / iNumUnits;

	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _iTotalMovementAllowance$[esp+56]
	cdq
	idiv	ebx
	mov	DWORD PTR _iMovementAverage$[esp+56], eax
$LN1@GetMovemen:

; 214  : 	}
; 215  : 
; 216  : 	return iMovementAverage;

	mov	DWORD PTR __$EHRec$[esp+64], -1
	test	esi, esi
	je	SHORT $LN49@GetMovemen
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN49@GetMovemen:

; 217  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	eax, DWORD PTR _iMovementAverage$[esp+56]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMovementRate@CvArmyAI@@QAEHXZ$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?GetMovementRate@CvArmyAI@@QAEHXZ$1:
	lea	ecx, DWORD PTR $T220912[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?GetMovementRate@CvArmyAI@@QAEHXZ$2:
	lea	ecx, DWORD PTR $T220913[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetMovementRate@CvArmyAI@@QAEHXZ:
	mov	eax, OFFSET __ehfuncinfo$?GetMovementRate@CvArmyAI@@QAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMovementRate@CvArmyAI@@QAEHXZ ENDP			; CvArmyAI::GetMovementRate
PUBLIC	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z$3
__ehfuncinfo$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
xdata$x	ENDS
;	COMDAT ?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z
_TEXT	SEGMENT
tv566 = -52						; size = 4
_pRtnValue$ = -52					; size = 4
tv772 = -48						; size = 4
_iTotalX$ = -48						; size = 4
tv569 = -44						; size = 4
_iReferenceUnitX$ = -44					; size = 4
_this$ = -40						; size = 4
tv582 = -36						; size = 4
tv493 = -36						; size = 4
$T221002 = -36						; size = 8
_pUnit$ = -28						; size = 8
$T221006 = -20						; size = 8
$T221003 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eDomainRequired$ = 8					; size = 4
?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z PROC ; CvArmyAI::GetCenterOfMass, COMDAT
; _this$ = ecx

; 221  : {

	push	-1
	push	__ehhandler$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	push	esi

; 222  : 	CvPlot* pRtnValue = NULL;

	xor	esi, esi
	push	edi
	mov	DWORD PTR _this$[esp+68], ecx
	mov	DWORD PTR _pRtnValue$[esp+68], esi

; 223  : 	int iTotalX = 0;

	mov	DWORD PTR _iTotalX$[esp+68], esi

; 224  : 	int iTotalY = 0;

	xor	ebp, ebp

; 225  : 	int iNumUnits = 0;

	xor	edi, edi

; 226  : 	UnitHandle pUnit;

	mov	DWORD PTR _pUnit$[esp+68], esi
	mov	BYTE PTR _pUnit$[esp+72], 0

; 227  : 	int iReferenceUnitX = -1;
; 228  : 	int iWorldWidth = GC.getMap().getGridWidth();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ebx, DWORD PTR [eax+4020]

; 229  : 
; 230  : 	pUnit = GetFirstUnit();

	lea	edx, DWORD PTR $T221002[esp+68]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+80], esi
	call	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetFirstUnit
	lea	ecx, DWORD PTR _pUnit$[esp+68]
	mov	BYTE PTR __$EHRec$[esp+76], 1
	cmp	eax, ecx
	je	SHORT $LN219@GetCenterO
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _pUnit$[esp+68], esi
	test	esi, esi
	je	SHORT $LN219@GetCenterO
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN219@GetCenterO:
	mov	ecx, DWORD PTR $T221002[esp+68]
	mov	BYTE PTR __$EHRec$[esp+76], 0
	test	ecx, ecx
	je	SHORT $LN55@GetCenterO
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN55@GetCenterO:

; 231  : 	if(pUnit)

	test	esi, esi
	je	$LN97@GetCenterO

; 232  : 	{
; 233  : 		iReferenceUnitX = pUnit->getX();

	mov	edx, DWORD PTR _pUnit$[esp+68]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR _iReferenceUnitX$[esp+68], eax
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv493[esp+68], eax
	npad	2
$LL29@GetCenterO:

; 237  : 	{
; 238  : 		int iUnitX = pUnit->getX();

	mov	ecx, DWORD PTR _pUnit$[esp+68]
	mov	ecx, DWORD PTR [ecx+76]

; 239  : 
; 240  : 		bool bWorldWrapAdjust = false;
; 241  : 		int iDiff = iUnitX - iReferenceUnitX;

	mov	eax, ecx
	sub	eax, DWORD PTR _iReferenceUnitX$[esp+68]

; 242  : 		if(abs(iDiff) > (iWorldWidth / 2))

	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, DWORD PTR tv493[esp+68]
	jle	SHORT $LN26@GetCenterO

; 243  : 		{
; 244  : 			bWorldWrapAdjust = true;
; 245  : 		}
; 246  : 
; 247  : 		if(bWorldWrapAdjust)
; 248  : 		{
; 249  : 			iTotalX += iUnitX + iWorldWidth;

	add	ecx, ebx
$LN26@GetCenterO:

; 250  : 		}
; 251  : 		else
; 252  : 		{
; 253  : 			iTotalX += iUnitX;

	add	DWORD PTR _iTotalX$[esp+68], ecx

; 254  : 		}
; 255  : 		iTotalY += pUnit->getY();

	mov	edx, DWORD PTR _pUnit$[esp+68]

; 256  : 		iNumUnits++;
; 257  : 		pUnit = GetNextUnit();

	mov	ecx, DWORD PTR _this$[esp+68]
	add	ebp, DWORD PTR [edx+88]
	lea	eax, DWORD PTR $T221003[esp+68]
	push	eax
	inc	edi
	call	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetNextUnit
	mov	esi, eax
	lea	ecx, DWORD PTR _pUnit$[esp+68]
	mov	BYTE PTR __$EHRec$[esp+76], 2
	cmp	esi, ecx
	je	SHORT $LN216@GetCenterO
	mov	ecx, DWORD PTR _pUnit$[esp+68]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR _pUnit$[esp+68], esi
	test	esi, esi
	je	SHORT $LN216@GetCenterO
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN216@GetCenterO:
	mov	ecx, DWORD PTR $T221003[esp+68]
	mov	BYTE PTR __$EHRec$[esp+76], 0
	test	ecx, ecx
	je	SHORT $LN91@GetCenterO
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN91@GetCenterO:

; 234  : 	}
; 235  : 
; 236  : 	while(pUnit)

	cmp	DWORD PTR _pUnit$[esp+68], 0
	jne	SHORT $LL29@GetCenterO

; 258  : 	}
; 259  : 
; 260  : 	if(iNumUnits > 0)

	test	edi, edi
	jle	$LN97@GetCenterO

; 261  : 	{
; 262  : 		int iAverageX = (iTotalX + (iNumUnits / 2)) / iNumUnits;

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iTotalX$[esp+68]
	mov	ecx, eax
	sar	ecx, 1
	lea	eax, DWORD PTR [ecx+edx]
	cdq
	idiv	edi
	mov	esi, eax

; 263  : 		if(iAverageX >= iWorldWidth)

	cmp	esi, ebx
	jl	SHORT $LN23@GetCenterO

; 264  : 		{
; 265  : 			iAverageX = iAverageX - iWorldWidth;

	sub	esi, ebx
$LN23@GetCenterO:

; 266  : 		}
; 267  : 		int iAverageY = (iTotalY + (iNumUnits / 2)) / iNumUnits;

	lea	eax, DWORD PTR [ecx+ebp]
	cdq
	idiv	edi
	mov	ebp, eax

; 268  : 		pRtnValue = GC.getMap().plot(iAverageX, iAverageY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN95@GetCenterO
	cmp	ebp, -2147483647			; 80000001H
	je	$LN95@GetCenterO
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	al, al
	je	SHORT $LN105@GetCenterO
	test	esi, esi
	jge	SHORT $LN107@GetCenterO
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN105@GetCenterO
$LN107@GetCenterO:
	cmp	esi, ecx
	jl	SHORT $LN105@GetCenterO
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN105@GetCenterO:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN115@GetCenterO
	test	ebp, ebp
	jge	SHORT $LN117@GetCenterO
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN119@GetCenterO
$LN117@GetCenterO:
	cmp	ebp, edi
	jl	SHORT $LN115@GetCenterO
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN119@GetCenterO
$LN115@GetCenterO:
	mov	edx, ebp
$LN119@GetCenterO:
	test	esi, esi
	jl	SHORT $LN95@GetCenterO
	cmp	esi, ecx
	jge	SHORT $LN95@GetCenterO
	test	edx, edx
	jl	SHORT $LN95@GetCenterO
	cmp	edx, edi
	jge	SHORT $LN95@GetCenterO
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	DWORD PTR _pRtnValue$[esp+68], ecx
	jmp	SHORT $LN97@GetCenterO
$LN95@GetCenterO:
	mov	DWORD PTR _pRtnValue$[esp+68], 0
$LN97@GetCenterO:

; 269  : 	}
; 270  : 
; 271  : 	// Domain check
; 272  : 	if (eDomainRequired != NO_DOMAIN && pRtnValue)

	mov	ecx, DWORD PTR _eDomainRequired$[esp+64]
	mov	esi, DWORD PTR _pRtnValue$[esp+68]
	cmp	ecx, -1
	je	$LN21@GetCenterO
	test	esi, esi
	je	$LN21@GetCenterO

; 273  : 	{
; 274  : 		if (pRtnValue->isWater() && eDomainRequired == DOMAIN_LAND || !pRtnValue->isWater() && eDomainRequired == DOMAIN_SEA)

	mov	al, BYTE PTR [esi+5]
	cmp	al, 3
	jne	SHORT $LN227@GetCenterO
	cmp	ecx, 2
	je	SHORT $LN20@GetCenterO
	cmp	al, al
	je	$LN21@GetCenterO
$LN227@GetCenterO:
	test	ecx, ecx
	jne	$LN21@GetCenterO
$LN20@GetCenterO:

; 275  : 		{
; 276  : 			// Find an adjacent plot that works
; 277  : 			for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	movsx	ebx, WORD PTR [esi+2]
	movsx	ebp, WORD PTR [esi]
	xor	edi, edi
	mov	DWORD PTR tv566[esp+68], ebx
	mov	DWORD PTR tv569[esp+68], ebp
$LL18@GetCenterO:

; 278  : 			{
; 279  : 				CvPlot *pLoopPlot = plotDirection(pRtnValue->getX(), pRtnValue->getY(), ((DirectionTypes)iI));

	push	edi
	push	ebx
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 280  : 				if (pLoopPlot != NULL)

	test	esi, esi
	je	SHORT $LN17@GetCenterO

; 281  : 				{
; 282  : 					if (pLoopPlot->isWater() && eDomainRequired == DOMAIN_SEA || !pLoopPlot->isWater() && eDomainRequired == DOMAIN_LAND)

	mov	al, BYTE PTR [esi+5]
	cmp	al, 3
	jne	SHORT $LN229@GetCenterO
	cmp	DWORD PTR _eDomainRequired$[esp+64], 0
	je	$LN21@GetCenterO
	cmp	al, al
	je	SHORT $LN17@GetCenterO
$LN229@GetCenterO:
	cmp	DWORD PTR _eDomainRequired$[esp+64], 2
	je	$LN21@GetCenterO
$LN17@GetCenterO:

; 275  : 		{
; 276  : 			// Find an adjacent plot that works
; 277  : 			for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	inc	edi
	cmp	edi, 6
	jl	SHORT $LL18@GetCenterO

; 283  : 					{
; 284  : 						return pLoopPlot;
; 285  : 					}
; 286  : 				}
; 287  : 			}
; 288  : 
; 289  : 			// Try two plots out if really having problems
; 290  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 291  : 			int iMaxDX, iDX;
; 292  : 			CvPlot* pLoopPlot;
; 293  : 			for (int iDY = -2; iDY <= 2; iDY++)
; 294  : 			{
; 295  : 				iMaxDX = 2 - MAX(0, iDY);
; 296  : 				for (iDX = -2 - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 297  : 				{
; 298  : 					// No need for range check because loops are set up properly
; 299  : 					pLoopPlot = plotXY(pRtnValue->getX(), pRtnValue->getY(), iDX, iDY);
; 300  : 					if (pLoopPlot)
; 301  : 					{
; 302  : 						if (hexDistance(iDX, iDY) == 2)
; 303  : #else
; 304  : 			for (int iDX = -2; iDX <= 2; iDX++)

	mov	ebx, -2					; fffffffeH
	mov	DWORD PTR tv772[esp+68], 2
	npad	3
$LL11@GetCenterO:

; 307  : 				{
; 308  : 					CvPlot *pLoopPlot = plotXYWithRangeCheck(pRtnValue->getX(), pRtnValue->getY(), iDX, iDY, 2);

	xor	eax, eax
	test	ebx, ebx
	setge	al
	mov	edi, -2					; fffffffeH
	lea	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR tv582[esp+68], eax
$LL8@GetCenterO:
	xor	ecx, ecx
	test	edi, edi
	setge	cl
	cmp	DWORD PTR tv582[esp+68], ecx
	mov	ecx, DWORD PTR tv772[esp+68]
	jne	SHORT $LN156@GetCenterO
	test	ecx, ecx
	jg	SHORT $LN159@GetCenterO
	mov	ecx, ebx
$LN159@GetCenterO:
	mov	eax, edi
	test	edi, edi
	jge	SHORT $LN162@GetCenterO
	mov	eax, ebp
$LN162@GetCenterO:
	add	eax, ecx
	jmp	SHORT $LN167@GetCenterO
$LN156@GetCenterO:
	test	ecx, ecx
	jg	SHORT $LN163@GetCenterO
	mov	ecx, ebx
$LN163@GetCenterO:
	mov	eax, edi
	test	edi, edi
	jge	SHORT $LN166@GetCenterO
	mov	eax, ebp
$LN166@GetCenterO:
	cmp	ecx, eax
	jl	SHORT $LN167@GetCenterO
	mov	eax, ecx
$LN167@GetCenterO:
	cmp	eax, 2
	jg	SHORT $LN7@GetCenterO
	mov	edx, DWORD PTR tv566[esp+68]
	mov	eax, DWORD PTR tv569[esp+68]
	push	edi
	push	ebx
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	esi, eax
	add	esp, 16					; 00000010H

; 309  : 					if (pLoopPlot)

	test	esi, esi
	je	SHORT $LN7@GetCenterO

; 310  : 					{
; 311  : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 312  : 						if (hexDistance(iDX, iDY) == 2)
; 313  : #else
; 314  : 						if (plotDistance(pRtnValue->getX(), pRtnValue->getY(), pLoopPlot->getX(), pLoopPlot->getY()) == 2)

	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	mov	eax, DWORD PTR tv566[esp+68]
	push	ecx
	mov	ecx, DWORD PTR tv569[esp+72]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jne	SHORT $LN7@GetCenterO

; 315  : #endif
; 316  : #endif
; 317  : 						{
; 318  : 							if (pLoopPlot->isWater() && eDomainRequired == DOMAIN_SEA || !pLoopPlot->isWater() && eDomainRequired == DOMAIN_LAND)

	mov	al, BYTE PTR [esi+5]
	cmp	al, 3
	jne	SHORT $LN233@GetCenterO
	cmp	DWORD PTR _eDomainRequired$[esp+64], 0
	je	$LN21@GetCenterO
	cmp	al, al
	je	SHORT $LN7@GetCenterO
$LN233@GetCenterO:
	cmp	DWORD PTR _eDomainRequired$[esp+64], 2
	je	SHORT $LN21@GetCenterO
$LN7@GetCenterO:

; 305  : 			{
; 306  : 				for (int iDY = -2; iDY <= 2; iDY++)

	dec	ebp
	inc	edi
	cmp	ebp, -2					; fffffffeH
	jge	$LL8@GetCenterO
	mov	eax, DWORD PTR tv772[esp+68]
	dec	eax
	inc	ebx
	cmp	eax, -2					; fffffffeH
	mov	DWORD PTR tv772[esp+68], eax
	jge	$LL11@GetCenterO

; 319  : 							{
; 320  : 								return pLoopPlot;
; 321  : 							}
; 322  : 						}
; 323  : 					}
; 324  : 				}
; 325  : 			}
; 326  : 
; 327  : 			// Give up - just use location of first unit
; 328  : 			pUnit = GetFirstUnit();

	mov	ecx, DWORD PTR _this$[esp+68]
	lea	edx, DWORD PTR $T221006[esp+68]
	push	edx
	call	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetFirstUnit
	mov	esi, eax
	lea	eax, DWORD PTR _pUnit$[esp+68]
	mov	BYTE PTR __$EHRec$[esp+76], 3
	cmp	esi, eax
	je	SHORT $LN217@GetCenterO
	mov	ecx, DWORD PTR _pUnit$[esp+68]
	test	ecx, ecx
	je	SHORT $LN191@GetCenterO
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN191@GetCenterO:
	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR _pUnit$[esp+68], esi
	test	esi, esi
	je	SHORT $LN193@GetCenterO
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	SHORT $LN193@GetCenterO
$LN217@GetCenterO:
	mov	esi, DWORD PTR _pUnit$[esp+68]
$LN193@GetCenterO:
	mov	ecx, DWORD PTR $T221006[esp+68]
	mov	BYTE PTR __$EHRec$[esp+76], 0
	test	ecx, ecx
	je	SHORT $LN198@GetCenterO
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN198@GetCenterO:

; 329  : 			pRtnValue = pUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pRtnValue$[esp+68], eax
	mov	esi, eax
$LN21@GetCenterO:

; 330  : 		}
; 331  : 	}
; 332  : 
; 333  : 	return pRtnValue;

	mov	ecx, DWORD PTR _pUnit$[esp+68]
	mov	DWORD PTR __$EHRec$[esp+76], -1
	test	ecx, ecx
	je	SHORT $LN205@GetCenterO
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN205@GetCenterO:

; 334  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z$1:
	lea	ecx, DWORD PTR $T221002[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z$2:
	lea	ecx, DWORD PTR $T221003[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z$3:
	lea	ecx, DWORD PTR $T221006[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ENDP ; CvArmyAI::GetCenterOfMass
PUBLIC	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z ; CvArmyAI::GetFurthestUnitDistance
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z$2
__ehfuncinfo$?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
xdata$x	ENDS
;	COMDAT ?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z
_TEXT	SEGMENT
_iLargestDistance$ = -40				; size = 4
_this$ = -36						; size = 4
_pUnit$ = -32						; size = 8
$T221385 = -24						; size = 8
$T221384 = -24						; size = 8
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z PROC ; CvArmyAI::GetFurthestUnitDistance, COMDAT
; _this$ = ecx

; 338  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi

; 339  : 	int iLargestDistance = 0;

	xor	edi, edi

; 340  : 	UnitHandle pUnit;

	xor	esi, esi
	mov	DWORD PTR _this$[esp+56], ecx
	mov	DWORD PTR _iLargestDistance$[esp+56], edi
	mov	DWORD PTR _pUnit$[esp+56], esi
	mov	BYTE PTR _pUnit$[esp+60], 0

; 341  : 	int iNewDistance;
; 342  : 
; 343  : 	pUnit = GetFirstUnit();

	lea	eax, DWORD PTR $T221384[esp+56]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+68], edi
	call	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetFirstUnit
	lea	ecx, DWORD PTR _pUnit$[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 1
	cmp	eax, ecx
	je	SHORT $LN18@GetFurthes
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _pUnit$[esp+56], esi
	cmp	esi, edi
	je	SHORT $LN18@GetFurthes
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN18@GetFurthes:
	mov	ecx, DWORD PTR $T221384[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 0
	cmp	ecx, edi
	je	SHORT $LN62@GetFurthes
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN62@GetFurthes:

; 344  : 	while(pUnit)

	cmp	esi, edi
	je	SHORT $LN2@GetFurthes
	mov	ebx, DWORD PTR _pPlot$[ebp]
	npad	5
$LL3@GetFurthes:

; 345  : 	{
; 346  : 		iNewDistance = plotDistance(pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY());

	movsx	edx, WORD PTR [ebx+2]
	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	edx
	movsx	edx, WORD PTR [ebx]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 347  : 		if(iNewDistance > iLargestDistance)

	cmp	eax, edi
	jle	SHORT $LN1@GetFurthes

; 348  : 		{
; 349  : 			iLargestDistance = iNewDistance;

	mov	DWORD PTR _iLargestDistance$[esp+56], eax
$LN1@GetFurthes:

; 350  : 		}
; 351  : 		pUnit = GetNextUnit();

	mov	ecx, DWORD PTR _this$[esp+56]
	lea	eax, DWORD PTR $T221385[esp+56]
	push	eax
	call	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetNextUnit
	mov	edi, eax
	lea	ecx, DWORD PTR _pUnit$[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 2
	cmp	edi, ecx
	je	SHORT $LN50@GetFurthes
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR _pUnit$[esp+56], esi
	test	esi, esi
	je	SHORT $LN50@GetFurthes
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN50@GetFurthes:
	mov	ecx, DWORD PTR $T221385[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 0
	test	ecx, ecx
	je	SHORT $LN55@GetFurthes
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN55@GetFurthes:
	mov	edi, DWORD PTR _iLargestDistance$[esp+56]
	test	esi, esi
	jne	SHORT $LL3@GetFurthes
$LN2@GetFurthes:

; 352  : 	}
; 353  : 	return iLargestDistance;

	mov	DWORD PTR __$EHRec$[esp+64], -1
	test	esi, esi
	je	SHORT $LN63@GetFurthes
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN63@GetFurthes:

; 354  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR $T221384[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR $T221385[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z ENDP ; CvArmyAI::GetFurthestUnitDistance
PUBLIC	?IsAllOceanGoing@CvArmyAI@@QAE_NXZ		; CvArmyAI::IsAllOceanGoing
EXTRN	?IsHasEmbarkAbility@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsHasEmbarkAbility
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?IsAllOceanGoing@CvArmyAI@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsAllOceanGoing@CvArmyAI@@QAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?IsAllOceanGoing@CvArmyAI@@QAE_NXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?IsAllOceanGoing@CvArmyAI@@QAE_NXZ$2
__ehfuncinfo$?IsAllOceanGoing@CvArmyAI@@QAE_NXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?IsAllOceanGoing@CvArmyAI@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
xdata$x	ENDS
;	COMDAT ?IsAllOceanGoing@CvArmyAI@@QAE_NXZ
_TEXT	SEGMENT
_pUnit$ = -32						; size = 8
$T221502 = -24						; size = 8
$T221499 = -24						; size = 8
__$EHRec$ = -12						; size = 12
?IsAllOceanGoing@CvArmyAI@@QAE_NXZ PROC			; CvArmyAI::IsAllOceanGoing, COMDAT
; _this$ = ecx

; 499  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?IsAllOceanGoing@CvArmyAI@@QAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 500  : 	UnitHandle pUnit;

	xor	ebx, ebx
	xor	esi, esi
	mov	DWORD PTR _pUnit$[esp+48], esi
	mov	BYTE PTR _pUnit$[esp+52], bl

; 501  : 
; 502  : 	pUnit = GetFirstUnit();

	lea	eax, DWORD PTR $T221499[esp+48]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+60], ebx
	call	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetFirstUnit
	lea	ecx, DWORD PTR _pUnit$[esp+48]
	mov	BYTE PTR __$EHRec$[esp+56], 1
	cmp	eax, ecx
	je	SHORT $LN19@IsAllOcean
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _pUnit$[esp+48], esi
	cmp	esi, ebx
	je	SHORT $LN19@IsAllOcean
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN19@IsAllOcean:
	mov	ecx, DWORD PTR $T221499[esp+48]
	mov	BYTE PTR __$EHRec$[esp+56], bl
	cmp	ecx, ebx
	je	SHORT $LN69@IsAllOcean
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN69@IsAllOcean:

; 503  : 	while(pUnit)

	cmp	esi, ebx
	je	SHORT $LN3@IsAllOcean
$LL4@IsAllOcean:

; 504  : 	{
; 505  : 		if(pUnit->getDomainType() != DOMAIN_SEA && !pUnit->IsHasEmbarkAbility())

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN2@IsAllOcean
	mov	ecx, esi
	call	?IsHasEmbarkAbility@CvUnit@@QBE_NXZ	; CvUnit::IsHasEmbarkAbility
	test	al, al
	je	SHORT $LN70@IsAllOcean
$LN2@IsAllOcean:

; 508  : 		}
; 509  : 
; 510  : 		// If can move over ocean, not a coastal vessel
; 511  : 		if(pUnit->isTerrainImpassable(TERRAIN_OCEAN))

	mov	edx, DWORD PTR [esi+1996]
	cmp	DWORD PTR [edx+24], ebx
	jg	$LN71@IsAllOcean

; 514  : 		}
; 515  : 
; 516  : 		pUnit = GetNextUnit();

	lea	eax, DWORD PTR $T221502[esp+48]
	push	eax
	mov	ecx, ebp
	call	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetNextUnit
	mov	edi, eax
	lea	ecx, DWORD PTR _pUnit$[esp+48]
	mov	BYTE PTR __$EHRec$[esp+56], 2
	cmp	edi, ecx
	je	SHORT $LN57@IsAllOcean
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR _pUnit$[esp+48], esi
	cmp	esi, ebx
	je	SHORT $LN57@IsAllOcean
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN57@IsAllOcean:
	mov	ecx, DWORD PTR $T221502[esp+48]
	mov	BYTE PTR __$EHRec$[esp+56], bl
	cmp	ecx, ebx
	je	SHORT $LN62@IsAllOcean
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN62@IsAllOcean:

; 503  : 	while(pUnit)

	cmp	esi, ebx
	jne	SHORT $LL4@IsAllOcean
$LN3@IsAllOcean:

; 517  : 	}
; 518  : 
; 519  : 	return true;

	mov	DWORD PTR __$EHRec$[esp+56], -1
	cmp	esi, ebx
	je	SHORT $LN67@IsAllOcean
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN67@IsAllOcean:
	mov	al, 1

; 520  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@IsAllOcean:

; 506  : 		{
; 507  : 			return false;

	mov	DWORD PTR __$EHRec$[esp+56], -1
	cmp	esi, ebx
	je	SHORT $LN35@IsAllOcean
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN35@IsAllOcean:
	xor	al, al

; 520  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@IsAllOcean:

; 512  : 		{
; 513  : 			return false;

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+56], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 520  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	xor	al, al
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsAllOceanGoing@CvArmyAI@@QAE_NXZ$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?IsAllOceanGoing@CvArmyAI@@QAE_NXZ$1:
	lea	ecx, DWORD PTR $T221499[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?IsAllOceanGoing@CvArmyAI@@QAE_NXZ$2:
	lea	ecx, DWORD PTR $T221502[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?IsAllOceanGoing@CvArmyAI@@QAE_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?IsAllOceanGoing@CvArmyAI@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsAllOceanGoing@CvArmyAI@@QAE_NXZ ENDP			; CvArmyAI::IsAllOceanGoing
PUBLIC	?AreAllInWater@CvArmyAI@@QAE_NXZ		; CvArmyAI::AreAllInWater
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?AreAllInWater@CvArmyAI@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AreAllInWater@CvArmyAI@@QAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AreAllInWater@CvArmyAI@@QAE_NXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?AreAllInWater@CvArmyAI@@QAE_NXZ$2
__ehfuncinfo$?AreAllInWater@CvArmyAI@@QAE_NXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?AreAllInWater@CvArmyAI@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
xdata$x	ENDS
;	COMDAT ?AreAllInWater@CvArmyAI@@QAE_NXZ
_TEXT	SEGMENT
_pUnit$ = -32						; size = 8
$T221631 = -24						; size = 8
$T221629 = -24						; size = 8
__$EHRec$ = -12						; size = 12
?AreAllInWater@CvArmyAI@@QAE_NXZ PROC			; CvArmyAI::AreAllInWater, COMDAT
; _this$ = ecx

; 612  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?AreAllInWater@CvArmyAI@@QAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 613  : 	UnitHandle pUnit;

	xor	ebx, ebx
	xor	esi, esi
	mov	DWORD PTR _pUnit$[esp+48], esi
	mov	BYTE PTR _pUnit$[esp+52], bl

; 614  : 
; 615  : 	pUnit = GetFirstUnit();

	lea	eax, DWORD PTR $T221629[esp+48]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+60], ebx
	call	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetFirstUnit
	lea	ecx, DWORD PTR _pUnit$[esp+48]
	mov	BYTE PTR __$EHRec$[esp+56], 1
	cmp	eax, ecx
	je	SHORT $LN18@AreAllInWa
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _pUnit$[esp+48], esi
	cmp	esi, ebx
	je	SHORT $LN18@AreAllInWa
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN18@AreAllInWa:
	mov	ecx, DWORD PTR $T221629[esp+48]
	mov	BYTE PTR __$EHRec$[esp+56], bl
	cmp	ecx, ebx
	je	SHORT $LN55@AreAllInWa
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN55@AreAllInWa:

; 616  : 	while(pUnit)

	cmp	esi, ebx
	je	SHORT $LN2@AreAllInWa
$LL3@AreAllInWa:

; 617  : 	{
; 618  : 		if(!pUnit->plot()->isWater())

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN56@AreAllInWa

; 621  : 		}
; 622  : 		pUnit = GetNextUnit();

	lea	edx, DWORD PTR $T221631[esp+48]
	push	edx
	mov	ecx, ebp
	call	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetNextUnit
	mov	edi, eax
	lea	eax, DWORD PTR _pUnit$[esp+48]
	mov	BYTE PTR __$EHRec$[esp+56], 2
	cmp	edi, eax
	je	SHORT $LN43@AreAllInWa
	cmp	esi, ebx
	je	SHORT $LN41@AreAllInWa
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@AreAllInWa:
	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR _pUnit$[esp+48], esi
	cmp	esi, ebx
	je	SHORT $LN43@AreAllInWa
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN43@AreAllInWa:
	mov	ecx, DWORD PTR $T221631[esp+48]
	mov	BYTE PTR __$EHRec$[esp+56], bl
	cmp	ecx, ebx
	je	SHORT $LN48@AreAllInWa
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN48@AreAllInWa:

; 616  : 	while(pUnit)

	cmp	esi, ebx
	jne	SHORT $LL3@AreAllInWa
$LN2@AreAllInWa:

; 623  : 	}
; 624  : 
; 625  : 	return true;

	mov	DWORD PTR __$EHRec$[esp+56], -1
	cmp	esi, ebx
	je	SHORT $LN53@AreAllInWa
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@AreAllInWa:
	mov	al, 1

; 626  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@AreAllInWa:

; 619  : 		{
; 620  : 			return false;

	mov	DWORD PTR __$EHRec$[esp+56], -1
	cmp	esi, ebx
	je	SHORT $LN34@AreAllInWa
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN34@AreAllInWa:

; 626  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	xor	al, al
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AreAllInWater@CvArmyAI@@QAE_NXZ$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?AreAllInWater@CvArmyAI@@QAE_NXZ$1:
	lea	ecx, DWORD PTR $T221629[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?AreAllInWater@CvArmyAI@@QAE_NXZ$2:
	lea	ecx, DWORD PTR $T221631[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?AreAllInWater@CvArmyAI@@QAE_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?AreAllInWater@CvArmyAI@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AreAllInWater@CvArmyAI@@QAE_NXZ ENDP			; CvArmyAI::AreAllInWater
PUBLIC	?DoTurn@CvArmyAI@@QAEXXZ			; CvArmyAI::DoTurn
; Function compile flags: /Ogtpy
;	COMDAT ?DoTurn@CvArmyAI@@QAEXXZ
_TEXT	SEGMENT
?DoTurn@CvArmyAI@@QAEXXZ PROC				; CvArmyAI::DoTurn, COMDAT
; _this$ = ecx

; 853  : {

	mov	edx, DWORD PTR [ecx+48]
	push	esi

; 854  : 	// do something with the army
; 855  : 	DoDelayedDeath();

	xor	esi, esi
	test	edx, edx
	jbe	SHORT $LN18@DoTurn
	mov	eax, DWORD PTR [ecx+44]
	npad	3
$LL9@DoTurn:
	cmp	DWORD PTR [eax], -1
	je	SHORT $LN8@DoTurn
	inc	esi
$LN8@DoTurn:
	add	eax, 12					; 0000000cH
	sub	edx, 1
	jne	SHORT $LL9@DoTurn
	test	esi, esi
	jne	SHORT $LN3@DoTurn
$LN18@DoTurn:
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN3@DoTurn
	pop	esi
	jmp	?Kill@CvArmyAI@@QAEXXZ			; CvArmyAI::Kill
$LN3@DoTurn:
	pop	esi

; 856  : }

	ret	0
?DoTurn@CvArmyAI@@QAEXXZ ENDP				; CvArmyAI::DoTurn
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvArmyFormationSlot@@@Z ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::push_back
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvArmyFormationSlot@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvArmyFormationSlot@@@Z PROC ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+252], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@QAEIABVCvArmyFormationSlot@@@Z ENDP ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::push_back
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvArmyAI@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvArmyAI@@UAEPAXI@Z PROC				; CvArmyAI::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvArmyAI@@6B@
	mov	DWORD PTR [esi+48], 0
	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [esi+56]
	cmp	eax, ecx
	je	SHORT $LN19@scalar
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN19@scalar:
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN31@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN31@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvArmyAI@@UAEPAXI@Z ENDP				; CvArmyAI::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.cpp
;	COMDAT ?read@CvArmyAI@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -16					; size = 4
_slot$217590 = -12					; size = 12
_iEntriesToRead$ = 8					; size = 4
_kStream$ = 8						; size = 4
?read@CvArmyAI@@UAEXAAVFDataStream@@@Z PROC		; CvArmyAI::read, COMDAT
; _this$ = ecx

; 104  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 105  : 	// Init saved data
; 106  : 	Reset();
; 107  : 
; 108  : 	// Version number to maintain backwards compatibility
; 109  : 	uint uiVersion;
; 110  : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+24]
	push	edi
	mov	edi, ecx
	xor	eax, eax
	lea	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR [ebp], eax
	lea	ebx, DWORD PTR [edi+8]
	mov	DWORD PTR [ebx], -1
	mov	DWORD PTR [edi+12], -1
	mov	DWORD PTR [edi+16], -1
	mov	DWORD PTR [edi+20], -1
	mov	DWORD PTR [edi+24], -1
	mov	DWORD PTR [edi+28], -1
	mov	DWORD PTR [edi+32], 2
	mov	DWORD PTR [edi+36], -1
	mov	DWORD PTR [edi+40], -1
	mov	DWORD PTR [edi+48], eax
	lea	eax, DWORD PTR _uiVersion$[esp+32]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 111  : 
; 112  : 	kStream >> m_iID;

	push	ebp
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 113  : 	kStream >> m_eOwner;

	push	ebx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 114  : 	kStream >> m_iCurrentX;

	lea	eax, DWORD PTR [edi+16]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 115  : 	kStream >> m_iCurrentY;

	lea	eax, DWORD PTR [edi+20]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 116  : 	kStream >> m_iGoalX;

	lea	eax, DWORD PTR [edi+24]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 117  : 	kStream >> m_iGoalY;

	lea	eax, DWORD PTR [edi+28]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 118  : 	kStream >> m_eDomainType;

	lea	eax, DWORD PTR [edi+32]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 119  : 	kStream >> m_iFormationIndex;

	lea	eax, DWORD PTR [edi+36]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 120  : 	kStream >> m_eAIState;

	lea	eax, DWORD PTR [edi+40]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 121  : 	kStream >> m_iOperationID;

	lea	eax, DWORD PTR [edi+12]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 122  : 
; 123  : 	int iEntriesToRead;
; 124  : 	kStream >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[esp+28]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 125  : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	xor	ebp, ebp
	xor	ebx, ebx
	cmp	DWORD PTR _iEntriesToRead$[esp+28], ebp
	jle	SHORT $LN1@read
	add	edi, 44					; 0000002cH
$LL3@read:

; 126  : 	{
; 127  : 		CvArmyFormationSlot slot;

	or	eax, -1

; 128  : 		kStream >> slot;

	lea	edx, DWORD PTR _slot$217590[esp+32]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR _slot$217590[esp+36], eax
	mov	DWORD PTR _slot$217590[esp+40], eax
	mov	DWORD PTR _slot$217590[esp+44], ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	eax, DWORD PTR _slot$217590[esp+36]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	ecx, DWORD PTR _slot$217590[esp+40]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 129  : 		m_FormationEntries.push_back(slot);

	mov	eax, DWORD PTR [edi+8]
	mov	BYTE PTR [edi+252], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN58@read
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::GrowSize
$LN58@read:
	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+edx*4]
	cmp	eax, ebp
	je	SHORT $LN61@read
	mov	ecx, DWORD PTR _slot$217590[esp+32]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _slot$217590[esp+36]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _slot$217590[esp+40]
	mov	DWORD PTR [eax+8], ecx
$LN61@read:
	inc	DWORD PTR [edi+4]
	inc	ebx
	cmp	ebx, DWORD PTR _iEntriesToRead$[esp+28]
	jl	SHORT $LL3@read
$LN1@read:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 130  : 	}
; 131  : }

	add	esp, 16					; 00000010H
	ret	4
?read@CvArmyAI@@UAEXAAVFDataStream@@@Z ENDP		; CvArmyAI::read
_TEXT	ENDS
PUBLIC	?SetFormationIndex@CvArmyAI@@QAEXH@Z		; CvArmyAI::SetFormationIndex
EXTRN	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ:PROC ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
; Function compile flags: /Ogtpy
;	COMDAT ?SetFormationIndex@CvArmyAI@@QAEXH@Z
_TEXT	SEGMENT
_slot$ = -12						; size = 12
tv163 = 8						; size = 4
_iFormationIndex$ = 8					; size = 4
?SetFormationIndex@CvArmyAI@@QAEXH@Z PROC		; CvArmyAI::SetFormationIndex, COMDAT
; _this$ = ecx

; 366  : {

	sub	esp, 12					; 0000000cH

; 367  : 	CvArmyFormationSlot slot;

	or	eax, -1
	push	esi
	mov	DWORD PTR _slot$[esp+16], eax
	mov	DWORD PTR _slot$[esp+20], eax

; 368  : 
; 369  : 	if(m_iFormationIndex != iFormationIndex)

	mov	eax, DWORD PTR _iFormationIndex$[esp+12]
	mov	esi, ecx
	cmp	DWORD PTR [esi+36], eax
	je	SHORT $LN1@SetFormati

; 370  : 	{
; 371  : 		m_iFormationIndex = iFormationIndex;
; 372  : 
; 373  : 		CvMultiUnitFormationInfo* thisFormation = GC.getMultiUnitFormationInfo(m_iFormationIndex);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+36], eax
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo

; 374  : 		if(thisFormation)

	test	eax, eax
	je	SHORT $LN1@SetFormati

; 375  : 		{
; 376  : 			int iNumSlots = thisFormation->getNumFormationSlotEntries();

	mov	ecx, eax
	call	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries

; 377  : 
; 378  : 			// Build all the formation entries
; 379  : 			m_FormationEntries.clear();

	mov	DWORD PTR [esi+48], 0

; 380  : 			for(int iI = 0; iI < iNumSlots; iI++)

	test	eax, eax
	jle	SHORT $LN1@SetFormati
	push	ebp
	add	esi, 44					; 0000002cH
	mov	DWORD PTR tv163[esp+16], eax
	push	edi
$LL31@SetFormati:

; 381  : 			{
; 382  : 				slot.SetUnitID(ARMY_NO_UNIT);
; 383  : 				slot.SetTurnAtCheckpoint(ARMYSLOT_UNKNOWN_TURN_AT_CHECKPOINT);
; 384  : 				m_FormationEntries.push_back(slot);

	mov	eax, DWORD PTR [esi+8]
	or	edi, -1
	or	ebp, edi
	mov	BYTE PTR [esi+252], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN22@SetFormati
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvArmyFormationSlot@@$0BE@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvArmyFormationSlot,20,1,297,0>::GrowSize
$LN22@SetFormati:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN25@SetFormati
	mov	DWORD PTR [eax], edi
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ecx
$LN25@SetFormati:
	mov	eax, 1
	add	DWORD PTR [esi+4], eax
	sub	DWORD PTR tv163[esp+20], eax
	jne	SHORT $LL31@SetFormati
	pop	edi
	pop	ebp
$LN1@SetFormati:
	pop	esi

; 385  : 			}
; 386  : 		}
; 387  : 	}
; 388  : }

	add	esp, 12					; 0000000cH
	ret	4
?SetFormationIndex@CvArmyAI@@QAEXH@Z ENDP		; CvArmyAI::SetFormationIndex
_TEXT	ENDS
END
