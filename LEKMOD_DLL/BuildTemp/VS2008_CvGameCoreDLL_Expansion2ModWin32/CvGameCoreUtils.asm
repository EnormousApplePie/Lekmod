; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvGameCoreUtils.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG218580 DB	'NOPICK', 00H
$SG218641 DB	00H
$SG218602 DB	'Months', 00H
	ORG $+1
$SG218615 DB	'Months', 00H
	ORG $+1
$SG218632 DB	'Seasons', 00H
$SG218646 DB	'1', 00H
	ORG $+2
$SG218647 DB	'0', 00H
	ORG $+2
$SG218669 DB	'NO_DIRECTION', 00H
	ORG $+3
$SG218671 DB	'northeast', 00H
	ORG $+2
$SG218673 DB	'east', 00H
	ORG $+3
$SG218675 DB	'southeast', 00H
	ORG $+2
$SG218677 DB	'southwest', 00H
	ORG $+2
$SG218679 DB	'west', 00H
	ORG $+3
$SG218681 DB	'northwest', 00H
	ORG $+2
$SG218684 DB	'UNKNOWN_DIRECTION(%d)', 00H
	ORG $+2
$SG218694 DB	'NO_ACTIVITY', 00H
$SG218696 DB	'ACTIVITY_AWAKE', 00H
	ORG $+1
$SG218698 DB	'ACTIVITY_HOLD', 00H
	ORG $+2
$SG218700 DB	'ACTIVITY_SLEEP', 00H
	ORG $+1
$SG218702 DB	'ACTIVITY_HEAL', 00H
	ORG $+2
$SG218704 DB	'ACTIVITY_SENTRY', 00H
$SG218706 DB	'ACTIVITY_SENTRY', 00H
$SG218708 DB	'ACTIVITY_MISSION', 00H
	ORG $+3
$SG218711 DB	'UNKNOWN_ACTIVITY(%d)', 00H
	ORG $+3
$SG218721 DB	'NO_MISSIONAI', 00H
	ORG $+3
$SG218723 DB	'MISSIONAI_SHADOW', 00H
	ORG $+3
$SG218725 DB	'MISSIONAI_GROUP', 00H
$SG218727 DB	'MISSIONAI_LOAD_ASSAULT', 00H
	ORG $+1
$SG218729 DB	'MISSIONAI_LOAD_SETTLER', 00H
	ORG $+1
$SG218731 DB	'MISSIONAI_LOAD_SPECIA', 00H
	ORG $+2
$SG218733 DB	'MISSIONAI_GUARD_CITY', 00H
	ORG $+3
$SG218735 DB	'MISSIONAI_GUARD_RESOURCE', 00H
	ORG $+3
$SG218737 DB	'MISSIONAI_GUARD_SPY', 00H
$SG218739 DB	'MISSIONAI_ATTACK_SPY', 00H
	ORG $+3
$SG218741 DB	'MISSIONAI_SPREAD', 00H
	ORG $+3
$SG218743 DB	'MISSIONAI_CONSTRUCT', 00H
$SG218745 DB	'MISSIONAI_HURRY', 00H
$SG218747 DB	'MISSIONAI_GREAT_WORK', 00H
	ORG $+3
$SG218749 DB	'MISSIONAI_EXPLORE', 00H
	ORG $+2
$SG218751 DB	'MISSIONAI_BLOCKADE', 00H
	ORG $+1
$SG218753 DB	'MISSIONAI_PILLAGE', 00H
	ORG $+2
$SG218755 DB	'MISSIONAI_FOUND', 00H
$SG218757 DB	'MISSIONAI_BUILD', 00H
$SG218759 DB	'MISSIONAI_ASSAULT', 00H
	ORG $+2
$SG218761 DB	'MISSIONAI_CARRIER', 00H
	ORG $+2
$SG218763 DB	'MISSIONAI_PICKUP', 00H
	ORG $+3
$SG218766 DB	'UNKOWN_MISSION_AI(%d)', 00H
	ORG $+2
$SG218776 DB	'no unitAI', 00H
	ORG $+2
$SG218778 DB	'unknown', 00H
$SG218780 DB	'settle', 00H
	ORG $+1
$SG218782 DB	'worker', 00H
	ORG $+1
$SG218784 DB	'attack', 00H
	ORG $+1
$SG218786 DB	'bombard city', 00H
	ORG $+3
$SG218788 DB	'fast attack', 00H
$SG218790 DB	'defense', 00H
$SG218792 DB	'counter', 00H
$SG218794 DB	'ranged', 00H
	ORG $+1
$SG218796 DB	'city special', 00H
	ORG $+3
$SG218798 DB	'explore', 00H
$SG218800 DB	'artist', 00H
	ORG $+1
$SG218802 DB	'scientist', 00H
	ORG $+2
$SG218804 DB	'general', 00H
$SG218806 DB	'merchant', 00H
	ORG $+3
$SG218808 DB	'engineer', 00H
	ORG $+3
$SG218810 DB	'icbm', 00H
	ORG $+3
$SG218812 DB	'worker sea', 00H
	ORG $+1
$SG218814 DB	'attack sea', 00H
	ORG $+1
$SG218816 DB	'reserve sea', 00H
$SG218818 DB	'escort sea', 00H
	ORG $+1
$SG218820 DB	'explore sea', 00H
$SG218822 DB	'assault sea', 00H
$SG218824 DB	'settler sea', 00H
$SG218826 DB	'carrier sea', 00H
$SG218828 DB	'missile carrier', 00H
$SG218830 DB	'pirate sea', 00H
	ORG $+1
$SG218832 DB	'attack air', 00H
	ORG $+1
$SG218834 DB	'defense air', 00H
$SG218836 DB	'carrier air', 00H
$SG218838 DB	'paradrop', 00H
	ORG $+3
$SG218840 DB	'spaceship part', 00H
	ORG $+1
$SG218842 DB	'treasure', 00H
	ORG $+3
$SG218844 DB	'prophet', 00H
$SG218846 DB	'missionary', 00H
	ORG $+1
$SG218848 DB	'inquisitor', 00H
	ORG $+1
$SG218850 DB	'admiral', 00H
$SG218852 DB	'trade unit', 00H
	ORG $+1
$SG218854 DB	'archaeologist', 00H
	ORG $+2
$SG218856 DB	'writer', 00H
	ORG $+1
$SG218858 DB	'musician', 00H
	ORG $+3
$SG218861 DB	'unknown(%d)', 00H
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	?hexDistance@@YAHHH@Z				; hexDistance
; Function compile flags: /Ogtpy
;	COMDAT ?hexDistance@@YAHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iDY$ = 12						; size = 4
?hexDistance@@YAHHH@Z PROC				; hexDistance, COMDAT

; 96   : 	// I'm assuming iDX and iDY are in hex-space
; 97   : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 98   : 	// Delnar: Using abs() because I trust the compiler to generate more efficient code than if I'd write an abs(int) function myself, especially if the CPU has an abs(int) operation
; 99   : 	if ((iDX ^ iDY) >= 0)  // the signs match
; 100  : 	{
; 101  : 		return abs(iDX) + abs(iDY);
; 102  : 	}
; 103  : 	else
; 104  : 	{
; 105  : 		return MAX(abs(iDX), abs(iDY));
; 106  : 	}
; 107  : #else
; 108  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	eax, DWORD PTR _iDX$[esp-4]
	xor	ecx, ecx
	test	eax, eax
	setge	cl
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	xor	edx, edx
	test	esi, esi
	setge	dl
	cmp	ecx, edx
	jne	SHORT $LN2@hexDistanc

; 109  : 	{
; 110  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	eax, eax
	jge	SHORT $LN6@hexDistanc
	neg	eax
$LN6@hexDistanc:

; 111  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	test	esi, esi
	jge	SHORT $LN8@hexDistanc
	neg	esi
$LN8@hexDistanc:

; 112  : 		return iAbsDX + iAbsDY;

	add	eax, esi
	pop	esi

; 119  : 	}
; 120  : #endif
; 121  : }

	ret	0
$LN2@hexDistanc:

; 113  : 	}
; 114  : 	else
; 115  : 	{
; 116  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	eax, eax
	jge	SHORT $LN10@hexDistanc
	neg	eax
$LN10@hexDistanc:

; 117  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	test	esi, esi
	jge	SHORT $LN12@hexDistanc
	neg	esi
$LN12@hexDistanc:

; 118  : 		return iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	eax, esi
	jge	SHORT $LN1@hexDistanc
	mov	eax, esi
$LN1@hexDistanc:
	pop	esi

; 119  : 	}
; 120  : #endif
; 121  : }

	ret	0
?hexDistance@@YAHHH@Z ENDP				; hexDistance
_TEXT	ENDS
PUBLIC	?hexspaceSpikeDirection@@YA?AW4DirectionTypes@@HH@Z ; hexspaceSpikeDirection
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceSpikeDirection@@YA?AW4DirectionTypes@@HH@Z
_TEXT	SEGMENT
_iXOffset$ = 8						; size = 4
_iYOffset$ = 12						; size = 4
?hexspaceSpikeDirection@@YA?AW4DirectionTypes@@HH@Z PROC ; hexspaceSpikeDirection, COMDAT

; 346  : 	if(iYOffset > 0)

	mov	eax, DWORD PTR _iYOffset$[esp-4]
	test	eax, eax
	jle	SHORT $LN19@hexspaceSp

; 347  : 	{
; 348  : 		if(iXOffset >= 0)

	mov	ecx, DWORD PTR _iXOffset$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN15@hexspaceSp

; 349  : 		{
; 350  : 			return DIRECTION_NORTHEAST;

	xor	eax, eax

; 383  : 		{
; 384  : 			return DIRECTION_SOUTHEAST;
; 385  : 		}
; 386  : 		else
; 387  : 		{
; 388  : 			return DIRECTION_SOUTHWEST;
; 389  : 		}
; 390  : 	}
; 391  : }

	ret	0
$LN15@hexspaceSp:

; 351  : 		}
; 352  : 		else if(-iXOffset <= iYOffset)

	neg	ecx
	xor	edx, edx
	cmp	ecx, eax
	setle	dl
	add	edx, 4
	mov	eax, edx

; 383  : 		{
; 384  : 			return DIRECTION_SOUTHEAST;
; 385  : 		}
; 386  : 		else
; 387  : 		{
; 388  : 			return DIRECTION_SOUTHWEST;
; 389  : 		}
; 390  : 	}
; 391  : }

	ret	0
$LN19@hexspaceSp:

; 353  : 		{
; 354  : 			return DIRECTION_NORTHWEST;
; 355  : 		}
; 356  : 		else //if (-iXOffset > iYOffset)
; 357  : 		{
; 358  : 			return DIRECTION_WEST;
; 359  : 		}
; 360  : 	}
; 361  : 	else if(iYOffset == 0)

	jne	SHORT $LN10@hexspaceSp

; 362  : 	{
; 363  : 		if(iXOffset > 0)

	mov	eax, DWORD PTR _iXOffset$[esp-4]
	test	eax, eax
	jle	SHORT $LN9@hexspaceSp
$LN20@hexspaceSp:

; 364  : 		{
; 365  : 			return DIRECTION_EAST;

	mov	eax, 1

; 383  : 		{
; 384  : 			return DIRECTION_SOUTHEAST;
; 385  : 		}
; 386  : 		else
; 387  : 		{
; 388  : 			return DIRECTION_SOUTHWEST;
; 389  : 		}
; 390  : 	}
; 391  : }

	ret	0
$LN9@hexspaceSp:

; 366  : 		}
; 367  : 		else if(iXOffset == 0)

	neg	eax
	sbb	eax, eax
	and	eax, 5
	dec	eax

; 383  : 		{
; 384  : 			return DIRECTION_SOUTHEAST;
; 385  : 		}
; 386  : 		else
; 387  : 		{
; 388  : 			return DIRECTION_SOUTHWEST;
; 389  : 		}
; 390  : 	}
; 391  : }

	ret	0
$LN10@hexspaceSp:

; 368  : 		{
; 369  : 			return NO_DIRECTION;
; 370  : 		}
; 371  : 		else
; 372  : 		{
; 373  : 			return DIRECTION_WEST;
; 374  : 		}
; 375  : 	}
; 376  : 	else// if (iYOffset < 0)
; 377  : 	{
; 378  : 		if(iXOffset > -iYOffset)

	mov	ecx, DWORD PTR _iXOffset$[esp-4]
	neg	eax
	cmp	ecx, eax

; 379  : 		{
; 380  : 			return DIRECTION_EAST;

	jg	SHORT $LN20@hexspaceSp

; 381  : 		}
; 382  : 		else if(iXOffset > 0)

	xor	eax, eax
	test	ecx, ecx
	setle	al
	add	eax, 2

; 383  : 		{
; 384  : 			return DIRECTION_SOUTHEAST;
; 385  : 		}
; 386  : 		else
; 387  : 		{
; 388  : 			return DIRECTION_SOUTHWEST;
; 389  : 		}
; 390  : 	}
; 391  : }

	ret	0
?hexspaceSpikeDirection@@YA?AW4DirectionTypes@@HH@Z ENDP ; hexspaceSpikeDirection
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	?estimateDirection@@YA?AW4DirectionTypes@@HH@Z	; estimateDirection
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA
_DATA	SEGMENT
?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA DQ 03fe0000000000000r ; 0.5 ; `estimateDirection'::`2'::displacements
	DQ	03febb67a0f9096bcr		; 0.866025
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	03fe0000000000000r		; 0.5
	DQ	0bfebb67a0f9096bcr		; -0.866025
	DQ	0bfe0000000000000r		; -0.5
	DQ	0bfebb67a0f9096bcr		; -0.866025
	DQ	0bff0000000000000r		; -1
	DQ	00000000000000000r		; 0
	DQ	0bfe0000000000000r		; -0.5
	DQ	0bfebb67a0f9096bcr		; -0.866025
; Function compile flags: /Ogtpy
_DATA	ENDS
;	COMDAT ?estimateDirection@@YA?AW4DirectionTypes@@HH@Z
_TEXT	SEGMENT
_dotProduct$218181 = -16				; size = 8
_maximum$ = -8						; size = 8
_iDX$ = 8						; size = 4
_iDY$ = 12						; size = 4
?estimateDirection@@YA?AW4DirectionTypes@@HH@Z PROC	; estimateDirection, COMDAT

; 131  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 64					; 00000040H

; 132  : 	const int displacementSize = 6;
; 133  : 	//														NE				E		SE					SW					W			NW
; 134  : 	static double displacements[displacementSize][2] = { {0.5, 0.866025}, {1, 0}, {0.5, -0.866025}, {-0.5, -0.866025}, {-1, 0}, {-0.5, -0.866025}};
; 135  : 	double maximum = 0;
; 136  : 	int maximumIndex = -1;
; 137  : 	for(int i=0; i<displacementSize; i++)
; 138  : 	{
; 139  : 		double dotProduct = iDX * displacements[i][0] + iDY * displacements[i][1];

	fild	DWORD PTR _iDY$[ebp]
	xor	edx, edx
	or	ecx, -1
	mov	DWORD PTR _maximum$[esp+64], edx
	fmul	QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA+8
	mov	DWORD PTR _maximum$[esp+68], edx
	fild	DWORD PTR _iDX$[ebp]
	fmul	QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _dotProduct$218181[esp+64]

; 140  : 		if(dotProduct > maximum)

	fldz
	fcomp	QWORD PTR _dotProduct$218181[esp+64]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@estimateDi

; 141  : 		{
; 142  : 			maximum = dotProduct;

	mov	ecx, DWORD PTR _dotProduct$218181[esp+68]
	mov	eax, DWORD PTR _dotProduct$218181[esp+64]
	mov	DWORD PTR _maximum$[esp+68], ecx
	mov	DWORD PTR _maximum$[esp+64], eax

; 143  : 			maximumIndex = i;

	xor	ecx, ecx
$LN3@estimateDi:
	fild	DWORD PTR _iDY$[ebp]
	fmul	QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA+24
	fild	DWORD PTR _iDX$[ebp]
	fmul	QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA+16
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _dotProduct$218181[esp+64]
	fld	QWORD PTR _maximum$[esp+64]
	fcomp	QWORD PTR _dotProduct$218181[esp+64]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN11@estimateDi
	mov	edx, DWORD PTR _dotProduct$218181[esp+64]
	mov	eax, DWORD PTR _dotProduct$218181[esp+68]
	mov	DWORD PTR _maximum$[esp+64], edx
	mov	DWORD PTR _maximum$[esp+68], eax
	mov	ecx, 1
$LN11@estimateDi:
	fild	DWORD PTR _iDY$[ebp]
	fmul	QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA+40
	fild	DWORD PTR _iDX$[ebp]
	fmul	QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA+32
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _dotProduct$218181[esp+64]
	fld	QWORD PTR _maximum$[esp+64]
	fcomp	QWORD PTR _dotProduct$218181[esp+64]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN13@estimateDi
	mov	ecx, DWORD PTR _dotProduct$218181[esp+64]
	mov	edx, DWORD PTR _dotProduct$218181[esp+68]
	mov	DWORD PTR _maximum$[esp+64], ecx
	mov	DWORD PTR _maximum$[esp+68], edx
	mov	ecx, 2
$LN13@estimateDi:
	fild	DWORD PTR _iDY$[ebp]
	fmul	QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA+56
	fild	DWORD PTR _iDX$[ebp]
	fmul	QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA+48
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _dotProduct$218181[esp+64]
	fld	QWORD PTR _maximum$[esp+64]
	fcomp	QWORD PTR _dotProduct$218181[esp+64]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN15@estimateDi
	mov	ecx, DWORD PTR _dotProduct$218181[esp+68]
	mov	eax, DWORD PTR _dotProduct$218181[esp+64]
	mov	DWORD PTR _maximum$[esp+68], ecx
	mov	DWORD PTR _maximum$[esp+64], eax
	mov	ecx, 3
$LN15@estimateDi:
	fild	DWORD PTR _iDY$[ebp]
	fmul	QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA+72
	fild	DWORD PTR _iDX$[ebp]
	fmul	QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA+64
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _dotProduct$218181[esp+64]
	fld	QWORD PTR _maximum$[esp+64]
	fcomp	QWORD PTR _dotProduct$218181[esp+64]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN17@estimateDi
	mov	edx, DWORD PTR _dotProduct$218181[esp+64]
	mov	eax, DWORD PTR _dotProduct$218181[esp+68]
	mov	DWORD PTR _maximum$[esp+64], edx
	mov	DWORD PTR _maximum$[esp+68], eax
	mov	ecx, 4
$LN17@estimateDi:
	fild	DWORD PTR _iDY$[ebp]
	fmul	QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA+88
	fild	DWORD PTR _iDX$[ebp]
	fmul	QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA+80
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _dotProduct$218181[esp+64]
	fld	QWORD PTR _maximum$[esp+64]
	fcomp	QWORD PTR _dotProduct$218181[esp+64]
	fnstsw	ax
	test	ah, 5
	mov	eax, 5
	jnp	SHORT $LN19@estimateDi

; 144  : 		}
; 145  : 	}
; 146  : 
; 147  : 	return (DirectionTypes) maximumIndex;

	mov	eax, ecx
$LN19@estimateDi:

; 148  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?estimateDirection@@YA?AW4DirectionTypes@@HH@Z ENDP	; estimateDirection
_TEXT	ENDS
PUBLIC	?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z		; isPotentialEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z PROC		; isPotentialEnemy, COMDAT

; 165  : 	return false;

	xor	al, al

; 166  : }

	ret	0
?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z ENDP		; isPotentialEnemy
_TEXT	ENDS
PUBLIC	?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z ; IsPromotionValidForUnitCombatType
EXTRN	?GetUnitCombatClass@CvPromotionEntry@@QBE_NH@Z:PROC ; CvPromotionEntry::GetUnitCombatClass
EXTRN	?GetUnitCombatType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetUnitCombatType
EXTRN	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z:PROC ; CvGlobals::getPromotionInfo
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z
_TEXT	SEGMENT
_ePromotion$ = 8					; size = 4
_eUnit$ = 12						; size = 4
?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z PROC ; IsPromotionValidForUnitCombatType, COMDAT

; 233  : 	CvUnitEntry* unitInfo = GC.getUnitInfo(eUnit);

	mov	eax, DWORD PTR _eUnit$[esp-4]
	push	esi
	push	edi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 234  : 	CvPromotionEntry* promotionInfo = GC.getPromotionInfo(ePromotion);

	mov	ecx, DWORD PTR _ePromotion$[esp+4]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	esi, eax
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	edi, eax

; 235  : 
; 236  : 	if(unitInfo == NULL || promotionInfo == NULL)

	test	esi, esi
	je	SHORT $LN3@IsPromotio
	test	edi, edi
	je	SHORT $LN3@IsPromotio

; 238  : 
; 239  : 	// No combat class (civilians)
; 240  : 	if(unitInfo->GetUnitCombatType() == NO_UNITCOMBAT)

	mov	ecx, esi
	call	?GetUnitCombatType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitCombatType
	cmp	eax, -1

; 241  : 	{
; 242  : 		return false;

	je	SHORT $LN3@IsPromotio

; 243  : 	}
; 244  : 
; 245  : 	// Combat class not valid for this Promotion
; 246  : 	if(!(promotionInfo->GetUnitCombatClass(unitInfo->GetUnitCombatType())))

	mov	ecx, esi
	call	?GetUnitCombatType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitCombatType
	push	eax
	mov	ecx, edi
	call	?GetUnitCombatClass@CvPromotionEntry@@QBE_NH@Z ; CvPromotionEntry::GetUnitCombatClass
	test	al, al
	pop	edi
	setne	al
	pop	esi

; 247  : 	{
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	return true;
; 252  : }

	ret	0
$LN3@IsPromotio:
	pop	edi

; 237  : 		return false;

	xor	al, al
	pop	esi

; 247  : 	{
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	return true;
; 252  : }

	ret	0
?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z ENDP ; IsPromotionValidForUnitCombatType
_TEXT	ENDS
PUBLIC	?IsPromotionValidForCivilianUnitType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z ; IsPromotionValidForCivilianUnitType
EXTRN	?GetCivilianUnitType@CvPromotionEntry@@QBE_NH@Z:PROC ; CvPromotionEntry::GetCivilianUnitType
; Function compile flags: /Ogtpy
;	COMDAT ?IsPromotionValidForCivilianUnitType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z
_TEXT	SEGMENT
_ePromotion$ = 8					; size = 4
_eUnit$ = 12						; size = 4
?IsPromotionValidForCivilianUnitType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z PROC ; IsPromotionValidForCivilianUnitType, COMDAT

; 257  : 	CvPromotionEntry* promotionInfo = GC.getPromotionInfo(ePromotion);

	mov	eax, DWORD PTR _ePromotion$[esp-4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo

; 258  : 
; 259  : 	if(promotionInfo == NULL)

	test	eax, eax
	jne	SHORT $LN2@IsPromotio@2

; 260  : 		return false;

	xor	al, al

; 263  : 	{
; 264  : 		return false;
; 265  : 	}
; 266  : 
; 267  : 	return true;
; 268  : }

	ret	0
$LN2@IsPromotio@2:

; 261  : 
; 262  : 	if(!(promotionInfo->GetCivilianUnitType((int)eUnit)))

	mov	ecx, DWORD PTR _eUnit$[esp-4]
	push	ecx
	mov	ecx, eax
	call	?GetCivilianUnitType@CvPromotionEntry@@QBE_NH@Z ; CvPromotionEntry::GetCivilianUnitType
	test	al, al
	setne	al

; 263  : 	{
; 264  : 		return false;
; 265  : 	}
; 266  : 
; 267  : 	return true;
; 268  : }

	ret	0
?IsPromotionValidForCivilianUnitType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z ENDP ; IsPromotionValidForCivilianUnitType
_TEXT	ENDS
PUBLIC	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
EXTRN	?GetPrereqOrPromotion9@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion9
EXTRN	?GetPrereqOrPromotion8@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion8
EXTRN	?GetPrereqOrPromotion7@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion7
EXTRN	?GetPrereqOrPromotion6@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion6
EXTRN	?GetPrereqOrPromotion5@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion5
EXTRN	?GetPrereqOrPromotion4@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion4
EXTRN	?GetPrereqOrPromotion3@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion3
EXTRN	?GetPrereqOrPromotion2@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion2
EXTRN	?GetPrereqOrPromotion1@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion1
EXTRN	?GetPrereqPromotion@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqPromotion
EXTRN	?IsBlitz@CvPromotionEntry@@QBE_NXZ:PROC		; CvPromotionEntry::IsBlitz
EXTRN	?GetMoves@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetMoves
EXTRN	?IsLeader@CvPromotionEntry@@QBE_NXZ:PROC	; CvPromotionEntry::IsLeader
EXTRN	?GetFreePromotions@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetFreePromotions
EXTRN	?IsCannotBeChosen@CvPromotionEntry@@QBE_NXZ:PROC ; CvPromotionEntry::IsCannotBeChosen
; Function compile flags: /Ogtpy
;	COMDAT ?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z
_TEXT	SEGMENT
_ePrereq2$ = -28					; size = 4
_ePrereq3$ = -24					; size = 4
_ePrereq4$ = -20					; size = 4
_ePrereq5$ = -16					; size = 4
_ePrereq6$ = -12					; size = 4
_ePrereq7$ = -8						; size = 4
_ePrereq8$ = -4						; size = 4
_ePromotion$ = 8					; size = 4
_eUnit$ = 12						; size = 4
_bLeader$ = 16						; size = 1
_bTestingPrereq$ = 20					; size = 1
?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z PROC ; isPromotionValid, COMDAT

; 271  : {

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp

; 272  : 	CvUnitEntry* unitInfo = GC.getUnitInfo(eUnit);

	mov	ebp, DWORD PTR _eUnit$[esp+32]
	push	esi
	push	edi
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 273  : 	CvPromotionEntry* promotionInfo = GC.getPromotionInfo(ePromotion);

	mov	ebx, DWORD PTR _ePromotion$[esp+40]
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	esi, eax

; 274  : 
; 275  : 	if(unitInfo == NULL || promotionInfo == NULL)

	test	edi, edi
	je	$LN31@isPromotio
	test	esi, esi
	je	$LN31@isPromotio

; 277  : 
; 278  : 	// Can this Promotion not be chosen through normal leveling?
; 279  : 	if(!bTestingPrereq && promotionInfo->IsCannotBeChosen())

	cmp	BYTE PTR _bTestingPrereq$[esp+40], 0
	jne	SHORT $LN30@isPromotio
	mov	ecx, esi
	call	?IsCannotBeChosen@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsCannotBeChosen
	test	al, al

; 280  : 	{
; 281  : 		return false;

	jne	$LN31@isPromotio
$LN30@isPromotio:

; 282  : 	}
; 283  : 
; 284  : 	// If a Unit gets a Promotion for free then hand it out, no questions asked
; 285  : 	if(unitInfo->GetFreePromotions(ePromotion))

	push	ebx
	mov	ecx, edi
	call	?GetFreePromotions@CvUnitEntry@@QBE_NH@Z ; CvUnitEntry::GetFreePromotions
	test	al, al
	je	SHORT $LN29@isPromotio
$LN1@isPromotio:
	pop	edi
	pop	esi
	pop	ebp

; 286  : 	{
; 287  : 		return true;

	mov	al, 1
	pop	ebx

; 440  : }

	add	esp, 28					; 0000001cH
	ret	0
$LN29@isPromotio:

; 288  : 	}
; 289  : 
; 290  : 	// If this isn't a combat Unit, no Promotion
; 291  : 	if(unitInfo->GetUnitCombatType() == NO_UNITCOMBAT)

	mov	ecx, edi
	call	?GetUnitCombatType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitCombatType
	cmp	eax, -1

; 292  : 	{
; 293  : 		return false;

	je	$LN31@isPromotio

; 294  : 	}
; 295  : 
; 296  : 	// Is this a valid Promotion for the UnitCombatType?
; 297  : 	if(!::IsPromotionValidForUnitCombatType(ePromotion, eUnit))

	push	ebp
	push	ebx
	call	?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z ; IsPromotionValidForUnitCombatType
	add	esp, 8
	test	al, al

; 298  : 	{
; 299  : 		return false;

	je	$LN31@isPromotio

; 300  : 	}
; 301  : 
; 302  : 	if(!bLeader && promotionInfo->IsLeader())

	mov	ebx, DWORD PTR _bLeader$[esp+40]
	test	bl, bl
	jne	SHORT $LN26@isPromotio
	mov	ecx, esi
	call	?IsLeader@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsLeader
	test	al, al

; 303  : 	{
; 304  : 		return false;

	jne	$LN31@isPromotio
$LN26@isPromotio:

; 305  : 	}
; 306  : 
; 307  : 	// If the Unit only has one move then Blitz is not useful
; 308  : 	if(unitInfo->GetMoves() == 1)

	mov	ecx, edi
	call	?GetMoves@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetMoves
	cmp	eax, 1
	jne	SHORT $LN24@isPromotio

; 309  : 	{
; 310  : 		if(promotionInfo->IsBlitz())

	mov	ecx, esi
	call	?IsBlitz@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsBlitz
	test	al, al

; 311  : 		{
; 312  : 			return false;

	jne	$LN31@isPromotio
$LN24@isPromotio:

; 313  : 		}
; 314  : 	}
; 315  : 
; 316  : 	// Promotion Prereqs
; 317  : 	if(NO_PROMOTION != promotionInfo->GetPrereqPromotion())

	mov	ecx, esi
	call	?GetPrereqPromotion@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqPromotion
	cmp	eax, -1
	je	SHORT $LN22@isPromotio

; 318  : 	{
; 319  : 		if(!isPromotionValid((PromotionTypes)promotionInfo->GetPrereqPromotion(), eUnit, bLeader, true))

	push	1
	push	ebx
	push	ebp
	mov	ecx, esi
	call	?GetPrereqPromotion@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqPromotion
	push	eax
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	test	al, al

; 320  : 		{
; 321  : 			return false;

	je	$LN31@isPromotio
$LN22@isPromotio:

; 322  : 		}
; 323  : 	}
; 324  : 
; 325  : 	PromotionTypes ePrereq1 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion1();

	mov	ecx, esi
	call	?GetPrereqOrPromotion1@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion1

; 326  : 	PromotionTypes ePrereq2 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion2();

	mov	ecx, esi
	mov	edi, eax
	call	?GetPrereqOrPromotion2@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion2

; 327  : 	PromotionTypes ePrereq3 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion3();

	mov	ecx, esi
	mov	DWORD PTR _ePrereq2$[esp+44], eax
	call	?GetPrereqOrPromotion3@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion3

; 328  : 	PromotionTypes ePrereq4 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion4();

	mov	ecx, esi
	mov	DWORD PTR _ePrereq3$[esp+44], eax
	call	?GetPrereqOrPromotion4@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion4

; 329  : 	PromotionTypes ePrereq5 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion5();

	mov	ecx, esi
	mov	DWORD PTR _ePrereq4$[esp+44], eax
	call	?GetPrereqOrPromotion5@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion5

; 330  : 	PromotionTypes ePrereq6 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion6();

	mov	ecx, esi
	mov	DWORD PTR _ePrereq5$[esp+44], eax
	call	?GetPrereqOrPromotion6@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion6

; 331  : 	PromotionTypes ePrereq7 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion7();

	mov	ecx, esi
	mov	DWORD PTR _ePrereq6$[esp+44], eax
	call	?GetPrereqOrPromotion7@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion7

; 332  : 	PromotionTypes ePrereq8 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion8();

	mov	ecx, esi
	mov	DWORD PTR _ePrereq7$[esp+44], eax
	call	?GetPrereqOrPromotion8@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion8

; 333  : 	PromotionTypes ePrereq9 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion9();

	mov	ecx, esi
	mov	DWORD PTR _ePrereq8$[esp+44], eax
	call	?GetPrereqOrPromotion9@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion9
	mov	esi, eax

; 334  : #ifdef AUI_WARNING_FIXES
; 335  : 	if ((ePrereq1 != NO_PROMOTION || ePrereq2 != NO_PROMOTION || ePrereq3 != NO_PROMOTION || ePrereq4 != NO_PROMOTION ||
; 336  : 			ePrereq5 != NO_PROMOTION || ePrereq6 != NO_PROMOTION || ePrereq7 != NO_PROMOTION || ePrereq8 != NO_PROMOTION || ePrereq9 != NO_PROMOTION) &&
; 337  : 		(NO_PROMOTION == ePrereq1 || !isPromotionValid(ePrereq1, eUnit, bLeader, true)) &&
; 338  : 		(NO_PROMOTION == ePrereq2 || !isPromotionValid(ePrereq2, eUnit, bLeader, true)) &&
; 339  : 		(NO_PROMOTION == ePrereq3 || !isPromotionValid(ePrereq3, eUnit, bLeader, true)) &&
; 340  : 		(NO_PROMOTION == ePrereq4 || !isPromotionValid(ePrereq4, eUnit, bLeader, true)) &&
; 341  : 		(NO_PROMOTION == ePrereq5 || !isPromotionValid(ePrereq5, eUnit, bLeader, true)) &&
; 342  : 		(NO_PROMOTION == ePrereq6 || !isPromotionValid(ePrereq6, eUnit, bLeader, true)) &&
; 343  : 		(NO_PROMOTION == ePrereq7 || !isPromotionValid(ePrereq7, eUnit, bLeader, true)) &&
; 344  : 		(NO_PROMOTION == ePrereq8 || !isPromotionValid(ePrereq8, eUnit, bLeader, true)) &&
; 345  : 		(NO_PROMOTION == ePrereq9 || !isPromotionValid(ePrereq9, eUnit, bLeader, true)))
; 346  : 	{
; 347  : 		return false;
; 348  : #else
; 349  : 	if(ePrereq1 != NO_PROMOTION ||
; 350  : 		ePrereq2 != NO_PROMOTION ||
; 351  : 		ePrereq3 != NO_PROMOTION ||
; 352  : 		ePrereq4 != NO_PROMOTION ||
; 353  : 		ePrereq5 != NO_PROMOTION ||
; 354  : 		ePrereq6 != NO_PROMOTION ||
; 355  : 		ePrereq7 != NO_PROMOTION ||
; 356  : 		ePrereq8 != NO_PROMOTION ||
; 357  : 		ePrereq9 != NO_PROMOTION)

	or	eax, -1
	cmp	edi, eax
	jne	SHORT $LN44@isPromotio
	cmp	DWORD PTR _ePrereq2$[esp+44], eax
	jne	SHORT $LN53@isPromotio
	cmp	DWORD PTR _ePrereq3$[esp+44], eax
	jne	SHORT $LN55@isPromotio
	cmp	DWORD PTR _ePrereq4$[esp+44], eax
	jne	$LN57@isPromotio
	cmp	DWORD PTR _ePrereq5$[esp+44], eax
	jne	$LN59@isPromotio
	cmp	DWORD PTR _ePrereq6$[esp+44], eax
	jne	$LN61@isPromotio
	cmp	DWORD PTR _ePrereq7$[esp+44], eax
	jne	$LN63@isPromotio
	cmp	DWORD PTR _ePrereq8$[esp+44], eax
	jne	$LN65@isPromotio
	cmp	esi, eax
	je	$LN1@isPromotio

; 358  : 	{
; 359  : 		bool bValid = false;
; 360  : 		if(!bValid)
; 361  : 		{
; 362  : 			if(NO_PROMOTION != ePrereq1 && isPromotionValid(ePrereq1, eUnit, bLeader, true))

	jmp	$LN52@isPromotio
$LN44@isPromotio:
	push	1
	push	ebx
	push	ebp
	push	edi
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN1@isPromotio

; 363  : 			{
; 364  : 				bValid = true;
; 365  : 			}
; 366  : 		}
; 367  : 
; 368  : 		if(!bValid)
; 369  : 		{
; 370  : 			if(NO_PROMOTION != ePrereq2 && isPromotionValid(ePrereq2, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq2$[esp+44], -1
	je	SHORT $LN67@isPromotio
$LN53@isPromotio:
	mov	eax, DWORD PTR _ePrereq2$[esp+44]
	push	1
	push	ebx
	push	ebp
	push	eax
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN1@isPromotio
$LN67@isPromotio:

; 371  : 			{
; 372  : 				bValid = true;
; 373  : 			}
; 374  : 		}
; 375  : 
; 376  : 		if(!bValid)
; 377  : 		{
; 378  : 			if(NO_PROMOTION != ePrereq3 && isPromotionValid(ePrereq3, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq3$[esp+44], -1
	je	SHORT $LN37@isPromotio
$LN55@isPromotio:
	mov	ecx, DWORD PTR _ePrereq3$[esp+44]
	push	1
	push	ebx
	push	ebp
	push	ecx
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN1@isPromotio
$LN37@isPromotio:

; 379  : 			{
; 380  : 				bValid = true;
; 381  : 			}
; 382  : 		}
; 383  : 
; 384  : 		if(!bValid)
; 385  : 		{
; 386  : 			if(NO_PROMOTION != ePrereq4 && isPromotionValid(ePrereq4, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq4$[esp+44], -1
	je	SHORT $LN38@isPromotio
$LN57@isPromotio:
	mov	edx, DWORD PTR _ePrereq4$[esp+44]
	push	1
	push	ebx
	push	ebp
	push	edx
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN1@isPromotio
$LN38@isPromotio:

; 387  : 			{
; 388  : 				bValid = true;
; 389  : 			}
; 390  : 		}
; 391  : 
; 392  : 		if(!bValid)
; 393  : 		{
; 394  : 			if(NO_PROMOTION != ePrereq5 && isPromotionValid(ePrereq5, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq5$[esp+44], -1
	je	SHORT $LN39@isPromotio
$LN59@isPromotio:
	mov	eax, DWORD PTR _ePrereq5$[esp+44]
	push	1
	push	ebx
	push	ebp
	push	eax
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN1@isPromotio
$LN39@isPromotio:

; 395  : 			{
; 396  : 				bValid = true;
; 397  : 			}
; 398  : 		}
; 399  : 
; 400  : 		if(!bValid)
; 401  : 		{
; 402  : 			if(NO_PROMOTION != ePrereq6 && isPromotionValid(ePrereq6, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq6$[esp+44], -1
	je	SHORT $LN40@isPromotio
$LN61@isPromotio:
	mov	ecx, DWORD PTR _ePrereq6$[esp+44]
	push	1
	push	ebx
	push	ebp
	push	ecx
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN1@isPromotio
$LN40@isPromotio:

; 403  : 			{
; 404  : 				bValid = true;
; 405  : 			}
; 406  : 		}
; 407  : 
; 408  : 		if(!bValid)
; 409  : 		{
; 410  : 			if(NO_PROMOTION != ePrereq7 && isPromotionValid(ePrereq7, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq7$[esp+44], -1
	je	SHORT $LN41@isPromotio
$LN63@isPromotio:
	mov	edx, DWORD PTR _ePrereq7$[esp+44]
	push	1
	push	ebx
	push	ebp
	push	edx
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN1@isPromotio
$LN41@isPromotio:

; 411  : 			{
; 412  : 				bValid = true;
; 413  : 			}
; 414  : 		}
; 415  : 
; 416  : 		if(!bValid)
; 417  : 		{
; 418  : 			if(NO_PROMOTION != ePrereq8 && isPromotionValid(ePrereq8, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq8$[esp+44], -1
	je	SHORT $LN42@isPromotio
$LN65@isPromotio:
	mov	eax, DWORD PTR _ePrereq8$[esp+44]
	push	1
	push	ebx
	push	ebp
	push	eax
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN1@isPromotio
$LN42@isPromotio:

; 419  : 			{
; 420  : 				bValid = true;
; 421  : 			}
; 422  : 		}
; 423  : 
; 424  : 		if(!bValid)
; 425  : 		{
; 426  : 			if(NO_PROMOTION != ePrereq9 && isPromotionValid(ePrereq9, eUnit, bLeader, true))

	cmp	esi, -1
	je	SHORT $LN31@isPromotio
$LN52@isPromotio:
	push	1
	push	ebx
	push	ebp
	push	esi
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	test	al, al

; 427  : 			{
; 428  : 				bValid = true;
; 429  : 			}
; 430  : 		}
; 431  : 
; 432  : 		if(!bValid)
; 433  : 		{
; 434  : 			return false;
; 435  : 		}
; 436  : #endif
; 437  : 	}
; 438  : 
; 439  : 	return true;

	jne	$LN1@isPromotio
$LN31@isPromotio:
	pop	edi
	pop	esi
	pop	ebp

; 276  : 		return false;

	xor	al, al
	pop	ebx

; 440  : }

	add	esp, 28					; 0000001cH
	ret	0
?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ENDP ; isPromotionValid
_TEXT	ENDS
PUBLIC	?getPopulationAsset@@YAHH@Z			; getPopulationAsset
; Function compile flags: /Ogtpy
;	COMDAT ?getPopulationAsset@@YAHH@Z
_TEXT	SEGMENT
_iPopulation$ = 8					; size = 4
?getPopulationAsset@@YAHH@Z PROC			; getPopulationAsset, COMDAT

; 444  : 	return (iPopulation * 2);

	mov	eax, DWORD PTR _iPopulation$[esp-4]
	add	eax, eax

; 445  : }

	ret	0
?getPopulationAsset@@YAHH@Z ENDP			; getPopulationAsset
_TEXT	ENDS
PUBLIC	?getLandPlotsAsset@@YAHH@Z			; getLandPlotsAsset
; Function compile flags: /Ogtpy
;	COMDAT ?getLandPlotsAsset@@YAHH@Z
_TEXT	SEGMENT
_iLandPlots$ = 8					; size = 4
?getLandPlotsAsset@@YAHH@Z PROC				; getLandPlotsAsset, COMDAT

; 449  : 	return iLandPlots;

	mov	eax, DWORD PTR _iLandPlots$[esp-4]

; 450  : }

	ret	0
?getLandPlotsAsset@@YAHH@Z ENDP				; getLandPlotsAsset
_TEXT	ENDS
PUBLIC	?getPopulationPower@@YAHH@Z			; getPopulationPower
; Function compile flags: /Ogtpy
;	COMDAT ?getPopulationPower@@YAHH@Z
_TEXT	SEGMENT
_iPopulation$ = 8					; size = 4
?getPopulationPower@@YAHH@Z PROC			; getPopulationPower, COMDAT

; 454  : 	return (iPopulation / 2);

	mov	eax, DWORD PTR _iPopulation$[esp-4]
	cdq
	sub	eax, edx
	sar	eax, 1

; 455  : }

	ret	0
?getPopulationPower@@YAHH@Z ENDP			; getPopulationPower
_TEXT	ENDS
PUBLIC	?getPopulationScore@@YAHH@Z			; getPopulationScore
; Function compile flags: /Ogtpy
;	COMDAT ?getPopulationScore@@YAHH@Z
_TEXT	SEGMENT
_iPopulation$ = 8					; size = 4
?getPopulationScore@@YAHH@Z PROC			; getPopulationScore, COMDAT

; 459  : 	return iPopulation;

	mov	eax, DWORD PTR _iPopulation$[esp-4]

; 460  : }

	ret	0
?getPopulationScore@@YAHH@Z ENDP			; getPopulationScore
_TEXT	ENDS
PUBLIC	?getLandPlotsScore@@YAHH@Z			; getLandPlotsScore
; Function compile flags: /Ogtpy
;	COMDAT ?getLandPlotsScore@@YAHH@Z
_TEXT	SEGMENT
_iLandPlots$ = 8					; size = 4
?getLandPlotsScore@@YAHH@Z PROC				; getLandPlotsScore, COMDAT

; 464  : 	return iLandPlots;

	mov	eax, DWORD PTR _iLandPlots$[esp-4]

; 465  : }

	ret	0
?getLandPlotsScore@@YAHH@Z ENDP				; getLandPlotsScore
_TEXT	ENDS
PUBLIC	?getTechScore@@YAHW4TechTypes@@@Z		; getTechScore
EXTRN	?GetEra@CvTechEntry@@QBEHXZ:PROC		; CvTechEntry::GetEra
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getTechScore@@YAHW4TechTypes@@@Z
_TEXT	SEGMENT
_eTech$ = 8						; size = 4
?getTechScore@@YAHW4TechTypes@@@Z PROC			; getTechScore, COMDAT

; 469  : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	mov	eax, DWORD PTR _eTech$[esp-4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 470  : 	if(pkTechInfo == NULL)

	test	eax, eax
	jne	SHORT $LN2@getTechSco

; 474  : }

	ret	0
$LN2@getTechSco:

; 471  : 		return 0;
; 472  : 	else
; 473  : 		return pkTechInfo->GetEra() + 1;

	mov	ecx, eax
	call	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra
	inc	eax

; 474  : }

	ret	0
?getTechScore@@YAHW4TechTypes@@@Z ENDP			; getTechScore
_TEXT	ENDS
PUBLIC	?getWonderScore@@YAHW4BuildingClassTypes@@@Z	; getWonderScore
EXTRN	?isLimitedWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isLimitedWonderClass
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getWonderScore@@YAHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_eWonderClass$ = 8					; size = 4
?getWonderScore@@YAHW4BuildingClassTypes@@@Z PROC	; getWonderScore, COMDAT

; 478  : 	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eWonderClass);

	mov	eax, DWORD PTR _eWonderClass$[esp-4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 479  : 	if(pkBuildingClassInfo)

	test	eax, eax
	je	SHORT $LN1@getWonderS

; 480  : 	{
; 481  : 		if(isLimitedWonderClass(*pkBuildingClassInfo))

	push	eax
	call	?isLimitedWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isLimitedWonderClass
	add	esp, 4
	test	al, al
	je	SHORT $LN1@getWonderS

; 482  : 			return 5;

	mov	eax, 5

; 486  : }

	ret	0
$LN1@getWonderS:

; 483  : 	}
; 484  : 
; 485  : 	return 0;

	xor	eax, eax

; 486  : }

	ret	0
?getWonderScore@@YAHW4BuildingClassTypes@@@Z ENDP	; getWonderScore
_TEXT	ENDS
PUBLIC	?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z ; finalImprovementUpgrade
EXTRN	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetImprovementUpgrade
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
; Function compile flags: /Ogtpy
;	COMDAT ?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z
_TEXT	SEGMENT
_eImprovement$ = 8					; size = 4
_iCount$ = 12						; size = 4
?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z PROC ; finalImprovementUpgrade, COMDAT

; 493  : {

	push	esi
	push	edi

; 494  : 	CvAssertMsg(eImprovement != NO_IMPROVEMENT, "Improvement is not assigned a valid value");
; 495  : 
; 496  : 	if(iCount > GC.getNumImprovementInfos())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	mov	edi, DWORD PTR _iCount$[esp+4]
	cmp	edi, eax
	jg	SHORT $LN8@finalImpro
	mov	esi, DWORD PTR _eImprovement$[esp+4]
	npad	8
$LL6@finalImpro:

; 499  : 	}
; 500  : 
; 501  : 	if(GC.getImprovementInfo(eImprovement)->GetImprovementUpgrade() != NO_IMPROVEMENT)

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementUpgrade
	cmp	eax, -1
	je	SHORT $LN2@finalImpro

; 502  : 	{
; 503  : 		return finalImprovementUpgrade(((ImprovementTypes)(GC.getImprovementInfo(eImprovement)->GetImprovementUpgrade())), (iCount + 1));

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementUpgrade
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	esi, eax
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	cmp	edi, eax
	jle	SHORT $LL6@finalImpro
$LN8@finalImpro:
	pop	edi

; 497  : 	{
; 498  : 		return NO_IMPROVEMENT;

	or	eax, -1
	pop	esi

; 508  : 	}
; 509  : }

	ret	0
$LN2@finalImpro:
	pop	edi

; 504  : 	}
; 505  : 	else
; 506  : 	{
; 507  : 		return eImprovement;

	mov	eax, esi
	pop	esi

; 508  : 	}
; 509  : }

	ret	0
?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z ENDP ; finalImprovementUpgrade
_TEXT	ENDS
PUBLIC	?isTechRequiredForProject@@YA_NW4TechTypes@@W4ProjectTypes@@@Z ; isTechRequiredForProject
EXTRN	?GetTechPrereq@CvProjectEntry@@QBEHXZ:PROC	; CvProjectEntry::GetTechPrereq
EXTRN	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z:PROC ; CvGlobals::getProjectInfo
; Function compile flags: /Ogtpy
;	COMDAT ?isTechRequiredForProject@@YA_NW4TechTypes@@W4ProjectTypes@@@Z
_TEXT	SEGMENT
_eTech$ = 8						; size = 4
_eProject$ = 12						; size = 4
?isTechRequiredForProject@@YA_NW4TechTypes@@W4ProjectTypes@@@Z PROC ; isTechRequiredForProject, COMDAT

; 559  : 	CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);

	mov	eax, DWORD PTR _eProject$[esp-4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo

; 560  : 	if(pkProjectInfo)

	test	eax, eax
	je	SHORT $LN1@isTechRequ

; 561  : 	{
; 562  : 		if(pkProjectInfo->GetTechPrereq() == eTech)

	mov	ecx, eax
	call	?GetTechPrereq@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetTechPrereq
	cmp	eax, DWORD PTR _eTech$[esp-4]
	jne	SHORT $LN1@isTechRequ

; 563  : 		{
; 564  : 			return true;

	mov	al, 1

; 569  : }

	ret	0
$LN1@isTechRequ:

; 565  : 		}
; 566  : 	}
; 567  : 
; 568  : 	return false;

	xor	al, al

; 569  : }

	ret	0
?isTechRequiredForProject@@YA_NW4TechTypes@@W4ProjectTypes@@@Z ENDP ; isTechRequiredForProject
_TEXT	ENDS
PUBLIC	?isWorldUnitClass@@YA_NW4UnitClassTypes@@@Z	; isWorldUnitClass
EXTRN	?getMaxGlobalInstances@CvUnitClassInfo@@QBEHXZ:PROC ; CvUnitClassInfo::getMaxGlobalInstances
EXTRN	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z:PROC ; CvGlobals::getUnitClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?isWorldUnitClass@@YA_NW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_eUnitClass$ = 8					; size = 4
?isWorldUnitClass@@YA_NW4UnitClassTypes@@@Z PROC	; isWorldUnitClass, COMDAT

; 573  : 	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);

	mov	eax, DWORD PTR _eUnitClass$[esp-4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo

; 574  : 	if(pkUnitClassInfo)

	test	eax, eax
	je	SHORT $LN1@isWorldUni

; 575  : 	{
; 576  : 		return (pkUnitClassInfo->getMaxGlobalInstances() != -1);

	mov	ecx, eax
	call	?getMaxGlobalInstances@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getMaxGlobalInstances
	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	al, cl

; 579  : }

	ret	0
$LN1@isWorldUni:

; 577  : 	}
; 578  : 	return false;

	xor	al, al

; 579  : }

	ret	0
?isWorldUnitClass@@YA_NW4UnitClassTypes@@@Z ENDP	; isWorldUnitClass
_TEXT	ENDS
PUBLIC	?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z	; isTeamUnitClass
EXTRN	?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ:PROC ; CvUnitClassInfo::getMaxTeamInstances
; Function compile flags: /Ogtpy
;	COMDAT ?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_eUnitClass$ = 8					; size = 4
?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z PROC		; isTeamUnitClass, COMDAT

; 583  : 	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);

	mov	eax, DWORD PTR _eUnitClass$[esp-4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo

; 584  : 	if(pkUnitClassInfo)

	test	eax, eax
	je	SHORT $LN1@isTeamUnit

; 585  : 	{
; 586  : 		return (pkUnitClassInfo->getMaxTeamInstances() != -1);

	mov	ecx, eax
	call	?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getMaxTeamInstances
	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	al, cl

; 589  : }

	ret	0
$LN1@isTeamUnit:

; 587  : 	}
; 588  : 	return false;

	xor	al, al

; 589  : }

	ret	0
?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z ENDP		; isTeamUnitClass
_TEXT	ENDS
PUBLIC	?isNationalUnitClass@@YA_NW4UnitClassTypes@@@Z	; isNationalUnitClass
EXTRN	?getMaxPlayerInstances@CvUnitClassInfo@@QBEHXZ:PROC ; CvUnitClassInfo::getMaxPlayerInstances
; Function compile flags: /Ogtpy
;	COMDAT ?isNationalUnitClass@@YA_NW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_eUnitClass$ = 8					; size = 4
?isNationalUnitClass@@YA_NW4UnitClassTypes@@@Z PROC	; isNationalUnitClass, COMDAT

; 593  : 	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);

	mov	eax, DWORD PTR _eUnitClass$[esp-4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo

; 594  : 	if(pkUnitClassInfo)

	test	eax, eax
	je	SHORT $LN1@isNational

; 595  : 	{
; 596  : 		return (pkUnitClassInfo->getMaxPlayerInstances() != -1);

	mov	ecx, eax
	call	?getMaxPlayerInstances@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getMaxPlayerInstances
	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	al, cl

; 599  : }

	ret	0
$LN1@isNational:

; 597  : 	}
; 598  : 	return false;

	xor	al, al

; 599  : }

	ret	0
?isNationalUnitClass@@YA_NW4UnitClassTypes@@@Z ENDP	; isNationalUnitClass
_TEXT	ENDS
PUBLIC	?isLimitedUnitClass@@YA_NW4UnitClassTypes@@@Z	; isLimitedUnitClass
; Function compile flags: /Ogtpy
;	COMDAT ?isLimitedUnitClass@@YA_NW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_eUnitClass$ = 8					; size = 4
?isLimitedUnitClass@@YA_NW4UnitClassTypes@@@Z PROC	; isLimitedUnitClass, COMDAT

; 602  : {

	push	esi

; 603  : 	return (isWorldUnitClass(eUnitClass) || isTeamUnitClass(eUnitClass) || isNationalUnitClass(eUnitClass));

	mov	esi, DWORD PTR _eUnitClass$[esp]
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
	test	eax, eax
	je	SHORT $LN14@isLimitedU
	mov	ecx, eax
	call	?getMaxGlobalInstances@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getMaxGlobalInstances
	cmp	eax, -1
	setne	al
	test	al, al
	jne	SHORT $LN3@isLimitedU
$LN14@isLimitedU:
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
	test	eax, eax
	je	SHORT $LN15@isLimitedU
	mov	ecx, eax
	call	?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getMaxTeamInstances
	cmp	eax, -1
	setne	al
	test	al, al
	jne	SHORT $LN3@isLimitedU
$LN15@isLimitedU:
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
	test	eax, eax
	je	SHORT $LN16@isLimitedU
	mov	ecx, eax
	call	?getMaxPlayerInstances@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getMaxPlayerInstances
	cmp	eax, -1
	setne	al
	test	al, al
	jne	SHORT $LN3@isLimitedU
$LN16@isLimitedU:
	xor	eax, eax
	pop	esi

; 604  : }

	ret	0
$LN3@isLimitedU:

; 603  : 	return (isWorldUnitClass(eUnitClass) || isTeamUnitClass(eUnitClass) || isNationalUnitClass(eUnitClass));

	mov	eax, 1
	pop	esi

; 604  : }

	ret	0
?isLimitedUnitClass@@YA_NW4UnitClassTypes@@@Z ENDP	; isLimitedUnitClass
_TEXT	ENDS
PUBLIC	?isWorldProject@@YA_NW4ProjectTypes@@@Z		; isWorldProject
EXTRN	?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ:PROC ; CvProjectEntry::GetMaxGlobalInstances
; Function compile flags: /Ogtpy
;	COMDAT ?isWorldProject@@YA_NW4ProjectTypes@@@Z
_TEXT	SEGMENT
_eProject$ = 8						; size = 4
?isWorldProject@@YA_NW4ProjectTypes@@@Z PROC		; isWorldProject, COMDAT

; 608  : 	CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);

	mov	eax, DWORD PTR _eProject$[esp-4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo

; 609  : 	if(pkProjectInfo)

	test	eax, eax
	je	SHORT $LN1@isWorldPro

; 610  : 	{
; 611  : 		return (pkProjectInfo->GetMaxGlobalInstances() != -1);

	mov	ecx, eax
	call	?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetMaxGlobalInstances
	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	al, cl

; 614  : }

	ret	0
$LN1@isWorldPro:

; 612  : 	}
; 613  : 	return false;

	xor	al, al

; 614  : }

	ret	0
?isWorldProject@@YA_NW4ProjectTypes@@@Z ENDP		; isWorldProject
_TEXT	ENDS
PUBLIC	?isTeamProject@@YA_NW4ProjectTypes@@@Z		; isTeamProject
EXTRN	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ:PROC ; CvProjectEntry::GetMaxTeamInstances
; Function compile flags: /Ogtpy
;	COMDAT ?isTeamProject@@YA_NW4ProjectTypes@@@Z
_TEXT	SEGMENT
_eProject$ = 8						; size = 4
?isTeamProject@@YA_NW4ProjectTypes@@@Z PROC		; isTeamProject, COMDAT

; 618  : 	CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);

	mov	eax, DWORD PTR _eProject$[esp-4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo

; 619  : 	if(pkProjectInfo)

	test	eax, eax
	je	SHORT $LN1@isTeamProj

; 620  : 	{
; 621  : 		return (pkProjectInfo->GetMaxTeamInstances() != -1);

	mov	ecx, eax
	call	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetMaxTeamInstances
	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	al, cl

; 624  : }

	ret	0
$LN1@isTeamProj:

; 622  : 	}
; 623  : 	return false;

	xor	al, al

; 624  : }

	ret	0
?isTeamProject@@YA_NW4ProjectTypes@@@Z ENDP		; isTeamProject
_TEXT	ENDS
PUBLIC	?isLimitedProject@@YA_NW4ProjectTypes@@@Z	; isLimitedProject
; Function compile flags: /Ogtpy
;	COMDAT ?isLimitedProject@@YA_NW4ProjectTypes@@@Z
_TEXT	SEGMENT
_eProject$ = 8						; size = 4
?isLimitedProject@@YA_NW4ProjectTypes@@@Z PROC		; isLimitedProject, COMDAT

; 627  : {

	push	esi

; 628  : 	return (isWorldProject(eProject) || isTeamProject(eProject));

	mov	esi, DWORD PTR _eProject$[esp]
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	test	eax, eax
	je	SHORT $LN11@isLimitedP
	mov	ecx, eax
	call	?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetMaxGlobalInstances
	cmp	eax, -1
	setne	al
	test	al, al
	jne	SHORT $LN3@isLimitedP
$LN11@isLimitedP:
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	test	eax, eax
	je	SHORT $LN12@isLimitedP
	mov	ecx, eax
	call	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetMaxTeamInstances
	cmp	eax, -1
	setne	al
	test	al, al
	jne	SHORT $LN3@isLimitedP
$LN12@isLimitedP:
	xor	eax, eax
	pop	esi

; 629  : }

	ret	0
$LN3@isLimitedP:

; 628  : 	return (isWorldProject(eProject) || isTeamProject(eProject));

	mov	eax, 1
	pop	esi

; 629  : }

	ret	0
?isLimitedProject@@YA_NW4ProjectTypes@@@Z ENDP		; isLimitedProject
_TEXT	ENDS
PUBLIC	?PUF_isTeam@@YA_NPBVCvUnit@@HH@Z		; PUF_isTeam
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isTeam@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isTeam@@YA_NPBVCvUnit@@HH@Z PROC			; PUF_isTeam, COMDAT

; 705  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 706  : 	return (pUnit->getTeam() == iData1);

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	xor	ecx, ecx
	cmp	eax, DWORD PTR _iData1$[esp-4]
	sete	cl
	mov	al, cl

; 707  : }

	ret	0
?PUF_isTeam@@YA_NPBVCvUnit@@HH@Z ENDP			; PUF_isTeam
_TEXT	ENDS
PUBLIC	?PUF_canDefend@@YA_NPBVCvUnit@@HH@Z		; PUF_canDefend
EXTRN	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::IsCanDefend
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_canDefend@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_canDefend@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_canDefend, COMDAT

; 802  : 	return pUnit->IsCanDefend();

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	push	0
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend

; 803  : }

	ret	0
?PUF_canDefend@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_canDefend
_TEXT	ENDS
PUBLIC	?PUF_cannotDefend@@YA_NPBVCvUnit@@HH@Z		; PUF_cannotDefend
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_cannotDefend@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_cannotDefend@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_cannotDefend, COMDAT

; 807  : 	return !(pUnit->IsCanDefend());

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	push	0
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	xor	ecx, ecx
	test	al, al
	sete	cl
	mov	al, cl

; 808  : }

	ret	0
?PUF_cannotDefend@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_cannotDefend
_TEXT	ENDS
PUBLIC	?PUF_isFighting@@YA_NPBVCvUnit@@HH@Z		; PUF_isFighting
EXTRN	?isFighting@CvUnit@@QBE_NXZ:PROC		; CvUnit::isFighting
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isFighting@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isFighting@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isFighting, COMDAT

; 825  : 	return pUnit->isFighting();

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	jmp	?isFighting@CvUnit@@QBE_NXZ		; CvUnit::isFighting
?PUF_isFighting@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isFighting
_TEXT	ENDS
PUBLIC	?PUF_isDomainType@@YA_NPBVCvUnit@@HH@Z		; PUF_isDomainType
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isDomainType@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isDomainType@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isDomainType, COMDAT

; 830  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 831  : 	return (pUnit->getDomainType() == iData1);

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	xor	ecx, ecx
	cmp	eax, DWORD PTR _iData1$[esp-4]
	sete	cl
	mov	al, cl

; 832  : }

	ret	0
?PUF_isDomainType@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isDomainType
_TEXT	ENDS
PUBLIC	?PUF_isUnitType@@YA_NPBVCvUnit@@HH@Z		; PUF_isUnitType
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isUnitType@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isUnitType@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isUnitType, COMDAT

; 836  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 837  : 	return (pUnit->getUnitType() == iData1);

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	xor	ecx, ecx
	cmp	eax, DWORD PTR _iData1$[esp-4]
	sete	cl
	mov	al, cl

; 838  : }

	ret	0
?PUF_isUnitType@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isUnitType
_TEXT	ENDS
PUBLIC	?PUF_isUnitAIType@@YA_NPBVCvUnit@@HH@Z		; PUF_isUnitAIType
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isUnitAIType@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isUnitAIType@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isUnitAIType, COMDAT

; 842  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 843  : 	return (pUnit->AI_getUnitAIType() == iData1);

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	xor	ecx, ecx
	cmp	eax, DWORD PTR _iData1$[esp-4]
	sete	cl
	mov	al, cl

; 844  : }

	ret	0
?PUF_isUnitAIType@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isUnitAIType
_TEXT	ENDS
PUBLIC	?PUF_isSelected@@YA_NPBVCvUnit@@HH@Z		; PUF_isSelected
EXTRN	?IsSelected@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsSelected
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isSelected@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isSelected@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isSelected, COMDAT

; 848  : 	return pUnit->IsSelected();

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	jmp	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
?PUF_isSelected@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isSelected
_TEXT	ENDS
PUBLIC	?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z	; PUF_makeInfoBarDirty
EXTRN	?setInfoBarDirty@CvUnit@@QAEX_N@Z:PROC		; CvUnit::setInfoBarDirty
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z PROC		; PUF_makeInfoBarDirty, COMDAT

; 853  : 	pUnit->setInfoBarDirty(true);

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	push	1
	call	?setInfoBarDirty@CvUnit@@QAEX_N@Z	; CvUnit::setInfoBarDirty

; 854  : 	return true;

	mov	al, 1

; 855  : }

	ret	0
?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z ENDP		; PUF_makeInfoBarDirty
_TEXT	ENDS
PUBLIC	?PUF_isNoMission@@YA_NPBVCvUnit@@HH@Z		; PUF_isNoMission
EXTRN	?GetActivityType@CvUnit@@QBE?AW4ActivityTypes@@XZ:PROC ; CvUnit::GetActivityType
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isNoMission@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isNoMission@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isNoMission, COMDAT

; 859  : 	return (pUnit->GetActivityType() != ACTIVITY_MISSION);

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	call	?GetActivityType@CvUnit@@QBE?AW4ActivityTypes@@XZ ; CvUnit::GetActivityType
	xor	ecx, ecx
	cmp	eax, 6
	setne	cl
	mov	al, cl

; 860  : }

	ret	0
?PUF_isNoMission@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isNoMission
_TEXT	ENDS
PUBLIC	?PUF_isFiniteRange@@YA_NPBVCvUnit@@HH@Z		; PUF_isFiniteRange
EXTRN	?GetRange@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetRange
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isFiniteRange@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isFiniteRange@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isFiniteRange, COMDAT

; 863  : {

	push	esi

; 864  : 	return ((pUnit->getDomainType() != DOMAIN_AIR) || (pUnit->getUnitInfo().GetRange() > 0));

	mov	esi, DWORD PTR _pUnit$[esp]
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN3@PUF_isFini
	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetRange@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetRange
	test	eax, eax
	jg	SHORT $LN3@PUF_isFini
	xor	eax, eax
	pop	esi

; 865  : }

	ret	0
$LN3@PUF_isFini:

; 864  : 	return ((pUnit->getDomainType() != DOMAIN_AIR) || (pUnit->getUnitInfo().GetRange() > 0));

	mov	eax, 1
	pop	esi

; 865  : }

	ret	0
?PUF_isFiniteRange@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isFiniteRange
_TEXT	ENDS
PUBLIC	?shuffleArray@@YAXPAHHAAVCvRandom@@@Z		; shuffleArray
EXTRN	?get@CvRandom@@QAEGGPBD@Z:PROC			; CvRandom::get
; Function compile flags: /Ogtpy
;	COMDAT ?shuffleArray@@YAXPAHHAAVCvRandom@@@Z
_TEXT	SEGMENT
_piShuffle$ = 8						; size = 4
_iNum$ = 12						; size = 4
_rand$ = 16						; size = 4
?shuffleArray@@YAXPAHHAAVCvRandom@@@Z PROC		; shuffleArray, COMDAT

; 898  : {

	push	ebx

; 899  : 	int iI, iJ;
; 900  : 
; 901  : 	for(iI = 0; iI < iNum; iI++)

	mov	ebx, DWORD PTR _iNum$[esp]
	push	esi
	xor	eax, eax
	push	edi
	mov	edi, DWORD PTR _piShuffle$[esp+8]
	test	ebx, ebx
	jle	SHORT $LN5@shuffleArr
$LL7@shuffleArr:

; 902  : 	{
; 903  : 		piShuffle[iI] = iI;

	mov	DWORD PTR [edi+eax*4], eax
	inc	eax
	cmp	eax, ebx
	jl	SHORT $LL7@shuffleArr
$LN5@shuffleArr:

; 904  : 	}
; 905  : 
; 906  : 	for(iI = 0; iI < iNum; iI++)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN2@shuffleArr
	push	ebp
	mov	ebp, DWORD PTR _rand$[esp+12]
$LL14@shuffleArr:

; 907  : 	{
; 908  : 		iJ = (rand.get(iNum - iI, NULL) + iI);

	mov	eax, ebx
	push	0
	sub	eax, esi
	push	eax
	mov	ecx, ebp
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	eax, ax
	add	eax, esi

; 909  : 
; 910  : 		if(iI != iJ)

	cmp	esi, eax
	je	SHORT $LN3@shuffleArr

; 911  : 		{
; 912  : 			int iTemp = piShuffle[iI];
; 913  : 			piShuffle[iI] = piShuffle[iJ];

	mov	edx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [edi+esi*4]
	mov	DWORD PTR [edi+esi*4], edx

; 914  : 			piShuffle[iJ] = iTemp;

	mov	DWORD PTR [edi+eax*4], ecx
$LN3@shuffleArr:
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL14@shuffleArr
	pop	ebp
$LN2@shuffleArr:
	pop	edi
	pop	esi
	pop	ebx

; 915  : 		}
; 916  : 	}
; 917  : }

	ret	0
?shuffleArray@@YAXPAHHAAVCvRandom@@@Z ENDP		; shuffleArray
_TEXT	ENDS
PUBLIC	?stringToBools@@YAXPBDPAHPAPA_N@Z		; stringToBools
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Ogtpy
;	COMDAT ?stringToBools@@YAXPBDPAHPAPA_N@Z
_TEXT	SEGMENT
_szString$ = 8						; size = 4
_iNumBools$ = 12					; size = 4
_ppBools$ = 16						; size = 4
?stringToBools@@YAXPBDPAHPAPA_N@Z PROC			; stringToBools, COMDAT

; 1017 : {

	push	edi

; 1018 : 	CvAssertMsg(szString, "null string");
; 1019 : 	if(szString)

	mov	edi, DWORD PTR _szString$[esp]
	test	edi, edi
	je	SHORT $LN1@stringToBo

; 1020 : 	{
; 1021 : 		*iNumBools = strlen(szString);

	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL9@stringToBo:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL9@stringToBo
	sub	eax, edx
	push	esi
	mov	esi, DWORD PTR _iNumBools$[esp+4]

; 1022 : 		*ppBools = FNEW(bool[*iNumBools], c_eCiv5GameplayDLL, 0);

	push	eax
	mov	DWORD PTR [esi], eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR _ppBools$[esp+8]
	mov	DWORD PTR [ecx], eax

; 1023 : 		int i;
; 1024 : 		for(i=0; i<*iNumBools; i++)

	xor	eax, eax
	add	esp, 4
	cmp	DWORD PTR [esi], eax
	jle	SHORT $LN10@stringToBo
	push	ebx
$LL3@stringToBo:

; 1025 : 		{
; 1026 : 			(*ppBools)[i] = (szString[i]=='1');

	cmp	BYTE PTR [eax+edi], 49			; 00000031H
	mov	ebx, DWORD PTR [ecx]
	sete	dl
	mov	BYTE PTR [eax+ebx], dl
	inc	eax
	cmp	eax, DWORD PTR [esi]
	jl	SHORT $LL3@stringToBo
	pop	ebx
$LN10@stringToBo:
	pop	esi
$LN1@stringToBo:
	pop	edi

; 1027 : 		}
; 1028 : 	}
; 1029 : }

	ret	0
?stringToBools@@YAXPBDPAHPAPA_N@Z ENDP			; stringToBools
_TEXT	ENDS
PUBLIC	?getRotatedPosition@@YAXHHW4DirectionTypes@@AAH1@Z ; getRotatedPosition
; Function compile flags: /Ogtpy
;	COMDAT ?getRotatedPosition@@YAXHHW4DirectionTypes@@AAH1@Z
_TEXT	SEGMENT
_inHexspaceX$ = 8					; size = 4
_inHexspaceY$ = 12					; size = 4
_rotatedDirection$ = 16					; size = 4
_outRotatedX$ = 20					; size = 4
_outRotatedY$ = 24					; size = 4
?getRotatedPosition@@YAXHHW4DirectionTypes@@AAH1@Z PROC	; getRotatedPosition, COMDAT

; 1322 : 	outRotatedX = inHexspaceX;
; 1323 : 	outRotatedY = inHexspaceY;
; 1324 : 
; 1325 : 	// early out if the facing is NE as that is the base rotation that the data is supposed to be stored in
; 1326 : 	// also early out if we are looking at the pivot
; 1327 : 	if(DIRECTION_NORTHEAST == rotatedDirection || (inHexspaceX == 0 && inHexspaceY == 0))

	cmp	DWORD PTR _rotatedDirection$[esp-4], 0
	mov	eax, DWORD PTR _outRotatedX$[esp-4]
	mov	ecx, DWORD PTR _outRotatedY$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _inHexspaceY$[esp]
	push	edi
	mov	edi, DWORD PTR _inHexspaceX$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [ecx], ebx
	je	$LN17@getRotated
	test	edi, edi
	jne	SHORT $LN18@getRotated
	test	ebx, ebx
	je	$LN17@getRotated
$LN18@getRotated:

; 1328 : 	{
; 1329 : 		return;
; 1330 : 	};
; 1331 : 
; 1332 : 	// find the ring that this is on
; 1333 : 	int ring = hexDistance(inHexspaceX, inHexspaceY);

	xor	edx, edx
	test	edi, edi
	setge	dl
	xor	eax, eax
	test	ebx, ebx
	setge	al
	push	esi
	cmp	edx, eax
	jne	SHORT $LN22@getRotated
	mov	ecx, edi
	test	edi, edi
	jge	SHORT $LN26@getRotated
	neg	ecx
$LN26@getRotated:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN28@getRotated
	neg	eax
$LN28@getRotated:
	lea	esi, DWORD PTR [eax+ecx]
	jmp	SHORT $LN34@getRotated
$LN22@getRotated:
	mov	esi, edi
	test	edi, edi
	jge	SHORT $LN30@getRotated
	neg	esi
$LN30@getRotated:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN32@getRotated
	neg	eax
$LN32@getRotated:
	cmp	esi, eax
	jge	SHORT $LN34@getRotated
	mov	esi, eax
$LN34@getRotated:
	push	ebp

; 1334 : 
; 1335 : 	// find the nearest spike direction
; 1336 : 	DirectionTypes spikeDirection = hexspaceSpikeDirection(inHexspaceX, inHexspaceY);

	push	ebx
	push	edi
	call	?hexspaceSpikeDirection@@YA?AW4DirectionTypes@@HH@Z ; hexspaceSpikeDirection
	mov	ebp, eax
	add	esp, 8

; 1337 : 
; 1338 : 	int spikeX = 0;

	xor	ecx, ecx

; 1339 : 	int spikeY = 0;

	xor	edx, edx

; 1340 : 	switch(spikeDirection)

	cmp	ebp, 5
	ja	SHORT $LN15@getRotated
	jmp	DWORD PTR $LN53@getRotated[ebp*4]
$LN13@getRotated:

; 1341 : 	{
; 1342 : 	case DIRECTION_NORTHEAST:
; 1343 : 	{
; 1344 : 		spikeY = ring;
; 1345 : 	}
; 1346 : 	break;
; 1347 : 	case DIRECTION_EAST:
; 1348 : 	{
; 1349 : 		spikeX = ring;

	mov	ecx, esi

; 1350 : 	}
; 1351 : 	break;

	jmp	SHORT $LN15@getRotated
$LN12@getRotated:

; 1352 : 	case DIRECTION_SOUTHEAST:
; 1353 : 	{
; 1354 : 		spikeX = ring;

	mov	ecx, esi
$LN11@getRotated:

; 1355 : 		spikeY = -ring;

	mov	edx, esi
	neg	edx

; 1356 : 	}
; 1357 : 	break;

	jmp	SHORT $LN15@getRotated
$LN10@getRotated:

; 1358 : 	case DIRECTION_SOUTHWEST:
; 1359 : 	{
; 1360 : 		spikeY = -ring;
; 1361 : 	}
; 1362 : 	break;
; 1363 : 	case DIRECTION_WEST:
; 1364 : 	{
; 1365 : 		spikeX = -ring;

	mov	ecx, esi
	neg	ecx

; 1366 : 	}
; 1367 : 	break;

	jmp	SHORT $LN15@getRotated
$LN9@getRotated:

; 1368 : 	case DIRECTION_NORTHWEST:
; 1369 : 	{
; 1370 : 		spikeX = -ring;

	mov	ecx, esi
	neg	ecx
$LN14@getRotated:

; 1371 : 		spikeY = ring;

	mov	edx, esi
$LN15@getRotated:

; 1372 : 	}
; 1373 : 	break;
; 1374 : 	}
; 1375 : 
; 1376 : 	// find the offset of this point from the spike
; 1377 : 	int offsetOnThisRing = hexDistance(spikeX-inHexspaceX,spikeY-inHexspaceY);

	sub	edx, ebx
	sub	ecx, edi
	mov	edi, ecx
	mov	ecx, 0
	setns	cl
	xor	eax, eax
	test	edx, edx
	setge	al
	cmp	ecx, eax
	jne	SHORT $LN36@getRotated
	test	edi, edi
	jge	SHORT $LN40@getRotated
	neg	edi
$LN40@getRotated:
	test	edx, edx
	jge	SHORT $LN42@getRotated
	neg	edx
$LN42@getRotated:
	lea	ecx, DWORD PTR [edx+edi]
	jmp	SHORT $LN48@getRotated
$LN36@getRotated:
	test	edi, edi
	jge	SHORT $LN50@getRotated
	neg	edi
$LN50@getRotated:
	mov	ecx, edi
	test	edx, edx
	jge	SHORT $LN46@getRotated
	neg	edx
$LN46@getRotated:
	cmp	ecx, edx
	jge	SHORT $LN48@getRotated
	mov	ecx, edx
$LN48@getRotated:

; 1378 : 
; 1379 : 	// find the rotated spike
; 1380 : 	int newSpikeX = 0;
; 1381 : 	int newSpikeY = 0;
; 1382 : 	DirectionTypes newSpikeDirection = (DirectionTypes)((spikeDirection + rotatedDirection) % (NUM_DIRECTION_TYPES));

	mov	edx, DWORD PTR _rotatedDirection$[esp+12]
	lea	eax, DWORD PTR [edx+ebp]
	cdq
	mov	edi, 6
	idiv	edi
	pop	ebp

; 1383 : 	switch(newSpikeDirection)

	cmp	edx, 5
	ja	SHORT $LN49@getRotated
	jmp	DWORD PTR $LN54@getRotated[edx*4]
$LN6@getRotated:

; 1424 : 	}
; 1425 : 	break;
; 1426 : 	case DIRECTION_NORTHWEST:
; 1427 : 	{
; 1428 : 		newSpikeX = -ring;
; 1429 : 		newSpikeY = ring;
; 1430 : 		// add in the offset in the appropriate direction
; 1431 : 		outRotatedX = newSpikeX+offsetOnThisRing;

	mov	eax, DWORD PTR _outRotatedX$[esp+8]
	sub	esi, ecx
	mov	DWORD PTR [eax], ecx

; 1432 : 		outRotatedY = newSpikeY;

	mov	ecx, DWORD PTR _outRotatedY$[esp+8]
	mov	DWORD PTR [ecx], esi
	pop	esi
	pop	edi
	pop	ebx

; 1433 : 	}
; 1434 : 	break;
; 1435 : 	}
; 1436 : }

	ret	0
$LN5@getRotated:

; 1384 : 	{
; 1385 : 	case DIRECTION_NORTHEAST:
; 1386 : 	{
; 1387 : 		newSpikeY = ring;
; 1388 : 		// add in the offset in the appropriate direction
; 1389 : 		outRotatedX = newSpikeX+offsetOnThisRing;
; 1390 : 		outRotatedY = newSpikeY-offsetOnThisRing;
; 1391 : 	}
; 1392 : 	break;
; 1393 : 	case DIRECTION_EAST:
; 1394 : 	{
; 1395 : 		newSpikeX = ring;
; 1396 : 		// add in the offset in the appropriate direction
; 1397 : 		outRotatedX = newSpikeX;

	mov	edx, DWORD PTR _outRotatedX$[esp+8]

; 1398 : 		outRotatedY = newSpikeY-offsetOnThisRing;

	mov	eax, DWORD PTR _outRotatedY$[esp+8]
	mov	DWORD PTR [edx], esi
	pop	esi
	neg	ecx
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 1433 : 	}
; 1434 : 	break;
; 1435 : 	}
; 1436 : }

	ret	0
$LN4@getRotated:

; 1399 : 	}
; 1400 : 	break;
; 1401 : 	case DIRECTION_SOUTHEAST:
; 1402 : 	{
; 1403 : 		newSpikeX = ring;
; 1404 : 		newSpikeY = -ring;
; 1405 : 		// add in the offset in the appropriate direction
; 1406 : 		outRotatedX = newSpikeX-offsetOnThisRing;

	mov	eax, DWORD PTR _outRotatedX$[esp+8]
	mov	edx, esi
	sub	edx, ecx

; 1432 : 		outRotatedY = newSpikeY;

	mov	ecx, DWORD PTR _outRotatedY$[esp+8]
	neg	esi
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [ecx], esi
	pop	esi
	pop	edi
	pop	ebx

; 1433 : 	}
; 1434 : 	break;
; 1435 : 	}
; 1436 : }

	ret	0
$LN3@getRotated:

; 1407 : 		outRotatedY = newSpikeY;
; 1408 : 	}
; 1409 : 	break;
; 1410 : 	case DIRECTION_SOUTHWEST:
; 1411 : 	{
; 1412 : 		newSpikeY = -ring;
; 1413 : 		// add in the offset in the appropriate direction
; 1414 : 		outRotatedX = newSpikeX-offsetOnThisRing;

	mov	eax, DWORD PTR _outRotatedX$[esp+8]
	mov	edx, ecx
	neg	edx

; 1415 : 		outRotatedY = newSpikeY+offsetOnThisRing;

	sub	ecx, esi
	pop	esi
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR _outRotatedY$[esp+4]
	pop	edi
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 1433 : 	}
; 1434 : 	break;
; 1435 : 	}
; 1436 : }

	ret	0
$LN2@getRotated:

; 1416 : 	}
; 1417 : 	break;
; 1418 : 	case DIRECTION_WEST:
; 1419 : 	{
; 1420 : 		newSpikeX = -ring;
; 1421 : 		// add in the offset in the appropriate direction
; 1422 : 		outRotatedX = newSpikeX;

	mov	eax, DWORD PTR _outRotatedX$[esp+8]

; 1423 : 		outRotatedY = newSpikeY+offsetOnThisRing;

	mov	edx, DWORD PTR _outRotatedY$[esp+8]
	neg	esi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	edi
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 1433 : 	}
; 1434 : 	break;
; 1435 : 	}
; 1436 : }

	ret	0
$LN1@getRotated:

; 1424 : 	}
; 1425 : 	break;
; 1426 : 	case DIRECTION_NORTHWEST:
; 1427 : 	{
; 1428 : 		newSpikeX = -ring;
; 1429 : 		newSpikeY = ring;
; 1430 : 		// add in the offset in the appropriate direction
; 1431 : 		outRotatedX = newSpikeX+offsetOnThisRing;

	mov	eax, DWORD PTR _outRotatedX$[esp+8]
	sub	ecx, esi
	mov	DWORD PTR [eax], ecx

; 1432 : 		outRotatedY = newSpikeY;

	mov	ecx, DWORD PTR _outRotatedY$[esp+8]
	mov	DWORD PTR [ecx], esi
$LN49@getRotated:
	pop	esi
$LN17@getRotated:
	pop	edi
	pop	ebx

; 1433 : 	}
; 1434 : 	break;
; 1435 : 	}
; 1436 : }

	ret	0
	npad	2
$LN53@getRotated:
	DD	$LN14@getRotated
	DD	$LN13@getRotated
	DD	$LN12@getRotated
	DD	$LN11@getRotated
	DD	$LN10@getRotated
	DD	$LN9@getRotated
$LN54@getRotated:
	DD	$LN6@getRotated
	DD	$LN5@getRotated
	DD	$LN4@getRotated
	DD	$LN3@getRotated
	DD	$LN2@getRotated
	DD	$LN1@getRotated
?getRotatedPosition@@YAXHHW4DirectionTypes@@AAH1@Z ENDP	; getRotatedPosition
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?SkipGUIDSeparators@@YAIPBDI@Z
_TEXT	SEGMENT
?SkipGUIDSeparators@@YAIPBDI@Z PROC			; SkipGUIDSeparators, COMDAT
; _pszGUID$ = edi
; _uiStartIndex$ = eax

; 1441 : 	UINT uiLength = strlen(pszGUID);

	mov	ecx, edi
	push	esi
	lea	esi, DWORD PTR [ecx+1]
$LL11@SkipGUIDSe:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL11@SkipGUIDSe
	sub	ecx, esi
	pop	esi

; 1442 : 	if(uiStartIndex < uiLength)

	cmp	eax, ecx
	jae	SHORT $LN4@SkipGUIDSe
$LL6@SkipGUIDSe:

; 1443 : 	{
; 1444 : 		do
; 1445 : 		{
; 1446 : 			char ch = pszGUID[uiStartIndex];

	mov	dl, BYTE PTR [edi+eax]

; 1447 : 			if(ch == '{' || ch == '-' || ch == ' ')

	cmp	dl, 123					; 0000007bH
	je	SHORT $LN2@SkipGUIDSe
	cmp	dl, 45					; 0000002dH
	je	SHORT $LN2@SkipGUIDSe
	cmp	dl, 32					; 00000020H
	jne	SHORT $LN4@SkipGUIDSe
$LN2@SkipGUIDSe:

; 1448 : 				++uiStartIndex;

	inc	eax

; 1449 : 			else
; 1450 : 				break;
; 1451 : 
; 1452 : 		}
; 1453 : 		while(uiStartIndex < uiLength);

	cmp	eax, ecx
	jb	SHORT $LL6@SkipGUIDSe
$LN4@SkipGUIDSe:

; 1454 : 	}
; 1455 : 	return uiStartIndex;
; 1456 : }

	ret	0
?SkipGUIDSeparators@@YAIPBDI@Z ENDP			; SkipGUIDSeparators
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetHexDigitValue@@YA_NDAAI@Z
_TEXT	SEGMENT
?GetHexDigitValue@@YA_NDAAI@Z PROC			; GetHexDigitValue, COMDAT
; _ch$ = eax
; _uiValue$ = ecx

; 1461 : 	if(ch >= '0' && ch <= '9')

	mov	dl, al
	sub	dl, 48					; 00000030H
	cmp	dl, 9
	ja	SHORT $LN6@GetHexDigi

; 1462 : 		uiValue = (uint)(ch - '0');

	movsx	eax, al
	sub	eax, 48					; 00000030H

; 1466 : 		uiValue = (uint)((ch - 'A') + 10);

	mov	DWORD PTR [ecx], eax

; 1469 : 
; 1470 : 	return true;

	mov	al, 1

; 1471 : }

	ret	0
$LN6@GetHexDigi:

; 1463 : 	else if(ch >= 'a' && ch <= 'f')

	mov	dl, al
	sub	dl, 97					; 00000061H
	cmp	dl, 5
	ja	SHORT $LN4@GetHexDigi

; 1464 : 		uiValue = (uint)((ch - 'a') + 10);

	movsx	eax, al
	sub	eax, 87					; 00000057H

; 1466 : 		uiValue = (uint)((ch - 'A') + 10);

	mov	DWORD PTR [ecx], eax

; 1469 : 
; 1470 : 	return true;

	mov	al, 1

; 1471 : }

	ret	0
$LN4@GetHexDigi:

; 1465 : 	else if(ch >= 'A' && ch <= 'F')

	mov	dl, al
	sub	dl, 65					; 00000041H
	cmp	dl, 5
	ja	SHORT $LN2@GetHexDigi

; 1466 : 		uiValue = (uint)((ch - 'A') + 10);

	movsx	eax, al
	sub	eax, 55					; 00000037H
	mov	DWORD PTR [ecx], eax

; 1469 : 
; 1470 : 	return true;

	mov	al, 1

; 1471 : }

	ret	0
$LN2@GetHexDigi:

; 1467 : 	else
; 1468 : 		return false;

	xor	al, al

; 1471 : }

	ret	0
?GetHexDigitValue@@YA_NDAAI@Z ENDP			; GetHexDigitValue
_TEXT	ENDS
PUBLIC	?ClearGUID@@YAXAAU_GUID@@@Z			; ClearGUID
; Function compile flags: /Ogtpy
;	COMDAT ?ClearGUID@@YAXAAU_GUID@@@Z
_TEXT	SEGMENT
_kGUID$ = 8						; size = 4
?ClearGUID@@YAXAAU_GUID@@@Z PROC			; ClearGUID, COMDAT

; 1538 : 	memset(&kGUID, 0, sizeof(GUID));

	mov	ecx, DWORD PTR _kGUID$[esp-4]
	xor	eax, eax
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax

; 1539 : }

	ret	0
?ClearGUID@@YAXAAU_GUID@@@Z ENDP			; ClearGUID
_TEXT	ENDS
PUBLIC	?IsGUIDEmpty@@YA_NABU_GUID@@@Z			; IsGUIDEmpty
; Function compile flags: /Ogtpy
;	COMDAT ?IsGUIDEmpty@@YA_NABU_GUID@@@Z
_TEXT	SEGMENT
_kGUID$ = 8						; size = 4
?IsGUIDEmpty@@YA_NABU_GUID@@@Z PROC			; IsGUIDEmpty, COMDAT

; 1544 : 	return kGUID.Data1 == 0 && kGUID.Data2 == 0 && kGUID.Data3 == 0 && *(INT32*)&kGUID.Data4[0] == 0 && *(INT32*)&kGUID.Data4[4] == 0;

	mov	eax, DWORD PTR _kGUID$[esp-4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@IsGUIDEmpt
	cmp	WORD PTR [eax+4], 0
	jne	SHORT $LN3@IsGUIDEmpt
	cmp	WORD PTR [eax+6], 0
	jne	SHORT $LN3@IsGUIDEmpt
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@IsGUIDEmpt
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@IsGUIDEmpt
	mov	eax, 1

; 1545 : }

	ret	0
$LN3@IsGUIDEmpt:

; 1544 : 	return kGUID.Data1 == 0 && kGUID.Data2 == 0 && kGUID.Data3 == 0 && *(INT32*)&kGUID.Data4[0] == 0 && *(INT32*)&kGUID.Data4[4] == 0;

	xor	eax, eax

; 1545 : }

	ret	0
?IsGUIDEmpty@@YA_NABU_GUID@@@Z ENDP			; IsGUIDEmpty
_TEXT	ENDS
PUBLIC	??$GetGUIDSegment@K@@YA_NPBDPAIAAK@Z		; GetGUIDSegment<unsigned long>
; Function compile flags: /Ogtpy
;	COMDAT ??$GetGUIDSegment@K@@YA_NPBDPAIAAK@Z
_TEXT	SEGMENT
_pszGUID$ = 8						; size = 4
_puiIndex$ = 12						; size = 4
_kDest$ = 16						; size = 4
??$GetGUIDSegment@K@@YA_NPBDPAIAAK@Z PROC		; GetGUIDSegment<unsigned long>, COMDAT

; 1475 : {

	push	ebp

; 1476 : 	*puiIndex = SkipGUIDSeparators(pszGUID, *puiIndex);

	mov	ebp, DWORD PTR _pszGUID$[esp]
	push	esi
	mov	esi, DWORD PTR _puiIndex$[esp+4]
	mov	ecx, DWORD PTR [esi]
	mov	eax, ebp
	push	edi
	lea	edi, DWORD PTR [eax+1]
$LL31@GetGUIDSeg:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL31@GetGUIDSeg
	sub	eax, edi
	cmp	ecx, eax
	jae	SHORT $LN14@GetGUIDSeg
	npad	1
$LL16@GetGUIDSeg:
	mov	dl, BYTE PTR [ecx+ebp]
	cmp	dl, 123					; 0000007bH
	je	SHORT $LN12@GetGUIDSeg
	cmp	dl, 45					; 0000002dH
	je	SHORT $LN12@GetGUIDSeg
	cmp	dl, 32					; 00000020H
	jne	SHORT $LN14@GetGUIDSeg
$LN12@GetGUIDSeg:
	inc	ecx
	cmp	ecx, eax
	jb	SHORT $LL16@GetGUIDSeg
$LN14@GetGUIDSeg:

; 1477 : 
; 1478 : 	kDest = 0;

	mov	edi, DWORD PTR _kDest$[esp+8]

; 1479 : 	UINT uiLength = strlen(pszGUID);

	mov	eax, ebp
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [edi], 0
	lea	edx, DWORD PTR [eax+1]
$LL32@GetGUIDSeg:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL32@GetGUIDSeg
	sub	eax, edx
	mov	ecx, eax

; 1480 : 	if(*puiIndex < uiLength)

	cmp	DWORD PTR [esi], ecx
	jae	SHORT $LN8@GetGUIDSeg

; 1481 : 	{
; 1482 : 		UINT uiDigitCount = sizeof(T) * 2;

	mov	edx, 8
	push	ebx
	npad	3
$LL7@GetGUIDSeg:

; 1483 : 		do
; 1484 : 		{
; 1485 : 			UINT uiValue = 0;
; 1486 : 			if(GetHexDigitValue(pszGUID[*puiIndex], uiValue))

	mov	eax, DWORD PTR [esi]
	mov	al, BYTE PTR [eax+ebp]
	mov	bl, al
	sub	bl, 48					; 00000030H
	cmp	bl, 9
	ja	SHORT $LN25@GetGUIDSeg
	movsx	eax, al
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN20@GetGUIDSeg
$LN25@GetGUIDSeg:
	mov	bl, al
	sub	bl, 97					; 00000061H
	cmp	bl, 5
	ja	SHORT $LN23@GetGUIDSeg
	movsx	eax, al
	sub	eax, 87					; 00000057H
	jmp	SHORT $LN20@GetGUIDSeg
$LN23@GetGUIDSeg:
	mov	bl, al
	sub	bl, 65					; 00000041H
	cmp	bl, 5
	ja	SHORT $LN4@GetGUIDSeg
	movsx	eax, al
	sub	eax, 55					; 00000037H
$LN20@GetGUIDSeg:

; 1487 : #ifdef AUI_WARNING_FIXES
; 1488 : 				kDest = T((kDest * 16) + uiValue);
; 1489 : #else
; 1490 : 				kDest = (kDest * 16) + uiValue;

	mov	ebx, DWORD PTR [edi]
	shl	ebx, 4
	add	ebx, eax
	mov	DWORD PTR [edi], ebx

; 1494 : 			*puiIndex += 1;

	inc	DWORD PTR [esi]

; 1495 : 		}
; 1496 : 		while(*puiIndex < uiLength  && --uiDigitCount);

	cmp	DWORD PTR [esi], ecx
	jae	SHORT $LN2@GetGUIDSeg
	sub	edx, 1
	jne	SHORT $LL7@GetGUIDSeg
$LN2@GetGUIDSeg:
	pop	ebx
	pop	edi
	pop	esi

; 1497 : 
; 1498 : 		return true;

	mov	al, 1
	pop	ebp

; 1502 : }

	ret	0
$LN4@GetGUIDSeg:
	pop	ebx
	pop	edi
	pop	esi

; 1491 : #endif
; 1492 : 			else
; 1493 : 				return false;

	xor	al, al
	pop	ebp

; 1502 : }

	ret	0
$LN8@GetGUIDSeg:
	pop	edi
	pop	esi

; 1499 : 	}
; 1500 : 	else
; 1501 : 		return false;

	xor	al, al
	pop	ebp

; 1502 : }

	ret	0
??$GetGUIDSegment@K@@YA_NPBDPAIAAK@Z ENDP		; GetGUIDSegment<unsigned long>
_TEXT	ENDS
PUBLIC	??$GetGUIDSegment@G@@YA_NPBDPAIAAG@Z		; GetGUIDSegment<unsigned short>
; Function compile flags: /Ogtpy
;	COMDAT ??$GetGUIDSegment@G@@YA_NPBDPAIAAG@Z
_TEXT	SEGMENT
_pszGUID$ = 8						; size = 4
_puiIndex$ = 12						; size = 4
_kDest$ = 16						; size = 4
??$GetGUIDSegment@G@@YA_NPBDPAIAAG@Z PROC		; GetGUIDSegment<unsigned short>, COMDAT

; 1475 : {

	push	ebp

; 1476 : 	*puiIndex = SkipGUIDSeparators(pszGUID, *puiIndex);

	mov	ebp, DWORD PTR _pszGUID$[esp]
	push	esi
	mov	esi, DWORD PTR _puiIndex$[esp+4]
	mov	ecx, DWORD PTR [esi]
	mov	eax, ebp
	push	edi
	lea	edi, DWORD PTR [eax+1]
$LL31@GetGUIDSeg@2:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL31@GetGUIDSeg@2
	sub	eax, edi
	cmp	ecx, eax
	jae	SHORT $LN14@GetGUIDSeg@2
	npad	1
$LL16@GetGUIDSeg@2:
	mov	dl, BYTE PTR [ecx+ebp]
	cmp	dl, 123					; 0000007bH
	je	SHORT $LN12@GetGUIDSeg@2
	cmp	dl, 45					; 0000002dH
	je	SHORT $LN12@GetGUIDSeg@2
	cmp	dl, 32					; 00000020H
	jne	SHORT $LN14@GetGUIDSeg@2
$LN12@GetGUIDSeg@2:
	inc	ecx
	cmp	ecx, eax
	jb	SHORT $LL16@GetGUIDSeg@2
$LN14@GetGUIDSeg@2:

; 1477 : 
; 1478 : 	kDest = 0;

	mov	edi, DWORD PTR _kDest$[esp+8]
	xor	eax, eax
	mov	DWORD PTR [esi], ecx
	mov	WORD PTR [edi], ax

; 1479 : 	UINT uiLength = strlen(pszGUID);

	mov	eax, ebp
	lea	edx, DWORD PTR [eax+1]
$LL32@GetGUIDSeg@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL32@GetGUIDSeg@2
	sub	eax, edx
	mov	ecx, eax

; 1480 : 	if(*puiIndex < uiLength)

	cmp	DWORD PTR [esi], ecx
	jae	SHORT $LN8@GetGUIDSeg@2

; 1481 : 	{
; 1482 : 		UINT uiDigitCount = sizeof(T) * 2;

	mov	edx, 4
	push	ebx
	npad	4
$LL7@GetGUIDSeg@2:

; 1483 : 		do
; 1484 : 		{
; 1485 : 			UINT uiValue = 0;
; 1486 : 			if(GetHexDigitValue(pszGUID[*puiIndex], uiValue))

	mov	eax, DWORD PTR [esi]
	mov	al, BYTE PTR [eax+ebp]
	mov	bl, al
	sub	bl, 48					; 00000030H
	cmp	bl, 9
	ja	SHORT $LN25@GetGUIDSeg@2
	movsx	eax, al
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN20@GetGUIDSeg@2
$LN25@GetGUIDSeg@2:
	mov	bl, al
	sub	bl, 97					; 00000061H
	cmp	bl, 5
	ja	SHORT $LN23@GetGUIDSeg@2
	movsx	eax, al
	sub	eax, 87					; 00000057H
	jmp	SHORT $LN20@GetGUIDSeg@2
$LN23@GetGUIDSeg@2:
	mov	bl, al
	sub	bl, 65					; 00000041H
	cmp	bl, 5
	ja	SHORT $LN4@GetGUIDSeg@2
	movsx	eax, al
	sub	eax, 55					; 00000037H
$LN20@GetGUIDSeg@2:

; 1487 : #ifdef AUI_WARNING_FIXES
; 1488 : 				kDest = T((kDest * 16) + uiValue);
; 1489 : #else
; 1490 : 				kDest = (kDest * 16) + uiValue;

	mov	bx, WORD PTR [edi]
	shl	bx, 4
	add	bx, ax
	mov	WORD PTR [edi], bx

; 1494 : 			*puiIndex += 1;

	inc	DWORD PTR [esi]

; 1495 : 		}
; 1496 : 		while(*puiIndex < uiLength  && --uiDigitCount);

	cmp	DWORD PTR [esi], ecx
	jae	SHORT $LN2@GetGUIDSeg@2
	sub	edx, 1
	jne	SHORT $LL7@GetGUIDSeg@2
$LN2@GetGUIDSeg@2:
	pop	ebx
	pop	edi
	pop	esi

; 1497 : 
; 1498 : 		return true;

	mov	al, 1
	pop	ebp

; 1502 : }

	ret	0
$LN4@GetGUIDSeg@2:
	pop	ebx
	pop	edi
	pop	esi

; 1491 : #endif
; 1492 : 			else
; 1493 : 				return false;

	xor	al, al
	pop	ebp

; 1502 : }

	ret	0
$LN8@GetGUIDSeg@2:
	pop	edi
	pop	esi

; 1499 : 	}
; 1500 : 	else
; 1501 : 		return false;

	xor	al, al
	pop	ebp

; 1502 : }

	ret	0
??$GetGUIDSegment@G@@YA_NPBDPAIAAG@Z ENDP		; GetGUIDSegment<unsigned short>
_TEXT	ENDS
PUBLIC	??$GetGUIDSegment@E@@YA_NPBDPAIAAE@Z		; GetGUIDSegment<unsigned char>
; Function compile flags: /Ogtpy
;	COMDAT ??$GetGUIDSegment@E@@YA_NPBDPAIAAE@Z
_TEXT	SEGMENT
_pszGUID$ = 8						; size = 4
_puiIndex$ = 12						; size = 4
_kDest$ = 16						; size = 4
??$GetGUIDSegment@E@@YA_NPBDPAIAAE@Z PROC		; GetGUIDSegment<unsigned char>, COMDAT

; 1475 : {

	push	ebp

; 1476 : 	*puiIndex = SkipGUIDSeparators(pszGUID, *puiIndex);

	mov	ebp, DWORD PTR _pszGUID$[esp]
	push	esi
	mov	esi, DWORD PTR _puiIndex$[esp+4]
	mov	ecx, DWORD PTR [esi]
	mov	eax, ebp
	push	edi
	lea	edi, DWORD PTR [eax+1]
$LL31@GetGUIDSeg@3:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL31@GetGUIDSeg@3
	sub	eax, edi
	cmp	ecx, eax
	jae	SHORT $LN14@GetGUIDSeg@3
	npad	1
$LL16@GetGUIDSeg@3:
	mov	dl, BYTE PTR [ecx+ebp]
	cmp	dl, 123					; 0000007bH
	je	SHORT $LN12@GetGUIDSeg@3
	cmp	dl, 45					; 0000002dH
	je	SHORT $LN12@GetGUIDSeg@3
	cmp	dl, 32					; 00000020H
	jne	SHORT $LN14@GetGUIDSeg@3
$LN12@GetGUIDSeg@3:
	inc	ecx
	cmp	ecx, eax
	jb	SHORT $LL16@GetGUIDSeg@3
$LN14@GetGUIDSeg@3:

; 1477 : 
; 1478 : 	kDest = 0;

	mov	edi, DWORD PTR _kDest$[esp+8]

; 1479 : 	UINT uiLength = strlen(pszGUID);

	mov	eax, ebp
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [edi], 0
	lea	edx, DWORD PTR [eax+1]
$LL32@GetGUIDSeg@3:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL32@GetGUIDSeg@3
	sub	eax, edx
	mov	ecx, eax

; 1480 : 	if(*puiIndex < uiLength)

	cmp	DWORD PTR [esi], ecx
	jae	SHORT $LN8@GetGUIDSeg@3

; 1481 : 	{
; 1482 : 		UINT uiDigitCount = sizeof(T) * 2;

	mov	edx, 2
	push	ebx
	npad	6
$LL7@GetGUIDSeg@3:

; 1483 : 		do
; 1484 : 		{
; 1485 : 			UINT uiValue = 0;
; 1486 : 			if(GetHexDigitValue(pszGUID[*puiIndex], uiValue))

	mov	eax, DWORD PTR [esi]
	mov	al, BYTE PTR [eax+ebp]
	mov	bl, al
	sub	bl, 48					; 00000030H
	cmp	bl, 9
	ja	SHORT $LN25@GetGUIDSeg@3
	movsx	eax, al
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN20@GetGUIDSeg@3
$LN25@GetGUIDSeg@3:
	mov	bl, al
	sub	bl, 97					; 00000061H
	cmp	bl, 5
	ja	SHORT $LN23@GetGUIDSeg@3
	movsx	eax, al
	sub	eax, 87					; 00000057H
	jmp	SHORT $LN20@GetGUIDSeg@3
$LN23@GetGUIDSeg@3:
	mov	bl, al
	sub	bl, 65					; 00000041H
	cmp	bl, 5
	ja	SHORT $LN4@GetGUIDSeg@3
	movsx	eax, al
	sub	eax, 55					; 00000037H
$LN20@GetGUIDSeg@3:

; 1487 : #ifdef AUI_WARNING_FIXES
; 1488 : 				kDest = T((kDest * 16) + uiValue);
; 1489 : #else
; 1490 : 				kDest = (kDest * 16) + uiValue;

	mov	bl, BYTE PTR [edi]
	shl	bl, 4
	add	bl, al
	mov	BYTE PTR [edi], bl

; 1494 : 			*puiIndex += 1;

	inc	DWORD PTR [esi]

; 1495 : 		}
; 1496 : 		while(*puiIndex < uiLength  && --uiDigitCount);

	cmp	DWORD PTR [esi], ecx
	jae	SHORT $LN2@GetGUIDSeg@3
	sub	edx, 1
	jne	SHORT $LL7@GetGUIDSeg@3
$LN2@GetGUIDSeg@3:
	pop	ebx
	pop	edi
	pop	esi

; 1497 : 
; 1498 : 		return true;

	mov	al, 1
	pop	ebp

; 1502 : }

	ret	0
$LN4@GetGUIDSeg@3:
	pop	ebx
	pop	edi
	pop	esi

; 1491 : #endif
; 1492 : 			else
; 1493 : 				return false;

	xor	al, al
	pop	ebp

; 1502 : }

	ret	0
$LN8@GetGUIDSeg@3:
	pop	edi
	pop	esi

; 1499 : 	}
; 1500 : 	else
; 1501 : 		return false;

	xor	al, al
	pop	ebp

; 1502 : }

	ret	0
??$GetGUIDSegment@E@@YA_NPBDPAIAAE@Z ENDP		; GetGUIDSegment<unsigned char>
_TEXT	ENDS
PUBLIC	__tcsicmp
EXTRN	__imp___mbsicmp:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\tchar.h
;	COMDAT __tcsicmp
_TEXT	SEGMENT
__String1$ = 8						; size = 4
__String2$ = 12						; size = 4
__tcsicmp PROC						; COMDAT

; 1650 :     return _mbsicmp((const unsigned char *)_String1,(const unsigned char *)_String2);

	jmp	DWORD PTR __imp___mbsicmp
__tcsicmp ENDP
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::CvString, COMDAT
; _this$ = ecx

; 26   : 	CvString(const std::string& s): std::string(s) {}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?format@CvString@@SA?AV1@PBDZZ			; CvString::format
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?format@CvString@@SA?AV1@PBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$0
__ehfuncinfo$?format@CvString@@SA?AV1@PBDZZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?format@CvString@@SA?AV1@PBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?format@CvString@@SA?AV1@PBDZZ
_TEXT	SEGMENT
$T219746 = -44						; size = 4
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_fmt$ = 12						; size = 4
?format@CvString@@SA?AV1@PBDZZ PROC			; CvString::format, COMDAT

; 243  : {

	push	-1
	push	__ehhandler$?format@CvString@@SA?AV1@PBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	esi

; 244  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+48]
	mov	DWORD PTR $T219746[esp+48], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 245  : 	va_list args;
; 246  : 	va_start(args,fmt);
; 247  : 	formatv(result,fmt,args);

	mov	ecx, DWORD PTR _fmt$[esp+44]
	lea	eax, DWORD PTR _fmt$[esp+48]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+56]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+68], 1
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv

; 248  : 	va_end(args);
; 249  : 	return CvString(result);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+56]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _result$[esp+48]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	ecx, DWORD PTR _result$[esp+48]
	mov	DWORD PTR $T219746[esp+48], 1
	mov	BYTE PTR __$EHRec$[esp+56], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 250  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$1:
	mov	eax, DWORD PTR $T219746[ebp]
	and	eax, 1
	je	$LN5@format
	and	DWORD PTR $T219746[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@format:
	ret	0
__ehhandler$?format@CvString@@SA?AV1@PBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?format@CvString@@SA?AV1@PBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?format@CvString@@SA?AV1@PBDZZ ENDP			; CvString::format
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getCityPlotX@CvGlobals@@QAEPAHXZ		; CvGlobals::getCityPlotX
; Function compile flags: /Ogtpy
;	COMDAT ?getCityPlotX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getCityPlotX@CvGlobals@@QAEPAHXZ PROC			; CvGlobals::getCityPlotX, COMDAT
; _this$ = ecx

; 253  : 		return m_aiCityPlotX;

	lea	eax, DWORD PTR [ecx+160]

; 254  : 	}

	ret	0
?getCityPlotX@CvGlobals@@QAEPAHXZ ENDP			; CvGlobals::getCityPlotX
_TEXT	ENDS
PUBLIC	?getCityPlotY@CvGlobals@@QAEPAHXZ		; CvGlobals::getCityPlotY
; Function compile flags: /Ogtpy
;	COMDAT ?getCityPlotY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getCityPlotY@CvGlobals@@QAEPAHXZ PROC			; CvGlobals::getCityPlotY, COMDAT
; _this$ = ecx

; 257  : 		return m_aiCityPlotY;

	lea	eax, DWORD PTR [ecx+308]

; 258  : 	}

	ret	0
?getCityPlotY@CvGlobals@@QAEPAHXZ ENDP			; CvGlobals::getCityPlotY
_TEXT	ENDS
PUBLIC	?getNumFlavorTypes@CvGlobals@@QAEHXZ		; CvGlobals::getNumFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFlavorTypes@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFlavorTypes@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFlavorTypes, COMDAT
; _this$ = ecx

; 804  : 		return m_iNumFlavorTypes;

	mov	eax, DWORD PTR [ecx+1764]

; 805  : 	}

	ret	0
?getNumFlavorTypes@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFlavorTypes
_TEXT	ENDS
PUBLIC	?getWEEKS_PER_MONTHS@CvGlobals@@QAEHXZ		; CvGlobals::getWEEKS_PER_MONTHS
; Function compile flags: /Ogtpy
;	COMDAT ?getWEEKS_PER_MONTHS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getWEEKS_PER_MONTHS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getWEEKS_PER_MONTHS, COMDAT
; _this$ = ecx

; 5260 : 		return m_iWEEKS_PER_MONTHS;

	mov	eax, DWORD PTR [ecx+6184]

; 5261 : 	}

	ret	0
?getWEEKS_PER_MONTHS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getWEEKS_PER_MONTHS
_TEXT	ENDS
PUBLIC	?getMAX_YIELD_STACK@CvGlobals@@QAEHXZ		; CvGlobals::getMAX_YIELD_STACK
; Function compile flags: /Ogtpy
;	COMDAT ?getMAX_YIELD_STACK@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAX_YIELD_STACK@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMAX_YIELD_STACK, COMDAT
; _this$ = ecx

; 5308 : 		return m_iMAX_YIELD_STACK;

	mov	eax, DWORD PTR [ecx+6232]

; 5309 : 	}

	ret	0
?getMAX_YIELD_STACK@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMAX_YIELD_STACK
_TEXT	ENDS
PUBLIC	?getNUM_UNIT_AND_TECH_PREREQS@CvGlobals@@QAEHXZ	; CvGlobals::getNUM_UNIT_AND_TECH_PREREQS
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_UNIT_AND_TECH_PREREQS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUM_UNIT_AND_TECH_PREREQS@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNUM_UNIT_AND_TECH_PREREQS, COMDAT
; _this$ = ecx

; 5352 : 		return m_iNUM_UNIT_AND_TECH_PREREQS;

	mov	eax, DWORD PTR [ecx+6276]

; 5353 : 	}

	ret	0
?getNUM_UNIT_AND_TECH_PREREQS@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNUM_UNIT_AND_TECH_PREREQS
_TEXT	ENDS
PUBLIC	?getNUM_BUILDING_AND_TECH_PREREQS@CvGlobals@@QAEHXZ ; CvGlobals::getNUM_BUILDING_AND_TECH_PREREQS
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_BUILDING_AND_TECH_PREREQS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUM_BUILDING_AND_TECH_PREREQS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getNUM_BUILDING_AND_TECH_PREREQS, COMDAT
; _this$ = ecx

; 5356 : 		return m_iNUM_BUILDING_AND_TECH_PREREQS;

	mov	eax, DWORD PTR [ecx+6280]

; 5357 : 	}

	ret	0
?getNUM_BUILDING_AND_TECH_PREREQS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getNUM_BUILDING_AND_TECH_PREREQS
_TEXT	ENDS
PUBLIC	?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ; CvGlobals::GetGameDatabase
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ
_TEXT	SEGMENT
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ PROC ; CvGlobals::GetGameDatabase, COMDAT
; _this$ = ecx

; 9792 : 	return m_pGameDatabase;

	mov	eax, DWORD PTR [ecx+912]

; 9793 : }

	ret	0
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ENDP ; CvGlobals::GetGameDatabase
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?atWar@@YA_NW4TeamTypes@@0@Z			; atWar
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
;	COMDAT ?atWar@@YA_NW4TeamTypes@@0@Z
_TEXT	SEGMENT
_eTeamA$ = 8						; size = 4
_eTeamB$ = 12						; size = 4
?atWar@@YA_NW4TeamTypes@@0@Z PROC			; atWar, COMDAT

; 152  : 	if((eTeamA == NO_TEAM) || (eTeamB == NO_TEAM))

	mov	eax, DWORD PTR _eTeamA$[esp-4]
	cmp	eax, -1
	je	SHORT $LN1@atWar
	mov	ecx, DWORD PTR _eTeamB$[esp-4]
	cmp	ecx, -1
	je	SHORT $LN1@atWar

; 155  : 	}
; 156  : 
; 157  : 	CvAssert(GET_TEAM(eTeamA).isAtWar(eTeamB) == GET_TEAM(eTeamB).isAtWar(eTeamA));
; 158  : 	CvAssert((eTeamA != eTeamB) || !(GET_TEAM(eTeamA).isAtWar(eTeamB)));
; 159  : 
; 160  : 	return GET_TEAM(eTeamA).isAtWar(eTeamB);

	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar

; 161  : }

	ret	0
$LN1@atWar:

; 153  : 	{
; 154  : 		return false;

	xor	al, al

; 161  : }

	ret	0
?atWar@@YA_NW4TeamTypes@@0@Z ENDP			; atWar
_TEXT	ENDS
PUBLIC	?getCity@@YAPAVCvCity@@UIDInfo@@@Z		; getCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
;	COMDAT ?getCity@@YAPAVCvCity@@UIDInfo@@@Z
_TEXT	SEGMENT
_city$ = 8						; size = 8
?getCity@@YAPAVCvCity@@UIDInfo@@@Z PROC			; getCity, COMDAT

; 170  : 	if((city.eOwner >= 0) && city.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _city$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@getCity

; 171  : 	{
; 172  : 		return (GET_PLAYER((PlayerTypes)city.eOwner).getCity(city.iID));

	mov	ecx, DWORD PTR _city$[esp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 176  : }

	ret	0
$LN1@getCity:

; 173  : 	}
; 174  : 
; 175  : 	return NULL;

	xor	eax, eax

; 176  : }

	ret	0
?getCity@@YAPAVCvCity@@UIDInfo@@@Z ENDP			; getCity
_TEXT	ENDS
PUBLIC	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z		; getUnit
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
; Function compile flags: /Ogtpy
;	COMDAT ?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z
_TEXT	SEGMENT
_unit$ = 8						; size = 4
?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z PROC		; getUnit, COMDAT

; 180  : 	if((unit.eOwner >= 0) && unit.eOwner < MAX_PLAYERS)

	mov	ecx, DWORD PTR _unit$[esp-4]
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jl	SHORT $LN1@getUnit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getUnit

; 181  : 	{
; 182  : 		return (GET_PLAYER((PlayerTypes)unit.eOwner).getUnit(unit.iID));

	mov	ecx, DWORD PTR [ecx+4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 186  : }

	ret	0
$LN1@getUnit:

; 183  : 	}
; 184  : 
; 185  : 	return NULL;

	xor	eax, eax

; 186  : }

	ret	0
?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z ENDP		; getUnit
_TEXT	ENDS
PUBLIC	?isTechRequiredForUnit@@YA_NW4TechTypes@@W4UnitTypes@@@Z ; isTechRequiredForUnit
EXTRN	?GetPrereqAndTechs@CvUnitEntry@@QBEHH@Z:PROC	; CvUnitEntry::GetPrereqAndTechs
EXTRN	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetPrereqAndTech
; Function compile flags: /Ogtpy
;	COMDAT ?isTechRequiredForUnit@@YA_NW4TechTypes@@W4UnitTypes@@@Z
_TEXT	SEGMENT
_eTech$ = 8						; size = 4
_eUnit$ = 12						; size = 4
?isTechRequiredForUnit@@YA_NW4TechTypes@@W4UnitTypes@@@Z PROC ; isTechRequiredForUnit, COMDAT

; 513  : 	CvUnitEntry* info = GC.getUnitInfo(eUnit);

	mov	eax, DWORD PTR _eUnit$[esp-4]
	push	edi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	edi, eax

; 514  : 	if(info == NULL)

	test	edi, edi
	jne	SHORT $LN6@isTechRequ@2

; 515  : 	{
; 516  : 		return false;

	xor	al, al
	pop	edi

; 533  : }

	ret	0
$LN6@isTechRequ@2:
	push	ebx

; 517  : 	}
; 518  : 
; 519  : 	if(info->GetPrereqAndTech() == eTech)

	mov	ecx, edi
	call	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetPrereqAndTech
	mov	ebx, DWORD PTR _eTech$[esp+4]
	cmp	eax, ebx
	jne	SHORT $LN5@isTechRequ@2
	pop	ebx

; 520  : 	{
; 521  : 		return true;

	mov	al, 1
	pop	edi

; 533  : }

	ret	0
$LN5@isTechRequ@2:
	push	esi

; 522  : 	}
; 523  : 
; 524  : 	for(int iI = 0; iI < GC.getNUM_UNIT_AND_TECH_PREREQS(); iI++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6276, esi
	jle	SHORT $LN2@isTechRequ@2
	npad	6
$LL4@isTechRequ@2:

; 525  : 	{
; 526  : 		if(info->GetPrereqAndTechs(iI) == eTech)

	push	esi
	mov	ecx, edi
	call	?GetPrereqAndTechs@CvUnitEntry@@QBEHH@Z	; CvUnitEntry::GetPrereqAndTechs
	cmp	eax, ebx
	je	SHORT $LN12@isTechRequ@2
	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6276
	jl	SHORT $LL4@isTechRequ@2
$LN2@isTechRequ@2:
	pop	esi
	pop	ebx

; 529  : 		}
; 530  : 	}
; 531  : 
; 532  : 	return false;

	xor	al, al
	pop	edi

; 533  : }

	ret	0
$LN12@isTechRequ@2:
	pop	esi
	pop	ebx

; 527  : 		{
; 528  : 			return true;

	mov	al, 1
	pop	edi

; 533  : }

	ret	0
?isTechRequiredForUnit@@YA_NW4TechTypes@@W4UnitTypes@@@Z ENDP ; isTechRequiredForUnit
_TEXT	ENDS
PUBLIC	?isTechRequiredForBuilding@@YA_NW4TechTypes@@W4BuildingTypes@@@Z ; isTechRequiredForBuilding
EXTRN	?GetPrereqAndTechs@CvBuildingEntry@@QBEHH@Z:PROC ; CvBuildingEntry::GetPrereqAndTechs
EXTRN	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetPrereqAndTech
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
; Function compile flags: /Ogtpy
;	COMDAT ?isTechRequiredForBuilding@@YA_NW4TechTypes@@W4BuildingTypes@@@Z
_TEXT	SEGMENT
_eTech$ = 8						; size = 4
_eBuilding$ = 12					; size = 4
?isTechRequiredForBuilding@@YA_NW4TechTypes@@W4BuildingTypes@@@Z PROC ; isTechRequiredForBuilding, COMDAT

; 537  : 	CvBuildingEntry* info = GC.getBuildingInfo(eBuilding);

	mov	eax, DWORD PTR _eBuilding$[esp-4]
	push	ebx
	push	esi
	push	edi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 538  : 	if(info)

	test	edi, edi
	je	SHORT $LN2@isTechRequ@3

; 539  : 	{
; 540  : 		if(info->GetPrereqAndTech() == eTech)

	mov	ecx, edi
	call	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPrereqAndTech
	mov	ebx, DWORD PTR _eTech$[esp+8]
	cmp	eax, ebx
	jne	SHORT $LN5@isTechRequ@3
$LN12@isTechRequ@3:
	pop	edi
	pop	esi

; 541  : 		{
; 542  : 			return true;

	mov	al, 1
	pop	ebx

; 555  : }

	ret	0
$LN5@isTechRequ@3:

; 543  : 		}
; 544  : 
; 545  : 		for(int iI = 0; iI < GC.getNUM_BUILDING_AND_TECH_PREREQS(); iI++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6280, esi
	jle	SHORT $LN2@isTechRequ@3
$LL4@isTechRequ@3:

; 546  : 		{
; 547  : 			if(info->GetPrereqAndTechs(iI) == eTech)

	push	esi
	mov	ecx, edi
	call	?GetPrereqAndTechs@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetPrereqAndTechs
	cmp	eax, ebx
	je	SHORT $LN12@isTechRequ@3
	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6280
	jl	SHORT $LL4@isTechRequ@3
$LN2@isTechRequ@3:
	pop	edi
	pop	esi

; 548  : 			{
; 549  : 				return true;
; 550  : 			}
; 551  : 		}
; 552  : 	}
; 553  : 
; 554  : 	return false;

	xor	al, al
	pop	ebx

; 555  : }

	ret	0
?isTechRequiredForBuilding@@YA_NW4TechTypes@@W4BuildingTypes@@@Z ENDP ; isTechRequiredForBuilding
_TEXT	ENDS
PUBLIC	?getDiscoveryTech@@YA?AW4TechTypes@@W4UnitTypes@@W4PlayerTypes@@@Z ; getDiscoveryTech
EXTRN	?GetFlavorValue@CvUnitEntry@@QBEHH@Z:PROC	; CvUnitEntry::GetFlavorValue
EXTRN	?GetFlavorValue@CvTechEntry@@QBEHH@Z:PROC	; CvTechEntry::GetFlavorValue
EXTRN	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z:PROC ; CvPlayerTechs::CanResearch
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getDiscoveryTech@@YA?AW4TechTypes@@W4UnitTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_kPlayer$ = -16						; size = 4
_iI$218419 = -12					; size = 4
_eBestTech$ = -8					; size = 4
_pkUnitInfo$ = -4					; size = 4
_eUnit$ = 8						; size = 4
_iBestValue$218418 = 12					; size = 4
_ePlayer$ = 12						; size = 4
?getDiscoveryTech@@YA?AW4TechTypes@@W4UnitTypes@@W4PlayerTypes@@@Z PROC ; getDiscoveryTech, COMDAT

; 656  : {

	sub	esp, 16					; 00000010H

; 657  : 	TechTypes eBestTech = NO_TECH;
; 658  : 	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
; 659  : 
; 660  : 	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);

	mov	eax, DWORD PTR _eUnit$[esp+12]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _ePlayer$[esp+20]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	or	edi, -1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eBestTech$[esp+32], edi
	mov	DWORD PTR _kPlayer$[esp+32], esi
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 661  : 	if(pkUnitInfo)

	xor	ebp, ebp
	mov	DWORD PTR _pkUnitInfo$[esp+28], eax
	cmp	eax, ebp
	je	$LN22@getDiscove

; 662  : 	{
; 663  : 		int iBestValue = 0;
; 664  : #ifdef AUI_WARNING_FIXES
; 665  : 		for (uint iI = 0; iI < GC.getNumTechInfos(); iI++)
; 666  : #else
; 667  : 		for(int iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBestValue$218418[esp+24], ebp
	mov	DWORD PTR _iI$218419[esp+28], ebp
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	$LN22@getDiscove
	push	ebx
	npad	7
$LL27@getDiscove:

; 668  : #endif
; 669  : 		{
; 670  : 			const TechTypes eTech = static_cast<TechTypes>(iI);
; 671  : 			CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	ebx, eax

; 672  : 			if(pkTechInfo)

	test	ebx, ebx
	je	SHORT $LN8@getDiscove

; 673  : 			{
; 674  : 				if(kPlayer.GetPlayerTechs()->CanResearch(eTech))

	push	0
	push	ebp
	mov	ecx, esi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	test	al, al
	je	SHORT $LN8@getDiscove

; 675  : 				{
; 676  : 					int iValue = 0;
; 677  : 
; 678  : 					for(int iJ = 0; iJ < GC.getNumFlavorTypes(); iJ++)

	xor	esi, esi
	xor	edi, edi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	jle	SHORT $LN24@getDiscove
$LL23@getDiscove:

; 679  : 					{
; 680  : 						iValue += (pkTechInfo->GetFlavorValue(iJ) * pkUnitInfo->GetFlavorValue(iJ));

	push	esi
	mov	ecx, ebx
	call	?GetFlavorValue@CvTechEntry@@QBEHH@Z	; CvTechEntry::GetFlavorValue
	mov	ecx, DWORD PTR _pkUnitInfo$[esp+32]
	push	esi
	mov	ebp, eax
	call	?GetFlavorValue@CvUnitEntry@@QBEHH@Z	; CvUnitEntry::GetFlavorValue
	imul	ebp, eax
	inc	esi
	add	edi, ebp
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL23@getDiscove

; 675  : 				{
; 676  : 					int iValue = 0;
; 677  : 
; 678  : 					for(int iJ = 0; iJ < GC.getNumFlavorTypes(); iJ++)

	mov	ebp, DWORD PTR _iI$218419[esp+32]
$LN24@getDiscove:

; 681  : 					}
; 682  : 
; 683  : 					if(iValue > iBestValue)

	cmp	edi, DWORD PTR _iBestValue$218418[esp+28]

; 684  : 					{
; 685  : 						iBestValue = iValue;
; 686  : 						eBestTech = eTech;

	mov	esi, DWORD PTR _kPlayer$[esp+32]
	jle	SHORT $LN8@getDiscove
	mov	DWORD PTR _iBestValue$218418[esp+28], edi
	mov	DWORD PTR _eBestTech$[esp+32], ebp
$LN8@getDiscove:
	inc	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$218419[esp+32], ebp
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	ebp, eax
	jl	SHORT $LL27@getDiscove

; 687  : 					}
; 688  : 				}
; 689  : 			}
; 690  : 		}
; 691  : 	}
; 692  : 
; 693  : 	return eBestTech;

	mov	eax, DWORD PTR _eBestTech$[esp+32]
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 694  : }

	add	esp, 16					; 00000010H
	ret	0
$LN22@getDiscove:

; 687  : 					}
; 688  : 				}
; 689  : 			}
; 690  : 		}
; 691  : 	}
; 692  : 
; 693  : 	return eBestTech;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp

; 694  : }

	add	esp, 16					; 00000010H
	ret	0
?getDiscoveryTech@@YA?AW4TechTypes@@W4UnitTypes@@W4PlayerTypes@@@Z ENDP ; getDiscoveryTech
_TEXT	ENDS
PUBLIC	?baseYieldToSymbol@@YAHHH@Z			; baseYieldToSymbol
; Function compile flags: /Ogtpy
;	COMDAT ?baseYieldToSymbol@@YAHHH@Z
_TEXT	SEGMENT
_iNumYieldTypes$ = 8					; size = 4
_iYieldStack$ = 12					; size = 4
?baseYieldToSymbol@@YAHHH@Z PROC			; baseYieldToSymbol, COMDAT

; 870  : 	int iReturn;	// holds the return value we will be calculating
; 871  : 
; 872  : 	// get the base value for the iReturn value
; 873  : 	iReturn = iNumYieldTypes * GC.getMAX_YIELD_STACK();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6232
	imul	eax, DWORD PTR _iNumYieldTypes$[esp-4]

; 874  : 	// then add the offset to the return value
; 875  : 	iReturn += iYieldStack;

	add	eax, DWORD PTR _iYieldStack$[esp-4]

; 876  : 
; 877  : 	// return the value we have calculated
; 878  : 	return iReturn;
; 879  : }

	ret	0
?baseYieldToSymbol@@YAHHH@Z ENDP			; baseYieldToSymbol
_TEXT	ENDS
PUBLIC	?isPickableName@@YA_NPBD@Z			; isPickableName
; Function compile flags: /Ogtpy
;	COMDAT ?isPickableName@@YA_NPBD@Z
_TEXT	SEGMENT
_szName$ = 8						; size = 4
?isPickableName@@YA_NPBD@Z PROC				; isPickableName, COMDAT

; 884  : 	if(szName)

	mov	edx, DWORD PTR _szName$[esp-4]
	test	edx, edx
	je	SHORT $LN1@isPickable

; 885  : 	{
; 886  : 		int iLen = _tcslen(szName);

	mov	eax, edx
	push	esi
	lea	esi, DWORD PTR [eax+1]
	npad	2
$LL7@isPickable:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL7@isPickable
	sub	eax, esi

; 887  : 
; 888  : 		if(!_tcsicmp(&szName[iLen-6], "NOPICK"))

	lea	eax, DWORD PTR [eax+edx-6]
	push	OFFSET $SG218580
	push	eax
	call	DWORD PTR __imp___mbsicmp
	add	esp, 8
	pop	esi
	test	eax, eax
	jne	SHORT $LN1@isPickable

; 889  : 		{
; 890  : 			return false;

	xor	al, al

; 895  : }

	ret	0
$LN1@isPickable:

; 891  : 		}
; 892  : 	}
; 893  : 
; 894  : 	return true;

	mov	al, 1

; 895  : }

	ret	0
?isPickableName@@YA_NPBD@Z ENDP				; isPickableName
_TEXT	ENDS
PUBLIC	?getTurnMonthForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z ; getTurnMonthForGame
EXTRN	?getGameTurnInfo@CvGameSpeedInfo@@QBEAAUGameTurnInfo@@H@Z:PROC ; CvGameSpeedInfo::getGameTurnInfo
EXTRN	?getNumTurnIncrements@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getNumTurnIncrements
EXTRN	__imp_?Count@Connection@Database@@QAEHPBD_N@Z:PROC
EXTRN	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z:PROC ; CvGlobals::getGameSpeedInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getTurnMonthForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z
_TEXT	SEGMENT
_iGameSpeedNumTurnIncrements$218621 = -8		; size = 4
_pkGameSpeedInfo$ = -4					; size = 4
_iGameTurn$ = 8						; size = 4
_iStartYear$ = 12					; size = 4
_eCalendar$ = 16					; size = 4
_eSpeed$ = 20						; size = 4
?getTurnMonthForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z PROC ; getTurnMonthForGame, COMDAT

; 926  : {

	sub	esp, 8

; 927  : 	int iTurnMonth;
; 928  : 	int iTurnCount;
; 929  : 	int iI;
; 930  : 
; 931  : 	CvGameSpeedInfo* pkGameSpeedInfo = GC.getGameSpeedInfo(eSpeed);

	mov	eax, DWORD PTR _eSpeed$[esp+4]
	push	edi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z ; CvGlobals::getGameSpeedInfo
	mov	edi, eax
	mov	DWORD PTR _pkGameSpeedInfo$[esp+12], edi

; 932  : 	if(pkGameSpeedInfo == NULL)

	test	edi, edi
	jne	SHORT $LN16@getTurnMon
	pop	edi

; 1000 : }

	add	esp, 8
	ret	0
$LN16@getTurnMon:

; 933  : 	{
; 934  : 		//This function requires a valid game speed type!
; 935  : 		CvAssert(pkGameSpeedInfo);
; 936  : 		return 0;
; 937  : 	}
; 938  : 
; 939  : 	const int iNumMonths = DB.Count("Months");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __imp_?Count@Connection@Database@@QAEHPBD_N@Z
	push	esi
	push	1
	push	OFFSET $SG218615
	call	ebp
	mov	esi, eax

; 940  : 
; 941  : 	iTurnMonth = iStartYear * iNumMonths;
; 942  : 
; 943  : 	switch(eCalendar)

	mov	eax, DWORD PTR _eCalendar$[esp+20]
	mov	ebx, esi
	imul	ebx, DWORD PTR _iStartYear$[esp+20]
	cmp	eax, 6
	ja	$LN1@getTurnMon
	jmp	DWORD PTR $LN28@getTurnMon[eax*4]
$LN13@getTurnMon:

; 944  : 	{
; 945  : 	case CALENDAR_DEFAULT:
; 946  : 		{
; 947  : 			iTurnCount = 0;
; 948  : 			const int iGameSpeedNumTurnIncrements = pkGameSpeedInfo->getNumTurnIncrements();

	mov	ecx, edi
	xor	ebp, ebp
	call	?getNumTurnIncrements@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getNumTurnIncrements

; 949  : 
; 950  : 			for(iI = 0; iI < iGameSpeedNumTurnIncrements; iI++)

	mov	esi, DWORD PTR _iGameTurn$[esp+20]
	xor	edi, edi
	mov	DWORD PTR _iGameSpeedNumTurnIncrements$218621[esp+24], eax
	test	eax, eax
	jle	SHORT $LN10@getTurnMon
	npad	2
$LL12@getTurnMon:

; 951  : 			{
; 952  : 				const GameTurnInfo& gameTurnInfo = pkGameSpeedInfo->getGameTurnInfo(iI);

	mov	ecx, DWORD PTR _pkGameSpeedInfo$[esp+24]
	push	edi
	call	?getGameTurnInfo@CvGameSpeedInfo@@QBEAAUGameTurnInfo@@H@Z ; CvGameSpeedInfo::getGameTurnInfo

; 953  : 
; 954  : 				if(iGameTurn > (iTurnCount + gameTurnInfo.iNumGameTurnsPerIncrement))

	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebp
	cmp	esi, ecx
	jle	SHORT $LN9@getTurnMon

; 955  : 				{
; 956  : 					iTurnMonth += (gameTurnInfo.iMonthIncrement * gameTurnInfo.iNumGameTurnsPerIncrement);

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	imul	edx, ecx
	inc	edi
	add	ebx, edx

; 957  : 					iTurnCount += gameTurnInfo.iNumGameTurnsPerIncrement;

	add	ebp, ecx
	cmp	edi, DWORD PTR _iGameSpeedNumTurnIncrements$218621[esp+24]
	jl	SHORT $LL12@getTurnMon

; 949  : 
; 950  : 			for(iI = 0; iI < iGameSpeedNumTurnIncrements; iI++)

	mov	eax, DWORD PTR _iGameSpeedNumTurnIncrements$218621[esp+24]
$LN10@getTurnMon:

; 958  : 				}
; 959  : 				else
; 960  : 				{
; 961  : 					iTurnMonth += (gameTurnInfo.iMonthIncrement * (iGameTurn - iTurnCount));
; 962  : 					iTurnCount += (iGameTurn - iTurnCount);
; 963  : 					break;
; 964  : 				}
; 965  : 			}
; 966  : 
; 967  : 			if(iGameTurn > iTurnCount)

	cmp	esi, ebp
	jle	$LN1@getTurnMon

; 968  : 			{
; 969  : 				iTurnMonth += (pkGameSpeedInfo->getGameTurnInfo(iGameSpeedNumTurnIncrements - 1).iMonthIncrement * (iGameTurn - iTurnCount));

	mov	ecx, DWORD PTR _pkGameSpeedInfo$[esp+24]
	dec	eax
	push	eax
	call	?getGameTurnInfo@CvGameSpeedInfo@@QBEAAUGameTurnInfo@@H@Z ; CvGameSpeedInfo::getGameTurnInfo
$LN9@getTurnMon:
	sub	esi, ebp
	imul	esi, DWORD PTR [eax]
	add	ebx, esi
	pop	esi
	pop	ebp

; 993  : 		break;
; 994  : 
; 995  : 	default:
; 996  : 		CvAssert(false);
; 997  : 	}
; 998  : 
; 999  : 	return iTurnMonth;

	mov	eax, ebx
	pop	ebx
	pop	edi

; 1000 : }

	add	esp, 8
	ret	0
$LN6@getTurnMon:

; 970  : 			}
; 971  : 		}
; 972  : 		break;
; 973  : 
; 974  : 	case CALENDAR_BI_YEARLY:
; 975  : 		iTurnMonth += (2 * iGameTurn * iNumMonths);

	imul	esi, DWORD PTR _iGameTurn$[esp+20]
	lea	ebx, DWORD PTR [ebx+esi*2]
	pop	esi
	pop	ebp

; 993  : 		break;
; 994  : 
; 995  : 	default:
; 996  : 		CvAssert(false);
; 997  : 	}
; 998  : 
; 999  : 	return iTurnMonth;

	mov	eax, ebx
	pop	ebx
	pop	edi

; 1000 : }

	add	esp, 8
	ret	0
$LN5@getTurnMon:

; 976  : 		break;
; 977  : 
; 978  : 	case CALENDAR_YEARS:
; 979  : 	case CALENDAR_TURNS:
; 980  : 		iTurnMonth += iGameTurn * iNumMonths;

	imul	esi, DWORD PTR _iGameTurn$[esp+20]
	add	ebx, esi
	pop	esi
	pop	ebp

; 993  : 		break;
; 994  : 
; 995  : 	default:
; 996  : 		CvAssert(false);
; 997  : 	}
; 998  : 
; 999  : 	return iTurnMonth;

	mov	eax, ebx
	pop	ebx
	pop	edi

; 1000 : }

	add	esp, 8
	ret	0
$LN4@getTurnMon:

; 981  : 		break;
; 982  : 
; 983  : 	case CALENDAR_SEASONS:
; 984  : 		iTurnMonth += (iGameTurn * iNumMonths) / DB.Count("Seasons");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	push	1
	push	OFFSET $SG218632
	call	ebp
	mov	ecx, eax
	mov	eax, esi
	imul	eax, DWORD PTR _iGameTurn$[esp+20]
	cdq
	idiv	ecx
	pop	esi
	pop	ebp

; 989  : 		break;
; 990  : 
; 991  : 	case CALENDAR_WEEKS:
; 992  : 		iTurnMonth += iGameTurn / GC.getWEEKS_PER_MONTHS();

	add	ebx, eax

; 993  : 		break;
; 994  : 
; 995  : 	default:
; 996  : 		CvAssert(false);
; 997  : 	}
; 998  : 
; 999  : 	return iTurnMonth;

	mov	eax, ebx
	pop	ebx
	pop	edi

; 1000 : }

	add	esp, 8
	ret	0
$LN3@getTurnMon:

; 985  : 		break;
; 986  : 
; 987  : 	case CALENDAR_MONTHS:
; 988  : 		iTurnMonth += iGameTurn;

	add	ebx, DWORD PTR _iGameTurn$[esp+20]
	pop	esi
	pop	ebp

; 993  : 		break;
; 994  : 
; 995  : 	default:
; 996  : 		CvAssert(false);
; 997  : 	}
; 998  : 
; 999  : 	return iTurnMonth;

	mov	eax, ebx
	pop	ebx
	pop	edi

; 1000 : }

	add	esp, 8
	ret	0
$LN2@getTurnMon:

; 989  : 		break;
; 990  : 
; 991  : 	case CALENDAR_WEEKS:
; 992  : 		iTurnMonth += iGameTurn / GC.getWEEKS_PER_MONTHS();

	mov	eax, DWORD PTR _iGameTurn$[esp+20]
	cdq
	idiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6184
	add	ebx, eax
$LN1@getTurnMon:
	pop	esi
	pop	ebp

; 993  : 		break;
; 994  : 
; 995  : 	default:
; 996  : 		CvAssert(false);
; 997  : 	}
; 998  : 
; 999  : 	return iTurnMonth;

	mov	eax, ebx
	pop	ebx
	pop	edi

; 1000 : }

	add	esp, 8
	ret	0
	npad	3
$LN28@getTurnMon:
	DD	$LN13@getTurnMon
	DD	$LN6@getTurnMon
	DD	$LN5@getTurnMon
	DD	$LN5@getTurnMon
	DD	$LN4@getTurnMon
	DD	$LN3@getTurnMon
	DD	$LN2@getTurnMon
?getTurnMonthForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z ENDP ; getTurnMonthForGame
_TEXT	ENDS
PUBLIC	?boolsToString@@YAXPB_NHPAVCvString@@@Z		; boolsToString
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?boolsToString@@YAXPB_NHPAVCvString@@@Z
_TEXT	SEGMENT
_pBools$ = 8						; size = 4
_iNumBools$ = 12					; size = 4
_szOut$ = 16						; size = 4
?boolsToString@@YAXPB_NHPAVCvString@@@Z PROC		; boolsToString, COMDAT

; 1004 : {

	push	ebx
	push	esi
	push	edi

; 1005 : 	*szOut = "";

	mov	edi, DWORD PTR _szOut$[esp+8]
	push	OFFSET $SG218641
	mov	ecx, edi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 1006 : 	int i;
; 1007 : 	for(i=0; i<iNumBools; i++)

	mov	ebx, DWORD PTR _iNumBools$[esp+8]
	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN1@boolsToStr
	push	ebp
	mov	ebp, DWORD PTR _pBools$[esp+12]
$LL3@boolsToStr:

; 1008 : 	{
; 1009 : 		*szOut += pBools[i] ? "1" : "0";

	cmp	BYTE PTR [esi+ebp], 0
	mov	eax, OFFSET $SG218646
	jne	SHORT $LN7@boolsToStr
	mov	eax, OFFSET $SG218647
$LN7@boolsToStr:
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL3@boolsToStr
	pop	ebp
$LN1@boolsToStr:
	pop	edi
	pop	esi
	pop	ebx

; 1010 : 	}
; 1011 : }

	ret	0
?boolsToString@@YAXPB_NHPAVCvString@@@Z ENDP		; boolsToString
_TEXT	ENDS
PUBLIC	?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z ; getDirectionTypeString
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z$0
__ehfuncinfo$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
xdata$x	ENDS
;	COMDAT ?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z
_TEXT	SEGMENT
$T220001 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strString$ = 8						; size = 4
_eDirectionType$ = 12					; size = 4
?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z PROC ; getDirectionTypeString, COMDAT

; 1034 : {

	mov	eax, DWORD PTR fs:0

; 1035 : 	switch(eDirectionType)

	mov	ecx, DWORD PTR _eDirectionType$[esp-4]
	push	-1
	push	__ehhandler$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	lea	eax, DWORD PTR [ecx+1]
	sub	esp, 28					; 0000001cH
	cmp	eax, 6
	ja	$LN1@getDirecti
	jmp	DWORD PTR $LN20@getDirecti[eax*4]
$LN8@getDirecti:

; 1036 : 	{
; 1037 : 	case NO_DIRECTION:
; 1038 : 		strString = "NO_DIRECTION";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218669
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1064 : 		break;
; 1065 : 	}
; 1066 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN7@getDirecti:

; 1039 : 		break;
; 1040 : 
; 1041 : 		//case DIRECTION_NORTH: strString = "north"; break;
; 1042 : 	case DIRECTION_NORTHEAST:
; 1043 : 		strString = "northeast";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218671
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1064 : 		break;
; 1065 : 	}
; 1066 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN6@getDirecti:

; 1044 : 		break;
; 1045 : 	case DIRECTION_EAST:
; 1046 : 		strString = "east";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218673
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1064 : 		break;
; 1065 : 	}
; 1066 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN5@getDirecti:

; 1047 : 		break;
; 1048 : 	case DIRECTION_SOUTHEAST:
; 1049 : 		strString = "southeast";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218675
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1064 : 		break;
; 1065 : 	}
; 1066 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN4@getDirecti:

; 1050 : 		break;
; 1051 : 		//case DIRECTION_SOUTH: strString = "south"; break;
; 1052 : 	case DIRECTION_SOUTHWEST:
; 1053 : 		strString = "southwest";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218677
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1064 : 		break;
; 1065 : 	}
; 1066 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN3@getDirecti:

; 1054 : 		break;
; 1055 : 	case DIRECTION_WEST:
; 1056 : 		strString = "west";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218679
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1064 : 		break;
; 1065 : 	}
; 1066 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN2@getDirecti:

; 1057 : 		break;
; 1058 : 	case DIRECTION_NORTHWEST:
; 1059 : 		strString = "northwest";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218681
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1064 : 		break;
; 1065 : 	}
; 1066 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN1@getDirecti:

; 1060 : 		break;
; 1061 : 
; 1062 : 	default:
; 1063 : 		strString = CvString::format("UNKNOWN_DIRECTION(%d)", eDirectionType);

	push	ecx
	lea	eax, DWORD PTR $T220001[esp+44]
	push	OFFSET $SG218684
	push	eax
	call	?format@CvString@@SA?AV1@PBDZZ		; CvString::format
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _strString$[esp+36]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+52], 0
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T220001[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1064 : 		break;
; 1065 : 	}
; 1066 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN20@getDirecti:
	DD	$LN8@getDirecti
	DD	$LN7@getDirecti
	DD	$LN6@getDirecti
	DD	$LN5@getDirecti
	DD	$LN4@getDirecti
	DD	$LN3@getDirecti
	DD	$LN2@getDirecti
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z$0:
	lea	ecx, DWORD PTR $T220001[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z ENDP ; getDirectionTypeString
PUBLIC	?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z ; getActivityTypeString
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z$0
__ehfuncinfo$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
xdata$x	ENDS
;	COMDAT ?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z
_TEXT	SEGMENT
$T220021 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strString$ = 8						; size = 4
_eActivityType$ = 12					; size = 4
?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z PROC ; getActivityTypeString, COMDAT

; 1069 : {

	mov	eax, DWORD PTR fs:0

; 1070 : 	switch(eActivityType)

	mov	ecx, DWORD PTR _eActivityType$[esp-4]
	push	-1
	push	__ehhandler$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	lea	eax, DWORD PTR [ecx+1]
	sub	esp, 28					; 0000001cH
	cmp	eax, 7
	ja	$LN1@getActivit
	jmp	DWORD PTR $LN21@getActivit[eax*4]
$LN9@getActivit:

; 1071 : 	{
; 1072 : 	case NO_ACTIVITY:
; 1073 : 		strString			= "NO_ACTIVITY";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218694
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1099 : 		break;
; 1100 : 	}
; 1101 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN8@getActivit:

; 1074 : 		break;
; 1075 : 	case ACTIVITY_AWAKE:
; 1076 : 		strString		= "ACTIVITY_AWAKE";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218696
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1099 : 		break;
; 1100 : 	}
; 1101 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN7@getActivit:

; 1077 : 		break;
; 1078 : 	case ACTIVITY_HOLD:
; 1079 : 		strString		= "ACTIVITY_HOLD";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218698
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1099 : 		break;
; 1100 : 	}
; 1101 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN6@getActivit:

; 1080 : 		break;
; 1081 : 	case ACTIVITY_SLEEP:
; 1082 : 		strString		= "ACTIVITY_SLEEP";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218700
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1099 : 		break;
; 1100 : 	}
; 1101 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN5@getActivit:

; 1083 : 		break;
; 1084 : 	case ACTIVITY_HEAL:
; 1085 : 		strString		= "ACTIVITY_HEAL";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218702
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1099 : 		break;
; 1100 : 	}
; 1101 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN4@getActivit:

; 1086 : 		break;
; 1087 : 	case ACTIVITY_SENTRY:
; 1088 : 		strString		= "ACTIVITY_SENTRY";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218704
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1099 : 		break;
; 1100 : 	}
; 1101 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN3@getActivit:

; 1089 : 		break;
; 1090 : 	case ACTIVITY_INTERCEPT:
; 1091 : 		strString	= "ACTIVITY_SENTRY";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218706
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1099 : 		break;
; 1100 : 	}
; 1101 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN2@getActivit:

; 1092 : 		break;
; 1093 : 	case ACTIVITY_MISSION:
; 1094 : 		strString	= "ACTIVITY_MISSION";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218708
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1099 : 		break;
; 1100 : 	}
; 1101 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN1@getActivit:

; 1095 : 		break;
; 1096 : 
; 1097 : 	default:
; 1098 : 		strString = CvString::format("UNKNOWN_ACTIVITY(%d)", eActivityType);

	push	ecx
	lea	eax, DWORD PTR $T220021[esp+44]
	push	OFFSET $SG218711
	push	eax
	call	?format@CvString@@SA?AV1@PBDZZ		; CvString::format
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _strString$[esp+36]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+52], 0
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T220021[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1099 : 		break;
; 1100 : 	}
; 1101 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
	npad	3
$LN21@getActivit:
	DD	$LN9@getActivit
	DD	$LN8@getActivit
	DD	$LN7@getActivit
	DD	$LN6@getActivit
	DD	$LN5@getActivit
	DD	$LN4@getActivit
	DD	$LN3@getActivit
	DD	$LN2@getActivit
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z$0:
	lea	ecx, DWORD PTR $T220021[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z ENDP ; getActivityTypeString
PUBLIC	?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z ; getMissionAIString
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z$0
__ehfuncinfo$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
xdata$x	ENDS
;	COMDAT ?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z
_TEXT	SEGMENT
$T220041 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strString$ = 8						; size = 4
_eMissionAI$ = 12					; size = 4
?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z PROC ; getMissionAIString, COMDAT

; 1104 : {

	mov	eax, DWORD PTR fs:0

; 1105 : 	switch(eMissionAI)

	mov	ecx, DWORD PTR _eMissionAI$[esp-4]
	push	-1
	push	__ehhandler$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	lea	eax, DWORD PTR [ecx+1]
	sub	esp, 28					; 0000001cH
	cmp	eax, 22					; 00000016H
	ja	$LN1@getMission
	jmp	DWORD PTR $LN35@getMission[eax*4]
$LN23@getMission:

; 1106 : 	{
; 1107 : 	case NO_MISSIONAI:
; 1108 : 		strString = "NO_MISSIONAI";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218721
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN22@getMission:

; 1109 : 		break;
; 1110 : 
; 1111 : 	case MISSIONAI_SHADOW:
; 1112 : 		strString = "MISSIONAI_SHADOW";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218723
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN21@getMission:

; 1113 : 		break;
; 1114 : 	case MISSIONAI_GROUP:
; 1115 : 		strString = "MISSIONAI_GROUP";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218725
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN20@getMission:

; 1116 : 		break;
; 1117 : 	case MISSIONAI_LOAD_ASSAULT:
; 1118 : 		strString = "MISSIONAI_LOAD_ASSAULT";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218727
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN19@getMission:

; 1119 : 		break;
; 1120 : 	case MISSIONAI_LOAD_SETTLER:
; 1121 : 		strString = "MISSIONAI_LOAD_SETTLER";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218729
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN18@getMission:

; 1122 : 		break;
; 1123 : 	case MISSIONAI_LOAD_SPECIAL:
; 1124 : 		strString = "MISSIONAI_LOAD_SPECIA";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218731
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN17@getMission:

; 1125 : 		break;
; 1126 : 	case MISSIONAI_GUARD_CITY:
; 1127 : 		strString = "MISSIONAI_GUARD_CITY";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218733
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN16@getMission:

; 1128 : 		break;
; 1129 : 	case MISSIONAI_GUARD_RESOURCE:
; 1130 : 		strString = "MISSIONAI_GUARD_RESOURCE";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218735
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN15@getMission:

; 1131 : 		break;
; 1132 : 	case MISSIONAI_GUARD_SPY:
; 1133 : 		strString = "MISSIONAI_GUARD_SPY";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218737
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN14@getMission:

; 1134 : 		break;
; 1135 : 	case MISSIONAI_ATTACK_SPY:
; 1136 : 		strString = "MISSIONAI_ATTACK_SPY";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218739
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN13@getMission:

; 1137 : 		break;
; 1138 : 	case MISSIONAI_SPREAD:
; 1139 : 		strString = "MISSIONAI_SPREAD";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218741
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN12@getMission:

; 1140 : 		break;
; 1141 : 	case MISSIONAI_CONSTRUCT:
; 1142 : 		strString = "MISSIONAI_CONSTRUCT";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218743
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN11@getMission:

; 1143 : 		break;
; 1144 : 	case MISSIONAI_HURRY:
; 1145 : 		strString = "MISSIONAI_HURRY";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218745
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN10@getMission:

; 1146 : 		break;
; 1147 : 	case MISSIONAI_GREAT_WORK:
; 1148 : 		strString = "MISSIONAI_GREAT_WORK";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218747
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN9@getMission:

; 1149 : 		break;
; 1150 : 	case MISSIONAI_EXPLORE:
; 1151 : 		strString = "MISSIONAI_EXPLORE";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218749
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN8@getMission:

; 1152 : 		break;
; 1153 : 	case MISSIONAI_BLOCKADE:
; 1154 : 		strString = "MISSIONAI_BLOCKADE";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218751
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN7@getMission:

; 1155 : 		break;
; 1156 : 	case MISSIONAI_PILLAGE:
; 1157 : 		strString = "MISSIONAI_PILLAGE";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218753
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN6@getMission:

; 1158 : 		break;
; 1159 : 	case MISSIONAI_FOUND:
; 1160 : 		strString = "MISSIONAI_FOUND";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218755
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN5@getMission:

; 1161 : 		break;
; 1162 : 	case MISSIONAI_BUILD:
; 1163 : 		strString = "MISSIONAI_BUILD";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218757
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN4@getMission:

; 1164 : 		break;
; 1165 : 	case MISSIONAI_ASSAULT:
; 1166 : 		strString = "MISSIONAI_ASSAULT";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218759
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN3@getMission:

; 1167 : 		break;
; 1168 : 	case MISSIONAI_CARRIER:
; 1169 : 		strString = "MISSIONAI_CARRIER";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218761
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN2@getMission:

; 1170 : 		break;
; 1171 : 	case MISSIONAI_PICKUP:
; 1172 : 		strString = "MISSIONAI_PICKUP";

	mov	ecx, DWORD PTR _strString$[esp+36]
	push	OFFSET $SG218763
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN1@getMission:

; 1173 : 		break;
; 1174 : 
; 1175 : 	default:
; 1176 : 		strString = CvString::format("UNKOWN_MISSION_AI(%d)", eMissionAI);

	push	ecx
	lea	eax, DWORD PTR $T220041[esp+44]
	push	OFFSET $SG218766
	push	eax
	call	?format@CvString@@SA?AV1@PBDZZ		; CvString::format
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _strString$[esp+36]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+52], 0
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T220041[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
	npad	1
$LN35@getMission:
	DD	$LN23@getMission
	DD	$LN22@getMission
	DD	$LN21@getMission
	DD	$LN20@getMission
	DD	$LN19@getMission
	DD	$LN18@getMission
	DD	$LN17@getMission
	DD	$LN16@getMission
	DD	$LN1@getMission
	DD	$LN15@getMission
	DD	$LN14@getMission
	DD	$LN13@getMission
	DD	$LN12@getMission
	DD	$LN11@getMission
	DD	$LN10@getMission
	DD	$LN9@getMission
	DD	$LN8@getMission
	DD	$LN7@getMission
	DD	$LN6@getMission
	DD	$LN5@getMission
	DD	$LN4@getMission
	DD	$LN3@getMission
	DD	$LN2@getMission
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z$0:
	lea	ecx, DWORD PTR $T220041[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z ENDP ; getMissionAIString
PUBLIC	?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z ; getUnitAIString
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z$0
__ehfuncinfo$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
xdata$x	ENDS
;	COMDAT ?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z
_TEXT	SEGMENT
$T220061 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strString$ = 8						; size = 4
_eUnitAI$ = 12						; size = 4
?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z PROC ; getUnitAIString, COMDAT

; 1182 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 1183 : 	// note, GC.getUnitAIInfo(eUnitAI).getDescription() is a international friendly way to get string (but it will be longer)
; 1184 : 
; 1185 : 	switch(eUnitAI)

	mov	esi, DWORD PTR _eUnitAI$[esp+40]
	lea	eax, DWORD PTR [esi+1]
	push	edi
	mov	edi, DWORD PTR _strString$[esp+44]
	cmp	eax, 42					; 0000002aH
	ja	$LN1@getUnitAIS
	jmp	DWORD PTR $LN55@getUnitAIS[eax*4]
$LN43@getUnitAIS:

; 1186 : 	{
; 1187 : 	case NO_UNITAI:
; 1188 : 		strString = "no unitAI";

	push	OFFSET $SG218776
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN42@getUnitAIS:

; 1189 : 		break;
; 1190 : 
; 1191 : 	case UNITAI_UNKNOWN:
; 1192 : 		strString = "unknown";

	push	OFFSET $SG218778
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN41@getUnitAIS:

; 1193 : 		break;
; 1194 : 	case UNITAI_SETTLE:
; 1195 : 		strString = "settle";

	push	OFFSET $SG218780
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN40@getUnitAIS:

; 1196 : 		break;
; 1197 : 	case UNITAI_WORKER:
; 1198 : 		strString = "worker";

	push	OFFSET $SG218782
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN39@getUnitAIS:

; 1199 : 		break;
; 1200 : 	case UNITAI_ATTACK:
; 1201 : 		strString = "attack";

	push	OFFSET $SG218784
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN38@getUnitAIS:

; 1202 : 		break;
; 1203 : 	case UNITAI_CITY_BOMBARD:
; 1204 : 		strString = "bombard city";

	push	OFFSET $SG218786
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN37@getUnitAIS:

; 1205 : 		break;
; 1206 : 	case UNITAI_FAST_ATTACK:
; 1207 : 		strString = "fast attack";

	push	OFFSET $SG218788
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN36@getUnitAIS:

; 1208 : 		break;
; 1209 : 	case UNITAI_DEFENSE:
; 1210 : 		strString = "defense";

	push	OFFSET $SG218790
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN35@getUnitAIS:

; 1211 : 		break;
; 1212 : 	case UNITAI_COUNTER:
; 1213 : 		strString = "counter";

	push	OFFSET $SG218792
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN34@getUnitAIS:

; 1214 : 		break;
; 1215 : 	case UNITAI_RANGED:
; 1216 : 		strString = "ranged";

	push	OFFSET $SG218794
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN33@getUnitAIS:

; 1217 : 		break;
; 1218 : 	case UNITAI_CITY_SPECIAL:
; 1219 : 		strString = "city special";

	push	OFFSET $SG218796
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN32@getUnitAIS:

; 1220 : 		break;
; 1221 : 	case UNITAI_EXPLORE:
; 1222 : 		strString = "explore";

	push	OFFSET $SG218798
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN31@getUnitAIS:

; 1223 : 		break;
; 1224 : 	case UNITAI_ARTIST:
; 1225 : 		strString = "artist";

	push	OFFSET $SG218800
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN30@getUnitAIS:

; 1226 : 		break;
; 1227 : 	case UNITAI_SCIENTIST:
; 1228 : 		strString = "scientist";

	push	OFFSET $SG218802
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN29@getUnitAIS:

; 1229 : 		break;
; 1230 : 	case UNITAI_GENERAL:
; 1231 : 		strString = "general";

	push	OFFSET $SG218804
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN28@getUnitAIS:

; 1232 : 		break;
; 1233 : 	case UNITAI_MERCHANT:
; 1234 : 		strString = "merchant";

	push	OFFSET $SG218806
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN27@getUnitAIS:

; 1235 : 		break;
; 1236 : 	case UNITAI_ENGINEER:
; 1237 : 		strString = "engineer";

	push	OFFSET $SG218808
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN26@getUnitAIS:

; 1238 : 		break;
; 1239 : 	case UNITAI_ICBM:
; 1240 : 		strString = "icbm";

	push	OFFSET $SG218810
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN25@getUnitAIS:

; 1241 : 		break;
; 1242 : 	case UNITAI_WORKER_SEA:
; 1243 : 		strString = "worker sea";

	push	OFFSET $SG218812
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN24@getUnitAIS:

; 1244 : 		break;
; 1245 : 	case UNITAI_ATTACK_SEA:
; 1246 : 		strString = "attack sea";

	push	OFFSET $SG218814
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN23@getUnitAIS:

; 1247 : 		break;
; 1248 : 	case UNITAI_RESERVE_SEA:
; 1249 : 		strString = "reserve sea";

	push	OFFSET $SG218816
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN22@getUnitAIS:

; 1250 : 		break;
; 1251 : 	case UNITAI_ESCORT_SEA:
; 1252 : 		strString = "escort sea";

	push	OFFSET $SG218818
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN21@getUnitAIS:

; 1253 : 		break;
; 1254 : 	case UNITAI_EXPLORE_SEA:
; 1255 : 		strString = "explore sea";

	push	OFFSET $SG218820
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN20@getUnitAIS:

; 1256 : 		break;
; 1257 : 	case UNITAI_ASSAULT_SEA:
; 1258 : 		strString = "assault sea";

	push	OFFSET $SG218822
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN19@getUnitAIS:

; 1259 : 		break;
; 1260 : 	case UNITAI_SETTLER_SEA:
; 1261 : 		strString = "settler sea";

	push	OFFSET $SG218824
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN18@getUnitAIS:

; 1262 : 		break;
; 1263 : 	case UNITAI_CARRIER_SEA:
; 1264 : 		strString = "carrier sea";

	push	OFFSET $SG218826
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN17@getUnitAIS:

; 1265 : 		break;
; 1266 : 	case UNITAI_MISSILE_CARRIER_SEA:
; 1267 : 		strString = "missile carrier";

	push	OFFSET $SG218828
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN16@getUnitAIS:

; 1268 : 		break;
; 1269 : 	case UNITAI_PIRATE_SEA:
; 1270 : 		strString = "pirate sea";

	push	OFFSET $SG218830
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN15@getUnitAIS:

; 1271 : 		break;
; 1272 : 	case UNITAI_ATTACK_AIR:
; 1273 : 		strString = "attack air";

	push	OFFSET $SG218832
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN14@getUnitAIS:

; 1274 : 		break;
; 1275 : 	case UNITAI_DEFENSE_AIR:
; 1276 : 		strString = "defense air";

	push	OFFSET $SG218834
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN13@getUnitAIS:

; 1277 : 		break;
; 1278 : 	case UNITAI_CARRIER_AIR:
; 1279 : 		strString = "carrier air";

	push	OFFSET $SG218836
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN12@getUnitAIS:

; 1280 : 		break;
; 1281 : 	case UNITAI_PARADROP:
; 1282 : 		strString = "paradrop";

	push	OFFSET $SG218838
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN11@getUnitAIS:

; 1283 : 		break;
; 1284 : 	case UNITAI_SPACESHIP_PART:
; 1285 : 		strString = "spaceship part";

	push	OFFSET $SG218840
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN10@getUnitAIS:

; 1286 : 		break;
; 1287 : 	case UNITAI_TREASURE:
; 1288 : 		strString = "treasure";

	push	OFFSET $SG218842
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN9@getUnitAIS:

; 1289 : 		break;
; 1290 : 	case UNITAI_PROPHET:
; 1291 : 		strString = "prophet";

	push	OFFSET $SG218844
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN8@getUnitAIS:

; 1292 : 		break;
; 1293 : 	case UNITAI_MISSIONARY:
; 1294 : 		strString = "missionary";

	push	OFFSET $SG218846
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN7@getUnitAIS:

; 1295 : 		break;
; 1296 : 	case UNITAI_INQUISITOR:
; 1297 : 		strString = "inquisitor";

	push	OFFSET $SG218848
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN6@getUnitAIS:

; 1298 : 		break;
; 1299 : 	case UNITAI_ADMIRAL:
; 1300 : 		strString = "admiral";

	push	OFFSET $SG218850
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN5@getUnitAIS:

; 1301 : 		break;
; 1302 : 	case UNITAI_TRADE_UNIT:
; 1303 : 		strString = "trade unit";

	push	OFFSET $SG218852
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN4@getUnitAIS:

; 1304 : 		break;
; 1305 : 	case UNITAI_ARCHAEOLOGIST:
; 1306 : 		strString = "archaeologist";

	push	OFFSET $SG218854
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN3@getUnitAIS:

; 1307 : 		break;
; 1308 : 	case UNITAI_WRITER:
; 1309 : 		strString = "writer";

	push	OFFSET $SG218856
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
	pop	edi
	pop	esi

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
$LN2@getUnitAIS:

; 1310 : 		break;
; 1311 : 	case UNITAI_MUSICIAN:
; 1312 : 		strString = "musician";

	push	OFFSET $SG218858
	mov	ecx, edi
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
$LN1@getUnitAIS:

; 1313 : 
; 1314 : 	default:
; 1315 : 		strString = CvString::format("unknown(%d)", eUnitAI);

	push	esi
	lea	eax, DWORD PTR $T220061[esp+52]
	push	OFFSET $SG218861
	push	eax
	call	?format@CvString@@SA?AV1@PBDZZ		; CvString::format
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T220061[esp+48]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
	npad	3
$LN55@getUnitAIS:
	DD	$LN43@getUnitAIS
	DD	$LN42@getUnitAIS
	DD	$LN41@getUnitAIS
	DD	$LN40@getUnitAIS
	DD	$LN39@getUnitAIS
	DD	$LN38@getUnitAIS
	DD	$LN37@getUnitAIS
	DD	$LN36@getUnitAIS
	DD	$LN35@getUnitAIS
	DD	$LN34@getUnitAIS
	DD	$LN33@getUnitAIS
	DD	$LN32@getUnitAIS
	DD	$LN31@getUnitAIS
	DD	$LN30@getUnitAIS
	DD	$LN29@getUnitAIS
	DD	$LN28@getUnitAIS
	DD	$LN27@getUnitAIS
	DD	$LN26@getUnitAIS
	DD	$LN25@getUnitAIS
	DD	$LN24@getUnitAIS
	DD	$LN23@getUnitAIS
	DD	$LN22@getUnitAIS
	DD	$LN21@getUnitAIS
	DD	$LN20@getUnitAIS
	DD	$LN19@getUnitAIS
	DD	$LN18@getUnitAIS
	DD	$LN17@getUnitAIS
	DD	$LN16@getUnitAIS
	DD	$LN15@getUnitAIS
	DD	$LN14@getUnitAIS
	DD	$LN13@getUnitAIS
	DD	$LN1@getUnitAIS
	DD	$LN12@getUnitAIS
	DD	$LN11@getUnitAIS
	DD	$LN10@getUnitAIS
	DD	$LN9@getUnitAIS
	DD	$LN8@getUnitAIS
	DD	$LN7@getUnitAIS
	DD	$LN6@getUnitAIS
	DD	$LN5@getUnitAIS
	DD	$LN4@getUnitAIS
	DD	$LN3@getUnitAIS
	DD	$LN2@getUnitAIS
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z$0:
	lea	ecx, DWORD PTR $T220061[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z ENDP ; getUnitAIString
PUBLIC	?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z		; ExtractGUID
; Function compile flags: /Ogtpy
;	COMDAT ?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z
_TEXT	SEGMENT
_uiIndex$218936 = 8					; size = 4
_pszGUID$ = 8						; size = 4
_kGUID$ = 12						; size = 4
_puiStartIndex$ = 16					; size = 4
?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z PROC		; ExtractGUID, COMDAT

; 1505 : {

	push	ebx

; 1506 : 	if(pszGUID)

	mov	ebx, DWORD PTR _pszGUID$[esp]
	push	ebp
	push	esi
	xor	esi, esi
	push	edi
	cmp	ebx, esi
	je	$LN6@ExtractGUI

; 1507 : 	{
; 1508 : 		UINT uiIndex = (puiStartIndex != NULL)?(*puiStartIndex):0;

	mov	ebp, DWORD PTR _puiStartIndex$[esp+12]
	cmp	ebp, esi
	je	SHORT $LN12@ExtractGUI
	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR _uiIndex$218936[esp+12], eax
	jmp	SHORT $LN13@ExtractGUI
$LN12@ExtractGUI:
	mov	DWORD PTR _uiIndex$218936[esp+12], esi
$LN13@ExtractGUI:

; 1509 : 
; 1510 : 		if(GetGUIDSegment(pszGUID, &uiIndex, kGUID.Data1))

	mov	edi, DWORD PTR _kGUID$[esp+12]
	push	edi
	lea	ecx, DWORD PTR _uiIndex$218936[esp+16]
	push	ecx
	push	ebx
	call	??$GetGUIDSegment@K@@YA_NPBDPAIAAK@Z	; GetGUIDSegment<unsigned long>
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN6@ExtractGUI

; 1511 : 		{
; 1512 : 			if(GetGUIDSegment(pszGUID, &uiIndex, kGUID.Data2))

	lea	edx, DWORD PTR [edi+4]
	push	edx
	lea	eax, DWORD PTR _uiIndex$218936[esp+16]
	push	eax
	push	ebx
	call	??$GetGUIDSegment@G@@YA_NPBDPAIAAG@Z	; GetGUIDSegment<unsigned short>
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN6@ExtractGUI

; 1513 : 			{
; 1514 : 				if(GetGUIDSegment(pszGUID, &uiIndex, kGUID.Data3))

	lea	ecx, DWORD PTR [edi+6]
	push	ecx
	lea	edx, DWORD PTR _uiIndex$218936[esp+16]
	push	edx
	push	ebx
	call	??$GetGUIDSegment@G@@YA_NPBDPAIAAG@Z	; GetGUIDSegment<unsigned short>
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN6@ExtractGUI
	npad	6
$LL5@ExtractGUI:

; 1515 : 				{
; 1516 : 					for(int iByte = 0; iByte < 8; ++iByte)

	lea	eax, DWORD PTR [edi+esi+8]

; 1517 : 					{
; 1518 : 						if(!GetGUIDSegment(pszGUID, &uiIndex, kGUID.Data4[iByte]))

	push	eax
	lea	ecx, DWORD PTR _uiIndex$218936[esp+16]
	push	ecx
	push	ebx
	call	??$GetGUIDSegment@E@@YA_NPBDPAIAAE@Z	; GetGUIDSegment<unsigned char>
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN6@ExtractGUI
	inc	esi
	cmp	esi, 8
	jl	SHORT $LL5@ExtractGUI

; 1519 : 						{
; 1520 : 							return false;
; 1521 : 						}
; 1522 : 					}
; 1523 : 
; 1524 : 					if(puiStartIndex)

	test	ebp, ebp
	je	SHORT $LN1@ExtractGUI

; 1525 : 						*puiStartIndex = uiIndex;

	mov	edx, DWORD PTR _uiIndex$218936[esp+12]
	mov	DWORD PTR [ebp], edx
$LN1@ExtractGUI:
	pop	edi
	pop	esi
	pop	ebp

; 1526 : 					return true;

	mov	al, 1
	pop	ebx

; 1533 : }

	ret	0
$LN6@ExtractGUI:
	pop	edi
	pop	esi
	pop	ebp

; 1527 : 				}
; 1528 : 			}
; 1529 : 		}
; 1530 : 	}
; 1531 : 
; 1532 : 	return false;

	xor	al, al
	pop	ebx

; 1533 : }

	ret	0
?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z ENDP		; ExtractGUID
_TEXT	ENDS
PUBLIC	?GetID@CvUnit@@QBEHXZ				; CvUnit::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?GetID@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvUnit@@QBEHXZ PROC				; CvUnit::GetID, COMDAT
; _this$ = ecx

; 662  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+100]

; 663  : 	}

	ret	0
?GetID@CvUnit@@QBEHXZ ENDP				; CvUnit::GetID
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1182 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1183 : 	}

	ret	0

; 1182 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1183 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 219  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 220  : 	{
; 221  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0
$LN2@plotDirect:

; 222  : 	}
; 223  : 	else
; 224  : 	{
; 225  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 226  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 227  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 228  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 229  : 
; 230  : 		// convert from hex-space coordinates to the storage array
; 231  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 232  : 
; 233  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0

; 232  : 
; 233  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotCity@@YAPAVCvPlot@@HHH@Z			; plotCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
;	COMDAT ?plotCity@@YAPAVCvPlot@@HHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iIndex$ = 16						; size = 4
?plotCity@@YAPAVCvPlot@@HHH@Z PROC			; plotCity, COMDAT

; 38   : 	int iDeltaHexX = 0;
; 39   : 	int iDeltaHexY = 0;
; 40   : 	if(iIndex < NUM_CITY_PLOTS)

	mov	edx, DWORD PTR _iIndex$[esp-4]
	cmp	edx, 37					; 00000025H
	push	esi
	push	edi
	jge	SHORT $LN13@plotCity

; 41   : 	{
; 42   : 		iDeltaHexX = GC.getCityPlotX()[iIndex]; // getCityPlotX now uses hex-space coords

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+160]

; 43   : 		iDeltaHexY = GC.getCityPlotY()[iIndex];

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+308]

; 44   : 	}
; 45   : 	else

	jmp	SHORT $LN8@plotCity
$LN13@plotCity:

; 46   : 	{
; 47   : 		// loop till we find the ring this is on
; 48   : 		int iThisRing = 0;

	xor	ecx, ecx

; 49   : 		int iHighestValueOnThisRing = 0;

	xor	eax, eax

; 50   : 		int iLowestValueOnThisRing = 0;

	xor	edi, edi

; 51   : 		while(iHighestValueOnThisRing < iIndex)

	test	edx, edx
	jle	SHORT $LN10@plotCity

; 46   : 	{
; 47   : 		// loop till we find the ring this is on
; 48   : 		int iThisRing = 0;

	xor	esi, esi
$LL11@plotCity:

; 52   : 		{
; 53   : 			iThisRing++;

	add	esi, 6

; 54   : 			iLowestValueOnThisRing = iHighestValueOnThisRing + 1;

	lea	edi, DWORD PTR [eax+1]

; 55   : 			iHighestValueOnThisRing += iThisRing*6;

	add	eax, esi
	inc	ecx
	cmp	eax, edx
	jl	SHORT $LL11@plotCity
$LN10@plotCity:

; 56   : 		}
; 57   : 		// determine what side of the hex we are on
; 58   : 		int iDiff = (iIndex - iLowestValueOnThisRing);

	sub	edx, edi
	mov	eax, edx

; 59   : 		int iSide = iDiff / iThisRing;
; 60   : 		int iOffset = iDiff % iThisRing;

	cdq
	idiv	ecx

; 61   : 
; 62   : 		switch(iSide)

	cmp	eax, 5
	ja	$LN1@plotCity
	jmp	DWORD PTR $LN75@plotCity[eax*4]
$LN7@plotCity:

; 63   : 		{
; 64   : 		case 0:
; 65   : 			iDeltaHexX = 0 + iOffset;
; 66   : 			iDeltaHexY = iThisRing - iOffset;

	sub	ecx, edx

; 67   : 			break;

	jmp	SHORT $LN72@plotCity
$LN6@plotCity:

; 68   : 		case 1:
; 69   : 			iDeltaHexX = iThisRing;
; 70   : 			iDeltaHexY = 0 - iOffset;

	neg	edx
	mov	esi, ecx
	mov	ecx, edx

; 71   : 			break;

	jmp	SHORT $LN8@plotCity
$LN5@plotCity:

; 72   : 		case 2:
; 73   : 			iDeltaHexX = iThisRing - iOffset;

	mov	esi, ecx
	sub	esi, edx

; 74   : 			iDeltaHexY = -iThisRing;

	neg	ecx

; 75   : 			break;

	jmp	SHORT $LN8@plotCity
$LN4@plotCity:

; 76   : 		case 3:
; 77   : 			iDeltaHexX = 0 - iOffset;

	mov	esi, edx
	neg	esi

; 78   : 			iDeltaHexY = -iThisRing + iOffset;

	sub	edx, ecx
	mov	ecx, edx

; 79   : 			break;

	jmp	SHORT $LN8@plotCity
$LN3@plotCity:

; 80   : 		case 4:
; 81   : 			iDeltaHexX = -iThisRing;

	neg	ecx
	mov	esi, ecx

; 82   : 			iDeltaHexY = 0 + iOffset;

	mov	ecx, edx

; 83   : 			break;

	jmp	SHORT $LN8@plotCity
$LN2@plotCity:

; 84   : 		case 5:
; 85   : 			iDeltaHexX = -iThisRing + iOffset;

	sub	edx, ecx
$LN72@plotCity:
	mov	esi, edx
$LN8@plotCity:

; 90   : 		}
; 91   : 
; 92   : 	}
; 93   : 	// convert the city coord to hex-space coordinates
; 94   : 	int iCityHexX = xToHexspaceX(iX, iY);

	mov	edi, DWORD PTR _iY$[esp+4]
	test	edi, edi
	jl	SHORT $LN22@plotCity
	mov	eax, edi
	jmp	SHORT $LN73@plotCity
$LN22@plotCity:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN73@plotCity:
	sar	eax, 1

; 95   : 
; 96   : 	int iPlotHexX = iCityHexX + iDeltaHexX;

	sub	esi, eax
	add	esi, DWORD PTR _iX$[esp+4]

; 97   : 	int iPlotY = iY + iDeltaHexY; // Y is the same in both coordinate systems

	add	edi, ecx

; 98   : 
; 99   : 	// convert from hex-space coordinates to the storage array
; 100  : 	int iPlotX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN26@plotCity
	mov	eax, edi
	jmp	SHORT $LN74@plotCity
$LN26@plotCity:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN74@plotCity:
	sar	eax, 1
	add	eax, esi
	push	ebx
	push	ebp

; 101  : 
; 102  : 	return GC.getMap().plot(iPlotX , iPlotY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN30@plotCity
	cmp	edi, -2147483647			; 80000001H
	je	$LN30@plotCity
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN40@plotCity
	test	eax, eax
	jge	SHORT $LN42@plotCity
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN44@plotCity
$LN42@plotCity:
	cmp	eax, ecx
	jl	SHORT $LN40@plotCity
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN44@plotCity
$LN40@plotCity:
	mov	esi, eax
$LN44@plotCity:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN71@plotCity
	test	edi, edi
	jge	SHORT $LN52@plotCity
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN54@plotCity
$LN52@plotCity:
	cmp	edi, ebx
	jl	SHORT $LN71@plotCity
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN54@plotCity
$LN71@plotCity:
	mov	edx, edi
$LN54@plotCity:
	test	esi, esi
	jl	SHORT $LN30@plotCity
	cmp	esi, ecx
	jge	SHORT $LN30@plotCity
	test	edx, edx
	jl	SHORT $LN30@plotCity
	cmp	edx, ebx
	jge	SHORT $LN30@plotCity
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, ecx
	pop	esi

; 103  : }

	ret	0

; 101  : 
; 102  : 	return GC.getMap().plot(iPlotX , iPlotY);

$LN30@plotCity:
	pop	ebp
	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi

; 103  : }

	ret	0
$LN1@plotCity:
	pop	edi

; 86   : 			iDeltaHexY = iThisRing;
; 87   : 			break;
; 88   : 		default:
; 89   : 			return 0;

	xor	eax, eax
	pop	esi

; 103  : }

	ret	0
	npad	2
$LN75@plotCity:
	DD	$LN7@plotCity
	DD	$LN6@plotCity
	DD	$LN5@plotCity
	DD	$LN4@plotCity
	DD	$LN3@plotCity
	DD	$LN2@plotCity
?plotCity@@YAPAVCvPlot@@HHH@Z ENDP			; plotCity
_TEXT	ENDS
PUBLIC	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z	; plotCityXY
EXTRN	?getXYCityPlot@CvGlobals@@QAEHHH@Z:PROC		; CvGlobals::getXYCityPlot
; Function compile flags: /Ogtpy
;	COMDAT ?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z
_TEXT	SEGMENT
$T220632 = 8						; size = 4
_pCity$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z PROC		; plotCityXY, COMDAT

; 107  : {

	push	ebx

; 108  : 
; 109  : 	int iDX;
; 110  : 	int iWrappedDX = dxWrap(pPlot->getX() - pCity->getX());

	mov	ebx, DWORD PTR _pCity$[esp]
	mov	ecx, DWORD PTR [ebx+96]
	push	ebp
	mov	ebp, DWORD PTR _pPlot$[esp+4]
	movsx	eax, WORD PTR [ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [edi+4020]
	sub	eax, ecx
	cmp	BYTE PTR [edi+4056], 0
	je	SHORT $LN19@plotCityXY
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN21@plotCityXY
	sub	eax, esi
$LN19@plotCityXY:
	mov	DWORD PTR $T220632[esp+12], eax
$LN23@plotCityXY:

; 111  : 	int iWrappedDY = dyWrap(pPlot->getY() - pCity->getY());

	movsx	eax, WORD PTR [ebp+2]
	mov	ebx, DWORD PTR [ebx+108]
	mov	esi, DWORD PTR [edi+4024]
	sub	eax, ebx
	cmp	BYTE PTR [edi+4057], 0
	je	SHORT $LN97@plotCityXY
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN41@plotCityXY
	sub	eax, esi
	jmp	SHORT $LN97@plotCityXY

; 108  : 
; 109  : 	int iDX;
; 110  : 	int iWrappedDX = dxWrap(pPlot->getX() - pCity->getX());

$LN21@plotCityXY:
	neg	edx
	cmp	eax, edx
	jge	SHORT $LN19@plotCityXY
	add	esi, eax
	mov	DWORD PTR $T220632[esp+12], esi
	jmp	SHORT $LN23@plotCityXY

; 111  : 	int iWrappedDY = dyWrap(pPlot->getY() - pCity->getY());

$LN41@plotCityXY:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN43@plotCityXY
$LN97@plotCityXY:
	mov	ebp, eax
$LN43@plotCityXY:

; 112  : 	int iDY = iWrappedDY;
; 113  : 
; 114  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 115  : 	int iCityHexX = xToHexspaceX(pCity->getX(), pCity->getY());

	test	ebx, ebx
	jl	SHORT $LN55@plotCityXY
	mov	eax, ebx
	jmp	SHORT $LN98@plotCityXY
$LN55@plotCityXY:
	lea	eax, DWORD PTR [ebx-1]
	cdq
	sub	eax, edx
$LN98@plotCityXY:
	sar	eax, 1
	mov	esi, ecx
	sub	esi, eax

; 116  : 	int iPlotHexX = xToHexspaceX(pCity->getX() + iWrappedDX, pCity->getY() + iWrappedDY);

	lea	eax, DWORD PTR [ebx+ebp]
	test	eax, eax
	jge	SHORT $LN99@plotCityXY
	dec	eax
	cdq
	sub	eax, edx
$LN99@plotCityXY:
	sar	eax, 1

; 117  : 
; 118  : 	iDX = dxWrap(iPlotHexX - iCityHexX);

	sub	ecx, eax
	mov	eax, DWORD PTR [edi+4020]
	sub	ecx, esi
	add	ecx, DWORD PTR $T220632[esp+12]
	cmp	BYTE PTR [edi+4056], 0
	je	SHORT $LN77@plotCityXY
	mov	edx, eax
	shr	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN79@plotCityXY
	sub	ecx, eax
	jmp	SHORT $LN77@plotCityXY
$LN79@plotCityXY:
	neg	edx
	cmp	ecx, edx
	jge	SHORT $LN77@plotCityXY
	add	ecx, eax
$LN77@plotCityXY:

; 119  : 
; 120  : 	if(hexDistance(iDX, iDY) > CITY_PLOTS_RADIUS)

	xor	eax, eax
	test	ecx, ecx
	setge	al
	xor	edx, edx
	test	ebp, ebp
	setge	dl
	cmp	eax, edx
	mov	edx, ecx
	jne	SHORT $LN84@plotCityXY
	test	ecx, ecx
	jge	SHORT $LN88@plotCityXY
	neg	edx
$LN88@plotCityXY:
	mov	eax, ebp
	test	ebp, ebp
	jge	SHORT $LN90@plotCityXY
	neg	eax
$LN90@plotCityXY:
	add	eax, edx
	jmp	SHORT $LN95@plotCityXY
$LN84@plotCityXY:
	test	ecx, ecx
	jge	SHORT $LN92@plotCityXY
	neg	edx
$LN92@plotCityXY:
	mov	eax, ebp
	test	ebp, ebp
	jge	SHORT $LN94@plotCityXY
	neg	eax
$LN94@plotCityXY:
	cmp	edx, eax
	jl	SHORT $LN95@plotCityXY
	mov	eax, edx
$LN95@plotCityXY:
	cmp	eax, 3
	jle	SHORT $LN2@plotCityXY
	pop	edi
	pop	esi
	pop	ebp

; 121  : 	{
; 122  : 		return -1;

	or	eax, -1
	pop	ebx

; 127  : 	}
; 128  : }

	ret	0
$LN2@plotCityXY:

; 123  : 	}
; 124  : 	else
; 125  : 	{
; 126  : 		return GC.getXYCityPlot((iDX + CITY_PLOTS_RADIUS), (iDY + CITY_PLOTS_RADIUS));

	add	ebp, 3
	add	ecx, 3
	push	ebp
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getXYCityPlot@CvGlobals@@QAEHHH@Z	; CvGlobals::getXYCityPlot
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 127  : 	}
; 128  : }

	ret	0
?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ENDP		; plotCityXY
_TEXT	ENDS
PUBLIC	?isBeforeUnitCycle@@YA_NPBVCvUnit@@0@Z		; isBeforeUnitCycle
EXTRN	?getExperience@CvUnit@@QBEHXZ:PROC		; CvUnit::getExperience
EXTRN	?getLevel@CvUnit@@QBEHXZ:PROC			; CvUnit::getLevel
EXTRN	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z:PROC	; CvUnit::GetBaseCombatStrength
; Function compile flags: /Ogtpy
;	COMDAT ?isBeforeUnitCycle@@YA_NPBVCvUnit@@0@Z
_TEXT	SEGMENT
_pFirstUnit$ = 8					; size = 4
_pSecondUnit$ = 12					; size = 4
?isBeforeUnitCycle@@YA_NPBVCvUnit@@0@Z PROC		; isBeforeUnitCycle, COMDAT

; 189  : {

	push	esi
	push	edi

; 190  : 	CvAssert(pFirstUnit != NULL);
; 191  : 	CvAssert(pSecondUnit != NULL);
; 192  : 	CvAssert(pFirstUnit != pSecondUnit);
; 193  : 
; 194  : 	if(!pFirstUnit || !pSecondUnit)

	mov	edi, DWORD PTR _pFirstUnit$[esp+4]
	test	edi, edi
	je	$LN7@isBeforeUn
	mov	esi, DWORD PTR _pSecondUnit$[esp+4]
	test	esi, esi
	je	$LN7@isBeforeUn

; 196  : 
; 197  : 	if(pFirstUnit->getOwner() != pSecondUnit->getOwner())

	mov	eax, DWORD PTR [edi+40]
	mov	ecx, DWORD PTR [esi+40]
	cmp	eax, ecx
	je	SHORT $LN6@isBeforeUn

; 198  : 	{
; 199  : 		return (pFirstUnit->getOwner() < pSecondUnit->getOwner());

	xor	edx, edx
	cmp	eax, ecx
	setl	dl
	pop	edi
	mov	al, dl
	pop	esi

; 228  : }

	ret	0
$LN6@isBeforeUn:
	push	ebx

; 200  : 	}
; 201  : 
; 202  : 	if(pFirstUnit->getDomainType() != pSecondUnit->getDomainType())

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	ecx, esi
	mov	ebx, eax
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 203  : 	{
; 204  : 		return (pFirstUnit->getDomainType() < pSecondUnit->getDomainType());

	mov	ecx, edi
	cmp	ebx, eax
	je	SHORT $LN5@isBeforeUn
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	ecx, esi
	mov	edi, eax
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	xor	ecx, ecx
	cmp	edi, eax
	pop	ebx
	setl	cl
	pop	edi

; 213  : 	{
; 214  : 		return (pFirstUnit->getUnitType() > pSecondUnit->getUnitType());

	mov	al, cl
	pop	esi

; 228  : }

	ret	0
$LN5@isBeforeUn:

; 205  : 	}
; 206  : 
; 207  : 	if(pFirstUnit->GetBaseCombatStrength() != pSecondUnit->GetBaseCombatStrength())

	push	0
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	push	0
	mov	ecx, esi
	mov	ebx, eax
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength

; 208  : 	{
; 209  : 		return (pFirstUnit->GetBaseCombatStrength() > pSecondUnit->GetBaseCombatStrength());

	mov	ecx, edi
	cmp	ebx, eax
	je	SHORT $LN4@isBeforeUn
	push	0
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	push	0
	mov	ecx, esi
	mov	edi, eax
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	xor	edx, edx
	cmp	edi, eax
	pop	ebx
	setg	dl
	pop	edi
	mov	al, dl
	pop	esi

; 228  : }

	ret	0
$LN4@isBeforeUn:

; 210  : 	}
; 211  : 
; 212  : 	if(pFirstUnit->getUnitType() != pSecondUnit->getUnitType())

	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	ecx, esi
	mov	ebx, eax
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType

; 213  : 	{
; 214  : 		return (pFirstUnit->getUnitType() > pSecondUnit->getUnitType());

	mov	ecx, edi
	cmp	ebx, eax
	je	SHORT $LN3@isBeforeUn
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	ecx, esi
	mov	edi, eax
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	xor	ecx, ecx
	cmp	edi, eax
	pop	ebx
	setg	cl
	pop	edi
	mov	al, cl
	pop	esi

; 228  : }

	ret	0
$LN3@isBeforeUn:

; 215  : 	}
; 216  : 
; 217  : 	if(pFirstUnit->getLevel() != pSecondUnit->getLevel())

	call	?getLevel@CvUnit@@QBEHXZ		; CvUnit::getLevel
	mov	ecx, esi
	mov	ebx, eax
	call	?getLevel@CvUnit@@QBEHXZ		; CvUnit::getLevel

; 218  : 	{
; 219  : 		return (pFirstUnit->getLevel() > pSecondUnit->getLevel());

	mov	ecx, edi
	cmp	ebx, eax
	je	SHORT $LN2@isBeforeUn
	call	?getLevel@CvUnit@@QBEHXZ		; CvUnit::getLevel
	mov	ecx, esi
	mov	edi, eax
	call	?getLevel@CvUnit@@QBEHXZ		; CvUnit::getLevel
	xor	edx, edx
	cmp	edi, eax
	pop	ebx
	setg	dl
	pop	edi
	mov	al, dl
	pop	esi

; 228  : }

	ret	0
$LN2@isBeforeUn:

; 220  : 	}
; 221  : 
; 222  : 	if(pFirstUnit->getExperience() != pSecondUnit->getExperience())

	call	?getExperience@CvUnit@@QBEHXZ		; CvUnit::getExperience
	mov	ecx, esi
	mov	ebx, eax
	call	?getExperience@CvUnit@@QBEHXZ		; CvUnit::getExperience
	cmp	ebx, eax
	je	SHORT $LN1@isBeforeUn

; 223  : 	{
; 224  : 		return (pFirstUnit->getExperience() > pSecondUnit->getExperience());

	mov	ecx, edi
	call	?getExperience@CvUnit@@QBEHXZ		; CvUnit::getExperience
	mov	ecx, esi
	mov	edi, eax
	call	?getExperience@CvUnit@@QBEHXZ		; CvUnit::getExperience
	xor	ecx, ecx
	cmp	edi, eax
	pop	ebx
	setg	cl
	pop	edi
	mov	al, cl
	pop	esi

; 228  : }

	ret	0
$LN1@isBeforeUn:

; 225  : 	}
; 226  : 
; 227  : 	return (pFirstUnit->GetID() < pSecondUnit->GetID());

	mov	edx, DWORD PTR [edi+100]
	xor	eax, eax
	cmp	edx, DWORD PTR [esi+100]
	pop	ebx
	pop	edi
	setl	al
	pop	esi

; 228  : }

	ret	0
$LN7@isBeforeUn:
	pop	edi

; 195  : 		return false;

	xor	al, al
	pop	esi

; 228  : }

	ret	0
?isBeforeUnitCycle@@YA_NPBVCvUnit@@0@Z ENDP		; isBeforeUnitCycle
_TEXT	ENDS
PUBLIC	?OnSameBodyOfWater@@YA_NPAVCvCity@@0@Z		; OnSameBodyOfWater
; Function compile flags: /Ogtpy
;	COMDAT ?OnSameBodyOfWater@@YA_NPAVCvCity@@0@Z
_TEXT	SEGMENT
_iI$218395 = -12					; size = 4
tv163 = -8						; size = 4
tv166 = -4						; size = 4
_pCity1$ = 8						; size = 4
_pCity2$ = 12						; size = 4
?OnSameBodyOfWater@@YA_NPAVCvCity@@0@Z PROC		; OnSameBodyOfWater, COMDAT

; 632  : {

	sub	esp, 12					; 0000000cH

; 633  : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	eax, DWORD PTR _pCity1$[esp+8]

; 634  : 	{
; 635  : 		CvPlot* pAdjacentPlot1 = plotDirection(pCity1->getX(), pCity1->getY(), ((DirectionTypes)iI));
; 636  : 
; 637  : 		if(pAdjacentPlot1 != NULL && pAdjacentPlot1->isWater())

	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR [eax+96]
	push	ebx
	push	ebp
	push	esi
	xor	esi, esi
	push	edi
	mov	DWORD PTR _iI$218395[esp+28], esi
	mov	DWORD PTR tv163[esp+28], ecx
	mov	DWORD PTR tv166[esp+28], edx
	npad	1
$LL41@OnSameBody:
	mov	eax, DWORD PTR tv163[esp+28]
	mov	ecx, DWORD PTR tv166[esp+28]
	push	esi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	test	ebx, ebx
	je	SHORT $LN8@OnSameBody
	cmp	BYTE PTR [ebx+5], 3
	jne	SHORT $LN8@OnSameBody

; 638  : 		{
; 639  : 			for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	mov	eax, DWORD PTR _pCity2$[esp+24]
	mov	edi, DWORD PTR [eax+108]
	mov	ebp, DWORD PTR [eax+96]
	xor	esi, esi
	npad	5
$LL5@OnSameBody:

; 640  : 			{
; 641  : 				CvPlot* pAdjacentPlot2 = plotDirection(pCity2->getX(), pCity2->getY(), ((DirectionTypes)jJ));

	push	esi
	push	edi
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 642  : 				if(pAdjacentPlot2 != NULL && pAdjacentPlot2->isWater())

	test	eax, eax
	je	SHORT $LN4@OnSameBody
	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN4@OnSameBody

; 643  : 				{
; 644  : 					if(pAdjacentPlot2->getArea() == pAdjacentPlot1->getArea())

	mov	edx, DWORD PTR [eax+356]
	cmp	edx, DWORD PTR [ebx+356]
	je	SHORT $LN38@OnSameBody
$LN4@OnSameBody:

; 638  : 		{
; 639  : 			for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@OnSameBody
	mov	esi, DWORD PTR _iI$218395[esp+28]
$LN8@OnSameBody:

; 633  : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	inc	esi
	cmp	esi, 6
	mov	DWORD PTR _iI$218395[esp+28], esi
	jl	SHORT $LL41@OnSameBody
	pop	edi
	pop	esi
	pop	ebp

; 647  : 					}
; 648  : 				}
; 649  : 			}
; 650  : 		}
; 651  : 	}
; 652  : 	return false;

	xor	al, al
	pop	ebx

; 653  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN38@OnSameBody:
	pop	edi
	pop	esi
	pop	ebp

; 645  : 					{
; 646  : 						return true;

	mov	al, 1
	pop	ebx

; 653  : }

	add	esp, 12					; 0000000cH
	ret	0
?OnSameBodyOfWater@@YA_NPAVCvCity@@0@Z ENDP		; OnSameBodyOfWater
_TEXT	ENDS
PUBLIC	?PUF_isPlayer@@YA_NPBVCvUnit@@HH@Z		; PUF_isPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isPlayer@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isPlayer@@YA_NPBVCvUnit@@HH@Z PROC			; PUF_isPlayer, COMDAT

; 699  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 700  : 	return (pUnit->getOwner() == iData1);

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	mov	edx, DWORD PTR [ecx+40]
	xor	eax, eax
	cmp	edx, DWORD PTR _iData1$[esp-4]
	sete	al

; 701  : }

	ret	0
?PUF_isPlayer@@YA_NPBVCvUnit@@HH@Z ENDP			; PUF_isPlayer
_TEXT	ENDS
PUBLIC	?PUF_isCombatTeam@@YA_NPBVCvUnit@@HH@Z		; PUF_isCombatTeam
EXTRN	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z:PROC ; CvUnit::isInvisible
EXTRN	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z:PROC ; CvUnit::getCombatOwner
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isCombatTeam@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
?PUF_isCombatTeam@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isCombatTeam, COMDAT

; 710  : {

	push	esi

; 711  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 712  : 	CvAssertMsg(iData2 != -1, "Invalid data argument, should be >= 0");
; 713  : 
; 714  : 	return (GET_PLAYER(pUnit->getCombatOwner((TeamTypes)iData2, *(pUnit->plot()))).getTeam() == iData1 && !pUnit->isInvisible((TeamTypes)iData2, false, false));

	mov	esi, DWORD PTR _pUnit$[esp]
	push	edi
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	edi, DWORD PTR _iData2$[esp+4]
	push	eax
	push	edi
	mov	ecx, esi
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN11@PUF_isComb
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN12@PUF_isComb
$LN11@PUF_isComb:
	or	eax, -1
$LN12@PUF_isComb:
	cmp	eax, DWORD PTR _iData1$[esp+4]
	jne	SHORT $LN3@PUF_isComb
	push	0
	push	0
	push	edi
	mov	ecx, esi
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	jne	SHORT $LN3@PUF_isComb
	pop	edi
	mov	eax, 1
	pop	esi

; 715  : }

	ret	0
$LN3@PUF_isComb:
	pop	edi

; 711  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 712  : 	CvAssertMsg(iData2 != -1, "Invalid data argument, should be >= 0");
; 713  : 
; 714  : 	return (GET_PLAYER(pUnit->getCombatOwner((TeamTypes)iData2, *(pUnit->plot()))).getTeam() == iData1 && !pUnit->isInvisible((TeamTypes)iData2, false, false));

	xor	eax, eax
	pop	esi

; 715  : }

	ret	0
?PUF_isCombatTeam@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isCombatTeam
_TEXT	ENDS
PUBLIC	?PUF_isOtherPlayer@@YA_NPBVCvUnit@@HH@Z		; PUF_isOtherPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isOtherPlayer@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isOtherPlayer@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isOtherPlayer, COMDAT

; 719  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 720  : 	return (pUnit->getOwner() != iData1);

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	mov	edx, DWORD PTR [ecx+40]
	xor	eax, eax
	cmp	edx, DWORD PTR _iData1$[esp-4]
	setne	al

; 721  : }

	ret	0
?PUF_isOtherPlayer@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isOtherPlayer
_TEXT	ENDS
PUBLIC	?PUF_isOtherTeam@@YA_NPBVCvUnit@@HH@Z		; PUF_isOtherTeam
EXTRN	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z:PROC ; CvUnit::canCoexistWithEnemyUnit
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isOtherTeam@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isOtherTeam@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isOtherTeam, COMDAT

; 725  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 726  : 	TeamTypes eTeam = GET_PLAYER((PlayerTypes)iData1).getTeam();

	mov	eax, DWORD PTR _iData1$[esp-4]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	push	esi
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN10@PUF_isOthe
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN11@PUF_isOthe
$LN10@PUF_isOthe:
	or	esi, -1
$LN11@PUF_isOthe:

; 727  : 	if(pUnit->canCoexistWithEnemyUnit(eTeam))

	mov	edi, DWORD PTR _pUnit$[esp+4]
	push	esi
	mov	ecx, edi
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	test	al, al
	je	SHORT $LN1@PUF_isOthe
	pop	edi

; 728  : 	{
; 729  : 		return false;

	xor	al, al
	pop	esi

; 733  : }

	ret	0
$LN1@PUF_isOthe:

; 730  : 	}
; 731  : 
; 732  : 	return (pUnit->getTeam() != eTeam);

	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	xor	edx, edx
	cmp	eax, esi
	setne	dl
	pop	edi
	mov	al, dl
	pop	esi

; 733  : }

	ret	0
?PUF_isOtherTeam@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isOtherTeam
_TEXT	ENDS
PUBLIC	?PUF_isEnemy@@YA_NPBVCvUnit@@HH@Z		; PUF_isEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isEnemy@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
?PUF_isEnemy@@YA_NPBVCvUnit@@HH@Z PROC			; PUF_isEnemy, COMDAT

; 737  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 738  : 	CvAssertMsg(iData2 != -1, "Invalid data argument, should be >= 0");
; 739  : 
; 740  : 	TeamTypes eOtherTeam = GET_PLAYER((PlayerTypes)iData1).getTeam();

	mov	eax, DWORD PTR _iData1$[esp-4]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	push	esi
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN12@PUF_isEnem
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN13@PUF_isEnem
$LN12@PUF_isEnem:
	or	esi, -1
$LN13@PUF_isEnem:
	push	ebx

; 741  : 	TeamTypes eOurTeam = GET_PLAYER(pUnit->getCombatOwner(eOtherTeam, *(pUnit->plot()))).getTeam();

	mov	ebx, DWORD PTR _pUnit$[esp+8]
	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	push	esi
	mov	ecx, ebx
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@PUF_isEnem
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN24@PUF_isEnem
$LN23@PUF_isEnem:
	or	edi, -1
$LN24@PUF_isEnem:

; 742  : 
; 743  : 	if(pUnit->canCoexistWithEnemyUnit(eOtherTeam))

	push	esi
	mov	ecx, ebx
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	pop	ebx
	test	al, al
	je	SHORT $LN1@PUF_isEnem
	pop	edi

; 744  : 	{
; 745  : 		return false;

	xor	al, al
	pop	esi

; 749  : }

	ret	0
$LN1@PUF_isEnem:

; 746  : 	}
; 747  : 
; 748  : 	return (iData2 ? eOtherTeam != eOurTeam : atWar(eOtherTeam, eOurTeam));

	cmp	DWORD PTR _iData2$[esp+4], 0
	je	SHORT $LN4@PUF_isEnem
	xor	eax, eax
	cmp	esi, edi
	pop	edi
	setne	al
	pop	esi

; 749  : }

	ret	0
$LN4@PUF_isEnem:

; 746  : 	}
; 747  : 
; 748  : 	return (iData2 ? eOtherTeam != eOurTeam : atWar(eOtherTeam, eOurTeam));

	cmp	esi, -1
	je	SHORT $LN28@PUF_isEnem
	cmp	edi, -1
	je	SHORT $LN28@PUF_isEnem
	imul	esi, 2984				; 00000ba8H
	add	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, esi
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	pop	edi
	movzx	eax, al
	pop	esi

; 749  : }

	ret	0

; 746  : 	}
; 747  : 
; 748  : 	return (iData2 ? eOtherTeam != eOurTeam : atWar(eOtherTeam, eOurTeam));

$LN28@PUF_isEnem:
	xor	al, al
	pop	edi
	movzx	eax, al
	pop	esi

; 749  : }

	ret	0
?PUF_isEnemy@@YA_NPBVCvUnit@@HH@Z ENDP			; PUF_isEnemy
_TEXT	ENDS
PUBLIC	?PUF_isVisible@@YA_NPBVCvUnit@@HH@Z		; PUF_isVisible
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isVisible@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isVisible@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isVisible, COMDAT

; 753  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 754  : 	return !(pUnit->isInvisible(GET_PLAYER((PlayerTypes)iData1).getTeam(), false));

	mov	eax, DWORD PTR _iData1$[esp-4]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN9@PUF_isVisi
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN10@PUF_isVisi
$LN9@PUF_isVisi:
	or	eax, -1
$LN10@PUF_isVisi:
	mov	ecx, DWORD PTR _pUnit$[esp-4]
	push	1
	push	0
	push	eax
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 755  : }

	ret	0
?PUF_isVisible@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isVisible
_TEXT	ENDS
PUBLIC	?PUF_isVisibleDebug@@YA_NPBVCvUnit@@HH@Z	; PUF_isVisibleDebug
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isVisibleDebug@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isVisibleDebug@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isVisibleDebug, COMDAT

; 759  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 760  : 	return !(pUnit->isInvisible(GET_PLAYER((PlayerTypes)iData1).getTeam(), true));

	mov	eax, DWORD PTR _iData1$[esp-4]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN9@PUF_isVisi@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN10@PUF_isVisi@2
$LN9@PUF_isVisi@2:
	or	eax, -1
$LN10@PUF_isVisi@2:
	mov	ecx, DWORD PTR _pUnit$[esp-4]
	push	1
	push	1
	push	eax
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 761  : }

	ret	0
?PUF_isVisibleDebug@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isVisibleDebug
_TEXT	ENDS
PUBLIC	?PUF_canSiege@@YA_NPBVCvUnit@@HH@Z		; PUF_canSiege
EXTRN	?canSiege@CvUnit@@QBE_NW4TeamTypes@@@Z:PROC	; CvUnit::canSiege
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_canSiege@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_canSiege@@YA_NPBVCvUnit@@HH@Z PROC			; PUF_canSiege, COMDAT

; 765  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 766  : 	return pUnit->canSiege(GET_PLAYER((PlayerTypes)iData1).getTeam());

	mov	eax, DWORD PTR _iData1$[esp-4]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN9@PUF_canSie
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _pUnit$[esp-4]
	push	eax
	call	?canSiege@CvUnit@@QBE_NW4TeamTypes@@@Z	; CvUnit::canSiege

; 767  : }

	ret	0

; 765  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 766  : 	return pUnit->canSiege(GET_PLAYER((PlayerTypes)iData1).getTeam());

$LN9@PUF_canSie:
	mov	ecx, DWORD PTR _pUnit$[esp-4]
	or	eax, -1
	push	eax
	call	?canSiege@CvUnit@@QBE_NW4TeamTypes@@@Z	; CvUnit::canSiege

; 767  : }

	ret	0
?PUF_canSiege@@YA_NPBVCvUnit@@HH@Z ENDP			; PUF_canSiege
_TEXT	ENDS
PUBLIC	?PUF_isPotentialEnemy@@YA_NPBVCvUnit@@HH@Z	; PUF_isPotentialEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_isPotentialEnemy@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
?PUF_isPotentialEnemy@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isPotentialEnemy, COMDAT

; 771  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 772  : 	CvAssertMsg(iData2 != -1, "Invalid data argument, should be >= 0");
; 773  : 
; 774  : 	TeamTypes eOtherTeam = GET_PLAYER((PlayerTypes)iData1).getTeam();

	mov	eax, DWORD PTR _iData1$[esp-4]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	push	ebx
	push	esi
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN12@PUF_isPote
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN13@PUF_isPote
$LN12@PUF_isPote:
	or	esi, -1
$LN13@PUF_isPote:

; 775  : 	TeamTypes eOurTeam = GET_PLAYER(pUnit->getCombatOwner(eOtherTeam, *(pUnit->plot()))).getTeam();

	mov	edi, DWORD PTR _pUnit$[esp+8]
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	push	esi
	mov	ecx, edi
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@PUF_isPote
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN24@PUF_isPote
$LN23@PUF_isPote:
	or	ebx, -1
$LN24@PUF_isPote:

; 776  : 
; 777  : 	if(pUnit->canCoexistWithEnemyUnit(eOtherTeam))

	push	esi
	mov	ecx, edi
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	test	al, al
	je	SHORT $LN1@PUF_isPote
	pop	edi
	pop	esi

; 778  : 	{
; 779  : 		return false;

	xor	al, al
	pop	ebx

; 782  : }

	ret	0
$LN1@PUF_isPote:

; 780  : 	}
; 781  : 	return (iData2 ? eOtherTeam != eOurTeam : isPotentialEnemy(eOtherTeam, eOurTeam));

	xor	eax, eax
	cmp	DWORD PTR _iData2$[esp+8], eax
	je	SHORT $LN2@PUF_isPote
	cmp	esi, ebx
	setne	al
$LN2@PUF_isPote:
	pop	edi
	pop	esi
	pop	ebx

; 782  : }

	ret	0
?PUF_isPotentialEnemy@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isPotentialEnemy
_TEXT	ENDS
PUBLIC	?PUF_canDeclareWar@@YA_NPBVCvUnit@@HH@Z		; PUF_canDeclareWar
EXTRN	?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::canDeclareWar
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_canDeclareWar@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
?PUF_canDeclareWar@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_canDeclareWar, COMDAT

; 786  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 787  : 	CvAssertMsg(iData2 != -1, "Invalid data argument, should be >= 0");
; 788  : 
; 789  : 	TeamTypes eOtherTeam = GET_PLAYER((PlayerTypes)iData1).getTeam();

	mov	eax, DWORD PTR _iData1$[esp-4]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	push	ebx
	push	esi
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN12@PUF_canDec
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN13@PUF_canDec
$LN12@PUF_canDec:
	or	esi, -1
$LN13@PUF_canDec:

; 790  : 	TeamTypes eOurTeam = GET_PLAYER(pUnit->getCombatOwner(eOtherTeam, *(pUnit->plot()))).getTeam();

	mov	edi, DWORD PTR _pUnit$[esp+8]
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	push	esi
	mov	ecx, edi
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@PUF_canDec
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN24@PUF_canDec
$LN23@PUF_canDec:
	or	ebx, -1
$LN24@PUF_canDec:

; 791  : 
; 792  : 	if(pUnit->canCoexistWithEnemyUnit(eOtherTeam))

	push	esi
	mov	ecx, edi
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	test	al, al
	je	SHORT $LN1@PUF_canDec
$LN30@PUF_canDec:
	pop	edi
	pop	esi

; 793  : 	{
; 794  : 		return false;

	xor	al, al
	pop	ebx

; 798  : }

	ret	0
$LN1@PUF_canDec:

; 795  : 	}
; 796  : 
; 797  : 	return (iData2 ? false : GET_TEAM(eOtherTeam).canDeclareWar(eOurTeam));

	cmp	DWORD PTR _iData2$[esp+8], 0
	jne	SHORT $LN30@PUF_canDec
	imul	esi, 2984				; 00000ba8H
	add	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebx
	mov	ecx, esi
	call	?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::canDeclareWar
	pop	edi
	pop	esi
	pop	ebx

; 798  : }

	ret	0
?PUF_canDeclareWar@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_canDeclareWar
_TEXT	ENDS
PUBLIC	?PUF_canDefendEnemy@@YA_NPBVCvUnit@@HH@Z	; PUF_canDefendEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_canDefendEnemy@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
?PUF_canDefendEnemy@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_canDefendEnemy, COMDAT

; 811  : {

	push	esi

; 812  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 813  : 	CvAssertMsg(iData2 != -1, "Invalid data argument, should be >= 0");
; 814  : 	return (PUF_canDefend(pUnit, iData1, iData2) && PUF_isEnemy(pUnit, iData1, iData2));

	mov	esi, DWORD PTR _pUnit$[esp]
	push	0
	mov	ecx, esi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	je	SHORT $LN3@PUF_canDef
	mov	eax, DWORD PTR _iData2$[esp]
	mov	ecx, DWORD PTR _iData1$[esp]
	push	eax
	push	ecx
	push	esi
	call	?PUF_isEnemy@@YA_NPBVCvUnit@@HH@Z	; PUF_isEnemy
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN3@PUF_canDef
	mov	eax, 1
	pop	esi

; 815  : }

	ret	0
$LN3@PUF_canDef:

; 812  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 813  : 	CvAssertMsg(iData2 != -1, "Invalid data argument, should be >= 0");
; 814  : 	return (PUF_canDefend(pUnit, iData1, iData2) && PUF_isEnemy(pUnit, iData1, iData2));

	xor	eax, eax
	pop	esi

; 815  : }

	ret	0
?PUF_canDefendEnemy@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_canDefendEnemy
_TEXT	ENDS
PUBLIC	?PUF_canDefendPotentialEnemy@@YA_NPBVCvUnit@@HH@Z ; PUF_canDefendPotentialEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?PUF_canDefendPotentialEnemy@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
?PUF_canDefendPotentialEnemy@@YA_NPBVCvUnit@@HH@Z PROC	; PUF_canDefendPotentialEnemy, COMDAT

; 818  : {

	push	esi

; 819  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 820  : 	return (PUF_canDefend(pUnit, iData1, iData2) && PUF_isPotentialEnemy(pUnit, iData1, iData2));

	mov	esi, DWORD PTR _pUnit$[esp]
	push	0
	mov	ecx, esi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	je	SHORT $LN3@PUF_canDef@2
	mov	eax, DWORD PTR _iData2$[esp]
	mov	ecx, DWORD PTR _iData1$[esp]
	push	eax
	push	ecx
	push	esi
	call	?PUF_isPotentialEnemy@@YA_NPBVCvUnit@@HH@Z ; PUF_isPotentialEnemy
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN3@PUF_canDef@2
	mov	eax, 1
	pop	esi

; 821  : }

	ret	0
$LN3@PUF_canDef@2:

; 819  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 820  : 	return (PUF_canDefend(pUnit, iData1, iData2) && PUF_isPotentialEnemy(pUnit, iData1, iData2));

	xor	eax, eax
	pop	esi

; 821  : }

	ret	0
?PUF_canDefendPotentialEnemy@@YA_NPBVCvUnit@@HH@Z ENDP	; PUF_canDefendPotentialEnemy
_TEXT	ENDS
PUBLIC	?getTurnYearForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z ; getTurnYearForGame
; Function compile flags: /Ogtpy
;	COMDAT ?getTurnYearForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z
_TEXT	SEGMENT
_iGameTurn$ = 8						; size = 4
_iStartYear$ = 12					; size = 4
_eCalendar$ = 16					; size = 4
_eSpeed$ = 20						; size = 4
?getTurnYearForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z PROC ; getTurnYearForGame, COMDAT

; 921  : 	return (getTurnMonthForGame(iGameTurn, iStartYear, eCalendar, eSpeed) / DB.Count("Months"));

	mov	eax, DWORD PTR _eSpeed$[esp-4]
	mov	ecx, DWORD PTR _eCalendar$[esp-4]
	mov	edx, DWORD PTR _iStartYear$[esp-4]
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	push	edi
	push	eax
	mov	eax, DWORD PTR _iGameTurn$[esp+8]
	push	ecx
	push	edx
	push	eax
	call	?getTurnMonthForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z ; getTurnMonthForGame
	add	esp, 16					; 00000010H
	push	1
	push	OFFSET $SG218602
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_?Count@Connection@Database@@QAEHPBD_N@Z
	mov	ecx, eax
	mov	eax, edi
	cdq
	pop	edi
	idiv	ecx
	pop	esi

; 922  : }

	ret	0
?getTurnYearForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z ENDP ; getTurnYearForGame
_TEXT	ENDS
END
