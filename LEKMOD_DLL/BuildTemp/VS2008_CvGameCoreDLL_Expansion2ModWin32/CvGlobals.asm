; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Cleanup (v1)\Lekmod Files\Lekmod DLL versions\v30\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvGlobals.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
_DATA	SEGMENT
_CIV5_XP2_DLL_VERSION DD FLAT:$SG226693
_DATA	ENDS
CONST	SEGMENT
$SG226693 DB	'1.0.0', 00H
	ORG $+2
$SG228460 DB	'SELECT Value from Defines where Name = ? LIMIT 1', 00H
	ORG $+3
$SG229207 DB	'Worlds', 00H
	ORG $+1
$SG229211 DB	'Climates', 00H
	ORG $+3
$SG229215 DB	'SeaLevels', 00H
	ORG $+2
$SG230472 DB	'GameCore.log', 00H
	ORG $+3
$SG230496 DB	'TargetingPathLayer', 00H
	ORG $+1
$SG230495 DB	'ArtifactLayer', 00H
	ORG $+2
$SG230494 DB	'TacticalAnalysisLayer', 00H
	ORG $+2
$SG230493 DB	'DangerLayer', 00H
$SG230492 DB	'RevealedLayer', 00H
	ORG $+2
$SG230491 DB	'VisibilityLayer', 00H
$SG230490 DB	'SettlerSiteEvaluationLayer', 00H
	ORG $+1
$SG230489 DB	'StartSiteEvaluationLayer', 00H
	ORG $+3
$SG230504 DB	'SettlerSiteEvaluationLayer', 00H
	ORG $+1
$SG230506 DB	'ArtifactLayer', 00H
	ORG $+2
$SG230518 DB	'StartSiteEvaluationLayer', 00H
	ORG $+3
$SG230521 DB	'%d', 00H
	ORG $+1
$SG230524 DB	'SettlerSiteEvaluationLayer', 00H
	ORG $+1
$SG230528 DB	'%d', 00H
	ORG $+1
$SG230531 DB	'VisibilityLayer', 00H
$SG230536 DB	'Vis %d', 00H
	ORG $+1
$SG230539 DB	'RevealedLayer', 00H
	ORG $+2
$SG230544 DB	'Rev %d', 00H
	ORG $+1
$SG230547 DB	'DangerLayer', 00H
$SG230551 DB	'%d', 00H
	ORG $+1
$SG230554 DB	'ArtifactLayer', 00H
	ORG $+2
$SG230557 DB	'%d', 00H
	ORG $+1
$SG230560 DB	'TacticalAnalysisLayer', 00H
	ORG $+2
$SG230566 DB	'X Terrain', 00H
	ORG $+2
$SG230569 DB	'X Territory', 00H
$SG230572 DB	'R ', 00H
	ORG $+1
$SG230574 DB	'V ', 00H
	ORG $+1
$SG230576 DB	'A+ ', 00H
$SG230579 DB	'N ', 00H
	ORG $+1
$SG230582 DB	'A ', 00H
	ORG $+1
$SG230584 DB	'E ', 00H
	ORG $+1
$SG230586 DB	'T ', 00H
	ORG $+1
$SG230588 DB	'F ', 00H
	ORG $+1
$SG230590 DB	'D ', 00H
	ORG $+1
$SG230598 DB	'%d ', 00H
$SG230602 DB	'[S%d] ', 00H
	ORG $+1
$SG230604 DB	'[%d] ', 00H
	ORG $+2
$SG230605 DB	'%s', 00H
	ORG $+1
$SG230608 DB	'TargetingPathLayer', 00H
	ORG $+1
$SG230611 DB	'%d', 00H
	ORG $+1
$SG230616 DB	'NEW_SCORE_CITY_MULTIPLIER', 00H
	ORG $+2
$SG230617 DB	'NEW_SCORE_POPULATION_MULTIPLIER', 00H
$SG230618 DB	'NEW_SCORE_WONDER_MULTIPLIER', 00H
$SG230619 DB	'NEW_SCORE_TECH_MULTIPLIER', 00H
	ORG $+2
$SG230620 DB	'NEW_SCORE_FUTURE_TECH_MULTIPLIER', 00H
	ORG $+3
$SG230621 DB	'NEW_SCORE_POLICY_MULTIPLIER', 00H
$SG230622 DB	'NEW_SCORE_GREAT_WORK_MULTIPLIER', 00H
$SG230623 DB	'NEW_SCORE_BELIEF_MULTIPLIER', 00H
$SG230624 DB	'AI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD', 00H
	ORG $+2
$SG230625 DB	'INITIAL_AI_CITY_PRODUCTION', 00H
	ORG $+1
$SG230626 DB	'AI_CAN_DISBAND_UNITS', 00H
	ORG $+3
$SG230627 DB	'AI_SHOULDNT_MANAGE_PLOT_ASSIGNMENT', 00H
	ORG $+1
$SG230628 DB	'POLICY_WEIGHT_PROPAGATION_PERCENT', 00H
	ORG $+2
$SG230629 DB	'POLICY_WEIGHT_PROPAGATION_LEVELS', 00H
	ORG $+3
$SG230630 DB	'POLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH', 00H
	ORG $+2
$SG230631 DB	'TECH_WEIGHT_PROPAGATION_PERCENT', 00H
$SG230632 DB	'TECH_WEIGHT_PROPAGATION_LEVELS', 00H
	ORG $+1
$SG230633 DB	'TECH_PRIORITY_UNIQUE_ITEM', 00H
	ORG $+2
$SG230634 DB	'TECH_PRIORITY_MAYA_CALENDAR_BONUS', 00H
	ORG $+2
$SG230635 DB	'AI_VALUE_OF_YIELD_GOLD', 00H
	ORG $+1
$SG230636 DB	'AI_VALUE_OF_YIELD_PRODUCTION', 00H
	ORG $+3
$SG230637 DB	'AI_VALUE_OF_YIELD_SCIENCE', 00H
	ORG $+2
$SG230638 DB	'DEFAULT_FLAVOR_VALUE', 00H
	ORG $+3
$SG230639 DB	'PERSONALITY_FLAVOR_MAX_VALUE', 00H
	ORG $+3
$SG230640 DB	'PERSONALITY_FLAVOR_MIN_VALUE', 00H
	ORG $+3
$SG230641 DB	'FLAVOR_MIN_VALUE', 00H
	ORG $+3
$SG230642 DB	'FLAVOR_MAX_VALUE', 00H
	ORG $+3
$SG230643 DB	'FLAVOR_RANDOMIZATION_RANGE', 00H
	ORG $+1
$SG230644 DB	'FLAVOR_EXPANDGROW_COEFFICIENT', 00H
	ORG $+2
$SG230645 DB	'AI_GRAND_STRATEGY_NUM_TURNS_STRATEGY_MUST_BE_ACTIVE', 00H
$SG230646 DB	'AI_GS_RAND_ROLL', 00H
$SG230647 DB	'AI_GRAND_STRATEGY_CURRENT_STRATEGY_WEIGHT', 00H
	ORG $+2
$SG230648 DB	'AI_GRAND_STRATEGY_GUESS_NO_CLUE_WEIGHT', 00H
	ORG $+1
$SG230649 DB	'AI_GRAND_STRATEGY_GUESS_POSITIVE_THRESHOLD', 00H
	ORG $+1
$SG230650 DB	'AI_GRAND_STRATEGY_GUESS_LIKELY_THRESHOLD', 00H
	ORG $+3
$SG230651 DB	'AI_GRAND_STRATEGY_OTHER_PLAYERS_GS_MULTIPLIER', 00H
	ORG $+2
$SG230652 DB	'AI_GS_CONQUEST_NOBODY_MET_FIRST_TURN', 00H
	ORG $+3
$SG230653 DB	'AI_GRAND_STRATEGY_CONQUEST_NOBODY_MET_WEIGHT', 00H
	ORG $+3
$SG230654 DB	'AI_GRAND_STRATEGY_CONQUEST_AT_WAR_WEIGHT', 00H
	ORG $+3
$SG230655 DB	'AI_GS_CONQUEST_MILITARY_STRENGTH_FIRST_TURN', 00H
$SG230656 DB	'AI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER', 00H
	ORG $+2
$SG230657 DB	'AI_GRAND_STRATEGY_CONQUEST_CRAMPED_WEIGHT', 00H
	ORG $+2
$SG230658 DB	'AI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_ATTACKED', 00H
	ORG $+3
$SG230659 DB	'AI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_CONQUERED', 00H
	ORG $+2
$SG230660 DB	'AI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_ATTACKED', 00H
	ORG $+3
$SG230661 DB	'AI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_CONQUERED', 00H
	ORG $+2
$SG230662 DB	'AI_GS_CULTURE_RATIO_MULTIPLIER', 00H
	ORG $+1
$SG230663 DB	'AI_GS_TOURISM_RATIO_MULTIPLIER', 00H
	ORG $+1
$SG230664 DB	'AI_GS_CULTURE_AHEAD_WEIGHT', 00H
	ORG $+1
$SG230665 DB	'AI_GS_CULTURE_TOURISM_AHEAD_WEIGHT', 00H
	ORG $+1
$SG230666 DB	'AI_GS_CULTURE_INFLUENTIAL_CIV_MOD', 00H
	ORG $+2
$SG230667 DB	'AI_GRAND_STRATEGY_UN_EACH_MINOR_ATTACKED_WEIGHT', 00H
$SG230668 DB	'AI_GS_UN_SECURED_VOTE_MOD', 00H
	ORG $+2
$SG230669 DB	'AI_GS_SS_HAS_APOLLO_PROGRAM', 00H
$SG230670 DB	'AI_GS_SS_TECH_PROGRESS_MOD', 00H
	ORG $+1
$SG230671 DB	'AI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT', 00H
	ORG $+2
$SG230672 DB	'AI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR', 00H
	ORG $+1
$SG230673 DB	'AI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR', 00H
$SG230674 DB	'AI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED', 00H
	ORG $+1
$SG230675 DB	'AI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT', 00H
	ORG $+3
$SG230676 DB	'AI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO', 00H
$SG230677 DB	'AI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT', 00H
	ORG $+2
$SG230678 DB	'AI_STRATEGY_AREA_IS_FULL_PERCENT', 00H
	ORG $+3
$SG230679 DB	'AI_STRATEGY_MINIMUM_SETTLE_FERTILITY', 00H
	ORG $+3
$SG230680 DB	'AI_BUY_PLOT_TEST_PROBES', 00H
$SG230681 DB	'AI_PLOT_VALUE_STRATEGIC_RESOURCE', 00H
	ORG $+3
$SG230682 DB	'AI_PLOT_VALUE_LUXURY_RESOURCE', 00H
	ORG $+2
$SG230683 DB	'AI_PLOT_VALUE_SPECIALIZATION_MULTIPLIER', 00H
$SG230684 DB	'AI_PLOT_VALUE_YIELD_MULTIPLIER', 00H
	ORG $+1
$SG230685 DB	'AI_PLOT_VALUE_DEFICIENT_YIELD_MULTIPLIER', 00H
	ORG $+3
$SG230686 DB	'AI_PLOT_VALUE_FIERCE_DISPUTE', 00H
	ORG $+3
$SG230687 DB	'AI_PLOT_VALUE_STRONG_DISPUTE', 00H
	ORG $+3
$SG230688 DB	'AI_PLOT_VALUE_WEAK_DISPUTE', 00H
	ORG $+1
$SG230689 DB	'AI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE', 00H
$SG230690 DB	'AI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM', 00H
	ORG $+2
$SG230691 DB	'AI_GOLD_PRIORITY_UPGRADE_BASE', 00H
	ORG $+2
$SG230692 DB	'AI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT', 00H
	ORG $+2
$SG230693 DB	'AI_GOLD_PRIORITY_DIPLOMACY_BASE', 00H
$SG230694 DB	'AI_GOLD_PRIORITY_DIPLOMACY_PER_FLAVOR_POINT', 00H
$SG230695 DB	'AI_GOLD_PRIORITY_UNIT', 00H
	ORG $+2
$SG230696 DB	'AI_GOLD_PRIORITY_DEFENSIVE_BUILDING', 00H
$SG230697 DB	'AI_GOLD_PRIORITY_BUYOUT_CITY_STATE', 00H
	ORG $+1
$SG230698 DB	'BUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD', 00H
	ORG $+2
$SG230699 DB	'BUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION', 00H
$SG230700 DB	'BUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD', 00H
	ORG $+2
$SG230701 DB	'BUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE', 00H
	ORG $+3
$SG230702 DB	'BUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE', 00H
	ORG $+3
$SG230703 DB	'BUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE', 00H
	ORG $+3
$SG230704 DB	'BUILDER_TASKING_IMPROVE_RESOURCE_TENDENCY', 00H
	ORG $+2
$SG230705 DB	'BUILDER_TASKING_BUILD_ROUTE_TENDENCY', 00H
	ORG $+3
$SG230706 DB	'BUILDER_TASKING_DIRECTIVES_TO_EVALUATE', 00H
	ORG $+1
$SG230707 DB	'BUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS', 00H
$SG230708 DB	'BUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS', 00H
	ORG $+3
$SG230709 DB	'BUILDER_TASKING_BASELINE_BUILD_ROUTES', 00H
	ORG $+2
$SG230710 DB	'BUILDER_TASKING_BASELINE_REPAIR', 00H
$SG230711 DB	'BUILDER_TASKING_BASELINE_SCRUB_FALLOUT', 00H
	ORG $+1
$SG230712 DB	'BUILDER_TASKING_BASELINE_ADDS_CULTURE', 00H
	ORG $+2
$SG230713 DB	'AI_MILITARY_THREAT_WEIGHT_MINOR', 00H
$SG230714 DB	'AI_MILITARY_THREAT_WEIGHT_MAJOR', 00H
$SG230715 DB	'AI_MILITARY_THREAT_WEIGHT_SEVERE', 00H
	ORG $+3
$SG230716 DB	'AI_MILITARY_THREAT_WEIGHT_CRITICAL', 00H
	ORG $+1
$SG230717 DB	'AI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS', 00H
	ORG $+1
$SG230718 DB	'AI_STRATEGY_MILITARY_RESERVE_PERCENTAGE', 00H
$SG230719 DB	'AI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL', 00H
	ORG $+1
$SG230720 DB	'AI_MILITARY_BARBARIANS_FOR_MINOR_THREAT', 00H
$SG230721 DB	'AI_MILITARY_IGNORE_BAD_ODDS', 00H
$SG230722 DB	'AI_MILITARY_RECAPTURING_OWN_CITY', 00H
	ORG $+3
$SG230723 DB	'AI_MILITARY_CAPTURING_ORIGINAL_CAPITAL', 00H
	ORG $+1
$SG230724 DB	'AI_CITY_SPECIALIZATION_EARLIEST_TURN', 00H
	ORG $+3
$SG230725 DB	'AI_CITY_SPECIALIZATION_REEVALUATION_INTERVAL', 00H
	ORG $+3
$SG230726 DB	'AI_CITY_SPECIALIZATION_GENERAL_ECONOMIC_WEIGHT', 00H
	ORG $+1
$SG230727 DB	'AI_CITY_SPECIALIZATION_FOOD_WEIGHT_FLAVOR_EXPANSION', 00H
$SG230728 DB	'AI_CITY_SPECIALIZATION_FOOD_WEIGHT_PERCENT_CONTINENT_UNO'
	DB	'WNED', 00H
	ORG $+3
$SG230729 DB	'AI_CITY_SPECIALIZATION_FOOD_WEIGHT_NUM_CITIES', 00H
	ORG $+2
$SG230730 DB	'AI_CITY_SPECIALIZATION_FOOD_WEIGHT_NUM_SETTLERS', 00H
$SG230731 DB	'AI_CITY_SPECIALIZATION_FOOD_WEIGHT_EARLY_EXPANSION', 00H
	ORG $+5
$SG230732 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_OPERATIONAL_UNI'
	DB	'TS_REQUESTED', 00H
	ORG $+3
$SG230733 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_CIVS_AT_WAR_WIT'
	DB	'H', 00H
	ORG $+2
$SG230734 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_WAR_MOBILIZATIO'
	DB	'N', 00H
	ORG $+2
$SG230735 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_EMPIRE_DEFENSE', 00H
$SG230736 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_EMPIRE_DEFENSE_'
	DB	'CRITICAL', 00H
	ORG $+3
$SG230737 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_CAPITAL_THREAT', 00H
$SG230738 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_NEED_NAVAL_UNIT'
	DB	'S', 00H
	ORG $+2
$SG230739 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_NEED_NAVAL_UNIT'
	DB	'S_CRITICAL', 00H
	ORG $+1
$SG230740 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_FLAVOR_WONDER', 00H
	ORG $+1
$SG230741 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_FLAVOR_SPACESHI'
	DB	'P', 00H
	ORG $+2
$SG230742 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_TRAINING_PER_OFFENSE', 00H
	ORG $+1
$SG230743 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_TRAINING_PER_PERSONALI'
	DB	'TY', 00H
	ORG $+1
$SG230744 DB	'AI_CITY_SPECIALIZATION_GOLD_WEIGHT_FLAVOR_GOLD', 00H
	ORG $+1
$SG230745 DB	'AI_CITY_SPECIALIZATION_GOLD_WEIGHT_LAND_DISPUTE', 00H
$SG230746 DB	'AI_CITY_SPECIALIZATION_SCIENCE_WEIGHT_FLAVOR_SCIENCE', 00H
	ORG $+3
$SG230747 DB	'AI_CITY_SPECIALIZATION_SCIENCE_WEIGHT_FLAVOR_SPACESHIP', 00H
	ORG $+1
$SG230748 DB	'AI_CITY_SPECIALIZATION_YIELD_WEIGHT_FIRST_RING', 00H
	ORG $+1
$SG230749 DB	'AI_CITY_SPECIALIZATION_YIELD_WEIGHT_SECOND_RING', 00H
$SG230750 DB	'AI_CITY_SPECIALIZATION_YIELD_WEIGHT_THIRD_RING', 00H
	ORG $+1
$SG230751 DB	'AI_CITY_SPECIALIZATION_YIELD_NUM_TILES_CONSIDERED', 00H
	ORG $+2
$SG230752 DB	'AI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD', 00H
	ORG $+3
$SG230753 DB	'AI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD', 00H
	ORG $+2
$SG230754 DB	'AI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD', 00H
	ORG $+3
$SG230755 DB	'AI_CITYSTRATEGY_NEED_TILE_IMPROVERS_CITY_THRESHOLD', 00H
	ORG $+1
$SG230756 DB	'AI_CITYSTRATEGY_NEED_TILE_IMPROVERS_WORKER_MOD', 00H
	ORG $+1
$SG230757 DB	'AI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN', 00H
	ORG $+1
$SG230758 DB	'AI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE', 00H
	ORG $+3
$SG230759 DB	'AI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD', 00H
	ORG $+3
$SG230760 DB	'AI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION', 00H
	ORG $+1
$SG230761 DB	'AI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD', 00H
	ORG $+3
$SG230762 DB	'AI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE', 00H
$SG230763 DB	'AI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT', 00H
	ORG $+1
$SG230764 DB	'AI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER', 00H
	ORG $+3
$SG230765 DB	'AI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT', 00H
	ORG $+2
$SG230766 DB	'AI_CITIZEN_VALUE_FOOD', 00H
	ORG $+2
$SG230767 DB	'AI_CITIZEN_VALUE_PRODUCTION', 00H
$SG230768 DB	'AI_CITIZEN_VALUE_GOLD', 00H
	ORG $+2
$SG230769 DB	'AI_CITIZEN_VALUE_SCIENCE', 00H
	ORG $+3
$SG230770 DB	'AI_CITIZEN_VALUE_CULTURE', 00H
	ORG $+3
$SG230771 DB	'AI_CITIZEN_VALUE_FAITH', 00H
	ORG $+1
$SG230772 DB	'AI_CITIZEN_FOOD_MOD_SIZE_CUTOFF', 00H
$SG230773 DB	'AI_CITIZEN_FOOD_MOD_SIZE_EXPONENT', 00H
	ORG $+2
$SG230774 DB	'AI_CITIZEN_MOD_FOOD_DEFICIT', 00H
$SG230775 DB	'AI_CITIZEN_MOD_PRODUCTION_DEFICIT', 00H
	ORG $+2
$SG230776 DB	'AI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE', 00H
	ORG $+1
$SG230777 DB	'AI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE', 00H
$SG230778 DB	'AI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE', 00H
	ORG $+2
$SG230779 DB	'AI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE', 00H
	ORG $+2
$SG230780 DB	'AI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER', 00H
	ORG $+3
$SG230781 DB	'AI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION', 00H
$SG230782 DB	'AI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER', 00H
	ORG $+3
$SG230783 DB	'AI_TACTICAL_MAP_DOMINANCE_PERCENTAGE', 00H
	ORG $+3
$SG230784 DB	'AI_TACTICAL_MAP_TEMP_ZONE_RADIUS', 00H
	ORG $+3
$SG230785 DB	'AI_TACTICAL_MAP_TEMP_ZONE_TURNS', 00H
$SG230786 DB	'AI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS', 00H
	ORG $+1
$SG230787 DB	'AI_TACTICAL_RECRUIT_RANGE', 00H
	ORG $+2
$SG230788 DB	'AI_TACTICAL_REPOSITION_RANGE', 00H
	ORG $+3
$SG230789 DB	'AI_TACTICAL_OVERKILL_PERCENT', 00H
	ORG $+3
$SG230790 DB	'AI_TACTICAL_BARBARIAN_RELEASE_VARIATION', 00H
$SG230791 DB	'AI_TACTICAL_MOVE_PRIORITY_RANDOMNESS', 00H
	ORG $+3
$SG230792 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_CAPTURE_CITY', 00H
$SG230793 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_DAMAGE_CITY', 00H
	ORG $+1
$SG230794 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_HIGH_UNIT', 00H
	ORG $+3
$SG230795 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_MEDIUM_UNIT', 00H
	ORG $+1
$SG230796 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_LOW_UNIT', 00H
$SG230797 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_TO_SAFETY', 00H
	ORG $+3
$SG230798 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_HIGH_UNIT', 00H
$SG230799 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_MEDIUM_UNIT', 00H
	ORG $+2
$SG230800 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_LOW_UNIT', 00H
	ORG $+1
$SG230801 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_DESPERATE_ATTACK', 00H
$SG230802 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE', 00H
	ORG $+1
$SG230803 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_CITADEL', 00H
	ORG $+1
$SG230804 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_NEXT_TURN', 00H
	ORG $+3
$SG230805 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE', 00H
	ORG $+3
$SG230806 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_CIVILIAN_ATTACK', 00H
	ORG $+1
$SG230807 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_PASSIVE_MOVE', 00H
$SG230808 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_AGGRESSIVE_MOVE', 00H
	ORG $+1
$SG230809 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_CAMP_DEFENSE', 00H
$SG230810 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_ESCORT_CIVILIAN', 00H
	ORG $+1
$SG230811 DB	'AI_TACTICAL_BARBARIAN_PRIORITY_PLUNDER_TRADE_UNIT', 00H
	ORG $+2
$SG230812 DB	'AI_HOMELAND_MOVE_PRIORITY_RANDOMNESS', 00H
	ORG $+3
$SG230813 DB	'AI_HOMELAND_MAX_UPGRADE_MOVE_TURNS', 00H
	ORG $+1
$SG230814 DB	'AI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS', 00H
	ORG $+3
$SG230815 DB	'AI_HOMELAND_ESTIMATE_TURNS_DISTANCE', 00H
$SG230816 DB	'AI_HOMELAND_MOVE_PRIORITY_SETTLE', 00H
	ORG $+3
$SG230817 DB	'AI_HOMELAND_MOVE_PRIORITY_HEAL', 00H
	ORG $+1
$SG230818 DB	'AI_HOMELAND_MOVE_PRIORITY_TO_SAFETY', 00H
$SG230819 DB	'AI_HOMELAND_MOVE_PRIORITY_WORKER', 00H
	ORG $+3
$SG230820 DB	'AI_HOMELAND_MOVE_PRIORITY_WORKER_SEA', 00H
	ORG $+3
$SG230821 DB	'AI_HOMELAND_MOVE_PRIORITY_EXPLORE', 00H
	ORG $+2
$SG230822 DB	'AI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA', 00H
	ORG $+2
$SG230823 DB	'AI_HOMELAND_MOVE_PRIORITY_SENTRY', 00H
	ORG $+3
$SG230824 DB	'AI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE', 00H
	ORG $+3
$SG230825 DB	'AI_HOMELAND_MOVE_PRIORITY_GARRISON', 00H
	ORG $+1
$SG230826 DB	'AI_HOMELAND_MOVE_PRIORITY_PATROL', 00H
	ORG $+3
$SG230827 DB	'AI_HOMELAND_MOVE_PRIORITY_UPGRADE', 00H
	ORG $+2
$SG230828 DB	'AI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS', 00H
$SG230829 DB	'AI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE', 00H
	ORG $+2
$SG230830 DB	'AI_HOMELAND_MOVE_PRIORITY_WRITER', 00H
	ORG $+3
$SG230831 DB	'AI_HOMELAND_MOVE_PRIORITY_ARTIST', 00H
	ORG $+3
$SG230832 DB	'AI_HOMELAND_MOVE_PRIORITY_MUSICIAN', 00H
	ORG $+1
$SG230833 DB	'AI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH', 00H
	ORG $+2
$SG230834 DB	'AI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY', 00H
	ORG $+3
$SG230835 DB	'AI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON', 00H
	ORG $+1
$SG230836 DB	'AI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON', 00H
	ORG $+1
$SG230837 DB	'AI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION', 00H
	ORG $+1
$SG230838 DB	'AI_HOMELAND_MOVE_PRIORITY_MISSIONARY', 00H
	ORG $+3
$SG230839 DB	'AI_HOMELAND_MOVE_PRIORITY_INQUISITOR', 00H
	ORG $+3
$SG230840 DB	'AI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT', 00H
$SG230841 DB	'AI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART', 00H
	ORG $+3
$SG230842 DB	'AI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART', 00H
	ORG $+3
$SG230843 DB	'AI_HOMELAND_MOVE_PRIORITY_TREASURE', 00H
	ORG $+1
$SG230844 DB	'AI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT', 00H
	ORG $+3
$SG230845 DB	'AI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST', 00H
$SG230846 DB	'AI_HOMELAND_MOVE_PRIORITY_AIRLIFT', 00H
	ORG $+2
$SG230847 DB	'AI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT', 00H
	ORG $+1
$SG230848 DB	'AI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT', 00H
	ORG $+3
$SG230849 DB	'AI_DIPLO_LAND_DISPUTE_WEIGHT_WEAK', 00H
	ORG $+2
$SG230850 DB	'AI_DIPLO_LAND_DISPUTE_WEIGHT_STRONG', 00H
$SG230851 DB	'AI_DIPLO_LAND_DISPUTE_WEIGHT_FIERCE', 00H
$SG230852 DB	'MINOR_BULLY_GOLD', 00H
	ORG $+3
$SG230853 DB	'MINOR_FRIENDSHIP_RATE_MOD_MAXIMUM', 00H
	ORG $+2
$SG230854 DB	'MINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION', 00H
	ORG $+2
$SG230855 DB	'MINOR_FRIENDSHIP_DROP_PER_TURN', 00H
	ORG $+1
$SG230856 DB	'MINOR_FRIENDSHIP_DROP_PER_TURN_HOSTILE', 00H
	ORG $+1
$SG230857 DB	'MINOR_FRIENDSHIP_DROP_PER_TURN_AGGRESSOR', 00H
	ORG $+3
$SG230858 DB	'MINOR_FRIENDSHIP_DROP_DISHONOR_PLEDGE_TO_PROTECT', 00H
	ORG $+3
$SG230859 DB	'MINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS', 00H
	ORG $+3
$SG230860 DB	'MINOR_FRIENDSHIP_DROP_BULLY_GOLD_FAILURE', 00H
	ORG $+3
$SG230861 DB	'MINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS', 00H
	ORG $+1
$SG230862 DB	'MINOR_FRIENDSHIP_DROP_BULLY_WORKER_FAILURE', 00H
	ORG $+1
$SG230863 DB	'MINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN', 00H
$SG230864 DB	'MINOR_FRIENDSHIP_AT_WAR', 00H
$SG230865 DB	'MINOR_CIV_AGGRESSOR_THRESHOLD', 00H
	ORG $+2
$SG230866 DB	'MINOR_CIV_WARMONGER_THRESHOLD', 00H
	ORG $+2
$SG230867 DB	'PERMANENT_WAR_AGGRESSOR_CHANCE', 00H
	ORG $+1
$SG230868 DB	'PERMANENT_WAR_OTHER_WARMONGER_CHANCE_DISTANT', 00H
	ORG $+3
$SG230869 DB	'PERMANENT_WAR_OTHER_WARMONGER_CHANCE_FAR', 00H
	ORG $+3
$SG230870 DB	'PERMANENT_WAR_OTHER_WARMONGER_CHANCE_CLOSE', 00H
	ORG $+1
$SG230871 DB	'PERMANENT_WAR_OTHER_WARMONGER_CHANCE_NEIGHBORS', 00H
	ORG $+1
$SG230872 DB	'PERMANENT_WAR_OTHER_CHANCE_DISTANT', 00H
	ORG $+1
$SG230873 DB	'PERMANENT_WAR_OTHER_CHANCE_FAR', 00H
	ORG $+1
$SG230874 DB	'PERMANENT_WAR_OTHER_CHANCE_CLOSE', 00H
	ORG $+3
$SG230875 DB	'PERMANENT_WAR_OTHER_CHANCE_NEIGHBORS', 00H
	ORG $+3
$SG230876 DB	'PERMANENT_WAR_OTHER_AT_WAR', 00H
	ORG $+1
$SG230877 DB	'FRIENDSHIP_NEUTRAL_ON_DEATH', 00H
$SG230878 DB	'FRIENDSHIP_THRESHOLD_NEUTRAL', 00H
	ORG $+3
$SG230879 DB	'FRIENDSHIP_FRIENDS_ON_DEATH', 00H
$SG230880 DB	'FRIENDSHIP_THRESHOLD_FRIENDS', 00H
	ORG $+3
$SG230881 DB	'FRIENDSHIP_ALLIES_ON_DEATH', 00H
	ORG $+1
$SG230882 DB	'FRIENDSHIP_THRESHOLD_ALLIES', 00H
$SG230883 DB	'FRIENDSHIP_THRESHOLD_MAX', 00H
	ORG $+3
$SG230884 DB	'FRIENDSHIP_THRESHOLD_CAN_BULLY', 00H
	ORG $+1
$SG230885 DB	'FRIENDSHIP_THRESHOLD_CAN_PLEDGE_TO_PROTECT', 00H
	ORG $+1
$SG230886 DB	'MINOR_FRIENDSHIP_CLOSE_AMOUNT', 00H
	ORG $+2
$SG230887 DB	'MINOR_CIV_SCIENCE_BONUS_MULTIPLIER', 00H
	ORG $+1
$SG230888 DB	'FRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT', 00H
	ORG $+3
$SG230889 DB	'FRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL', 00H
	ORG $+2
$SG230890 DB	'FRIENDS_CULTURE_BONUS_AMOUNT_INDUSTRIAL', 00H
$SG230891 DB	'ALLIES_CULTURE_BONUS_AMOUNT_ANCIENT', 00H
$SG230892 DB	'ALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL', 00H
	ORG $+3
$SG230893 DB	'ALLIES_CULTURE_BONUS_AMOUNT_INDUSTRIAL', 00H
	ORG $+1
$SG230894 DB	'FRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE', 00H
	ORG $+2
$SG230895 DB	'FRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_POST_RENAISSANCE', 00H
	ORG $+1
$SG230896 DB	'FRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE', 00H
	ORG $+1
$SG230897 DB	'FRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_POST_RENAISSANCE', 00H
$SG230898 DB	'ALLIES_CAPITAL_FOOD_BONUS_AMOUNT', 00H
	ORG $+3
$SG230899 DB	'ALLIES_OTHER_CITIES_FOOD_BONUS_AMOUNT', 00H
	ORG $+2
$SG230900 DB	'FRIENDS_BASE_TURNS_UNIT_SPAWN', 00H
	ORG $+2
$SG230901 DB	'FRIENDS_RAND_TURNS_UNIT_SPAWN', 00H
	ORG $+2
$SG230902 DB	'ALLIES_EXTRA_TURNS_UNIT_SPAWN', 00H
	ORG $+2
$SG230903 DB	'UNIT_SPAWN_BIAS_MULTIPLIER', 00H
	ORG $+1
$SG230904 DB	'UNIT_SPAWN_NUM_CHOICES', 00H
	ORG $+1
$SG230905 DB	'FRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT', 00H
$SG230906 DB	'FRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL', 00H
	ORG $+3
$SG230907 DB	'FRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL', 00H
	ORG $+1
$SG230908 DB	'ALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT', 00H
	ORG $+1
$SG230909 DB	'ALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL', 00H
$SG230910 DB	'ALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL', 00H
	ORG $+2
$SG230911 DB	'FRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT', 00H
	ORG $+2
$SG230912 DB	'FRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL', 00H
	ORG $+1
$SG230913 DB	'FRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL', 00H
	ORG $+3
$SG230914 DB	'ALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT', 00H
	ORG $+3
$SG230915 DB	'ALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL', 00H
	ORG $+2
$SG230916 DB	'ALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL', 00H
$SG230917 DB	'FRIENDS_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL', 00H
	ORG $+1
$SG230918 DB	'FRIENDS_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE', 00H
$SG230919 DB	'FRIENDS_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL', 00H
	ORG $+3
$SG230920 DB	'FRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL', 00H
	ORG $+2
$SG230921 DB	'FRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT', 00H
$SG230922 DB	'ALLIES_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL', 00H
	ORG $+2
$SG230923 DB	'ALLIES_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE', 00H
	ORG $+1
$SG230924 DB	'ALLIES_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL', 00H
$SG230925 DB	'ALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL', 00H
	ORG $+3
$SG230926 DB	'ALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT', 00H
	ORG $+1
$SG230927 DB	'MINOR_TURNS_GREAT_PEOPLE_SPAWN_BASE', 00H
$SG230928 DB	'MINOR_TURNS_GREAT_PEOPLE_SPAWN_RAND', 00H
$SG230929 DB	'MINOR_TURNS_GREAT_PEOPLE_SPAWN_BIAS_MULTIPLY', 00H
	ORG $+3
$SG230930 DB	'MINOR_ADDITIONAL_ALLIES_GP_CHANGE', 00H
	ORG $+2
$SG230931 DB	'MAX_MINOR_ADDITIONAL_ALLIES_GP_CHANGE', 00H
	ORG $+2
$SG230932 DB	'MAX_DISTANCE_MINORS_BARB_QUEST', 00H
	ORG $+1
$SG230933 DB	'TXT_KEY_MINOR_GIFT_UNITS_REMINDER', 00H
	ORG $+2
$SG230934 DB	'WAR_QUEST_COMPLETE_FRIENDSHIP', 00H
	ORG $+2
$SG230935 DB	'WAR_QUEST_UNITS_TO_KILL_DIVISOR', 00H
$SG230936 DB	'WAR_QUEST_MIN_UNITS_TO_KILL', 00H
$SG230937 DB	'MINOR_QUEST_FRIENDSHIP_ROUTE', 00H
	ORG $+3
$SG230938 DB	'MINOR_QUEST_FRIENDSHIP_KILL_CAMP', 00H
	ORG $+3
$SG230939 DB	'MINOR_QUEST_FRIENDSHIP_CONNECT_RESOURCE', 00H
$SG230940 DB	'MINOR_QUEST_FRIENDSHIP_CONSTRUCT_WONDER', 00H
$SG230941 DB	'MINOR_QUEST_FRIENDSHIP_GREAT_PERSON', 00H
$SG230942 DB	'MINOR_QUEST_FRIENDSHIP_KILL_CITY_STATE', 00H
	ORG $+1
$SG230943 DB	'MINOR_QUEST_FRIENDSHIP_FIND_PLAYER', 00H
	ORG $+1
$SG230944 DB	'MINOR_QUEST_FRIENDSHIP_FIND_NATURAL_WONDER', 00H
	ORG $+1
$SG230945 DB	'MINOR_QUEST_FRIENDSHIP_GIVE_GOLD', 00H
	ORG $+3
$SG230946 DB	'MINOR_QUEST_FRIENDSHIP_PLEDGE_TO_PROTECT', 00H
	ORG $+3
$SG230947 DB	'MINOR_QUEST_FRIENDSHIP_CONTEST_CULTURE', 00H
	ORG $+1
$SG230948 DB	'MINOR_QUEST_FRIENDSHIP_CONTEST_FAITH', 00H
	ORG $+3
$SG230949 DB	'MINOR_QUEST_FRIENDSHIP_CONTEST_TECHS', 00H
	ORG $+3
$SG230950 DB	'MINOR_QUEST_FRIENDSHIP_INVEST', 00H
	ORG $+2
$SG230951 DB	'MINOR_QUEST_FRIENDSHIP_BULLY_CITY_STATE', 00H
$SG230952 DB	'MINOR_QUEST_FRIENDSHIP_DENOUNCE_MAJOR', 00H
	ORG $+2
$SG230953 DB	'MINOR_QUEST_FRIENDSHIP_SPREAD_RELIGION', 00H
	ORG $+1
$SG230954 DB	'MINOR_QUEST_FRIENDSHIP_TRADE_ROUTE', 00H
	ORG $+1
$SG230955 DB	'MINOR_QUEST_STANDARD_CONTEST_LENGTH', 00H
$SG230956 DB	'MINOR_CIV_GOLD_GIFT_GAME_MULTIPLIER', 00H
$SG230957 DB	'MINOR_CIV_GOLD_GIFT_GAME_DIVISOR', 00H
	ORG $+3
$SG230958 DB	'MINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR', 00H
$SG230959 DB	'MINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD', 00H
	ORG $+2
$SG230960 DB	'MINOR_CIV_BEST_RELATIONS_HAPPINESS_BONUS', 00H
	ORG $+3
$SG230961 DB	'MINOR_CIV_RESOURCE_SEARCH_RADIUS', 00H
	ORG $+3
$SG230962 DB	'FRIENDSHIP_PER_UNIT_INTRUDING', 00H
	ORG $+2
$SG230963 DB	'FRIENDSHIP_PER_BARB_KILLED', 00H
	ORG $+1
$SG230964 DB	'FRIENDSHIP_PER_UNIT_GIFTED', 00H
	ORG $+1
$SG230965 DB	'MAX_INFLUENCE_FROM_MINOR_GIFTS', 00H
	ORG $+1
$SG230966 DB	'MINOR_LIBERATION_FRIENDSHIP', 00H
$SG230967 DB	'RETURN_CIVILIAN_FRIENDSHIP', 00H
	ORG $+1
$SG230968 DB	'MINOR_CIV_MAX_GLOBAL_QUESTS_FOR_PLAYER', 00H
	ORG $+1
$SG230969 DB	'MINOR_CIV_MAX_PERSONAL_QUESTS_FOR_PLAYER', 00H
	ORG $+3
$SG230970 DB	'MINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN', 00H
	ORG $+1
$SG230971 DB	'MINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN_RAND', 00H
$SG230972 DB	'MINOR_CIV_GLOBAL_QUEST_MIN_TURNS_BETWEEN', 00H
	ORG $+3
$SG230973 DB	'MINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN', 00H
	ORG $+2
$SG230974 DB	'MINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIP'
	DB	'LIER', 00H
	ORG $+3
$SG230975 DB	'MINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN', 00H
	ORG $+3
$SG230976 DB	'MINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN_RAND', 00H
	ORG $+2
$SG230977 DB	'MINOR_CIV_PERSONAL_QUEST_MIN_TURNS_BETWEEN', 00H
	ORG $+1
$SG230978 DB	'MINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN', 00H
$SG230979 DB	'MINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULT'
	DB	'IPLIER', 00H
	ORG $+1
$SG230980 DB	'MINOR_CIV_QUEST_KILL_CAMP_RANGE', 00H
$SG230981 DB	'MINOR_CIV_QUEST_WONDER_COMPLETION_THRESHOLD', 00H
$SG230982 DB	'MINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD', 00H
	ORG $+2
$SG230983 DB	'MINOR_CIV_MERCANTILE_RESOURCES_QUANTITY', 00H
$SG230984 DB	'MINOR_CIV_MERCANTILE_RESOURCES_KEEP_ON_CAPTURE_DISABLED', 00H
$SG230985 DB	'QUEST_DISABLED_ROUTE', 00H
	ORG $+3
$SG230986 DB	'QUEST_DISABLED_KILL_CAMP', 00H
	ORG $+3
$SG230987 DB	'QUEST_DISABLED_CONNECT_RESOURCE', 00H
$SG230988 DB	'QUEST_DISABLED_CONSTRUCT_WONDER', 00H
$SG230989 DB	'QUEST_DISABLED_GREAT_PERSON', 00H
$SG230990 DB	'QUEST_DISABLED_KILL_CITY_STATE', 00H
	ORG $+1
$SG230991 DB	'QUEST_DISABLED_FIND_PLAYER', 00H
	ORG $+1
$SG230992 DB	'QUEST_DISABLED_NATURAL_WONDER', 00H
	ORG $+2
$SG230993 DB	'QUEST_DISABLED_GIVE_GOLD', 00H
	ORG $+3
$SG230994 DB	'QUEST_DISABLED_PLEDGE_TO_PROTECT', 00H
	ORG $+3
$SG230995 DB	'QUEST_DISABLED_CONTEST_CULTURE', 00H
	ORG $+1
$SG230996 DB	'QUEST_DISABLED_CONTEST_FAITH', 00H
	ORG $+3
$SG230997 DB	'QUEST_DISABLED_CONTEST_TECHS', 00H
	ORG $+3
$SG230998 DB	'QUEST_DISABLED_INVEST', 00H
	ORG $+2
$SG230999 DB	'QUEST_DISABLED_BULLY_CITY_STATE', 00H
$SG231000 DB	'QUEST_DISABLED_DENOUNCE_MAJOR', 00H
	ORG $+2
$SG231001 DB	'QUEST_DISABLED_SPREAD_RELIGION', 00H
	ORG $+1
$SG231002 DB	'QUEST_DISABLED_TRADE_ROUTE', 00H
	ORG $+1
$SG231003 DB	'MINOR_CIV_QUEST_WEIGHT_DEFAULT', 00H
	ORG $+1
$SG231004 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_FRIENDLY_ROUTE', 00H
	ORG $+3
$SG231005 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_ROUTE', 00H
$SG231006 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_ROUTE', 00H
	ORG $+3
$SG231007 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_ROUTE', 00H
	ORG $+1
$SG231008 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CAMP'
	DB	00H
	ORG $+3
$SG231009 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_CONNECT_RESOU'
	DB	'RCE', 00H
$SG231010 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_CONNECT_RES'
	DB	'OURCE', 00H
	ORG $+2
$SG231011 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_CONSTRUCT_WON'
	DB	'DER', 00H
$SG231012 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_GREAT_PERSON', 00H
$SG231013 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CITY'
	DB	'_STATE', 00H
	ORG $+1
$SG231014 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_KILL_CITY_STAT'
	DB	'E', 00H
	ORG $+2
$SG231015 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_NEUTRAL_KILL_CITY_STAT'
	DB	'E', 00H
	ORG $+2
$SG231016 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_FIND_PLAYER', 00H
	ORG $+1
$SG231017 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_FIND_PLAYER'
	DB	00H
	ORG $+7
$SG231018 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_FIND_NATU'
	DB	'RAL_WONDER', 00H
	ORG $+1
$SG231019 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_FIND_NATURAL_W'
	DB	'ONDER', 00H
	ORG $+2
$SG231020 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_GIVE_GOLD'
	DB	00H
	ORG $+3
$SG231021 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_GIVE_GOLD', 00H
	ORG $+1
$SG231022 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_GIVE_GOLD', 00H
	ORG $+6
$SG231023 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_PLEDGE_TO'
	DB	'_PROTECT', 00H
	ORG $+3
$SG231024 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_PLEDGE_TO_PRO'
	DB	'TECT', 00H
	ORG $+3
$SG231025 DB	'MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_PLEDGE_TO_PROTEC'
	DB	'T', 00H
	ORG $+2
$SG231026 DB	'RELIGION_BELIEF_SCORE_CITY_MULTIPLIER', 00H
	ORG $+2
$SG231027 DB	'RELIGION_BELIEF_SCORE_WORKED_PLOT_MULTIPLIER', 00H
	ORG $+3
$SG231028 DB	'RELIGION_BELIEF_SCORE_OWNED_PLOT_MULTIPLIER', 00H
$SG231029 DB	'RELIGION_BELIEF_SCORE_UNOWNED_PLOT_MULTIPLIER', 00H
	ORG $+2
$SG231030 DB	'RELIGION_MISSIONARY_RANGE_IN_TURNS', 00H
	ORG $+1
$SG231031 DB	'RELIGION_MAX_MISSIONARIES', 00H
	ORG $+2
$SG231032 DB	'NORMAL_ANNEX', 00H
	ORG $+3
$SG231033 DB	'AGGRESSIVE_ANNEX', 00H
	ORG $+3
$SG231034 DB	'MC_GIFT_WEIGHT_THRESHOLD', 00H
	ORG $+3
$SG231035 DB	'MC_ALWAYS_GIFT_DIPLO_THRESHOLD', 00H
	ORG $+1
$SG231036 DB	'MC_SOMETIMES_GIFT_RAND_MULTIPLIER', 00H
	ORG $+2
$SG231037 DB	'MC_SMALL_GIFT_WEIGHT_PASS_OTHER_PLAYER', 00H
	ORG $+1
$SG231038 DB	'MC_GIFT_WEIGHT_PASS_OTHER_PLAYER', 00H
	ORG $+3
$SG231039 DB	'MC_GIFT_WEIGHT_MARITIME_GROWTH', 00H
	ORG $+1
$SG231040 DB	'MC_GIFT_WEIGHT_DIPLO_VICTORY', 00H
	ORG $+3
$SG231041 DB	'MC_GIFT_WEIGHT_CULTURE_VICTORY', 00H
	ORG $+1
$SG231042 DB	'MC_GIFT_WEIGHT_CONQUEST_VICTORY', 00H
$SG231043 DB	'MC_GIFT_WEIGHT_MILITARISTIC', 00H
$SG231044 DB	'MC_GIFT_WEIGHT_RESOURCE_WE_NEED', 00H
$SG231045 DB	'MC_GIFT_WEIGHT_NEUTRAL_VICTORY_ROLL', 00H
$SG231046 DB	'MC_GIFT_WEIGHT_PROTECTIVE', 00H
	ORG $+2
$SG231047 DB	'MC_GIFT_WEIGHT_HOSTILE', 00H
	ORG $+1
$SG231048 DB	'MC_GIFT_WEIGHT_NEIGHBORS', 00H
	ORG $+3
$SG231049 DB	'MC_GIFT_WEIGHT_CLOSE', 00H
	ORG $+3
$SG231050 DB	'MC_GIFT_WEIGHT_FAR', 00H
	ORG $+1
$SG231051 DB	'MC_GIFT_WEIGHT_ALMOST_NOT_ALLIES', 00H
	ORG $+3
$SG231052 DB	'MC_GIFT_WEIGHT_ALMOST_NOT_FRIENDS', 00H
	ORG $+2
$SG231053 DB	'OPINION_WEIGHT_LAND_FIERCE', 00H
	ORG $+1
$SG231054 DB	'OPINION_WEIGHT_LAND_STRONG', 00H
	ORG $+1
$SG231055 DB	'OPINION_WEIGHT_LAND_WEAK', 00H
	ORG $+3
$SG231056 DB	'OPINION_WEIGHT_LAND_NONE', 00H
	ORG $+3
$SG231057 DB	'OPINION_WEIGHT_VICTORY_FIERCE', 00H
	ORG $+2
$SG231058 DB	'OPINION_WEIGHT_VICTORY_STRONG', 00H
	ORG $+2
$SG231059 DB	'OPINION_WEIGHT_VICTORY_WEAK', 00H
$SG231060 DB	'OPINION_WEIGHT_VICTORY_NONE', 00H
$SG231061 DB	'OPINION_WEIGHT_WONDER_FIERCE', 00H
	ORG $+3
$SG231062 DB	'OPINION_WEIGHT_WONDER_STRONG', 00H
	ORG $+3
$SG231063 DB	'OPINION_WEIGHT_WONDER_WEAK', 00H
	ORG $+1
$SG231064 DB	'OPINION_WEIGHT_WONDER_NONE', 00H
	ORG $+1
$SG231065 DB	'OPINION_WEIGHT_MINOR_CIV_FIERCE', 00H
$SG231066 DB	'OPINION_WEIGHT_MINOR_CIV_STRONG', 00H
$SG231067 DB	'OPINION_WEIGHT_MINOR_CIV_WEAK', 00H
	ORG $+2
$SG231068 DB	'OPINION_WEIGHT_MINOR_CIV_NONE', 00H
	ORG $+2
$SG231069 DB	'OPINION_WEIGHT_WARMONGER_CRITICAL', 00H
	ORG $+2
$SG231070 DB	'OPINION_WEIGHT_WARMONGER_SEVERE', 00H
$SG231071 DB	'OPINION_WEIGHT_WARMONGER_MAJOR', 00H
	ORG $+1
$SG231072 DB	'OPINION_WEIGHT_WARMONGER_MINOR', 00H
	ORG $+1
$SG231073 DB	'OPINION_WEIGHT_WARMONGER_NONE', 00H
	ORG $+2
$SG231074 DB	'OPINION_WEIGHT_ASKED_NO_SETTLE', 00H
	ORG $+1
$SG231075 DB	'OPINION_WEIGHT_ASKED_STOP_SPYING', 00H
	ORG $+3
$SG231076 DB	'OPINION_WEIGHT_MADE_DEMAND_OF_US', 00H
	ORG $+3
$SG231077 DB	'OPINION_WEIGHT_RETURNED_CIVILIAN', 00H
	ORG $+3
$SG231078 DB	'OPINION_WEIGHT_BUILT_LANDMARK', 00H
	ORG $+2
$SG231079 DB	'OPINION_WEIGHT_RESURRECTED', 00H
	ORG $+1
$SG231080 DB	'OPINION_WEIGHT_LIBERATED_ONE_CITY', 00H
	ORG $+2
$SG231081 DB	'OPINION_WEIGHT_LIBERATED_TWO_CITIES', 00H
$SG231082 DB	'OPINION_WEIGHT_LIBERATED_THREE_CITIES', 00H
	ORG $+2
$SG231083 DB	'OPINION_WEIGHT_EMBASSY', 00H
	ORG $+1
$SG231084 DB	'OPINION_WEIGHT_CULTURE_BOMBED', 00H
	ORG $+2
$SG231085 DB	'OPINION_WEIGHT_PER_NEGATIVE_CONVERSION', 00H
	ORG $+1
$SG231086 DB	'OPINION_WEIGHT_ADOPTING_HIS_RELIGION', 00H
	ORG $+3
$SG231087 DB	'OPINION_WEIGHT_ADOPTING_MY_RELIGION', 00H
$SG231088 DB	'OPINION_WEIGHT_SAME_LATE_POLICIES', 00H
	ORG $+2
$SG231089 DB	'OPINION_WEIGHT_DIFFERENT_LATE_POLICIES', 00H
	ORG $+1
$SG231090 DB	'OPINION_WEIGHT_BROKEN_MILITARY_PROMISE', 00H
	ORG $+1
$SG231091 DB	'OPINION_WEIGHT_BROKEN_MILITARY_PROMISE_WORLD', 00H
	ORG $+3
$SG231092 DB	'OPINION_WEIGHT_IGNORED_MILITARY_PROMISE', 00H
$SG231093 DB	'OPINION_WEIGHT_BROKEN_EXPANSION_PROMISE', 00H
$SG231094 DB	'OPINION_WEIGHT_IGNORED_EXPANSION_PROMISE', 00H
	ORG $+3
$SG231095 DB	'OPINION_WEIGHT_BROKEN_BORDER_PROMISE', 00H
	ORG $+3
$SG231096 DB	'OPINION_WEIGHT_IGNORED_BORDER_PROMISE', 00H
	ORG $+2
$SG231097 DB	'OPINION_WEIGHT_BROKEN_CITY_STATE_PROMISE', 00H
	ORG $+3
$SG231098 DB	'OPINION_WEIGHT_BROKEN_CITY_STATE_PROMISE_WORLD', 00H
	ORG $+1
$SG231099 DB	'OPINION_WEIGHT_IGNORED_CITY_STATE_PROMISE', 00H
	ORG $+2
$SG231100 DB	'OPINION_WEIGHT_BROKEN_SPY_PROMISE', 00H
	ORG $+2
$SG231101 DB	'OPINION_WEIGHT_IGNORED_SPY_PROMISE', 00H
	ORG $+1
$SG231102 DB	'OPINION_WEIGHT_FORGAVE_FOR_SPYING', 00H
	ORG $+2
$SG231103 DB	'OPINION_WEIGHT_BROKEN_NO_CONVERT_PROMISE', 00H
	ORG $+3
$SG231104 DB	'OPINION_WEIGHT_IGNORED_NO_CONVERT_PROMISE', 00H
	ORG $+2
$SG231105 DB	'OPINION_WEIGHT_BROKEN_NO_DIG_PROMISE', 00H
	ORG $+3
$SG231106 DB	'OPINION_WEIGHT_IGNORED_NO_DIG_PROMISE', 00H
	ORG $+2
$SG231107 DB	'OPINION_WEIGHT_BROKEN_COOP_WAR_PROMISE', 00H
	ORG $+1
$SG231108 DB	'OPINION_WEIGHT_KILLED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FO'
	DB	'RGIVEN', 00H
	ORG $+1
$SG231109 DB	'OPINION_WEIGHT_KILLED_PROTECTED_MINOR', 00H
	ORG $+2
$SG231110 DB	'OPINION_WEIGHT_KILLED_MANY_PROTECTED_MINORS', 00H
$SG231111 DB	'OPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_NUM_TURNS_UNTIL_'
	DB	'FORGIVEN', 00H
	ORG $+3
$SG231112 DB	'OPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_RECENTLY_NUM_TUR'
	DB	'NS', 00H
	ORG $+1
$SG231113 DB	'OPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_RECENTLY', 00H
	ORG $+3
$SG231114 DB	'OPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_WHILE_AGO', 00H
	ORG $+2
$SG231115 DB	'OPINION_WEIGHT_ATTACKED_MANY_PROTECTED_MINORS', 00H
	ORG $+2
$SG231116 DB	'OPINION_WEIGHT_BULLIED_PROTECTED_MINOR_NUM_TURNS_UNTIL_F'
	DB	'ORGIVEN', 00H
$SG231117 DB	'OPINION_WEIGHT_BULLIED_PROTECTED_MINOR_RECENTLY_NUM_TURN'
	DB	'S', 00H
	ORG $+2
$SG231118 DB	'OPINION_WEIGHT_BULLIED_PROTECTED_MINOR_RECENTLY', 00H
$SG231119 DB	'OPINION_WEIGHT_BULLIED_PROTECTED_MINOR_WHILE_AGO', 00H
	ORG $+3
$SG231120 DB	'OPINION_WEIGHT_BULLIED_MANY_PROTECTED_MINORS', 00H
	ORG $+3
$SG231121 DB	'OPINION_WEIGHT_SIDED_WITH_THEIR_MINOR_NUM_TURNS_UNTIL_FO'
	DB	'RGIVEN', 00H
	ORG $+1
$SG231122 DB	'OPINION_WEIGHT_SIDED_WITH_THEIR_MINOR', 00H
	ORG $+2
$SG231123 DB	'OPINION_WEIGHT_DOF', 00H
	ORG $+1
$SG231124 DB	'OPINION_WEIGHT_DOF_WITH_FRIEND', 00H
	ORG $+1
$SG231125 DB	'OPINION_WEIGHT_DOF_WITH_ENEMY', 00H
	ORG $+2
$SG231126 DB	'OPINION_WEIGHT_DENOUNCED_BY_FRIEND_EACH', 00H
$SG231127 DB	'OPINION_WEIGHT_DENOUNCED_BY_FRIEND_DONT_LIKE', 00H
	ORG $+3
$SG231128 DB	'OPINION_WEIGHT_DENOUNCED_FRIEND_EACH', 00H
	ORG $+3
$SG231129 DB	'OPINION_WEIGHT_DENOUNCED_ME_FRIENDS', 00H
$SG231130 DB	'OPINION_WEIGHT_WAR_FRIEND_EACH', 00H
	ORG $+1
$SG231131 DB	'OPINION_WEIGHT_WAR_ME_FRIENDS', 00H
	ORG $+2
$SG231132 DB	'OPINION_WEIGHT_REFUSED_REQUEST_EACH', 00H
$SG231133 DB	'OPINION_WEIGHT_DENOUNCED_ME', 00H
$SG231134 DB	'OPINION_WEIGHT_DENOUNCED_THEM', 00H
	ORG $+2
$SG231135 DB	'OPINION_WEIGHT_DENOUNCED_FRIEND', 00H
$SG231136 DB	'OPINION_WEIGHT_DENOUNCED_ENEMY', 00H
	ORG $+1
$SG231137 DB	'OPINION_WEIGHT_RECKLESS_EXPANDER', 00H
	ORG $+3
$SG231138 DB	'OPINION_WEIGHT_TRADE_MAX', 00H
	ORG $+3
$SG231139 DB	'OPINION_WEIGHT_COMMON_FOE_MAX', 00H
	ORG $+2
$SG231140 DB	'OPINION_WEIGHT_ASSIST_MAX', 00H
	ORG $+2
$SG231141 DB	'OPINION_WEIGHT_LIBERATED_CAPITAL', 00H
	ORG $+3
$SG231142 DB	'OPINION_WEIGHT_LIBERATED_CITY', 00H
	ORG $+2
$SG231143 DB	'OPINION_WEIGHT_GAVE_ASSISTANCE', 00H
	ORG $+1
$SG231144 DB	'OPINION_WEIGHT_PAID_TRIBUTE', 00H
$SG231145 DB	'OPINION_WEIGHT_NUKED_MAX', 00H
	ORG $+3
$SG231146 DB	'OPINION_WEIGHT_ROBBED_BY', 00H
	ORG $+3
$SG231147 DB	'OPINION_WEIGHT_INTRIGUE_SHARED_BY', 00H
	ORG $+2
$SG231148 DB	'OPINION_WEIGHT_CAPTURED_CAPITAL', 00H
$SG231149 DB	'OPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL', 00H
	ORG $+1
$SG231150 DB	'OPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL_NUM_TURNS', 00H
	ORG $+3
$SG231151 DB	'OPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL', 00H
	ORG $+2
$SG231152 DB	'OPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL_NUM_TURNS', 00H
$SG231153 DB	'OPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL', 00H
	ORG $+1
$SG231154 DB	'OPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL_NUM_TURNS', 00H
	ORG $+3
$SG231155 DB	'OPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL', 00H
$SG231156 DB	'OPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL_NUM_TURNS', 00H
	ORG $+2
$SG231157 DB	'OPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING', 00H
	ORG $+2
$SG231158 DB	'OPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING_NUM_TURNS', 00H
$SG231159 DB	'OPINION_THRESHOLD_UNFORGIVABLE', 00H
	ORG $+1
$SG231160 DB	'OPINION_THRESHOLD_ENEMY', 00H
$SG231161 DB	'OPINION_THRESHOLD_COMPETITOR', 00H
	ORG $+3
$SG231162 DB	'OPINION_THRESHOLD_FAVORABLE', 00H
$SG231163 DB	'OPINION_THRESHOLD_FRIEND', 00H
	ORG $+3
$SG231164 DB	'OPINION_THRESHOLD_ALLY', 00H
	ORG $+1
$SG231165 DB	'APPROACH_NEUTRAL_DEFAULT', 00H
	ORG $+3
$SG231166 DB	'APPROACH_BIAS_FOR_CURRENT', 00H
	ORG $+2
$SG231167 DB	'APPROACH_WAR_CURRENTLY_DECEPTIVE', 00H
	ORG $+3
$SG231168 DB	'APPROACH_HOSTILE_CURRENTLY_HOSTILE', 00H
	ORG $+1
$SG231169 DB	'APPROACH_WAR_CURRENTLY_WAR', 00H
	ORG $+1
$SG231170 DB	'APPROACH_RANDOM_PERCENT', 00H
$SG231171 DB	'APPROACH_WAR_CONQUEST_GRAND_STRATEGY', 00H
	ORG $+3
$SG231172 DB	'APPROACH_OPINION_UNFORGIVABLE_WAR', 00H
	ORG $+2
$SG231173 DB	'APPROACH_OPINION_UNFORGIVABLE_HOSTILE', 00H
	ORG $+2
$SG231174 DB	'APPROACH_OPINION_UNFORGIVABLE_DECEPTIVE', 00H
$SG231175 DB	'APPROACH_OPINION_UNFORGIVABLE_GUARDED', 00H
	ORG $+2
$SG231176 DB	'APPROACH_OPINION_ENEMY_WAR', 00H
	ORG $+1
$SG231177 DB	'APPROACH_OPINION_ENEMY_HOSTILE', 00H
	ORG $+1
$SG231178 DB	'APPROACH_OPINION_ENEMY_DECEPTIVE', 00H
	ORG $+3
$SG231179 DB	'APPROACH_OPINION_ENEMY_GUARDED', 00H
	ORG $+1
$SG231180 DB	'APPROACH_OPINION_COMPETITOR_WAR', 00H
$SG231181 DB	'APPROACH_OPINION_COMPETITOR_HOSTILE', 00H
$SG231182 DB	'APPROACH_OPINION_COMPETITOR_DECEPTIVE', 00H
	ORG $+2
$SG231183 DB	'APPROACH_OPINION_COMPETITOR_GUARDED', 00H
$SG231184 DB	'APPROACH_OPINION_NEUTRAL_DECEPTIVE', 00H
	ORG $+1
$SG231185 DB	'APPROACH_OPINION_NEUTRAL_FRIENDLY', 00H
	ORG $+2
$SG231186 DB	'APPROACH_OPINION_FAVORABLE_HOSTILE', 00H
	ORG $+1
$SG231187 DB	'APPROACH_OPINION_FAVORABLE_DECEPTIVE', 00H
	ORG $+3
$SG231188 DB	'APPROACH_OPINION_FAVORABLE_FRIENDLY', 00H
$SG231189 DB	'APPROACH_OPINION_FRIEND_HOSTILE', 00H
$SG231190 DB	'APPROACH_OPINION_FRIEND_FRIENDLY', 00H
	ORG $+3
$SG231191 DB	'APPROACH_OPINION_ALLY_FRIENDLY', 00H
	ORG $+1
$SG231192 DB	'APPROACH_DECEPTIVE_WORKING_WITH_PLAYER', 00H
	ORG $+1
$SG231193 DB	'APPROACH_FRIENDLY_WORKING_WITH_PLAYER', 00H
	ORG $+2
$SG231194 DB	'APPROACH_HOSTILE_WORKING_WITH_PLAYER', 00H
	ORG $+3
$SG231195 DB	'APPROACH_GUARDED_WORKING_WITH_PLAYER', 00H
	ORG $+3
$SG231196 DB	'APPROACH_DECEPTIVE_WORKING_AGAINST_PLAYER', 00H
	ORG $+2
$SG231197 DB	'APPROACH_HOSTILE_WORKING_AGAINST_PLAYER', 00H
$SG231198 DB	'APPROACH_WAR_WORKING_AGAINST_PLAYER', 00H
$SG231199 DB	'APPROACH_WAR_DENOUNCED', 00H
	ORG $+1
$SG231200 DB	'APPROACH_HOSTILE_DENOUNCED', 00H
	ORG $+1
$SG231201 DB	'APPROACH_GUARDED_DENOUNCED', 00H
	ORG $+1
$SG231202 DB	'APPROACH_FRIENDLY_DENOUNCED', 00H
$SG231203 DB	'APPROACH_DECEPTIVE_DENOUNCED', 00H
	ORG $+3
$SG231204 DB	'APPROACH_ATTACKED_PROTECTED_MINOR_WAR', 00H
	ORG $+2
$SG231205 DB	'APPROACH_ATTACKED_PROTECTED_MINOR_HOSTILE', 00H
	ORG $+2
$SG231206 DB	'APPROACH_ATTACKED_PROTECTED_MINOR_GUARDED', 00H
	ORG $+2
$SG231207 DB	'APPROACH_ATTACKED_PROTECTED_MINOR_PAST_WAR', 00H
	ORG $+1
$SG231208 DB	'APPROACH_ATTACKED_PROTECTED_MINOR_PAST_HOSTILE', 00H
	ORG $+1
$SG231209 DB	'APPROACH_ATTACKED_PROTECTED_MINOR_PAST_GUARDED', 00H
	ORG $+1
$SG231210 DB	'APPROACH_DECEPTIVE_MILITARY_THREAT_CRITICAL', 00H
$SG231211 DB	'APPROACH_GUARDED_MILITARY_THREAT_CRITICAL', 00H
	ORG $+2
$SG231212 DB	'APPROACH_AFRAID_MILITARY_THREAT_CRITICAL', 00H
	ORG $+3
$SG231213 DB	'APPROACH_DECEPTIVE_DEMAND', 00H
	ORG $+2
$SG231214 DB	'APPROACH_FRIENDLY_DEMAND', 00H
	ORG $+3
$SG231215 DB	'APPROACH_WAR_BROKEN_MILITARY_PROMISE', 00H
	ORG $+3
$SG231216 DB	'APPROACH_DECEPTIVE_BROKEN_MILITARY_PROMISE', 00H
	ORG $+1
$SG231217 DB	'APPROACH_FRIENDLY_BROKEN_MILITARY_PROMISE', 00H
	ORG $+2
$SG231218 DB	'APPROACH_WAR_BROKEN_MILITARY_PROMISE_WORLD', 00H
	ORG $+1
$SG231219 DB	'APPROACH_DECEPTIVE_BROKEN_MILITARY_PROMISE_WORLD', 00H
	ORG $+3
$SG231220 DB	'APPROACH_FRIENDLY_BROKEN_MILITARY_PROMISE_WORLD', 00H
$SG231221 DB	'APPROACH_DECEPTIVE_IGNORED_MILITARY_PROMISE', 00H
$SG231222 DB	'APPROACH_FRIENDLY_IGNORED_MILITARY_PROMISE', 00H
	ORG $+1
$SG231223 DB	'APPROACH_WAR_BROKEN_EXPANSION_PROMISE', 00H
	ORG $+2
$SG231224 DB	'APPROACH_DECEPTIVE_BROKEN_EXPANSION_PROMISE', 00H
$SG231225 DB	'APPROACH_FRIENDLY_BROKEN_EXPANSION_PROMISE', 00H
	ORG $+1
$SG231226 DB	'APPROACH_WAR_IGNORED_EXPANSION_PROMISE', 00H
	ORG $+1
$SG231227 DB	'APPROACH_DECEPTIVE_IGNORED_EXPANSION_PROMISE', 00H
	ORG $+3
$SG231228 DB	'APPROACH_FRIENDLY_IGNORED_EXPANSION_PROMISE', 00H
$SG231229 DB	'APPROACH_WAR_BROKEN_BORDER_PROMISE', 00H
	ORG $+1
$SG231230 DB	'APPROACH_DECEPTIVE_BROKEN_BORDER_PROMISE', 00H
	ORG $+3
$SG231231 DB	'APPROACH_FRIENDLY_BROKEN_BORDER_PROMISE', 00H
$SG231232 DB	'APPROACH_WAR_IGNORED_BORDER_PROMISE', 00H
$SG231233 DB	'APPROACH_DECEPTIVE_IGNORED_BORDER_PROMISE', 00H
	ORG $+2
$SG231234 DB	'APPROACH_FRIENDLY_IGNORED_BORDER_PROMISE', 00H
	ORG $+3
$SG231235 DB	'APPROACH_WAR_BROKEN_CITY_STATE_PROMISE', 00H
	ORG $+1
$SG231236 DB	'APPROACH_DECEPTIVE_BROKEN_CITY_STATE_PROMISE', 00H
	ORG $+3
$SG231237 DB	'APPROACH_FRIENDLY_BROKEN_CITY_STATE_PROMISE', 00H
$SG231238 DB	'APPROACH_WAR_BROKEN_CITY_STATE_PROMISE_WORLD', 00H
	ORG $+3
$SG231239 DB	'APPROACH_DECEPTIVE_BROKEN_CITY_STATE_PROMISE_WORLD', 00H
	ORG $+1
$SG231240 DB	'APPROACH_FRIENDLY_BROKEN_CITY_STATE_PROMISE_WORLD', 00H
	ORG $+2
$SG231241 DB	'APPROACH_WAR_IGNORED_CITY_STATE_PROMISE', 00H
$SG231242 DB	'APPROACH_DECEPTIVE_IGNORED_CITY_STATE_PROMISE', 00H
	ORG $+2
$SG231243 DB	'APPROACH_FRIENDLY_IGNORED_CITY_STATE_PROMISE', 00H
	ORG $+3
$SG231244 DB	'APPROACH_FRIENDLY_MILITARY_THREAT_CRITICAL', 00H
	ORG $+1
$SG231245 DB	'APPROACH_DECEPTIVE_MILITARY_THREAT_SEVERE', 00H
	ORG $+2
$SG231246 DB	'APPROACH_GUARDED_MILITARY_THREAT_SEVERE', 00H
$SG231247 DB	'APPROACH_AFRAID_MILITARY_THREAT_SEVERE', 00H
	ORG $+1
$SG231248 DB	'APPROACH_FRIENDLY_MILITARY_THREAT_SEVERE', 00H
	ORG $+3
$SG231249 DB	'APPROACH_DECEPTIVE_MILITARY_THREAT_MAJOR', 00H
	ORG $+3
$SG231250 DB	'APPROACH_GUARDED_MILITARY_THREAT_MAJOR', 00H
	ORG $+1
$SG231251 DB	'APPROACH_AFRAID_MILITARY_THREAT_MAJOR', 00H
	ORG $+2
$SG231252 DB	'APPROACH_FRIENDLY_MILITARY_THREAT_MAJOR', 00H
$SG231253 DB	'APPROACH_DECEPTIVE_MILITARY_THREAT_MINOR', 00H
	ORG $+3
$SG231254 DB	'APPROACH_GUARDED_MILITARY_THREAT_MINOR', 00H
	ORG $+1
$SG231255 DB	'APPROACH_AFRAID_MILITARY_THREAT_MINOR', 00H
	ORG $+2
$SG231256 DB	'APPROACH_FRIENDLY_MILITARY_THREAT_MINOR', 00H
$SG231257 DB	'APPROACH_HOSTILE_MILITARY_THREAT_NONE', 00H
	ORG $+2
$SG231258 DB	'APPROACH_WAR_AT_WAR_WITH_PLAYER_WARS_NEUTRAL', 00H
	ORG $+3
$SG231259 DB	'APPROACH_WAR_AT_WAR_WITH_PLAYER_WARS_WINNING', 00H
	ORG $+3
$SG231260 DB	'APPROACH_WAR_AT_WAR_WITH_PLAYER_WARS_LOSING', 00H
$SG231261 DB	'APPROACH_HOSTILE_AT_WAR_WITH_PLAYER', 00H
$SG231262 DB	'APPROACH_DECEPTIVE_AT_WAR_WITH_PLAYER', 00H
	ORG $+2
$SG231263 DB	'APPROACH_GUARDED_AT_WAR_WITH_PLAYER', 00H
$SG231264 DB	'APPROACH_FRIENDLY_AT_WAR_WITH_PLAYER', 00H
	ORG $+3
$SG231265 DB	'APPROACH_WAR_PLANNING_WAR_WITH_ANOTHER_PLAYER', 00H
	ORG $+2
$SG231266 DB	'APPROACH_HOSTILE_PLANNING_WAR_WITH_ANOTHER_PLAYER', 00H
	ORG $+2
$SG231267 DB	'APPROACH_DECEPTIVE_PLANNING_WAR_WITH_ANOTHER_PLAYER', 00H
$SG231268 DB	'APPROACH_GUARDED_PLANNING_WAR_WITH_ANOTHER_PLAYER', 00H
	ORG $+2
$SG231269 DB	'APPROACH_FRIENDLY_PLANNING_WAR_WITH_ANOTHER_PLAYER', 00H
	ORG $+1
$SG231270 DB	'APPROACH_WAR_HOSTILE_WITH_ANOTHER_PLAYER', 00H
	ORG $+3
$SG231271 DB	'APPROACH_HOSTILE_HOSTILE_WITH_ANOTHER_PLAYER', 00H
	ORG $+3
$SG231272 DB	'APPROACH_DECEPTIVE_HOSTILE_WITH_ANOTHER_PLAYER', 00H
	ORG $+1
$SG231273 DB	'APPROACH_FRIENDLY_HOSTILE_WITH_ANOTHER_PLAYER', 00H
	ORG $+2
$SG231274 DB	'APPROACH_WAR_AFRAID_WITH_ANOTHER_PLAYER', 00H
$SG231275 DB	'APPROACH_HOSTILE_AFRAID_WITH_ANOTHER_PLAYER', 00H
$SG231276 DB	'APPROACH_DECEPTIVE_AFRAID_WITH_ANOTHER_PLAYER', 00H
	ORG $+2
$SG231277 DB	'APPROACH_FRIENDLY_AFRAID_WITH_ANOTHER_PLAYER', 00H
	ORG $+3
$SG231278 DB	'APPROACH_WAR_PROJECTION_DESTRUCTION_PERCENT', 00H
$SG231279 DB	'APPROACH_WAR_PROJECTION_DEFEAT_PERCENT', 00H
	ORG $+1
$SG231280 DB	'APPROACH_WAR_PROJECTION_STALEMATE_PERCENT', 00H
	ORG $+2
$SG231281 DB	'APPROACH_WAR_PROJECTION_UNKNOWN_PERCENT', 00H
$SG231282 DB	'APPROACH_WAR_PROJECTION_GOOD_PERCENT', 00H
	ORG $+3
$SG231283 DB	'APPROACH_WAR_PROJECTION_VERY_GOOD_PERCENT', 00H
	ORG $+2
$SG231284 DB	'APPROACH_GUARDED_PROJECTION_DESTRUCTION_PERCENT', 00H
$SG231285 DB	'APPROACH_GUARDED_PROJECTION_DEFEAT_PERCENT', 00H
	ORG $+1
$SG231286 DB	'APPROACH_GUARDED_PROJECTION_STALEMATE_PERCENT', 00H
	ORG $+2
$SG231287 DB	'APPROACH_GUARDED_PROJECTION_UNKNOWN_PERCENT', 00H
$SG231288 DB	'APPROACH_GUARDED_PROJECTION_GOOD_PERCENT', 00H
	ORG $+3
$SG231289 DB	'APPROACH_GUARDED_PROJECTION_VERY_GOOD_PERCENT', 00H
	ORG $+2
$SG231290 DB	'TURNS_SINCE_PEACE_WEIGHT_DAMPENER', 00H
	ORG $+2
$SG231291 DB	'APPROACH_WAR_HAS_MADE_PEACE_BEFORE_PERCENT', 00H
	ORG $+1
$SG231292 DB	'APPROACH_WAR_RECKLESS_EXPANDER', 00H
	ORG $+1
$SG231293 DB	'APPROACH_WAR_PROXIMITY_NEIGHBORS', 00H
	ORG $+3
$SG231294 DB	'APPROACH_WAR_PROXIMITY_CLOSE', 00H
	ORG $+3
$SG231295 DB	'APPROACH_WAR_PROXIMITY_FAR', 00H
	ORG $+1
$SG231296 DB	'APPROACH_WAR_PROXIMITY_DISTANT', 00H
	ORG $+1
$SG231297 DB	'MINOR_APPROACH_IGNORE_DEFAULT', 00H
	ORG $+2
$SG231298 DB	'MINOR_APPROACH_BIAS_FOR_CURRENT', 00H
$SG231299 DB	'MINOR_APPROACH_IGNORE_CURRENTLY_WAR', 00H
$SG231300 DB	'MINOR_APPROACH_WAR_CONQUEST_GRAND_STRATEGY', 00H
	ORG $+1
$SG231301 DB	'MINOR_APPROACH_PROTECTIVE_CONQUEST_GRAND_STRATEGY', 00H
	ORG $+2
$SG231302 DB	'MINOR_APPROACH_FRIENDLY_CONQUEST_GRAND_STRATEGY', 00H
$SG231303 DB	'MINOR_APPROACH_WAR_CONQUEST_GRAND_STRATEGY_NEIGHBORS', 00H
	ORG $+3
$SG231304 DB	'MINOR_APPROACH_WAR_DIPLO_GRAND_STRATEGY', 00H
$SG231305 DB	'MINOR_APPROACH_IGNORE_DIPLO_GRAND_STRATEGY', 00H
	ORG $+1
$SG231306 DB	'MINOR_APPROACH_PROTECTIVE_DIPLO_GRAND_STRATEGY_NEIGHBORS'
	DB	00H
	ORG $+3
$SG231307 DB	'MINOR_APPROACH_WAR_CULTURE_GRAND_STRATEGY', 00H
	ORG $+2
$SG231308 DB	'MINOR_APPROACH_IGNORE_CULTURE_GRAND_STRATEGY', 00H
	ORG $+3
$SG231309 DB	'MINOR_APPROACH_PROTECTIVE_CULTURE_GRAND_STRATEGY_CST', 00H
	ORG $+3
$SG231310 DB	'MINOR_APPROACH_WAR_CURRENTLY_PROTECTIVE', 00H
$SG231311 DB	'MINOR_APPROACH_PROTECTIVE_CURRENTLY_PROTECTIVE', 00H
	ORG $+1
$SG231312 DB	'MINOR_APPROACH_PROTECTIVE_CURRENTLY_WAR', 00H
$SG231313 DB	'MINOR_APPROACH_FRIENDLY_CURRENTLY_WAR', 00H
	ORG $+2
$SG231314 DB	'MINOR_APPROACH_FRIENDLY_RESOURCES', 00H
	ORG $+2
$SG231315 DB	'MINOR_APPROACH_PROTECTIVE_RESOURCES', 00H
$SG231316 DB	'MINOR_APPROACH_WAR_FRIENDS', 00H
	ORG $+1
$SG231317 DB	'MINOR_APPROACH_FRIENDLY_FRIENDS', 00H
$SG231318 DB	'MINOR_APPROACH_PROTECTIVE_FRIENDS', 00H
	ORG $+2
$SG231319 DB	'MINOR_APPROACH_IGNORE_PROXIMITY_NEIGHBORS', 00H
	ORG $+2
$SG231320 DB	'MINOR_APPROACH_FRIENDLY_PROXIMITY_NEIGHBORS', 00H
$SG231321 DB	'MINOR_APPROACH_PROTECTIVE_PROXIMITY_NEIGHBORS', 00H
	ORG $+2
$SG231322 DB	'MINOR_APPROACH_CONQUEST_PROXIMITY_NEIGHBORS', 00H
$SG231323 DB	'MINOR_APPROACH_IGNORE_PROXIMITY_CLOSE', 00H
	ORG $+2
$SG231324 DB	'MINOR_APPROACH_PROTECTIVE_PROXIMITY_CLOSE', 00H
	ORG $+2
$SG231325 DB	'MINOR_APPROACH_CONQUEST_PROXIMITY_CLOSE', 00H
$SG231326 DB	'MINOR_APPROACH_FRIENDLY_PROXIMITY_FAR', 00H
	ORG $+2
$SG231327 DB	'MINOR_APPROACH_CONQUEST_PROXIMITY_FAR', 00H
	ORG $+2
$SG231328 DB	'MINOR_APPROACH_FRIENDLY_PROXIMITY_DISTANT', 00H
	ORG $+2
$SG231329 DB	'MINOR_APPROACH_CONQUEST_PROXIMITY_DISTANT', 00H
	ORG $+2
$SG231330 DB	'MINOR_APPROACH_FRIENDLY_PERSONALITY_FRIENDLY', 00H
	ORG $+3
$SG231331 DB	'MINOR_APPROACH_PROTECTIVE_PERSONALITY_PROTECTIVE', 00H
	ORG $+3
$SG231332 DB	'MINOR_APPROACH_FRIENDLY_PERSONALITY_NEUTRAL', 00H
$SG231333 DB	'MINOR_APPROACH_PROTECTIVE_PERSONALITY_NEUTRAL', 00H
	ORG $+2
$SG231334 DB	'MINOR_APPROACH_FRIENDLY_PERSONALITY_HOSTILE', 00H
$SG231335 DB	'MINOR_APPROACH_PROTECTIVE_PERSONALITY_HOSTILE', 00H
	ORG $+2
$SG231336 DB	'MINOR_APPROACH_CONQUEST_PERSONALITY_HOSTILE', 00H
$SG231337 DB	'MINOR_APPROACH_FRIENDLY_PERSONALITY_IRRATIONAL', 00H
	ORG $+1
$SG231338 DB	'MINOR_APPROACH_PROTECTIVE_PERSONALITY_IRRATIONAL', 00H
	ORG $+3
$SG231339 DB	'MINOR_APPROACH_WAR_PLANNING_WAR_WITH_ANOTHER_PLAYER', 00H
$SG231340 DB	'MINOR_APPROACH_PROTECTIVE_WITH_ANOTHER_PLAYER', 00H
	ORG $+2
$SG231341 DB	'MINOR_APPROACH_WAR_TARGET_IMPOSSIBLE', 00H
	ORG $+3
$SG231342 DB	'MINOR_APPROACH_WAR_TARGET_BAD', 00H
	ORG $+2
$SG231343 DB	'MINOR_APPROACH_WAR_TARGET_AVERAGE', 00H
	ORG $+2
$SG231344 DB	'MINOR_APPROACH_WAR_TARGET_FAVORABLE', 00H
$SG231345 DB	'MINOR_APPROACH_WAR_TARGET_SOFT', 00H
	ORG $+1
$SG231346 DB	'COOPERATION_DESIRE_THRESHOLD_EAGER', 00H
	ORG $+1
$SG231347 DB	'COOPERATION_DESIRE_THRESHOLD_STRONG', 00H
$SG231348 DB	'COOPERATION_DESIRE_THRESHOLD_DECENT', 00H
$SG231349 DB	'COOPERATION_DESIRE_THRESHOLD_WEAK', 00H
	ORG $+2
$SG231350 DB	'COOPERATION_DESIRE_WAR_STATE_CALM', 00H
	ORG $+2
$SG231351 DB	'COOPERATION_DESIRE_WAR_STATE_NEARLY_WON', 00H
$SG231352 DB	'COOPERATION_DESIRE_WAR_STATE_OFFENSIVE', 00H
	ORG $+1
$SG231353 DB	'COOPERATION_DESIRE_WAR_STATE_STALEMATE', 00H
	ORG $+1
$SG231354 DB	'COOPERATION_DESIRE_WAR_STATE_DEFENSIVE', 00H
	ORG $+1
$SG231355 DB	'COOPERATION_DESIRE_WAR_STATE_NEARLY_DEFEATED', 00H
	ORG $+3
$SG231356 DB	'COOPERATION_DESIRE_MILITARY_STRENGTH_IMMENSE', 00H
	ORG $+3
$SG231357 DB	'COOPERATION_DESIRE_MILITARY_STRENGTH_POWERFUL', 00H
	ORG $+2
$SG231358 DB	'COOPERATION_DESIRE_MILITARY_STRENGTH_STRONG', 00H
$SG231359 DB	'COOPERATION_DESIRE_MILITARY_STRENGTH_AVERAGE', 00H
	ORG $+3
$SG231360 DB	'COOPERATION_DESIRE_MILITARY_STRENGTH_POOR', 00H
	ORG $+2
$SG231361 DB	'COOPERATION_DESIRE_MILITARY_STRENGTH_WEAK', 00H
	ORG $+2
$SG231362 DB	'COOPERATION_DESIRE_MILITARY_STRENGTH_PATHETIC', 00H
	ORG $+2
$SG231363 DB	'COOPERATION_DESIRE_OPINION_ALLY', 00H
$SG231364 DB	'COOPERATION_DESIRE_OPINION_FRIEND', 00H
	ORG $+2
$SG231365 DB	'COOPERATION_DESIRE_OPINION_NEUTRAL', 00H
	ORG $+1
$SG231366 DB	'COOPERATION_DESIRE_OPINION_COMPETITOR', 00H
	ORG $+2
$SG231367 DB	'COOPERATION_DESIRE_OPINION_ENEMY', 00H
	ORG $+3
$SG231368 DB	'COOPERATION_DESIRE_GAME_THREAT_CRITICAL', 00H
$SG231369 DB	'COOPERATION_DESIRE_GAME_THREAT_SEVERE', 00H
	ORG $+2
$SG231370 DB	'COOPERATION_DESIRE_GAME_THREAT_MAJOR', 00H
	ORG $+3
$SG231371 DB	'COOPERATION_DESIRE_GAME_THREAT_MINOR', 00H
	ORG $+3
$SG231372 DB	'COOPERATION_DESIRE_GAME_THREAT_NONE', 00H
$SG231373 DB	'COOPERATION_DESIRE_THEM_US_SAME_COMPETITOR', 00H
	ORG $+1
$SG231374 DB	'COOPERATION_DESIRE_THEM_US_COMPETITOR_ENEMY', 00H
$SG231375 DB	'COOPERATION_DESIRE_THEM_US_ENEMY_COMPETITOR', 00H
$SG231376 DB	'COOPERATION_DESIRE_THEM_US_SAME_ENEMY', 00H
	ORG $+2
$SG231377 DB	'EVALUATE_WAR_PLAYER_THRESHOLD', 00H
	ORG $+2
$SG231378 DB	'EVALUATE_WAR_WILLING_TO_DECLARE_THRESHOLD', 00H
	ORG $+2
$SG231379 DB	'EVALUATE_WAR_CONQUEST_GRAND_STRATEGY', 00H
	ORG $+3
$SG231380 DB	'EVALUATE_WAR_NOT_PREPARED', 00H
	ORG $+2
$SG231381 DB	'EVALUATE_WAR_ALREADY_FIGHTING', 00H
	ORG $+2
$SG231382 DB	'EVALUATE_WAR_GAME_THREAT_CRITICAL', 00H
	ORG $+2
$SG231383 DB	'EVALUATE_WAR_GAME_THREAT_SEVERE', 00H
$SG231384 DB	'EVALUATE_WAR_GAME_THREAT_MAJOR', 00H
	ORG $+1
$SG231385 DB	'EVALUATE_WAR_GAME_THREAT_MINOR', 00H
	ORG $+1
$SG231386 DB	'EVALUATE_WAR_GAME_THREAT_NONE', 00H
	ORG $+2
$SG231387 DB	'EVALUATE_WAR_SOFT_TARGET', 00H
	ORG $+3
$SG231388 DB	'EVALUATE_WAR_FAVORABLE_TARGET', 00H
	ORG $+2
$SG231389 DB	'EVALUATE_WAR_AVERAGE_TARGET', 00H
$SG231390 DB	'EVALUATE_WAR_BAD_TARGET', 00H
$SG231391 DB	'EVALUATE_WAR_IMPOSSIBLE_TARGET', 00H
	ORG $+1
$SG231392 DB	'REQUEST_PEACE_TURN_THRESHOLD', 00H
	ORG $+3
$SG231393 DB	'PEACE_WILLINGNESS_OFFER_PROJECTION_DESTRUCTION', 00H
	ORG $+1
$SG231394 DB	'PEACE_WILLINGNESS_OFFER_PROJECTION_DEFEAT', 00H
	ORG $+2
$SG231395 DB	'PEACE_WILLINGNESS_OFFER_PROJECTION_STALEMATE', 00H
	ORG $+3
$SG231396 DB	'PEACE_WILLINGNESS_OFFER_PROJECTION_UNKNOWN', 00H
	ORG $+1
$SG231397 DB	'PEACE_WILLINGNESS_OFFER_PROJECTION_GOOD', 00H
$SG231398 DB	'PEACE_WILLINGNESS_OFFER_PROJECTION_VERY_GOOD', 00H
	ORG $+3
$SG231399 DB	'PEACE_WILLINGNESS_OFFER_WAR_DAMAGE_NONE', 00H
$SG231400 DB	'PEACE_WILLINGNESS_OFFER_WAR_DAMAGE_MINOR', 00H
	ORG $+3
$SG231401 DB	'PEACE_WILLINGNESS_OFFER_WAR_DAMAGE_MAJOR', 00H
	ORG $+3
$SG231402 DB	'PEACE_WILLINGNESS_OFFER_WAR_DAMAGE_SERIOUS', 00H
	ORG $+1
$SG231403 DB	'PEACE_WILLINGNESS_OFFER_WAR_DAMAGE_CRIPPLED', 00H
$SG231404 DB	'PEACE_WILLINGNESS_OFFER_THRESHOLD_UN_SURRENDER', 00H
	ORG $+1
$SG231405 DB	'PEACE_WILLINGNESS_OFFER_THRESHOLD_CAPITULATION', 00H
	ORG $+1
$SG231406 DB	'PEACE_WILLINGNESS_OFFER_THRESHOLD_CESSION', 00H
	ORG $+2
$SG231407 DB	'PEACE_WILLINGNESS_OFFER_THRESHOLD_SURRENDER', 00H
$SG231408 DB	'PEACE_WILLINGNESS_OFFER_THRESHOLD_SUBMISSION', 00H
	ORG $+3
$SG231409 DB	'PEACE_WILLINGNESS_OFFER_THRESHOLD_BACKDOWN', 00H
	ORG $+1
$SG231410 DB	'PEACE_WILLINGNESS_OFFER_THRESHOLD_SETTLEMENT', 00H
	ORG $+3
$SG231411 DB	'PEACE_WILLINGNESS_OFFER_THRESHOLD_ARMISTICE', 00H
$SG231412 DB	'PEACE_WILLINGNESS_ACCEPT_PROJECTION_DESTRUCTION', 00H
$SG231413 DB	'PEACE_WILLINGNESS_ACCEPT_PROJECTION_DEFEAT', 00H
	ORG $+1
$SG231414 DB	'PEACE_WILLINGNESS_ACCEPT_PROJECTION_STALEMATE', 00H
	ORG $+2
$SG231415 DB	'PEACE_WILLINGNESS_ACCEPT_PROJECTION_UNKNOWN', 00H
$SG231416 DB	'PEACE_WILLINGNESS_ACCEPT_PROJECTION_GOOD', 00H
	ORG $+3
$SG231417 DB	'PEACE_WILLINGNESS_ACCEPT_PROJECTION_VERY_GOOD', 00H
	ORG $+2
$SG231418 DB	'PEACE_WILLINGNESS_ACCEPT_TARGET_IMPOSSIBLE', 00H
	ORG $+1
$SG231419 DB	'PEACE_WILLINGNESS_ACCEPT_TARGET_BAD', 00H
$SG231420 DB	'PEACE_WILLINGNESS_ACCEPT_TARGET_AVERAGE', 00H
$SG231421 DB	'PEACE_WILLINGNESS_ACCEPT_TARGET_FAVORABLE', 00H
	ORG $+2
$SG231422 DB	'PEACE_WILLINGNESS_ACCEPT_TARGET_SOFT', 00H
	ORG $+3
$SG231423 DB	'PEACE_WILLINGNESS_ACCEPT_THRESHOLD_UN_SURRENDER', 00H
$SG231424 DB	'PEACE_WILLINGNESS_ACCEPT_THRESHOLD_CAPITULATION', 00H
$SG231425 DB	'PEACE_WILLINGNESS_ACCEPT_THRESHOLD_CESSION', 00H
	ORG $+1
$SG231426 DB	'PEACE_WILLINGNESS_ACCEPT_THRESHOLD_SURRENDER', 00H
	ORG $+3
$SG231427 DB	'PEACE_WILLINGNESS_ACCEPT_THRESHOLD_SUBMISSION', 00H
	ORG $+2
$SG231428 DB	'PEACE_WILLINGNESS_ACCEPT_THRESHOLD_BACKDOWN', 00H
$SG231429 DB	'PEACE_WILLINGNESS_ACCEPT_THRESHOLD_SETTLEMENT', 00H
	ORG $+2
$SG231430 DB	'PEACE_WILLINGNESS_ACCEPT_THRESHOLD_ARMISTICE', 00H
	ORG $+3
$SG231431 DB	'ARMISTICE_GPT_DIVISOR', 00H
	ORG $+2
$SG231432 DB	'ARMISTICE_MIN_GOLD', 00H
	ORG $+1
$SG231433 DB	'WAR_GOAL_THRESHOLD_CONQUEST', 00H
$SG231434 DB	'WAR_GOAL_THRESHOLD_DAMAGE', 00H
	ORG $+2
$SG231435 DB	'WAR_GOAL_THRESHOLD_PEACE', 00H
	ORG $+3
$SG231436 DB	'WAR_GOAL_STATE_CALM', 00H
$SG231437 DB	'WAR_GOAL_STATE_NEARLY_WON', 00H
	ORG $+2
$SG231438 DB	'WAR_GOAL_STATE_OFFENSIVE', 00H
	ORG $+3
$SG231439 DB	'WAR_GOAL_STATE_STALEMATE', 00H
	ORG $+3
$SG231440 DB	'WAR_GOAL_STATE_DEFENSIVE', 00H
	ORG $+3
$SG231441 DB	'WAR_GOAL_STATE_NEARLY_DEFEATED', 00H
	ORG $+1
$SG231442 DB	'WAR_GOAL_ANOTHER_PLAYER_STATE_CALM', 00H
	ORG $+1
$SG231443 DB	'WAR_GOAL_ANOTHER_PLAYER_STATE_NEARLY_WON', 00H
	ORG $+3
$SG231444 DB	'WAR_GOAL_ANOTHER_PLAYER_STATE_OFFENSIVE', 00H
$SG231445 DB	'WAR_GOAL_ANOTHER_PLAYER_STATE_STALEMATE', 00H
$SG231446 DB	'WAR_GOAL_ANOTHER_PLAYER_STATE_DEFENSIVE', 00H
$SG231447 DB	'WAR_GOAL_ANOTHER_PLAYER_STATE_NEARLY_DEFEATED', 00H
	ORG $+2
$SG231448 DB	'WAR_GOAL_DAMAGE_CRIPPLED', 00H
	ORG $+3
$SG231449 DB	'WAR_GOAL_DAMAGE_SERIOUS', 00H
$SG231450 DB	'WAR_GOAL_DAMAGE_MAJOR', 00H
	ORG $+2
$SG231451 DB	'WAR_GOAL_DAMAGE_MINOR', 00H
	ORG $+2
$SG231452 DB	'WAR_GOAL_DAMAGE_NONE', 00H
	ORG $+3
$SG231453 DB	'WAR_GOAL_GAME_THREAT_CRITICAL', 00H
	ORG $+2
$SG231454 DB	'WAR_GOAL_GAME_THREAT_SEVERE', 00H
$SG231455 DB	'WAR_GOAL_GAME_THREAT_MAJOR', 00H
	ORG $+1
$SG231456 DB	'WAR_GOAL_GAME_THREAT_MINOR', 00H
	ORG $+1
$SG231457 DB	'WAR_GOAL_GAME_THREAT_NONE', 00H
	ORG $+2
$SG231458 DB	'WAR_GOAL_TARGET_SOFT', 00H
	ORG $+3
$SG231459 DB	'WAR_GOAL_TARGET_FAVORABLE', 00H
	ORG $+2
$SG231460 DB	'WAR_GOAL_TARGET_AVERAGE', 00H
$SG231461 DB	'WAR_GOAL_TARGET_BAD', 00H
$SG231462 DB	'WAR_GOAL_TARGET_IMPOSSIBLE', 00H
	ORG $+1
$SG231463 DB	'WAR_PROJECTION_THRESHOLD_VERY_GOOD', 00H
	ORG $+1
$SG231464 DB	'WAR_PROJECTION_THRESHOLD_GOOD', 00H
	ORG $+2
$SG231465 DB	'WAR_PROJECTION_THRESHOLD_DESTRUCTION', 00H
	ORG $+3
$SG231466 DB	'WAR_PROJECTION_THRESHOLD_DEFEAT', 00H
$SG231467 DB	'WAR_PROJECTION_THRESHOLD_STALEMATE', 00H
	ORG $+1
$SG231468 DB	'WAR_PROJECTION_THEIR_MILITARY_STRENGTH_PATHETIC', 00H
$SG231469 DB	'WAR_PROJECTION_THEIR_MILITARY_STRENGTH_WEAK', 00H
$SG231470 DB	'WAR_PROJECTION_RECKLESS_EXPANDER', 00H
	ORG $+3
$SG231471 DB	'WAR_PROJECTION_THEIR_MILITARY_STRENGTH_POOR', 00H
$SG231472 DB	'WAR_PROJECTION_THEIR_MILITARY_STRENGTH_AVERAGE', 00H
	ORG $+1
$SG231473 DB	'WAR_PROJECTION_THEIR_MILITARY_STRENGTH_STRONG', 00H
	ORG $+2
$SG231474 DB	'WAR_PROJECTION_THEIR_MILITARY_STRENGTH_POWERFUL', 00H
$SG231475 DB	'WAR_PROJECTION_THEIR_MILITARY_STRENGTH_IMMENSE', 00H
	ORG $+1
$SG231476 DB	'WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_PATHETIC', 00H
$SG231477 DB	'WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_WEAK', 00H
$SG231478 DB	'WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_POOR', 00H
$SG231479 DB	'WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_AVERAGE', 00H
	ORG $+1
$SG231480 DB	'WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_STRONG', 00H
	ORG $+2
$SG231481 DB	'WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_POWERFUL', 00H
$SG231482 DB	'WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_IMMENSE', 00H
	ORG $+1
$SG231483 DB	'WAR_PROJECTION_WAR_DAMAGE_US_NONE', 00H
	ORG $+2
$SG231484 DB	'WAR_PROJECTION_WAR_DAMAGE_US_MINOR', 00H
	ORG $+1
$SG231485 DB	'WAR_PROJECTION_WAR_DAMAGE_US_MAJOR', 00H
	ORG $+1
$SG231486 DB	'WAR_PROJECTION_WAR_DAMAGE_US_SERIOUS', 00H
	ORG $+3
$SG231487 DB	'WAR_PROJECTION_WAR_DAMAGE_US_CRIPPLED', 00H
	ORG $+2
$SG231488 DB	'WAR_PROJECTION_WAR_DAMAGE_THEM_NONE', 00H
$SG231489 DB	'WAR_PROJECTION_WAR_DAMAGE_THEM_MINOR', 00H
	ORG $+3
$SG231490 DB	'WAR_PROJECTION_WAR_DAMAGE_THEM_MAJOR', 00H
	ORG $+3
$SG231491 DB	'WAR_PROJECTION_WAR_DAMAGE_THEM_SERIOUS', 00H
	ORG $+1
$SG231492 DB	'WAR_PROJECTION_WAR_DAMAGE_THEM_CRIPPLED', 00H
$SG231493 DB	'WAR_PROJECTION_WAR_DURATION_SCORE_CAP', 00H
	ORG $+2
$SG231494 DB	'WAR_STATE_CALM_THRESHOLD_FOREIGN_FORCES', 00H
$SG231495 DB	'WAR_STATE_THRESHOLD_NEARLY_WON', 00H
	ORG $+1
$SG231496 DB	'WAR_STATE_THRESHOLD_OFFENSIVE', 00H
	ORG $+2
$SG231497 DB	'WAR_STATE_THRESHOLD_STALEMATE', 00H
	ORG $+2
$SG231498 DB	'WAR_STATE_THRESHOLD_DEFENSIVE', 00H
	ORG $+2
$SG231499 DB	'WAR_DAMAGE_LEVEL_THRESHOLD_CRIPPLED', 00H
$SG231500 DB	'WAR_DAMAGE_LEVEL_THRESHOLD_SERIOUS', 00H
	ORG $+1
$SG231501 DB	'WAR_DAMAGE_LEVEL_THRESHOLD_MAJOR', 00H
	ORG $+3
$SG231502 DB	'WAR_DAMAGE_LEVEL_THRESHOLD_MINOR', 00H
	ORG $+3
$SG231503 DB	'WAR_DAMAGE_LEVEL_CITY_WEIGHT', 00H
	ORG $+3
$SG231504 DB	'WAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER', 00H
	ORG $+2
$SG231505 DB	'WAR_DAMAGE_LEVEL_UNINVOLVED_CITY_POP_MULTIPLIER', 00H
$SG231506 DB	'MILITARY_AGGRESSIVE_POSTURE_THRESHOLD_INCREDIBLE', 00H
	ORG $+3
$SG231507 DB	'MILITARY_AGGRESSIVE_POSTURE_THRESHOLD_HIGH', 00H
	ORG $+1
$SG231508 DB	'MILITARY_AGGRESSIVE_POSTURE_THRESHOLD_MEDIUM', 00H
	ORG $+3
$SG231509 DB	'MILITARY_AGGRESSIVE_POSTURE_THRESHOLD_LOW', 00H
	ORG $+2
$SG231510 DB	'EXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_HIGH', 00H
	ORG $+1
$SG231511 DB	'EXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_MEDIUM', 00H
	ORG $+3
$SG231512 DB	'EXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_LOW', 00H
	ORG $+2
$SG231513 DB	'PLOT_BUYING_POSTURE_INCREDIBLE_THRESHOLD', 00H
	ORG $+3
$SG231514 DB	'PLOT_BUYING_POSTURE_HIGH_THRESHOLD', 00H
	ORG $+1
$SG231515 DB	'PLOT_BUYING_POSTURE_MEDIUM_THRESHOLD', 00H
	ORG $+3
$SG231516 DB	'PLOT_BUYING_POSTURE_LOW_THRESHOLD', 00H
	ORG $+2
$SG231517 DB	'MILITARY_STRENGTH_BASE', 00H
	ORG $+1
$SG231518 DB	'MILITARY_STRENGTH_RATIO_MULTIPLIER', 00H
	ORG $+1
$SG231519 DB	'MILITARY_STRENGTH_CITY_MOD', 00H
	ORG $+1
$SG231520 DB	'MILITARY_STRENGTH_IMMENSE_THRESHOLD', 00H
$SG231521 DB	'MILITARY_STRENGTH_POWERFUL_THRESHOLD', 00H
	ORG $+3
$SG231522 DB	'MILITARY_STRENGTH_STRONG_THRESHOLD', 00H
	ORG $+1
$SG231523 DB	'MILITARY_STRENGTH_AVERAGE_THRESHOLD', 00H
$SG231524 DB	'MILITARY_STRENGTH_POOR_THRESHOLD', 00H
	ORG $+3
$SG231525 DB	'MILITARY_STRENGTH_WEAK_THRESHOLD', 00H
	ORG $+3
$SG231526 DB	'ECONOMIC_STRENGTH_RATIO_MULTIPLIER', 00H
	ORG $+1
$SG231527 DB	'ECONOMIC_STRENGTH_IMMENSE_THRESHOLD', 00H
$SG231528 DB	'ECONOMIC_STRENGTH_POWERFUL_THRESHOLD', 00H
	ORG $+3
$SG231529 DB	'ECONOMIC_STRENGTH_STRONG_THRESHOLD', 00H
	ORG $+1
$SG231530 DB	'ECONOMIC_STRENGTH_AVERAGE_THRESHOLD', 00H
$SG231531 DB	'ECONOMIC_STRENGTH_POOR_THRESHOLD', 00H
	ORG $+3
$SG231532 DB	'ECONOMIC_STRENGTH_WEAK_THRESHOLD', 00H
	ORG $+3
$SG231533 DB	'TARGET_IMPOSSIBLE_THRESHOLD', 00H
$SG231534 DB	'TARGET_BAD_THRESHOLD', 00H
	ORG $+3
$SG231535 DB	'TARGET_AVERAGE_THRESHOLD', 00H
	ORG $+3
$SG231536 DB	'TARGET_FAVORABLE_THRESHOLD', 00H
	ORG $+1
$SG231537 DB	'TARGET_INCREASE_WAR_TURNS', 00H
	ORG $+2
$SG231538 DB	'TARGET_MILITARY_STRENGTH_IMMENSE', 00H
	ORG $+3
$SG231539 DB	'TARGET_MILITARY_STRENGTH_POWERFUL', 00H
	ORG $+2
$SG231540 DB	'TARGET_MILITARY_STRENGTH_STRONG', 00H
$SG231541 DB	'TARGET_MILITARY_STRENGTH_AVERAGE', 00H
	ORG $+3
$SG231542 DB	'TARGET_MILITARY_STRENGTH_POOR', 00H
	ORG $+2
$SG231543 DB	'TARGET_MILITARY_STRENGTH_WEAK', 00H
	ORG $+2
$SG231544 DB	'TARGET_MILITARY_STRENGTH_PATHETIC', 00H
	ORG $+2
$SG231545 DB	'TARGET_ALREADY_WAR_EACH_PLAYER', 00H
	ORG $+1
$SG231546 DB	'TARGET_NEIGHBORS', 00H
	ORG $+3
$SG231547 DB	'TARGET_CLOSE', 00H
	ORG $+3
$SG231548 DB	'TARGET_FAR', 00H
	ORG $+1
$SG231549 DB	'TARGET_DISTANT', 00H
	ORG $+1
$SG231550 DB	'TARGET_MINOR_BACKUP_PATHETIC', 00H
	ORG $+3
$SG231551 DB	'TARGET_MINOR_BACKUP_WEAK', 00H
	ORG $+3
$SG231552 DB	'TARGET_MINOR_BACKUP_POOR', 00H
	ORG $+3
$SG231553 DB	'TARGET_MINOR_BACKUP_AVERAGE', 00H
$SG231554 DB	'TARGET_MINOR_BACKUP_STRONG', 00H
	ORG $+1
$SG231555 DB	'TARGET_MINOR_BACKUP_POWERFUL', 00H
	ORG $+3
$SG231556 DB	'TARGET_MINOR_BACKUP_IMMENSE', 00H
$SG231557 DB	'TARGET_MINOR_BACKUP_DISTANT', 00H
$SG231558 DB	'TARGET_MINOR_BACKUP_FAR', 00H
$SG231559 DB	'TARGET_MINOR_BACKUP_CLOSE', 00H
	ORG $+2
$SG231560 DB	'TARGET_MINOR_BACKUP_NEIGHBORS', 00H
	ORG $+2
$SG231561 DB	'GAME_THREAT_CRITICAL_THRESHOLD', 00H
	ORG $+1
$SG231562 DB	'GAME_THREAT_SEVERE_THRESHOLD', 00H
	ORG $+3
$SG231563 DB	'GAME_THREAT_MAJOR_THRESHOLD', 00H
$SG231564 DB	'GAME_THREAT_MINOR_THRESHOLD', 00H
$SG231565 DB	'GAME_THREAT_AT_WAR_STALEMATE', 00H
	ORG $+3
$SG231566 DB	'GAME_THREAT_AT_WAR_DEFENSIVE', 00H
	ORG $+3
$SG231567 DB	'GAME_THREAT_AT_WAR_NEARLY_DEFEATED', 00H
	ORG $+1
$SG231568 DB	'GAME_THREAT_AT_WAR_MILITARY_STRENGTH_IMMENSE', 00H
	ORG $+3
$SG231569 DB	'GAME_THREAT_AT_WAR_MILITARY_STRENGTH_POWERFUL', 00H
	ORG $+2
$SG231570 DB	'GAME_THREAT_AT_WAR_MILITARY_STRENGTH_STRONG', 00H
$SG231571 DB	'GAME_THREAT_AT_WAR_MILITARY_STRENGTH_AVERAGE', 00H
	ORG $+3
$SG231572 DB	'GAME_THREAT_GUESS_AT_WAR', 00H
	ORG $+3
$SG231573 DB	'GAME_THREAT_GUESS_AT_WAR_MILITARY_STRENGTH_IMMENSE', 00H
	ORG $+1
$SG231574 DB	'GAME_THREAT_GUESS_AT_WAR_MILITARY_STRENGTH_POWERFUL', 00H
$SG231575 DB	'GAME_THREAT_GUESS_AT_WAR_MILITARY_STRENGTH_STRONG', 00H
	ORG $+2
$SG231576 DB	'GAME_THREAT_GUESS_AT_WAR_MILITARY_STRENGTH_AVERAGE', 00H
	ORG $+1
$SG231577 DB	'MILITARY_THREAT_CRITICAL_THRESHOLD', 00H
	ORG $+1
$SG231578 DB	'MILITARY_THREAT_SEVERE_THRESHOLD', 00H
	ORG $+3
$SG231579 DB	'MILITARY_THREAT_MAJOR_THRESHOLD', 00H
$SG231580 DB	'MILITARY_THREAT_MINOR_THRESHOLD', 00H
$SG231581 DB	'MILITARY_THREAT_STRENGTH_IMMENSE', 00H
	ORG $+3
$SG231582 DB	'MILITARY_THREAT_STRENGTH_POWERFUL', 00H
	ORG $+2
$SG231583 DB	'MILITARY_THREAT_STRENGTH_STRONG', 00H
$SG231584 DB	'MILITARY_THREAT_STRENGTH_AVERAGE', 00H
	ORG $+3
$SG231585 DB	'MILITARY_THREAT_STRENGTH_POOR', 00H
	ORG $+2
$SG231586 DB	'MILITARY_THREAT_STRENGTH_WEAK', 00H
	ORG $+2
$SG231587 DB	'MILITARY_THREAT_STRENGTH_PATHETIC', 00H
	ORG $+2
$SG231588 DB	'MILITARY_THREAT_WAR_STATE_CALM', 00H
	ORG $+1
$SG231589 DB	'MILITARY_THREAT_WAR_STATE_NEARLY_WON', 00H
	ORG $+3
$SG231590 DB	'MILITARY_THREAT_WAR_STATE_OFFENSIVE', 00H
$SG231591 DB	'MILITARY_THREAT_WAR_STATE_STALEMATE', 00H
$SG231592 DB	'MILITARY_THREAT_WAR_STATE_DEFENSIVE', 00H
$SG231593 DB	'MILITARY_THREAT_WAR_STATE_NEARLY_DEFEATED', 00H
	ORG $+2
$SG231594 DB	'MILITARY_THREAT_NEIGHBORS', 00H
	ORG $+2
$SG231595 DB	'MILITARY_THREAT_CLOSE', 00H
	ORG $+2
$SG231596 DB	'MILITARY_THREAT_FAR', 00H
$SG231597 DB	'MILITARY_THREAT_DISTANT', 00H
$SG231598 DB	'MILITARY_THREAT_PER_MINOR_ATTACKED', 00H
	ORG $+1
$SG231599 DB	'MILITARY_THREAT_PER_MINOR_CONQUERED', 00H
$SG231600 DB	'MILITARY_THREAT_PER_MAJOR_ATTACKED', 00H
	ORG $+1
$SG231601 DB	'MILITARY_THREAT_PER_MAJOR_CONQUERED', 00H
$SG231602 DB	'MILITARY_THREAT_ALREADY_WAR_EACH_PLAYER_MULTIPLIER', 00H
	ORG $+1
$SG231603 DB	'WARMONGER_THREAT_CRITICAL_THRESHOLD', 00H
$SG231604 DB	'WARMONGER_THREAT_SEVERE_THRESHOLD', 00H
	ORG $+2
$SG231605 DB	'WARMONGER_THREAT_MAJOR_THRESHOLD', 00H
	ORG $+3
$SG231606 DB	'WARMONGER_THREAT_MINOR_THRESHOLD', 00H
	ORG $+3
$SG231607 DB	'WARMONGER_THREAT_MINOR_ATTACKED_WEIGHT', 00H
	ORG $+1
$SG231608 DB	'WARMONGER_THREAT_MINOR_CONQUERED_WEIGHT', 00H
$SG231609 DB	'WARMONGER_THREAT_MAJOR_ATTACKED_WEIGHT', 00H
	ORG $+1
$SG231610 DB	'WARMONGER_THREAT_MAJOR_CONQUERED_WEIGHT', 00H
$SG231611 DB	'WARMONGER_THREAT_PER_TURN_DECAY', 00H
$SG231612 DB	'WARMONGER_THREAT_PERSONALITY_MOD', 00H
	ORG $+3
$SG231613 DB	'WARMONGER_THREAT_CRITICAL_PERCENT_THRESHOLD', 00H
$SG231614 DB	'WARMONGER_THREAT_SEVERE_PERCENT_THRESHOLD', 00H
	ORG $+2
$SG231615 DB	'WARMONGER_ON_CITY_STATE_MULTIPLIER', 00H
	ORG $+1
$SG231616 DB	'LAND_DISPUTE_FIERCE_THRESHOLD', 00H
	ORG $+2
$SG231617 DB	'LAND_DISPUTE_STRONG_THRESHOLD', 00H
	ORG $+2
$SG231618 DB	'LAND_DISPUTE_WEAK_THRESHOLD', 00H
$SG231619 DB	'VICTORY_DISPUTE_FIERCE_THRESHOLD', 00H
	ORG $+3
$SG231620 DB	'VICTORY_DISPUTE_STRONG_THRESHOLD', 00H
	ORG $+3
$SG231621 DB	'VICTORY_DISPUTE_WEAK_THRESHOLD', 00H
	ORG $+1
$SG231622 DB	'WONDER_DISPUTE_FIERCE_THRESHOLD', 00H
$SG231623 DB	'WONDER_DISPUTE_STRONG_THRESHOLD', 00H
$SG231624 DB	'WONDER_DISPUTE_WEAK_THRESHOLD', 00H
	ORG $+2
$SG231625 DB	'MINOR_CIV_DISPUTE_FIERCE_THRESHOLD', 00H
	ORG $+1
$SG231626 DB	'MINOR_CIV_DISPUTE_STRONG_THRESHOLD', 00H
	ORG $+1
$SG231627 DB	'MINOR_CIV_DISPUTE_WEAK_THRESHOLD', 00H
	ORG $+3
$SG231628 DB	'MINOR_CIV_DISPUTE_ALLIES_WEIGHT', 00H
$SG231629 DB	'MINOR_CIV_DISPUTE_FRIENDS_WEIGHT', 00H
	ORG $+3
$SG231630 DB	'LAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_NONE', 00H
	ORG $+3
$SG231631 DB	'LAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_LOW', 00H
$SG231632 DB	'LAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_MEDIUM', 00H
	ORG $+1
$SG231633 DB	'LAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_HIGH', 00H
	ORG $+3
$SG231634 DB	'LAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_INCREDIBLE', 00H
	ORG $+1
$SG231635 DB	'LAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_NONE', 00H
	ORG $+2
$SG231636 DB	'LAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_LOW', 00H
	ORG $+3
$SG231637 DB	'LAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_MEDIUM', 00H
$SG231638 DB	'LAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_HIGH', 00H
	ORG $+2
$SG231639 DB	'LAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_INCREDIBLE', 00H
$SG231640 DB	'LAND_DISPUTE_DISTANT', 00H
	ORG $+3
$SG231641 DB	'LAND_DISPUTE_FAR', 00H
	ORG $+3
$SG231642 DB	'LAND_DISPUTE_CLOSE', 00H
	ORG $+1
$SG231643 DB	'LAND_DISPUTE_NEIGHBORS', 00H
	ORG $+1
$SG231644 DB	'LAND_DISPUTE_CRAMPED_MULTIPLIER', 00H
$SG231645 DB	'LAND_DISPUTE_NO_EXPANSION_STRATEGY', 00H
	ORG $+1
$SG231646 DB	'VICTORY_DISPUTE_GRAND_STRATEGY_MATCH_POSITIVE', 00H
	ORG $+2
$SG231647 DB	'VICTORY_DISPUTE_GRAND_STRATEGY_MATCH_LIKELY', 00H
$SG231648 DB	'VICTORY_DISPUTE_GRAND_STRATEGY_MATCH_UNSURE', 00H
$SG231649 DB	'LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_10', 00H
	ORG $+1
$SG231650 DB	'LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_9', 00H
	ORG $+2
$SG231651 DB	'LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_8', 00H
	ORG $+2
$SG231652 DB	'LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_7', 00H
	ORG $+2
$SG231653 DB	'LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_6', 00H
	ORG $+2
$SG231654 DB	'LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_5', 00H
	ORG $+2
$SG231655 DB	'LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_4', 00H
	ORG $+2
$SG231656 DB	'LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_3', 00H
	ORG $+2
$SG231657 DB	'LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_2', 00H
	ORG $+2
$SG231658 DB	'VICTORY_DISPUTE_OTHER_PLAYER_FIERCE_THRESHOLD', 00H
	ORG $+2
$SG231659 DB	'VICTORY_DISPUTE_OTHER_PLAYER_STRONG_THRESHOLD', 00H
	ORG $+2
$SG231660 DB	'VICTORY_DISPUTE_OTHER_PLAYER_WEAK_THRESHOLD', 00H
$SG231661 DB	'VICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_POSITI'
	DB	'VE', 00H
	ORG $+1
$SG231662 DB	'VICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_LIKELY'
	DB	00H
	ORG $+3
$SG231663 DB	'VICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_UNSURE'
	DB	00H
	ORG $+3
$SG231664 DB	'IC_MEMORY_TURN_EXPIRATION', 00H
	ORG $+2
$SG231665 DB	'STOP_SPYING_MEMORY_TURN_EXPIRATION', 00H
	ORG $+1
$SG231666 DB	'COOP_WAR_SOON_COUNTER', 00H
	ORG $+2
$SG231667 DB	'COOP_WAR_LOCKED_TURNS', 00H
	ORG $+2
$SG231668 DB	'COOP_WAR_LOCKED_TURNS_WAR_WEIGHT', 00H
	ORG $+3
$SG231669 DB	'DEMAND_TURN_LIMIT_MIN', 00H
	ORG $+2
$SG231670 DB	'DEMAND_TURN_LIMIT_RAND', 00H
	ORG $+1
$SG231671 DB	'DONT_SETTLE_RAND', 00H
	ORG $+3
$SG231672 DB	'DONT_SETTLE_FLAVOR_BASE', 00H
$SG231673 DB	'DONT_SETTLE_FLAVOR_MULTIPLIER', 00H
	ORG $+2
$SG231674 DB	'DONT_SETTLE_FRIENDLY', 00H
	ORG $+3
$SG231675 DB	'DONT_SETTLE_STRENGTH_PATHETIC', 00H
	ORG $+2
$SG231676 DB	'DONT_SETTLE_STRENGTH_WEAK', 00H
	ORG $+2
$SG231677 DB	'DONT_SETTLE_STRENGTH_POOR', 00H
	ORG $+2
$SG231678 DB	'DONT_SETTLE_STRENGTH_AVERAGE', 00H
	ORG $+3
$SG231679 DB	'DONT_SETTLE_STRENGTH_STRONG', 00H
$SG231680 DB	'DONT_SETTLE_STRENGTH_POWERFUL', 00H
	ORG $+2
$SG231681 DB	'DONT_SETTLE_STRENGTH_IMMENSE', 00H
	ORG $+3
$SG231682 DB	'DONT_SETTLE_MOD_MILITARY_POSTURE_NONE', 00H
	ORG $+2
$SG231683 DB	'DONT_SETTLE_MOD_MILITARY_POSTURE_LOW', 00H
	ORG $+3
$SG231684 DB	'DONT_SETTLE_MOD_MILITARY_POSTURE_MEDIUM', 00H
$SG231685 DB	'DONT_SETTLE_MOD_MILITARY_POSTURE_HIGH', 00H
	ORG $+2
$SG231686 DB	'DONT_SETTLE_MOD_MILITARY_POSTURE_INCREDIBLE', 00H
$SG231687 DB	'DOF_TURN_BUFFER', 00H
$SG231688 DB	'DOF_THRESHOLD', 00H
	ORG $+2
$SG231689 DB	'DENUNCIATION_EXPIRATION_TIME', 00H
	ORG $+3
$SG231690 DB	'DOF_EXPIRATION_TIME', 00H
$SG231691 DB	'EACH_GOLD_VALUE_PERCENT', 00H
$SG231692 DB	'EACH_GOLD_PER_TURN_VALUE_PERCENT', 00H
	ORG $+3
$SG231693 DB	'EXPANSION_BICKER_TIMEOUT', 00H
	ORG $+3
$SG231694 DB	'EXPANSION_PROMISE_TURNS_EFFECTIVE', 00H
	ORG $+2
$SG231695 DB	'EXPANSION_PROMISE_BROKEN_PER_TURN_DECAY', 00H
$SG231696 DB	'BROKEN_EXPANSION_PROMISE_PER_OPINION_WEIGHT', 00H
$SG231697 DB	'OPINION_WEIGHT_EXPANSION_PROMISE_BROKE_MAX', 00H
	ORG $+1
$SG231698 DB	'EXPANSION_PROMISE_IGNORED_PER_TURN_DECAY', 00H
	ORG $+3
$SG231699 DB	'IGNORED_EXPANSION_PROMISE_PER_OPINION_WEIGHT', 00H
	ORG $+3
$SG231700 DB	'OPINION_WEIGHT_EXPANSION_PROMISE_IGNORED_MAX', 00H
	ORG $+3
$SG231701 DB	'BORDER_PROMISE_TURNS_EFFECTIVE', 00H
	ORG $+1
$SG231702 DB	'BORDER_PROMISE_BROKEN_PER_TURN_DECAY', 00H
	ORG $+3
$SG231703 DB	'BROKEN_BORDER_PROMISE_PER_OPINION_WEIGHT', 00H
	ORG $+3
$SG231704 DB	'OPINION_WEIGHT_BORDER_PROMISE_BROKE_MAX', 00H
$SG231705 DB	'BORDER_PROMISE_IGNORED_PER_TURN_DECAY', 00H
	ORG $+2
$SG231706 DB	'IGNORED_BORDER_PROMISE_PER_OPINION_WEIGHT', 00H
	ORG $+2
$SG231707 DB	'OPINION_WEIGHT_BORDER_PROMISE_IGNORED_MAX', 00H
	ORG $+2
$SG231708 DB	'DECLARED_WAR_ON_FRIEND_PER_TURN_DECAY', 00H
	ORG $+2
$SG231709 DB	'DECLARED_WAR_ON_FRIEND_PER_OPINION_WEIGHT', 00H
	ORG $+2
$SG231710 DB	'DEAL_VALUE_PER_TURN_DECAY', 00H
	ORG $+2
$SG231711 DB	'DEAL_VALUE_PER_OPINION_WEIGHT', 00H
	ORG $+2
$SG231712 DB	'COMMON_FOE_VALUE_PER_TURN_DECAY', 00H
$SG231713 DB	'COMMON_FOE_VALUE_PER_OPINION_WEIGHT', 00H
$SG231714 DB	'WANT_RESEARCH_AGREEMENT_RAND', 00H
	ORG $+3
$SG231715 DB	'DEMAND_RAND', 00H
$SG231716 DB	'CAN_WORK_WATER_FROM_GAME_START', 00H
	ORG $+1
$SG231717 DB	'NAVAL_PLOT_BLOCKADE_RANGE', 00H
	ORG $+2
$SG231718 DB	'EVENT_MESSAGE_TIME', 00H
	ORG $+1
$SG231719 DB	'START_YEAR', 00H
	ORG $+1
$SG231720 DB	'WEEKS_PER_MONTHS', 00H
	ORG $+3
$SG231721 DB	'HIDDEN_START_TURN_OFFSET', 00H
	ORG $+3
$SG231722 DB	'RECON_VISIBILITY_RANGE', 00H
	ORG $+1
$SG231723 DB	'PLOT_VISIBILITY_RANGE', 00H
	ORG $+2
$SG231724 DB	'UNIT_VISIBILITY_RANGE', 00H
	ORG $+2
$SG231725 DB	'AIR_UNIT_REBASE_RANGE_MULTIPLIER', 00H
	ORG $+3
$SG231726 DB	'MOUNTAIN_SEE_FROM_CHANGE', 00H
	ORG $+3
$SG231727 DB	'MOUNTAIN_SEE_THROUGH_CHANGE', 00H
$SG231728 DB	'HILLS_SEE_FROM_CHANGE', 00H
	ORG $+2
$SG231729 DB	'HILLS_SEE_THROUGH_CHANGE', 00H
	ORG $+3
$SG231730 DB	'SEAWATER_SEE_FROM_CHANGE', 00H
	ORG $+3
$SG231731 DB	'SEAWATER_SEE_THROUGH_CHANGE', 00H
$SG231732 DB	'MAX_YIELD_STACK', 00H
$SG231733 DB	'MOVE_DENOMINATOR', 00H
	ORG $+3
$SG231734 DB	'STARTING_DISTANCE_PERCENT', 00H
	ORG $+2
$SG231735 DB	'MIN_CIV_STARTING_DISTANCE', 00H
	ORG $+2
$SG231736 DB	'MIN_CITY_RANGE', 00H
	ORG $+1
$SG231737 DB	'OWNERSHIP_SCORE_DURATION_THRESHOLD', 00H
	ORG $+1
$SG231738 DB	'NUM_POLICY_BRANCHES_ALLOWED', 00H
$SG231739 DB	'VICTORY_POINTS_NEEDED_TO_WIN', 00H
	ORG $+3
$SG231740 DB	'NUM_VICTORY_POINT_AWARDS', 00H
	ORG $+3
$SG231741 DB	'NUM_OR_TECH_PREREQS', 00H
$SG231742 DB	'NUM_AND_TECH_PREREQS', 00H
	ORG $+3
$SG231743 DB	'NUM_UNIT_AND_TECH_PREREQS', 00H
	ORG $+2
$SG231744 DB	'NUM_BUILDING_AND_TECH_PREREQS', 00H
	ORG $+2
$SG231745 DB	'NUM_BUILDING_RESOURCE_PREREQS', 00H
	ORG $+2
$SG231746 DB	'BASE_RESEARCH_RATE', 00H
	ORG $+1
$SG231747 DB	'MAX_WORLD_WONDERS_PER_CITY', 00H
	ORG $+1
$SG231748 DB	'MAX_TEAM_WONDERS_PER_CITY', 00H
	ORG $+2
$SG231749 DB	'MAX_NATIONAL_WONDERS_PER_CITY', 00H
	ORG $+2
$SG231750 DB	'MAX_NATIONAL_WONDERS_PER_CITY_FOR_OCC', 00H
	ORG $+2
$SG231751 DB	'MAX_BUILDINGS_PER_CITY', 00H
	ORG $+1
$SG231752 DB	'INITIAL_CITY_POPULATION', 00H
$SG231753 DB	'BASE_CITY_AIR_STACKING', 00H
	ORG $+1
$SG231754 DB	'CITY_CAPTURE_POPULATION_PERCENT', 00H
$SG231755 DB	'BASE_CITY_GROWTH_THRESHOLD', 00H
	ORG $+1
$SG231756 DB	'FOOD_CONSUMPTION_PER_POPULATION', 00H
$SG231757 DB	'HAPPINESS_PER_CITY_WITH_STATE_RELIGION', 00H
	ORG $+1
$SG231758 DB	'HAPPINESS_PER_NATURAL_WONDER', 00H
	ORG $+3
$SG231759 DB	'HAPPINESS_PER_EXTRA_LUXURY', 00H
	ORG $+1
$SG231760 DB	'UNHAPPINESS_PER_POPULATION', 00H
	ORG $+1
$SG231761 DB	'UNHAPPINESS_PER_OCCUPIED_POPULATION', 00H
$SG231762 DB	'UNHAPPINESS_PER_CITY', 00H
	ORG $+3
$SG231763 DB	'UNHAPPINESS_PER_CAPTURED_CITY', 00H
	ORG $+2
$SG231764 DB	'UNHAPPY_GROWTH_PENALTY', 00H
	ORG $+1
$SG231765 DB	'VERY_UNHAPPY_GROWTH_PENALTY', 00H
$SG231766 DB	'VERY_UNHAPPY_CANT_TRAIN_SETTLERS', 00H
	ORG $+3
$SG231767 DB	'VERY_UNHAPPY_THRESHOLD', 00H
	ORG $+1
$SG231768 DB	'SUPER_UNHAPPY_THRESHOLD', 00H
$SG231769 DB	'UPRISING_COUNTER_MIN', 00H
	ORG $+3
$SG231770 DB	'UPRISING_COUNTER_POSSIBLE', 00H
	ORG $+2
$SG231771 DB	'UPRISING_NUM_BASE', 00H
	ORG $+2
$SG231772 DB	'UPRISING_NUM_CITY_COUNT', 00H
$SG231773 DB	'REVOLT_COUNTER_MIN', 00H
	ORG $+1
$SG231774 DB	'VERY_UNHAPPY_COMBAT_PENALTY_PER_UNHAPPY', 00H
$SG231775 DB	'VERY_UNHAPPY_MAX_COMBAT_PENALTY', 00H
$SG231776 DB	'STRATEGIC_RESOURCE_EXHAUSTED_PENALTY', 00H
	ORG $+3
$SG231777 DB	'VERY_UNHAPPY_PRODUCTION_PENALTY_PER_UNHAPPY', 00H
$SG231778 DB	'VERY_UNHAPPY_MAX_PRODUCTION_PENALTY', 00H
$SG231779 DB	'VERY_UNHAPPY_GOLD_PENALTY_PER_UNHAPPY', 00H
	ORG $+2
$SG231780 DB	'VERY_UNHAPPY_MAX_GOLD_PENALTY', 00H
	ORG $+2
$SG231781 DB	'WLTKD_GROWTH_MULTIPLIER', 00H
$SG231782 DB	'INDUSTRIAL_ROUTE_PRODUCTION_MOD', 00H
$SG231783 DB	'RESOURCE_DEMAND_COUNTDOWN_BASE', 00H
	ORG $+1
$SG231784 DB	'RESOURCE_DEMAND_COUNTDOWN_CAPITAL_ADD', 00H
	ORG $+2
$SG231785 DB	'RESOURCE_DEMAND_COUNTDOWN_RAND', 00H
	ORG $+1
$SG231786 DB	'NEW_HURRY_MODIFIER', 00H
	ORG $+1
$SG231787 DB	'GREAT_GENERAL_RANGE', 00H
$SG231788 DB	'GREAT_GENERAL_STRENGTH_MOD', 00H
	ORG $+1
$SG231789 DB	'BONUS_PER_ADJACENT_FRIEND', 00H
	ORG $+2
$SG231790 DB	'POLICY_ATTACK_BONUS_MOD', 00H
$SG231791 DB	'CONSCRIPT_MIN_CITY_POPULATION', 00H
	ORG $+2
$SG231792 DB	'CONSCRIPT_POPULATION_PER_COST', 00H
	ORG $+2
$SG231793 DB	'MIN_TIMER_UNIT_DOUBLE_MOVES', 00H
$SG231794 DB	'COMBAT_DAMAGE', 00H
	ORG $+2
$SG231795 DB	'NONCOMBAT_UNIT_RANGED_DAMAGE', 00H
	ORG $+3
$SG231796 DB	'NAVAL_COMBAT_DEFENDER_STRENGTH_MULTIPLIER', 00H
	ORG $+2
$SG231797 DB	'LAKE_PLOT_RAND', 00H
	ORG $+1
$SG231798 DB	'PLOTS_PER_RIVER_EDGE', 00H
	ORG $+3
$SG231799 DB	'RIVER_SOURCE_MIN_RIVER_RANGE', 00H
	ORG $+3
$SG231800 DB	'RIVER_SOURCE_MIN_SEAWATER_RANGE', 00H
$SG231801 DB	'LAKE_MAX_AREA_SIZE', 00H
	ORG $+1
$SG231802 DB	'INITIAL_GOLD_PER_UNIT_TIMES_100', 00H
$SG231803 DB	'INITIAL_FREE_OUTSIDE_UNITS', 00H
	ORG $+1
$SG231804 DB	'INITIAL_OUTSIDE_UNIT_GOLD_PERCENT', 00H
	ORG $+2
$SG231805 DB	'UNIT_MAINTENANCE_GAME_MULTIPLIER', 00H
	ORG $+3
$SG231806 DB	'UNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR', 00H
	ORG $+1
$SG231807 DB	'FREE_UNIT_HAPPINESS', 00H
$SG231808 DB	'TRADE_ROUTE_BASE_GOLD', 00H
	ORG $+2
$SG231809 DB	'TRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER', 00H
$SG231810 DB	'TRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER', 00H
	ORG $+3
$SG231811 DB	'DEFICIT_UNIT_DISBANDING_THRESHOLD', 00H
	ORG $+2
$SG231812 DB	'GOLDEN_AGE_BASE_THRESHOLD_HAPPINESS', 00H
$SG231813 DB	'GOLDEN_AGE_THRESHOLD_CITY_MULTIPLIER', 00H
	ORG $+3
$SG231814 DB	'GOLDEN_AGE_EACH_GA_ADDITIONAL_HAPPINESS', 00H
$SG231815 DB	'GOLDEN_AGE_VISIBLE_THRESHOLD_DIVISOR', 00H
	ORG $+3
$SG231816 DB	'BASE_GOLDEN_AGE_UNITS', 00H
	ORG $+2
$SG231817 DB	'GOLDEN_AGE_UNITS_MULTIPLIER', 00H
$SG231818 DB	'GOLDEN_AGE_LENGTH', 00H
	ORG $+2
$SG231819 DB	'GOLDEN_AGE_GREAT_PEOPLE_MODIFIER', 00H
	ORG $+3
$SG231820 DB	'MIN_UNIT_GOLDEN_AGE_TURNS', 00H
	ORG $+2
$SG231821 DB	'GOLDEN_AGE_CULTURE_MODIFIER', 00H
$SG231822 DB	'HILLS_EXTRA_MOVEMENT', 00H
	ORG $+3
$SG231823 DB	'RIVER_EXTRA_MOVEMENT', 00H
	ORG $+3
$SG231824 DB	'FEATURE_GROWTH_MODIFIER', 00H
$SG231825 DB	'ROUTE_FEATURE_GROWTH_MODIFIER', 00H
	ORG $+2
$SG231826 DB	'EXTRA_YIELD', 00H
$SG231827 DB	'FORTIFY_MODIFIER_PER_TURN', 00H
	ORG $+2
$SG231828 DB	'MAX_FORTIFY_TURNS', 00H
	ORG $+2
$SG231829 DB	'NUKE_FALLOUT_PROB', 00H
	ORG $+2
$SG231830 DB	'NUKE_UNIT_DAMAGE_BASE', 00H
	ORG $+2
$SG231831 DB	'NUKE_UNIT_DAMAGE_RAND_1', 00H
$SG231832 DB	'NUKE_UNIT_DAMAGE_RAND_2', 00H
$SG231833 DB	'NUKE_NON_COMBAT_DEATH_THRESHOLD', 00H
$SG231834 DB	'NUKE_LEVEL1_POPULATION_DEATH_BASE', 00H
	ORG $+2
$SG231835 DB	'NUKE_LEVEL1_POPULATION_DEATH_RAND_1', 00H
$SG231836 DB	'NUKE_LEVEL1_POPULATION_DEATH_RAND_2', 00H
$SG231837 DB	'NUKE_LEVEL2_POPULATION_DEATH_BASE', 00H
	ORG $+2
$SG231838 DB	'NUKE_LEVEL2_POPULATION_DEATH_RAND_1', 00H
$SG231839 DB	'NUKE_LEVEL2_POPULATION_DEATH_RAND_2', 00H
$SG231840 DB	'NUKE_LEVEL2_ELIM_POPULATION_THRESHOLD', 00H
	ORG $+2
$SG231841 DB	'NUKE_CITY_HIT_POINT_DAMAGE', 00H
	ORG $+1
$SG231842 DB	'NUKE_BLAST_RADIUS', 00H
	ORG $+2
$SG231843 DB	'TECH_COST_EXTRA_TEAM_MEMBER_MODIFIER', 00H
	ORG $+3
$SG231844 DB	'TECH_COST_TOTAL_KNOWN_TEAM_MODIFIER', 00H
$SG231845 DB	'TECH_COST_KNOWN_PREREQ_MODIFIER', 00H
$SG231846 DB	'PEACE_TREATY_LENGTH', 00H
$SG231847 DB	'COOP_WAR_LOCKED_LENGTH', 00H
	ORG $+1
$SG231848 DB	'BASE_FEATURE_PRODUCTION_PERCENT', 00H
$SG231849 DB	'FEATURE_PRODUCTION_PERCENT_MULTIPLIER', 00H
	ORG $+2
$SG231850 DB	'DIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT', 00H
	ORG $+2
$SG231851 DB	'DEFAULT_WAR_VALUE_FOR_UNIT', 00H
	ORG $+1
$SG231852 DB	'UNIT_PRODUCTION_PERCENT', 00H
$SG231853 DB	'MAX_UNIT_SUPPLY_PRODMOD', 00H
$SG231854 DB	'BUILDING_PRODUCTION_PERCENT', 00H
$SG231855 DB	'PROJECT_PRODUCTION_PERCENT', 00H
	ORG $+1
$SG231856 DB	'MAXED_UNIT_GOLD_PERCENT', 00H
$SG231857 DB	'MAXED_BUILDING_GOLD_PERCENT', 00H
$SG231858 DB	'MAXED_PROJECT_GOLD_PERCENT', 00H
	ORG $+1
$SG231859 DB	'MAX_CITY_DEFENSE_DAMAGE', 00H
$SG231860 DB	'CIRCUMNAVIGATE_FREE_MOVES', 00H
	ORG $+2
$SG231861 DB	'BASE_CAPTURE_GOLD', 00H
	ORG $+2
$SG231862 DB	'CAPTURE_GOLD_PER_POPULATION', 00H
$SG231863 DB	'CAPTURE_GOLD_RAND1', 00H
	ORG $+1
$SG231864 DB	'CAPTURE_GOLD_RAND2', 00H
	ORG $+1
$SG231865 DB	'CAPTURE_GOLD_MAX_TURNS', 00H
	ORG $+1
$SG231866 DB	'BARBARIAN_CITY_ATTACK_MODIFIER', 00H
	ORG $+1
$SG231867 DB	'BUILDING_PRODUCTION_DECAY_TIME', 00H
	ORG $+1
$SG231868 DB	'BUILDING_PRODUCTION_DECAY_PERCENT', 00H
	ORG $+2
$SG231869 DB	'UNIT_PRODUCTION_DECAY_TIME', 00H
	ORG $+1
$SG231870 DB	'UNIT_PRODUCTION_DECAY_PERCENT', 00H
	ORG $+2
$SG231871 DB	'BASE_UNIT_UPGRADE_COST', 00H
	ORG $+1
$SG231872 DB	'UNIT_UPGRADE_COST_PER_PRODUCTION', 00H
	ORG $+3
$SG231873 DB	'UNIT_UPGRADE_COST_VISIBLE_DIVISOR', 00H
	ORG $+2
$SG231874 DB	'UNIT_UPGRADE_COST_DISCOUNT_MAX', 00H
	ORG $+1
$SG231875 DB	'WAR_SUCCESS_UNIT_CAPTURING', 00H
	ORG $+1
$SG231876 DB	'WAR_SUCCESS_CITY_CAPTURING', 00H
	ORG $+1
$SG231877 DB	'DIPLO_VOTE_SECRETARY_GENERAL_INTERVAL', 00H
	ORG $+2
$SG231878 DB	'TEAM_VOTE_MIN_CANDIDATES', 00H
	ORG $+3
$SG231879 DB	'RESEARCH_AGREEMENT_TIMER', 00H
	ORG $+3
$SG231880 DB	'RESEARCH_AGREEMENT_BOOST_DIVISOR', 00H
	ORG $+3
$SG231881 DB	'SCORE_POPULATION_FACTOR', 00H
$SG231882 DB	'SCORE_LAND_FACTOR', 00H
	ORG $+2
$SG231883 DB	'SCORE_WONDER_FACTOR', 00H
$SG231884 DB	'SCORE_TECH_FACTOR', 00H
	ORG $+2
$SG231885 DB	'SCORE_FREE_PERCENT', 00H
	ORG $+1
$SG231886 DB	'SCORE_VICTORY_PERCENT', 00H
	ORG $+2
$SG231887 DB	'SCORE_HANDICAP_PERCENT_OFFSET', 00H
	ORG $+2
$SG231888 DB	'SCORE_HANDICAP_PERCENT_PER', 00H
	ORG $+1
$SG231889 DB	'MINIMAP_RENDER_SIZE', 00H
$SG231890 DB	'MAX_INTERCEPTION_PROBABILITY', 00H
	ORG $+3
$SG231891 DB	'MAX_EVASION_PROBABILITY', 00H
$SG231892 DB	'PLAYER_ALWAYS_RAZES_CITIES', 00H
	ORG $+1
$SG231893 DB	'MIN_WATER_SIZE_FOR_OCEAN', 00H
	ORG $+3
$SG231894 DB	'CITY_SCREEN_CLICK_WILL_EXIT', 00H
$SG231895 DB	'WATER_POTENTIAL_CITY_WORK_FOR_AREA', 00H
	ORG $+1
$SG231896 DB	'LAND_UNITS_CAN_ATTACK_WATER_CITIES', 00H
	ORG $+1
$SG231897 DB	'CITY_MAX_NUM_BUILDINGS', 00H
	ORG $+1
$SG231898 DB	'CITY_MIN_SIZE_FOR_SETTLERS', 00H
	ORG $+1
$SG231899 DB	'RANGED_ATTACKS_USE_MOVES', 00H
	ORG $+3
$SG231900 DB	'ADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES', 00H
	ORG $+2
$SG231901 DB	'ADVANCED_START_MAX_UNITS_PER_CITY', 00H
	ORG $+2
$SG231902 DB	'ADVANCED_START_CITY_COST', 00H
	ORG $+3
$SG231903 DB	'ADVANCED_START_CITY_COST_INCREASE', 00H
	ORG $+2
$SG231904 DB	'ADVANCED_START_POPULATION_COST', 00H
	ORG $+1
$SG231905 DB	'ADVANCED_START_POPULATION_COST_INCREASE', 00H
$SG231906 DB	'ADVANCED_START_VISIBILITY_COST', 00H
	ORG $+1
$SG231907 DB	'ADVANCED_START_VISIBILITY_COST_INCREASE', 00H
$SG231908 DB	'ADVANCED_START_CITY_PLACEMENT_MAX_RANGE', 00H
$SG231909 DB	'NEW_CITY_BUILDING_VALUE_MODIFIER', 00H
	ORG $+3
$SG231910 DB	'PATH_DAMAGE_WEIGHT', 00H
	ORG $+1
$SG231911 DB	'PUPPET_SCIENCE_MODIFIER', 00H
$SG231912 DB	'PUPPET_CULTURE_MODIFIER', 00H
$SG231913 DB	'PUPPET_GOLD_MODIFIER', 00H
	ORG $+3
$SG231914 DB	'PUPPET_FAITH_MODIFIER', 00H
	ORG $+2
$SG231915 DB	'BASE_POLICY_COST', 00H
	ORG $+3
$SG231916 DB	'POLICY_COST_INCREASE_TO_BE_EXPONENTED', 00H
	ORG $+2
$SG231917 DB	'POLICY_COST_VISIBLE_DIVISOR', 00H
$SG231918 DB	'SWITCH_POLICY_BRANCHES_ANARCHY_TURNS', 00H
	ORG $+3
$SG231919 DB	'SWITCH_POLICY_BRANCHES_TENETS_LOST', 00H
	ORG $+1
$SG231920 DB	'POLICY_COST_DISCOUNT_MAX', 00H
	ORG $+3
$SG231921 DB	'GOLD_PURCHASE_GOLD_PER_PRODUCTION', 00H
	ORG $+2
$SG231922 DB	'GOLD_PURCHASE_VISIBLE_DIVISOR', 00H
	ORG $+2
$SG231923 DB	'PROJECT_PURCHASING_DISABLED', 00H
$SG231924 DB	'INFLUENCE_MOUNTAIN_COST', 00H
$SG231925 DB	'INFLUENCE_HILL_COST', 00H
$SG231926 DB	'INFLUENCE_RIVER_COST', 00H
	ORG $+3
$SG231927 DB	'USE_FIRST_RING_INFLUENCE_TERRAIN_COST', 00H
	ORG $+2
$SG231928 DB	'NUM_RESOURCE_QUANTITY_TYPES', 00H
$SG231929 DB	'SPECIALISTS_DIVERT_POPULATION_ENABLED', 00H
	ORG $+2
$SG231930 DB	'SCIENCE_PER_POPULATION', 00H
	ORG $+1
$SG231931 DB	'RESEARCH_AGREEMENT_MOD', 00H
	ORG $+1
$SG231932 DB	'BARBARIAN_CAMP_FIRST_TURN_PERCENT_OF_TARGET_TO_ADD', 00H
	ORG $+1
$SG231933 DB	'BARBARIAN_CAMP_ODDS_OF_NEW_CAMP_SPAWNING', 00H
	ORG $+3
$SG231934 DB	'BARBARIAN_CAMP_MINIMUM_DISTANCE_CAPITAL', 00H
$SG231935 DB	'BARBARIAN_CAMP_MINIMUM_DISTANCE_ANOTHER_CAMP', 00H
	ORG $+3
$SG231936 DB	'BARBARIAN_CAMP_COASTAL_SPAWN_ROLL', 00H
	ORG $+2
$SG231937 DB	'BARBARIAN_EXTRA_RAGING_UNIT_SPAWN_CHANCE', 00H
	ORG $+3
$SG231938 DB	'BARBARIAN_NAVAL_UNIT_START_TURN_SPAWN', 00H
	ORG $+2
$SG231939 DB	'MAX_BARBARIANS_FROM_CAMP_NEARBY', 00H
$SG231940 DB	'MAX_BARBARIANS_FROM_CAMP_NEARBY_RANGE', 00H
	ORG $+2
$SG231941 DB	'GOLD_FROM_BARBARIAN_CONVERSION', 00H
	ORG $+1
$SG231942 DB	'BARBARIAN_CITY_GOLD_RANSOM', 00H
	ORG $+1
$SG231943 DB	'BARBARIAN_UNIT_GOLD_RANSOM', 00H
	ORG $+1
$SG231944 DB	'EMBARKED_UNIT_MOVEMENT', 00H
	ORG $+1
$SG231945 DB	'EMBARKED_VISIBILITY_RANGE', 00H
	ORG $+2
$SG231946 DB	'DEFAULT_MAX_NUM_BUILDERS', 00H
	ORG $+3
$SG231947 DB	'BARBARIAN_TECH_PERCENT', 00H
	ORG $+1
$SG231948 DB	'CITY_RESOURCE_WLTKD_TURNS', 00H
	ORG $+2
$SG231949 DB	'MAX_SPECIALISTS_FROM_BUILDING', 00H
	ORG $+2
$SG231950 DB	'GREAT_PERSON_THRESHOLD_BASE', 00H
$SG231951 DB	'GREAT_PERSON_THRESHOLD_INCREASE', 00H
$SG231952 DB	'CULTURE_BOMB_COOLDOWN', 00H
	ORG $+2
$SG231953 DB	'CULTURE_BOMB_MINOR_FRIENDSHIP_CHANGE', 00H
	ORG $+3
$SG231954 DB	'LANDMARK_MINOR_FRIENDSHIP_CHANGE', 00H
	ORG $+3
$SG231955 DB	'UNIT_AUTO_EXPLORE_DISABLED', 00H
	ORG $+1
$SG231956 DB	'UNIT_AUTO_EXPLORE_FULL_DISABLED', 00H
$SG231957 DB	'UNIT_WORKER_AUTOMATION_DISABLED', 00H
$SG231958 DB	'UNIT_DELETE_DISABLED', 00H
	ORG $+3
$SG231959 DB	'MIN_START_AREA_TILES', 00H
	ORG $+3
$SG231960 DB	'MIN_DISTANCE_OTHER_AREA_PERCENT', 00H
$SG231961 DB	'MINOR_CIV_FOOD_REQUIREMENT', 00H
	ORG $+1
$SG231962 DB	'MAJOR_CIV_FOOD_REQUIREMENT', 00H
	ORG $+1
$SG231963 DB	'MIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST', 00H
	ORG $+3
$SG231964 DB	'START_AREA_FOOD_MULTIPLIER', 00H
	ORG $+1
$SG231965 DB	'START_AREA_HAPPINESS_MULTIPLIER', 00H
$SG231966 DB	'START_AREA_PRODUCTION_MULTIPLIER', 00H
	ORG $+3
$SG231967 DB	'START_AREA_GOLD_MULTIPLIER', 00H
	ORG $+1
$SG231968 DB	'START_AREA_SCIENCE_MULTIPLIER', 00H
	ORG $+2
$SG231969 DB	'START_AREA_FAITH_MULTIPLIER', 00H
$SG231970 DB	'START_AREA_RESOURCE_MULTIPLIER', 00H
	ORG $+1
$SG231971 DB	'START_AREA_STRATEGIC_MULTIPLIER', 00H
$SG231972 DB	'START_AREA_BUILD_ON_COAST_PERCENT', 00H
	ORG $+2
$SG231973 DB	'SETTLER_FOOD_MULTIPLIER', 00H
$SG231974 DB	'SETTLER_HAPPINESS_MULTIPLIER', 00H
	ORG $+3
$SG231975 DB	'SETTLER_PRODUCTION_MULTIPLIER', 00H
	ORG $+2
$SG231976 DB	'SETTLER_GOLD_MULTIPLIER', 00H
$SG231977 DB	'SETTLER_SCIENCE_MULTIPLIER', 00H
	ORG $+1
$SG231978 DB	'SETTLER_FAITH_MULTIPLIER', 00H
	ORG $+3
$SG231979 DB	'SETTLER_RESOURCE_MULTIPLIER', 00H
$SG231980 DB	'SETTLER_STRATEGIC_MULTIPLIER', 00H
	ORG $+3
$SG231981 DB	'SETTLER_BUILD_ON_COAST_PERCENT', 00H
	ORG $+1
$SG231982 DB	'CITY_RING_1_MULTIPLIER', 00H
	ORG $+1
$SG231983 DB	'CITY_RING_2_MULTIPLIER', 00H
	ORG $+1
$SG231984 DB	'CITY_RING_3_MULTIPLIER', 00H
	ORG $+1
$SG231985 DB	'CITY_RING_4_MULTIPLIER', 00H
	ORG $+1
$SG231986 DB	'CITY_RING_5_MULTIPLIER', 00H
	ORG $+1
$SG231987 DB	'SETTLER_EVALUATION_DISTANCE', 00H
$SG231988 DB	'SETTLER_DISTANCE_DROPOFF_MODIFIER', 00H
	ORG $+2
$SG231989 DB	'BUILD_ON_RESOURCE_PERCENT', 00H
	ORG $+2
$SG231990 DB	'BUILD_ON_RIVER_PERCENT', 00H
	ORG $+1
$SG231991 DB	'CHOKEPOINT_STRATEGIC_VALUE', 00H
	ORG $+1
$SG231992 DB	'HILL_STRATEGIC_VALUE', 00H
	ORG $+3
$SG231993 DB	'ALREADY_OWNED_STRATEGIC_VALUE', 00H
	ORG $+2
$SG231994 DB	'MINOR_CIV_CONTACT_GOLD_FIRST', 00H
	ORG $+3
$SG231995 DB	'MINOR_CIV_CONTACT_GOLD_OTHER', 00H
	ORG $+3
$SG231996 DB	'MINOR_CIV_GROWTH_PERCENT', 00H
	ORG $+3
$SG231997 DB	'MINOR_CIV_PRODUCTION_PERCENT', 00H
	ORG $+3
$SG231998 DB	'MINOR_CIV_GOLD_PERCENT', 00H
	ORG $+1
$SG231999 DB	'MINOR_CIV_TECH_PERCENT', 00H
	ORG $+1
$SG232000 DB	'MINOR_POLICY_RESOURCE_MULTIPLIER', 00H
	ORG $+3
$SG232001 DB	'MINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER', 00H
	ORG $+1
$SG232002 DB	'MINOR_GOLD_GIFT_LARGE', 00H
	ORG $+2
$SG232003 DB	'MINOR_GOLD_GIFT_MEDIUM', 00H
	ORG $+1
$SG232004 DB	'MINOR_GOLD_GIFT_SMALL', 00H
	ORG $+2
$SG232005 DB	'MINOR_CIV_TILE_IMPROVEMENT_GIFT_COST', 00H
	ORG $+3
$SG232006 DB	'MINOR_CIV_BUYOUT_COST', 00H
	ORG $+2
$SG232007 DB	'MINOR_CIV_BUYOUT_TURNS', 00H
	ORG $+1
$SG232008 DB	'MINOR_FRIENDSHIP_FROM_TRADE_MISSION', 00H
$SG232009 DB	'MINOR_FRIENDSHIP_ANCHOR_DEFAULT', 00H
$SG232010 DB	'MINOR_FRIENDSHIP_ANCHOR_MOD_PROTECTED', 00H
	ORG $+2
$SG232011 DB	'MINOR_FRIENDSHIP_ANCHOR_MOD_WARY_OF', 00H
$SG232012 DB	'MINOR_UNIT_GIFT_TRAVEL_TURNS', 00H
	ORG $+3
$SG232013 DB	'PLOT_UNIT_LIMIT', 00H
$SG232014 DB	'ZONE_OF_CONTROL_ENABLED', 00H
$SG232015 DB	'FIRE_SUPPORT_DISABLED', 00H
	ORG $+2
$SG232016 DB	'MAX_HIT_POINTS', 00H
	ORG $+1
$SG232017 DB	'MAX_CITY_HIT_POINTS', 00H
$SG232018 DB	'CITY_HIT_POINTS_HEALED_PER_TURN', 00H
$SG232019 DB	'FLAT_LAND_EXTRA_DEFENSE', 00H
$SG232020 DB	'HILLS_EXTRA_DEFENSE', 00H
$SG232021 DB	'RIVER_ATTACK_MODIFIER', 00H
	ORG $+2
$SG232022 DB	'AMPHIB_ATTACK_MODIFIER', 00H
	ORG $+1
$SG232023 DB	'ENEMY_HEAL_RATE', 00H
$SG232024 DB	'NEUTRAL_HEAL_RATE', 00H
	ORG $+2
$SG232025 DB	'FRIENDLY_HEAL_RATE', 00H
	ORG $+1
$SG232026 DB	'INSTA_HEAL_RATE', 00H
$SG232027 DB	'CITY_HEAL_RATE', 00H
	ORG $+1
$SG232028 DB	'ATTACK_SAME_STRENGTH_MIN_DAMAGE', 00H
$SG232029 DB	'RANGE_ATTACK_RANGED_DEFENDER_MOD', 00H
	ORG $+3
$SG232030 DB	'ATTACK_SAME_STRENGTH_POSSIBLE_EXTRA_DAMAGE', 00H
	ORG $+1
$SG232031 DB	'RANGE_ATTACK_SAME_STRENGTH_MIN_DAMAGE', 00H
	ORG $+2
$SG232032 DB	'RANGE_ATTACK_SAME_STRENGTH_POSSIBLE_EXTRA_DAMAGE', 00H
	ORG $+3
$SG232033 DB	'AIR_STRIKE_SAME_STRENGTH_MIN_DEFENSE_DAMAGE', 00H
$SG232034 DB	'AIR_STRIKE_SAME_STRENGTH_POSSIBLE_EXTRA_DEFENSE_DAMAGE', 00H
	ORG $+1
$SG232035 DB	'INTERCEPTION_SAME_STRENGTH_MIN_DAMAGE', 00H
	ORG $+2
$SG232036 DB	'INTERCEPTION_SAME_STRENGTH_POSSIBLE_EXTRA_DAMAGE', 00H
	ORG $+3
$SG232037 DB	'AIR_SWEEP_INTERCEPTION_DAMAGE_MOD', 00H
	ORG $+2
$SG232038 DB	'WOUNDED_DAMAGE_MULTIPLIER', 00H
	ORG $+2
$SG232039 DB	'TRAIT_WOUNDED_DAMAGE_MOD', 00H
	ORG $+3
$SG232040 DB	'CITY_STRENGTH_DEFAULT', 00H
	ORG $+2
$SG232041 DB	'CITY_STRENGTH_POPULATION_CHANGE', 00H
$SG232042 DB	'CITY_STRENGTH_UNIT_DIVISOR', 00H
	ORG $+1
$SG232043 DB	'CITY_STRENGTH_HILL_CHANGE', 00H
	ORG $+2
$SG232044 DB	'CITY_ATTACKING_DAMAGE_MOD', 00H
	ORG $+2
$SG232045 DB	'ATTACKING_CITY_MELEE_DAMAGE_MOD', 00H
$SG232046 DB	'CITY_ATTACK_RANGE', 00H
	ORG $+2
$SG232047 DB	'CAN_CITY_USE_INDIRECT_FIRE', 00H
	ORG $+1
$SG232048 DB	'CITY_RANGED_ATTACK_STRENGTH_MULTIPLIER', 00H
	ORG $+1
$SG232049 DB	'MIN_CITY_STRIKE_DAMAGE', 00H
	ORG $+1
$SG232050 DB	'CITY_CAPTURE_DAMAGE_PERCENT', 00H
$SG232051 DB	'EXPERIENCE_PER_LEVEL', 00H
	ORG $+3
$SG232052 DB	'EXPERIENCE_ATTACKING_UNIT_MELEE', 00H
$SG232053 DB	'EXPERIENCE_DEFENDING_UNIT_MELEE', 00H
$SG232054 DB	'EXPERIENCE_ATTACKING_UNIT_AIR', 00H
	ORG $+2
$SG232055 DB	'EXPERIENCE_DEFENDING_UNIT_AIR', 00H
	ORG $+2
$SG232056 DB	'EXPERIENCE_ATTACKING_UNIT_RANGED', 00H
	ORG $+3
$SG232057 DB	'EXPERIENCE_DEFENDING_UNIT_RANGED', 00H
	ORG $+3
$SG232058 DB	'EXPERIENCE_ATTACKING_AIR_SWEEP', 00H
	ORG $+1
$SG232059 DB	'EXPERIENCE_DEFENDING_AIR_SWEEP_AIR', 00H
	ORG $+1
$SG232060 DB	'EXPERIENCE_DEFENDING_AIR_SWEEP_GROUND', 00H
	ORG $+2
$SG232061 DB	'EXPERIENCE_ATTACKING_CITY_MELEE', 00H
$SG232062 DB	'EXPERIENCE_ATTACKING_CITY_RANGED', 00H
	ORG $+3
$SG232063 DB	'EXPERIENCE_ATTACKING_CITY_AIR', 00H
	ORG $+2
$SG232064 DB	'BARBARIAN_MAX_XP_VALUE', 00H
	ORG $+1
$SG232065 DB	'COMBAT_EXPERIENCE_IN_BORDERS_PERCENT', 00H
	ORG $+3
$SG232066 DB	'GREAT_GENERALS_THRESHOLD_INCREASE', 00H
	ORG $+2
$SG232067 DB	'GREAT_GENERALS_THRESHOLD_INCREASE_TEAM', 00H
	ORG $+1
$SG232068 DB	'GREAT_GENERALS_THRESHOLD', 00H
	ORG $+3
$SG232069 DB	'UNIT_DEATH_XP_GREAT_GENERAL_LOSS', 00H
	ORG $+3
$SG232070 DB	'MIN_EXPERIENCE_PER_COMBAT', 00H
	ORG $+2
$SG232071 DB	'MAX_EXPERIENCE_PER_COMBAT', 00H
	ORG $+2
$SG232072 DB	'CRAMPED_RANGE_FROM_CITY', 00H
$SG232073 DB	'CRAMPED_USABLE_PLOT_PERCENT', 00H
$SG232074 DB	'PROXIMITY_NEIGHBORS_CLOSEST_CITY_REQUIREMENT', 00H
	ORG $+3
$SG232075 DB	'PROXIMITY_CLOSE_CLOSEST_CITY_POSSIBILITY', 00H
	ORG $+3
$SG232076 DB	'PROXIMITY_CLOSE_DISTANCE_MAP_MULTIPLIER', 00H
$SG232077 DB	'PROXIMITY_CLOSE_DISTANCE_MAX', 00H
	ORG $+3
$SG232078 DB	'PROXIMITY_CLOSE_DISTANCE_MIN', 00H
	ORG $+3
$SG232079 DB	'PROXIMITY_FAR_DISTANCE_MAP_MULTIPLIER', 00H
	ORG $+2
$SG232080 DB	'PROXIMITY_FAR_DISTANCE_MAX', 00H
	ORG $+1
$SG232081 DB	'PROXIMITY_FAR_DISTANCE_MIN', 00H
	ORG $+1
$SG232082 DB	'PLOT_BASE_COST', 00H
	ORG $+1
$SG232083 DB	'PLOT_ADDITIONAL_COST_PER_PLOT', 00H
	ORG $+2
$SG232084 DB	'PLOT_COST_APPEARANCE_DIVISOR', 00H
	ORG $+3
$SG232085 DB	'CULTURE_COST_FIRST_PLOT', 00H
$SG232086 DB	'CULTURE_COST_LATER_PLOT_MULTIPLIER', 00H
	ORG $+1
$SG232087 DB	'CULTURE_COST_VISIBLE_DIVISOR', 00H
	ORG $+3
$SG232088 DB	'CULTURE_PLOT_COST_MOD_MINIMUM', 00H
	ORG $+2
$SG232089 DB	'MINOR_CIV_PLOT_CULTURE_COST_MULTIPLIER', 00H
	ORG $+1
$SG232090 DB	'MAXIMUM_BUY_PLOT_DISTANCE', 00H
	ORG $+2
$SG232091 DB	'MAXIMUM_ACQUIRE_PLOT_DISTANCE', 00H
	ORG $+2
$SG232092 DB	'PLOT_INFLUENCE_BASE_MULTIPLIER', 00H
	ORG $+1
$SG232093 DB	'PLOT_INFLUENCE_DISTANCE_MULTIPLIER', 00H
	ORG $+1
$SG232094 DB	'PLOT_INFLUENCE_DISTANCE_DIVISOR', 00H
$SG232095 DB	'PLOT_INFLUENCE_RING_COST', 00H
	ORG $+3
$SG232096 DB	'PLOT_INFLUENCE_WATER_COST', 00H
	ORG $+2
$SG232097 DB	'PLOT_INFLUENCE_IMPROVEMENT_COST', 00H
$SG232098 DB	'PLOT_INFLUENCE_ROUTE_COST', 00H
	ORG $+2
$SG232099 DB	'PLOT_INFLUENCE_RESOURCE_COST', 00H
	ORG $+3
$SG232100 DB	'PLOT_INFLUENCE_NW_COST', 00H
	ORG $+1
$SG232101 DB	'PLOT_BUY_RESOURCE_COST', 00H
	ORG $+1
$SG232102 DB	'PLOT_BUY_YIELD_COST', 00H
$SG232103 DB	'PLOT_INFLUENCE_YIELD_POINT_COST', 00H
$SG232104 DB	'PLOT_INFLUENCE_NO_ADJACENT_OWNED_COST', 00H
	ORG $+2
$SG232105 DB	'UNITED_NATIONS_COUNTDOWN_TURNS', 00H
	ORG $+1
$SG232106 DB	'OWN_UNITED_NATIONS_VOTE_BONUS', 00H
	ORG $+2
$SG232107 DB	'DIPLO_VICTORY_ALGORITHM_THRESHOLD', 00H
	ORG $+2
$SG232108 DB	'DIPLO_VICTORY_BEYOND_ALGORITHM_MULTIPLIER', 00H
	ORG $+2
$SG232109 DB	'DIPLO_VICTORY_DEFAULT_VOTE_PERCENT', 00H
	ORG $+1
$SG232110 DB	'SCORE_CITY_MULTIPLIER', 00H
	ORG $+2
$SG232111 DB	'SCORE_POPULATION_MULTIPLIER', 00H
$SG232112 DB	'SCORE_LAND_MULTIPLIER', 00H
	ORG $+2
$SG232113 DB	'SCORE_WONDER_MULTIPLIER', 00H
$SG232114 DB	'SCORE_TECH_MULTIPLIER', 00H
	ORG $+2
$SG232115 DB	'SCORE_FUTURE_TECH_MULTIPLIER', 00H
	ORG $+3
$SG232116 DB	'SCORE_POLICY_MULTIPLIER', 00H
$SG232117 DB	'SCORE_GREAT_WORK_MULTIPLIER', 00H
$SG232118 DB	'SCORE_BELIEF_MULTIPLIER', 00H
$SG232119 DB	'SCORE_RELIGION_CITIES_MULTIPLIER', 00H
	ORG $+3
$SG232120 DB	'VICTORY_POINTS_PER_ERA', 00H
	ORG $+1
$SG232121 DB	'MIN_GAME_TURNS_ELAPSED_TO_TEST_VICTORY', 00H
	ORG $+1
$SG232122 DB	'ZERO_SUM_COMPETITION_WONDERS_VICTORY_POINTS', 00H
$SG232123 DB	'ZERO_SUM_COMPETITION_POLICIES_VICTORY_POINTS', 00H
	ORG $+3
$SG232124 DB	'ZERO_SUM_COMPETITION_GREAT_PEOPLE_VICTORY_POINTS', 00H
	ORG $+3
$SG232125 DB	'MAX_CITY_DIST_HIGHWATER_MARK', 00H
	ORG $+3
$SG232126 DB	'HEAVY_RESOURCE_THRESHOLD', 00H
	ORG $+3
$SG232127 DB	'PROGRESS_POPUP_TURN_FREQUENCY', 00H
	ORG $+2
$SG232128 DB	'SETTLER_PRODUCTION_SPEED', 00H
	ORG $+3
$SG232129 DB	'BUY_PLOTS_DISABLED', 00H
	ORG $+1
$SG232130 DB	'CITY_STRENGTH_TECH_MULTIPLIER', 00H
	ORG $+2
$SG232131 DB	'WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT', 00H
	ORG $+2
$SG232132 DB	'BUILDING_SALE_DIVISOR', 00H
	ORG $+2
$SG232133 DB	'DISBAND_UNIT_REFUND_PERCENT', 00H
$SG232134 DB	'MINOR_CIV_ROUTE_QUEST_WEIGHT', 00H
	ORG $+3
$SG232135 DB	'WITHDRAW_MOD_ENEMY_MOVES', 00H
	ORG $+3
$SG232136 DB	'WITHDRAW_MOD_BLOCKED_TILE', 00H
	ORG $+2
$SG232137 DB	'AI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT', 00H
	ORG $+3
$SG232138 DB	'AI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY', 00H
	ORG $+3
$SG232139 DB	'DIPLO_VICTORY_CIV_DELEGATES_COEFFICIENT', 00H
$SG232140 DB	'DIPLO_VICTORY_CIV_DELEGATES_CONSTANT', 00H
	ORG $+3
$SG232141 DB	'DIPLO_VICTORY_CS_DELEGATES_COEFFICIENT', 00H
	ORG $+1
$SG232142 DB	'DIPLO_VICTORY_CS_DELEGATES_CONSTANT', 00H
$SG232143 DB	'AI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT', 00H
	ORG $+1
$SG232144 DB	'AI_PRODUCTION_WEIGHT_BASE_MOD', 00H
	ORG $+2
$SG232145 DB	'AI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT', 00H
	ORG $+3
$SG232146 DB	'AI_RESEARCH_WEIGHT_BASE_MOD', 00H
$SG232147 DB	'HURRY_GOLD_PRODUCTION_EXPONENT', 00H
	ORG $+1
$SG232148 DB	'CITY_ZOOM_LEVEL_1', 00H
	ORG $+2
$SG232149 DB	'CITY_ZOOM_LEVEL_2', 00H
	ORG $+2
$SG232150 DB	'CITY_ZOOM_LEVEL_3', 00H
	ORG $+2
$SG232151 DB	'CITY_ZOOM_OFFSET', 00H
	ORG $+3
$SG232152 DB	'CULTURE_COST_LATER_PLOT_EXPONENT', 00H
	ORG $+3
$SG232153 DB	'POST_COMBAT_TEXT_DELAY', 00H
	ORG $+1
$SG232154 DB	'AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_NEXT_WONDER', 00H
	ORG $+3
$SG232155 DB	'AI_DANGER_MAJOR_APPROACH_WAR', 00H
	ORG $+3
$SG232156 DB	'AI_DANGER_MAJOR_APPROACH_HOSTILE', 00H
	ORG $+3
$SG232157 DB	'AI_DANGER_MAJOR_APPROACH_DECEPTIVE', 00H
	ORG $+1
$SG232158 DB	'AI_DANGER_MAJOR_APPROACH_GUARDED', 00H
	ORG $+3
$SG232159 DB	'AI_DANGER_MAJOR_APPROACH_AFRAID', 00H
$SG232160 DB	'AI_DANGER_MAJOR_APPROACH_FRIENDLY', 00H
	ORG $+2
$SG232161 DB	'AI_DANGER_MAJOR_APPROACH_NEUTRAL', 00H
	ORG $+3
$SG232162 DB	'AI_DANGER_MINOR_APPROACH_NEUTRAL', 00H
	ORG $+3
$SG232163 DB	'AI_DANGER_MINOR_APPROACH_FRIENDLY', 00H
	ORG $+2
$SG232164 DB	'AI_DANGER_MINOR_APPROACH_BULLY', 00H
	ORG $+1
$SG232165 DB	'AI_DANGER_MINOR_APPROACH_CONQUEST', 00H
	ORG $+2
$SG232166 DB	'FLAVOR_STANDARD_LOG10_TILES_PER_PLAYER', 00H
	ORG $+1
$SG232167 DB	'DIPLO_VICTORY_TEAM_MULTIPLIER', 00H
	ORG $+2
$SG232168 DB	'AI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION', 00H
	ORG $+3
$SG232169 DB	'AI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY', 00H
	ORG $+1
$SG232170 DB	'AI_STRATEGY_NAVAL_UNITS_PER_CITY', 00H
	ORG $+3
$SG232171 DB	'GOLD_GIFT_FRIENDSHIP_EXPONENT', 00H
	ORG $+2
$SG232172 DB	'GOLD_GIFT_FRIENDSHIP_DIVISOR', 00H
	ORG $+3
$SG232173 DB	'HURRY_GOLD_TECH_EXPONENT', 00H
	ORG $+3
$SG232174 DB	'HURRY_GOLD_CULTURE_EXPONENT', 00H
$SG232175 DB	'CITY_GROWTH_MULTIPLIER', 00H
	ORG $+1
$SG232176 DB	'CITY_GROWTH_EXPONENT', 00H
	ORG $+3
$SG232177 DB	'POLICY_COST_EXPONENT', 00H
	ORG $+3
$SG232178 DB	'UNIT_UPGRADE_COST_MULTIPLIER_PER_ERA', 00H
	ORG $+3
$SG232179 DB	'UNIT_UPGRADE_COST_EXPONENT', 00H
	ORG $+1
$SG232180 DB	'CITY_STRENGTH_TECH_BASE', 00H
$SG232181 DB	'CITY_STRENGTH_TECH_EXPONENT', 00H
$SG232182 DB	'ESPIONAGE_COUP_NOBODY_BONUS', 00H
$SG232183 DB	'ESPIONAGE_COUP_MULTIPLY_CONSTANT', 00H
	ORG $+3
$SG232184 DB	'ESPIONAGE_COUP_SPY_LEVEL_DELTA_ZERO', 00H
$SG232185 DB	'ESPIONAGE_COUP_SPY_LEVEL_DELTA_ONE', 00H
	ORG $+1
$SG232186 DB	'ESPIONAGE_COUP_SPY_LEVEL_DELTA_TWO', 00H
	ORG $+1
$SG232187 DB	'ESPIONAGE_COUP_SPY_LEVEL_DELTA_THREE', 00H
	ORG $+3
$SG232188 DB	'ESPIONAGE_COUP_SPY_LEVEL_DELTA_FOUR', 00H
$SG232189 DB	'INTERNATIONAL_TRADE_BASE', 00H
	ORG $+3
$SG232190 DB	'INTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION', 00H
	ORG $+3
$SG232191 DB	'INTERNATIONAL_TRADE_CITY_GPT_DIVISOR', 00H
	ORG $+3
$SG232192 DB	'PILLAGE_HEAL_AMOUNT', 00H
$SG232193 DB	'CITY_CONNECTIONS_CONNECT_TO_CAPITAL', 00H
$SG232194 DB	'UNRESEARCHED_TECH_BONUS_FROM_KILLS_SLOPE', 00H
	ORG $+3
$SG232195 DB	'UNRESEARCHED_TECH_BONUS_FROM_KILLS_INTERCEPT', 00H
	ORG $+3
$SG232196 DB	'BASE_CULTURE_PER_GREAT_WORK', 00H
$SG232197 DB	'BASE_TOURISM_PER_GREAT_WORK', 00H
$SG232198 DB	'TOURISM_MODIFIER_SHARED_RELIGION', 00H
	ORG $+3
$SG232199 DB	'TOURISM_MODIFIER_TRADE_ROUTE', 00H
	ORG $+3
$SG232200 DB	'TOURISM_MODIFIER_OPEN_BORDERS', 00H
	ORG $+2
$SG232201 DB	'TOURISM_MODIFIER_DIFFERENT_IDEOLOGIES', 00H
	ORG $+2
$SG232202 DB	'TOURISM_MODIFIER_DIPLOMAT', 00H
	ORG $+2
$SG232203 DB	'MINIUMUM_TOURISM_BLAST_STRENGTH', 00H
$SG232204 DB	'CULTURE_LEVEL_EXOTIC', 00H
	ORG $+3
$SG232205 DB	'CULTURE_LEVEL_FAMILIAR', 00H
	ORG $+1
$SG232206 DB	'CULTURE_LEVEL_POPULAR', 00H
	ORG $+2
$SG232207 DB	'CULTURE_LEVEL_INFLUENTIAL', 00H
	ORG $+2
$SG232208 DB	'CULTURE_LEVEL_DOMINANT', 00H
	ORG $+1
$SG232209 DB	'MIN_DIG_SITES_PER_MAJOR_CIV', 00H
$SG232210 DB	'MAX_DIG_SITES_PER_MAJOR_CIV', 00H
$SG232211 DB	'PERCENT_SITES_HIDDEN', 00H
	ORG $+3
$SG232212 DB	'PERCENT_HIDDEN_SITES_WRITING', 00H
	ORG $+3
$SG232213 DB	'SAPPED_CITY_ATTACK_MODIFIER', 00H
$SG232214 DB	'SAPPER_BONUS_RANGE', 00H
	ORG $+1
$SG232215 DB	'EXOTIC_GOODS_GOLD_MIN', 00H
	ORG $+2
$SG232216 DB	'EXOTIC_GOODS_GOLD_MAX', 00H
	ORG $+2
$SG232217 DB	'EXOTIC_GOODS_XP_MIN', 00H
$SG232218 DB	'EXOTIC_GOODS_XP_MAX', 00H
$SG232219 DB	'TEMPORARY_CULTURE_BOOST_MOD', 00H
$SG232220 DB	'TEMPORARY_TOURISM_BOOST_MOD', 00H
$SG232221 DB	'LEAGUE_SESSION_INTERVAL_BASE_TURNS', 00H
	ORG $+1
$SG232222 DB	'LEAGUE_SESSION_SOON_WARNING_TURNS', 00H
	ORG $+2
$SG232223 DB	'LEAGUE_MEMBER_PROPOSALS_BASE', 00H
	ORG $+3
$SG232224 DB	'LEAGUE_MEMBER_VOTES_BASE', 00H
	ORG $+3
$SG232225 DB	'LEAGUE_MEMBER_VOTES_FOR_HOST', 00H
	ORG $+3
$SG232226 DB	'LEAGUE_MEMBER_VOTES_PER_CITY_STATE_ALLY', 00H
$SG232227 DB	'LEAGUE_PROJECT_REWARD_TIER_1_THRESHOLD', 00H
	ORG $+1
$SG232228 DB	'LEAGUE_PROJECT_REWARD_TIER_2_THRESHOLD', 00H
	ORG $+1
$SG232229 DB	'LAND_TERRAIN', 00H
	ORG $+3
$SG232230 DB	'DEEP_WATER_TERRAIN', 00H
	ORG $+1
$SG232231 DB	'SHALLOW_WATER_TERRAIN', 00H
	ORG $+2
$SG232232 DB	'RUINS_IMPROVEMENT', 00H
	ORG $+2
$SG232233 DB	'NUKE_FEATURE', 00H
	ORG $+3
$SG232234 DB	'ARTIFACT_RESOURCE', 00H
	ORG $+2
$SG232235 DB	'HIDDEN_ARTIFACT_RESOURCE', 00H
	ORG $+3
$SG232236 DB	'CAPITAL_BUILDINGCLASS', 00H
	ORG $+2
$SG232237 DB	'DEFAULT_SPECIALIST', 00H
	ORG $+1
$SG232238 DB	'SPACE_RACE_TRIGGER_PROJECT', 00H
	ORG $+1
$SG232239 DB	'SPACESHIP_CAPSULE', 00H
	ORG $+2
$SG232240 DB	'SPACESHIP_BOOSTER', 00H
	ORG $+2
$SG232241 DB	'SPACESHIP_STASIS', 00H
	ORG $+3
$SG232242 DB	'SPACESHIP_ENGINE', 00H
	ORG $+3
$SG232243 DB	'MANHATTAN_PROJECT', 00H
	ORG $+2
$SG232244 DB	'INITIAL_CITY_ROUTE_TYPE', 00H
$SG232245 DB	'STANDARD_HANDICAP', 00H
	ORG $+2
$SG232246 DB	'MULTIPLAYER_HANDICAP', 00H
	ORG $+3
$SG232247 DB	'STANDARD_HANDICAP_QUICK', 00H
$SG232248 DB	'STANDARD_GAMESPEED', 00H
	ORG $+1
$SG232249 DB	'STANDARD_TURNTIMER', 00H
	ORG $+1
$SG232250 DB	'STANDARD_CLIMATE', 00H
	ORG $+3
$SG232251 DB	'STANDARD_WORLD_SIZE', 00H
$SG232252 DB	'STANDARD_SEALEVEL', 00H
	ORG $+2
$SG232253 DB	'STANDARD_ERA', 00H
	ORG $+3
$SG232254 DB	'LAST_EMBARK_ART_ERA', 00H
$SG232255 DB	'LAST_UNIT_ART_ERA', 00H
	ORG $+2
$SG232256 DB	'LAST_BRIDGE_ART_ERA', 00H
$SG232257 DB	'STANDARD_CALENDAR', 00H
	ORG $+2
$SG232258 DB	'BARBARIAN_HANDICAP', 00H
	ORG $+1
$SG232259 DB	'BARBARIAN_CIVILIZATION', 00H
	ORG $+1
$SG232260 DB	'BARBARIAN_LEADER', 00H
	ORG $+3
$SG232261 DB	'MINOR_CIV_HANDICAP', 00H
	ORG $+1
$SG232262 DB	'MINOR_CIVILIZATION', 00H
	ORG $+1
$SG232263 DB	'PROMOTION_EMBARKATION', 00H
	ORG $+2
$SG232264 DB	'PROMOTION_DEFENSIVE_EMBARKATION', 00H
$SG232265 DB	'PROMOTION_ALLWATER_EMBARKATION', 00H
	ORG $+1
$SG232266 DB	'PROMOTION_OCEAN_IMPASSABLE_UNTIL_ASTRONOMY', 00H
	ORG $+1
$SG232267 DB	'PROMOTION_OCEAN_IMPASSABLE', 00H
	ORG $+1
$SG232268 DB	'AI_HANDICAP', 00H
$SG232269 DB	'BARBARIAN_CAMP_IMPROVEMENT', 00H
	ORG $+1
$SG232270 DB	'WALLS_BUILDINGCLASS', 00H
$SG232271 DB	'PROMOTION_ONLY_DEFENSIVE', 00H
	ORG $+3
$SG232272 DB	'PROMOTION_UNWELCOME_EVANGELIST', 00H
	ORG $+1
$SG232273 DB	'COMBAT_CAPTURE_HEALTH', 00H
	ORG $+2
$SG232274 DB	'COMBAT_CAPTURE_MIN_CHANCE', 00H
	ORG $+2
$SG232275 DB	'COMBAT_CAPTURE_MAX_CHANCE', 00H
	ORG $+2
$SG232276 DB	'COMBAT_CAPTURE_RATIO_MULTIPLIER', 00H
$SG232277 DB	'RELIGION_MIN_FAITH_FIRST_PANTHEON', 00H
	ORG $+2
$SG232278 DB	'RELIGION_MIN_FAITH_FIRST_PROPHET', 00H
	ORG $+3
$SG232279 DB	'RELIGION_MIN_FAITH_FIRST_GREAT_PERSON', 00H
	ORG $+2
$SG232280 DB	'RELIGION_GAME_FAITH_DELTA_NEXT_PANTHEON', 00H
$SG232281 DB	'RELIGION_FAITH_DELTA_NEXT_PROPHET', 00H
	ORG $+2
$SG232282 DB	'RELIGION_FAITH_DELTA_NEXT_GREAT_PERSON', 00H
	ORG $+1
$SG232283 DB	'RELIGION_BASE_CHANCE_PROPHET_SPAWN', 00H
	ORG $+1
$SG232284 DB	'RELIGION_ATHEISM_PRESSURE_PER_POP', 00H
	ORG $+2
$SG232285 DB	'RELIGION_INITIAL_FOUNDING_CITY_PRESSURE', 00H
$SG232286 DB	'RELIGION_PER_TURN_FOUNDING_CITY_PRESSURE', 00H
	ORG $+3
$SG232287 DB	'RELIGION_MISSIONARY_PRESSURE_MULTIPLIER', 00H
$SG232288 DB	'RELIGION_ADJACENT_CITY_DISTANCE', 00H
$SG232289 DB	'RELIGION_DIPLO_HIT_INITIAL_CONVERT_FRIENDLY_CITY', 00H
	ORG $+3
$SG232290 DB	'RELIGION_DIPLO_HIT_RELIGIOUS_FLIP_FRIENDLY_CITY', 00H
$SG232291 DB	'RELIGION_DIPLO_HIT_CONVERT_HOLY_CITY', 00H
	ORG $+3
$SG232292 DB	'RELIGION_DIPLO_HIT_THRESHOLD', 00H
	ORG $+3
$SG232293 DB	'ESPIONAGE_GATHERING_INTEL_COST_PERCENT', 00H
	ORG $+1
$SG232294 DB	'ESPIONAGE_GATHERING_INTEL_RATE_BY_SPY_RANK_PERCENT', 00H
	ORG $+1
$SG232295 DB	'ESPIONAGE_GATHERING_INTEL_RATE_BASE_PERCENT', 00H
$SG232296 DB	'ESPIONAGE_TURNS_BETWEEN_CITY_STATE_ELECTIONS', 00H
	ORG $+3
$SG232297 DB	'ESPIONAGE_INFLUENCE_GAINED_FOR_RIGGED_ELECTION', 00H
	ORG $+1
$SG232298 DB	'ESPIONAGE_INFLUENCE_LOST_FOR_RIGGED_ELECTION', 00H
	ORG $+3
$SG232299 DB	'ESPIONAGE_SURVEILLANCE_SIGHT_RANGE', 00H
	ORG $+1
$SG232300 DB	'ESPIONAGE_COUP_OTHER_PLAYERS_INFLUENCE_DROP', 00H
$SG232301 DB	'PROMOTION_GOODY_HUT_PICKER', 00H
	ORG $+1
$SG232302 DB	'IDEOLOGY_PERCENT_CLEAR_VICTORY_PREF', 00H
$SG232303 DB	'IDEOLOGY_SCORE_GRAND_STRATS', 00H
$SG232304 DB	'IDEOLOGY_SCORE_HAPPINESS', 00H
	ORG $+3
$SG232305 DB	'IDEOLOGY_SCORE_PER_FREE_TENET', 00H
	ORG $+2
$SG232306 DB	'IDEOLOGY_SCORE_HOSTILE', 00H
	ORG $+1
$SG232307 DB	'IDEOLOGY_SCORE_GUARDED', 00H
	ORG $+1
$SG232308 DB	'IDEOLOGY_SCORE_AFRAID', 00H
	ORG $+2
$SG232309 DB	'IDEOLOGY_SCORE_FRIENDLY', 00H
$SG232310 DB	'POLICY_BRANCH_FREEDOM', 00H
	ORG $+2
$SG232312 DB	'POLICY_BRANCH_AUTOCRACY', 00H
$SG232314 DB	'POLICY_BRANCH_ORDER', 00H
$SG232793 DB	'Info type %s not found.', 00H
_guidICvDLLDatabaseUtility1 DD 0ae87f7bdH
	DW	08510H
	DW	0444fH
	DB	09dH
	DB	054H
	DB	098H
	DB	03dH
	DB	077H
	DB	064H
	DB	085H
	DB	0a6H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?GetInterfaceId@ICvDLLDatabaseUtility1@@SG?AU_GUID@@XZ ; ICvDLLDatabaseUtility1::GetInterfaceId
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\icvdlldatabaseutility.h
;	COMDAT ?GetInterfaceId@ICvDLLDatabaseUtility1@@SG?AU_GUID@@XZ
_TEXT	SEGMENT
$T252556 = 8						; size = 4
?GetInterfaceId@ICvDLLDatabaseUtility1@@SG?AU_GUID@@XZ PROC ; ICvDLLDatabaseUtility1::GetInterfaceId, COMDAT

; 12   : 	static GUID DLLCALL GetInterfaceId() { return guidICvDLLDatabaseUtility1; }

	mov	eax, DWORD PTR $T252556[esp-4]
	mov	ecx, DWORD PTR _guidICvDLLDatabaseUtility1
	mov	edx, DWORD PTR _guidICvDLLDatabaseUtility1+4
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _guidICvDLLDatabaseUtility1+8
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _guidICvDLLDatabaseUtility1+12
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	ret	4
?GetInterfaceId@ICvDLLDatabaseUtility1@@SG?AU_GUID@@XZ ENDP ; ICvDLLDatabaseUtility1::GetInterfaceId
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 134  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CvIgnoreUnitsPathFinder@@QAE@XZ		; CvIgnoreUnitsPathFinder::CvIgnoreUnitsPathFinder
EXTRN	??0CvAStar@@QAE@XZ:PROC				; CvAStar::CvAStar
; Function compile flags: /Ogtpy
;	COMDAT ??0CvIgnoreUnitsPathFinder@@QAE@XZ
_TEXT	SEGMENT
??0CvIgnoreUnitsPathFinder@@QAE@XZ PROC			; CvIgnoreUnitsPathFinder::CvIgnoreUnitsPathFinder, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	mov	eax, esi
	pop	esi
	ret	0
??0CvIgnoreUnitsPathFinder@@QAE@XZ ENDP			; CvIgnoreUnitsPathFinder::CvIgnoreUnitsPathFinder
_TEXT	ENDS
PUBLIC	??0CvStepPathFinder@@QAE@XZ			; CvStepPathFinder::CvStepPathFinder
; Function compile flags: /Ogtpy
;	COMDAT ??0CvStepPathFinder@@QAE@XZ
_TEXT	SEGMENT
??0CvStepPathFinder@@QAE@XZ PROC			; CvStepPathFinder::CvStepPathFinder, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	mov	eax, esi
	pop	esi
	ret	0
??0CvStepPathFinder@@QAE@XZ ENDP			; CvStepPathFinder::CvStepPathFinder
_TEXT	ENDS
PUBLIC	?UnwrapCityPointer@CvGlobals@@QAEPAVCvCity@@PAVICvCity1@@@Z ; CvGlobals::UnwrapCityPointer
EXTRN	?GetInstance@CvDllCity@@QAEPAVCvCity@@XZ:PROC	; CvDllCity::GetInstance
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
;	COMDAT ?UnwrapCityPointer@CvGlobals@@QAEPAVCvCity@@PAVICvCity1@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?UnwrapCityPointer@CvGlobals@@QAEPAVCvCity@@PAVICvCity1@@@Z PROC ; CvGlobals::UnwrapCityPointer, COMDAT
; _this$ = ecx

; 2297 : 	return (NULL != pCity)? static_cast<CvDllCity*>(pCity)->GetInstance() : NULL;

	mov	ecx, DWORD PTR _pCity$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@UnwrapCity
	call	?GetInstance@CvDllCity@@QAEPAVCvCity@@XZ ; CvDllCity::GetInstance

; 2298 : }

	ret	4
$LN3@UnwrapCity:

; 2297 : 	return (NULL != pCity)? static_cast<CvDllCity*>(pCity)->GetInstance() : NULL;

	xor	eax, eax

; 2298 : }

	ret	4
?UnwrapCityPointer@CvGlobals@@QAEPAVCvCity@@PAVICvCity1@@@Z ENDP ; CvGlobals::UnwrapCityPointer
_TEXT	ENDS
PUBLIC	?UnwrapDealPointer@CvGlobals@@QAEPAVCvDeal@@PAVICvDeal1@@@Z ; CvGlobals::UnwrapDealPointer
EXTRN	?GetInstance@CvDllDeal@@QAEPAVCvDeal@@XZ:PROC	; CvDllDeal::GetInstance
; Function compile flags: /Ogtpy
;	COMDAT ?UnwrapDealPointer@CvGlobals@@QAEPAVCvDeal@@PAVICvDeal1@@@Z
_TEXT	SEGMENT
_pDeal$ = 8						; size = 4
?UnwrapDealPointer@CvGlobals@@QAEPAVCvDeal@@PAVICvDeal1@@@Z PROC ; CvGlobals::UnwrapDealPointer, COMDAT
; _this$ = ecx

; 2307 : 	return (NULL != pDeal)? static_cast<CvDllDeal*>(pDeal)->GetInstance() : NULL;

	mov	ecx, DWORD PTR _pDeal$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@UnwrapDeal
	call	?GetInstance@CvDllDeal@@QAEPAVCvDeal@@XZ ; CvDllDeal::GetInstance

; 2308 : }

	ret	4
$LN3@UnwrapDeal:

; 2307 : 	return (NULL != pDeal)? static_cast<CvDllDeal*>(pDeal)->GetInstance() : NULL;

	xor	eax, eax

; 2308 : }

	ret	4
?UnwrapDealPointer@CvGlobals@@QAEPAVCvDeal@@PAVICvDeal1@@@Z ENDP ; CvGlobals::UnwrapDealPointer
_TEXT	ENDS
PUBLIC	?UnwrapPlotPointer@CvGlobals@@QAEPAVCvPlot@@PAVICvPlot1@@@Z ; CvGlobals::UnwrapPlotPointer
EXTRN	?GetInstance@CvDllPlot@@QAEPAVCvPlot@@XZ:PROC	; CvDllPlot::GetInstance
; Function compile flags: /Ogtpy
;	COMDAT ?UnwrapPlotPointer@CvGlobals@@QAEPAVCvPlot@@PAVICvPlot1@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?UnwrapPlotPointer@CvGlobals@@QAEPAVCvPlot@@PAVICvPlot1@@@Z PROC ; CvGlobals::UnwrapPlotPointer, COMDAT
; _this$ = ecx

; 2317 : 	return (NULL != pPlot)? static_cast<CvDllPlot*>(pPlot)->GetInstance() : NULL;

	mov	ecx, DWORD PTR _pPlot$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@UnwrapPlot
	call	?GetInstance@CvDllPlot@@QAEPAVCvPlot@@XZ ; CvDllPlot::GetInstance

; 2318 : }

	ret	4
$LN3@UnwrapPlot:

; 2317 : 	return (NULL != pPlot)? static_cast<CvDllPlot*>(pPlot)->GetInstance() : NULL;

	xor	eax, eax

; 2318 : }

	ret	4
?UnwrapPlotPointer@CvGlobals@@QAEPAVCvPlot@@PAVICvPlot1@@@Z ENDP ; CvGlobals::UnwrapPlotPointer
_TEXT	ENDS
PUBLIC	?UnwrapRandomPointer@CvGlobals@@QAEPAVCvRandom@@PAVICvRandom1@@@Z ; CvGlobals::UnwrapRandomPointer
EXTRN	?GetInstance@CvDllRandom@@QAEPAVCvRandom@@XZ:PROC ; CvDllRandom::GetInstance
; Function compile flags: /Ogtpy
;	COMDAT ?UnwrapRandomPointer@CvGlobals@@QAEPAVCvRandom@@PAVICvRandom1@@@Z
_TEXT	SEGMENT
_pRandom$ = 8						; size = 4
?UnwrapRandomPointer@CvGlobals@@QAEPAVCvRandom@@PAVICvRandom1@@@Z PROC ; CvGlobals::UnwrapRandomPointer, COMDAT
; _this$ = ecx

; 2327 : 	return (NULL != pRandom)? static_cast<CvDllRandom*>(pRandom)->GetInstance() : NULL;

	mov	ecx, DWORD PTR _pRandom$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@UnwrapRand
	call	?GetInstance@CvDllRandom@@QAEPAVCvRandom@@XZ ; CvDllRandom::GetInstance

; 2328 : }

	ret	4
$LN3@UnwrapRand:

; 2327 : 	return (NULL != pRandom)? static_cast<CvDllRandom*>(pRandom)->GetInstance() : NULL;

	xor	eax, eax

; 2328 : }

	ret	4
?UnwrapRandomPointer@CvGlobals@@QAEPAVCvRandom@@PAVICvRandom1@@@Z ENDP ; CvGlobals::UnwrapRandomPointer
_TEXT	ENDS
PUBLIC	?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z ; CvGlobals::UnwrapUnitPointer
EXTRN	?GetInstance@CvDllUnit@@QAEPAVCvUnit@@XZ:PROC	; CvDllUnit::GetInstance
; Function compile flags: /Ogtpy
;	COMDAT ?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z PROC ; CvGlobals::UnwrapUnitPointer, COMDAT
; _this$ = ecx

; 2342 : 	return (NULL != pUnit)? static_cast<CvDllUnit*>(pUnit)->GetInstance() : NULL;

	mov	ecx, DWORD PTR _pUnit$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@UnwrapUnit
	call	?GetInstance@CvDllUnit@@QAEPAVCvUnit@@XZ ; CvDllUnit::GetInstance

; 2343 : }

	ret	4
$LN3@UnwrapUnit:

; 2342 : 	return (NULL != pUnit)? static_cast<CvDllUnit*>(pUnit)->GetInstance() : NULL;

	xor	eax, eax

; 2343 : }

	ret	4
?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z ENDP ; CvGlobals::UnwrapUnitPointer
_TEXT	ENDS
PUBLIC	?getInstance@CvGlobals@@SAAAV1@XZ		; CvGlobals::getInstance
; Function compile flags: /Ogtpy
;	COMDAT ?getInstance@CvGlobals@@SAAAV1@XZ
_TEXT	SEGMENT
?getInstance@CvGlobals@@SAAAV1@XZ PROC			; CvGlobals::getInstance, COMDAT

; 2347 : 	return gGlobals;

	mov	eax, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals

; 2348 : }

	ret	0
?getInstance@CvGlobals@@SAAAV1@XZ ENDP			; CvGlobals::getInstance
_TEXT	ENDS
PUBLIC	?getASyncRand@CvGlobals@@QAEAAVCvRandom@@XZ	; CvGlobals::getASyncRand
; Function compile flags: /Ogtpy
;	COMDAT ?getASyncRand@CvGlobals@@QAEAAVCvRandom@@XZ
_TEXT	SEGMENT
?getASyncRand@CvGlobals@@QAEAAVCvRandom@@XZ PROC	; CvGlobals::getASyncRand, COMDAT
; _this$ = ecx

; 2352 : 	return *m_asyncRand;

	mov	eax, DWORD PTR [ecx+44]

; 2353 : }

	ret	0
?getASyncRand@CvGlobals@@QAEAAVCvRandom@@XZ ENDP	; CvGlobals::getASyncRand
_TEXT	ENDS
PUBLIC	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
; Function compile flags: /Ogtpy
;	COMDAT ?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ
_TEXT	SEGMENT
?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ PROC ; CvGlobals::getPathFinder, COMDAT
; _this$ = ecx

; 2357 : 	return *m_pathFinder;

	mov	eax, DWORD PTR [ecx+56]

; 2358 : }

	ret	0
?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ENDP ; CvGlobals::getPathFinder
_TEXT	ENDS
PUBLIC	?getInterfacePathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getInterfacePathFinder
; Function compile flags: /Ogtpy
;	COMDAT ?getInterfacePathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ
_TEXT	SEGMENT
?getInterfacePathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ PROC ; CvGlobals::getInterfacePathFinder, COMDAT
; _this$ = ecx

; 2362 : 	return *m_interfacePathFinder;

	mov	eax, DWORD PTR [ecx+60]

; 2363 : }

	ret	0
?getInterfacePathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ENDP ; CvGlobals::getInterfacePathFinder
_TEXT	ENDS
PUBLIC	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
; Function compile flags: /Ogtpy
;	COMDAT ?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ
_TEXT	SEGMENT
?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ PROC ; CvGlobals::getIgnoreUnitsPathFinder, COMDAT
; _this$ = ecx

; 2367 : 	return *m_ignoreUnitsPathFinder;

	mov	eax, DWORD PTR [ecx+64]

; 2368 : }

	ret	0
?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ENDP ; CvGlobals::getIgnoreUnitsPathFinder
_TEXT	ENDS
PUBLIC	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
; Function compile flags: /Ogtpy
;	COMDAT ?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ
_TEXT	SEGMENT
?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ PROC ; CvGlobals::getStepFinder, COMDAT
; _this$ = ecx

; 2372 : 	return *m_stepFinder;

	mov	eax, DWORD PTR [ecx+68]

; 2373 : }

	ret	0
?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ENDP ; CvGlobals::getStepFinder
_TEXT	ENDS
PUBLIC	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ	; CvGlobals::getRouteFinder
; Function compile flags: /Ogtpy
;	COMDAT ?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ
_TEXT	SEGMENT
?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ PROC	; CvGlobals::getRouteFinder, COMDAT
; _this$ = ecx

; 2377 : 	return *m_routeFinder;

	mov	eax, DWORD PTR [ecx+72]

; 2378 : }

	ret	0
?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ENDP	; CvGlobals::getRouteFinder
_TEXT	ENDS
PUBLIC	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetWaterRouteFinder
; Function compile flags: /Ogtpy
;	COMDAT ?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ
_TEXT	SEGMENT
?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ PROC	; CvGlobals::GetWaterRouteFinder, COMDAT
; _this$ = ecx

; 2382 : 	return *m_waterRouteFinder;

	mov	eax, DWORD PTR [ecx+76]

; 2383 : }

	ret	0
?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ENDP	; CvGlobals::GetWaterRouteFinder
_TEXT	ENDS
PUBLIC	?getAreaFinder@CvGlobals@@QAEAAVCvAStar@@XZ	; CvGlobals::getAreaFinder
; Function compile flags: /Ogtpy
;	COMDAT ?getAreaFinder@CvGlobals@@QAEAAVCvAStar@@XZ
_TEXT	SEGMENT
?getAreaFinder@CvGlobals@@QAEAAVCvAStar@@XZ PROC	; CvGlobals::getAreaFinder, COMDAT
; _this$ = ecx

; 2387 : 	return *m_areaFinder;

	mov	eax, DWORD PTR [ecx+84]

; 2388 : }

	ret	0
?getAreaFinder@CvGlobals@@QAEAAVCvAStar@@XZ ENDP	; CvGlobals::getAreaFinder
_TEXT	ENDS
PUBLIC	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
; Function compile flags: /Ogtpy
;	COMDAT ?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ
_TEXT	SEGMENT
?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ PROC	; CvGlobals::getInfluenceFinder, COMDAT
; _this$ = ecx

; 2392 : 	return *m_influenceFinder;

	mov	eax, DWORD PTR [ecx+88]

; 2393 : }

	ret	0
?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ENDP	; CvGlobals::getInfluenceFinder
_TEXT	ENDS
PUBLIC	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ
_TEXT	SEGMENT
?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ PROC	; CvGlobals::GetBuildRouteFinder, COMDAT
; _this$ = ecx

; 2397 : 	return *m_buildRouteFinder;

	mov	eax, DWORD PTR [ecx+92]

; 2398 : }

	ret	0
?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ENDP	; CvGlobals::GetBuildRouteFinder
_TEXT	ENDS
PUBLIC	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
; Function compile flags: /Ogtpy
;	COMDAT ?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ
_TEXT	SEGMENT
?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ PROC ; CvGlobals::GetInternationalTradeRouteLandFinder, COMDAT
; _this$ = ecx

; 2402 : 	return *m_internationalTradeRouteLandFinder;

	mov	eax, DWORD PTR [ecx+96]

; 2403 : }

	ret	0
?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ENDP ; CvGlobals::GetInternationalTradeRouteLandFinder
_TEXT	ENDS
PUBLIC	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
; Function compile flags: /Ogtpy
;	COMDAT ?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ
_TEXT	SEGMENT
?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ PROC ; CvGlobals::GetInternationalTradeRouteWaterFinder, COMDAT
; _this$ = ecx

; 2407 : 	return *m_internationalTradeRouteWaterFinder;

	mov	eax, DWORD PTR [ecx+100]

; 2408 : }

	ret	0
?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ENDP ; CvGlobals::GetInternationalTradeRouteWaterFinder
_TEXT	ENDS
PUBLIC	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
; Function compile flags: /Ogtpy
;	COMDAT ?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ
_TEXT	SEGMENT
?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ PROC ; CvGlobals::GetTacticalAnalysisMapFinder, COMDAT
; _this$ = ecx

; 2412 : 	return *m_tacticalAnalysisMapFinder;

	mov	eax, DWORD PTR [ecx+104]

; 2413 : }

	ret	0
?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ENDP ; CvGlobals::GetTacticalAnalysisMapFinder
_TEXT	ENDS
PUBLIC	?getInterfaceModeInfo@CvGlobals@@QAEAAV?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@XZ ; CvGlobals::getInterfaceModeInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getInterfaceModeInfo@CvGlobals@@QAEAAV?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getInterfaceModeInfo@CvGlobals@@QAEAAV?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@XZ PROC ; CvGlobals::getInterfaceModeInfo, COMDAT
; _this$ = ecx

; 2434 : 	return m_paInterfaceModeInfo;

	lea	eax, DWORD PTR [ecx+896]

; 2435 : }

	ret	0
?getInterfaceModeInfo@CvGlobals@@QAEAAV?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getInterfaceModeInfo
_TEXT	ENDS
PUBLIC	?getLogging@CvGlobals@@QAE_NXZ			; CvGlobals::getLogging
; Function compile flags: /Ogtpy
;	COMDAT ?getLogging@CvGlobals@@QAE_NXZ
_TEXT	SEGMENT
?getLogging@CvGlobals@@QAE_NXZ PROC			; CvGlobals::getLogging, COMDAT
; _this$ = ecx

; 2449 : 	return m_bLogging;

	mov	al, BYTE PTR [ecx+7]

; 2450 : }

	ret	0
?getLogging@CvGlobals@@QAE_NXZ ENDP			; CvGlobals::getLogging
_TEXT	ENDS
PUBLIC	?setLogging@CvGlobals@@QAEX_N@Z			; CvGlobals::setLogging
; Function compile flags: /Ogtpy
;	COMDAT ?setLogging@CvGlobals@@QAEX_N@Z
_TEXT	SEGMENT
_bLoggingEnabled$ = 8					; size = 1
?setLogging@CvGlobals@@QAEX_N@Z PROC			; CvGlobals::setLogging, COMDAT
; _this$ = ecx

; 2454 : 	m_bLogging = bLoggingEnabled;

	mov	al, BYTE PTR _bLoggingEnabled$[esp-4]
	mov	BYTE PTR [ecx+7], al

; 2455 : }

	ret	4
?setLogging@CvGlobals@@QAEX_N@Z ENDP			; CvGlobals::setLogging
_TEXT	ENDS
PUBLIC	?getRandLogging@CvGlobals@@QAEHXZ		; CvGlobals::getRandLogging
; Function compile flags: /Ogtpy
;	COMDAT ?getRandLogging@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getRandLogging@CvGlobals@@QAEHXZ PROC			; CvGlobals::getRandLogging, COMDAT
; _this$ = ecx

; 2459 : 	return m_iRandLogging;

	mov	eax, DWORD PTR [ecx+8]

; 2460 : }

	ret	0
?getRandLogging@CvGlobals@@QAEHXZ ENDP			; CvGlobals::getRandLogging
_TEXT	ENDS
PUBLIC	?setRandLogging@CvGlobals@@QAEXH@Z		; CvGlobals::setRandLogging
; Function compile flags: /Ogtpy
;	COMDAT ?setRandLogging@CvGlobals@@QAEXH@Z
_TEXT	SEGMENT
_iRandLoggingFlags$ = 8					; size = 4
?setRandLogging@CvGlobals@@QAEXH@Z PROC			; CvGlobals::setRandLogging, COMDAT
; _this$ = ecx

; 2464 : 	m_iRandLogging = iRandLoggingFlags;

	mov	eax, DWORD PTR _iRandLoggingFlags$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 2465 : }

	ret	4
?setRandLogging@CvGlobals@@QAEXH@Z ENDP			; CvGlobals::setRandLogging
_TEXT	ENDS
PUBLIC	?getAILogging@CvGlobals@@QAE_NXZ		; CvGlobals::getAILogging
; Function compile flags: /Ogtpy
;	COMDAT ?getAILogging@CvGlobals@@QAE_NXZ
_TEXT	SEGMENT
?getAILogging@CvGlobals@@QAE_NXZ PROC			; CvGlobals::getAILogging, COMDAT
; _this$ = ecx

; 2469 : 	return m_bAILogging;

	mov	al, BYTE PTR [ecx+13]

; 2470 : }

	ret	0
?getAILogging@CvGlobals@@QAE_NXZ ENDP			; CvGlobals::getAILogging
_TEXT	ENDS
PUBLIC	?setAILogging@CvGlobals@@QAEX_N@Z		; CvGlobals::setAILogging
; Function compile flags: /Ogtpy
;	COMDAT ?setAILogging@CvGlobals@@QAEX_N@Z
_TEXT	SEGMENT
_bEnable$ = 8						; size = 1
?setAILogging@CvGlobals@@QAEX_N@Z PROC			; CvGlobals::setAILogging, COMDAT
; _this$ = ecx

; 2474 : 	m_bAILogging = bEnable;

	mov	al, BYTE PTR _bEnable$[esp-4]
	mov	BYTE PTR [ecx+13], al

; 2475 : }

	ret	4
?setAILogging@CvGlobals@@QAEX_N@Z ENDP			; CvGlobals::setAILogging
_TEXT	ENDS
PUBLIC	?getAIPerfLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getAIPerfLogging
; Function compile flags: /Ogtpy
;	COMDAT ?getAIPerfLogging@CvGlobals@@QAE_NXZ
_TEXT	SEGMENT
?getAIPerfLogging@CvGlobals@@QAE_NXZ PROC		; CvGlobals::getAIPerfLogging, COMDAT
; _this$ = ecx

; 2479 : 	return m_bAIPerfLogging;

	mov	al, BYTE PTR [ecx+14]

; 2480 : }

	ret	0
?getAIPerfLogging@CvGlobals@@QAE_NXZ ENDP		; CvGlobals::getAIPerfLogging
_TEXT	ENDS
PUBLIC	?setAIPerfLogging@CvGlobals@@QAEX_N@Z		; CvGlobals::setAIPerfLogging
; Function compile flags: /Ogtpy
;	COMDAT ?setAIPerfLogging@CvGlobals@@QAEX_N@Z
_TEXT	SEGMENT
_bEnable$ = 8						; size = 1
?setAIPerfLogging@CvGlobals@@QAEX_N@Z PROC		; CvGlobals::setAIPerfLogging, COMDAT
; _this$ = ecx

; 2484 : 	m_bAIPerfLogging = bEnable;

	mov	al, BYTE PTR _bEnable$[esp-4]
	mov	BYTE PTR [ecx+14], al

; 2485 : }

	ret	4
?setAIPerfLogging@CvGlobals@@QAEX_N@Z ENDP		; CvGlobals::setAIPerfLogging
_TEXT	ENDS
PUBLIC	?GetBuilderAILogging@CvGlobals@@QAE_NXZ		; CvGlobals::GetBuilderAILogging
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuilderAILogging@CvGlobals@@QAE_NXZ
_TEXT	SEGMENT
?GetBuilderAILogging@CvGlobals@@QAE_NXZ PROC		; CvGlobals::GetBuilderAILogging, COMDAT
; _this$ = ecx

; 2489 : 	return m_bBuilderAILogging;

	mov	al, BYTE PTR [ecx+15]

; 2490 : }

	ret	0
?GetBuilderAILogging@CvGlobals@@QAE_NXZ ENDP		; CvGlobals::GetBuilderAILogging
_TEXT	ENDS
PUBLIC	?SetBuilderAILogging@CvGlobals@@QAEX_N@Z	; CvGlobals::SetBuilderAILogging
; Function compile flags: /Ogtpy
;	COMDAT ?SetBuilderAILogging@CvGlobals@@QAEX_N@Z
_TEXT	SEGMENT
_bEnable$ = 8						; size = 1
?SetBuilderAILogging@CvGlobals@@QAEX_N@Z PROC		; CvGlobals::SetBuilderAILogging, COMDAT
; _this$ = ecx

; 2494 : 	m_bBuilderAILogging = bEnable;

	mov	al, BYTE PTR _bEnable$[esp-4]
	mov	BYTE PTR [ecx+15], al

; 2495 : }

	ret	4
?SetBuilderAILogging@CvGlobals@@QAEX_N@Z ENDP		; CvGlobals::SetBuilderAILogging
_TEXT	ENDS
PUBLIC	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ	; CvGlobals::getPlayerAndCityAILogSplit
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ
_TEXT	SEGMENT
?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ PROC	; CvGlobals::getPlayerAndCityAILogSplit, COMDAT
; _this$ = ecx

; 2499 : 	return m_bPlayerAndCityAILogSplit;

	mov	al, BYTE PTR [ecx+17]

; 2500 : }

	ret	0
?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ENDP	; CvGlobals::getPlayerAndCityAILogSplit
_TEXT	ENDS
PUBLIC	?setPlayerAndCityAILogSplit@CvGlobals@@QAEX_N@Z	; CvGlobals::setPlayerAndCityAILogSplit
; Function compile flags: /Ogtpy
;	COMDAT ?setPlayerAndCityAILogSplit@CvGlobals@@QAEX_N@Z
_TEXT	SEGMENT
_bEnable$ = 8						; size = 1
?setPlayerAndCityAILogSplit@CvGlobals@@QAEX_N@Z PROC	; CvGlobals::setPlayerAndCityAILogSplit, COMDAT
; _this$ = ecx

; 2504 : 	m_bPlayerAndCityAILogSplit = bEnable;

	mov	al, BYTE PTR _bEnable$[esp-4]
	mov	BYTE PTR [ecx+17], al

; 2505 : }

	ret	4
?setPlayerAndCityAILogSplit@CvGlobals@@QAEX_N@Z ENDP	; CvGlobals::setPlayerAndCityAILogSplit
_TEXT	ENDS
PUBLIC	?GetTutorialLogging@CvGlobals@@QAE_NXZ		; CvGlobals::GetTutorialLogging
; Function compile flags: /Ogtpy
;	COMDAT ?GetTutorialLogging@CvGlobals@@QAE_NXZ
_TEXT	SEGMENT
?GetTutorialLogging@CvGlobals@@QAE_NXZ PROC		; CvGlobals::GetTutorialLogging, COMDAT
; _this$ = ecx

; 2509 : 	return m_bTutorialLogging;

	mov	al, BYTE PTR [ecx+18]

; 2510 : }

	ret	0
?GetTutorialLogging@CvGlobals@@QAE_NXZ ENDP		; CvGlobals::GetTutorialLogging
_TEXT	ENDS
PUBLIC	?SetTutorialLogging@CvGlobals@@QAEX_N@Z		; CvGlobals::SetTutorialLogging
; Function compile flags: /Ogtpy
;	COMDAT ?SetTutorialLogging@CvGlobals@@QAEX_N@Z
_TEXT	SEGMENT
_bEnable$ = 8						; size = 1
?SetTutorialLogging@CvGlobals@@QAEX_N@Z PROC		; CvGlobals::SetTutorialLogging, COMDAT
; _this$ = ecx

; 2514 : 	m_bTutorialLogging = bEnable;

	mov	al, BYTE PTR _bEnable$[esp-4]
	mov	BYTE PTR [ecx+18], al

; 2515 : }

	ret	4
?SetTutorialLogging@CvGlobals@@QAEX_N@Z ENDP		; CvGlobals::SetTutorialLogging
_TEXT	ENDS
PUBLIC	?GetTutorialDebugging@CvGlobals@@QAE_NXZ	; CvGlobals::GetTutorialDebugging
; Function compile flags: /Ogtpy
;	COMDAT ?GetTutorialDebugging@CvGlobals@@QAE_NXZ
_TEXT	SEGMENT
?GetTutorialDebugging@CvGlobals@@QAE_NXZ PROC		; CvGlobals::GetTutorialDebugging, COMDAT
; _this$ = ecx

; 2519 : 	return m_bTutorialDebugging;

	mov	al, BYTE PTR [ecx+19]

; 2520 : }

	ret	0
?GetTutorialDebugging@CvGlobals@@QAE_NXZ ENDP		; CvGlobals::GetTutorialDebugging
_TEXT	ENDS
PUBLIC	?SetTutorialDebugging@CvGlobals@@QAEX_N@Z	; CvGlobals::SetTutorialDebugging
; Function compile flags: /Ogtpy
;	COMDAT ?SetTutorialDebugging@CvGlobals@@QAEX_N@Z
_TEXT	SEGMENT
_bEnable$ = 8						; size = 1
?SetTutorialDebugging@CvGlobals@@QAEX_N@Z PROC		; CvGlobals::SetTutorialDebugging, COMDAT
; _this$ = ecx

; 2524 : 	m_bTutorialDebugging = bEnable;

	mov	al, BYTE PTR _bEnable$[esp-4]
	mov	BYTE PTR [ecx+19], al

; 2525 : }

	ret	4
?SetTutorialDebugging@CvGlobals@@QAEX_N@Z ENDP		; CvGlobals::SetTutorialDebugging
_TEXT	ENDS
PUBLIC	?GetAllowRClickMovementWhileScrolling@CvGlobals@@QAE_NXZ ; CvGlobals::GetAllowRClickMovementWhileScrolling
; Function compile flags: /Ogtpy
;	COMDAT ?GetAllowRClickMovementWhileScrolling@CvGlobals@@QAE_NXZ
_TEXT	SEGMENT
?GetAllowRClickMovementWhileScrolling@CvGlobals@@QAE_NXZ PROC ; CvGlobals::GetAllowRClickMovementWhileScrolling, COMDAT
; _this$ = ecx

; 2529 : 	return m_bAllowRClickMovementWhileCameraScrolling;

	mov	al, BYTE PTR [ecx+20]

; 2530 : }

	ret	0
?GetAllowRClickMovementWhileScrolling@CvGlobals@@QAE_NXZ ENDP ; CvGlobals::GetAllowRClickMovementWhileScrolling
_TEXT	ENDS
PUBLIC	?SetAllowRClickMovementWhileScrolling@CvGlobals@@QAEX_N@Z ; CvGlobals::SetAllowRClickMovementWhileScrolling
; Function compile flags: /Ogtpy
;	COMDAT ?SetAllowRClickMovementWhileScrolling@CvGlobals@@QAEX_N@Z
_TEXT	SEGMENT
_bAllow$ = 8						; size = 1
?SetAllowRClickMovementWhileScrolling@CvGlobals@@QAEX_N@Z PROC ; CvGlobals::SetAllowRClickMovementWhileScrolling, COMDAT
; _this$ = ecx

; 2534 : 	m_bAllowRClickMovementWhileCameraScrolling = bAllow;

	mov	al, BYTE PTR _bAllow$[esp-4]
	mov	BYTE PTR [ecx+20], al

; 2535 : }

	ret	4
?SetAllowRClickMovementWhileScrolling@CvGlobals@@QAEX_N@Z ENDP ; CvGlobals::SetAllowRClickMovementWhileScrolling
_TEXT	ENDS
PUBLIC	?GetPostTurnAutosaves@CvGlobals@@QAE_NXZ	; CvGlobals::GetPostTurnAutosaves
; Function compile flags: /Ogtpy
;	COMDAT ?GetPostTurnAutosaves@CvGlobals@@QAE_NXZ
_TEXT	SEGMENT
?GetPostTurnAutosaves@CvGlobals@@QAE_NXZ PROC		; CvGlobals::GetPostTurnAutosaves, COMDAT
; _this$ = ecx

; 2539 : 	return m_bPostTurnAutosaves;

	mov	al, BYTE PTR [ecx+21]

; 2540 : }

	ret	0
?GetPostTurnAutosaves@CvGlobals@@QAE_NXZ ENDP		; CvGlobals::GetPostTurnAutosaves
_TEXT	ENDS
PUBLIC	?SetPostTurnAutosaves@CvGlobals@@QAEX_N@Z	; CvGlobals::SetPostTurnAutosaves
; Function compile flags: /Ogtpy
;	COMDAT ?SetPostTurnAutosaves@CvGlobals@@QAEX_N@Z
_TEXT	SEGMENT
_bEnable$ = 8						; size = 1
?SetPostTurnAutosaves@CvGlobals@@QAEX_N@Z PROC		; CvGlobals::SetPostTurnAutosaves, COMDAT
; _this$ = ecx

; 2544 : 	m_bPostTurnAutosaves = bEnable;

	mov	al, BYTE PTR _bEnable$[esp-4]
	mov	BYTE PTR [ecx+21], al

; 2545 : }

	ret	4
?SetPostTurnAutosaves@CvGlobals@@QAEX_N@Z ENDP		; CvGlobals::SetPostTurnAutosaves
_TEXT	ENDS
PUBLIC	?getCityPlotPriority@CvGlobals@@QAEPAHXZ	; CvGlobals::getCityPlotPriority
; Function compile flags: /Ogtpy
;	COMDAT ?getCityPlotPriority@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getCityPlotPriority@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getCityPlotPriority, COMDAT
; _this$ = ecx

; 2550 : 	return m_aiCityPlotPriority;

	lea	eax, DWORD PTR [ecx+456]

; 2551 : }

	ret	0
?getCityPlotPriority@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getCityPlotPriority
_TEXT	ENDS
PUBLIC	?getXYCityPlot@CvGlobals@@QAEHHH@Z		; CvGlobals::getXYCityPlot
; Function compile flags: /Ogtpy
;	COMDAT ?getXYCityPlot@CvGlobals@@QAEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?getXYCityPlot@CvGlobals@@QAEHHH@Z PROC			; CvGlobals::getXYCityPlot, COMDAT
; _this$ = ecx

; 2555 : 	CvAssertMsg(i < CITY_PLOTS_DIAMETER, "Index out of bounds");
; 2556 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2557 : 	if(i < 0 || i >= CITY_PLOTS_DIAMETER) return -1;

	mov	eax, DWORD PTR _i$[esp-4]
	cmp	eax, 6
	ja	SHORT $LN3@getXYCityP

; 2558 : 
; 2559 : 	CvAssertMsg(j < CITY_PLOTS_DIAMETER, "Index out of bounds");
; 2560 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2561 : 	if(j < 0 || j >= CITY_PLOTS_DIAMETER) return -1;

	mov	edx, DWORD PTR _j$[esp-4]
	cmp	edx, 6
	ja	SHORT $LN3@getXYCityP
	push	esi

; 2562 : 
; 2563 : 	return m_aaiXYCityPlot[i][j];

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	add	esi, edx
	mov	eax, DWORD PTR [ecx+esi*4+604]
	pop	esi

; 2564 : }

	ret	8
$LN3@getXYCityP:

; 2555 : 	CvAssertMsg(i < CITY_PLOTS_DIAMETER, "Index out of bounds");
; 2556 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2557 : 	if(i < 0 || i >= CITY_PLOTS_DIAMETER) return -1;

	or	eax, -1

; 2564 : }

	ret	8
?getXYCityPlot@CvGlobals@@QAEHHH@Z ENDP			; CvGlobals::getXYCityPlot
_TEXT	ENDS
PUBLIC	?getTurnLeftDirection@CvGlobals@@QAEPAW4DirectionTypes@@XZ ; CvGlobals::getTurnLeftDirection
; Function compile flags: /Ogtpy
;	COMDAT ?getTurnLeftDirection@CvGlobals@@QAEPAW4DirectionTypes@@XZ
_TEXT	SEGMENT
?getTurnLeftDirection@CvGlobals@@QAEPAW4DirectionTypes@@XZ PROC ; CvGlobals::getTurnLeftDirection, COMDAT
; _this$ = ecx

; 2568 : 	return m_aeTurnLeftDirection;

	lea	eax, DWORD PTR [ecx+800]

; 2569 : }

	ret	0
?getTurnLeftDirection@CvGlobals@@QAEPAW4DirectionTypes@@XZ ENDP ; CvGlobals::getTurnLeftDirection
_TEXT	ENDS
PUBLIC	?getTurnLeftDirection@CvGlobals@@QAE?AW4DirectionTypes@@H@Z ; CvGlobals::getTurnLeftDirection
; Function compile flags: /Ogtpy
;	COMDAT ?getTurnLeftDirection@CvGlobals@@QAE?AW4DirectionTypes@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getTurnLeftDirection@CvGlobals@@QAE?AW4DirectionTypes@@H@Z PROC ; CvGlobals::getTurnLeftDirection, COMDAT
; _this$ = ecx

; 2573 : 	CvAssertMsg(i < NUM_DIRECTION_TYPES, "Index out of bounds");
; 2574 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2575 : 
; 2576 : 	if(i < 0 || i >= NUM_DIRECTION_TYPES) return NO_DIRECTION;

	mov	eax, DWORD PTR _i$[esp-4]
	cmp	eax, 5
	ja	SHORT $LN1@getTurnLef

; 2577 : 
; 2578 : 	return m_aeTurnLeftDirection[i];

	mov	eax, DWORD PTR [ecx+eax*4+800]

; 2579 : }

	ret	4
$LN1@getTurnLef:

; 2573 : 	CvAssertMsg(i < NUM_DIRECTION_TYPES, "Index out of bounds");
; 2574 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2575 : 
; 2576 : 	if(i < 0 || i >= NUM_DIRECTION_TYPES) return NO_DIRECTION;

	or	eax, -1

; 2579 : }

	ret	4
?getTurnLeftDirection@CvGlobals@@QAE?AW4DirectionTypes@@H@Z ENDP ; CvGlobals::getTurnLeftDirection
_TEXT	ENDS
PUBLIC	?getTurnRightDirection@CvGlobals@@QAEPAW4DirectionTypes@@XZ ; CvGlobals::getTurnRightDirection
; Function compile flags: /Ogtpy
;	COMDAT ?getTurnRightDirection@CvGlobals@@QAEPAW4DirectionTypes@@XZ
_TEXT	SEGMENT
?getTurnRightDirection@CvGlobals@@QAEPAW4DirectionTypes@@XZ PROC ; CvGlobals::getTurnRightDirection, COMDAT
; _this$ = ecx

; 2583 : 	return m_aeTurnRightDirection;

	lea	eax, DWORD PTR [ecx+824]

; 2584 : }

	ret	0
?getTurnRightDirection@CvGlobals@@QAEPAW4DirectionTypes@@XZ ENDP ; CvGlobals::getTurnRightDirection
_TEXT	ENDS
PUBLIC	?getTurnRightDirection@CvGlobals@@QAE?AW4DirectionTypes@@H@Z ; CvGlobals::getTurnRightDirection
; Function compile flags: /Ogtpy
;	COMDAT ?getTurnRightDirection@CvGlobals@@QAE?AW4DirectionTypes@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getTurnRightDirection@CvGlobals@@QAE?AW4DirectionTypes@@H@Z PROC ; CvGlobals::getTurnRightDirection, COMDAT
; _this$ = ecx

; 2588 : 	CvAssertMsg(i < NUM_DIRECTION_TYPES, "Index out of bounds");
; 2589 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2590 : 
; 2591 : 	if(i < 0 || i >= NUM_DIRECTION_TYPES) return NO_DIRECTION;

	mov	eax, DWORD PTR _i$[esp-4]
	cmp	eax, 5
	ja	SHORT $LN1@getTurnRig

; 2592 : 
; 2593 : 	return m_aeTurnRightDirection[i];

	mov	eax, DWORD PTR [ecx+eax*4+824]

; 2594 : }

	ret	4
$LN1@getTurnRig:

; 2588 : 	CvAssertMsg(i < NUM_DIRECTION_TYPES, "Index out of bounds");
; 2589 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2590 : 
; 2591 : 	if(i < 0 || i >= NUM_DIRECTION_TYPES) return NO_DIRECTION;

	or	eax, -1

; 2594 : }

	ret	4
?getTurnRightDirection@CvGlobals@@QAE?AW4DirectionTypes@@H@Z ENDP ; CvGlobals::getTurnRightDirection
_TEXT	ENDS
PUBLIC	?GetColorInfo@CvGlobals@@QAEAAV?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@XZ ; CvGlobals::GetColorInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetColorInfo@CvGlobals@@QAEAAV?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetColorInfo@CvGlobals@@QAEAAV?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@XZ PROC ; CvGlobals::GetColorInfo, COMDAT
; _this$ = ecx

; 2624 : 	return m_paColorInfo;

	lea	eax, DWORD PTR [ecx+1036]

; 2625 : }

	ret	0
?GetColorInfo@CvGlobals@@QAEAAV?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@XZ ENDP ; CvGlobals::GetColorInfo
_TEXT	ENDS
PUBLIC	?GetPlayerColorInfo@CvGlobals@@QAEAAV?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@XZ ; CvGlobals::GetPlayerColorInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerColorInfo@CvGlobals@@QAEAAV?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetPlayerColorInfo@CvGlobals@@QAEAAV?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@XZ PROC ; CvGlobals::GetPlayerColorInfo, COMDAT
; _this$ = ecx

; 2655 : 	return m_paPlayerColorInfo;

	lea	eax, DWORD PTR [ecx+1052]

; 2656 : }

	ret	0
?GetPlayerColorInfo@CvGlobals@@QAEAAV?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@XZ ENDP ; CvGlobals::GetPlayerColorInfo
_TEXT	ENDS
PUBLIC	?getEntityEventInfo@CvGlobals@@QAEAAV?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@XZ ; CvGlobals::getEntityEventInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getEntityEventInfo@CvGlobals@@QAEAAV?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getEntityEventInfo@CvGlobals@@QAEAAV?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@XZ PROC ; CvGlobals::getEntityEventInfo, COMDAT
; _this$ = ecx

; 2685 : 	return m_paEntityEventInfo;

	lea	eax, DWORD PTR [ecx+1620]

; 2686 : }

	ret	0
?getEntityEventInfo@CvGlobals@@QAEAAV?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getEntityEventInfo
_TEXT	ENDS
PUBLIC	?getMultiUnitFormationInfo@CvGlobals@@QAEAAV?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@XZ ; CvGlobals::getMultiUnitFormationInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getMultiUnitFormationInfo@CvGlobals@@QAEAAV?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getMultiUnitFormationInfo@CvGlobals@@QAEAAV?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@XZ PROC ; CvGlobals::getMultiUnitFormationInfo, COMDAT
; _this$ = ecx

; 2715 : 	return m_paMultiUnitFormationInfo;

	lea	eax, DWORD PTR [ecx+1652]

; 2716 : }

	ret	0
?getMultiUnitFormationInfo@CvGlobals@@QAEAAV?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getMultiUnitFormationInfo
_TEXT	ENDS
PUBLIC	?getTerrainInfo@CvGlobals@@QAEAAV?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@XZ ; CvGlobals::getTerrainInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getTerrainInfo@CvGlobals@@QAEAAV?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getTerrainInfo@CvGlobals@@QAEAAV?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@XZ PROC ; CvGlobals::getTerrainInfo, COMDAT
; _this$ = ecx

; 2745 : 	return m_paTerrainInfo;

	lea	eax, DWORD PTR [ecx+1068]

; 2746 : }

	ret	0
?getTerrainInfo@CvGlobals@@QAEAAV?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getTerrainInfo
_TEXT	ENDS
PUBLIC	?getResourceClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@XZ ; CvGlobals::getResourceClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getResourceClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getResourceClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@XZ PROC ; CvGlobals::getResourceClassInfo, COMDAT
; _this$ = ecx

; 2771 : 	return m_paResourceClassInfo;

	lea	eax, DWORD PTR [ecx+1132]

; 2772 : }

	ret	0
?getResourceClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getResourceClassInfo
_TEXT	ENDS
PUBLIC	?getResourceInfo@CvGlobals@@QAEAAV?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@XZ ; CvGlobals::getResourceInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getResourceInfo@CvGlobals@@QAEAAV?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getResourceInfo@CvGlobals@@QAEAAV?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@XZ PROC ; CvGlobals::getResourceInfo, COMDAT
; _this$ = ecx

; 2802 : 	return m_paResourceInfo;

	lea	eax, DWORD PTR [ecx+1148]

; 2803 : }

	ret	0
?getResourceInfo@CvGlobals@@QAEAAV?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getResourceInfo
_TEXT	ENDS
PUBLIC	?getFeatureInfo@CvGlobals@@QAEAAV?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@XZ ; CvGlobals::getFeatureInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureInfo@CvGlobals@@QAEAAV?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getFeatureInfo@CvGlobals@@QAEAAV?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@XZ PROC ; CvGlobals::getFeatureInfo, COMDAT
; _this$ = ecx

; 2828 : 	return m_paFeatureInfo;

	lea	eax, DWORD PTR [ecx+1116]

; 2829 : }

	ret	0
?getFeatureInfo@CvGlobals@@QAEAAV?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getFeatureInfo
_TEXT	ENDS
PUBLIC	?getNumPlayableCivilizationInfos@CvGlobals@@QAEAAHXZ ; CvGlobals::getNumPlayableCivilizationInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumPlayableCivilizationInfos@CvGlobals@@QAEAAHXZ
_TEXT	SEGMENT
?getNumPlayableCivilizationInfos@CvGlobals@@QAEAAHXZ PROC ; CvGlobals::getNumPlayableCivilizationInfos, COMDAT
; _this$ = ecx

; 2843 : 	return m_iNumPlayableCivilizationInfos;

	lea	eax, DWORD PTR [ecx+1244]

; 2844 : }

	ret	0
?getNumPlayableCivilizationInfos@CvGlobals@@QAEAAHXZ ENDP ; CvGlobals::getNumPlayableCivilizationInfos
_TEXT	ENDS
PUBLIC	?getNumAIPlayableCivilizationInfos@CvGlobals@@QAEAAHXZ ; CvGlobals::getNumAIPlayableCivilizationInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumAIPlayableCivilizationInfos@CvGlobals@@QAEAAHXZ
_TEXT	SEGMENT
?getNumAIPlayableCivilizationInfos@CvGlobals@@QAEAAHXZ PROC ; CvGlobals::getNumAIPlayableCivilizationInfos, COMDAT
; _this$ = ecx

; 2848 : 	return m_iNumAIPlayableCivilizationInfos;

	lea	eax, DWORD PTR [ecx+1248]

; 2849 : }

	ret	0
?getNumAIPlayableCivilizationInfos@CvGlobals@@QAEAAHXZ ENDP ; CvGlobals::getNumAIPlayableCivilizationInfos
_TEXT	ENDS
PUBLIC	?getCivilizationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@XZ ; CvGlobals::getCivilizationInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getCivilizationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getCivilizationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@XZ PROC ; CvGlobals::getCivilizationInfo, COMDAT
; _this$ = ecx

; 2864 : 	return m_paCivilizationInfo;

	lea	eax, DWORD PTR [ecx+1228]

; 2865 : }

	ret	0
?getCivilizationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getCivilizationInfo
_TEXT	ENDS
PUBLIC	?getMinorCivInfo@CvGlobals@@QAEAAV?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@XZ ; CvGlobals::getMinorCivInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getMinorCivInfo@CvGlobals@@QAEAAV?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getMinorCivInfo@CvGlobals@@QAEAAV?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@XZ PROC ; CvGlobals::getMinorCivInfo, COMDAT
; _this$ = ecx

; 2934 : 	return m_paMinorCivInfo;

	lea	eax, DWORD PTR [ecx+1252]

; 2935 : }

	ret	0
?getMinorCivInfo@CvGlobals@@QAEAAV?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getMinorCivInfo
_TEXT	ENDS
PUBLIC	?getLeaderHeadInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@XZ ; CvGlobals::getLeaderHeadInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getLeaderHeadInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getLeaderHeadInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@XZ PROC ; CvGlobals::getLeaderHeadInfo, COMDAT
; _this$ = ecx

; 2960 : 	return m_paLeaderHeadInfo;

	lea	eax, DWORD PTR [ecx+1268]

; 2961 : }

	ret	0
?getLeaderHeadInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getLeaderHeadInfo
_TEXT	ENDS
PUBLIC	?getNumUnitInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumUnitInfos
EXTRN	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ:PROC	; CvUnitXMLEntries::GetNumUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getNumUnitInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumUnitInfos@CvGlobals@@QAEHXZ PROC			; CvGlobals::getNumUnitInfos, COMDAT
; _this$ = ecx

; 2983 : 	return m_pUnits->GetNumUnits();

	mov	ecx, DWORD PTR [ecx+1704]
	jmp	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ	; CvUnitXMLEntries::GetNumUnits
?getNumUnitInfos@CvGlobals@@QAEHXZ ENDP			; CvGlobals::getNumUnitInfos
_TEXT	ENDS
PUBLIC	?getUnitInfo@CvGlobals@@QAEAAV?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@XZ ; CvGlobals::getUnitInfo
EXTRN	?GetUnitEntries@CvUnitXMLEntries@@QAEAAV?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@XZ:PROC ; CvUnitXMLEntries::GetUnitEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitInfo@CvGlobals@@QAEAAV?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getUnitInfo@CvGlobals@@QAEAAV?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@XZ PROC ; CvGlobals::getUnitInfo, COMDAT
; _this$ = ecx

; 2988 : 	return m_pUnits->GetUnitEntries();

	mov	ecx, DWORD PTR [ecx+1704]
	jmp	?GetUnitEntries@CvUnitXMLEntries@@QAEAAV?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@XZ ; CvUnitXMLEntries::GetUnitEntries
?getUnitInfo@CvGlobals@@QAEAAV?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getUnitInfo
_TEXT	ENDS
PUBLIC	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ PROC ; CvGlobals::GetGameUnits, COMDAT
; _this$ = ecx

; 3014 : 	return m_pUnits;

	mov	eax, DWORD PTR [ecx+1704]

; 3015 : }

	ret	0
?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ENDP ; CvGlobals::GetGameUnits
_TEXT	ENDS
PUBLIC	?getSpecialUnitInfo@CvGlobals@@QAEAAV?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@XZ ; CvGlobals::getSpecialUnitInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getSpecialUnitInfo@CvGlobals@@QAEAAV?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getSpecialUnitInfo@CvGlobals@@QAEAAV?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@XZ PROC ; CvGlobals::getSpecialUnitInfo, COMDAT
; _this$ = ecx

; 3030 : 	return m_paSpecialUnitInfo;

	lea	eax, DWORD PTR [ecx+1348]

; 3031 : }

	ret	0
?getSpecialUnitInfo@CvGlobals@@QAEAAV?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getSpecialUnitInfo
_TEXT	ENDS
PUBLIC	?getVoteSourceInfo@CvGlobals@@QAEAAV?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@XZ ; CvGlobals::getVoteSourceInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getVoteSourceInfo@CvGlobals@@QAEAAV?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getVoteSourceInfo@CvGlobals@@QAEAAV?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@XZ PROC ; CvGlobals::getVoteSourceInfo, COMDAT
; _this$ = ecx

; 3065 : 	return m_paVoteSourceInfo;

	lea	eax, DWORD PTR [ecx+1364]

; 3066 : }

	ret	0
?getVoteSourceInfo@CvGlobals@@QAEAAV?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getVoteSourceInfo
_TEXT	ENDS
PUBLIC	?getUnitCombatClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@XZ ; CvGlobals::getUnitCombatClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitCombatClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getUnitCombatClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@XZ PROC ; CvGlobals::getUnitCombatClassInfo, COMDAT
; _this$ = ecx

; 3100 : 	return m_paUnitCombatClassInfo;

	lea	eax, DWORD PTR [ecx+1380]

; 3101 : }

	ret	0
?getUnitCombatClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getUnitCombatClassInfo
_TEXT	ENDS
PUBLIC	?getUnitAIInfo@CvGlobals@@QAEAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@XZ ; CvGlobals::getUnitAIInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitAIInfo@CvGlobals@@QAEAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getUnitAIInfo@CvGlobals@@QAEAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@XZ PROC ; CvGlobals::getUnitAIInfo, COMDAT
; _this$ = ecx

; 3124 : 	return m_paUnitAIInfos;

	lea	eax, DWORD PTR [ecx+1396]

; 3125 : }

	ret	0
?getUnitAIInfo@CvGlobals@@QAEAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getUnitAIInfo
_TEXT	ENDS
PUBLIC	?getGameOptionInfo@CvGlobals@@QAEAAV?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@XZ ; CvGlobals::getGameOptionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getGameOptionInfo@CvGlobals@@QAEAAV?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getGameOptionInfo@CvGlobals@@QAEAAV?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@XZ PROC ; CvGlobals::getGameOptionInfo, COMDAT
; _this$ = ecx

; 3159 : 	return m_paGameOptionInfos;

	lea	eax, DWORD PTR [ecx+1412]

; 3160 : }

	ret	0
?getGameOptionInfo@CvGlobals@@QAEAAV?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getGameOptionInfo
_TEXT	ENDS
PUBLIC	?getMPOptionInfo@CvGlobals@@QAEAAV?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@XZ ; CvGlobals::getMPOptionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getMPOptionInfo@CvGlobals@@QAEAAV?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getMPOptionInfo@CvGlobals@@QAEAAV?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@XZ PROC ; CvGlobals::getMPOptionInfo, COMDAT
; _this$ = ecx

; 3194 : 	return m_paMPOptionInfos;

	lea	eax, DWORD PTR [ecx+1428]

; 3195 : }

	ret	0
?getMPOptionInfo@CvGlobals@@QAEAAV?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getMPOptionInfo
_TEXT	ENDS
PUBLIC	?getPlayerOptionInfo@CvGlobals@@QAEAAV?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@XZ ; CvGlobals::getPlayerOptionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerOptionInfo@CvGlobals@@QAEAAV?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getPlayerOptionInfo@CvGlobals@@QAEAAV?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@XZ PROC ; CvGlobals::getPlayerOptionInfo, COMDAT
; _this$ = ecx

; 3218 : 	return m_paPlayerOptionInfos;

	lea	eax, DWORD PTR [ecx+1444]

; 3219 : }

	ret	0
?getPlayerOptionInfo@CvGlobals@@QAEAAV?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getPlayerOptionInfo
_TEXT	ENDS
PUBLIC	?getYieldInfo@CvGlobals@@QAEAAV?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@XZ ; CvGlobals::getYieldInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getYieldInfo@CvGlobals@@QAEAAV?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getYieldInfo@CvGlobals@@QAEAAV?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@XZ PROC ; CvGlobals::getYieldInfo, COMDAT
; _this$ = ecx

; 3241 : 	return m_paYieldInfo;

	lea	eax, DWORD PTR [ecx+1084]

; 3242 : }

	ret	0
?getYieldInfo@CvGlobals@@QAEAAV?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getYieldInfo
_TEXT	ENDS
PUBLIC	?getRouteInfo@CvGlobals@@QAEAAV?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@XZ ; CvGlobals::getRouteInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getRouteInfo@CvGlobals@@QAEAAV?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getRouteInfo@CvGlobals@@QAEAAV?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@XZ PROC ; CvGlobals::getRouteInfo, COMDAT
; _this$ = ecx

; 3280 : 	return m_paRouteInfo;

	lea	eax, DWORD PTR [ecx+1100]

; 3281 : }

	ret	0
?getRouteInfo@CvGlobals@@QAEAAV?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getRouteInfo
_TEXT	ENDS
PUBLIC	?getNumImprovementInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumImprovementInfos
EXTRN	?GetNumImprovements@CvImprovementXMLEntries@@QAEHXZ:PROC ; CvImprovementXMLEntries::GetNumImprovements
; Function compile flags: /Ogtpy
;	COMDAT ?getNumImprovementInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumImprovementInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumImprovementInfos, COMDAT
; _this$ = ecx

; 3308 : 	return m_pImprovements->GetNumImprovements();

	mov	ecx, DWORD PTR [ecx+1716]
	jmp	?GetNumImprovements@CvImprovementXMLEntries@@QAEHXZ ; CvImprovementXMLEntries::GetNumImprovements
?getNumImprovementInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumImprovementInfos
_TEXT	ENDS
PUBLIC	?getImprovementInfo@CvGlobals@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ ; CvGlobals::getImprovementInfo
EXTRN	?GetImprovementEntries@CvImprovementXMLEntries@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ:PROC ; CvImprovementXMLEntries::GetImprovementEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovementInfo@CvGlobals@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getImprovementInfo@CvGlobals@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ PROC ; CvGlobals::getImprovementInfo, COMDAT
; _this$ = ecx

; 3313 : 	return m_pImprovements->GetImprovementEntries();

	mov	ecx, DWORD PTR [ecx+1716]
	jmp	?GetImprovementEntries@CvImprovementXMLEntries@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ ; CvImprovementXMLEntries::GetImprovementEntries
?getImprovementInfo@CvGlobals@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getImprovementInfo
_TEXT	ENDS
PUBLIC	?GetGameImprovements@CvGlobals@@QBEPAVCvImprovementXMLEntries@@XZ ; CvGlobals::GetGameImprovements
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameImprovements@CvGlobals@@QBEPAVCvImprovementXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameImprovements@CvGlobals@@QBEPAVCvImprovementXMLEntries@@XZ PROC ; CvGlobals::GetGameImprovements, COMDAT
; _this$ = ecx

; 3335 : 	return m_pImprovements;

	mov	eax, DWORD PTR [ecx+1716]

; 3336 : }

	ret	0
?GetGameImprovements@CvGlobals@@QBEPAVCvImprovementXMLEntries@@XZ ENDP ; CvGlobals::GetGameImprovements
_TEXT	ENDS
PUBLIC	?getBuildInfo@CvGlobals@@QAEAAV?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@XZ ; CvGlobals::getBuildInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildInfo@CvGlobals@@QAEAAV?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getBuildInfo@CvGlobals@@QAEAAV?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@XZ PROC ; CvGlobals::getBuildInfo, COMDAT
; _this$ = ecx

; 3351 : 	return m_paBuildInfo;

	lea	eax, DWORD PTR [ecx+1164]

; 3352 : }

	ret	0
?getBuildInfo@CvGlobals@@QAEAAV?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getBuildInfo
_TEXT	ENDS
PUBLIC	?getHandicapInfo@CvGlobals@@QAEAAV?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@XZ ; CvGlobals::getHandicapInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getHandicapInfo@CvGlobals@@QAEAAV?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getHandicapInfo@CvGlobals@@QAEAAV?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@XZ PROC ; CvGlobals::getHandicapInfo, COMDAT
; _this$ = ecx

; 3384 : 	return m_paHandicapInfo;

	lea	eax, DWORD PTR [ecx+1180]

; 3385 : }

	ret	0
?getHandicapInfo@CvGlobals@@QAEAAV?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getHandicapInfo
_TEXT	ENDS
PUBLIC	?getGameSpeedInfo@CvGlobals@@QAEAAV?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@XZ ; CvGlobals::getGameSpeedInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getGameSpeedInfo@CvGlobals@@QAEAAV?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getGameSpeedInfo@CvGlobals@@QAEAAV?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@XZ PROC ; CvGlobals::getGameSpeedInfo, COMDAT
; _this$ = ecx

; 3419 : 	return m_paGameSpeedInfo;

	lea	eax, DWORD PTR [ecx+1196]

; 3420 : }

	ret	0
?getGameSpeedInfo@CvGlobals@@QAEAAV?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getGameSpeedInfo
_TEXT	ENDS
PUBLIC	?getProcessInfo@CvGlobals@@QAEAAV?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@XZ ; CvGlobals::getProcessInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getProcessInfo@CvGlobals@@QAEAAV?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getProcessInfo@CvGlobals@@QAEAAV?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@XZ PROC ; CvGlobals::getProcessInfo, COMDAT
; _this$ = ecx

; 3454 : 	return m_paProcessInfo;

	lea	eax, DWORD PTR [ecx+1284]

; 3455 : }

	ret	0
?getProcessInfo@CvGlobals@@QAEAAV?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getProcessInfo
_TEXT	ENDS
PUBLIC	?getVoteInfo@CvGlobals@@QAEAAV?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@XZ ; CvGlobals::getVoteInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getVoteInfo@CvGlobals@@QAEAAV?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getVoteInfo@CvGlobals@@QAEAAV?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@XZ PROC ; CvGlobals::getVoteInfo, COMDAT
; _this$ = ecx

; 3487 : 	return m_paVoteInfo;

	lea	eax, DWORD PTR [ecx+1300]

; 3488 : }

	ret	0
?getVoteInfo@CvGlobals@@QAEAAV?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getVoteInfo
_TEXT	ENDS
PUBLIC	?getNumProjectInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumProjectInfos
EXTRN	?GetNumProjects@CvProjectXMLEntries@@QAEHXZ:PROC ; CvProjectXMLEntries::GetNumProjects
; Function compile flags: /Ogtpy
;	COMDAT ?getNumProjectInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumProjectInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumProjectInfos, COMDAT
; _this$ = ecx

; 3513 : 	return m_pProjects->GetNumProjects();

	mov	ecx, DWORD PTR [ecx+1708]
	jmp	?GetNumProjects@CvProjectXMLEntries@@QAEHXZ ; CvProjectXMLEntries::GetNumProjects
?getNumProjectInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumProjectInfos
_TEXT	ENDS
PUBLIC	?getProjectInfo@CvGlobals@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ ; CvGlobals::getProjectInfo
EXTRN	?GetProjectEntries@CvProjectXMLEntries@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ:PROC ; CvProjectXMLEntries::GetProjectEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getProjectInfo@CvGlobals@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getProjectInfo@CvGlobals@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ PROC ; CvGlobals::getProjectInfo, COMDAT
; _this$ = ecx

; 3518 : 	return m_pProjects->GetProjectEntries();

	mov	ecx, DWORD PTR [ecx+1708]
	jmp	?GetProjectEntries@CvProjectXMLEntries@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ ; CvProjectXMLEntries::GetProjectEntries
?getProjectInfo@CvGlobals@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getProjectInfo
_TEXT	ENDS
PUBLIC	?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ ; CvGlobals::GetGameProjects
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ PROC ; CvGlobals::GetGameProjects, COMDAT
; _this$ = ecx

; 3540 : 	return m_pProjects;

	mov	eax, DWORD PTR [ecx+1708]

; 3541 : }

	ret	0
?GetGameProjects@CvGlobals@@QBEPAVCvProjectXMLEntries@@XZ ENDP ; CvGlobals::GetGameProjects
_TEXT	ENDS
PUBLIC	?getBuildingClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@XZ ; CvGlobals::getBuildingClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildingClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getBuildingClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@XZ PROC ; CvGlobals::getBuildingClassInfo, COMDAT
; _this$ = ecx

; 3556 : 	return m_paBuildingClassInfo;

	lea	eax, DWORD PTR [ecx+1316]

; 3557 : }

	ret	0
?getBuildingClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getBuildingClassInfo
_TEXT	ENDS
PUBLIC	?getNumBuildingInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumBuildingInfos
EXTRN	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ:PROC ; CvBuildingXMLEntries::GetNumBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?getNumBuildingInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumBuildingInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumBuildingInfos, COMDAT
; _this$ = ecx

; 3584 : 	return m_pBuildings->GetNumBuildings();

	mov	ecx, DWORD PTR [ecx+1700]
	jmp	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
?getNumBuildingInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumBuildingInfos
_TEXT	ENDS
PUBLIC	?getBuildingInfo@CvGlobals@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ ; CvGlobals::getBuildingInfo
EXTRN	?GetBuildingEntries@CvBuildingXMLEntries@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ:PROC ; CvBuildingXMLEntries::GetBuildingEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildingInfo@CvGlobals@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getBuildingInfo@CvGlobals@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ PROC ; CvGlobals::getBuildingInfo, COMDAT
; _this$ = ecx

; 3589 : 	return m_pBuildings->GetBuildingEntries();

	mov	ecx, DWORD PTR [ecx+1700]
	jmp	?GetBuildingEntries@CvBuildingXMLEntries@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ ; CvBuildingXMLEntries::GetBuildingEntries
?getBuildingInfo@CvGlobals@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getBuildingInfo
_TEXT	ENDS
PUBLIC	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ PROC ; CvGlobals::GetGameBuildings, COMDAT
; _this$ = ecx

; 3613 : 	return m_pBuildings;

	mov	eax, DWORD PTR [ecx+1700]

; 3614 : }

	ret	0
?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ENDP ; CvGlobals::GetGameBuildings
_TEXT	ENDS
PUBLIC	?getUnitClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@XZ ; CvGlobals::getUnitClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getUnitClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@XZ PROC ; CvGlobals::getUnitClassInfo, COMDAT
; _this$ = ecx

; 3629 : 	return m_paUnitClassInfo;

	lea	eax, DWORD PTR [ecx+1332]

; 3630 : }

	ret	0
?getUnitClassInfo@CvGlobals@@QAEAAV?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getUnitClassInfo
_TEXT	ENDS
PUBLIC	?getActionInfo@CvGlobals@@QAEAAV?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@XZ ; CvGlobals::getActionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getActionInfo@CvGlobals@@QAEAAV?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getActionInfo@CvGlobals@@QAEAAV?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@XZ PROC ; CvGlobals::getActionInfo, COMDAT
; _this$ = ecx

; 3666 : 	return m_paActionInfo;

	lea	eax, DWORD PTR [ecx+1476]

; 3667 : }

	ret	0
?getActionInfo@CvGlobals@@QAEAAV?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getActionInfo
_TEXT	ENDS
PUBLIC	?getMissionInfo@CvGlobals@@QAEAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@XZ ; CvGlobals::getMissionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getMissionInfo@CvGlobals@@QAEAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getMissionInfo@CvGlobals@@QAEAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@XZ PROC ; CvGlobals::getMissionInfo, COMDAT
; _this$ = ecx

; 3688 : 	return m_paMissionInfo;

	lea	eax, DWORD PTR [ecx+1492]

; 3689 : }

	ret	0
?getMissionInfo@CvGlobals@@QAEAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getMissionInfo
_TEXT	ENDS
PUBLIC	?getControlInfo@CvGlobals@@QAEAAV?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@XZ ; CvGlobals::getControlInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getControlInfo@CvGlobals@@QAEAAV?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getControlInfo@CvGlobals@@QAEAAV?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@XZ PROC ; CvGlobals::getControlInfo, COMDAT
; _this$ = ecx

; 3712 : 	return m_paControlInfo;

	lea	eax, DWORD PTR [ecx+1508]

; 3713 : }

	ret	0
?getControlInfo@CvGlobals@@QAEAAV?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getControlInfo
_TEXT	ENDS
PUBLIC	?getCommandInfo@CvGlobals@@QAEAAV?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@XZ ; CvGlobals::getCommandInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getCommandInfo@CvGlobals@@QAEAAV?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getCommandInfo@CvGlobals@@QAEAAV?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@XZ PROC ; CvGlobals::getCommandInfo, COMDAT
; _this$ = ecx

; 3736 : 	return m_paCommandInfo;

	lea	eax, DWORD PTR [ecx+1524]

; 3737 : }

	ret	0
?getCommandInfo@CvGlobals@@QAEAAV?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getCommandInfo
_TEXT	ENDS
PUBLIC	?getAutomateInfo@CvGlobals@@QAEAAV?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@XZ ; CvGlobals::getAutomateInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getAutomateInfo@CvGlobals@@QAEAAV?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getAutomateInfo@CvGlobals@@QAEAAV?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@XZ PROC ; CvGlobals::getAutomateInfo, COMDAT
; _this$ = ecx

; 3771 : 	return m_paAutomateInfo;

	lea	eax, DWORD PTR [ecx+1540]

; 3772 : }

	ret	0
?getAutomateInfo@CvGlobals@@QAEAAV?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getAutomateInfo
_TEXT	ENDS
PUBLIC	?getPromotionInfo@CvGlobals@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ ; CvGlobals::getPromotionInfo
EXTRN	?GetPromotionEntries@CvPromotionXMLEntries@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ:PROC ; CvPromotionXMLEntries::GetPromotionEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getPromotionInfo@CvGlobals@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getPromotionInfo@CvGlobals@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ PROC ; CvGlobals::getPromotionInfo, COMDAT
; _this$ = ecx

; 3805 : 	return m_pPromotions->GetPromotionEntries();

	mov	ecx, DWORD PTR [ecx+1712]
	jmp	?GetPromotionEntries@CvPromotionXMLEntries@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ ; CvPromotionXMLEntries::GetPromotionEntries
?getPromotionInfo@CvGlobals@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getPromotionInfo
_TEXT	ENDS
PUBLIC	?GetGamePromotions@CvGlobals@@QBEPAVCvPromotionXMLEntries@@XZ ; CvGlobals::GetGamePromotions
; Function compile flags: /Ogtpy
;	COMDAT ?GetGamePromotions@CvGlobals@@QBEPAVCvPromotionXMLEntries@@XZ
_TEXT	SEGMENT
?GetGamePromotions@CvGlobals@@QBEPAVCvPromotionXMLEntries@@XZ PROC ; CvGlobals::GetGamePromotions, COMDAT
; _this$ = ecx

; 3829 : 	return m_pPromotions;

	mov	eax, DWORD PTR [ecx+1712]

; 3830 : }

	ret	0
?GetGamePromotions@CvGlobals@@QBEPAVCvPromotionXMLEntries@@XZ ENDP ; CvGlobals::GetGamePromotions
_TEXT	ENDS
PUBLIC	?getSpecialistInfo@CvGlobals@@QAEAAV?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@XZ ; CvGlobals::getSpecialistInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getSpecialistInfo@CvGlobals@@QAEAAV?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getSpecialistInfo@CvGlobals@@QAEAAV?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@XZ PROC ; CvGlobals::getSpecialistInfo, COMDAT
; _this$ = ecx

; 3845 : 	return m_paSpecialistInfo;

	lea	eax, DWORD PTR [ecx+1460]

; 3846 : }

	ret	0
?getSpecialistInfo@CvGlobals@@QAEAAV?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getSpecialistInfo
_TEXT	ENDS
PUBLIC	?getEconomicAIStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ ; CvGlobals::getEconomicAIStrategyInfo
EXTRN	?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ:PROC ; CvEconomicAIStrategyXMLEntries::GetEconomicAIStrategyEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getEconomicAIStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getEconomicAIStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ PROC ; CvGlobals::getEconomicAIStrategyInfo, COMDAT
; _this$ = ecx

; 3880 : 	return m_pEconomicAIStrategies->GetEconomicAIStrategyEntries();

	mov	ecx, DWORD PTR [ecx+1668]
	jmp	?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ ; CvEconomicAIStrategyXMLEntries::GetEconomicAIStrategyEntries
?getEconomicAIStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getEconomicAIStrategyInfo
_TEXT	ENDS
PUBLIC	?GetGameEconomicAIStrategies@CvGlobals@@QBEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvGlobals::GetGameEconomicAIStrategies
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameEconomicAIStrategies@CvGlobals@@QBEPAVCvEconomicAIStrategyXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameEconomicAIStrategies@CvGlobals@@QBEPAVCvEconomicAIStrategyXMLEntries@@XZ PROC ; CvGlobals::GetGameEconomicAIStrategies, COMDAT
; _this$ = ecx

; 3904 : 	return m_pEconomicAIStrategies;

	mov	eax, DWORD PTR [ecx+1668]

; 3905 : }

	ret	0
?GetGameEconomicAIStrategies@CvGlobals@@QBEPAVCvEconomicAIStrategyXMLEntries@@XZ ENDP ; CvGlobals::GetGameEconomicAIStrategies
_TEXT	ENDS
PUBLIC	?getCitySpecializationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ ; CvGlobals::getCitySpecializationInfo
EXTRN	?GetCitySpecializationEntries@CvCitySpecializationXMLEntries@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ:PROC ; CvCitySpecializationXMLEntries::GetCitySpecializationEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getCitySpecializationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getCitySpecializationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ PROC ; CvGlobals::getCitySpecializationInfo, COMDAT
; _this$ = ecx

; 3920 : 	return m_pCitySpecializations->GetCitySpecializationEntries();

	mov	ecx, DWORD PTR [ecx+1672]
	jmp	?GetCitySpecializationEntries@CvCitySpecializationXMLEntries@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ ; CvCitySpecializationXMLEntries::GetCitySpecializationEntries
?getCitySpecializationInfo@CvGlobals@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getCitySpecializationInfo
_TEXT	ENDS
PUBLIC	?GetGameCitySpecializations@CvGlobals@@QBEPAVCvCitySpecializationXMLEntries@@XZ ; CvGlobals::GetGameCitySpecializations
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameCitySpecializations@CvGlobals@@QBEPAVCvCitySpecializationXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameCitySpecializations@CvGlobals@@QBEPAVCvCitySpecializationXMLEntries@@XZ PROC ; CvGlobals::GetGameCitySpecializations, COMDAT
; _this$ = ecx

; 3944 : 	return m_pCitySpecializations;

	mov	eax, DWORD PTR [ecx+1672]

; 3945 : }

	ret	0
?GetGameCitySpecializations@CvGlobals@@QBEPAVCvCitySpecializationXMLEntries@@XZ ENDP ; CvGlobals::GetGameCitySpecializations
_TEXT	ENDS
PUBLIC	?getTacticalMoveInfo@CvGlobals@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ ; CvGlobals::getTacticalMoveInfo
EXTRN	?GetTacticalMoveEntries@CvTacticalMoveXMLEntries@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ:PROC ; CvTacticalMoveXMLEntries::GetTacticalMoveEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getTacticalMoveInfo@CvGlobals@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getTacticalMoveInfo@CvGlobals@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ PROC ; CvGlobals::getTacticalMoveInfo, COMDAT
; _this$ = ecx

; 3960 : 	return m_pTacticalMoves->GetTacticalMoveEntries();

	mov	ecx, DWORD PTR [ecx+1676]
	jmp	?GetTacticalMoveEntries@CvTacticalMoveXMLEntries@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ ; CvTacticalMoveXMLEntries::GetTacticalMoveEntries
?getTacticalMoveInfo@CvGlobals@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getTacticalMoveInfo
_TEXT	ENDS
PUBLIC	?GetGameTacticalMoves@CvGlobals@@QBEPAVCvTacticalMoveXMLEntries@@XZ ; CvGlobals::GetGameTacticalMoves
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameTacticalMoves@CvGlobals@@QBEPAVCvTacticalMoveXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameTacticalMoves@CvGlobals@@QBEPAVCvTacticalMoveXMLEntries@@XZ PROC ; CvGlobals::GetGameTacticalMoves, COMDAT
; _this$ = ecx

; 3984 : 	return m_pTacticalMoves;

	mov	eax, DWORD PTR [ecx+1676]

; 3985 : }

	ret	0
?GetGameTacticalMoves@CvGlobals@@QBEPAVCvTacticalMoveXMLEntries@@XZ ENDP ; CvGlobals::GetGameTacticalMoves
_TEXT	ENDS
PUBLIC	?getMilitaryAIStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ ; CvGlobals::getMilitaryAIStrategyInfo
EXTRN	?GetMilitaryAIStrategyEntries@CvMilitaryAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ:PROC ; CvMilitaryAIStrategyXMLEntries::GetMilitaryAIStrategyEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getMilitaryAIStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getMilitaryAIStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ PROC ; CvGlobals::getMilitaryAIStrategyInfo, COMDAT
; _this$ = ecx

; 4000 : 	return m_pMilitaryAIStrategies->GetMilitaryAIStrategyEntries();

	mov	ecx, DWORD PTR [ecx+1680]
	jmp	?GetMilitaryAIStrategyEntries@CvMilitaryAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ ; CvMilitaryAIStrategyXMLEntries::GetMilitaryAIStrategyEntries
?getMilitaryAIStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getMilitaryAIStrategyInfo
_TEXT	ENDS
PUBLIC	?GetGameMilitaryAIStrategies@CvGlobals@@QBEPAVCvMilitaryAIStrategyXMLEntries@@XZ ; CvGlobals::GetGameMilitaryAIStrategies
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameMilitaryAIStrategies@CvGlobals@@QBEPAVCvMilitaryAIStrategyXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameMilitaryAIStrategies@CvGlobals@@QBEPAVCvMilitaryAIStrategyXMLEntries@@XZ PROC ; CvGlobals::GetGameMilitaryAIStrategies, COMDAT
; _this$ = ecx

; 4022 : 	return m_pMilitaryAIStrategies;

	mov	eax, DWORD PTR [ecx+1680]

; 4023 : }

	ret	0
?GetGameMilitaryAIStrategies@CvGlobals@@QBEPAVCvMilitaryAIStrategyXMLEntries@@XZ ENDP ; CvGlobals::GetGameMilitaryAIStrategies
_TEXT	ENDS
PUBLIC	?getAIGrandStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@XZ ; CvGlobals::getAIGrandStrategyInfo
EXTRN	?GetAIGrandStrategyEntries@CvAIGrandStrategyXMLEntries@@QAEAAV?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@XZ:PROC ; CvAIGrandStrategyXMLEntries::GetAIGrandStrategyEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getAIGrandStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getAIGrandStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@XZ PROC ; CvGlobals::getAIGrandStrategyInfo, COMDAT
; _this$ = ecx

; 4038 : 	return m_pAIGrandStrategies->GetAIGrandStrategyEntries();

	mov	ecx, DWORD PTR [ecx+1684]
	jmp	?GetAIGrandStrategyEntries@CvAIGrandStrategyXMLEntries@@QAEAAV?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@XZ ; CvAIGrandStrategyXMLEntries::GetAIGrandStrategyEntries
?getAIGrandStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getAIGrandStrategyInfo
_TEXT	ENDS
PUBLIC	?GetGameAIGrandStrategies@CvGlobals@@QBEPAVCvAIGrandStrategyXMLEntries@@XZ ; CvGlobals::GetGameAIGrandStrategies
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameAIGrandStrategies@CvGlobals@@QBEPAVCvAIGrandStrategyXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameAIGrandStrategies@CvGlobals@@QBEPAVCvAIGrandStrategyXMLEntries@@XZ PROC ; CvGlobals::GetGameAIGrandStrategies, COMDAT
; _this$ = ecx

; 4061 : 	return m_pAIGrandStrategies;

	mov	eax, DWORD PTR [ecx+1684]

; 4062 : }

	ret	0
?GetGameAIGrandStrategies@CvGlobals@@QBEPAVCvAIGrandStrategyXMLEntries@@XZ ENDP ; CvGlobals::GetGameAIGrandStrategies
_TEXT	ENDS
PUBLIC	?getAICityStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ ; CvGlobals::getAICityStrategyInfo
EXTRN	?GetAICityStrategyEntries@CvAICityStrategies@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ:PROC ; CvAICityStrategies::GetAICityStrategyEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getAICityStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getAICityStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ PROC ; CvGlobals::getAICityStrategyInfo, COMDAT
; _this$ = ecx

; 4077 : 	return m_pAICityStrategies->GetAICityStrategyEntries();

	mov	ecx, DWORD PTR [ecx+1688]
	jmp	?GetAICityStrategyEntries@CvAICityStrategies@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ ; CvAICityStrategies::GetAICityStrategyEntries
?getAICityStrategyInfo@CvGlobals@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getAICityStrategyInfo
_TEXT	ENDS
PUBLIC	?GetGameAICityStrategies@CvGlobals@@QBEPAVCvAICityStrategies@@XZ ; CvGlobals::GetGameAICityStrategies
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameAICityStrategies@CvGlobals@@QBEPAVCvAICityStrategies@@XZ
_TEXT	SEGMENT
?GetGameAICityStrategies@CvGlobals@@QBEPAVCvAICityStrategies@@XZ PROC ; CvGlobals::GetGameAICityStrategies, COMDAT
; _this$ = ecx

; 4100 : 	return m_pAICityStrategies;

	mov	eax, DWORD PTR [ecx+1688]

; 4101 : }

	ret	0
?GetGameAICityStrategies@CvGlobals@@QBEPAVCvAICityStrategies@@XZ ENDP ; CvGlobals::GetGameAICityStrategies
_TEXT	ENDS
PUBLIC	?getPolicyInfo@CvGlobals@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ ; CvGlobals::getPolicyInfo
EXTRN	?GetPolicyEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ:PROC ; CvPolicyXMLEntries::GetPolicyEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getPolicyInfo@CvGlobals@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getPolicyInfo@CvGlobals@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ PROC ; CvGlobals::getPolicyInfo, COMDAT
; _this$ = ecx

; 4116 : 	return m_pPolicies->GetPolicyEntries();

	mov	ecx, DWORD PTR [ecx+1692]
	jmp	?GetPolicyEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ ; CvPolicyXMLEntries::GetPolicyEntries
?getPolicyInfo@CvGlobals@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getPolicyInfo
_TEXT	ENDS
PUBLIC	?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ ; CvGlobals::GetGamePolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ
_TEXT	SEGMENT
?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ PROC ; CvGlobals::GetGamePolicies, COMDAT
; _this$ = ecx

; 4139 : 	return m_pPolicies;

	mov	eax, DWORD PTR [ecx+1692]

; 4140 : }

	ret	0
?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ ENDP ; CvGlobals::GetGamePolicies
_TEXT	ENDS
PUBLIC	?getPolicyBranchInfo@CvGlobals@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ ; CvGlobals::getPolicyBranchInfo
EXTRN	?GetPolicyBranchEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ:PROC ; CvPolicyXMLEntries::GetPolicyBranchEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getPolicyBranchInfo@CvGlobals@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getPolicyBranchInfo@CvGlobals@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ PROC ; CvGlobals::getPolicyBranchInfo, COMDAT
; _this$ = ecx

; 4155 : 	return m_pPolicies->GetPolicyBranchEntries();

	mov	ecx, DWORD PTR [ecx+1692]
	jmp	?GetPolicyBranchEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ ; CvPolicyXMLEntries::GetPolicyBranchEntries
?getPolicyBranchInfo@CvGlobals@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getPolicyBranchInfo
_TEXT	ENDS
PUBLIC	?getEmphasisInfo@CvGlobals@@QAEAAV?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@XZ ; CvGlobals::getEmphasisInfo
EXTRN	?GetEmphasisEntries@CvEmphasisXMLEntries@@QAEAAV?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@XZ:PROC ; CvEmphasisXMLEntries::GetEmphasisEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getEmphasisInfo@CvGlobals@@QAEAAV?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getEmphasisInfo@CvGlobals@@QAEAAV?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@XZ PROC ; CvGlobals::getEmphasisInfo, COMDAT
; _this$ = ecx

; 4189 : 	return m_pEmphases->GetEmphasisEntries();

	mov	ecx, DWORD PTR [ecx+1720]
	jmp	?GetEmphasisEntries@CvEmphasisXMLEntries@@QAEAAV?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@XZ ; CvEmphasisXMLEntries::GetEmphasisEntries
?getEmphasisInfo@CvGlobals@@QAEAAV?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getEmphasisInfo
_TEXT	ENDS
PUBLIC	?GetGameEmphases@CvGlobals@@QBEPAVCvEmphasisXMLEntries@@XZ ; CvGlobals::GetGameEmphases
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameEmphases@CvGlobals@@QBEPAVCvEmphasisXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameEmphases@CvGlobals@@QBEPAVCvEmphasisXMLEntries@@XZ PROC ; CvGlobals::GetGameEmphases, COMDAT
; _this$ = ecx

; 4212 : 	return m_pEmphases;

	mov	eax, DWORD PTR [ecx+1720]

; 4213 : }

	ret	0
?GetGameEmphases@CvGlobals@@QBEPAVCvEmphasisXMLEntries@@XZ ENDP ; CvGlobals::GetGameEmphases
_TEXT	ENDS
PUBLIC	?getTraitInfo@CvGlobals@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ ; CvGlobals::getTraitInfo
EXTRN	?GetTraitEntries@CvTraitXMLEntries@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ:PROC ; CvTraitXMLEntries::GetTraitEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getTraitInfo@CvGlobals@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getTraitInfo@CvGlobals@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ PROC ; CvGlobals::getTraitInfo, COMDAT
; _this$ = ecx

; 4228 : 	return m_pTraits->GetTraitEntries();

	mov	ecx, DWORD PTR [ecx+1724]
	jmp	?GetTraitEntries@CvTraitXMLEntries@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ ; CvTraitXMLEntries::GetTraitEntries
?getTraitInfo@CvGlobals@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getTraitInfo
_TEXT	ENDS
PUBLIC	?GetGameTraits@CvGlobals@@QBEPAVCvTraitXMLEntries@@XZ ; CvGlobals::GetGameTraits
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameTraits@CvGlobals@@QBEPAVCvTraitXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameTraits@CvGlobals@@QBEPAVCvTraitXMLEntries@@XZ PROC ; CvGlobals::GetGameTraits, COMDAT
; _this$ = ecx

; 4251 : 	return m_pTraits;

	mov	eax, DWORD PTR [ecx+1724]

; 4252 : }

	ret	0
?GetGameTraits@CvGlobals@@QBEPAVCvTraitXMLEntries@@XZ ENDP ; CvGlobals::GetGameTraits
_TEXT	ENDS
PUBLIC	?getReligionInfo@CvGlobals@@QAEAAV?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@XZ ; CvGlobals::getReligionInfo
EXTRN	?GetReligionEntries@CvReligionXMLEntries@@QAEAAV?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@XZ:PROC ; CvReligionXMLEntries::GetReligionEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getReligionInfo@CvGlobals@@QAEAAV?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getReligionInfo@CvGlobals@@QAEAAV?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@XZ PROC ; CvGlobals::getReligionInfo, COMDAT
; _this$ = ecx

; 4267 : 	return m_pReligions->GetReligionEntries();

	mov	ecx, DWORD PTR [ecx+1728]
	jmp	?GetReligionEntries@CvReligionXMLEntries@@QAEAAV?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@XZ ; CvReligionXMLEntries::GetReligionEntries
?getReligionInfo@CvGlobals@@QAEAAV?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getReligionInfo
_TEXT	ENDS
PUBLIC	?GetGameReligions@CvGlobals@@QBEPAVCvReligionXMLEntries@@XZ ; CvGlobals::GetGameReligions
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameReligions@CvGlobals@@QBEPAVCvReligionXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameReligions@CvGlobals@@QBEPAVCvReligionXMLEntries@@XZ PROC ; CvGlobals::GetGameReligions, COMDAT
; _this$ = ecx

; 4290 : 	return m_pReligions;

	mov	eax, DWORD PTR [ecx+1728]

; 4291 : }

	ret	0
?GetGameReligions@CvGlobals@@QBEPAVCvReligionXMLEntries@@XZ ENDP ; CvGlobals::GetGameReligions
_TEXT	ENDS
PUBLIC	?getBeliefInfo@CvGlobals@@QAEAAV?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@XZ ; CvGlobals::getBeliefInfo
EXTRN	?GetBeliefEntries@CvBeliefXMLEntries@@QAEAAV?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@XZ:PROC ; CvBeliefXMLEntries::GetBeliefEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getBeliefInfo@CvGlobals@@QAEAAV?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getBeliefInfo@CvGlobals@@QAEAAV?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@XZ PROC ; CvGlobals::getBeliefInfo, COMDAT
; _this$ = ecx

; 4306 : 	return m_pBeliefs->GetBeliefEntries();

	mov	ecx, DWORD PTR [ecx+1732]
	jmp	?GetBeliefEntries@CvBeliefXMLEntries@@QAEAAV?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@XZ ; CvBeliefXMLEntries::GetBeliefEntries
?getBeliefInfo@CvGlobals@@QAEAAV?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getBeliefInfo
_TEXT	ENDS
PUBLIC	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ PROC ; CvGlobals::GetGameBeliefs, COMDAT
; _this$ = ecx

; 4329 : 	return m_pBeliefs;

	mov	eax, DWORD PTR [ecx+1732]

; 4330 : }

	ret	0
?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ENDP ; CvGlobals::GetGameBeliefs
_TEXT	ENDS
PUBLIC	?getLeagueSpecialSessionInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@XZ ; CvGlobals::getLeagueSpecialSessionInfo
EXTRN	?GetLeagueSpecialSessionEntries@CvLeagueSpecialSessionXMLEntries@@QAEAAV?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@XZ:PROC ; CvLeagueSpecialSessionXMLEntries::GetLeagueSpecialSessionEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getLeagueSpecialSessionInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getLeagueSpecialSessionInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@XZ PROC ; CvGlobals::getLeagueSpecialSessionInfo, COMDAT
; _this$ = ecx

; 4345 : 	return m_pLeagueSpecialSessions->GetLeagueSpecialSessionEntries();

	mov	ecx, DWORD PTR [ecx+1736]
	jmp	?GetLeagueSpecialSessionEntries@CvLeagueSpecialSessionXMLEntries@@QAEAAV?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@XZ ; CvLeagueSpecialSessionXMLEntries::GetLeagueSpecialSessionEntries
?getLeagueSpecialSessionInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getLeagueSpecialSessionInfo
_TEXT	ENDS
PUBLIC	?GetGameLeagueSpecialSessions@CvGlobals@@QBEPAVCvLeagueSpecialSessionXMLEntries@@XZ ; CvGlobals::GetGameLeagueSpecialSessions
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameLeagueSpecialSessions@CvGlobals@@QBEPAVCvLeagueSpecialSessionXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameLeagueSpecialSessions@CvGlobals@@QBEPAVCvLeagueSpecialSessionXMLEntries@@XZ PROC ; CvGlobals::GetGameLeagueSpecialSessions, COMDAT
; _this$ = ecx

; 4366 : 	return m_pLeagueSpecialSessions;

	mov	eax, DWORD PTR [ecx+1736]

; 4367 : }

	ret	0
?GetGameLeagueSpecialSessions@CvGlobals@@QBEPAVCvLeagueSpecialSessionXMLEntries@@XZ ENDP ; CvGlobals::GetGameLeagueSpecialSessions
_TEXT	ENDS
PUBLIC	?getLeagueNameInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@XZ ; CvGlobals::getLeagueNameInfo
EXTRN	?GetLeagueNameEntries@CvLeagueNameXMLEntries@@QAEAAV?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@XZ:PROC ; CvLeagueNameXMLEntries::GetLeagueNameEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getLeagueNameInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getLeagueNameInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@XZ PROC ; CvGlobals::getLeagueNameInfo, COMDAT
; _this$ = ecx

; 4382 : 	return m_pLeagueNames->GetLeagueNameEntries();

	mov	ecx, DWORD PTR [ecx+1740]
	jmp	?GetLeagueNameEntries@CvLeagueNameXMLEntries@@QAEAAV?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@XZ ; CvLeagueNameXMLEntries::GetLeagueNameEntries
?getLeagueNameInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getLeagueNameInfo
_TEXT	ENDS
PUBLIC	?GetGameLeagueNames@CvGlobals@@QBEPAVCvLeagueNameXMLEntries@@XZ ; CvGlobals::GetGameLeagueNames
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameLeagueNames@CvGlobals@@QBEPAVCvLeagueNameXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameLeagueNames@CvGlobals@@QBEPAVCvLeagueNameXMLEntries@@XZ PROC ; CvGlobals::GetGameLeagueNames, COMDAT
; _this$ = ecx

; 4405 : 	return m_pLeagueNames;

	mov	eax, DWORD PTR [ecx+1740]

; 4406 : }

	ret	0
?GetGameLeagueNames@CvGlobals@@QBEPAVCvLeagueNameXMLEntries@@XZ ENDP ; CvGlobals::GetGameLeagueNames
_TEXT	ENDS
PUBLIC	?getLeagueProjectInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@XZ ; CvGlobals::getLeagueProjectInfo
EXTRN	?GetLeagueProjectEntries@CvLeagueProjectXMLEntries@@QAEAAV?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@XZ:PROC ; CvLeagueProjectXMLEntries::GetLeagueProjectEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getLeagueProjectInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getLeagueProjectInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@XZ PROC ; CvGlobals::getLeagueProjectInfo, COMDAT
; _this$ = ecx

; 4421 : 	return m_pLeagueProjects->GetLeagueProjectEntries();

	mov	ecx, DWORD PTR [ecx+1744]
	jmp	?GetLeagueProjectEntries@CvLeagueProjectXMLEntries@@QAEAAV?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@XZ ; CvLeagueProjectXMLEntries::GetLeagueProjectEntries
?getLeagueProjectInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getLeagueProjectInfo
_TEXT	ENDS
PUBLIC	?GetGameLeagueProjects@CvGlobals@@QBEPAVCvLeagueProjectXMLEntries@@XZ ; CvGlobals::GetGameLeagueProjects
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameLeagueProjects@CvGlobals@@QBEPAVCvLeagueProjectXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameLeagueProjects@CvGlobals@@QBEPAVCvLeagueProjectXMLEntries@@XZ PROC ; CvGlobals::GetGameLeagueProjects, COMDAT
; _this$ = ecx

; 4444 : 	return m_pLeagueProjects;

	mov	eax, DWORD PTR [ecx+1744]

; 4445 : }

	ret	0
?GetGameLeagueProjects@CvGlobals@@QBEPAVCvLeagueProjectXMLEntries@@XZ ENDP ; CvGlobals::GetGameLeagueProjects
_TEXT	ENDS
PUBLIC	?getLeagueProjectRewardInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@XZ ; CvGlobals::getLeagueProjectRewardInfo
EXTRN	?GetLeagueProjectRewardEntries@CvLeagueProjectRewardXMLEntries@@QAEAAV?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@XZ:PROC ; CvLeagueProjectRewardXMLEntries::GetLeagueProjectRewardEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getLeagueProjectRewardInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getLeagueProjectRewardInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@XZ PROC ; CvGlobals::getLeagueProjectRewardInfo, COMDAT
; _this$ = ecx

; 4460 : 	return m_pLeagueProjectRewards->GetLeagueProjectRewardEntries();

	mov	ecx, DWORD PTR [ecx+1748]
	jmp	?GetLeagueProjectRewardEntries@CvLeagueProjectRewardXMLEntries@@QAEAAV?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@XZ ; CvLeagueProjectRewardXMLEntries::GetLeagueProjectRewardEntries
?getLeagueProjectRewardInfo@CvGlobals@@QAEAAV?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getLeagueProjectRewardInfo
_TEXT	ENDS
PUBLIC	?GetGameLeagueProjectRewards@CvGlobals@@QBEPAVCvLeagueProjectRewardXMLEntries@@XZ ; CvGlobals::GetGameLeagueProjectRewards
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameLeagueProjectRewards@CvGlobals@@QBEPAVCvLeagueProjectRewardXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameLeagueProjectRewards@CvGlobals@@QBEPAVCvLeagueProjectRewardXMLEntries@@XZ PROC ; CvGlobals::GetGameLeagueProjectRewards, COMDAT
; _this$ = ecx

; 4483 : 	return m_pLeagueProjectRewards;

	mov	eax, DWORD PTR [ecx+1748]

; 4484 : }

	ret	0
?GetGameLeagueProjectRewards@CvGlobals@@QBEPAVCvLeagueProjectRewardXMLEntries@@XZ ENDP ; CvGlobals::GetGameLeagueProjectRewards
_TEXT	ENDS
PUBLIC	?getResolutionInfo@CvGlobals@@QAEAAV?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@XZ ; CvGlobals::getResolutionInfo
EXTRN	?GetResolutionEntries@CvResolutionXMLEntries@@QAEAAV?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@XZ:PROC ; CvResolutionXMLEntries::GetResolutionEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getResolutionInfo@CvGlobals@@QAEAAV?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getResolutionInfo@CvGlobals@@QAEAAV?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@XZ PROC ; CvGlobals::getResolutionInfo, COMDAT
; _this$ = ecx

; 4499 : 	return m_pResolutions->GetResolutionEntries();

	mov	ecx, DWORD PTR [ecx+1752]
	jmp	?GetResolutionEntries@CvResolutionXMLEntries@@QAEAAV?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@XZ ; CvResolutionXMLEntries::GetResolutionEntries
?getResolutionInfo@CvGlobals@@QAEAAV?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getResolutionInfo
_TEXT	ENDS
PUBLIC	?GetGameResolutions@CvGlobals@@QBEPAVCvResolutionXMLEntries@@XZ ; CvGlobals::GetGameResolutions
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameResolutions@CvGlobals@@QBEPAVCvResolutionXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameResolutions@CvGlobals@@QBEPAVCvResolutionXMLEntries@@XZ PROC ; CvGlobals::GetGameResolutions, COMDAT
; _this$ = ecx

; 4522 : 	return m_pResolutions;

	mov	eax, DWORD PTR [ecx+1752]

; 4523 : }

	ret	0
?GetGameResolutions@CvGlobals@@QBEPAVCvResolutionXMLEntries@@XZ ENDP ; CvGlobals::GetGameResolutions
_TEXT	ENDS
PUBLIC	?getTechInfo@CvGlobals@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ ; CvGlobals::getTechInfo
EXTRN	?GetTechEntries@CvTechXMLEntries@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ:PROC ; CvTechXMLEntries::GetTechEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getTechInfo@CvGlobals@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?getTechInfo@CvGlobals@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ PROC ; CvGlobals::getTechInfo, COMDAT
; _this$ = ecx

; 4538 : 	return m_pTechs->GetTechEntries();

	mov	ecx, DWORD PTR [ecx+1696]
	jmp	?GetTechEntries@CvTechXMLEntries@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ ; CvTechXMLEntries::GetTechEntries
?getTechInfo@CvGlobals@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ ENDP ; CvGlobals::getTechInfo
_TEXT	ENDS
PUBLIC	?GetGameTechs@CvGlobals@@QBEPAVCvTechXMLEntries@@XZ ; CvGlobals::GetGameTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameTechs@CvGlobals@@QBEPAVCvTechXMLEntries@@XZ
_TEXT	SEGMENT
?GetGameTechs@CvGlobals@@QBEPAVCvTechXMLEntries@@XZ PROC ; CvGlobals::GetGameTechs, COMDAT
; _this$ = ecx

; 4561 : 	return m_pTechs;

	mov	eax, DWORD PTR [ecx+1696]

; 4562 : }

	ret	0
?GetGameTechs@CvGlobals@@QBEPAVCvTechXMLEntries@@XZ ENDP ; CvGlobals::GetGameTechs
_TEXT	ENDS
PUBLIC	?getEraInfo@CvGlobals@@QAEAAV?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@XZ ; CvGlobals::getEraInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getEraInfo@CvGlobals@@QAEAAV?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getEraInfo@CvGlobals@@QAEAAV?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@XZ PROC ; CvGlobals::getEraInfo, COMDAT
; _this$ = ecx

; 4577 : 	return m_aEraInfo;

	lea	eax, DWORD PTR [ecx+1556]

; 4578 : }

	ret	0
?getEraInfo@CvGlobals@@QAEAAV?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getEraInfo
_TEXT	ENDS
PUBLIC	?getHurryInfo@CvGlobals@@QAEAAV?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@XZ ; CvGlobals::getHurryInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getHurryInfo@CvGlobals@@QAEAAV?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getHurryInfo@CvGlobals@@QAEAAV?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@XZ PROC ; CvGlobals::getHurryInfo, COMDAT
; _this$ = ecx

; 4609 : 	return m_paHurryInfo;

	lea	eax, DWORD PTR [ecx+1572]

; 4610 : }

	ret	0
?getHurryInfo@CvGlobals@@QAEAAV?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getHurryInfo
_TEXT	ENDS
PUBLIC	?getVictoryInfo@CvGlobals@@QAEAAV?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@XZ ; CvGlobals::getVictoryInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getVictoryInfo@CvGlobals@@QAEAAV?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getVictoryInfo@CvGlobals@@QAEAAV?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@XZ PROC ; CvGlobals::getVictoryInfo, COMDAT
; _this$ = ecx

; 4643 : 	return m_paVictoryInfo;

	lea	eax, DWORD PTR [ecx+1588]

; 4644 : }

	ret	0
?getVictoryInfo@CvGlobals@@QAEAAV?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getVictoryInfo
_TEXT	ENDS
PUBLIC	?getSmallAwardInfo@CvGlobals@@QAEAAV?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@XZ ; CvGlobals::getSmallAwardInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getSmallAwardInfo@CvGlobals@@QAEAAV?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getSmallAwardInfo@CvGlobals@@QAEAAV?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@XZ PROC ; CvGlobals::getSmallAwardInfo, COMDAT
; _this$ = ecx

; 4677 : 	return m_paSmallAwardInfo;

	lea	eax, DWORD PTR [ecx+1604]

; 4678 : }

	ret	0
?getSmallAwardInfo@CvGlobals@@QAEAAV?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getSmallAwardInfo
_TEXT	ENDS
PUBLIC	?getUnitDomainInfo@CvGlobals@@QAEAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@XZ ; CvGlobals::getUnitDomainInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitDomainInfo@CvGlobals@@QAEAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@XZ
_TEXT	SEGMENT
?getUnitDomainInfo@CvGlobals@@QAEAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@XZ PROC ; CvGlobals::getUnitDomainInfo, COMDAT
; _this$ = ecx

; 4712 : 	return m_paUnitDomainInfo;

	lea	eax, DWORD PTR [ecx+1636]

; 4713 : }

	ret	0
?getUnitDomainInfo@CvGlobals@@QAEAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@XZ ENDP ; CvGlobals::getUnitDomainInfo
_TEXT	ENDS
PUBLIC	?LogMessage@CvGlobals@@QAEXPBD@Z		; CvGlobals::LogMessage
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
; Function compile flags: /Ogtpy
;	COMDAT ?LogMessage@CvGlobals@@QAEXPBD@Z
_TEXT	SEGMENT
_szMessage$ = 8						; size = 4
?LogMessage@CvGlobals@@QAEXPBD@Z PROC			; CvGlobals::LogMessage, COMDAT
; _this$ = ecx

; 4736 : 	if(getLogging())

	cmp	BYTE PTR [ecx+7], 0
	je	SHORT $LN1@LogMessage

; 4737 : 	{
; 4738 : 		FILogFile* pLog = LOGFILEMGR.GetLog("GameCore.log", 0);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edx, DWORD PTR [eax]
	push	0
	push	0
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	push	OFFSET $SG230472
	call	eax

; 4739 : 		if(pLog)

	test	eax, eax
	je	SHORT $LN1@LogMessage

; 4740 : 			pLog->Msg(szMessage);

	mov	edx, DWORD PTR _szMessage$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8
$LN1@LogMessage:

; 4741 : 	}
; 4742 : }

	ret	4
?LogMessage@CvGlobals@@QAEXPBD@Z ENDP			; CvGlobals::LogMessage
_TEXT	ENDS
PUBLIC	?GetNotificationEntries@CvGlobals@@QAEPAVCvNotificationXMLEntries@@XZ ; CvGlobals::GetNotificationEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetNotificationEntries@CvGlobals@@QAEPAVCvNotificationXMLEntries@@XZ
_TEXT	SEGMENT
?GetNotificationEntries@CvGlobals@@QAEPAVCvNotificationXMLEntries@@XZ PROC ; CvGlobals::GetNotificationEntries, COMDAT
; _this$ = ecx

; 4746 : 	return m_pNotifications;

	mov	eax, DWORD PTR [ecx+1756]

; 4747 : }

	ret	0
?GetNotificationEntries@CvGlobals@@QAEPAVCvNotificationXMLEntries@@XZ ENDP ; CvGlobals::GetNotificationEntries
_TEXT	ENDS
PUBLIC	?getFootstepAudioTags@CvGlobals@@QAEAAPAVCvString@@XZ ; CvGlobals::getFootstepAudioTags
; Function compile flags: /Ogtpy
;	COMDAT ?getFootstepAudioTags@CvGlobals@@QAEAAPAVCvString@@XZ
_TEXT	SEGMENT
?getFootstepAudioTags@CvGlobals@@QAEAAPAVCvString@@XZ PROC ; CvGlobals::getFootstepAudioTags, COMDAT
; _this$ = ecx

; 4751 : 	return m_paszFootstepAudioTags;

	lea	eax, DWORD PTR [ecx+1768]

; 4752 : }

	ret	0
?getFootstepAudioTags@CvGlobals@@QAEAAPAVCvString@@XZ ENDP ; CvGlobals::getFootstepAudioTags
_TEXT	ENDS
PUBLIC	?getFootstepAudioTags@CvGlobals@@QAEAAVCvString@@H@Z ; CvGlobals::getFootstepAudioTags
; Function compile flags: /Ogtpy
;	COMDAT ?getFootstepAudioTags@CvGlobals@@QAEAAVCvString@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getFootstepAudioTags@CvGlobals@@QAEAAVCvString@@H@Z PROC ; CvGlobals::getFootstepAudioTags, COMDAT
; _this$ = ecx

; 4756 : //	CvAssertMsg(i < getNumFootstepAudioTags(), "Index out of bounds")
; 4757 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4758 : 	return m_paszFootstepAudioTags[i];

	mov	eax, DWORD PTR _i$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+1768]
	lea	eax, DWORD PTR [eax+edx*4]

; 4759 : }

	ret	4
?getFootstepAudioTags@CvGlobals@@QAEAAVCvString@@H@Z ENDP ; CvGlobals::getFootstepAudioTags
_TEXT	ENDS
PUBLIC	?GetHexDebugLayerNames@CvGlobals@@QAEPAPBDXZ	; CvGlobals::GetHexDebugLayerNames
;	COMDAT ?hexDebugLayerNames@?1??GetHexDebugLayerNames@CvGlobals@@QAEPAPBDXZ@4PAPBDA
_DATA	SEGMENT
?hexDebugLayerNames@?1??GetHexDebugLayerNames@CvGlobals@@QAEPAPBDXZ@4PAPBDA DD FLAT:$SG230489 ; `CvGlobals::GetHexDebugLayerNames'::`2'::hexDebugLayerNames
	DD	FLAT:$SG230490
	DD	FLAT:$SG230491
	DD	FLAT:$SG230492
	DD	FLAT:$SG230493
	DD	FLAT:$SG230494
	DD	FLAT:$SG230495
	DD	FLAT:$SG230496
	DD	00H
; Function compile flags: /Ogtpy
_DATA	ENDS
;	COMDAT ?GetHexDebugLayerNames@CvGlobals@@QAEPAPBDXZ
_TEXT	SEGMENT
?GetHexDebugLayerNames@CvGlobals@@QAEPAPBDXZ PROC	; CvGlobals::GetHexDebugLayerNames, COMDAT
; _this$ = ecx

; 4763 : 	static const char* hexDebugLayerNames[] =
; 4764 : 	{
; 4765 : 		"StartSiteEvaluationLayer",
; 4766 : 		"SettlerSiteEvaluationLayer",
; 4767 : 		"VisibilityLayer",
; 4768 : 		"RevealedLayer",
; 4769 : 		"DangerLayer",
; 4770 : 		"TacticalAnalysisLayer",
; 4771 : 		"ArtifactLayer",
; 4772 : 		"TargetingPathLayer",
; 4773 : 		NULL
; 4774 : 	};
; 4775 : 	return hexDebugLayerNames;

	mov	eax, OFFSET ?hexDebugLayerNames@?1??GetHexDebugLayerNames@CvGlobals@@QAEPAPBDXZ@4PAPBDA

; 4776 : }

	ret	0
?GetHexDebugLayerNames@CvGlobals@@QAEPAPBDXZ ENDP	; CvGlobals::GetHexDebugLayerNames
_TEXT	ENDS
PUBLIC	?GetHexDebugLayerScale@CvGlobals@@QAEMPBD@Z	; CvGlobals::GetHexDebugLayerScale
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__fltused:DWORD
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetHexDebugLayerScale@CvGlobals@@QAEMPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetHexDebugLayerScale@CvGlobals@@QAEMPBD@Z$0
__ehfuncinfo$?GetHexDebugLayerScale@CvGlobals@@QAEMPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetHexDebugLayerScale@CvGlobals@@QAEMPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GetHexDebugLayerScale@CvGlobals@@QAEMPBD@Z
_TEXT	SEGMENT
_strLayerName$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_fScale$ = 8						; size = 4
_szLayerName$ = 8					; size = 4
?GetHexDebugLayerScale@CvGlobals@@QAEMPBD@Z PROC	; CvGlobals::GetHexDebugLayerScale, COMDAT
; _this$ = ecx

; 4779 : {

	push	-1
	push	__ehhandler$?GetHexDebugLayerScale@CvGlobals@@QAEMPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 4780 : 	std::string strLayerName = szLayerName;

	mov	eax, DWORD PTR _szLayerName$[esp+36]
	push	esi
	push	eax
	lea	ecx, DWORD PTR _strLayerName$[esp+48]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 4781 : 	float fScale = 1.0f;
; 4782 : 
; 4783 : 	if(strLayerName == "SettlerSiteEvaluationLayer")

	mov	esi, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	lea	ecx, DWORD PTR _strLayerName$[esp+44]
	push	OFFSET $SG230504
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	mov	DWORD PTR _fScale$[esp+48], 1065353216	; 3f800000H
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN2@GetHexDebu

; 4784 : 	{
; 4785 : 		fScale = 1.5f;

	mov	DWORD PTR _fScale$[esp+40], 1069547520	; 3fc00000H
$LN2@GetHexDebu:

; 4786 : 	}
; 4787 : 	if(strLayerName == "ArtifactLayer")

	lea	edx, DWORD PTR _strLayerName$[esp+44]
	push	OFFSET $SG230506
	push	edx
	call	esi
	add	esp, 8
	pop	esi
	test	al, al
	je	SHORT $LN1@GetHexDebu

; 4788 : 	{
; 4789 : 		fScale = 2.0f;

	mov	DWORD PTR _fScale$[esp+36], 1073741824	; 40000000H
$LN1@GetHexDebu:

; 4790 : 	}
; 4791 : 
; 4792 : 	return fScale;

	lea	ecx, DWORD PTR _strLayerName$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	fld	DWORD PTR _fScale$[esp+36]

; 4793 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetHexDebugLayerScale@CvGlobals@@QAEMPBD@Z$0:
	lea	ecx, DWORD PTR _strLayerName$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetHexDebugLayerScale@CvGlobals@@QAEMPBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetHexDebugLayerScale@CvGlobals@@QAEMPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetHexDebugLayerScale@CvGlobals@@QAEMPBD@Z ENDP	; CvGlobals::GetHexDebugLayerScale
PUBLIC	?SafeStrlen@FStringA@@SAHPBD@Z			; FStringA::SafeStrlen
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ?SafeStrlen@FStringA@@SAHPBD@Z
_TEXT	SEGMENT
_lpsz$ = 8						; size = 4
?SafeStrlen@FStringA@@SAHPBD@Z PROC			; FStringA::SafeStrlen, COMDAT

; 1030 : 	return ( lpsz ? ( int )strlen( lpsz ) : 0 );

	mov	eax, DWORD PTR _lpsz$[esp-4]
	test	eax, eax
	je	SHORT $LN3@SafeStrlen
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL5@SafeStrlen:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL5@SafeStrlen
	sub	eax, edx

; 1031 : }

	ret	0
$LN3@SafeStrlen:

; 1030 : 	return ( lpsz ? ( int )strlen( lpsz ) : 0 );

	xor	eax, eax

; 1031 : }

	ret	0
?SafeStrlen@FStringA@@SAHPBD@Z ENDP			; FStringA::SafeStrlen
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?getDefineValue@CvGlobals@@IAE_NPBDAAH_N@Z	; CvGlobals::getDefineValue
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBD_N@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
;	COMDAT ?getDefineValue@CvGlobals@@IAE_NPBDAAH_N@Z
_TEXT	SEGMENT
_szName$ = 8						; size = 4
_iValue$ = 12						; size = 4
_bReportErrors$ = 16					; size = 1
?getDefineValue@CvGlobals@@IAE_NPBDAAH_N@Z PROC		; CvGlobals::getDefineValue, COMDAT
; _this$ = ecx

; 6780 : 	bool bSuccess = false;
; 6781 : 	if(m_kGlobalDefinesLookup.Bind(1, szName))

	mov	eax, DWORD PTR _szName$[esp-4]
	push	ebx
	push	esi
	push	1
	lea	esi, DWORD PTR [ecx+916]
	push	eax
	push	1
	mov	ecx, esi
	xor	bl, bl
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
	test	al, al
	je	SHORT $LN2@getDefineV

; 6782 : 	{
; 6783 : 		if(m_kGlobalDefinesLookup.Step())

	mov	ecx, esi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN2@getDefineV

; 6784 : 		{
; 6785 : 			iValue = m_kGlobalDefinesLookup.GetInt(0);

	push	0
	mov	ecx, esi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	ecx, DWORD PTR _iValue$[esp+4]
	mov	DWORD PTR [ecx], eax

; 6786 : 			bSuccess = true;

	mov	bl, 1
$LN2@getDefineV:

; 6787 : 		}
; 6788 : 	}
; 6789 : 
; 6790 : 	m_kGlobalDefinesLookup.Reset();

	mov	ecx, esi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ
	pop	esi

; 6791 : 
; 6792 : 	if(bReportErrors)
; 6793 : 	{
; 6794 : 		CvAssertFmt(bSuccess, "Integer Define Value not found for %s", szName);
; 6795 : 	}
; 6796 : 
; 6797 : 	return bSuccess;

	mov	al, bl
	pop	ebx

; 6798 : }

	ret	12					; 0000000cH
?getDefineValue@CvGlobals@@IAE_NPBDAAH_N@Z ENDP		; CvGlobals::getDefineValue
_TEXT	ENDS
PUBLIC	?getDefineValue@CvGlobals@@IAE_NPBDAAM_N@Z	; CvGlobals::getDefineValue
EXTRN	__imp_?GetFloat@Results@Database@@QAEMH@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?getDefineValue@CvGlobals@@IAE_NPBDAAM_N@Z
_TEXT	SEGMENT
_szName$ = 8						; size = 4
_fValue$ = 12						; size = 4
_bReportErrors$ = 16					; size = 1
?getDefineValue@CvGlobals@@IAE_NPBDAAM_N@Z PROC		; CvGlobals::getDefineValue, COMDAT
; _this$ = ecx

; 6802 : 	bool bSuccess = false;
; 6803 : 	if(m_kGlobalDefinesLookup.Bind(1, szName))

	mov	eax, DWORD PTR _szName$[esp-4]
	push	ebx
	push	esi
	push	1
	lea	esi, DWORD PTR [ecx+916]
	push	eax
	push	1
	mov	ecx, esi
	xor	bl, bl
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
	test	al, al
	je	SHORT $LN2@getDefineV@2

; 6804 : 	{
; 6805 : 		if(m_kGlobalDefinesLookup.Step())

	mov	ecx, esi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN2@getDefineV@2

; 6806 : 		{
; 6807 : 			fValue = m_kGlobalDefinesLookup.GetFloat(0);

	push	0
	mov	ecx, esi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMH@Z
	mov	ecx, DWORD PTR _fValue$[esp+4]
	fstp	DWORD PTR [ecx]

; 6808 : 			bSuccess = true;

	mov	bl, 1
$LN2@getDefineV@2:

; 6809 : 		}
; 6810 : 	}
; 6811 : 
; 6812 : 	m_kGlobalDefinesLookup.Reset();

	mov	ecx, esi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ
	pop	esi

; 6813 : 
; 6814 : 	if(bReportErrors)
; 6815 : 	{
; 6816 : 		CvAssertFmt(bSuccess, "Float Define Value not found for %s", szName);
; 6817 : 	}
; 6818 : 
; 6819 : 	return bSuccess;

	mov	al, bl
	pop	ebx

; 6820 : }

	ret	12					; 0000000cH
?getDefineValue@CvGlobals@@IAE_NPBDAAM_N@Z ENDP		; CvGlobals::getDefineValue
_TEXT	ENDS
PUBLIC	?getDefineValue@CvGlobals@@IAE_NPBDAAVCvString@@_N@Z ; CvGlobals::getDefineValue
EXTRN	__imp_?GetText@Results@Database@@QAEPBDH@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?getDefineValue@CvGlobals@@IAE_NPBDAAVCvString@@_N@Z
_TEXT	SEGMENT
_szName$ = 8						; size = 4
_strValue$ = 12						; size = 4
_bReportErrors$ = 16					; size = 1
?getDefineValue@CvGlobals@@IAE_NPBDAAVCvString@@_N@Z PROC ; CvGlobals::getDefineValue, COMDAT
; _this$ = ecx

; 6848 : 	bool bSuccess = false;
; 6849 : 	if(m_kGlobalDefinesLookup.Bind(1, szName))

	mov	eax, DWORD PTR _szName$[esp-4]
	push	ebx
	push	esi
	push	1
	lea	esi, DWORD PTR [ecx+916]
	push	eax
	push	1
	mov	ecx, esi
	xor	bl, bl
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
	test	al, al
	je	SHORT $LN2@getDefineV@3

; 6850 : 	{
; 6851 : 		if(m_kGlobalDefinesLookup.Step())

	mov	ecx, esi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN2@getDefineV@3

; 6852 : 		{
; 6853 : 			strValue = m_kGlobalDefinesLookup.GetText(0);

	push	0
	mov	ecx, esi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDH@Z
	mov	ecx, DWORD PTR _strValue$[esp+4]
	test	eax, eax
	je	SHORT $LN7@getDefineV@3
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 6855 : 		}
; 6856 : 	}
; 6857 : 
; 6858 : 	m_kGlobalDefinesLookup.Reset();

	mov	ecx, esi
	mov	bl, 1
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ
	pop	esi

; 6859 : 
; 6860 : 	if(bReportErrors)
; 6861 : 	{
; 6862 : 		CvAssertFmt(bSuccess, "String Define Value not found for %s", szName);
; 6863 : 	}
; 6864 : 
; 6865 : 	return bSuccess;

	mov	al, bl
	pop	ebx

; 6866 : }

	ret	12					; 0000000cH

; 6852 : 		{
; 6853 : 			strValue = m_kGlobalDefinesLookup.GetText(0);

$LN7@getDefineV@3:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 6854 : 			bSuccess = true;

	mov	bl, 1
$LN2@getDefineV@3:

; 6855 : 		}
; 6856 : 	}
; 6857 : 
; 6858 : 	m_kGlobalDefinesLookup.Reset();

	mov	ecx, esi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ
	pop	esi

; 6859 : 
; 6860 : 	if(bReportErrors)
; 6861 : 	{
; 6862 : 		CvAssertFmt(bSuccess, "String Define Value not found for %s", szName);
; 6863 : 	}
; 6864 : 
; 6865 : 	return bSuccess;

	mov	al, bl
	pop	ebx

; 6866 : }

	ret	12					; 0000000cH
?getDefineValue@CvGlobals@@IAE_NPBDAAVCvString@@_N@Z ENDP ; CvGlobals::getDefineValue
_TEXT	ENDS
PUBLIC	?getNUM_YIELD_TYPES@CvGlobals@@QBEHXZ		; CvGlobals::getNUM_YIELD_TYPES
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_YIELD_TYPES@CvGlobals@@QBEHXZ
_TEXT	SEGMENT
?getNUM_YIELD_TYPES@CvGlobals@@QBEHXZ PROC		; CvGlobals::getNUM_YIELD_TYPES, COMDAT
; _this$ = ecx

; 6870 : 	return NUM_YIELD_TYPES;

	mov	eax, 6

; 6871 : }

	ret	0
?getNUM_YIELD_TYPES@CvGlobals@@QBEHXZ ENDP		; CvGlobals::getNUM_YIELD_TYPES
_TEXT	ENDS
PUBLIC	?getNUM_CONTROL_TYPES@CvGlobals@@QBEHXZ		; CvGlobals::getNUM_CONTROL_TYPES
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_CONTROL_TYPES@CvGlobals@@QBEHXZ
_TEXT	SEGMENT
?getNUM_CONTROL_TYPES@CvGlobals@@QBEHXZ PROC		; CvGlobals::getNUM_CONTROL_TYPES, COMDAT
; _this$ = ecx

; 6875 : 	return NUM_CONTROL_TYPES;

	mov	eax, 44					; 0000002cH

; 6876 : }

	ret	0
?getNUM_CONTROL_TYPES@CvGlobals@@QBEHXZ ENDP		; CvGlobals::getNUM_CONTROL_TYPES
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?GetInfoTypes@CvGlobals@@QBEABV?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@XZ ; CvGlobals::GetInfoTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
;	COMDAT ?GetInfoTypes@CvGlobals@@QBEABV?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@XZ
_TEXT	SEGMENT
?GetInfoTypes@CvGlobals@@QBEABV?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@XZ PROC ; CvGlobals::GetInfoTypes, COMDAT
; _this$ = ecx

; 6937 : 	return m_infosMap;

	lea	eax, DWORD PTR [ecx+980]

; 6938 : }

	ret	0
?GetInfoTypes@CvGlobals@@QBEABV?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@XZ ENDP ; CvGlobals::GetInfoTypes
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?getNumDirections@CvGlobals@@QBEHXZ		; CvGlobals::getNumDirections
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
;	COMDAT ?getNumDirections@CvGlobals@@QBEHXZ
_TEXT	SEGMENT
?getNumDirections@CvGlobals@@QBEHXZ PROC		; CvGlobals::getNumDirections, COMDAT
; _this$ = ecx

; 7014 : 	return NUM_DIRECTION_TYPES;

	mov	eax, 6

; 7015 : }

	ret	0
?getNumDirections@CvGlobals@@QBEHXZ ENDP		; CvGlobals::getNumDirections
_TEXT	ENDS
PUBLIC	?getNumGameOptions@CvGlobals@@QBEHXZ		; CvGlobals::getNumGameOptions
; Function compile flags: /Ogtpy
;	COMDAT ?getNumGameOptions@CvGlobals@@QBEHXZ
_TEXT	SEGMENT
?getNumGameOptions@CvGlobals@@QBEHXZ PROC		; CvGlobals::getNumGameOptions, COMDAT
; _this$ = ecx

; 7018 : 	return NUM_GAMEOPTION_TYPES;

	mov	eax, 22					; 00000016H

; 7019 : }

	ret	0
?getNumGameOptions@CvGlobals@@QBEHXZ ENDP		; CvGlobals::getNumGameOptions
_TEXT	ENDS
PUBLIC	?getNumMPOptions@CvGlobals@@QBEHXZ		; CvGlobals::getNumMPOptions
; Function compile flags: /Ogtpy
;	COMDAT ?getNumMPOptions@CvGlobals@@QBEHXZ
_TEXT	SEGMENT
?getNumMPOptions@CvGlobals@@QBEHXZ PROC			; CvGlobals::getNumMPOptions, COMDAT
; _this$ = ecx

; 7022 : 	return NUM_MPOPTION_TYPES;

	mov	eax, 4

; 7023 : }

	ret	0
?getNumMPOptions@CvGlobals@@QBEHXZ ENDP			; CvGlobals::getNumMPOptions
_TEXT	ENDS
PUBLIC	?getNumSpecialOptions@CvGlobals@@QBEHXZ		; CvGlobals::getNumSpecialOptions
; Function compile flags: /Ogtpy
;	COMDAT ?getNumSpecialOptions@CvGlobals@@QBEHXZ
_TEXT	SEGMENT
?getNumSpecialOptions@CvGlobals@@QBEHXZ PROC		; CvGlobals::getNumSpecialOptions, COMDAT
; _this$ = ecx

; 7026 : 	return NUM_SPECIALOPTION_TYPES;

	mov	eax, 1

; 7027 : }

	ret	0
?getNumSpecialOptions@CvGlobals@@QBEHXZ ENDP		; CvGlobals::getNumSpecialOptions
_TEXT	ENDS
PUBLIC	?getNumCommandInfos@CvGlobals@@QBEHXZ		; CvGlobals::getNumCommandInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumCommandInfos@CvGlobals@@QBEHXZ
_TEXT	SEGMENT
?getNumCommandInfos@CvGlobals@@QBEHXZ PROC		; CvGlobals::getNumCommandInfos, COMDAT
; _this$ = ecx

; 7030 : 	return NUM_COMMAND_TYPES;

	mov	eax, 10					; 0000000aH

; 7031 : }

	ret	0
?getNumCommandInfos@CvGlobals@@QBEHXZ ENDP		; CvGlobals::getNumCommandInfos
_TEXT	ENDS
PUBLIC	?getNumControlInfos@CvGlobals@@QBEHXZ		; CvGlobals::getNumControlInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumControlInfos@CvGlobals@@QBEHXZ
_TEXT	SEGMENT
?getNumControlInfos@CvGlobals@@QBEHXZ PROC		; CvGlobals::getNumControlInfos, COMDAT
; _this$ = ecx

; 7034 : 	return NUM_CONTROL_TYPES;

	mov	eax, 44					; 0000002cH

; 7035 : }

	ret	0
?getNumControlInfos@CvGlobals@@QBEHXZ ENDP		; CvGlobals::getNumControlInfos
_TEXT	ENDS
PUBLIC	?SetGameDatabase@CvGlobals@@QAEXPAVConnection@Database@@@Z ; CvGlobals::SetGameDatabase
EXTRN	__imp_?Release@Results@Database@@QAEXXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?SetGameDatabase@CvGlobals@@QAEXPAVConnection@Database@@@Z
_TEXT	SEGMENT
_pGameDatabase$ = 8					; size = 4
?SetGameDatabase@CvGlobals@@QAEXPAVConnection@Database@@@Z PROC ; CvGlobals::SetGameDatabase, COMDAT
; _this$ = ecx

; 7044 : {

	push	esi
	mov	esi, ecx

; 7045 : 	if(m_pGameDatabase != pGameDatabase)

	mov	eax, DWORD PTR [esi+912]
	push	edi
	mov	edi, DWORD PTR _pGameDatabase$[esp+4]
	cmp	eax, edi
	je	SHORT $LN2@SetGameDat

; 7046 : 	{
; 7047 : 		if(m_pGameDatabase)

	test	eax, eax
	je	SHORT $LN1@SetGameDat

; 7048 : 			m_kGlobalDefinesLookup.Release();

	lea	ecx, DWORD PTR [esi+916]
	call	DWORD PTR __imp_?Release@Results@Database@@QAEXXZ
$LN1@SetGameDat:

; 7049 : 
; 7050 : 		m_pGameDatabase = pGameDatabase;

	mov	DWORD PTR [esi+912], edi
$LN2@SetGameDat:
	pop	edi
	pop	esi

; 7051 : 	}
; 7052 : }

	ret	4
?SetGameDatabase@CvGlobals@@QAEXPAVConnection@Database@@@Z ENDP ; CvGlobals::SetGameDatabase
_TEXT	ENDS
PUBLIC	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ	; CvGlobals::IsGraphicsInitialized
; Function compile flags: /Ogtpy
;	COMDAT ?IsGraphicsInitialized@CvGlobals@@QBE_NXZ
_TEXT	SEGMENT
?IsGraphicsInitialized@CvGlobals@@QBE_NXZ PROC		; CvGlobals::IsGraphicsInitialized, COMDAT
; _this$ = ecx

; 7057 : 	return m_bGraphicsInitialized;

	mov	al, BYTE PTR [ecx+4]

; 7058 : }

	ret	0
?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ENDP		; CvGlobals::IsGraphicsInitialized
_TEXT	ENDS
PUBLIC	?SetGraphicsInitialized@CvGlobals@@QAEX_N@Z	; CvGlobals::SetGraphicsInitialized
; Function compile flags: /Ogtpy
;	COMDAT ?SetGraphicsInitialized@CvGlobals@@QAEX_N@Z
_TEXT	SEGMENT
_bVal$ = 8						; size = 1
?SetGraphicsInitialized@CvGlobals@@QAEX_N@Z PROC	; CvGlobals::SetGraphicsInitialized, COMDAT
; _this$ = ecx

; 7061 : 	m_bGraphicsInitialized = bVal;

	mov	al, BYTE PTR _bVal$[esp-4]
	mov	BYTE PTR [ecx+4], al

; 7062 : }

	ret	4
?SetGraphicsInitialized@CvGlobals@@QAEX_N@Z ENDP	; CvGlobals::SetGraphicsInitialized
_TEXT	ENDS
PUBLIC	?setPathFinder@CvGlobals@@QAEXPAVCvTwoLayerPathFinder@@@Z ; CvGlobals::setPathFinder
; Function compile flags: /Ogtpy
;	COMDAT ?setPathFinder@CvGlobals@@QAEXPAVCvTwoLayerPathFinder@@@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
?setPathFinder@CvGlobals@@QAEXPAVCvTwoLayerPathFinder@@@Z PROC ; CvGlobals::setPathFinder, COMDAT
; _this$ = ecx

; 7065 : 	m_pathFinder = pVal;

	mov	eax, DWORD PTR _pVal$[esp-4]
	mov	DWORD PTR [ecx+56], eax

; 7066 : }

	ret	4
?setPathFinder@CvGlobals@@QAEXPAVCvTwoLayerPathFinder@@@Z ENDP ; CvGlobals::setPathFinder
_TEXT	ENDS
PUBLIC	?setInterfacePathFinder@CvGlobals@@QAEXPAVCvTwoLayerPathFinder@@@Z ; CvGlobals::setInterfacePathFinder
; Function compile flags: /Ogtpy
;	COMDAT ?setInterfacePathFinder@CvGlobals@@QAEXPAVCvTwoLayerPathFinder@@@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
?setInterfacePathFinder@CvGlobals@@QAEXPAVCvTwoLayerPathFinder@@@Z PROC ; CvGlobals::setInterfacePathFinder, COMDAT
; _this$ = ecx

; 7069 : 	m_interfacePathFinder = pVal;

	mov	eax, DWORD PTR _pVal$[esp-4]
	mov	DWORD PTR [ecx+60], eax

; 7070 : }

	ret	4
?setInterfacePathFinder@CvGlobals@@QAEXPAVCvTwoLayerPathFinder@@@Z ENDP ; CvGlobals::setInterfacePathFinder
_TEXT	ENDS
PUBLIC	?setIgnoreUnitsPathFinder@CvGlobals@@QAEXPAVCvIgnoreUnitsPathFinder@@@Z ; CvGlobals::setIgnoreUnitsPathFinder
; Function compile flags: /Ogtpy
;	COMDAT ?setIgnoreUnitsPathFinder@CvGlobals@@QAEXPAVCvIgnoreUnitsPathFinder@@@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
?setIgnoreUnitsPathFinder@CvGlobals@@QAEXPAVCvIgnoreUnitsPathFinder@@@Z PROC ; CvGlobals::setIgnoreUnitsPathFinder, COMDAT
; _this$ = ecx

; 7073 : 	m_ignoreUnitsPathFinder = pVal;

	mov	eax, DWORD PTR _pVal$[esp-4]
	mov	DWORD PTR [ecx+64], eax

; 7074 : }

	ret	4
?setIgnoreUnitsPathFinder@CvGlobals@@QAEXPAVCvIgnoreUnitsPathFinder@@@Z ENDP ; CvGlobals::setIgnoreUnitsPathFinder
_TEXT	ENDS
PUBLIC	?setStepFinder@CvGlobals@@QAEXPAVCvStepPathFinder@@@Z ; CvGlobals::setStepFinder
; Function compile flags: /Ogtpy
;	COMDAT ?setStepFinder@CvGlobals@@QAEXPAVCvStepPathFinder@@@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
?setStepFinder@CvGlobals@@QAEXPAVCvStepPathFinder@@@Z PROC ; CvGlobals::setStepFinder, COMDAT
; _this$ = ecx

; 7077 : 	m_stepFinder = pVal;

	mov	eax, DWORD PTR _pVal$[esp-4]
	mov	DWORD PTR [ecx+68], eax

; 7078 : }

	ret	4
?setStepFinder@CvGlobals@@QAEXPAVCvStepPathFinder@@@Z ENDP ; CvGlobals::setStepFinder
_TEXT	ENDS
PUBLIC	?setRouteFinder@CvGlobals@@QAEXPAVCvAStar@@@Z	; CvGlobals::setRouteFinder
; Function compile flags: /Ogtpy
;	COMDAT ?setRouteFinder@CvGlobals@@QAEXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
?setRouteFinder@CvGlobals@@QAEXPAVCvAStar@@@Z PROC	; CvGlobals::setRouteFinder, COMDAT
; _this$ = ecx

; 7081 : 	m_routeFinder = pVal;

	mov	eax, DWORD PTR _pVal$[esp-4]
	mov	DWORD PTR [ecx+72], eax

; 7082 : }

	ret	4
?setRouteFinder@CvGlobals@@QAEXPAVCvAStar@@@Z ENDP	; CvGlobals::setRouteFinder
_TEXT	ENDS
PUBLIC	?SetWaterRouteFinder@CvGlobals@@QAEXPAVCvAStar@@@Z ; CvGlobals::SetWaterRouteFinder
; Function compile flags: /Ogtpy
;	COMDAT ?SetWaterRouteFinder@CvGlobals@@QAEXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
?SetWaterRouteFinder@CvGlobals@@QAEXPAVCvAStar@@@Z PROC	; CvGlobals::SetWaterRouteFinder, COMDAT
; _this$ = ecx

; 7085 : 	m_waterRouteFinder = pVal;

	mov	eax, DWORD PTR _pVal$[esp-4]
	mov	DWORD PTR [ecx+76], eax

; 7086 : }

	ret	4
?SetWaterRouteFinder@CvGlobals@@QAEXPAVCvAStar@@@Z ENDP	; CvGlobals::SetWaterRouteFinder
_TEXT	ENDS
PUBLIC	?setAreaFinder@CvGlobals@@QAEXPAVCvAStar@@@Z	; CvGlobals::setAreaFinder
; Function compile flags: /Ogtpy
;	COMDAT ?setAreaFinder@CvGlobals@@QAEXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
?setAreaFinder@CvGlobals@@QAEXPAVCvAStar@@@Z PROC	; CvGlobals::setAreaFinder, COMDAT
; _this$ = ecx

; 7089 : 	m_areaFinder = pVal;

	mov	eax, DWORD PTR _pVal$[esp-4]
	mov	DWORD PTR [ecx+84], eax

; 7090 : }

	ret	4
?setAreaFinder@CvGlobals@@QAEXPAVCvAStar@@@Z ENDP	; CvGlobals::setAreaFinder
_TEXT	ENDS
PUBLIC	?setInfluenceFinder@CvGlobals@@QAEXPAVCvAStar@@@Z ; CvGlobals::setInfluenceFinder
; Function compile flags: /Ogtpy
;	COMDAT ?setInfluenceFinder@CvGlobals@@QAEXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
?setInfluenceFinder@CvGlobals@@QAEXPAVCvAStar@@@Z PROC	; CvGlobals::setInfluenceFinder, COMDAT
; _this$ = ecx

; 7093 : 	m_influenceFinder = pVal;

	mov	eax, DWORD PTR _pVal$[esp-4]
	mov	DWORD PTR [ecx+88], eax

; 7094 : }

	ret	4
?setInfluenceFinder@CvGlobals@@QAEXPAVCvAStar@@@Z ENDP	; CvGlobals::setInfluenceFinder
_TEXT	ENDS
PUBLIC	?SetBuildRouteFinder@CvGlobals@@QAEXPAVCvAStar@@@Z ; CvGlobals::SetBuildRouteFinder
; Function compile flags: /Ogtpy
;	COMDAT ?SetBuildRouteFinder@CvGlobals@@QAEXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
?SetBuildRouteFinder@CvGlobals@@QAEXPAVCvAStar@@@Z PROC	; CvGlobals::SetBuildRouteFinder, COMDAT
; _this$ = ecx

; 7097 : 	m_buildRouteFinder = pVal;

	mov	eax, DWORD PTR _pVal$[esp-4]
	mov	DWORD PTR [ecx+92], eax

; 7098 : }

	ret	4
?SetBuildRouteFinder@CvGlobals@@QAEXPAVCvAStar@@@Z ENDP	; CvGlobals::SetBuildRouteFinder
_TEXT	ENDS
PUBLIC	?SetInternationalTradeRouteLandFinder@CvGlobals@@QAEXPAVCvAStar@@@Z ; CvGlobals::SetInternationalTradeRouteLandFinder
; Function compile flags: /Ogtpy
;	COMDAT ?SetInternationalTradeRouteLandFinder@CvGlobals@@QAEXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
?SetInternationalTradeRouteLandFinder@CvGlobals@@QAEXPAVCvAStar@@@Z PROC ; CvGlobals::SetInternationalTradeRouteLandFinder, COMDAT
; _this$ = ecx

; 7101 : 	m_internationalTradeRouteLandFinder = pVal;

	mov	eax, DWORD PTR _pVal$[esp-4]
	mov	DWORD PTR [ecx+96], eax

; 7102 : }

	ret	4
?SetInternationalTradeRouteLandFinder@CvGlobals@@QAEXPAVCvAStar@@@Z ENDP ; CvGlobals::SetInternationalTradeRouteLandFinder
_TEXT	ENDS
PUBLIC	?SetInternationalTradeRouteWaterFinder@CvGlobals@@QAEXPAVCvAStar@@@Z ; CvGlobals::SetInternationalTradeRouteWaterFinder
; Function compile flags: /Ogtpy
;	COMDAT ?SetInternationalTradeRouteWaterFinder@CvGlobals@@QAEXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
?SetInternationalTradeRouteWaterFinder@CvGlobals@@QAEXPAVCvAStar@@@Z PROC ; CvGlobals::SetInternationalTradeRouteWaterFinder, COMDAT
; _this$ = ecx

; 7105 : 	m_internationalTradeRouteWaterFinder = pVal;

	mov	eax, DWORD PTR _pVal$[esp-4]
	mov	DWORD PTR [ecx+100], eax

; 7106 : }

	ret	4
?SetInternationalTradeRouteWaterFinder@CvGlobals@@QAEXPAVCvAStar@@@Z ENDP ; CvGlobals::SetInternationalTradeRouteWaterFinder
_TEXT	ENDS
PUBLIC	?SetTacticalAnalysisMapFinder@CvGlobals@@QAEXPAVCvTwoLayerPathFinder@@@Z ; CvGlobals::SetTacticalAnalysisMapFinder
; Function compile flags: /Ogtpy
;	COMDAT ?SetTacticalAnalysisMapFinder@CvGlobals@@QAEXPAVCvTwoLayerPathFinder@@@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
?SetTacticalAnalysisMapFinder@CvGlobals@@QAEXPAVCvTwoLayerPathFinder@@@Z PROC ; CvGlobals::SetTacticalAnalysisMapFinder, COMDAT
; _this$ = ecx

; 7109 : 	m_tacticalAnalysisMapFinder = pVal;

	mov	eax, DWORD PTR _pVal$[esp-4]
	mov	DWORD PTR [ecx+104], eax

; 7110 : }

	ret	4
?SetTacticalAnalysisMapFinder@CvGlobals@@QAEXPAVCvTwoLayerPathFinder@@@Z ENDP ; CvGlobals::SetTacticalAnalysisMapFinder
_TEXT	ENDS
PUBLIC	?setOutOfSyncDebuggingEnabled@CvGlobals@@QAEX_N@Z ; CvGlobals::setOutOfSyncDebuggingEnabled
EXTRN	?EnableCallStacks@FAutoArchive@@SAX_N@Z:PROC	; FAutoArchive::EnableCallStacks
; Function compile flags: /Ogtpy
;	COMDAT ?setOutOfSyncDebuggingEnabled@CvGlobals@@QAEX_N@Z
_TEXT	SEGMENT
_isEnabled$ = 8						; size = 1
?setOutOfSyncDebuggingEnabled@CvGlobals@@QAEX_N@Z PROC	; CvGlobals::setOutOfSyncDebuggingEnabled, COMDAT
; _this$ = ecx

; 7120 : 	m_bOutOfSyncDebuggingEnabled = isEnabled;

	mov	eax, DWORD PTR _isEnabled$[esp-4]

; 7121 : 	FAutoArchive::EnableCallStacks(isEnabled);

	push	eax
	mov	BYTE PTR [ecx+23], al
	call	?EnableCallStacks@FAutoArchive@@SAX_N@Z	; FAutoArchive::EnableCallStacks
	pop	ecx

; 7122 : }

	ret	4
?setOutOfSyncDebuggingEnabled@CvGlobals@@QAEX_N@Z ENDP	; CvGlobals::setOutOfSyncDebuggingEnabled
_TEXT	ENDS
PUBLIC	?getOutOfSyncDebuggingEnabled@CvGlobals@@QBE_NXZ ; CvGlobals::getOutOfSyncDebuggingEnabled
; Function compile flags: /Ogtpy
;	COMDAT ?getOutOfSyncDebuggingEnabled@CvGlobals@@QBE_NXZ
_TEXT	SEGMENT
?getOutOfSyncDebuggingEnabled@CvGlobals@@QBE_NXZ PROC	; CvGlobals::getOutOfSyncDebuggingEnabled, COMDAT
; _this$ = ecx

; 7126 : 	return m_bOutOfSyncDebuggingEnabled;

	mov	al, BYTE PTR [ecx+23]

; 7127 : }

	ret	0
?getOutOfSyncDebuggingEnabled@CvGlobals@@QBE_NXZ ENDP	; CvGlobals::getOutOfSyncDebuggingEnabled
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEIXZ ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAPAVCvPromotionEntry@@I@Z ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAPAVCvPromotionEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAPAVCvPromotionEntry@@I@Z PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAPAVCvPromotionEntry@@I@Z ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEIXZ ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEAAPAVCvInterfaceModeInfo@@I@Z ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEAAPAVCvInterfaceModeInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEAAPAVCvInterfaceModeInfo@@I@Z PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEAAPAVCvInterfaceModeInfo@@I@Z ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	??0CvPoint3@@QAE@XZ				; CvPoint3::CvPoint3
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvpoint.h
;	COMDAT ??0CvPoint3@@QAE@XZ
_TEXT	SEGMENT
??0CvPoint3@@QAE@XZ PROC				; CvPoint3::CvPoint3, COMDAT
; _this$ = ecx

; 25   : 	CvPoint3(): x(0), y(0), z(0) {}

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0CvPoint3@@QAE@XZ ENDP				; CvPoint3::CvPoint3
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEIXZ ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEAAPAVCvColorInfo@@I@Z ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEAAPAVCvColorInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEAAPAVCvColorInfo@@I@Z PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEAAPAVCvColorInfo@@I@Z ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEIXZ ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEAAPAVCvPlayerColorInfo@@I@Z ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEAAPAVCvPlayerColorInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEAAPAVCvPlayerColorInfo@@I@Z PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEAAPAVCvPlayerColorInfo@@I@Z ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEIXZ ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEAAPAVCvTerrainInfo@@I@Z ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEAAPAVCvTerrainInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEAAPAVCvTerrainInfo@@I@Z PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEAAPAVCvTerrainInfo@@I@Z ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEIXZ ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEAAPAVCvYieldInfo@@I@Z ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEAAPAVCvYieldInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEAAPAVCvYieldInfo@@I@Z PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEAAPAVCvYieldInfo@@I@Z ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	??3ICvUnknown@@SGXPAX@Z				; ICvUnknown::operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??3ICvUnknown@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3ICvUnknown@@SGXPAX@Z PROC				; ICvUnknown::operator delete, COMDAT

; 310  : 		if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@operator@2

; 311  : 		{
; 312  : 			ICvUnknown* inst = (ICvUnknown*)(p);
; 313  : 			inst->Destroy();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[esp-4], eax
	jmp	edx
$LN1@operator@2:

; 314  : 		}
; 315  : 	}

	ret	4
??3ICvUnknown@@SGXPAX@Z ENDP				; ICvUnknown::operator delete
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEIXZ ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEAAPAVCvRouteInfo@@I@Z ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEAAPAVCvRouteInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEAAPAVCvRouteInfo@@I@Z PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEAAPAVCvRouteInfo@@I@Z ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEIXZ ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEAAPAVCvFeatureInfo@@I@Z ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEAAPAVCvFeatureInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEAAPAVCvFeatureInfo@@I@Z PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEAAPAVCvFeatureInfo@@I@Z ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEIXZ ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEAAPAVCvResourceClassInfo@@I@Z ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEAAPAVCvResourceClassInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEAAPAVCvResourceClassInfo@@I@Z PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEAAPAVCvResourceClassInfo@@I@Z ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEIXZ ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEAAPAVCvResourceInfo@@I@Z ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEAAPAVCvResourceInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEAAPAVCvResourceInfo@@I@Z PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEAAPAVCvResourceInfo@@I@Z ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEIXZ ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEAAPAVCvBuildInfo@@I@Z ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEAAPAVCvBuildInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEAAPAVCvBuildInfo@@I@Z PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEAAPAVCvBuildInfo@@I@Z ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEIXZ ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEAAPAVCvHandicapInfo@@I@Z ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEAAPAVCvHandicapInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEAAPAVCvHandicapInfo@@I@Z PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEAAPAVCvHandicapInfo@@I@Z ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEIXZ ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEAAPAVCvGameSpeedInfo@@I@Z ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEAAPAVCvGameSpeedInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEAAPAVCvGameSpeedInfo@@I@Z PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEAAPAVCvGameSpeedInfo@@I@Z ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEIXZ ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEAAPAVCvCivilizationInfo@@I@Z ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEAAPAVCvCivilizationInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEAAPAVCvCivilizationInfo@@I@Z PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEAAPAVCvCivilizationInfo@@I@Z ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEIXZ ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEABQAVCvMinorCivInfo@@I@Z ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEABQAVCvMinorCivInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEABQAVCvMinorCivInfo@@I@Z PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEABQAVCvMinorCivInfo@@I@Z ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEAAPAVCvMinorCivInfo@@I@Z ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEAAPAVCvMinorCivInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEAAPAVCvMinorCivInfo@@I@Z PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEAAPAVCvMinorCivInfo@@I@Z ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEIXZ ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEAAPAVCvLeaderHeadInfo@@I@Z ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEAAPAVCvLeaderHeadInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEAAPAVCvLeaderHeadInfo@@I@Z PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEAAPAVCvLeaderHeadInfo@@I@Z ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEIXZ ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEAAPAVCvProcessInfo@@I@Z ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEAAPAVCvProcessInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEAAPAVCvProcessInfo@@I@Z PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEAAPAVCvProcessInfo@@I@Z ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEIXZ ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEAAPAVCvVoteInfo@@I@Z ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEAAPAVCvVoteInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEAAPAVCvVoteInfo@@I@Z PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEAAPAVCvVoteInfo@@I@Z ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEIXZ ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEAAPAVCvBuildingClassInfo@@I@Z ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEAAPAVCvBuildingClassInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEAAPAVCvBuildingClassInfo@@I@Z PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEAAPAVCvBuildingClassInfo@@I@Z ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEIXZ ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEAAPAVCvUnitClassInfo@@I@Z ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEAAPAVCvUnitClassInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEAAPAVCvUnitClassInfo@@I@Z PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEAAPAVCvUnitClassInfo@@I@Z ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEIXZ ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEAAPAVCvSpecialUnitInfo@@I@Z ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEAAPAVCvSpecialUnitInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEAAPAVCvSpecialUnitInfo@@I@Z PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEAAPAVCvSpecialUnitInfo@@I@Z ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEIXZ ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEAAPAVCvVoteSourceInfo@@I@Z ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEAAPAVCvVoteSourceInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEAAPAVCvVoteSourceInfo@@I@Z PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEAAPAVCvVoteSourceInfo@@I@Z ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEIXZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEAAPAVCvBaseInfo@@I@Z ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEAAPAVCvBaseInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEAAPAVCvBaseInfo@@I@Z PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEAAPAVCvBaseInfo@@I@Z ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEIXZ ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEAAPAVCvGameOptionInfo@@I@Z ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEAAPAVCvGameOptionInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEAAPAVCvGameOptionInfo@@I@Z PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEAAPAVCvGameOptionInfo@@I@Z ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEIXZ ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEAAPAVCvMPOptionInfo@@I@Z ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEAAPAVCvMPOptionInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEAAPAVCvMPOptionInfo@@I@Z PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEAAPAVCvMPOptionInfo@@I@Z ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEIXZ ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEAAPAVCvPlayerOptionInfo@@I@Z ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEAAPAVCvPlayerOptionInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEAAPAVCvPlayerOptionInfo@@I@Z PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEAAPAVCvPlayerOptionInfo@@I@Z ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEIXZ ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEAAPAVCvSpecialistInfo@@I@Z ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEAAPAVCvSpecialistInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEAAPAVCvSpecialistInfo@@I@Z PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEAAPAVCvSpecialistInfo@@I@Z ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEIXZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAPAVCvActionInfo@@I@Z ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAPAVCvActionInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAPAVCvActionInfo@@I@Z PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAPAVCvActionInfo@@I@Z ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEIXZ ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEAAPAVCvMissionInfo@@I@Z ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEAAPAVCvMissionInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEAAPAVCvMissionInfo@@I@Z PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEAAPAVCvMissionInfo@@I@Z ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEIXZ ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEAAPAVCvControlInfo@@I@Z ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEAAPAVCvControlInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEAAPAVCvControlInfo@@I@Z PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEAAPAVCvControlInfo@@I@Z ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEIXZ ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEAAPAVCvCommandInfo@@I@Z ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEAAPAVCvCommandInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEAAPAVCvCommandInfo@@I@Z PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEAAPAVCvCommandInfo@@I@Z ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEIXZ ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEAAPAVCvAutomateInfo@@I@Z ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEAAPAVCvAutomateInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEAAPAVCvAutomateInfo@@I@Z PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEAAPAVCvAutomateInfo@@I@Z ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEIXZ ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEAAPAVCvEraInfo@@I@Z ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEAAPAVCvEraInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEAAPAVCvEraInfo@@I@Z PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEAAPAVCvEraInfo@@I@Z ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEIXZ ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEAAPAVCvHurryInfo@@I@Z ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEAAPAVCvHurryInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEAAPAVCvHurryInfo@@I@Z PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEAAPAVCvHurryInfo@@I@Z ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEIXZ ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEAAPAVCvVictoryInfo@@I@Z ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEAAPAVCvVictoryInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEAAPAVCvVictoryInfo@@I@Z PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEAAPAVCvVictoryInfo@@I@Z ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEIXZ ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEAAPAVCvSmallAwardInfo@@I@Z ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEAAPAVCvSmallAwardInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEAAPAVCvSmallAwardInfo@@I@Z PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEAAPAVCvSmallAwardInfo@@I@Z ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEIXZ ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEAAPAVCvEntityEventInfo@@I@Z ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEAAPAVCvEntityEventInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEAAPAVCvEntityEventInfo@@I@Z PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEAAPAVCvEntityEventInfo@@I@Z ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QBEIXZ ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAEAAPAVCvMultiUnitFormationInfo@@I@Z ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAEAAPAVCvMultiUnitFormationInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAEAAPAVCvMultiUnitFormationInfo@@I@Z PROC ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAEAAPAVCvMultiUnitFormationInfo@@I@Z ENDP ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAPAVCvTacticalMoveXMLEntry@@I@Z ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAPAVCvTacticalMoveXMLEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAPAVCvTacticalMoveXMLEntry@@I@Z PROC ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@QAEAAPAVCvTacticalMoveXMLEntry@@I@Z ENDP ; std::vector<CvTacticalMoveXMLEntry *,std::allocator<CvTacticalMoveXMLEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEIXZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAPAVCvTechEntry@@I@Z ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAPAVCvTechEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAPAVCvTechEntry@@I@Z PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAPAVCvTechEntry@@I@Z ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEIXZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAPAVCvPolicyEntry@@I@Z ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAPAVCvPolicyEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAPAVCvPolicyEntry@@I@Z PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAEAAPAVCvPolicyEntry@@I@Z ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEIXZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAPAVCvPolicyBranchEntry@@I@Z ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAPAVCvPolicyBranchEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAPAVCvPolicyBranchEntry@@I@Z PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAEAAPAVCvPolicyBranchEntry@@I@Z ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAPAVCvBuildingEntry@@I@Z ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAPAVCvBuildingEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAPAVCvBuildingEntry@@I@Z PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAEAAPAVCvBuildingEntry@@I@Z ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAPAVCvUnitEntry@@I@Z ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAPAVCvUnitEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAPAVCvUnitEntry@@I@Z PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAPAVCvUnitEntry@@I@Z ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAPAVCvProjectEntry@@I@Z ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAPAVCvProjectEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAPAVCvProjectEntry@@I@Z PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAEAAPAVCvProjectEntry@@I@Z ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAPAVCvImprovementEntry@@I@Z ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAPAVCvImprovementEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAPAVCvImprovementEntry@@I@Z PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAPAVCvImprovementEntry@@I@Z ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEIXZ ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAPAVCvEmphasisEntry@@I@Z ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAPAVCvEmphasisEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAPAVCvEmphasisEntry@@I@Z PROC ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@QAEAAPAVCvEmphasisEntry@@I@Z ENDP ; std::vector<CvEmphasisEntry *,std::allocator<CvEmphasisEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEIXZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAPAVCvTraitEntry@@I@Z ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAPAVCvTraitEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAPAVCvTraitEntry@@I@Z PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAPAVCvTraitEntry@@I@Z ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEIXZ ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAPAVCvBeliefEntry@@I@Z ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAPAVCvBeliefEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAPAVCvBeliefEntry@@I@Z PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAPAVCvBeliefEntry@@I@Z ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@QBEIXZ ; std::vector<CvReligionEntry *,std::allocator<CvReligionEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvReligionEntry *,std::allocator<CvReligionEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvReligionEntry *,std::allocator<CvReligionEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@QAEAAPAVCvReligionEntry@@I@Z ; std::vector<CvReligionEntry *,std::allocator<CvReligionEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@QAEAAPAVCvReligionEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@QAEAAPAVCvReligionEntry@@I@Z PROC ; std::vector<CvReligionEntry *,std::allocator<CvReligionEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@QAEAAPAVCvReligionEntry@@I@Z ENDP ; std::vector<CvReligionEntry *,std::allocator<CvReligionEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@QBEIXZ ; std::vector<CvLeagueSpecialSessionEntry *,std::allocator<CvLeagueSpecialSessionEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvLeagueSpecialSessionEntry *,std::allocator<CvLeagueSpecialSessionEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvLeagueSpecialSessionEntry *,std::allocator<CvLeagueSpecialSessionEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@QAEAAPAVCvLeagueSpecialSessionEntry@@I@Z ; std::vector<CvLeagueSpecialSessionEntry *,std::allocator<CvLeagueSpecialSessionEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@QAEAAPAVCvLeagueSpecialSessionEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@QAEAAPAVCvLeagueSpecialSessionEntry@@I@Z PROC ; std::vector<CvLeagueSpecialSessionEntry *,std::allocator<CvLeagueSpecialSessionEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@QAEAAPAVCvLeagueSpecialSessionEntry@@I@Z ENDP ; std::vector<CvLeagueSpecialSessionEntry *,std::allocator<CvLeagueSpecialSessionEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@QBEIXZ ; std::vector<CvLeagueNameEntry *,std::allocator<CvLeagueNameEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvLeagueNameEntry *,std::allocator<CvLeagueNameEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvLeagueNameEntry *,std::allocator<CvLeagueNameEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@QAEAAPAVCvLeagueNameEntry@@I@Z ; std::vector<CvLeagueNameEntry *,std::allocator<CvLeagueNameEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@QAEAAPAVCvLeagueNameEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@QAEAAPAVCvLeagueNameEntry@@I@Z PROC ; std::vector<CvLeagueNameEntry *,std::allocator<CvLeagueNameEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@QAEAAPAVCvLeagueNameEntry@@I@Z ENDP ; std::vector<CvLeagueNameEntry *,std::allocator<CvLeagueNameEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@QBEIXZ ; std::vector<CvLeagueProjectRewardEntry *,std::allocator<CvLeagueProjectRewardEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvLeagueProjectRewardEntry *,std::allocator<CvLeagueProjectRewardEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvLeagueProjectRewardEntry *,std::allocator<CvLeagueProjectRewardEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@QAEAAPAVCvLeagueProjectRewardEntry@@I@Z ; std::vector<CvLeagueProjectRewardEntry *,std::allocator<CvLeagueProjectRewardEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@QAEAAPAVCvLeagueProjectRewardEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@QAEAAPAVCvLeagueProjectRewardEntry@@I@Z PROC ; std::vector<CvLeagueProjectRewardEntry *,std::allocator<CvLeagueProjectRewardEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@QAEAAPAVCvLeagueProjectRewardEntry@@I@Z ENDP ; std::vector<CvLeagueProjectRewardEntry *,std::allocator<CvLeagueProjectRewardEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@QBEIXZ ; std::vector<CvLeagueProjectEntry *,std::allocator<CvLeagueProjectEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvLeagueProjectEntry *,std::allocator<CvLeagueProjectEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvLeagueProjectEntry *,std::allocator<CvLeagueProjectEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@QAEAAPAVCvLeagueProjectEntry@@I@Z ; std::vector<CvLeagueProjectEntry *,std::allocator<CvLeagueProjectEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@QAEAAPAVCvLeagueProjectEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@QAEAAPAVCvLeagueProjectEntry@@I@Z PROC ; std::vector<CvLeagueProjectEntry *,std::allocator<CvLeagueProjectEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@QAEAAPAVCvLeagueProjectEntry@@I@Z ENDP ; std::vector<CvLeagueProjectEntry *,std::allocator<CvLeagueProjectEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@QBEIXZ ; std::vector<CvResolutionEntry *,std::allocator<CvResolutionEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvResolutionEntry *,std::allocator<CvResolutionEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvResolutionEntry *,std::allocator<CvResolutionEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@QAEAAPAVCvResolutionEntry@@I@Z ; std::vector<CvResolutionEntry *,std::allocator<CvResolutionEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@QAEAAPAVCvResolutionEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@QAEAAPAVCvResolutionEntry@@I@Z PROC ; std::vector<CvResolutionEntry *,std::allocator<CvResolutionEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@QAEAAPAVCvResolutionEntry@@I@Z ENDP ; std::vector<CvResolutionEntry *,std::allocator<CvResolutionEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEIXZ ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAPAVCvAICityStrategyEntry@@I@Z ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAPAVCvAICityStrategyEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAPAVCvAICityStrategyEntry@@I@Z PROC ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@QAEAAPAVCvAICityStrategyEntry@@I@Z ENDP ; std::vector<CvAICityStrategyEntry *,std::allocator<CvAICityStrategyEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvEconomicAIStrategyXMLEntry@@I@Z ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvEconomicAIStrategyXMLEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvEconomicAIStrategyXMLEntry@@I@Z PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvEconomicAIStrategyXMLEntry@@I@Z ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvMilitaryAIStrategyXMLEntry@@I@Z ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvMilitaryAIStrategyXMLEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvMilitaryAIStrategyXMLEntry@@I@Z PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvMilitaryAIStrategyXMLEntry@@I@Z ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAPAVCvCitySpecializationXMLEntry@@I@Z ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAPAVCvCitySpecializationXMLEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAPAVCvCitySpecializationXMLEntry@@I@Z PROC ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@QAEAAPAVCvCitySpecializationXMLEntry@@I@Z ENDP ; std::vector<CvCitySpecializationXMLEntry *,std::allocator<CvCitySpecializationXMLEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvAIGrandStrategyXMLEntry@@I@Z ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvAIGrandStrategyXMLEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvAIGrandStrategyXMLEntry@@I@Z PROC ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvAIGrandStrategyXMLEntry@@I@Z ENDP ; std::vector<CvAIGrandStrategyXMLEntry *,std::allocator<CvAIGrandStrategyXMLEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QAE@PAVICvDLLDatabaseUtility1@@@Z ; std::auto_ptr<ICvDLLDatabaseUtility1>::auto_ptr<ICvDLLDatabaseUtility1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QAE@PAVICvDLLDatabaseUtility1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QAE@PAVICvDLLDatabaseUtility1@@@Z PROC ; std::auto_ptr<ICvDLLDatabaseUtility1>::auto_ptr<ICvDLLDatabaseUtility1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QAE@PAVICvDLLDatabaseUtility1@@@Z ENDP ; std::auto_ptr<ICvDLLDatabaseUtility1>::auto_ptr<ICvDLLDatabaseUtility1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QAE@XZ ; std::auto_ptr<ICvDLLDatabaseUtility1>::~auto_ptr<ICvDLLDatabaseUtility1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QAE@XZ PROC ; std::auto_ptr<ICvDLLDatabaseUtility1>::~auto_ptr<ICvDLLDatabaseUtility1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QAE@XZ ENDP ; std::auto_ptr<ICvDLLDatabaseUtility1>::~auto_ptr<ICvDLLDatabaseUtility1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z PROC	; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ENDP	; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z PROC ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvCity1@@@std@@QAE@U?$auto_ptr_ref@VICvCity1@@@1@@Z ENDP ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@2:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z ; std::auto_ptr<ICvDeal1>::auto_ptr<ICvDeal1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z PROC	; std::auto_ptr<ICvDeal1>::auto_ptr<ICvDeal1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z ENDP	; std::auto_ptr<ICvDeal1>::auto_ptr<ICvDeal1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvDeal1@@@std@@QAE@U?$auto_ptr_ref@VICvDeal1@@@1@@Z ; std::auto_ptr<ICvDeal1>::auto_ptr<ICvDeal1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvDeal1@@@std@@QAE@U?$auto_ptr_ref@VICvDeal1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvDeal1@@@std@@QAE@U?$auto_ptr_ref@VICvDeal1@@@1@@Z PROC ; std::auto_ptr<ICvDeal1>::auto_ptr<ICvDeal1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvDeal1@@@std@@QAE@U?$auto_ptr_ref@VICvDeal1@@@1@@Z ENDP ; std::auto_ptr<ICvDeal1>::auto_ptr<ICvDeal1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ		; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@3
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@3:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z PROC	; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ENDP	; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z PROC ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z ENDP ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@4:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvRandom1@@@std@@QAE@PAVICvRandom1@@@Z ; std::auto_ptr<ICvRandom1>::auto_ptr<ICvRandom1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvRandom1@@@std@@QAE@PAVICvRandom1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvRandom1@@@std@@QAE@PAVICvRandom1@@@Z PROC ; std::auto_ptr<ICvRandom1>::auto_ptr<ICvRandom1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvRandom1@@@std@@QAE@PAVICvRandom1@@@Z ENDP ; std::auto_ptr<ICvRandom1>::auto_ptr<ICvRandom1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvRandom1@@@std@@QAE@U?$auto_ptr_ref@VICvRandom1@@@1@@Z ; std::auto_ptr<ICvRandom1>::auto_ptr<ICvRandom1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvRandom1@@@std@@QAE@U?$auto_ptr_ref@VICvRandom1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvRandom1@@@std@@QAE@U?$auto_ptr_ref@VICvRandom1@@@1@@Z PROC ; std::auto_ptr<ICvRandom1>::auto_ptr<ICvRandom1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvRandom1@@@std@@QAE@U?$auto_ptr_ref@VICvRandom1@@@1@@Z ENDP ; std::auto_ptr<ICvRandom1>::auto_ptr<ICvRandom1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvRandom1@@@std@@QAE@XZ		; std::auto_ptr<ICvRandom1>::~auto_ptr<ICvRandom1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvRandom1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvRandom1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvRandom1>::~auto_ptr<ICvRandom1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@5
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@5:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvRandom1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvRandom1>::~auto_ptr<ICvRandom1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z PROC	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ENDP	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvUnit1@@@std@@QAE@U?$auto_ptr_ref@VICvUnit1@@@1@@Z ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvUnit1@@@std@@QAE@U?$auto_ptr_ref@VICvUnit1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@U?$auto_ptr_ref@VICvUnit1@@@1@@Z PROC ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@U?$auto_ptr_ref@VICvUnit1@@@1@@Z ENDP ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@6
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@6:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>, COMDAT
; _this$ = ecx
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAE@XZ ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
_TEXT	ENDS
PUBLIC	??0?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@QAE@XZ ; stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ??0?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@QAE@XZ
_TEXT	SEGMENT
??0?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@QAE@XZ PROC ; stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 118  : 		{	// construct with default comparator

	mov	eax, ecx

; 119  : 		}

	ret	0
??0?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@QAE@XZ ENDP ; stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvInterfaceModeInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvInterfaceModeInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvInterfaceModeInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvInterfaceModeInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvInterfaceModeInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvInterfaceModeInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvInterfaceModeInfo@@@std@@QAE@XZ ; std::allocator<CvInterfaceModeInfo *>::allocator<CvInterfaceModeInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvInterfaceModeInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvInterfaceModeInfo@@@std@@QAE@XZ PROC ; std::allocator<CvInterfaceModeInfo *>::allocator<CvInterfaceModeInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvInterfaceModeInfo@@@std@@QAE@XZ ENDP ; std::allocator<CvInterfaceModeInfo *>::allocator<CvInterfaceModeInfo *>
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@XZ	; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvColorInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvColorInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvColorInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvColorInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvColorInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvColorInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvColorInfo@@@std@@QAE@XZ	; std::allocator<CvColorInfo *>::allocator<CvColorInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvColorInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvColorInfo@@@std@@QAE@XZ PROC	; std::allocator<CvColorInfo *>::allocator<CvColorInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvColorInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvColorInfo *>::allocator<CvColorInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerColorInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlayerColorInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerColorInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlayerColorInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerColorInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlayerColorInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPlayerColorInfo@@@std@@QAE@XZ ; std::allocator<CvPlayerColorInfo *>::allocator<CvPlayerColorInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPlayerColorInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvPlayerColorInfo@@@std@@QAE@XZ PROC	; std::allocator<CvPlayerColorInfo *>::allocator<CvPlayerColorInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvPlayerColorInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvPlayerColorInfo *>::allocator<CvPlayerColorInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvTerrainInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTerrainInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTerrainInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTerrainInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTerrainInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTerrainInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvTerrainInfo@@@std@@QAE@XZ	; std::allocator<CvTerrainInfo *>::allocator<CvTerrainInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvTerrainInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvTerrainInfo@@@std@@QAE@XZ PROC	; std::allocator<CvTerrainInfo *>::allocator<CvTerrainInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvTerrainInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvTerrainInfo *>::allocator<CvTerrainInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvYieldInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvYieldInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvYieldInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvYieldInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvYieldInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvYieldInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvYieldInfo@@@std@@QAE@XZ	; std::allocator<CvYieldInfo *>::allocator<CvYieldInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvYieldInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvYieldInfo@@@std@@QAE@XZ PROC	; std::allocator<CvYieldInfo *>::allocator<CvYieldInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvYieldInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvYieldInfo *>::allocator<CvYieldInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvRouteInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvRouteInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvRouteInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvRouteInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvRouteInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvRouteInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvRouteInfo@@@std@@QAE@XZ	; std::allocator<CvRouteInfo *>::allocator<CvRouteInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvRouteInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvRouteInfo@@@std@@QAE@XZ PROC	; std::allocator<CvRouteInfo *>::allocator<CvRouteInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvRouteInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvRouteInfo *>::allocator<CvRouteInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvFeatureInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvFeatureInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvFeatureInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvFeatureInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvFeatureInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvFeatureInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvFeatureInfo@@@std@@QAE@XZ	; std::allocator<CvFeatureInfo *>::allocator<CvFeatureInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvFeatureInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvFeatureInfo@@@std@@QAE@XZ PROC	; std::allocator<CvFeatureInfo *>::allocator<CvFeatureInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvFeatureInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvFeatureInfo *>::allocator<CvFeatureInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvResourceClassInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvResourceClassInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvResourceClassInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvResourceClassInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvResourceClassInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvResourceClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvResourceClassInfo@@@std@@QAE@XZ ; std::allocator<CvResourceClassInfo *>::allocator<CvResourceClassInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvResourceClassInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvResourceClassInfo@@@std@@QAE@XZ PROC ; std::allocator<CvResourceClassInfo *>::allocator<CvResourceClassInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvResourceClassInfo@@@std@@QAE@XZ ENDP ; std::allocator<CvResourceClassInfo *>::allocator<CvResourceClassInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvResourceInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvResourceInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvResourceInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvResourceInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvResourceInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvResourceInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvResourceInfo@@@std@@QAE@XZ	; std::allocator<CvResourceInfo *>::allocator<CvResourceInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvResourceInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvResourceInfo@@@std@@QAE@XZ PROC	; std::allocator<CvResourceInfo *>::allocator<CvResourceInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvResourceInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvResourceInfo *>::allocator<CvResourceInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBuildInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBuildInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBuildInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvBuildInfo@@@std@@QAE@XZ	; std::allocator<CvBuildInfo *>::allocator<CvBuildInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvBuildInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvBuildInfo@@@std@@QAE@XZ PROC	; std::allocator<CvBuildInfo *>::allocator<CvBuildInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvBuildInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvBuildInfo *>::allocator<CvBuildInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvHandicapInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvHandicapInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvHandicapInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvHandicapInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvHandicapInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvHandicapInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvHandicapInfo@@@std@@QAE@XZ	; std::allocator<CvHandicapInfo *>::allocator<CvHandicapInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvHandicapInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvHandicapInfo@@@std@@QAE@XZ PROC	; std::allocator<CvHandicapInfo *>::allocator<CvHandicapInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvHandicapInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvHandicapInfo *>::allocator<CvHandicapInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvGameSpeedInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvGameSpeedInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvGameSpeedInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvGameSpeedInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvGameSpeedInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvGameSpeedInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvGameSpeedInfo@@@std@@QAE@XZ	; std::allocator<CvGameSpeedInfo *>::allocator<CvGameSpeedInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvGameSpeedInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvGameSpeedInfo@@@std@@QAE@XZ PROC	; std::allocator<CvGameSpeedInfo *>::allocator<CvGameSpeedInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvGameSpeedInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvGameSpeedInfo *>::allocator<CvGameSpeedInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvTurnTimerInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTurnTimerInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTurnTimerInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTurnTimerInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTurnTimerInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTurnTimerInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvTurnTimerInfo@@@std@@QAE@XZ	; std::allocator<CvTurnTimerInfo *>::allocator<CvTurnTimerInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvTurnTimerInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvTurnTimerInfo@@@std@@QAE@XZ PROC	; std::allocator<CvTurnTimerInfo *>::allocator<CvTurnTimerInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvTurnTimerInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvTurnTimerInfo *>::allocator<CvTurnTimerInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvCivilizationInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCivilizationInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCivilizationInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCivilizationInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCivilizationInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCivilizationInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCivilizationInfo@@@std@@QAE@XZ ; std::allocator<CvCivilizationInfo *>::allocator<CvCivilizationInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvCivilizationInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvCivilizationInfo@@@std@@QAE@XZ PROC	; std::allocator<CvCivilizationInfo *>::allocator<CvCivilizationInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvCivilizationInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvCivilizationInfo *>::allocator<CvCivilizationInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvMinorCivInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMinorCivInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvMinorCivInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMinorCivInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvMinorCivInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMinorCivInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvMinorCivInfo@@@std@@QAE@XZ	; std::allocator<CvMinorCivInfo *>::allocator<CvMinorCivInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvMinorCivInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvMinorCivInfo@@@std@@QAE@XZ PROC	; std::allocator<CvMinorCivInfo *>::allocator<CvMinorCivInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvMinorCivInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvMinorCivInfo *>::allocator<CvMinorCivInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvLeaderHeadInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvLeaderHeadInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvLeaderHeadInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvLeaderHeadInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvLeaderHeadInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvLeaderHeadInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvLeaderHeadInfo@@@std@@QAE@XZ ; std::allocator<CvLeaderHeadInfo *>::allocator<CvLeaderHeadInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvLeaderHeadInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvLeaderHeadInfo@@@std@@QAE@XZ PROC	; std::allocator<CvLeaderHeadInfo *>::allocator<CvLeaderHeadInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvLeaderHeadInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvLeaderHeadInfo *>::allocator<CvLeaderHeadInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvProcessInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvProcessInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvProcessInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvProcessInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvProcessInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvProcessInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvProcessInfo@@@std@@QAE@XZ	; std::allocator<CvProcessInfo *>::allocator<CvProcessInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvProcessInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvProcessInfo@@@std@@QAE@XZ PROC	; std::allocator<CvProcessInfo *>::allocator<CvProcessInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvProcessInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvProcessInfo *>::allocator<CvProcessInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvVoteInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvVoteInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvVoteInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvVoteInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvVoteInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvVoteInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvVoteInfo@@@std@@QAE@XZ	; std::allocator<CvVoteInfo *>::allocator<CvVoteInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvVoteInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvVoteInfo@@@std@@QAE@XZ PROC		; std::allocator<CvVoteInfo *>::allocator<CvVoteInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvVoteInfo@@@std@@QAE@XZ ENDP		; std::allocator<CvVoteInfo *>::allocator<CvVoteInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildingClassInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBuildingClassInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildingClassInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBuildingClassInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildingClassInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBuildingClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvBuildingClassInfo@@@std@@QAE@XZ ; std::allocator<CvBuildingClassInfo *>::allocator<CvBuildingClassInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvBuildingClassInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvBuildingClassInfo@@@std@@QAE@XZ PROC ; std::allocator<CvBuildingClassInfo *>::allocator<CvBuildingClassInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvBuildingClassInfo@@@std@@QAE@XZ ENDP ; std::allocator<CvBuildingClassInfo *>::allocator<CvBuildingClassInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvUnitClassInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvUnitClassInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvUnitClassInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvUnitClassInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvUnitClassInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvUnitClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvUnitClassInfo@@@std@@QAE@XZ	; std::allocator<CvUnitClassInfo *>::allocator<CvUnitClassInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvUnitClassInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvUnitClassInfo@@@std@@QAE@XZ PROC	; std::allocator<CvUnitClassInfo *>::allocator<CvUnitClassInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvUnitClassInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvUnitClassInfo *>::allocator<CvUnitClassInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvSpecialUnitInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvSpecialUnitInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvSpecialUnitInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvSpecialUnitInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvSpecialUnitInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvSpecialUnitInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvSpecialUnitInfo@@@std@@QAE@XZ ; std::allocator<CvSpecialUnitInfo *>::allocator<CvSpecialUnitInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvSpecialUnitInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvSpecialUnitInfo@@@std@@QAE@XZ PROC	; std::allocator<CvSpecialUnitInfo *>::allocator<CvSpecialUnitInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvSpecialUnitInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvSpecialUnitInfo *>::allocator<CvSpecialUnitInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvVoteSourceInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvVoteSourceInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvVoteSourceInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvVoteSourceInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvVoteSourceInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvVoteSourceInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvVoteSourceInfo@@@std@@QAE@XZ ; std::allocator<CvVoteSourceInfo *>::allocator<CvVoteSourceInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvVoteSourceInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvVoteSourceInfo@@@std@@QAE@XZ PROC	; std::allocator<CvVoteSourceInfo *>::allocator<CvVoteSourceInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvVoteSourceInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvVoteSourceInfo *>::allocator<CvVoteSourceInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvBaseInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBaseInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvBaseInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBaseInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvBaseInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBaseInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvBaseInfo@@@std@@QAE@XZ	; std::allocator<CvBaseInfo *>::allocator<CvBaseInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvBaseInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvBaseInfo@@@std@@QAE@XZ PROC		; std::allocator<CvBaseInfo *>::allocator<CvBaseInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvBaseInfo@@@std@@QAE@XZ ENDP		; std::allocator<CvBaseInfo *>::allocator<CvBaseInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvGameOptionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvGameOptionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvGameOptionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvGameOptionInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvGameOptionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvGameOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvGameOptionInfo@@@std@@QAE@XZ ; std::allocator<CvGameOptionInfo *>::allocator<CvGameOptionInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvGameOptionInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvGameOptionInfo@@@std@@QAE@XZ PROC	; std::allocator<CvGameOptionInfo *>::allocator<CvGameOptionInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvGameOptionInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvGameOptionInfo *>::allocator<CvGameOptionInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvMPOptionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMPOptionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvMPOptionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMPOptionInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvMPOptionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMPOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvMPOptionInfo@@@std@@QAE@XZ	; std::allocator<CvMPOptionInfo *>::allocator<CvMPOptionInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvMPOptionInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvMPOptionInfo@@@std@@QAE@XZ PROC	; std::allocator<CvMPOptionInfo *>::allocator<CvMPOptionInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvMPOptionInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvMPOptionInfo *>::allocator<CvMPOptionInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerOptionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlayerOptionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerOptionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlayerOptionInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerOptionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlayerOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPlayerOptionInfo@@@std@@QAE@XZ ; std::allocator<CvPlayerOptionInfo *>::allocator<CvPlayerOptionInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPlayerOptionInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvPlayerOptionInfo@@@std@@QAE@XZ PROC	; std::allocator<CvPlayerOptionInfo *>::allocator<CvPlayerOptionInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvPlayerOptionInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvPlayerOptionInfo *>::allocator<CvPlayerOptionInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvSpecialistInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvSpecialistInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvSpecialistInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvSpecialistInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvSpecialistInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvSpecialistInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvSpecialistInfo@@@std@@QAE@XZ ; std::allocator<CvSpecialistInfo *>::allocator<CvSpecialistInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvSpecialistInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvSpecialistInfo@@@std@@QAE@XZ PROC	; std::allocator<CvSpecialistInfo *>::allocator<CvSpecialistInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvSpecialistInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvSpecialistInfo *>::allocator<CvSpecialistInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvActionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvActionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvActionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvActionInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvActionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvActionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvActionInfo@@@std@@QAE@XZ	; std::allocator<CvActionInfo *>::allocator<CvActionInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvActionInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvActionInfo@@@std@@QAE@XZ PROC	; std::allocator<CvActionInfo *>::allocator<CvActionInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvActionInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvActionInfo *>::allocator<CvActionInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvMissionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMissionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvMissionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMissionInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvMissionInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMissionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvMissionInfo@@@std@@QAE@XZ	; std::allocator<CvMissionInfo *>::allocator<CvMissionInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvMissionInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvMissionInfo@@@std@@QAE@XZ PROC	; std::allocator<CvMissionInfo *>::allocator<CvMissionInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvMissionInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvMissionInfo *>::allocator<CvMissionInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvControlInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvControlInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvControlInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvControlInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvControlInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvControlInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvControlInfo@@@std@@QAE@XZ	; std::allocator<CvControlInfo *>::allocator<CvControlInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvControlInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvControlInfo@@@std@@QAE@XZ PROC	; std::allocator<CvControlInfo *>::allocator<CvControlInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvControlInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvControlInfo *>::allocator<CvControlInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvCommandInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCommandInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCommandInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCommandInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCommandInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCommandInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCommandInfo@@@std@@QAE@XZ	; std::allocator<CvCommandInfo *>::allocator<CvCommandInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvCommandInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvCommandInfo@@@std@@QAE@XZ PROC	; std::allocator<CvCommandInfo *>::allocator<CvCommandInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvCommandInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvCommandInfo *>::allocator<CvCommandInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvAutomateInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvAutomateInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvAutomateInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvAutomateInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvAutomateInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvAutomateInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvAutomateInfo@@@std@@QAE@XZ	; std::allocator<CvAutomateInfo *>::allocator<CvAutomateInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvAutomateInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvAutomateInfo@@@std@@QAE@XZ PROC	; std::allocator<CvAutomateInfo *>::allocator<CvAutomateInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvAutomateInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvAutomateInfo *>::allocator<CvAutomateInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvEraInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvEraInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvEraInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvEraInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvEraInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvEraInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvEraInfo@@@std@@QAE@XZ	; std::allocator<CvEraInfo *>::allocator<CvEraInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvEraInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvEraInfo@@@std@@QAE@XZ PROC		; std::allocator<CvEraInfo *>::allocator<CvEraInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvEraInfo@@@std@@QAE@XZ ENDP		; std::allocator<CvEraInfo *>::allocator<CvEraInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvHurryInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvHurryInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvHurryInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvHurryInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvHurryInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvHurryInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvHurryInfo@@@std@@QAE@XZ	; std::allocator<CvHurryInfo *>::allocator<CvHurryInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvHurryInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvHurryInfo@@@std@@QAE@XZ PROC	; std::allocator<CvHurryInfo *>::allocator<CvHurryInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvHurryInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvHurryInfo *>::allocator<CvHurryInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvVictoryInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvVictoryInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvVictoryInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvVictoryInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvVictoryInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvVictoryInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvVictoryInfo@@@std@@QAE@XZ	; std::allocator<CvVictoryInfo *>::allocator<CvVictoryInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvVictoryInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvVictoryInfo@@@std@@QAE@XZ PROC	; std::allocator<CvVictoryInfo *>::allocator<CvVictoryInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvVictoryInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvVictoryInfo *>::allocator<CvVictoryInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvSmallAwardInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvSmallAwardInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvSmallAwardInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvSmallAwardInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvSmallAwardInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvSmallAwardInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvSmallAwardInfo@@@std@@QAE@XZ ; std::allocator<CvSmallAwardInfo *>::allocator<CvSmallAwardInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvSmallAwardInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvSmallAwardInfo@@@std@@QAE@XZ PROC	; std::allocator<CvSmallAwardInfo *>::allocator<CvSmallAwardInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvSmallAwardInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvSmallAwardInfo *>::allocator<CvSmallAwardInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvEntityEventInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvEntityEventInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvEntityEventInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvEntityEventInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvEntityEventInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvEntityEventInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvEntityEventInfo@@@std@@QAE@XZ ; std::allocator<CvEntityEventInfo *>::allocator<CvEntityEventInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvEntityEventInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvEntityEventInfo@@@std@@QAE@XZ PROC	; std::allocator<CvEntityEventInfo *>::allocator<CvEntityEventInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvEntityEventInfo@@@std@@QAE@XZ ENDP	; std::allocator<CvEntityEventInfo *>::allocator<CvEntityEventInfo *>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvMultiUnitFormationInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMultiUnitFormationInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvMultiUnitFormationInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMultiUnitFormationInfo *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvMultiUnitFormationInfo *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMultiUnitFormationInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAE@XZ ; std::allocator<CvMultiUnitFormationInfo *>::allocator<CvMultiUnitFormationInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAE@XZ PROC ; std::allocator<CvMultiUnitFormationInfo *>::allocator<CvMultiUnitFormationInfo *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAE@XZ ENDP ; std::allocator<CvMultiUnitFormationInfo *>::allocator<CvMultiUnitFormationInfo *>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QBEPAVICvDLLDatabaseUtility1@@XZ ; std::auto_ptr<ICvDLLDatabaseUtility1>::get
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?get@?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QBEPAVICvDLLDatabaseUtility1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QBEPAVICvDLLDatabaseUtility1@@XZ PROC ; std::auto_ptr<ICvDLLDatabaseUtility1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QBEPAVICvDLLDatabaseUtility1@@XZ ENDP ; std::auto_ptr<ICvDLLDatabaseUtility1>::get
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEABQAVCvCivilizationInfo@@XZ ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEABQAVCvCivilizationInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEABQAVCvCivilizationInfo@@XZ PROC ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEABQAVCvCivilizationInfo@@XZ ENDP ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??8?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??8?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator==, COMDAT
; _this$ = ecx

; 291  : 
; 292  :  #if _HAS_ITERATOR_DEBUGGING
; 293  : 			_Compat(_Right);
; 294  :  #else
; 295  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 296  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 297  : 
; 298  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 299  : 			}

	ret	4
??8?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator==
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABH@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABH@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, DWORD PTR __Val1$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __Val2$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [esi+28], edx

; 51   : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABH@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBIH@std@@QAE@ABIABH@Z		; std::pair<unsigned int const ,int>::pair<unsigned int const ,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@$$CBIH@std@@QAE@ABIABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBIH@std@@QAE@ABIABH@Z PROC			; std::pair<unsigned int const ,int>::pair<unsigned int const ,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@$$CBIH@std@@QAE@ABIABH@Z ENDP			; std::pair<unsigned int const ,int>::pair<unsigned int const ,int>
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Nextnode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Nextnode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Nextnode, COMDAT

; 115  : 		return ((_Nodepref)(*_Pnode)._Next);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 116  : 		}

	ret	0
?_Nextnode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Prevnode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Prevnode
; Function compile flags: /Ogtpy
;	COMDAT ?_Prevnode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Prevnode, COMDAT

; 120  : 		return ((_Nodepref)(*_Pnode)._Prev);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 121  : 		}

	ret	0
?_Prevnode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Prevnode
_TEXT	ENDS
PUBLIC	?_Myval@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Myval, COMDAT

; 125  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 126  : 		}

	ret	0
?_Myval@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Myval
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z PROC ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z ENDP ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??A?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@I@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@I@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@I@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAEAAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@I@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAEAAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAEAAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@I@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAEAAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@I@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::~_Container_base_aux_alloc_empty<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::~_Container_base_aux_alloc_empty<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::~_Container_base_aux_alloc_empty<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	?_Get_iter_from_vec@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV345@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Get_iter_from_vec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?_Get_iter_from_vec@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV345@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Iter$ = 12						; size = 4
?_Get_iter_from_vec@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV345@@Z PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Get_iter_from_vec, COMDAT
; _this$ = ecx

; 321  : 	return (_Iter);

	mov	eax, DWORD PTR __Iter$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 322  : 	}

	ret	8
?_Get_iter_from_vec@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV345@@Z ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Get_iter_from_vec
_TEXT	ENDS
PUBLIC	??0?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z ; stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0>::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\hash_map
;	COMDAT ??0?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z
_TEXT	SEGMENT
__Traits$ = 8						; size = 4
??0?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z PROC ; stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0>::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0>, COMDAT
; _this$ = ecx

; 49   : 		{	// construct with specified comparator

	mov	eax, ecx
	mov	ecx, DWORD PTR __Traits$[esp-4]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 50   : 		}

	ret	4
??0?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z ENDP ; stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0>::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0>
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@@Z ; stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0>::_Kfn
; Function compile flags: /Ogtpy
;	COMDAT ?_Kfn@?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@@Z PROC ; stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0>::_Kfn, COMDAT

; 75   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[esp-4]

; 76   : 		}

	ret	0
?_Kfn@?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@@Z ENDP ; stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254069 = -80						; size = 28
$T254068 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254069[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254068[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254069[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254068[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254068[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254068[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254068[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254069[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254068[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE@V?$allocator@PAVCvInterfaceModeInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvInterfaceModeInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvInterfaceModeInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE@V?$allocator@PAVCvInterfaceModeInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE@V?$allocator@PAVCvInterfaceModeInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvInterfaceModeInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvInterfaceModeInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE@V?$allocator@PAVCvInterfaceModeInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvInterfaceModeInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvInterfaceModeInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvInterfaceModeInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvInterfaceModeInfo *>::allocator<CvInterfaceModeInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvInterfaceModeInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvInterfaceModeInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvInterfaceModeInfo *>::allocator<CvInterfaceModeInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvInterfaceModeInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvInterfaceModeInfo *>::allocator<CvInterfaceModeInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvInterfaceModeInfo@@@std@@QAEXPAPAVCvInterfaceModeInfo@@I@Z ; std::allocator<CvInterfaceModeInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvInterfaceModeInfo@@@std@@QAEXPAPAVCvInterfaceModeInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvInterfaceModeInfo@@@std@@QAEXPAPAVCvInterfaceModeInfo@@I@Z PROC ; std::allocator<CvInterfaceModeInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvInterfaceModeInfo@@@std@@QAEXPAPAVCvInterfaceModeInfo@@I@Z ENDP ; std::allocator<CvInterfaceModeInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 21					; 00000015H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::size, COMDAT
; _this$ = ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::size
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@SAABIABU?$pair@$$CBIH@2@@Z ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@SAABIABU?$pair@$$CBIH@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@SAABIABU?$pair@$$CBIH@2@@Z PROC ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Kfn, COMDAT

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[esp-4]

; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@SAABIABU?$pair@$$CBIH@2@@Z ENDP ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254142 = -80						; size = 28
$T254141 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254142[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254141[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254142[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254141[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254141[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254141[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254141[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254142[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254141[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvColorInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvColorInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvColorInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvColorInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvColorInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvColorInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvColorInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvColorInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvColorInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvColorInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvColorInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvColorInfo *>::allocator<CvColorInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvColorInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvColorInfo@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvColorInfo *>::allocator<CvColorInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvColorInfo@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvColorInfo *>::allocator<CvColorInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvColorInfo@@@std@@QAEXPAPAVCvColorInfo@@I@Z ; std::allocator<CvColorInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvColorInfo@@@std@@QAEXPAPAVCvColorInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvColorInfo@@@std@@QAEXPAPAVCvColorInfo@@I@Z PROC ; std::allocator<CvColorInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvColorInfo@@@std@@QAEXPAPAVCvColorInfo@@I@Z ENDP ; std::allocator<CvColorInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254176 = -80						; size = 28
$T254175 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254176[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254175[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254176[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254175[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254175[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254175[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254175[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254176[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254175[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerColorInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerColorInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlayerColorInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerColorInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerColorInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerColorInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlayerColorInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerColorInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerColorInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlayerColorInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPlayerColorInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvPlayerColorInfo *>::allocator<CvPlayerColorInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPlayerColorInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvPlayerColorInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvPlayerColorInfo *>::allocator<CvPlayerColorInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvPlayerColorInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvPlayerColorInfo *>::allocator<CvPlayerColorInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvPlayerColorInfo@@@std@@QAEXPAPAVCvPlayerColorInfo@@I@Z ; std::allocator<CvPlayerColorInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvPlayerColorInfo@@@std@@QAEXPAPAVCvPlayerColorInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvPlayerColorInfo@@@std@@QAEXPAPAVCvPlayerColorInfo@@I@Z PROC ; std::allocator<CvPlayerColorInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvPlayerColorInfo@@@std@@QAEXPAPAVCvPlayerColorInfo@@I@Z ENDP ; std::allocator<CvPlayerColorInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254210 = -80						; size = 28
$T254209 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254210[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254209[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254210[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254209[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254209[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254209[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254209[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@4:
$LN12@Xlen@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254210[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254209[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTerrainInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvTerrainInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvTerrainInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTerrainInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTerrainInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTerrainInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvTerrainInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTerrainInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTerrainInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvTerrainInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvTerrainInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvTerrainInfo *>::allocator<CvTerrainInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvTerrainInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvTerrainInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvTerrainInfo *>::allocator<CvTerrainInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvTerrainInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvTerrainInfo *>::allocator<CvTerrainInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvTerrainInfo@@@std@@QAEXPAPAVCvTerrainInfo@@I@Z ; std::allocator<CvTerrainInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvTerrainInfo@@@std@@QAEXPAPAVCvTerrainInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvTerrainInfo@@@std@@QAEXPAPAVCvTerrainInfo@@I@Z PROC ; std::allocator<CvTerrainInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvTerrainInfo@@@std@@QAEXPAPAVCvTerrainInfo@@I@Z ENDP ; std::allocator<CvTerrainInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254244 = -80						; size = 28
$T254243 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254244[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254243[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254244[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254243[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254243[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254243[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254243[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@5:
$LN12@Xlen@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254244[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254243[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE@V?$allocator@PAVCvYieldInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvYieldInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvYieldInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE@V?$allocator@PAVCvYieldInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE@V?$allocator@PAVCvYieldInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvYieldInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvYieldInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE@V?$allocator@PAVCvYieldInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvYieldInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvYieldInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvYieldInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvYieldInfo *>::allocator<CvYieldInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvYieldInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvYieldInfo@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvYieldInfo *>::allocator<CvYieldInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvYieldInfo@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvYieldInfo *>::allocator<CvYieldInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvYieldInfo@@@std@@QAEXPAPAVCvYieldInfo@@I@Z ; std::allocator<CvYieldInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvYieldInfo@@@std@@QAEXPAPAVCvYieldInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvYieldInfo@@@std@@QAEXPAPAVCvYieldInfo@@I@Z PROC ; std::allocator<CvYieldInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvYieldInfo@@@std@@QAEXPAPAVCvYieldInfo@@I@Z ENDP ; std::allocator<CvYieldInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254278 = -80						; size = 28
$T254277 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254278[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254277[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254278[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254277[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254277[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254277[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254277[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@6:
$LN12@Xlen@6:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254278[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254277[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvRouteInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvRouteInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvRouteInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvRouteInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvRouteInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvRouteInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvRouteInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvRouteInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvRouteInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvRouteInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvRouteInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvRouteInfo *>::allocator<CvRouteInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvRouteInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvRouteInfo@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvRouteInfo *>::allocator<CvRouteInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvRouteInfo@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvRouteInfo *>::allocator<CvRouteInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvRouteInfo@@@std@@QAEXPAPAVCvRouteInfo@@I@Z ; std::allocator<CvRouteInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvRouteInfo@@@std@@QAEXPAPAVCvRouteInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvRouteInfo@@@std@@QAEXPAPAVCvRouteInfo@@I@Z PROC ; std::allocator<CvRouteInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvRouteInfo@@@std@@QAEXPAPAVCvRouteInfo@@I@Z ENDP ; std::allocator<CvRouteInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254312 = -80						; size = 28
$T254311 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254312[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254311[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254312[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254311[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254311[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254311[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254311[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@7:
$LN12@Xlen@7:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254312[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254311[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE@V?$allocator@PAVCvFeatureInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvFeatureInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvFeatureInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE@V?$allocator@PAVCvFeatureInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE@V?$allocator@PAVCvFeatureInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvFeatureInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvFeatureInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE@V?$allocator@PAVCvFeatureInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvFeatureInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvFeatureInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvFeatureInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvFeatureInfo *>::allocator<CvFeatureInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvFeatureInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvFeatureInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvFeatureInfo *>::allocator<CvFeatureInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvFeatureInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvFeatureInfo *>::allocator<CvFeatureInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvFeatureInfo@@@std@@QAEXPAPAVCvFeatureInfo@@I@Z ; std::allocator<CvFeatureInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvFeatureInfo@@@std@@QAEXPAPAVCvFeatureInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvFeatureInfo@@@std@@QAEXPAPAVCvFeatureInfo@@I@Z PROC ; std::allocator<CvFeatureInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvFeatureInfo@@@std@@QAEXPAPAVCvFeatureInfo@@I@Z ENDP ; std::allocator<CvFeatureInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254346 = -80						; size = 28
$T254345 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254346[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254345[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254346[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254345[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254345[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254345[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254345[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@8:
$LN12@Xlen@8:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254346[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254345[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceClassInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvResourceClassInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvResourceClassInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceClassInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceClassInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvResourceClassInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvResourceClassInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceClassInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvResourceClassInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvResourceClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvResourceClassInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvResourceClassInfo *>::allocator<CvResourceClassInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvResourceClassInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvResourceClassInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvResourceClassInfo *>::allocator<CvResourceClassInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvResourceClassInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvResourceClassInfo *>::allocator<CvResourceClassInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvResourceClassInfo@@@std@@QAEXPAPAVCvResourceClassInfo@@I@Z ; std::allocator<CvResourceClassInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvResourceClassInfo@@@std@@QAEXPAPAVCvResourceClassInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvResourceClassInfo@@@std@@QAEXPAPAVCvResourceClassInfo@@I@Z PROC ; std::allocator<CvResourceClassInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvResourceClassInfo@@@std@@QAEXPAPAVCvResourceClassInfo@@I@Z ENDP ; std::allocator<CvResourceClassInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254380 = -80						; size = 28
$T254379 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254380[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254379[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254380[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254379[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254379[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254379[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254379[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@9:
$LN12@Xlen@9:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254380[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254379[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvResourceInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvResourceInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvResourceInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvResourceInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvResourceInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvResourceInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvResourceInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvResourceInfo *>::allocator<CvResourceInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvResourceInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvResourceInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvResourceInfo *>::allocator<CvResourceInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvResourceInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvResourceInfo *>::allocator<CvResourceInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvResourceInfo@@@std@@QAEXPAPAVCvResourceInfo@@I@Z ; std::allocator<CvResourceInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvResourceInfo@@@std@@QAEXPAPAVCvResourceInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvResourceInfo@@@std@@QAEXPAPAVCvResourceInfo@@I@Z PROC ; std::allocator<CvResourceInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvResourceInfo@@@std@@QAEXPAPAVCvResourceInfo@@I@Z ENDP ; std::allocator<CvResourceInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254414 = -80						; size = 28
$T254413 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254414[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254413[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254414[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254413[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254413[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254413[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254413[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@10:
$LN12@Xlen@10:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254414[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254413[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvBuildInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvBuildInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvBuildInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvBuildInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvBuildInfo *>::allocator<CvBuildInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvBuildInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvBuildInfo@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvBuildInfo *>::allocator<CvBuildInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvBuildInfo@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvBuildInfo *>::allocator<CvBuildInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvBuildInfo@@@std@@QAEXPAPAVCvBuildInfo@@I@Z ; std::allocator<CvBuildInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvBuildInfo@@@std@@QAEXPAPAVCvBuildInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvBuildInfo@@@std@@QAEXPAPAVCvBuildInfo@@I@Z PROC ; std::allocator<CvBuildInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvBuildInfo@@@std@@QAEXPAPAVCvBuildInfo@@I@Z ENDP ; std::allocator<CvBuildInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254448 = -80						; size = 28
$T254447 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254448[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254447[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254448[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254447[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254447[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254447[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254447[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@11:
$LN12@Xlen@11:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254448[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254447[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHandicapInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvHandicapInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvHandicapInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHandicapInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHandicapInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvHandicapInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvHandicapInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHandicapInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvHandicapInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvHandicapInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvHandicapInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvHandicapInfo *>::allocator<CvHandicapInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvHandicapInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvHandicapInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvHandicapInfo *>::allocator<CvHandicapInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvHandicapInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvHandicapInfo *>::allocator<CvHandicapInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvHandicapInfo@@@std@@QAEXPAPAVCvHandicapInfo@@I@Z ; std::allocator<CvHandicapInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvHandicapInfo@@@std@@QAEXPAPAVCvHandicapInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvHandicapInfo@@@std@@QAEXPAPAVCvHandicapInfo@@I@Z PROC ; std::allocator<CvHandicapInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvHandicapInfo@@@std@@QAEXPAPAVCvHandicapInfo@@I@Z ENDP ; std::allocator<CvHandicapInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254482 = -80						; size = 28
$T254481 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254482[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254481[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254482[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254481[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254481[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254481[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254481[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@12:
$LN12@Xlen@12:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254482[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254481[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameSpeedInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvGameSpeedInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvGameSpeedInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameSpeedInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameSpeedInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvGameSpeedInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvGameSpeedInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameSpeedInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvGameSpeedInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvGameSpeedInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvGameSpeedInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvGameSpeedInfo *>::allocator<CvGameSpeedInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvGameSpeedInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvGameSpeedInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvGameSpeedInfo *>::allocator<CvGameSpeedInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvGameSpeedInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvGameSpeedInfo *>::allocator<CvGameSpeedInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvGameSpeedInfo@@@std@@QAEXPAPAVCvGameSpeedInfo@@I@Z ; std::allocator<CvGameSpeedInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvGameSpeedInfo@@@std@@QAEXPAPAVCvGameSpeedInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvGameSpeedInfo@@@std@@QAEXPAPAVCvGameSpeedInfo@@I@Z PROC ; std::allocator<CvGameSpeedInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvGameSpeedInfo@@@std@@QAEXPAPAVCvGameSpeedInfo@@I@Z ENDP ; std::allocator<CvGameSpeedInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254516 = -80						; size = 28
$T254515 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254516[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254515[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254516[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254515[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254515[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254515[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254515[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@13:
$LN12@Xlen@13:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254516[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254515[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTurnTimerInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvTurnTimerInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvTurnTimerInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTurnTimerInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTurnTimerInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTurnTimerInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvTurnTimerInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTurnTimerInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTurnTimerInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvTurnTimerInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvTurnTimerInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvTurnTimerInfo *>::allocator<CvTurnTimerInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvTurnTimerInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvTurnTimerInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvTurnTimerInfo *>::allocator<CvTurnTimerInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvTurnTimerInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvTurnTimerInfo *>::allocator<CvTurnTimerInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvTurnTimerInfo@@@std@@QAEXPAPAVCvTurnTimerInfo@@I@Z ; std::allocator<CvTurnTimerInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvTurnTimerInfo@@@std@@QAEXPAPAVCvTurnTimerInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvTurnTimerInfo@@@std@@QAEXPAPAVCvTurnTimerInfo@@I@Z PROC ; std::allocator<CvTurnTimerInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvTurnTimerInfo@@@std@@QAEXPAPAVCvTurnTimerInfo@@I@Z ENDP ; std::allocator<CvTurnTimerInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254550 = -80						; size = 28
$T254549 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254550[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254549[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254550[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254549[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254549[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254549[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254549[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@14:
$LN12@Xlen@14:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254550[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254549[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCivilizationInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvCivilizationInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvCivilizationInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCivilizationInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCivilizationInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCivilizationInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvCivilizationInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCivilizationInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCivilizationInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvCivilizationInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCivilizationInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvCivilizationInfo *>::allocator<CvCivilizationInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvCivilizationInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvCivilizationInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvCivilizationInfo *>::allocator<CvCivilizationInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvCivilizationInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvCivilizationInfo *>::allocator<CvCivilizationInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvCivilizationInfo@@@std@@QAEXPAPAVCvCivilizationInfo@@I@Z ; std::allocator<CvCivilizationInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvCivilizationInfo@@@std@@QAEXPAPAVCvCivilizationInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvCivilizationInfo@@@std@@QAEXPAPAVCvCivilizationInfo@@I@Z PROC ; std::allocator<CvCivilizationInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvCivilizationInfo@@@std@@QAEXPAPAVCvCivilizationInfo@@I@Z ENDP ; std::allocator<CvCivilizationInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254584 = -80						; size = 28
$T254583 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254584[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254583[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254584[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254583[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254583[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254583[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254583[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@15:
$LN12@Xlen@15:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254584[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254583[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMinorCivInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvMinorCivInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvMinorCivInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMinorCivInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMinorCivInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvMinorCivInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvMinorCivInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMinorCivInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvMinorCivInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvMinorCivInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvMinorCivInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvMinorCivInfo *>::allocator<CvMinorCivInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvMinorCivInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvMinorCivInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvMinorCivInfo *>::allocator<CvMinorCivInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvMinorCivInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvMinorCivInfo *>::allocator<CvMinorCivInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvMinorCivInfo@@@std@@QAEXPAPAVCvMinorCivInfo@@I@Z ; std::allocator<CvMinorCivInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvMinorCivInfo@@@std@@QAEXPAPAVCvMinorCivInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvMinorCivInfo@@@std@@QAEXPAPAVCvMinorCivInfo@@I@Z PROC ; std::allocator<CvMinorCivInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvMinorCivInfo@@@std@@QAEXPAPAVCvMinorCivInfo@@I@Z ENDP ; std::allocator<CvMinorCivInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254618 = -80						; size = 28
$T254617 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254618[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254617[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254618[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254617[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254617[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254617[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254617[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@16:
$LN12@Xlen@16:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254618[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254617[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE@V?$allocator@PAVCvLeaderHeadInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvLeaderHeadInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvLeaderHeadInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE@V?$allocator@PAVCvLeaderHeadInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE@V?$allocator@PAVCvLeaderHeadInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvLeaderHeadInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvLeaderHeadInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE@V?$allocator@PAVCvLeaderHeadInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvLeaderHeadInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvLeaderHeadInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvLeaderHeadInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvLeaderHeadInfo *>::allocator<CvLeaderHeadInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvLeaderHeadInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvLeaderHeadInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvLeaderHeadInfo *>::allocator<CvLeaderHeadInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvLeaderHeadInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvLeaderHeadInfo *>::allocator<CvLeaderHeadInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvLeaderHeadInfo@@@std@@QAEXPAPAVCvLeaderHeadInfo@@I@Z ; std::allocator<CvLeaderHeadInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvLeaderHeadInfo@@@std@@QAEXPAPAVCvLeaderHeadInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvLeaderHeadInfo@@@std@@QAEXPAPAVCvLeaderHeadInfo@@I@Z PROC ; std::allocator<CvLeaderHeadInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvLeaderHeadInfo@@@std@@QAEXPAPAVCvLeaderHeadInfo@@I@Z ENDP ; std::allocator<CvLeaderHeadInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254652 = -80						; size = 28
$T254651 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254652[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254651[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254652[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254651[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254651[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254651[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254651[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@17:
$LN12@Xlen@17:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254652[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254651[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE@V?$allocator@PAVCvProcessInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvProcessInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvProcessInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE@V?$allocator@PAVCvProcessInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE@V?$allocator@PAVCvProcessInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvProcessInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvProcessInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE@V?$allocator@PAVCvProcessInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvProcessInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvProcessInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvProcessInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvProcessInfo *>::allocator<CvProcessInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvProcessInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvProcessInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvProcessInfo *>::allocator<CvProcessInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvProcessInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvProcessInfo *>::allocator<CvProcessInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvProcessInfo@@@std@@QAEXPAPAVCvProcessInfo@@I@Z ; std::allocator<CvProcessInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvProcessInfo@@@std@@QAEXPAPAVCvProcessInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvProcessInfo@@@std@@QAEXPAPAVCvProcessInfo@@I@Z PROC ; std::allocator<CvProcessInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvProcessInfo@@@std@@QAEXPAPAVCvProcessInfo@@I@Z ENDP ; std::allocator<CvProcessInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254686 = -80						; size = 28
$T254685 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254686[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254685[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254686[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254685[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254685[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254685[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254685[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@18:
$LN12@Xlen@18:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254686[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254685[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvVoteInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvVoteInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvVoteInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvVoteInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvVoteInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvVoteInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvVoteInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvVoteInfo *>::allocator<CvVoteInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvVoteInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvVoteInfo@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvVoteInfo *>::allocator<CvVoteInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvVoteInfo@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvVoteInfo *>::allocator<CvVoteInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvVoteInfo@@@std@@QAEXPAPAVCvVoteInfo@@I@Z ; std::allocator<CvVoteInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvVoteInfo@@@std@@QAEXPAPAVCvVoteInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvVoteInfo@@@std@@QAEXPAPAVCvVoteInfo@@I@Z PROC ; std::allocator<CvVoteInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvVoteInfo@@@std@@QAEXPAPAVCvVoteInfo@@I@Z ENDP ; std::allocator<CvVoteInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254720 = -80						; size = 28
$T254719 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254720[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254719[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254720[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254719[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254719[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254719[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254719[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@19:
$LN12@Xlen@19:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254720[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254719[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingClassInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildingClassInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvBuildingClassInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingClassInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingClassInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildingClassInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvBuildingClassInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingClassInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvBuildingClassInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvBuildingClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvBuildingClassInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvBuildingClassInfo *>::allocator<CvBuildingClassInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvBuildingClassInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvBuildingClassInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvBuildingClassInfo *>::allocator<CvBuildingClassInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvBuildingClassInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvBuildingClassInfo *>::allocator<CvBuildingClassInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvBuildingClassInfo@@@std@@QAEXPAPAVCvBuildingClassInfo@@I@Z ; std::allocator<CvBuildingClassInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvBuildingClassInfo@@@std@@QAEXPAPAVCvBuildingClassInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvBuildingClassInfo@@@std@@QAEXPAPAVCvBuildingClassInfo@@I@Z PROC ; std::allocator<CvBuildingClassInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvBuildingClassInfo@@@std@@QAEXPAPAVCvBuildingClassInfo@@I@Z ENDP ; std::allocator<CvBuildingClassInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254754 = -80						; size = 28
$T254753 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254754[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254753[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254754[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254753[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254753[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254753[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254753[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@20:
$LN12@Xlen@20:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254754[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254753[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvUnitClassInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvUnitClassInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvUnitClassInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvUnitClassInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvUnitClassInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvUnitClassInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvUnitClassInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvUnitClassInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvUnitClassInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvUnitClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvUnitClassInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvUnitClassInfo *>::allocator<CvUnitClassInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvUnitClassInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvUnitClassInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvUnitClassInfo *>::allocator<CvUnitClassInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvUnitClassInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvUnitClassInfo *>::allocator<CvUnitClassInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvUnitClassInfo@@@std@@QAEXPAPAVCvUnitClassInfo@@I@Z ; std::allocator<CvUnitClassInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvUnitClassInfo@@@std@@QAEXPAPAVCvUnitClassInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvUnitClassInfo@@@std@@QAEXPAPAVCvUnitClassInfo@@I@Z PROC ; std::allocator<CvUnitClassInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvUnitClassInfo@@@std@@QAEXPAPAVCvUnitClassInfo@@I@Z ENDP ; std::allocator<CvUnitClassInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254788 = -80						; size = 28
$T254787 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254788[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254787[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254788[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254787[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254787[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254787[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254787[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@21:
$LN12@Xlen@21:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254788[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254787[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialUnitInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvSpecialUnitInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvSpecialUnitInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialUnitInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialUnitInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvSpecialUnitInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvSpecialUnitInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialUnitInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvSpecialUnitInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvSpecialUnitInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvSpecialUnitInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvSpecialUnitInfo *>::allocator<CvSpecialUnitInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvSpecialUnitInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvSpecialUnitInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvSpecialUnitInfo *>::allocator<CvSpecialUnitInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvSpecialUnitInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvSpecialUnitInfo *>::allocator<CvSpecialUnitInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvSpecialUnitInfo@@@std@@QAEXPAPAVCvSpecialUnitInfo@@I@Z ; std::allocator<CvSpecialUnitInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvSpecialUnitInfo@@@std@@QAEXPAPAVCvSpecialUnitInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvSpecialUnitInfo@@@std@@QAEXPAPAVCvSpecialUnitInfo@@I@Z PROC ; std::allocator<CvSpecialUnitInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvSpecialUnitInfo@@@std@@QAEXPAPAVCvSpecialUnitInfo@@I@Z ENDP ; std::allocator<CvSpecialUnitInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254822 = -80						; size = 28
$T254821 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254822[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254821[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254822[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254821[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254821[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254821[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254821[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@22:
$LN12@Xlen@22:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254822[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254821[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteSourceInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvVoteSourceInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvVoteSourceInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteSourceInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteSourceInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvVoteSourceInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvVoteSourceInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteSourceInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvVoteSourceInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvVoteSourceInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvVoteSourceInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvVoteSourceInfo *>::allocator<CvVoteSourceInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvVoteSourceInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvVoteSourceInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvVoteSourceInfo *>::allocator<CvVoteSourceInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvVoteSourceInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvVoteSourceInfo *>::allocator<CvVoteSourceInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvVoteSourceInfo@@@std@@QAEXPAPAVCvVoteSourceInfo@@I@Z ; std::allocator<CvVoteSourceInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvVoteSourceInfo@@@std@@QAEXPAPAVCvVoteSourceInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvVoteSourceInfo@@@std@@QAEXPAPAVCvVoteSourceInfo@@I@Z PROC ; std::allocator<CvVoteSourceInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvVoteSourceInfo@@@std@@QAEXPAPAVCvVoteSourceInfo@@I@Z ENDP ; std::allocator<CvVoteSourceInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254856 = -80						; size = 28
$T254855 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254856[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254855[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254856[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254855[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254855[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254855[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254855[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@23:
$LN12@Xlen@23:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254856[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254855[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBaseInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvBaseInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvBaseInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBaseInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBaseInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvBaseInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvBaseInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBaseInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvBaseInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvBaseInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvBaseInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvBaseInfo *>::allocator<CvBaseInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvBaseInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvBaseInfo@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvBaseInfo *>::allocator<CvBaseInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvBaseInfo@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvBaseInfo *>::allocator<CvBaseInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvBaseInfo@@@std@@QAEXPAPAVCvBaseInfo@@I@Z ; std::allocator<CvBaseInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvBaseInfo@@@std@@QAEXPAPAVCvBaseInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvBaseInfo@@@std@@QAEXPAPAVCvBaseInfo@@I@Z PROC ; std::allocator<CvBaseInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvBaseInfo@@@std@@QAEXPAPAVCvBaseInfo@@I@Z ENDP ; std::allocator<CvBaseInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254890 = -80						; size = 28
$T254889 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254890[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254889[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254890[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254889[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254889[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254889[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254889[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@24:
$LN12@Xlen@24:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254890[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254889[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameOptionInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvGameOptionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvGameOptionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameOptionInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameOptionInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvGameOptionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvGameOptionInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameOptionInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvGameOptionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvGameOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvGameOptionInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvGameOptionInfo *>::allocator<CvGameOptionInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvGameOptionInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvGameOptionInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvGameOptionInfo *>::allocator<CvGameOptionInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvGameOptionInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvGameOptionInfo *>::allocator<CvGameOptionInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvGameOptionInfo@@@std@@QAEXPAPAVCvGameOptionInfo@@I@Z ; std::allocator<CvGameOptionInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvGameOptionInfo@@@std@@QAEXPAPAVCvGameOptionInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvGameOptionInfo@@@std@@QAEXPAPAVCvGameOptionInfo@@I@Z PROC ; std::allocator<CvGameOptionInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvGameOptionInfo@@@std@@QAEXPAPAVCvGameOptionInfo@@I@Z ENDP ; std::allocator<CvGameOptionInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254924 = -80						; size = 28
$T254923 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254924[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254923[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254924[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254923[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254923[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254923[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254923[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@25:
$LN12@Xlen@25:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254924[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254923[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMPOptionInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvMPOptionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvMPOptionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMPOptionInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMPOptionInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvMPOptionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvMPOptionInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMPOptionInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvMPOptionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvMPOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvMPOptionInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvMPOptionInfo *>::allocator<CvMPOptionInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvMPOptionInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvMPOptionInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvMPOptionInfo *>::allocator<CvMPOptionInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvMPOptionInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvMPOptionInfo *>::allocator<CvMPOptionInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvMPOptionInfo@@@std@@QAEXPAPAVCvMPOptionInfo@@I@Z ; std::allocator<CvMPOptionInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvMPOptionInfo@@@std@@QAEXPAPAVCvMPOptionInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvMPOptionInfo@@@std@@QAEXPAPAVCvMPOptionInfo@@I@Z PROC ; std::allocator<CvMPOptionInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvMPOptionInfo@@@std@@QAEXPAPAVCvMPOptionInfo@@I@Z ENDP ; std::allocator<CvMPOptionInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254958 = -80						; size = 28
$T254957 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254958[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254957[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254958[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254957[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254957[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254957[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254957[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@26:
$LN12@Xlen@26:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254958[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254957[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerOptionInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerOptionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlayerOptionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerOptionInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerOptionInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerOptionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlayerOptionInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerOptionInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlayerOptionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlayerOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPlayerOptionInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvPlayerOptionInfo *>::allocator<CvPlayerOptionInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPlayerOptionInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvPlayerOptionInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvPlayerOptionInfo *>::allocator<CvPlayerOptionInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvPlayerOptionInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvPlayerOptionInfo *>::allocator<CvPlayerOptionInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvPlayerOptionInfo@@@std@@QAEXPAPAVCvPlayerOptionInfo@@I@Z ; std::allocator<CvPlayerOptionInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvPlayerOptionInfo@@@std@@QAEXPAPAVCvPlayerOptionInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvPlayerOptionInfo@@@std@@QAEXPAPAVCvPlayerOptionInfo@@I@Z PROC ; std::allocator<CvPlayerOptionInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvPlayerOptionInfo@@@std@@QAEXPAPAVCvPlayerOptionInfo@@I@Z ENDP ; std::allocator<CvPlayerOptionInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254992 = -80						; size = 28
$T254991 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254992[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254991[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254992[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T254991[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T254991[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254991[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T254991[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@27:
$LN12@Xlen@27:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254992[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254991[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialistInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvSpecialistInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvSpecialistInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialistInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialistInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvSpecialistInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvSpecialistInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialistInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvSpecialistInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvSpecialistInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvSpecialistInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvSpecialistInfo *>::allocator<CvSpecialistInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvSpecialistInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvSpecialistInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvSpecialistInfo *>::allocator<CvSpecialistInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvSpecialistInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvSpecialistInfo *>::allocator<CvSpecialistInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvSpecialistInfo@@@std@@QAEXPAPAVCvSpecialistInfo@@I@Z ; std::allocator<CvSpecialistInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvSpecialistInfo@@@std@@QAEXPAPAVCvSpecialistInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvSpecialistInfo@@@std@@QAEXPAPAVCvSpecialistInfo@@I@Z PROC ; std::allocator<CvSpecialistInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvSpecialistInfo@@@std@@QAEXPAPAVCvSpecialistInfo@@I@Z ENDP ; std::allocator<CvSpecialistInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T255026 = -80						; size = 28
$T255025 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255026[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T255025[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T255026[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255025[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T255025[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255025[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T255025[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@28:
$LN12@Xlen@28:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255026[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255025[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvActionInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvActionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvActionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvActionInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvActionInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvActionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvActionInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvActionInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvActionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvActionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvActionInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvActionInfo *>::allocator<CvActionInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvActionInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvActionInfo@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvActionInfo *>::allocator<CvActionInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvActionInfo@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvActionInfo *>::allocator<CvActionInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvActionInfo@@@std@@QAEXPAPAVCvActionInfo@@I@Z ; std::allocator<CvActionInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvActionInfo@@@std@@QAEXPAPAVCvActionInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvActionInfo@@@std@@QAEXPAPAVCvActionInfo@@I@Z PROC ; std::allocator<CvActionInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvActionInfo@@@std@@QAEXPAPAVCvActionInfo@@I@Z ENDP ; std::allocator<CvActionInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T255060 = -80						; size = 28
$T255059 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255060[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T255059[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T255060[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255059[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T255059[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255059[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T255059[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@29:
$LN12@Xlen@29:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255060[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255059[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMissionInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvMissionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvMissionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMissionInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMissionInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvMissionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvMissionInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMissionInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvMissionInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvMissionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvMissionInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvMissionInfo *>::allocator<CvMissionInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvMissionInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvMissionInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvMissionInfo *>::allocator<CvMissionInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvMissionInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvMissionInfo *>::allocator<CvMissionInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvMissionInfo@@@std@@QAEXPAPAVCvMissionInfo@@I@Z ; std::allocator<CvMissionInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvMissionInfo@@@std@@QAEXPAPAVCvMissionInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvMissionInfo@@@std@@QAEXPAPAVCvMissionInfo@@I@Z PROC ; std::allocator<CvMissionInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvMissionInfo@@@std@@QAEXPAPAVCvMissionInfo@@I@Z ENDP ; std::allocator<CvMissionInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T255094 = -80						; size = 28
$T255093 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255094[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T255093[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T255094[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255093[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T255093[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255093[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T255093[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@30:
$LN12@Xlen@30:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255094[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255093[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE@V?$allocator@PAVCvControlInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvControlInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvControlInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE@V?$allocator@PAVCvControlInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE@V?$allocator@PAVCvControlInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvControlInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvControlInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE@V?$allocator@PAVCvControlInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvControlInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvControlInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvControlInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvControlInfo *>::allocator<CvControlInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvControlInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvControlInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvControlInfo *>::allocator<CvControlInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvControlInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvControlInfo *>::allocator<CvControlInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvControlInfo@@@std@@QAEXPAPAVCvControlInfo@@I@Z ; std::allocator<CvControlInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvControlInfo@@@std@@QAEXPAPAVCvControlInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvControlInfo@@@std@@QAEXPAPAVCvControlInfo@@I@Z PROC ; std::allocator<CvControlInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvControlInfo@@@std@@QAEXPAPAVCvControlInfo@@I@Z ENDP ; std::allocator<CvControlInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T255128 = -80						; size = 28
$T255127 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255128[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T255127[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T255128[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255127[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T255127[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255127[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T255127[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@31:
$LN12@Xlen@31:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255128[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255127[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCommandInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvCommandInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvCommandInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCommandInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCommandInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCommandInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvCommandInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCommandInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCommandInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvCommandInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCommandInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvCommandInfo *>::allocator<CvCommandInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvCommandInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvCommandInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvCommandInfo *>::allocator<CvCommandInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvCommandInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvCommandInfo *>::allocator<CvCommandInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvCommandInfo@@@std@@QAEXPAPAVCvCommandInfo@@I@Z ; std::allocator<CvCommandInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvCommandInfo@@@std@@QAEXPAPAVCvCommandInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvCommandInfo@@@std@@QAEXPAPAVCvCommandInfo@@I@Z PROC ; std::allocator<CvCommandInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvCommandInfo@@@std@@QAEXPAPAVCvCommandInfo@@I@Z ENDP ; std::allocator<CvCommandInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T255162 = -80						; size = 28
$T255161 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255162[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T255161[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T255162[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255161[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T255161[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255161[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T255161[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@32:
$LN12@Xlen@32:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255162[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255161[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE@V?$allocator@PAVCvAutomateInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvAutomateInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvAutomateInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE@V?$allocator@PAVCvAutomateInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE@V?$allocator@PAVCvAutomateInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvAutomateInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvAutomateInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE@V?$allocator@PAVCvAutomateInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvAutomateInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvAutomateInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvAutomateInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvAutomateInfo *>::allocator<CvAutomateInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvAutomateInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvAutomateInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvAutomateInfo *>::allocator<CvAutomateInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvAutomateInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvAutomateInfo *>::allocator<CvAutomateInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvAutomateInfo@@@std@@QAEXPAPAVCvAutomateInfo@@I@Z ; std::allocator<CvAutomateInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvAutomateInfo@@@std@@QAEXPAPAVCvAutomateInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvAutomateInfo@@@std@@QAEXPAPAVCvAutomateInfo@@I@Z PROC ; std::allocator<CvAutomateInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvAutomateInfo@@@std@@QAEXPAPAVCvAutomateInfo@@I@Z ENDP ; std::allocator<CvAutomateInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T255196 = -80						; size = 28
$T255195 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255196[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T255195[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T255196[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255195[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T255195[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255195[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T255195[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@33:
$LN12@Xlen@33:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255196[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255195[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEraInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvEraInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvEraInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEraInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEraInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvEraInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvEraInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEraInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvEraInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvEraInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvEraInfo@@@std@@QAE@ABV01@@Z	; std::allocator<CvEraInfo *>::allocator<CvEraInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvEraInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvEraInfo@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvEraInfo *>::allocator<CvEraInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvEraInfo@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvEraInfo *>::allocator<CvEraInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvEraInfo@@@std@@QAEXPAPAVCvEraInfo@@I@Z ; std::allocator<CvEraInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvEraInfo@@@std@@QAEXPAPAVCvEraInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvEraInfo@@@std@@QAEXPAPAVCvEraInfo@@I@Z PROC ; std::allocator<CvEraInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvEraInfo@@@std@@QAEXPAPAVCvEraInfo@@I@Z ENDP ; std::allocator<CvEraInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T255230 = -80						; size = 28
$T255229 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255230[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T255229[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T255230[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255229[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T255229[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255229[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T255229[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@34:
$LN12@Xlen@34:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255230[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255229[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHurryInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvHurryInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvHurryInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHurryInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHurryInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvHurryInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvHurryInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHurryInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvHurryInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvHurryInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvHurryInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvHurryInfo *>::allocator<CvHurryInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvHurryInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvHurryInfo@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvHurryInfo *>::allocator<CvHurryInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvHurryInfo@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvHurryInfo *>::allocator<CvHurryInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvHurryInfo@@@std@@QAEXPAPAVCvHurryInfo@@I@Z ; std::allocator<CvHurryInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvHurryInfo@@@std@@QAEXPAPAVCvHurryInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvHurryInfo@@@std@@QAEXPAPAVCvHurryInfo@@I@Z PROC ; std::allocator<CvHurryInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvHurryInfo@@@std@@QAEXPAPAVCvHurryInfo@@I@Z ENDP ; std::allocator<CvHurryInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T255264 = -80						; size = 28
$T255263 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255264[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T255263[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T255264[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255263[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T255263[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255263[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T255263[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@35:
$LN12@Xlen@35:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255264[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255263[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVictoryInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvVictoryInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvVictoryInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVictoryInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVictoryInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvVictoryInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvVictoryInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVictoryInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvVictoryInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvVictoryInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvVictoryInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvVictoryInfo *>::allocator<CvVictoryInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvVictoryInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvVictoryInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvVictoryInfo *>::allocator<CvVictoryInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvVictoryInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvVictoryInfo *>::allocator<CvVictoryInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvVictoryInfo@@@std@@QAEXPAPAVCvVictoryInfo@@I@Z ; std::allocator<CvVictoryInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvVictoryInfo@@@std@@QAEXPAPAVCvVictoryInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvVictoryInfo@@@std@@QAEXPAPAVCvVictoryInfo@@I@Z PROC ; std::allocator<CvVictoryInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvVictoryInfo@@@std@@QAEXPAPAVCvVictoryInfo@@I@Z ENDP ; std::allocator<CvVictoryInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T255298 = -80						; size = 28
$T255297 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255298[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T255297[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T255298[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255297[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T255297[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255297[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T255297[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@36:
$LN12@Xlen@36:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255298[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255297[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSmallAwardInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvSmallAwardInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvSmallAwardInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSmallAwardInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSmallAwardInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvSmallAwardInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvSmallAwardInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSmallAwardInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvSmallAwardInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvSmallAwardInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvSmallAwardInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvSmallAwardInfo *>::allocator<CvSmallAwardInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvSmallAwardInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvSmallAwardInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvSmallAwardInfo *>::allocator<CvSmallAwardInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvSmallAwardInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvSmallAwardInfo *>::allocator<CvSmallAwardInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvSmallAwardInfo@@@std@@QAEXPAPAVCvSmallAwardInfo@@I@Z ; std::allocator<CvSmallAwardInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvSmallAwardInfo@@@std@@QAEXPAPAVCvSmallAwardInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvSmallAwardInfo@@@std@@QAEXPAPAVCvSmallAwardInfo@@I@Z PROC ; std::allocator<CvSmallAwardInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvSmallAwardInfo@@@std@@QAEXPAPAVCvSmallAwardInfo@@I@Z ENDP ; std::allocator<CvSmallAwardInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T255332 = -80						; size = 28
$T255331 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255332[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T255331[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T255332[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255331[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T255331[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255331[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T255331[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@37:
$LN12@Xlen@37:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255332[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255331[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEntityEventInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvEntityEventInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvEntityEventInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEntityEventInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEntityEventInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvEntityEventInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvEntityEventInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEntityEventInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvEntityEventInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvEntityEventInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvEntityEventInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvEntityEventInfo *>::allocator<CvEntityEventInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvEntityEventInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvEntityEventInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvEntityEventInfo *>::allocator<CvEntityEventInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvEntityEventInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvEntityEventInfo *>::allocator<CvEntityEventInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvEntityEventInfo@@@std@@QAEXPAPAVCvEntityEventInfo@@I@Z ; std::allocator<CvEntityEventInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvEntityEventInfo@@@std@@QAEXPAPAVCvEntityEventInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvEntityEventInfo@@@std@@QAEXPAPAVCvEntityEventInfo@@I@Z PROC ; std::allocator<CvEntityEventInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvEntityEventInfo@@@std@@QAEXPAPAVCvEntityEventInfo@@I@Z ENDP ; std::allocator<CvEntityEventInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T255366 = -80						; size = 28
$T255365 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255366[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T255365[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T255366[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255365[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T255365[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255365[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T255365[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@38:
$LN12@Xlen@38:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255366[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255365[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMultiUnitFormationInfo@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvMultiUnitFormationInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvMultiUnitFormationInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMultiUnitFormationInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMultiUnitFormationInfo@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvMultiUnitFormationInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvMultiUnitFormationInfo *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMultiUnitFormationInfo@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvMultiUnitFormationInfo *> >::_Container_base_aux_alloc_empty<std::allocator<CvMultiUnitFormationInfo *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAE@ABV01@@Z ; std::allocator<CvMultiUnitFormationInfo *>::allocator<CvMultiUnitFormationInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvMultiUnitFormationInfo *>::allocator<CvMultiUnitFormationInfo *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvMultiUnitFormationInfo *>::allocator<CvMultiUnitFormationInfo *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAEXPAPAVCvMultiUnitFormationInfo@@I@Z ; std::allocator<CvMultiUnitFormationInfo *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAEXPAPAVCvMultiUnitFormationInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAEXPAPAVCvMultiUnitFormationInfo@@I@Z PROC ; std::allocator<CvMultiUnitFormationInfo *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAEXPAPAVCvMultiUnitFormationInfo@@I@Z ENDP ; std::allocator<CvMultiUnitFormationInfo *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@PAPAVCvCivilizationInfo@@@Z ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@PAPAVCvCivilizationInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@PAPAVCvCivilizationInfo@@@Z PROC ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@PAPAVCvCivilizationInfo@@@Z ENDP ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::_Const_iterator<0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::_Const_iterator<0>, COMDAT
; _this$ = ecx

; 163  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 164  : 			}

	ret	0
??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::_Const_iterator<0>
_TEXT	ENDS
PUBLIC	??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::_Const_iterator<0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::_Const_iterator<0>, COMDAT
; _this$ = ecx

; 184  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 185  : 			}

	ret	4
??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::_Const_iterator<0>
_TEXT	ENDS
PUBLIC	??E?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// preincrement

	mov	eax, ecx

; 236  : 
; 237  :  #if _HAS_ITERATOR_DEBUGGING
; 238  : 			if (this->_Mycont == 0
; 239  : 				|| _Ptr == 0
; 240  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 241  : 				{
; 242  : 				_DEBUG_ERROR("list iterator not incrementable");
; 243  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 244  : 				}
; 245  :  #else
; 246  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 247  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 248  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 249  : 
; 250  : 			_Ptr = _Nextnode(_Ptr);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 251  : 			return (*this);
; 252  : 			}

	ret	0
??E?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 217  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::_Iterator<0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??0?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::_Iterator<0>, COMDAT
; _this$ = ecx

; 348  : 		_Iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 349  : 			{	// construct with null node
; 350  : 			}

	ret	0
??0?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::_Iterator<0>
_TEXT	ENDS
PUBLIC	??E?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::operator++, COMDAT
; _this$ = ecx

; 403  : 			{	// preincrement

	mov	eax, ecx

; 404  : 			++(*(_Mybase_iter *)this);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 405  : 			return (*this);
; 406  : 			}

	ret	0
??E?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z PROC ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z ENDP ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::deallocate
_TEXT	ENDS
PUBLIC	?bucket_count@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEIXZ ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::bucket_count
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEIXZ
_TEXT	SEGMENT
?bucket_count@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEIXZ PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::bucket_count, COMDAT
; _this$ = ecx

; 451  : 		return (_Maxidx);

	mov	eax, DWORD PTR [ecx+36]

; 452  : 		}

	ret	0
?bucket_count@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEIXZ ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::bucket_count
_TEXT	ENDS
PUBLIC	?max_load_factor@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEMXZ ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::max_load_factor
; Function compile flags: /Ogtpy
;	COMDAT ?max_load_factor@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEMXZ
_TEXT	SEGMENT
?max_load_factor@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEMXZ PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::max_load_factor, COMDAT
; _this$ = ecx

; 513  : 		return (_Max_bucket_size);

	fld	DWORD PTR [ecx+40]

; 514  : 		}

	ret	0
?max_load_factor@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEMXZ ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::max_load_factor
_TEXT	ENDS
PUBLIC	??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
EXTRN	__imp_??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR __Left$[esp-4]
	push	eax
	push	ecx
	call	DWORD PTR __imp_??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
	add	esp, 8

; 144  : 		}

	ret	8
??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvInterfaceModeInfo@@@std@@QBEIXZ ; std::allocator<CvInterfaceModeInfo *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvInterfaceModeInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvInterfaceModeInfo@@@std@@QBEIXZ PROC ; std::allocator<CvInterfaceModeInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvInterfaceModeInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvInterfaceModeInfo *>::max_size
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 20					; 00000014H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvColorInfo@@@std@@QBEIXZ ; std::allocator<CvColorInfo *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvColorInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvColorInfo@@@std@@QBEIXZ PROC	; std::allocator<CvColorInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvColorInfo@@@std@@QBEIXZ ENDP	; std::allocator<CvColorInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvPlayerColorInfo@@@std@@QBEIXZ ; std::allocator<CvPlayerColorInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvPlayerColorInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvPlayerColorInfo@@@std@@QBEIXZ PROC ; std::allocator<CvPlayerColorInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvPlayerColorInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvPlayerColorInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvTerrainInfo@@@std@@QBEIXZ ; std::allocator<CvTerrainInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvTerrainInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvTerrainInfo@@@std@@QBEIXZ PROC ; std::allocator<CvTerrainInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvTerrainInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvTerrainInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvYieldInfo@@@std@@QBEIXZ ; std::allocator<CvYieldInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvYieldInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvYieldInfo@@@std@@QBEIXZ PROC	; std::allocator<CvYieldInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvYieldInfo@@@std@@QBEIXZ ENDP	; std::allocator<CvYieldInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvRouteInfo@@@std@@QBEIXZ ; std::allocator<CvRouteInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvRouteInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvRouteInfo@@@std@@QBEIXZ PROC	; std::allocator<CvRouteInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvRouteInfo@@@std@@QBEIXZ ENDP	; std::allocator<CvRouteInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvFeatureInfo@@@std@@QBEIXZ ; std::allocator<CvFeatureInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvFeatureInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvFeatureInfo@@@std@@QBEIXZ PROC ; std::allocator<CvFeatureInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvFeatureInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvFeatureInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvResourceClassInfo@@@std@@QBEIXZ ; std::allocator<CvResourceClassInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvResourceClassInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvResourceClassInfo@@@std@@QBEIXZ PROC ; std::allocator<CvResourceClassInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvResourceClassInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvResourceClassInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvResourceInfo@@@std@@QBEIXZ ; std::allocator<CvResourceInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvResourceInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvResourceInfo@@@std@@QBEIXZ PROC ; std::allocator<CvResourceInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvResourceInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvResourceInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvBuildInfo@@@std@@QBEIXZ ; std::allocator<CvBuildInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvBuildInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvBuildInfo@@@std@@QBEIXZ PROC	; std::allocator<CvBuildInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvBuildInfo@@@std@@QBEIXZ ENDP	; std::allocator<CvBuildInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvHandicapInfo@@@std@@QBEIXZ ; std::allocator<CvHandicapInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvHandicapInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvHandicapInfo@@@std@@QBEIXZ PROC ; std::allocator<CvHandicapInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvHandicapInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvHandicapInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvGameSpeedInfo@@@std@@QBEIXZ ; std::allocator<CvGameSpeedInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvGameSpeedInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvGameSpeedInfo@@@std@@QBEIXZ PROC ; std::allocator<CvGameSpeedInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvGameSpeedInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvGameSpeedInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvTurnTimerInfo@@@std@@QBEIXZ ; std::allocator<CvTurnTimerInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvTurnTimerInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvTurnTimerInfo@@@std@@QBEIXZ PROC ; std::allocator<CvTurnTimerInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvTurnTimerInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvTurnTimerInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvCivilizationInfo@@@std@@QBEIXZ ; std::allocator<CvCivilizationInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvCivilizationInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvCivilizationInfo@@@std@@QBEIXZ PROC ; std::allocator<CvCivilizationInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvCivilizationInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvCivilizationInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvMinorCivInfo@@@std@@QBEIXZ ; std::allocator<CvMinorCivInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvMinorCivInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvMinorCivInfo@@@std@@QBEIXZ PROC ; std::allocator<CvMinorCivInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvMinorCivInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvMinorCivInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvLeaderHeadInfo@@@std@@QBEIXZ ; std::allocator<CvLeaderHeadInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvLeaderHeadInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvLeaderHeadInfo@@@std@@QBEIXZ PROC ; std::allocator<CvLeaderHeadInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvLeaderHeadInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvLeaderHeadInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvProcessInfo@@@std@@QBEIXZ ; std::allocator<CvProcessInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvProcessInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvProcessInfo@@@std@@QBEIXZ PROC ; std::allocator<CvProcessInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvProcessInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvProcessInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvVoteInfo@@@std@@QBEIXZ ; std::allocator<CvVoteInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvVoteInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvVoteInfo@@@std@@QBEIXZ PROC	; std::allocator<CvVoteInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvVoteInfo@@@std@@QBEIXZ ENDP	; std::allocator<CvVoteInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvBuildingClassInfo@@@std@@QBEIXZ ; std::allocator<CvBuildingClassInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvBuildingClassInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvBuildingClassInfo@@@std@@QBEIXZ PROC ; std::allocator<CvBuildingClassInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvBuildingClassInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvBuildingClassInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvUnitClassInfo@@@std@@QBEIXZ ; std::allocator<CvUnitClassInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvUnitClassInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvUnitClassInfo@@@std@@QBEIXZ PROC ; std::allocator<CvUnitClassInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvUnitClassInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvUnitClassInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvSpecialUnitInfo@@@std@@QBEIXZ ; std::allocator<CvSpecialUnitInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvSpecialUnitInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvSpecialUnitInfo@@@std@@QBEIXZ PROC ; std::allocator<CvSpecialUnitInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvSpecialUnitInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvSpecialUnitInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvVoteSourceInfo@@@std@@QBEIXZ ; std::allocator<CvVoteSourceInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvVoteSourceInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvVoteSourceInfo@@@std@@QBEIXZ PROC ; std::allocator<CvVoteSourceInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvVoteSourceInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvVoteSourceInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvBaseInfo@@@std@@QBEIXZ ; std::allocator<CvBaseInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvBaseInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvBaseInfo@@@std@@QBEIXZ PROC	; std::allocator<CvBaseInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvBaseInfo@@@std@@QBEIXZ ENDP	; std::allocator<CvBaseInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvGameOptionInfo@@@std@@QBEIXZ ; std::allocator<CvGameOptionInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvGameOptionInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvGameOptionInfo@@@std@@QBEIXZ PROC ; std::allocator<CvGameOptionInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvGameOptionInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvGameOptionInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvMPOptionInfo@@@std@@QBEIXZ ; std::allocator<CvMPOptionInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvMPOptionInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvMPOptionInfo@@@std@@QBEIXZ PROC ; std::allocator<CvMPOptionInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvMPOptionInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvMPOptionInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvPlayerOptionInfo@@@std@@QBEIXZ ; std::allocator<CvPlayerOptionInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvPlayerOptionInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvPlayerOptionInfo@@@std@@QBEIXZ PROC ; std::allocator<CvPlayerOptionInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvPlayerOptionInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvPlayerOptionInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvSpecialistInfo@@@std@@QBEIXZ ; std::allocator<CvSpecialistInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvSpecialistInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvSpecialistInfo@@@std@@QBEIXZ PROC ; std::allocator<CvSpecialistInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvSpecialistInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvSpecialistInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvActionInfo@@@std@@QBEIXZ ; std::allocator<CvActionInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvActionInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvActionInfo@@@std@@QBEIXZ PROC ; std::allocator<CvActionInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvActionInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvActionInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvMissionInfo@@@std@@QBEIXZ ; std::allocator<CvMissionInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvMissionInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvMissionInfo@@@std@@QBEIXZ PROC ; std::allocator<CvMissionInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvMissionInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvMissionInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvControlInfo@@@std@@QBEIXZ ; std::allocator<CvControlInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvControlInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvControlInfo@@@std@@QBEIXZ PROC ; std::allocator<CvControlInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvControlInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvControlInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvCommandInfo@@@std@@QBEIXZ ; std::allocator<CvCommandInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvCommandInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvCommandInfo@@@std@@QBEIXZ PROC ; std::allocator<CvCommandInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvCommandInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvCommandInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvAutomateInfo@@@std@@QBEIXZ ; std::allocator<CvAutomateInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvAutomateInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvAutomateInfo@@@std@@QBEIXZ PROC ; std::allocator<CvAutomateInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvAutomateInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvAutomateInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvEraInfo@@@std@@QBEIXZ ; std::allocator<CvEraInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvEraInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvEraInfo@@@std@@QBEIXZ PROC	; std::allocator<CvEraInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvEraInfo@@@std@@QBEIXZ ENDP	; std::allocator<CvEraInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvHurryInfo@@@std@@QBEIXZ ; std::allocator<CvHurryInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvHurryInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvHurryInfo@@@std@@QBEIXZ PROC	; std::allocator<CvHurryInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvHurryInfo@@@std@@QBEIXZ ENDP	; std::allocator<CvHurryInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvVictoryInfo@@@std@@QBEIXZ ; std::allocator<CvVictoryInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvVictoryInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvVictoryInfo@@@std@@QBEIXZ PROC ; std::allocator<CvVictoryInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvVictoryInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvVictoryInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvSmallAwardInfo@@@std@@QBEIXZ ; std::allocator<CvSmallAwardInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvSmallAwardInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvSmallAwardInfo@@@std@@QBEIXZ PROC ; std::allocator<CvSmallAwardInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvSmallAwardInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvSmallAwardInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvEntityEventInfo@@@std@@QBEIXZ ; std::allocator<CvEntityEventInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvEntityEventInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvEntityEventInfo@@@std@@QBEIXZ PROC ; std::allocator<CvEntityEventInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvEntityEventInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvEntityEventInfo *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QBEIXZ ; std::allocator<CvMultiUnitFormationInfo *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QBEIXZ PROC ; std::allocator<CvMultiUnitFormationInfo *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QBEIXZ ENDP ; std::allocator<CvMultiUnitFormationInfo *>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::_Iterator<0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??0?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::_Iterator<0>, COMDAT
; _this$ = ecx

; 367  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 368  : 			}

	ret	4
??0?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::_Iterator<0>
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@QAE@ABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@AB_N@Z ; std::pair<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,bool>::pair<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@QAE@ABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@QAE@ABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@AB_N@Z PROC ; std::pair<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,bool>::pair<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@QAE@ABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@AB_N@Z ENDP ; std::pair<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,bool>::pair<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,bool>
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	?begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::begin, COMDAT
; _this$ = ecx

; 560  : 		return (iterator(_Nextnode(_Myhead)));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 561  : 		}

	ret	4
?begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::begin
_TEXT	ENDS
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Make_iter, COMDAT
; _this$ = ecx

; 580  : 		return (iterator(_Where._Ptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 581  : 		}

	ret	8
?_Make_iter@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ
_TEXT	SEGMENT
$T255705 = -80						; size = 28
$T255704 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255705[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T255704[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T255705[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T255704[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T255704[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255704[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T255704[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@39:
$LN12@Xlen@39:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255705[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255704[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Container_base_aux_alloc_empty<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Container_base_aux_alloc_empty<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Container_base_aux_alloc_empty<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QBEIXZ ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::max_size
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Max
	npad	3
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Min
	npad	4
$LL2@Min:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBIH@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,int> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBIH@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBIH@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int const ,int> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBIH@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int const ,int> >::max_size
_TEXT	ENDS
PUBLIC	??E?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV012@H@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??E?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV012@H@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator++, COMDAT
; _this$ = ecx

; 256  : 			_Myt_iter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 257  : 			++*this;

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 258  : 			return (_Tmp);
; 259  : 			}

	ret	8
??E?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV012@H@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??F?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??F?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator--, COMDAT
; _this$ = ecx

; 262  : 			{	// predecrement

	mov	eax, ecx

; 263  : 
; 264  :  #if _HAS_ITERATOR_DEBUGGING
; 265  : 			if (this->_Mycont == 0
; 266  : 				|| _Ptr == 0
; 267  : 				|| (_Ptr = _Prevnode(_Ptr))
; 268  : 					== ((_Myt *)this->_Mycont)->_Myhead)
; 269  : 				{
; 270  : 				_DEBUG_ERROR("list iterator not decrementable");
; 271  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 272  : 				}
; 273  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 274  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 275  : 			_Ptr = _Prevnode(_Ptr);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 276  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 277  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 278  : 
; 279  : 			return (*this);
; 280  : 			}

	ret	0
??F?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator--
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@3@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@3@XZ
_TEXT	SEGMENT
?_Mynode@?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@3@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::_Mynode, COMDAT
; _this$ = ecx

; 308  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 309  : 			}

	ret	0
?_Mynode@?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@3@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::_Mynode
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], dl
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEIXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::size, COMDAT
; _this$ = ecx

; 620  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 621  : 		}

	ret	0
?size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::size
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
PUBLIC	?capacity@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEIXZ ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEIXZ PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEIXZ ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEIXZ ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEIXZ PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEIXZ ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::size
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@@Z ; std::_Vector_const_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Vector_const_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@@Z PROC ; std::_Vector_const_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Vector_const_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@@Z ENDP ; std::_Vector_const_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Vector_const_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QBEIXZ ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 134217727				; 07ffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::max_size
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvMap@@@@YAXAAPAVCvMap@@@Z	; SAFE_DELETE<CvMap>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvMap@@@@YAXAAPAVCvMap@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvMap@@@@YAXAAPAVCvMap@@@Z PROC		; SAFE_DELETE<CvMap>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN5@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvMap@@@@YAXAAPAVCvMap@@@Z ENDP		; SAFE_DELETE<CvMap>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvRandom@@@@YAXAAPAVCvRandom@@@Z ; SAFE_DELETE<CvRandom>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvRandom@@@@YAXAAPAVCvRandom@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvRandom@@@@YAXAAPAVCvRandom@@@Z PROC	; SAFE_DELETE<CvRandom>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@2
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN5@SAFE_DELET@2:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvRandom@@@@YAXAAPAVCvRandom@@@Z ENDP	; SAFE_DELETE<CvRandom>
_TEXT	ENDS
PUBLIC	??$QueryInterface@VICvDLLDatabaseUtility1@@@ICvUnknown@@QAGPAVICvDLLDatabaseUtility1@@XZ ; ICvUnknown::QueryInterface<ICvDLLDatabaseUtility1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??$QueryInterface@VICvDLLDatabaseUtility1@@@ICvUnknown@@QAGPAVICvDLLDatabaseUtility1@@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??$QueryInterface@VICvDLLDatabaseUtility1@@@ICvUnknown@@QAGPAVICvDLLDatabaseUtility1@@XZ PROC ; ICvUnknown::QueryInterface<ICvDLLDatabaseUtility1>, COMDAT

; 322  :  		return static_cast<T*>(QueryInterface(T::GetInterfaceId()));

	mov	ecx, DWORD PTR _this$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR _guidICvDLLDatabaseUtility1
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR _guidICvDLLDatabaseUtility1+4
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR _guidICvDLLDatabaseUtility1+8
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR _guidICvDLLDatabaseUtility1+12
	mov	DWORD PTR [eax+12], esi
	mov	eax, DWORD PTR [edx]
	push	ecx
	call	eax

; 323  :  	}

	pop	esi
	ret	4
??$QueryInterface@VICvDLLDatabaseUtility1@@@ICvUnknown@@QAGPAVICvDLLDatabaseUtility1@@XZ ENDP ; ICvUnknown::QueryInterface<ICvDLLDatabaseUtility1>
_TEXT	ENDS
PUBLIC	??$sprintf_s@$0BA@@@YAHAAY0BA@DPBDZZ		; sprintf_s<16>
EXTRN	__imp__vsprintf_s:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0BA@@@YAHAAY0BA@DPBDZZ
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BA@@@YAHAAY0BA@DPBDZZ PROC		; sprintf_s<16>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	mov	ecx, DWORD PTR __Format$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	ecx
	push	16					; 00000010H
	push	edx
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	ret	0
??$sprintf_s@$0BA@@@YAHAAY0BA@DPBDZZ ENDP		; sprintf_s<16>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z PROC ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ENDP ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvInterfaceModeInfo@@@std@@YAPAPAVCvInterfaceModeInfo@@IPAPAV1@@Z ; std::_Allocate<CvInterfaceModeInfo *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvInterfaceModeInfo@@@std@@YAPAPAVCvInterfaceModeInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255855 = -12						; size = 12
$T255859 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvInterfaceModeInfo@@@std@@YAPAPAVCvInterfaceModeInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvInterfaceModeInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255859[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255855[esp+16]
	mov	DWORD PTR $T255859[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255855[esp+16]
	push	ecx
	mov	DWORD PTR $T255855[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvInterfaceModeInfo@@@std@@YAPAPAVCvInterfaceModeInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvInterfaceModeInfo *>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvColorInfo@@@std@@YAPAPAVCvColorInfo@@IPAPAV1@@Z ; std::_Allocate<CvColorInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvColorInfo@@@std@@YAPAPAVCvColorInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255871 = -12						; size = 12
$T255875 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvColorInfo@@@std@@YAPAPAVCvColorInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvColorInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255875[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255871[esp+16]
	mov	DWORD PTR $T255875[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255871[esp+16]
	push	ecx
	mov	DWORD PTR $T255871[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@PAVCvColorInfo@@@std@@YAPAPAVCvColorInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvColorInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvPlayerColorInfo@@@std@@YAPAPAVCvPlayerColorInfo@@IPAPAV1@@Z ; std::_Allocate<CvPlayerColorInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvPlayerColorInfo@@@std@@YAPAPAVCvPlayerColorInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255881 = -12						; size = 12
$T255885 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvPlayerColorInfo@@@std@@YAPAPAVCvPlayerColorInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvPlayerColorInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255885[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255881[esp+16]
	mov	DWORD PTR $T255885[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255881[esp+16]
	push	ecx
	mov	DWORD PTR $T255881[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@PAVCvPlayerColorInfo@@@std@@YAPAPAVCvPlayerColorInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvPlayerColorInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvTerrainInfo@@@std@@YAPAPAVCvTerrainInfo@@IPAPAV1@@Z ; std::_Allocate<CvTerrainInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvTerrainInfo@@@std@@YAPAPAVCvTerrainInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255891 = -12						; size = 12
$T255895 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvTerrainInfo@@@std@@YAPAPAVCvTerrainInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvTerrainInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255895[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255891[esp+16]
	mov	DWORD PTR $T255895[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255891[esp+16]
	push	ecx
	mov	DWORD PTR $T255891[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@PAVCvTerrainInfo@@@std@@YAPAPAVCvTerrainInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvTerrainInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvYieldInfo@@@std@@YAPAPAVCvYieldInfo@@IPAPAV1@@Z ; std::_Allocate<CvYieldInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvYieldInfo@@@std@@YAPAPAVCvYieldInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255901 = -12						; size = 12
$T255905 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvYieldInfo@@@std@@YAPAPAVCvYieldInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvYieldInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255905[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255901[esp+16]
	mov	DWORD PTR $T255905[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255901[esp+16]
	push	ecx
	mov	DWORD PTR $T255901[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@5:
$LN8@Allocate@5:
	int	3
??$_Allocate@PAVCvYieldInfo@@@std@@YAPAPAVCvYieldInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvYieldInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvRouteInfo@@@std@@YAPAPAVCvRouteInfo@@IPAPAV1@@Z ; std::_Allocate<CvRouteInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvRouteInfo@@@std@@YAPAPAVCvRouteInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255911 = -12						; size = 12
$T255915 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvRouteInfo@@@std@@YAPAPAVCvRouteInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvRouteInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255915[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255911[esp+16]
	mov	DWORD PTR $T255915[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255911[esp+16]
	push	ecx
	mov	DWORD PTR $T255911[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@6:
$LN8@Allocate@6:
	int	3
??$_Allocate@PAVCvRouteInfo@@@std@@YAPAPAVCvRouteInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvRouteInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvFeatureInfo@@@std@@YAPAPAVCvFeatureInfo@@IPAPAV1@@Z ; std::_Allocate<CvFeatureInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvFeatureInfo@@@std@@YAPAPAVCvFeatureInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255921 = -12						; size = 12
$T255925 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvFeatureInfo@@@std@@YAPAPAVCvFeatureInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvFeatureInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@7

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@7:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255925[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255921[esp+16]
	mov	DWORD PTR $T255925[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255921[esp+16]
	push	ecx
	mov	DWORD PTR $T255921[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@7:
$LN8@Allocate@7:
	int	3
??$_Allocate@PAVCvFeatureInfo@@@std@@YAPAPAVCvFeatureInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvFeatureInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvResourceClassInfo@@@std@@YAPAPAVCvResourceClassInfo@@IPAPAV1@@Z ; std::_Allocate<CvResourceClassInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvResourceClassInfo@@@std@@YAPAPAVCvResourceClassInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255931 = -12						; size = 12
$T255935 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvResourceClassInfo@@@std@@YAPAPAVCvResourceClassInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvResourceClassInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@8

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@8:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255935[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255931[esp+16]
	mov	DWORD PTR $T255935[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255931[esp+16]
	push	ecx
	mov	DWORD PTR $T255931[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@8:
$LN8@Allocate@8:
	int	3
??$_Allocate@PAVCvResourceClassInfo@@@std@@YAPAPAVCvResourceClassInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvResourceClassInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvResourceInfo@@@std@@YAPAPAVCvResourceInfo@@IPAPAV1@@Z ; std::_Allocate<CvResourceInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvResourceInfo@@@std@@YAPAPAVCvResourceInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255941 = -12						; size = 12
$T255945 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvResourceInfo@@@std@@YAPAPAVCvResourceInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvResourceInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@9

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@9:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@9:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@9

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255945[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255941[esp+16]
	mov	DWORD PTR $T255945[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255941[esp+16]
	push	ecx
	mov	DWORD PTR $T255941[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@9:
$LN8@Allocate@9:
	int	3
??$_Allocate@PAVCvResourceInfo@@@std@@YAPAPAVCvResourceInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvResourceInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvBuildInfo@@@std@@YAPAPAVCvBuildInfo@@IPAPAV1@@Z ; std::_Allocate<CvBuildInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvBuildInfo@@@std@@YAPAPAVCvBuildInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255951 = -12						; size = 12
$T255955 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvBuildInfo@@@std@@YAPAPAVCvBuildInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvBuildInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@10

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@10:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@10:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@10

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255955[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255951[esp+16]
	mov	DWORD PTR $T255955[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255951[esp+16]
	push	ecx
	mov	DWORD PTR $T255951[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@10:
$LN8@Allocate@10:
	int	3
??$_Allocate@PAVCvBuildInfo@@@std@@YAPAPAVCvBuildInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvBuildInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvHandicapInfo@@@std@@YAPAPAVCvHandicapInfo@@IPAPAV1@@Z ; std::_Allocate<CvHandicapInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvHandicapInfo@@@std@@YAPAPAVCvHandicapInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255961 = -12						; size = 12
$T255965 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvHandicapInfo@@@std@@YAPAPAVCvHandicapInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvHandicapInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@11

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@11:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@11:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@11

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255965[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255961[esp+16]
	mov	DWORD PTR $T255965[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255961[esp+16]
	push	ecx
	mov	DWORD PTR $T255961[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@11:
$LN8@Allocate@11:
	int	3
??$_Allocate@PAVCvHandicapInfo@@@std@@YAPAPAVCvHandicapInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvHandicapInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvGameSpeedInfo@@@std@@YAPAPAVCvGameSpeedInfo@@IPAPAV1@@Z ; std::_Allocate<CvGameSpeedInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvGameSpeedInfo@@@std@@YAPAPAVCvGameSpeedInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255971 = -12						; size = 12
$T255975 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvGameSpeedInfo@@@std@@YAPAPAVCvGameSpeedInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvGameSpeedInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@12

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@12:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@12:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@12

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255975[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255971[esp+16]
	mov	DWORD PTR $T255975[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255971[esp+16]
	push	ecx
	mov	DWORD PTR $T255971[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@12:
$LN8@Allocate@12:
	int	3
??$_Allocate@PAVCvGameSpeedInfo@@@std@@YAPAPAVCvGameSpeedInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvGameSpeedInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvTurnTimerInfo@@@std@@YAPAPAVCvTurnTimerInfo@@IPAPAV1@@Z ; std::_Allocate<CvTurnTimerInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvTurnTimerInfo@@@std@@YAPAPAVCvTurnTimerInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255981 = -12						; size = 12
$T255985 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvTurnTimerInfo@@@std@@YAPAPAVCvTurnTimerInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvTurnTimerInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@13

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@13:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@13:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@13

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255985[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255981[esp+16]
	mov	DWORD PTR $T255985[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255981[esp+16]
	push	ecx
	mov	DWORD PTR $T255981[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@13:
$LN8@Allocate@13:
	int	3
??$_Allocate@PAVCvTurnTimerInfo@@@std@@YAPAPAVCvTurnTimerInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvTurnTimerInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvCivilizationInfo@@@std@@YAPAPAVCvCivilizationInfo@@IPAPAV1@@Z ; std::_Allocate<CvCivilizationInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvCivilizationInfo@@@std@@YAPAPAVCvCivilizationInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T255991 = -12						; size = 12
$T255995 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvCivilizationInfo@@@std@@YAPAPAVCvCivilizationInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvCivilizationInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@14

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@14:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@14:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@14

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T255995[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T255991[esp+16]
	mov	DWORD PTR $T255995[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255991[esp+16]
	push	ecx
	mov	DWORD PTR $T255991[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@14:
$LN8@Allocate@14:
	int	3
??$_Allocate@PAVCvCivilizationInfo@@@std@@YAPAPAVCvCivilizationInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvCivilizationInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvMinorCivInfo@@@std@@YAPAPAVCvMinorCivInfo@@IPAPAV1@@Z ; std::_Allocate<CvMinorCivInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvMinorCivInfo@@@std@@YAPAPAVCvMinorCivInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256001 = -12						; size = 12
$T256005 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvMinorCivInfo@@@std@@YAPAPAVCvMinorCivInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvMinorCivInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@15

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@15:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@15:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@15

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256005[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256001[esp+16]
	mov	DWORD PTR $T256005[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256001[esp+16]
	push	ecx
	mov	DWORD PTR $T256001[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@15:
$LN8@Allocate@15:
	int	3
??$_Allocate@PAVCvMinorCivInfo@@@std@@YAPAPAVCvMinorCivInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvMinorCivInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvLeaderHeadInfo@@@std@@YAPAPAVCvLeaderHeadInfo@@IPAPAV1@@Z ; std::_Allocate<CvLeaderHeadInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvLeaderHeadInfo@@@std@@YAPAPAVCvLeaderHeadInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256011 = -12						; size = 12
$T256015 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvLeaderHeadInfo@@@std@@YAPAPAVCvLeaderHeadInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvLeaderHeadInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@16

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@16:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@16:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@16

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256015[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256011[esp+16]
	mov	DWORD PTR $T256015[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256011[esp+16]
	push	ecx
	mov	DWORD PTR $T256011[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@16:
$LN8@Allocate@16:
	int	3
??$_Allocate@PAVCvLeaderHeadInfo@@@std@@YAPAPAVCvLeaderHeadInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvLeaderHeadInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvProcessInfo@@@std@@YAPAPAVCvProcessInfo@@IPAPAV1@@Z ; std::_Allocate<CvProcessInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvProcessInfo@@@std@@YAPAPAVCvProcessInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256021 = -12						; size = 12
$T256025 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvProcessInfo@@@std@@YAPAPAVCvProcessInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvProcessInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@17

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@17:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@17:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@17

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256025[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256021[esp+16]
	mov	DWORD PTR $T256025[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256021[esp+16]
	push	ecx
	mov	DWORD PTR $T256021[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@17:
$LN8@Allocate@17:
	int	3
??$_Allocate@PAVCvProcessInfo@@@std@@YAPAPAVCvProcessInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvProcessInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvVoteInfo@@@std@@YAPAPAVCvVoteInfo@@IPAPAV1@@Z ; std::_Allocate<CvVoteInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvVoteInfo@@@std@@YAPAPAVCvVoteInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256031 = -12						; size = 12
$T256035 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvVoteInfo@@@std@@YAPAPAVCvVoteInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvVoteInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@18

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@18:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@18:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@18

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256035[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256031[esp+16]
	mov	DWORD PTR $T256035[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256031[esp+16]
	push	ecx
	mov	DWORD PTR $T256031[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@18:
$LN8@Allocate@18:
	int	3
??$_Allocate@PAVCvVoteInfo@@@std@@YAPAPAVCvVoteInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvVoteInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvBuildingClassInfo@@@std@@YAPAPAVCvBuildingClassInfo@@IPAPAV1@@Z ; std::_Allocate<CvBuildingClassInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvBuildingClassInfo@@@std@@YAPAPAVCvBuildingClassInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256041 = -12						; size = 12
$T256045 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvBuildingClassInfo@@@std@@YAPAPAVCvBuildingClassInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvBuildingClassInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@19

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@19:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@19:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@19

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256045[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256041[esp+16]
	mov	DWORD PTR $T256045[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256041[esp+16]
	push	ecx
	mov	DWORD PTR $T256041[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@19:
$LN8@Allocate@19:
	int	3
??$_Allocate@PAVCvBuildingClassInfo@@@std@@YAPAPAVCvBuildingClassInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvBuildingClassInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvUnitClassInfo@@@std@@YAPAPAVCvUnitClassInfo@@IPAPAV1@@Z ; std::_Allocate<CvUnitClassInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvUnitClassInfo@@@std@@YAPAPAVCvUnitClassInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256051 = -12						; size = 12
$T256055 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvUnitClassInfo@@@std@@YAPAPAVCvUnitClassInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvUnitClassInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@20

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@20:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@20:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@20

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256055[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256051[esp+16]
	mov	DWORD PTR $T256055[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256051[esp+16]
	push	ecx
	mov	DWORD PTR $T256051[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@20:
$LN8@Allocate@20:
	int	3
??$_Allocate@PAVCvUnitClassInfo@@@std@@YAPAPAVCvUnitClassInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvUnitClassInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvSpecialUnitInfo@@@std@@YAPAPAVCvSpecialUnitInfo@@IPAPAV1@@Z ; std::_Allocate<CvSpecialUnitInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvSpecialUnitInfo@@@std@@YAPAPAVCvSpecialUnitInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256061 = -12						; size = 12
$T256065 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvSpecialUnitInfo@@@std@@YAPAPAVCvSpecialUnitInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvSpecialUnitInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@21

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@21:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@21:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@21

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256065[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256061[esp+16]
	mov	DWORD PTR $T256065[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256061[esp+16]
	push	ecx
	mov	DWORD PTR $T256061[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@21:
$LN8@Allocate@21:
	int	3
??$_Allocate@PAVCvSpecialUnitInfo@@@std@@YAPAPAVCvSpecialUnitInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvSpecialUnitInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvVoteSourceInfo@@@std@@YAPAPAVCvVoteSourceInfo@@IPAPAV1@@Z ; std::_Allocate<CvVoteSourceInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvVoteSourceInfo@@@std@@YAPAPAVCvVoteSourceInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256071 = -12						; size = 12
$T256075 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvVoteSourceInfo@@@std@@YAPAPAVCvVoteSourceInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvVoteSourceInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@22

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@22:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@22:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@22

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256075[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256071[esp+16]
	mov	DWORD PTR $T256075[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256071[esp+16]
	push	ecx
	mov	DWORD PTR $T256071[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@22:
$LN8@Allocate@22:
	int	3
??$_Allocate@PAVCvVoteSourceInfo@@@std@@YAPAPAVCvVoteSourceInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvVoteSourceInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvBaseInfo@@@std@@YAPAPAVCvBaseInfo@@IPAPAV1@@Z ; std::_Allocate<CvBaseInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvBaseInfo@@@std@@YAPAPAVCvBaseInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256081 = -12						; size = 12
$T256085 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvBaseInfo@@@std@@YAPAPAVCvBaseInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvBaseInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@23

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@23:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@23:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@23

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256085[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256081[esp+16]
	mov	DWORD PTR $T256085[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256081[esp+16]
	push	ecx
	mov	DWORD PTR $T256081[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@23:
$LN8@Allocate@23:
	int	3
??$_Allocate@PAVCvBaseInfo@@@std@@YAPAPAVCvBaseInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvBaseInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvGameOptionInfo@@@std@@YAPAPAVCvGameOptionInfo@@IPAPAV1@@Z ; std::_Allocate<CvGameOptionInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvGameOptionInfo@@@std@@YAPAPAVCvGameOptionInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256091 = -12						; size = 12
$T256095 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvGameOptionInfo@@@std@@YAPAPAVCvGameOptionInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvGameOptionInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@24

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@24:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@24:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@24

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256095[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256091[esp+16]
	mov	DWORD PTR $T256095[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256091[esp+16]
	push	ecx
	mov	DWORD PTR $T256091[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@24:
$LN8@Allocate@24:
	int	3
??$_Allocate@PAVCvGameOptionInfo@@@std@@YAPAPAVCvGameOptionInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvGameOptionInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvMPOptionInfo@@@std@@YAPAPAVCvMPOptionInfo@@IPAPAV1@@Z ; std::_Allocate<CvMPOptionInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvMPOptionInfo@@@std@@YAPAPAVCvMPOptionInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256101 = -12						; size = 12
$T256105 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvMPOptionInfo@@@std@@YAPAPAVCvMPOptionInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvMPOptionInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@25

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@25:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@25:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@25

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256105[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256101[esp+16]
	mov	DWORD PTR $T256105[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256101[esp+16]
	push	ecx
	mov	DWORD PTR $T256101[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@25:
$LN8@Allocate@25:
	int	3
??$_Allocate@PAVCvMPOptionInfo@@@std@@YAPAPAVCvMPOptionInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvMPOptionInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvPlayerOptionInfo@@@std@@YAPAPAVCvPlayerOptionInfo@@IPAPAV1@@Z ; std::_Allocate<CvPlayerOptionInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvPlayerOptionInfo@@@std@@YAPAPAVCvPlayerOptionInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256111 = -12						; size = 12
$T256115 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvPlayerOptionInfo@@@std@@YAPAPAVCvPlayerOptionInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvPlayerOptionInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@26

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@26:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@26:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@26

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256115[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256111[esp+16]
	mov	DWORD PTR $T256115[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256111[esp+16]
	push	ecx
	mov	DWORD PTR $T256111[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@26:
$LN8@Allocate@26:
	int	3
??$_Allocate@PAVCvPlayerOptionInfo@@@std@@YAPAPAVCvPlayerOptionInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvPlayerOptionInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvSpecialistInfo@@@std@@YAPAPAVCvSpecialistInfo@@IPAPAV1@@Z ; std::_Allocate<CvSpecialistInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvSpecialistInfo@@@std@@YAPAPAVCvSpecialistInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256121 = -12						; size = 12
$T256125 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvSpecialistInfo@@@std@@YAPAPAVCvSpecialistInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvSpecialistInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@27

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@27:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@27:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@27

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256125[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256121[esp+16]
	mov	DWORD PTR $T256125[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256121[esp+16]
	push	ecx
	mov	DWORD PTR $T256121[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@27:
$LN8@Allocate@27:
	int	3
??$_Allocate@PAVCvSpecialistInfo@@@std@@YAPAPAVCvSpecialistInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvSpecialistInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvActionInfo@@@std@@YAPAPAVCvActionInfo@@IPAPAV1@@Z ; std::_Allocate<CvActionInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvActionInfo@@@std@@YAPAPAVCvActionInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256131 = -12						; size = 12
$T256135 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvActionInfo@@@std@@YAPAPAVCvActionInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvActionInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@28

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@28:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@28:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@28

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256135[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256131[esp+16]
	mov	DWORD PTR $T256135[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256131[esp+16]
	push	ecx
	mov	DWORD PTR $T256131[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@28:
$LN8@Allocate@28:
	int	3
??$_Allocate@PAVCvActionInfo@@@std@@YAPAPAVCvActionInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvActionInfo *>
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvMissionInfo@@@std@@YAPAPAVCvMissionInfo@@IPAPAV1@@Z ; std::_Allocate<CvMissionInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@PAVCvMissionInfo@@@std@@YAPAPAVCvMissionInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256144 = -12						; size = 12
$T256148 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvMissionInfo@@@std@@YAPAPAVCvMissionInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvMissionInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@29

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@29:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@29:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@29

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256148[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256144[esp+16]
	mov	DWORD PTR $T256148[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256144[esp+16]
	push	ecx
	mov	DWORD PTR $T256144[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@29:
$LN8@Allocate@29:
	int	3
??$_Allocate@PAVCvMissionInfo@@@std@@YAPAPAVCvMissionInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvMissionInfo *>
_TEXT	ENDS
PUBLIC	?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ; CvGlobals::GetGameDatabase
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ
_TEXT	SEGMENT
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ PROC ; CvGlobals::GetGameDatabase, COMDAT
; _this$ = ecx

; 9745 : 	return m_pGameDatabase;

	mov	eax, DWORD PTR [ecx+912]

; 9746 : }

	ret	0
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ENDP ; CvGlobals::GetGameDatabase
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvControlInfo@@@std@@YAPAPAVCvControlInfo@@IPAPAV1@@Z ; std::_Allocate<CvControlInfo *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@PAVCvControlInfo@@@std@@YAPAPAVCvControlInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256157 = -12						; size = 12
$T256161 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvControlInfo@@@std@@YAPAPAVCvControlInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvControlInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@30

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@30:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@30:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@30

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256161[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256157[esp+16]
	mov	DWORD PTR $T256161[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256157[esp+16]
	push	ecx
	mov	DWORD PTR $T256157[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@30:
$LN8@Allocate@30:
	int	3
??$_Allocate@PAVCvControlInfo@@@std@@YAPAPAVCvControlInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvControlInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvCommandInfo@@@std@@YAPAPAVCvCommandInfo@@IPAPAV1@@Z ; std::_Allocate<CvCommandInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvCommandInfo@@@std@@YAPAPAVCvCommandInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256167 = -12						; size = 12
$T256171 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvCommandInfo@@@std@@YAPAPAVCvCommandInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvCommandInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@31

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@31:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@31:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@31

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256171[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256167[esp+16]
	mov	DWORD PTR $T256171[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256167[esp+16]
	push	ecx
	mov	DWORD PTR $T256167[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@31:
$LN8@Allocate@31:
	int	3
??$_Allocate@PAVCvCommandInfo@@@std@@YAPAPAVCvCommandInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvCommandInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvAutomateInfo@@@std@@YAPAPAVCvAutomateInfo@@IPAPAV1@@Z ; std::_Allocate<CvAutomateInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvAutomateInfo@@@std@@YAPAPAVCvAutomateInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256177 = -12						; size = 12
$T256181 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvAutomateInfo@@@std@@YAPAPAVCvAutomateInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvAutomateInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@32

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@32:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@32:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@32

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256181[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256177[esp+16]
	mov	DWORD PTR $T256181[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256177[esp+16]
	push	ecx
	mov	DWORD PTR $T256177[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@32:
$LN8@Allocate@32:
	int	3
??$_Allocate@PAVCvAutomateInfo@@@std@@YAPAPAVCvAutomateInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvAutomateInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvEraInfo@@@std@@YAPAPAVCvEraInfo@@IPAPAV1@@Z ; std::_Allocate<CvEraInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvEraInfo@@@std@@YAPAPAVCvEraInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256187 = -12						; size = 12
$T256191 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvEraInfo@@@std@@YAPAPAVCvEraInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvEraInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@33

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@33:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@33:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@33

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256191[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256187[esp+16]
	mov	DWORD PTR $T256191[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256187[esp+16]
	push	ecx
	mov	DWORD PTR $T256187[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@33:
$LN8@Allocate@33:
	int	3
??$_Allocate@PAVCvEraInfo@@@std@@YAPAPAVCvEraInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvEraInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvHurryInfo@@@std@@YAPAPAVCvHurryInfo@@IPAPAV1@@Z ; std::_Allocate<CvHurryInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvHurryInfo@@@std@@YAPAPAVCvHurryInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256197 = -12						; size = 12
$T256201 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvHurryInfo@@@std@@YAPAPAVCvHurryInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvHurryInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@34

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@34:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@34:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@34

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256201[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256197[esp+16]
	mov	DWORD PTR $T256201[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256197[esp+16]
	push	ecx
	mov	DWORD PTR $T256197[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@34:
$LN8@Allocate@34:
	int	3
??$_Allocate@PAVCvHurryInfo@@@std@@YAPAPAVCvHurryInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvHurryInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvVictoryInfo@@@std@@YAPAPAVCvVictoryInfo@@IPAPAV1@@Z ; std::_Allocate<CvVictoryInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvVictoryInfo@@@std@@YAPAPAVCvVictoryInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256207 = -12						; size = 12
$T256211 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvVictoryInfo@@@std@@YAPAPAVCvVictoryInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvVictoryInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@35

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@35:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@35:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@35

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256211[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256207[esp+16]
	mov	DWORD PTR $T256211[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256207[esp+16]
	push	ecx
	mov	DWORD PTR $T256207[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@35:
$LN8@Allocate@35:
	int	3
??$_Allocate@PAVCvVictoryInfo@@@std@@YAPAPAVCvVictoryInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvVictoryInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvSmallAwardInfo@@@std@@YAPAPAVCvSmallAwardInfo@@IPAPAV1@@Z ; std::_Allocate<CvSmallAwardInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvSmallAwardInfo@@@std@@YAPAPAVCvSmallAwardInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256217 = -12						; size = 12
$T256221 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvSmallAwardInfo@@@std@@YAPAPAVCvSmallAwardInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvSmallAwardInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@36

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@36:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@36:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@36

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256221[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256217[esp+16]
	mov	DWORD PTR $T256221[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256217[esp+16]
	push	ecx
	mov	DWORD PTR $T256217[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@36:
$LN8@Allocate@36:
	int	3
??$_Allocate@PAVCvSmallAwardInfo@@@std@@YAPAPAVCvSmallAwardInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvSmallAwardInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvEntityEventInfo@@@std@@YAPAPAVCvEntityEventInfo@@IPAPAV1@@Z ; std::_Allocate<CvEntityEventInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvEntityEventInfo@@@std@@YAPAPAVCvEntityEventInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256227 = -12						; size = 12
$T256231 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvEntityEventInfo@@@std@@YAPAPAVCvEntityEventInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvEntityEventInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@37

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@37:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@37:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@37

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256231[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256227[esp+16]
	mov	DWORD PTR $T256231[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256227[esp+16]
	push	ecx
	mov	DWORD PTR $T256227[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@37:
$LN8@Allocate@37:
	int	3
??$_Allocate@PAVCvEntityEventInfo@@@std@@YAPAPAVCvEntityEventInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvEntityEventInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvMultiUnitFormationInfo@@@std@@YAPAPAVCvMultiUnitFormationInfo@@IPAPAV1@@Z ; std::_Allocate<CvMultiUnitFormationInfo *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvMultiUnitFormationInfo@@@std@@YAPAPAVCvMultiUnitFormationInfo@@IPAPAV1@@Z
_TEXT	SEGMENT
$T256237 = -12						; size = 12
$T256241 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvMultiUnitFormationInfo@@@std@@YAPAPAVCvMultiUnitFormationInfo@@IPAPAV1@@Z PROC ; std::_Allocate<CvMultiUnitFormationInfo *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@38

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@38:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@38:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@38

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256241[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256237[esp+16]
	mov	DWORD PTR $T256241[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256237[esp+16]
	push	ecx
	mov	DWORD PTR $T256237[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@38:
$LN8@Allocate@38:
	int	3
??$_Allocate@PAVCvMultiUnitFormationInfo@@@std@@YAPAPAVCvMultiUnitFormationInfo@@IPAPAV1@@Z ENDP ; std::_Allocate<CvMultiUnitFormationInfo *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z ; std::_Destroy<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z PROC ; std::_Destroy<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z ENDP ; std::_Destroy<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *><std::pair<unsigned int const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *><std::pair<unsigned int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *><std::pair<unsigned int const ,int> >
_TEXT	ENDS
PUBLIC	??$?8U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@0@0@Z ; std::operator==<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?8U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@0@0@Z PROC ; std::operator==<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >, COMDAT

; 175  : 	return (true);

	mov	al, 1

; 176  : 	}

	ret	0
??$?8U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@0@0@Z ENDP ; std::operator==<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z PROC ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ENDP ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IPAU120@@Z
_TEXT	SEGMENT
$T256259 = -12						; size = 12
$T256263 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@39

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@39:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*4]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@39:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 40					; 00000028H
	jae	SHORT $LN1@Allocate@39

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256263[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256259[esp+16]
	mov	DWORD PTR $T256263[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256259[esp+16]
	push	ecx
	mov	DWORD PTR $T256259[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@39:
$LN8@Allocate@39:
	int	3
??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *,std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@ABQAU120@@Z PROC ; std::_Construct<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *,std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *,std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IPAV120@@Z ; std::_Allocate<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IPAV120@@Z
_TEXT	SEGMENT
$T256278 = -12						; size = 12
$T256282 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IPAV120@@Z PROC ; std::_Allocate<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@40

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@40:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@40:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@40

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256282[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256278[esp+16]
	mov	DWORD PTR $T256282[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256278[esp+16]
	push	ecx
	mov	DWORD PTR $T256278[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@40:
$LN8@Allocate@40:
	int	3
??$_Allocate@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IPAV120@@Z ENDP ; std::_Allocate<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node><std::pair<unsigned int const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node><std::pair<unsigned int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node><std::pair<unsigned int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T256291 = -12						; size = 12
$T256295 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@41

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@41:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@41:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN1@Allocate@41

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T256295[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T256291[esp+16]
	mov	DWORD PTR $T256295[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T256291[esp+16]
	push	ecx
	mov	DWORD PTR $T256291[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@41:
$LN8@Allocate@41:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z PROC ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ENDP ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
_TEXT	ENDS
PUBLIC	??_GCvEconomicAIStrategyXMLEntries@@QAEPAXI@Z	; CvEconomicAIStrategyXMLEntries::`scalar deleting destructor'
EXTRN	??1CvEconomicAIStrategyXMLEntries@@QAE@XZ:PROC	; CvEconomicAIStrategyXMLEntries::~CvEconomicAIStrategyXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvEconomicAIStrategyXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvEconomicAIStrategyXMLEntries@@QAEPAXI@Z PROC	; CvEconomicAIStrategyXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvEconomicAIStrategyXMLEntries@@QAE@XZ ; CvEconomicAIStrategyXMLEntries::~CvEconomicAIStrategyXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvEconomicAIStrategyXMLEntries@@QAEPAXI@Z ENDP	; CvEconomicAIStrategyXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvCitySpecializationXMLEntries@@QAEPAXI@Z	; CvCitySpecializationXMLEntries::`scalar deleting destructor'
EXTRN	??1CvCitySpecializationXMLEntries@@QAE@XZ:PROC	; CvCitySpecializationXMLEntries::~CvCitySpecializationXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvCitySpecializationXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvCitySpecializationXMLEntries@@QAEPAXI@Z PROC	; CvCitySpecializationXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvCitySpecializationXMLEntries@@QAE@XZ ; CvCitySpecializationXMLEntries::~CvCitySpecializationXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvCitySpecializationXMLEntries@@QAEPAXI@Z ENDP	; CvCitySpecializationXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvTacticalMoveXMLEntries@@QAEPAXI@Z		; CvTacticalMoveXMLEntries::`scalar deleting destructor'
EXTRN	??1CvTacticalMoveXMLEntries@@QAE@XZ:PROC	; CvTacticalMoveXMLEntries::~CvTacticalMoveXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvTacticalMoveXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvTacticalMoveXMLEntries@@QAEPAXI@Z PROC		; CvTacticalMoveXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvTacticalMoveXMLEntries@@QAE@XZ	; CvTacticalMoveXMLEntries::~CvTacticalMoveXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@7:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvTacticalMoveXMLEntries@@QAEPAXI@Z ENDP		; CvTacticalMoveXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvMilitaryAIStrategyXMLEntries@@QAEPAXI@Z	; CvMilitaryAIStrategyXMLEntries::`scalar deleting destructor'
EXTRN	??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ:PROC	; CvMilitaryAIStrategyXMLEntries::~CvMilitaryAIStrategyXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvMilitaryAIStrategyXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvMilitaryAIStrategyXMLEntries@@QAEPAXI@Z PROC	; CvMilitaryAIStrategyXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ ; CvMilitaryAIStrategyXMLEntries::~CvMilitaryAIStrategyXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@8
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@8:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvMilitaryAIStrategyXMLEntries@@QAEPAXI@Z ENDP	; CvMilitaryAIStrategyXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvAIGrandStrategyXMLEntries@@QAEPAXI@Z	; CvAIGrandStrategyXMLEntries::`scalar deleting destructor'
EXTRN	??1CvAIGrandStrategyXMLEntries@@QAE@XZ:PROC	; CvAIGrandStrategyXMLEntries::~CvAIGrandStrategyXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvAIGrandStrategyXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIGrandStrategyXMLEntries@@QAEPAXI@Z PROC		; CvAIGrandStrategyXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvAIGrandStrategyXMLEntries@@QAE@XZ	; CvAIGrandStrategyXMLEntries::~CvAIGrandStrategyXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@9
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@9:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIGrandStrategyXMLEntries@@QAEPAXI@Z ENDP		; CvAIGrandStrategyXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvPolicyXMLEntries@@QAEPAXI@Z		; CvPolicyXMLEntries::`scalar deleting destructor'
EXTRN	??1CvPolicyXMLEntries@@QAE@XZ:PROC		; CvPolicyXMLEntries::~CvPolicyXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvPolicyXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvPolicyXMLEntries@@QAEPAXI@Z PROC			; CvPolicyXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvPolicyXMLEntries@@QAE@XZ		; CvPolicyXMLEntries::~CvPolicyXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@10
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@10:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvPolicyXMLEntries@@QAEPAXI@Z ENDP			; CvPolicyXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvBuildingXMLEntries@@QAEPAXI@Z		; CvBuildingXMLEntries::`scalar deleting destructor'
EXTRN	??1CvBuildingXMLEntries@@QAE@XZ:PROC		; CvBuildingXMLEntries::~CvBuildingXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvBuildingXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvBuildingXMLEntries@@QAEPAXI@Z PROC		; CvBuildingXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBuildingXMLEntries@@QAE@XZ		; CvBuildingXMLEntries::~CvBuildingXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@11
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@11:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvBuildingXMLEntries@@QAEPAXI@Z ENDP		; CvBuildingXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvUnitXMLEntries@@QAEPAXI@Z			; CvUnitXMLEntries::`scalar deleting destructor'
EXTRN	??1CvUnitXMLEntries@@QAE@XZ:PROC		; CvUnitXMLEntries::~CvUnitXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvUnitXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvUnitXMLEntries@@QAEPAXI@Z PROC			; CvUnitXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvUnitXMLEntries@@QAE@XZ		; CvUnitXMLEntries::~CvUnitXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@12
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@12:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvUnitXMLEntries@@QAEPAXI@Z ENDP			; CvUnitXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvProjectXMLEntries@@QAEPAXI@Z		; CvProjectXMLEntries::`scalar deleting destructor'
EXTRN	??1CvProjectXMLEntries@@QAE@XZ:PROC		; CvProjectXMLEntries::~CvProjectXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvProjectXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvProjectXMLEntries@@QAEPAXI@Z PROC			; CvProjectXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvProjectXMLEntries@@QAE@XZ		; CvProjectXMLEntries::~CvProjectXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@13
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@13:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvProjectXMLEntries@@QAEPAXI@Z ENDP			; CvProjectXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvPromotionXMLEntries@@QAEPAXI@Z		; CvPromotionXMLEntries::`scalar deleting destructor'
EXTRN	??1CvPromotionXMLEntries@@QAE@XZ:PROC		; CvPromotionXMLEntries::~CvPromotionXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvPromotionXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvPromotionXMLEntries@@QAEPAXI@Z PROC		; CvPromotionXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvPromotionXMLEntries@@QAE@XZ	; CvPromotionXMLEntries::~CvPromotionXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@14
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@14:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvPromotionXMLEntries@@QAEPAXI@Z ENDP		; CvPromotionXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvEmphasisXMLEntries@@QAEPAXI@Z		; CvEmphasisXMLEntries::`scalar deleting destructor'
EXTRN	??1CvEmphasisXMLEntries@@QAE@XZ:PROC		; CvEmphasisXMLEntries::~CvEmphasisXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvEmphasisXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvEmphasisXMLEntries@@QAEPAXI@Z PROC		; CvEmphasisXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvEmphasisXMLEntries@@QAE@XZ		; CvEmphasisXMLEntries::~CvEmphasisXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@15
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@15:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvEmphasisXMLEntries@@QAEPAXI@Z ENDP		; CvEmphasisXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvTraitXMLEntries@@QAEPAXI@Z		; CvTraitXMLEntries::`scalar deleting destructor'
EXTRN	??1CvTraitXMLEntries@@QAE@XZ:PROC		; CvTraitXMLEntries::~CvTraitXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvTraitXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvTraitXMLEntries@@QAEPAXI@Z PROC			; CvTraitXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvTraitXMLEntries@@QAE@XZ		; CvTraitXMLEntries::~CvTraitXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@16
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@16:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvTraitXMLEntries@@QAEPAXI@Z ENDP			; CvTraitXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvReligionXMLEntries@@QAEPAXI@Z		; CvReligionXMLEntries::`scalar deleting destructor'
EXTRN	??1CvReligionXMLEntries@@QAE@XZ:PROC		; CvReligionXMLEntries::~CvReligionXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvReligionXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvReligionXMLEntries@@QAEPAXI@Z PROC		; CvReligionXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvReligionXMLEntries@@QAE@XZ		; CvReligionXMLEntries::~CvReligionXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@17
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@17:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvReligionXMLEntries@@QAEPAXI@Z ENDP		; CvReligionXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvBeliefXMLEntries@@QAEPAXI@Z		; CvBeliefXMLEntries::`scalar deleting destructor'
EXTRN	??1CvBeliefXMLEntries@@QAE@XZ:PROC		; CvBeliefXMLEntries::~CvBeliefXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvBeliefXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvBeliefXMLEntries@@QAEPAXI@Z PROC			; CvBeliefXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBeliefXMLEntries@@QAE@XZ		; CvBeliefXMLEntries::~CvBeliefXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@18
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@18:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvBeliefXMLEntries@@QAEPAXI@Z ENDP			; CvBeliefXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvLeagueSpecialSessionXMLEntries@@QAEPAXI@Z	; CvLeagueSpecialSessionXMLEntries::`scalar deleting destructor'
EXTRN	??1CvLeagueSpecialSessionXMLEntries@@QAE@XZ:PROC ; CvLeagueSpecialSessionXMLEntries::~CvLeagueSpecialSessionXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvLeagueSpecialSessionXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvLeagueSpecialSessionXMLEntries@@QAEPAXI@Z PROC	; CvLeagueSpecialSessionXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvLeagueSpecialSessionXMLEntries@@QAE@XZ ; CvLeagueSpecialSessionXMLEntries::~CvLeagueSpecialSessionXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@19
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@19:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvLeagueSpecialSessionXMLEntries@@QAEPAXI@Z ENDP	; CvLeagueSpecialSessionXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvLeagueNameXMLEntries@@QAEPAXI@Z		; CvLeagueNameXMLEntries::`scalar deleting destructor'
EXTRN	??1CvLeagueNameXMLEntries@@QAE@XZ:PROC		; CvLeagueNameXMLEntries::~CvLeagueNameXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvLeagueNameXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvLeagueNameXMLEntries@@QAEPAXI@Z PROC		; CvLeagueNameXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvLeagueNameXMLEntries@@QAE@XZ	; CvLeagueNameXMLEntries::~CvLeagueNameXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@20
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@20:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvLeagueNameXMLEntries@@QAEPAXI@Z ENDP		; CvLeagueNameXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvLeagueProjectXMLEntries@@QAEPAXI@Z	; CvLeagueProjectXMLEntries::`scalar deleting destructor'
EXTRN	??1CvLeagueProjectXMLEntries@@QAE@XZ:PROC	; CvLeagueProjectXMLEntries::~CvLeagueProjectXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvLeagueProjectXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvLeagueProjectXMLEntries@@QAEPAXI@Z PROC		; CvLeagueProjectXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvLeagueProjectXMLEntries@@QAE@XZ	; CvLeagueProjectXMLEntries::~CvLeagueProjectXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@21
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@21:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvLeagueProjectXMLEntries@@QAEPAXI@Z ENDP		; CvLeagueProjectXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvLeagueProjectRewardXMLEntries@@QAEPAXI@Z	; CvLeagueProjectRewardXMLEntries::`scalar deleting destructor'
EXTRN	??1CvLeagueProjectRewardXMLEntries@@QAE@XZ:PROC	; CvLeagueProjectRewardXMLEntries::~CvLeagueProjectRewardXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvLeagueProjectRewardXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvLeagueProjectRewardXMLEntries@@QAEPAXI@Z PROC	; CvLeagueProjectRewardXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvLeagueProjectRewardXMLEntries@@QAE@XZ ; CvLeagueProjectRewardXMLEntries::~CvLeagueProjectRewardXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@22
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@22:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvLeagueProjectRewardXMLEntries@@QAEPAXI@Z ENDP	; CvLeagueProjectRewardXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvResolutionXMLEntries@@QAEPAXI@Z		; CvResolutionXMLEntries::`scalar deleting destructor'
EXTRN	??1CvResolutionXMLEntries@@QAE@XZ:PROC		; CvResolutionXMLEntries::~CvResolutionXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvResolutionXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvResolutionXMLEntries@@QAEPAXI@Z PROC		; CvResolutionXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvResolutionXMLEntries@@QAE@XZ	; CvResolutionXMLEntries::~CvResolutionXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@23
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@23:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvResolutionXMLEntries@@QAEPAXI@Z ENDP		; CvResolutionXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvNotificationXMLEntries@@QAEPAXI@Z		; CvNotificationXMLEntries::`scalar deleting destructor'
EXTRN	??1CvNotificationXMLEntries@@QAE@XZ:PROC	; CvNotificationXMLEntries::~CvNotificationXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvNotificationXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvNotificationXMLEntries@@QAEPAXI@Z PROC		; CvNotificationXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvNotificationXMLEntries@@QAE@XZ	; CvNotificationXMLEntries::~CvNotificationXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@24
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@24:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvNotificationXMLEntries@@QAEPAXI@Z ENDP		; CvNotificationXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvImprovementXMLEntries@@QAEPAXI@Z		; CvImprovementXMLEntries::`scalar deleting destructor'
EXTRN	??1CvImprovementXMLEntries@@QAE@XZ:PROC		; CvImprovementXMLEntries::~CvImprovementXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvImprovementXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvImprovementXMLEntries@@QAEPAXI@Z PROC		; CvImprovementXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvImprovementXMLEntries@@QAE@XZ	; CvImprovementXMLEntries::~CvImprovementXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@25
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@25:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvImprovementXMLEntries@@QAEPAXI@Z ENDP		; CvImprovementXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvTechXMLEntries@@QAEPAXI@Z			; CvTechXMLEntries::`scalar deleting destructor'
EXTRN	??1CvTechXMLEntries@@QAE@XZ:PROC		; CvTechXMLEntries::~CvTechXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvTechXMLEntries@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvTechXMLEntries@@QAEPAXI@Z PROC			; CvTechXMLEntries::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvTechXMLEntries@@QAE@XZ		; CvTechXMLEntries::~CvTechXMLEntries
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@26
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@26:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvTechXMLEntries@@QAEPAXI@Z ENDP			; CvTechXMLEntries::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvGame@@QAEPAXI@Z				; CvGame::`scalar deleting destructor'
EXTRN	??1CvGame@@QAE@XZ:PROC				; CvGame::~CvGame
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvGame@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvGame@@QAEPAXI@Z PROC				; CvGame::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvGame@@QAE@XZ			; CvGame::~CvGame
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@27
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@27:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvGame@@QAEPAXI@Z ENDP				; CvGame::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvTwoLayerPathFinder@@QAEPAXI@Z		; CvTwoLayerPathFinder::`scalar deleting destructor'
EXTRN	??1CvTwoLayerPathFinder@@QAE@XZ:PROC		; CvTwoLayerPathFinder::~CvTwoLayerPathFinder
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvTwoLayerPathFinder@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvTwoLayerPathFinder@@QAEPAXI@Z PROC		; CvTwoLayerPathFinder::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvTwoLayerPathFinder@@QAE@XZ		; CvTwoLayerPathFinder::~CvTwoLayerPathFinder
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@28
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@28:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvTwoLayerPathFinder@@QAEPAXI@Z ENDP		; CvTwoLayerPathFinder::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvAStar@@QAEPAXI@Z				; CvAStar::`scalar deleting destructor'
EXTRN	??1CvAStar@@QAE@XZ:PROC				; CvAStar::~CvAStar
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvAStar@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAStar@@QAEPAXI@Z PROC				; CvAStar::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@29
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@29:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAStar@@QAEPAXI@Z ENDP				; CvAStar::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_ECvString@@QAEPAXI@Z				; CvString::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_ECvString@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECvString@@QAEPAXI@Z PROC				; CvString::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1CvString@@QAE@XZ		; CvString::~CvString
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	28					; 0000001cH
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector:
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	bl, 1
	je	SHORT $LN1@vector
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_ECvString@@QAEPAXI@Z ENDP				; CvString::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@ABU01@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@ABU01@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	push	edi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], eax
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@ABU01@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>
_TEXT	ENDS
PUBLIC	??1CvIgnoreUnitsPathFinder@@QAE@XZ		; CvIgnoreUnitsPathFinder::~CvIgnoreUnitsPathFinder
; Function compile flags: /Ogtpy
;	COMDAT ??1CvIgnoreUnitsPathFinder@@QAE@XZ
_TEXT	SEGMENT
??1CvIgnoreUnitsPathFinder@@QAE@XZ PROC			; CvIgnoreUnitsPathFinder::~CvIgnoreUnitsPathFinder, COMDAT
; _this$ = ecx
	jmp	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
??1CvIgnoreUnitsPathFinder@@QAE@XZ ENDP			; CvIgnoreUnitsPathFinder::~CvIgnoreUnitsPathFinder
_TEXT	ENDS
PUBLIC	??1CvStepPathFinder@@QAE@XZ			; CvStepPathFinder::~CvStepPathFinder
; Function compile flags: /Ogtpy
;	COMDAT ??1CvStepPathFinder@@QAE@XZ
_TEXT	SEGMENT
??1CvStepPathFinder@@QAE@XZ PROC			; CvStepPathFinder::~CvStepPathFinder, COMDAT
; _this$ = ecx
	jmp	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
??1CvStepPathFinder@@QAE@XZ ENDP			; CvStepPathFinder::~CvStepPathFinder
_TEXT	ENDS
PUBLIC	??1_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node::~_Node
; Function compile flags: /Ogtpy
;	COMDAT ??1_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ PROC ; std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node::~_Node, COMDAT
; _this$ = ecx
	add	ecx, 8
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ENDP ; std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node::~_Node
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z	; CvTacticalAnalysisCell::GetBit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z
_TEXT	SEGMENT
_uiFlag$ = 8						; size = 4
?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z PROC		; CvTacticalAnalysisCell::GetBit, COMDAT
; _this$ = ecx

; 83   : 	FBITFLAGS(uint);

	mov	eax, DWORD PTR [ecx]
	and	eax, DWORD PTR _uiFlag$[esp-4]
	neg	eax
	sbb	eax, eax
	neg	eax
	ret	4
?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z ENDP		; CvTacticalAnalysisCell::GetBit
_TEXT	ENDS
PUBLIC	?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsRevealed, COMDAT
; _this$ = ecx

; 92   : 		return GetBit(TACTICAL_FLAG_REVEALED);

	mov	eax, DWORD PTR [ecx]
	and	eax, 1

; 93   : 	};

	ret	0
?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsRevealed
_TEXT	ENDS
PUBLIC	?IsVisible@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsVisible
; Function compile flags: /Ogtpy
;	COMDAT ?IsVisible@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsVisible@CvTacticalAnalysisCell@@QAE_NXZ PROC		; CvTacticalAnalysisCell::IsVisible, COMDAT
; _this$ = ecx

; 100  : 		return GetBit(TACTICAL_FLAG_VISIBLE);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 1
	and	eax, 1

; 101  : 	};

	ret	0
?IsVisible@CvTacticalAnalysisCell@@QAE_NXZ ENDP		; CvTacticalAnalysisCell::IsVisible
_TEXT	ENDS
PUBLIC	?IsImpassableTerrain@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsImpassableTerrain
; Function compile flags: /Ogtpy
;	COMDAT ?IsImpassableTerrain@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsImpassableTerrain@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsImpassableTerrain, COMDAT
; _this$ = ecx

; 108  : 		return GetBit(TACTICAL_FLAG_IMPASSABLE_TERRAIN);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 2
	and	eax, 1

; 109  : 	};

	ret	0
?IsImpassableTerrain@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsImpassableTerrain
_TEXT	ENDS
PUBLIC	?IsImpassableTerritory@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsImpassableTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?IsImpassableTerritory@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsImpassableTerritory@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsImpassableTerritory, COMDAT
; _this$ = ecx

; 116  : 		return GetBit(TACTICAL_FLAG_IMPASSABLE_TERRITORY);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 3
	and	eax, 1

; 117  : 	};

	ret	0
?IsImpassableTerritory@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsImpassableTerritory
_TEXT	ENDS
PUBLIC	?IsNotVisibleToEnemy@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsNotVisibleToEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?IsNotVisibleToEnemy@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsNotVisibleToEnemy@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsNotVisibleToEnemy, COMDAT
; _this$ = ecx

; 124  : 		return GetBit(TACTICAL_FLAG_NOT_VISIBLE_TO_ENEMY);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 4
	and	eax, 1

; 125  : 	};

	ret	0
?IsNotVisibleToEnemy@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsNotVisibleToEnemy
_TEXT	ENDS
PUBLIC	?IsSubjectToAttack@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsSubjectToAttack
; Function compile flags: /Ogtpy
;	COMDAT ?IsSubjectToAttack@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsSubjectToAttack@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsSubjectToAttack, COMDAT
; _this$ = ecx

; 132  : 		return GetBit(TACTICAL_FLAG_SUBJECT_TO_ENEMY_ATTACK);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 5
	and	eax, 1

; 133  : 	};

	ret	0
?IsSubjectToAttack@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsSubjectToAttack
_TEXT	ENDS
PUBLIC	?IsEnemyCanMovePast@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsEnemyCanMovePast
; Function compile flags: /Ogtpy
;	COMDAT ?IsEnemyCanMovePast@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsEnemyCanMovePast@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsEnemyCanMovePast, COMDAT
; _this$ = ecx

; 140  : 		return GetBit(TACTICAL_FLAG_ENEMY_CAN_REACH_WITH_MOVES);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 6
	and	eax, 1

; 141  : 	};

	ret	0
?IsEnemyCanMovePast@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsEnemyCanMovePast
_TEXT	ENDS
PUBLIC	?IsFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsFriendlyTurnEndTile
; Function compile flags: /Ogtpy
;	COMDAT ?IsFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsFriendlyTurnEndTile, COMDAT
; _this$ = ecx

; 148  : 		return GetBit(TACTICAL_FLAG_FRIENDLY_TURN_END_TILE);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 7
	and	eax, 1

; 149  : 	};

	ret	0
?IsFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsFriendlyTurnEndTile
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ; std::auto_ptr_ref<ICvCity1>::auto_ptr_ref<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z PROC ; std::auto_ptr_ref<ICvCity1>::auto_ptr_ref<ICvCity1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ENDP ; std::auto_ptr_ref<ICvCity1>::auto_ptr_ref<ICvCity1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z ; std::auto_ptr_ref<ICvDeal1>::auto_ptr_ref<ICvDeal1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr_ref@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z PROC ; std::auto_ptr_ref<ICvDeal1>::auto_ptr_ref<ICvDeal1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvDeal1@@@std@@QAE@PAVICvDeal1@@@Z ENDP ; std::auto_ptr_ref<ICvDeal1>::auto_ptr_ref<ICvDeal1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z PROC ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ENDP ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvRandom1@@@std@@QAE@PAVICvRandom1@@@Z ; std::auto_ptr_ref<ICvRandom1>::auto_ptr_ref<ICvRandom1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr_ref@VICvRandom1@@@std@@QAE@PAVICvRandom1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvRandom1@@@std@@QAE@PAVICvRandom1@@@Z PROC ; std::auto_ptr_ref<ICvRandom1>::auto_ptr_ref<ICvRandom1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvRandom1@@@std@@QAE@PAVICvRandom1@@@Z ENDP ; std::auto_ptr_ref<ICvRandom1>::auto_ptr_ref<ICvRandom1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ; std::auto_ptr_ref<ICvUnit1>::auto_ptr_ref<ICvUnit1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr_ref@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z PROC ; std::auto_ptr_ref<ICvUnit1>::auto_ptr_ref<ICvUnit1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ENDP ; std::auto_ptr_ref<ICvUnit1>::auto_ptr_ref<ICvUnit1>
_TEXT	ENDS
PUBLIC	?IsWithinRangeOfTarget@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsWithinRangeOfTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?IsWithinRangeOfTarget@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsWithinRangeOfTarget@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsWithinRangeOfTarget, COMDAT
; _this$ = ecx

; 233  : 		return GetBit(TACTICAL_FLAG_WITHIN_RANGE_OF_TARGET);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 17					; 00000011H
	and	eax, 1

; 234  : 	};

	ret	0
?IsWithinRangeOfTarget@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsWithinRangeOfTarget
_TEXT	ENDS
PUBLIC	?IsHelpsProvidesFlankBonus@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsHelpsProvidesFlankBonus
; Function compile flags: /Ogtpy
;	COMDAT ?IsHelpsProvidesFlankBonus@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsHelpsProvidesFlankBonus@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsHelpsProvidesFlankBonus, COMDAT
; _this$ = ecx

; 241  : 		return GetBit(TACTICAL_FLAG_CAN_USE_TO_FLANK);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 18					; 00000012H
	and	eax, 1

; 242  : 	};

	ret	0
?IsHelpsProvidesFlankBonus@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsHelpsProvidesFlankBonus
_TEXT	ENDS
PUBLIC	?IsSafeForDeployment@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsSafeForDeployment
; Function compile flags: /Ogtpy
;	COMDAT ?IsSafeForDeployment@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsSafeForDeployment@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsSafeForDeployment, COMDAT
; _this$ = ecx

; 249  : 		return GetBit(TACTICAL_FLAG_SAFE_DEPLOYMENT);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 19					; 00000013H
	and	eax, 1

; 250  : 	};

	ret	0
?IsSafeForDeployment@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsSafeForDeployment
_TEXT	ENDS
PUBLIC	?GetDefenseModifier@CvTacticalAnalysisCell@@QBEHXZ ; CvTacticalAnalysisCell::GetDefenseModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetDefenseModifier@CvTacticalAnalysisCell@@QBEHXZ
_TEXT	SEGMENT
?GetDefenseModifier@CvTacticalAnalysisCell@@QBEHXZ PROC	; CvTacticalAnalysisCell::GetDefenseModifier, COMDAT
; _this$ = ecx

; 307  : 		return m_iDefenseModifier;

	mov	eax, DWORD PTR [ecx+28]

; 308  : 	};

	ret	0
?GetDefenseModifier@CvTacticalAnalysisCell@@QBEHXZ ENDP	; CvTacticalAnalysisCell::GetDefenseModifier
_TEXT	ENDS
PUBLIC	?GetDeploymentScore@CvTacticalAnalysisCell@@QBEHXZ ; CvTacticalAnalysisCell::GetDeploymentScore
; Function compile flags: /Ogtpy
;	COMDAT ?GetDeploymentScore@CvTacticalAnalysisCell@@QBEHXZ
_TEXT	SEGMENT
?GetDeploymentScore@CvTacticalAnalysisCell@@QBEHXZ PROC	; CvTacticalAnalysisCell::GetDeploymentScore, COMDAT
; _this$ = ecx

; 315  : 		return m_iDeploymentScore;

	mov	eax, DWORD PTR [ecx+32]

; 316  : 	};

	ret	0
?GetDeploymentScore@CvTacticalAnalysisCell@@QBEHXZ ENDP	; CvTacticalAnalysisCell::GetDeploymentScore
_TEXT	ENDS
PUBLIC	?GetDominanceZone@CvTacticalAnalysisCell@@QBEHXZ ; CvTacticalAnalysisCell::GetDominanceZone
; Function compile flags: /Ogtpy
;	COMDAT ?GetDominanceZone@CvTacticalAnalysisCell@@QBEHXZ
_TEXT	SEGMENT
?GetDominanceZone@CvTacticalAnalysisCell@@QBEHXZ PROC	; CvTacticalAnalysisCell::GetDominanceZone, COMDAT
; _this$ = ecx

; 323  : 		return m_iDominanceZoneID;

	mov	eax, DWORD PTR [ecx+40]

; 324  : 	};

	ret	0
?GetDominanceZone@CvTacticalAnalysisCell@@QBEHXZ ENDP	; CvTacticalAnalysisCell::GetDominanceZone
_TEXT	ENDS
PUBLIC	?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z ; CvTacticalAnalysisMap::GetCell
; Function compile flags: /Ogtpy
;	COMDAT ?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z
_TEXT	SEGMENT
_iPlotIndex$ = 8					; size = 4
?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z PROC ; CvTacticalAnalysisMap::GetCell, COMDAT
; _this$ = ecx

; 630  : 		return &m_pPlots[iPlotIndex];

	mov	eax, DWORD PTR _iPlotIndex$[esp-4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+12]

; 631  : 	};

	ret	4
?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z ENDP ; CvTacticalAnalysisMap::GetCell
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEABQAVCvBuildingClassInfo@@XZ ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEABQAVCvBuildingClassInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEABQAVCvBuildingClassInfo@@XZ PROC ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEABQAVCvBuildingClassInfo@@XZ ENDP ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEABQAVCvLeaderHeadInfo@@XZ ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEABQAVCvLeaderHeadInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEABQAVCvLeaderHeadInfo@@XZ PROC ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEABQAVCvLeaderHeadInfo@@XZ ENDP ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEABQAVCvMinorCivInfo@@XZ ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEABQAVCvMinorCivInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEABQAVCvMinorCivInfo@@XZ PROC ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEABQAVCvMinorCivInfo@@XZ ENDP ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEABQAVCvVoteSourceInfo@@XZ ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEABQAVCvVoteSourceInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEABQAVCvVoteSourceInfo@@XZ PROC ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEABQAVCvVoteSourceInfo@@XZ ENDP ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEABQAVCvHandicapInfo@@XZ ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEABQAVCvHandicapInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEABQAVCvHandicapInfo@@XZ PROC ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEABQAVCvHandicapInfo@@XZ ENDP ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEABQAVCvGameSpeedInfo@@XZ ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEABQAVCvGameSpeedInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEABQAVCvGameSpeedInfo@@XZ PROC ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEABQAVCvGameSpeedInfo@@XZ ENDP ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBEABQAVCvTurnTimerInfo@@XZ ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBEABQAVCvTurnTimerInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBEABQAVCvTurnTimerInfo@@XZ PROC ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBEABQAVCvTurnTimerInfo@@XZ ENDP ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEABQAVCvVictoryInfo@@XZ ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEABQAVCvVictoryInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEABQAVCvVictoryInfo@@XZ PROC ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEABQAVCvVictoryInfo@@XZ ENDP ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEABQAVCvSmallAwardInfo@@XZ ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEABQAVCvSmallAwardInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEABQAVCvSmallAwardInfo@@XZ PROC ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEABQAVCvSmallAwardInfo@@XZ ENDP ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEABQAVCvHurryInfo@@XZ ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEABQAVCvHurryInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEABQAVCvHurryInfo@@XZ PROC ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEABQAVCvHurryInfo@@XZ ENDP ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEABQAVCvProcessInfo@@XZ ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEABQAVCvProcessInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEABQAVCvProcessInfo@@XZ PROC ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEABQAVCvProcessInfo@@XZ ENDP ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEABQAVCvVoteInfo@@XZ ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEABQAVCvVoteInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEABQAVCvVoteInfo@@XZ PROC ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEABQAVCvVoteInfo@@XZ ENDP ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEABQAVCvColorInfo@@XZ ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEABQAVCvColorInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEABQAVCvColorInfo@@XZ PROC ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEABQAVCvColorInfo@@XZ ENDP ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEABQAVCvPlayerColorInfo@@XZ ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEABQAVCvPlayerColorInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEABQAVCvPlayerColorInfo@@XZ PROC ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEABQAVCvPlayerColorInfo@@XZ ENDP ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEABQAVCvInterfaceModeInfo@@XZ ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEABQAVCvInterfaceModeInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEABQAVCvInterfaceModeInfo@@XZ PROC ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEABQAVCvInterfaceModeInfo@@XZ ENDP ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEABQAVCvRouteInfo@@XZ ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEABQAVCvRouteInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEABQAVCvRouteInfo@@XZ PROC ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEABQAVCvRouteInfo@@XZ ENDP ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEABQAVCvEraInfo@@XZ ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEABQAVCvEraInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEABQAVCvEraInfo@@XZ PROC ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEABQAVCvEraInfo@@XZ ENDP ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEABQAVCvBuildInfo@@XZ ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEABQAVCvBuildInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEABQAVCvBuildInfo@@XZ PROC ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEABQAVCvBuildInfo@@XZ ENDP ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEABQAVCvUnitClassInfo@@XZ ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEABQAVCvUnitClassInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEABQAVCvUnitClassInfo@@XZ PROC ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEABQAVCvUnitClassInfo@@XZ ENDP ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEABQAVCvSpecialUnitInfo@@XZ ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEABQAVCvSpecialUnitInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEABQAVCvSpecialUnitInfo@@XZ PROC ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEABQAVCvSpecialUnitInfo@@XZ ENDP ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEABQAVCvSpecialistInfo@@XZ ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEABQAVCvSpecialistInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEABQAVCvSpecialistInfo@@XZ PROC ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEABQAVCvSpecialistInfo@@XZ ENDP ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEABQAVCvActionInfo@@XZ ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEABQAVCvActionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEABQAVCvActionInfo@@XZ PROC ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEABQAVCvActionInfo@@XZ ENDP ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEABQAVCvMissionInfo@@XZ ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEABQAVCvMissionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEABQAVCvMissionInfo@@XZ PROC ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEABQAVCvMissionInfo@@XZ ENDP ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEABQAVCvControlInfo@@XZ ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEABQAVCvControlInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEABQAVCvControlInfo@@XZ PROC ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEABQAVCvControlInfo@@XZ ENDP ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEABQAVCvCommandInfo@@XZ ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEABQAVCvCommandInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEABQAVCvCommandInfo@@XZ PROC ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEABQAVCvCommandInfo@@XZ ENDP ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEABQAVCvAutomateInfo@@XZ ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEABQAVCvAutomateInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEABQAVCvAutomateInfo@@XZ PROC ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEABQAVCvAutomateInfo@@XZ ENDP ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEABQAVCvBaseInfo@@XZ ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEABQAVCvBaseInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEABQAVCvBaseInfo@@XZ PROC ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEABQAVCvBaseInfo@@XZ ENDP ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEABQAVCvGameOptionInfo@@XZ ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEABQAVCvGameOptionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEABQAVCvGameOptionInfo@@XZ PROC ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEABQAVCvGameOptionInfo@@XZ ENDP ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEABQAVCvMPOptionInfo@@XZ ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEABQAVCvMPOptionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEABQAVCvMPOptionInfo@@XZ PROC ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEABQAVCvMPOptionInfo@@XZ ENDP ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEABQAVCvPlayerOptionInfo@@XZ ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEABQAVCvPlayerOptionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEABQAVCvPlayerOptionInfo@@XZ PROC ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEABQAVCvPlayerOptionInfo@@XZ ENDP ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEABQAVCvYieldInfo@@XZ ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEABQAVCvYieldInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEABQAVCvYieldInfo@@XZ PROC ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEABQAVCvYieldInfo@@XZ ENDP ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEABQAVCvTerrainInfo@@XZ ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEABQAVCvTerrainInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEABQAVCvTerrainInfo@@XZ PROC ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEABQAVCvTerrainInfo@@XZ ENDP ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEABQAVCvFeatureInfo@@XZ ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEABQAVCvFeatureInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEABQAVCvFeatureInfo@@XZ PROC ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEABQAVCvFeatureInfo@@XZ ENDP ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEABQAVCvResourceClassInfo@@XZ ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEABQAVCvResourceClassInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEABQAVCvResourceClassInfo@@XZ PROC ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEABQAVCvResourceClassInfo@@XZ ENDP ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEABQAVCvResourceInfo@@XZ ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEABQAVCvResourceInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEABQAVCvResourceInfo@@XZ PROC ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEABQAVCvResourceInfo@@XZ ENDP ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEABQAVCvEntityEventInfo@@XZ ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEABQAVCvEntityEventInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEABQAVCvEntityEventInfo@@XZ PROC ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEABQAVCvEntityEventInfo@@XZ ENDP ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@PAPAVCvBuildingClassInfo@@@Z ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@PAPAVCvBuildingClassInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@PAPAVCvBuildingClassInfo@@@Z PROC ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@PAPAVCvBuildingClassInfo@@@Z ENDP ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@PAPAVCvLeaderHeadInfo@@@Z ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@PAPAVCvLeaderHeadInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@PAPAVCvLeaderHeadInfo@@@Z PROC ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@PAPAVCvLeaderHeadInfo@@@Z ENDP ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@PAPAVCvMinorCivInfo@@@Z ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@PAPAVCvMinorCivInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@PAPAVCvMinorCivInfo@@@Z PROC ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@PAPAVCvMinorCivInfo@@@Z ENDP ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@PAPAVCvVoteSourceInfo@@@Z ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@PAPAVCvVoteSourceInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@PAPAVCvVoteSourceInfo@@@Z PROC ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@PAPAVCvVoteSourceInfo@@@Z ENDP ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@PAPAVCvHandicapInfo@@@Z ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@PAPAVCvHandicapInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@PAPAVCvHandicapInfo@@@Z PROC ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@PAPAVCvHandicapInfo@@@Z ENDP ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@PAPAVCvGameSpeedInfo@@@Z ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@PAPAVCvGameSpeedInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@PAPAVCvGameSpeedInfo@@@Z PROC ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@PAPAVCvGameSpeedInfo@@@Z ENDP ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@PAPAVCvTurnTimerInfo@@@Z ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@PAPAVCvTurnTimerInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@PAPAVCvTurnTimerInfo@@@Z PROC ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@PAPAVCvTurnTimerInfo@@@Z ENDP ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@PAPAVCvVictoryInfo@@@Z ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@PAPAVCvVictoryInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@PAPAVCvVictoryInfo@@@Z PROC ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@PAPAVCvVictoryInfo@@@Z ENDP ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@PAPAVCvSmallAwardInfo@@@Z ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@PAPAVCvSmallAwardInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@PAPAVCvSmallAwardInfo@@@Z PROC ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@PAPAVCvSmallAwardInfo@@@Z ENDP ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@PAPAVCvHurryInfo@@@Z ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@PAPAVCvHurryInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@PAPAVCvHurryInfo@@@Z PROC ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@PAPAVCvHurryInfo@@@Z ENDP ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@PAPAVCvProcessInfo@@@Z ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@PAPAVCvProcessInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@PAPAVCvProcessInfo@@@Z PROC ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@PAPAVCvProcessInfo@@@Z ENDP ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@PAPAVCvVoteInfo@@@Z ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@PAPAVCvVoteInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@PAPAVCvVoteInfo@@@Z PROC ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@PAPAVCvVoteInfo@@@Z ENDP ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@PAPAVCvColorInfo@@@Z ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@PAPAVCvColorInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@PAPAVCvColorInfo@@@Z PROC ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@PAPAVCvColorInfo@@@Z ENDP ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@PAPAVCvPlayerColorInfo@@@Z ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@PAPAVCvPlayerColorInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@PAPAVCvPlayerColorInfo@@@Z PROC ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@PAPAVCvPlayerColorInfo@@@Z ENDP ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@PAPAVCvInterfaceModeInfo@@@Z ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@PAPAVCvInterfaceModeInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@PAPAVCvInterfaceModeInfo@@@Z PROC ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@PAPAVCvInterfaceModeInfo@@@Z ENDP ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@PAPAVCvRouteInfo@@@Z ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@PAPAVCvRouteInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@PAPAVCvRouteInfo@@@Z PROC ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@PAPAVCvRouteInfo@@@Z ENDP ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@PAPAVCvEraInfo@@@Z ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@PAPAVCvEraInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@PAPAVCvEraInfo@@@Z PROC ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@PAPAVCvEraInfo@@@Z ENDP ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@PAPAVCvBuildInfo@@@Z ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@PAPAVCvBuildInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@PAPAVCvBuildInfo@@@Z PROC ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@PAPAVCvBuildInfo@@@Z ENDP ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@PAPAVCvUnitClassInfo@@@Z ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@PAPAVCvUnitClassInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@PAPAVCvUnitClassInfo@@@Z PROC ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@PAPAVCvUnitClassInfo@@@Z ENDP ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@PAPAVCvSpecialUnitInfo@@@Z ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@PAPAVCvSpecialUnitInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@PAPAVCvSpecialUnitInfo@@@Z PROC ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@PAPAVCvSpecialUnitInfo@@@Z ENDP ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@PAPAVCvSpecialistInfo@@@Z ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@PAPAVCvSpecialistInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@PAPAVCvSpecialistInfo@@@Z PROC ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@PAPAVCvSpecialistInfo@@@Z ENDP ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z PROC ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z ENDP ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@PAPAVCvMissionInfo@@@Z ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@PAPAVCvMissionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@PAPAVCvMissionInfo@@@Z PROC ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@PAPAVCvMissionInfo@@@Z ENDP ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@PAPAVCvControlInfo@@@Z ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@PAPAVCvControlInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@PAPAVCvControlInfo@@@Z PROC ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@PAPAVCvControlInfo@@@Z ENDP ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@PAPAVCvCommandInfo@@@Z ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@PAPAVCvCommandInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@PAPAVCvCommandInfo@@@Z PROC ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@PAPAVCvCommandInfo@@@Z ENDP ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@PAPAVCvAutomateInfo@@@Z ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@PAPAVCvAutomateInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@PAPAVCvAutomateInfo@@@Z PROC ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@PAPAVCvAutomateInfo@@@Z ENDP ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@PAPAVCvBaseInfo@@@Z ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@PAPAVCvBaseInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@PAPAVCvBaseInfo@@@Z PROC ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@PAPAVCvBaseInfo@@@Z ENDP ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@PAPAVCvGameOptionInfo@@@Z ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@PAPAVCvGameOptionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@PAPAVCvGameOptionInfo@@@Z PROC ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@PAPAVCvGameOptionInfo@@@Z ENDP ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@PAPAVCvMPOptionInfo@@@Z ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@PAPAVCvMPOptionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@PAPAVCvMPOptionInfo@@@Z PROC ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@PAPAVCvMPOptionInfo@@@Z ENDP ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@PAPAVCvPlayerOptionInfo@@@Z ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@PAPAVCvPlayerOptionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@PAPAVCvPlayerOptionInfo@@@Z PROC ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@PAPAVCvPlayerOptionInfo@@@Z ENDP ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@PAPAVCvYieldInfo@@@Z ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@PAPAVCvYieldInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@PAPAVCvYieldInfo@@@Z PROC ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@PAPAVCvYieldInfo@@@Z ENDP ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@PAPAVCvTerrainInfo@@@Z ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@PAPAVCvTerrainInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@PAPAVCvTerrainInfo@@@Z PROC ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@PAPAVCvTerrainInfo@@@Z ENDP ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@PAPAVCvFeatureInfo@@@Z ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@PAPAVCvFeatureInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@PAPAVCvFeatureInfo@@@Z PROC ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@PAPAVCvFeatureInfo@@@Z ENDP ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@PAPAVCvResourceClassInfo@@@Z ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@PAPAVCvResourceClassInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@PAPAVCvResourceClassInfo@@@Z PROC ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@PAPAVCvResourceClassInfo@@@Z ENDP ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@PAPAVCvResourceInfo@@@Z ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@PAPAVCvResourceInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@PAPAVCvResourceInfo@@@Z PROC ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@PAPAVCvResourceInfo@@@Z ENDP ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@PAPAVCvEntityEventInfo@@@Z ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@PAPAVCvEntityEventInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@PAPAVCvEntityEventInfo@@@Z PROC ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@PAPAVCvEntityEventInfo@@@Z ENDP ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvBuildingClassInfo@@@@YAXAAPAVCvBuildingClassInfo@@@Z ; SAFE_DELETE<CvBuildingClassInfo>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvBuildingClassInfo@@@@YAXAAPAVCvBuildingClassInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvBuildingClassInfo@@@@YAXAAPAVCvBuildingClassInfo@@@Z PROC ; SAFE_DELETE<CvBuildingClassInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@3
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@3:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvBuildingClassInfo@@@@YAXAAPAVCvBuildingClassInfo@@@Z ENDP ; SAFE_DELETE<CvBuildingClassInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvLeaderHeadInfo@@@@YAXAAPAVCvLeaderHeadInfo@@@Z ; SAFE_DELETE<CvLeaderHeadInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvLeaderHeadInfo@@@@YAXAAPAVCvLeaderHeadInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvLeaderHeadInfo@@@@YAXAAPAVCvLeaderHeadInfo@@@Z PROC ; SAFE_DELETE<CvLeaderHeadInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@4
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@4:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvLeaderHeadInfo@@@@YAXAAPAVCvLeaderHeadInfo@@@Z ENDP ; SAFE_DELETE<CvLeaderHeadInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvCivilizationInfo@@@@YAXAAPAVCvCivilizationInfo@@@Z ; SAFE_DELETE<CvCivilizationInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvCivilizationInfo@@@@YAXAAPAVCvCivilizationInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvCivilizationInfo@@@@YAXAAPAVCvCivilizationInfo@@@Z PROC ; SAFE_DELETE<CvCivilizationInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@5
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@5:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvCivilizationInfo@@@@YAXAAPAVCvCivilizationInfo@@@Z ENDP ; SAFE_DELETE<CvCivilizationInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvMinorCivInfo@@@@YAXAAPAVCvMinorCivInfo@@@Z ; SAFE_DELETE<CvMinorCivInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvMinorCivInfo@@@@YAXAAPAVCvMinorCivInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvMinorCivInfo@@@@YAXAAPAVCvMinorCivInfo@@@Z PROC ; SAFE_DELETE<CvMinorCivInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@6
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@6:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvMinorCivInfo@@@@YAXAAPAVCvMinorCivInfo@@@Z ENDP ; SAFE_DELETE<CvMinorCivInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvVoteSourceInfo@@@@YAXAAPAVCvVoteSourceInfo@@@Z ; SAFE_DELETE<CvVoteSourceInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvVoteSourceInfo@@@@YAXAAPAVCvVoteSourceInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvVoteSourceInfo@@@@YAXAAPAVCvVoteSourceInfo@@@Z PROC ; SAFE_DELETE<CvVoteSourceInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@7
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@7:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvVoteSourceInfo@@@@YAXAAPAVCvVoteSourceInfo@@@Z ENDP ; SAFE_DELETE<CvVoteSourceInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvHandicapInfo@@@@YAXAAPAVCvHandicapInfo@@@Z ; SAFE_DELETE<CvHandicapInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvHandicapInfo@@@@YAXAAPAVCvHandicapInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvHandicapInfo@@@@YAXAAPAVCvHandicapInfo@@@Z PROC ; SAFE_DELETE<CvHandicapInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@8
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@8:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvHandicapInfo@@@@YAXAAPAVCvHandicapInfo@@@Z ENDP ; SAFE_DELETE<CvHandicapInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvGameSpeedInfo@@@@YAXAAPAVCvGameSpeedInfo@@@Z ; SAFE_DELETE<CvGameSpeedInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvGameSpeedInfo@@@@YAXAAPAVCvGameSpeedInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvGameSpeedInfo@@@@YAXAAPAVCvGameSpeedInfo@@@Z PROC ; SAFE_DELETE<CvGameSpeedInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@9
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@9:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvGameSpeedInfo@@@@YAXAAPAVCvGameSpeedInfo@@@Z ENDP ; SAFE_DELETE<CvGameSpeedInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvVictoryInfo@@@@YAXAAPAVCvVictoryInfo@@@Z ; SAFE_DELETE<CvVictoryInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvVictoryInfo@@@@YAXAAPAVCvVictoryInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvVictoryInfo@@@@YAXAAPAVCvVictoryInfo@@@Z PROC ; SAFE_DELETE<CvVictoryInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@10
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@10:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvVictoryInfo@@@@YAXAAPAVCvVictoryInfo@@@Z ENDP ; SAFE_DELETE<CvVictoryInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvSmallAwardInfo@@@@YAXAAPAVCvSmallAwardInfo@@@Z ; SAFE_DELETE<CvSmallAwardInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvSmallAwardInfo@@@@YAXAAPAVCvSmallAwardInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvSmallAwardInfo@@@@YAXAAPAVCvSmallAwardInfo@@@Z PROC ; SAFE_DELETE<CvSmallAwardInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@11
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@11:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvSmallAwardInfo@@@@YAXAAPAVCvSmallAwardInfo@@@Z ENDP ; SAFE_DELETE<CvSmallAwardInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvProcessInfo@@@@YAXAAPAVCvProcessInfo@@@Z ; SAFE_DELETE<CvProcessInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvProcessInfo@@@@YAXAAPAVCvProcessInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvProcessInfo@@@@YAXAAPAVCvProcessInfo@@@Z PROC ; SAFE_DELETE<CvProcessInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@12
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@12:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvProcessInfo@@@@YAXAAPAVCvProcessInfo@@@Z ENDP ; SAFE_DELETE<CvProcessInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvVoteInfo@@@@YAXAAPAVCvVoteInfo@@@Z ; SAFE_DELETE<CvVoteInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvVoteInfo@@@@YAXAAPAVCvVoteInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvVoteInfo@@@@YAXAAPAVCvVoteInfo@@@Z PROC ; SAFE_DELETE<CvVoteInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@13
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@13:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvVoteInfo@@@@YAXAAPAVCvVoteInfo@@@Z ENDP ; SAFE_DELETE<CvVoteInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvRouteInfo@@@@YAXAAPAVCvRouteInfo@@@Z ; SAFE_DELETE<CvRouteInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvRouteInfo@@@@YAXAAPAVCvRouteInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvRouteInfo@@@@YAXAAPAVCvRouteInfo@@@Z PROC ; SAFE_DELETE<CvRouteInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@14
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@14:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvRouteInfo@@@@YAXAAPAVCvRouteInfo@@@Z ENDP ; SAFE_DELETE<CvRouteInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvEraInfo@@@@YAXAAPAVCvEraInfo@@@Z ; SAFE_DELETE<CvEraInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvEraInfo@@@@YAXAAPAVCvEraInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvEraInfo@@@@YAXAAPAVCvEraInfo@@@Z PROC	; SAFE_DELETE<CvEraInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@15
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@15:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvEraInfo@@@@YAXAAPAVCvEraInfo@@@Z ENDP	; SAFE_DELETE<CvEraInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvBuildInfo@@@@YAXAAPAVCvBuildInfo@@@Z ; SAFE_DELETE<CvBuildInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvBuildInfo@@@@YAXAAPAVCvBuildInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvBuildInfo@@@@YAXAAPAVCvBuildInfo@@@Z PROC ; SAFE_DELETE<CvBuildInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@16
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@16:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvBuildInfo@@@@YAXAAPAVCvBuildInfo@@@Z ENDP ; SAFE_DELETE<CvBuildInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvSpecialUnitInfo@@@@YAXAAPAVCvSpecialUnitInfo@@@Z ; SAFE_DELETE<CvSpecialUnitInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvSpecialUnitInfo@@@@YAXAAPAVCvSpecialUnitInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvSpecialUnitInfo@@@@YAXAAPAVCvSpecialUnitInfo@@@Z PROC ; SAFE_DELETE<CvSpecialUnitInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@17
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@17:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvSpecialUnitInfo@@@@YAXAAPAVCvSpecialUnitInfo@@@Z ENDP ; SAFE_DELETE<CvSpecialUnitInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvSpecialistInfo@@@@YAXAAPAVCvSpecialistInfo@@@Z ; SAFE_DELETE<CvSpecialistInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvSpecialistInfo@@@@YAXAAPAVCvSpecialistInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvSpecialistInfo@@@@YAXAAPAVCvSpecialistInfo@@@Z PROC ; SAFE_DELETE<CvSpecialistInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@18
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@18:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvSpecialistInfo@@@@YAXAAPAVCvSpecialistInfo@@@Z ENDP ; SAFE_DELETE<CvSpecialistInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvActionInfo@@@@YAXAAPAVCvActionInfo@@@Z ; SAFE_DELETE<CvActionInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvActionInfo@@@@YAXAAPAVCvActionInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvActionInfo@@@@YAXAAPAVCvActionInfo@@@Z PROC ; SAFE_DELETE<CvActionInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvActionInfo@@@@YAXAAPAVCvActionInfo@@@Z ENDP ; SAFE_DELETE<CvActionInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvTerrainInfo@@@@YAXAAPAVCvTerrainInfo@@@Z ; SAFE_DELETE<CvTerrainInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvTerrainInfo@@@@YAXAAPAVCvTerrainInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvTerrainInfo@@@@YAXAAPAVCvTerrainInfo@@@Z PROC ; SAFE_DELETE<CvTerrainInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@19
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@19:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvTerrainInfo@@@@YAXAAPAVCvTerrainInfo@@@Z ENDP ; SAFE_DELETE<CvTerrainInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvFeatureInfo@@@@YAXAAPAVCvFeatureInfo@@@Z ; SAFE_DELETE<CvFeatureInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvFeatureInfo@@@@YAXAAPAVCvFeatureInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvFeatureInfo@@@@YAXAAPAVCvFeatureInfo@@@Z PROC ; SAFE_DELETE<CvFeatureInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@20
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@20:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvFeatureInfo@@@@YAXAAPAVCvFeatureInfo@@@Z ENDP ; SAFE_DELETE<CvFeatureInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvResourceInfo@@@@YAXAAPAVCvResourceInfo@@@Z ; SAFE_DELETE<CvResourceInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvResourceInfo@@@@YAXAAPAVCvResourceInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvResourceInfo@@@@YAXAAPAVCvResourceInfo@@@Z PROC ; SAFE_DELETE<CvResourceInfo>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET@21
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET@21:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvResourceInfo@@@@YAXAAPAVCvResourceInfo@@@Z ENDP ; SAFE_DELETE<CvResourceInfo>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvInterfaceModeInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvInterfaceModeInfo@@0@Z ; std::_Ptr_cat<CvInterfaceModeInfo * *,CvInterfaceModeInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvInterfaceModeInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvInterfaceModeInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvInterfaceModeInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvInterfaceModeInfo@@0@Z PROC ; std::_Ptr_cat<CvInterfaceModeInfo * *,CvInterfaceModeInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvInterfaceModeInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvInterfaceModeInfo@@0@Z ENDP ; std::_Ptr_cat<CvInterfaceModeInfo * *,CvInterfaceModeInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@YAXPAPAVCvInterfaceModeInfo@@0AAV?$allocator@PAVCvInterfaceModeInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvInterfaceModeInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@YAXPAPAVCvInterfaceModeInfo@@0AAV?$allocator@PAVCvInterfaceModeInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@YAXPAPAVCvInterfaceModeInfo@@0AAV?$allocator@PAVCvInterfaceModeInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvInterfaceModeInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@YAXPAPAVCvInterfaceModeInfo@@0AAV?$allocator@PAVCvInterfaceModeInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvInterfaceModeInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvColorInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvColorInfo@@0@Z ; std::_Ptr_cat<CvColorInfo * *,CvColorInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvColorInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvColorInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvColorInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvColorInfo@@0@Z PROC ; std::_Ptr_cat<CvColorInfo * *,CvColorInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvColorInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvColorInfo@@0@Z ENDP ; std::_Ptr_cat<CvColorInfo * *,CvColorInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvColorInfo@@@std@@@std@@YAXPAPAVCvColorInfo@@0AAV?$allocator@PAVCvColorInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvColorInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvColorInfo@@@std@@@std@@YAXPAPAVCvColorInfo@@0AAV?$allocator@PAVCvColorInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvColorInfo@@@std@@@std@@YAXPAPAVCvColorInfo@@0AAV?$allocator@PAVCvColorInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvColorInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvColorInfo@@@std@@@std@@YAXPAPAVCvColorInfo@@0AAV?$allocator@PAVCvColorInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvColorInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvPlayerColorInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlayerColorInfo@@0@Z ; std::_Ptr_cat<CvPlayerColorInfo * *,CvPlayerColorInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvPlayerColorInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlayerColorInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvPlayerColorInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlayerColorInfo@@0@Z PROC ; std::_Ptr_cat<CvPlayerColorInfo * *,CvPlayerColorInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvPlayerColorInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlayerColorInfo@@0@Z ENDP ; std::_Ptr_cat<CvPlayerColorInfo * *,CvPlayerColorInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@YAXPAPAVCvPlayerColorInfo@@0AAV?$allocator@PAVCvPlayerColorInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvPlayerColorInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@YAXPAPAVCvPlayerColorInfo@@0AAV?$allocator@PAVCvPlayerColorInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@YAXPAPAVCvPlayerColorInfo@@0AAV?$allocator@PAVCvPlayerColorInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPlayerColorInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@YAXPAPAVCvPlayerColorInfo@@0AAV?$allocator@PAVCvPlayerColorInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPlayerColorInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvTerrainInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTerrainInfo@@0@Z ; std::_Ptr_cat<CvTerrainInfo * *,CvTerrainInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvTerrainInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTerrainInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvTerrainInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTerrainInfo@@0@Z PROC ; std::_Ptr_cat<CvTerrainInfo * *,CvTerrainInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvTerrainInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTerrainInfo@@0@Z ENDP ; std::_Ptr_cat<CvTerrainInfo * *,CvTerrainInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@YAXPAPAVCvTerrainInfo@@0AAV?$allocator@PAVCvTerrainInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvTerrainInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@YAXPAPAVCvTerrainInfo@@0AAV?$allocator@PAVCvTerrainInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@YAXPAPAVCvTerrainInfo@@0AAV?$allocator@PAVCvTerrainInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTerrainInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@YAXPAPAVCvTerrainInfo@@0AAV?$allocator@PAVCvTerrainInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTerrainInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvYieldInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvYieldInfo@@0@Z ; std::_Ptr_cat<CvYieldInfo * *,CvYieldInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvYieldInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvYieldInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvYieldInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvYieldInfo@@0@Z PROC ; std::_Ptr_cat<CvYieldInfo * *,CvYieldInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvYieldInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvYieldInfo@@0@Z ENDP ; std::_Ptr_cat<CvYieldInfo * *,CvYieldInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvYieldInfo@@@std@@@std@@YAXPAPAVCvYieldInfo@@0AAV?$allocator@PAVCvYieldInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvYieldInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvYieldInfo@@@std@@@std@@YAXPAPAVCvYieldInfo@@0AAV?$allocator@PAVCvYieldInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvYieldInfo@@@std@@@std@@YAXPAPAVCvYieldInfo@@0AAV?$allocator@PAVCvYieldInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvYieldInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvYieldInfo@@@std@@@std@@YAXPAPAVCvYieldInfo@@0AAV?$allocator@PAVCvYieldInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvYieldInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvRouteInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvRouteInfo@@0@Z ; std::_Ptr_cat<CvRouteInfo * *,CvRouteInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvRouteInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvRouteInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvRouteInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvRouteInfo@@0@Z PROC ; std::_Ptr_cat<CvRouteInfo * *,CvRouteInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvRouteInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvRouteInfo@@0@Z ENDP ; std::_Ptr_cat<CvRouteInfo * *,CvRouteInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvRouteInfo@@@std@@@std@@YAXPAPAVCvRouteInfo@@0AAV?$allocator@PAVCvRouteInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvRouteInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvRouteInfo@@@std@@@std@@YAXPAPAVCvRouteInfo@@0AAV?$allocator@PAVCvRouteInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvRouteInfo@@@std@@@std@@YAXPAPAVCvRouteInfo@@0AAV?$allocator@PAVCvRouteInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvRouteInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvRouteInfo@@@std@@@std@@YAXPAPAVCvRouteInfo@@0AAV?$allocator@PAVCvRouteInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvRouteInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvFeatureInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvFeatureInfo@@0@Z ; std::_Ptr_cat<CvFeatureInfo * *,CvFeatureInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvFeatureInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvFeatureInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvFeatureInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvFeatureInfo@@0@Z PROC ; std::_Ptr_cat<CvFeatureInfo * *,CvFeatureInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvFeatureInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvFeatureInfo@@0@Z ENDP ; std::_Ptr_cat<CvFeatureInfo * *,CvFeatureInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@YAXPAPAVCvFeatureInfo@@0AAV?$allocator@PAVCvFeatureInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvFeatureInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@YAXPAPAVCvFeatureInfo@@0AAV?$allocator@PAVCvFeatureInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@YAXPAPAVCvFeatureInfo@@0AAV?$allocator@PAVCvFeatureInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvFeatureInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@YAXPAPAVCvFeatureInfo@@0AAV?$allocator@PAVCvFeatureInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvFeatureInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvResourceClassInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvResourceClassInfo@@0@Z ; std::_Ptr_cat<CvResourceClassInfo * *,CvResourceClassInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvResourceClassInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvResourceClassInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvResourceClassInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvResourceClassInfo@@0@Z PROC ; std::_Ptr_cat<CvResourceClassInfo * *,CvResourceClassInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvResourceClassInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvResourceClassInfo@@0@Z ENDP ; std::_Ptr_cat<CvResourceClassInfo * *,CvResourceClassInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@YAXPAPAVCvResourceClassInfo@@0AAV?$allocator@PAVCvResourceClassInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvResourceClassInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@YAXPAPAVCvResourceClassInfo@@0AAV?$allocator@PAVCvResourceClassInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@YAXPAPAVCvResourceClassInfo@@0AAV?$allocator@PAVCvResourceClassInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvResourceClassInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@YAXPAPAVCvResourceClassInfo@@0AAV?$allocator@PAVCvResourceClassInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvResourceClassInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvResourceInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvResourceInfo@@0@Z ; std::_Ptr_cat<CvResourceInfo * *,CvResourceInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvResourceInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvResourceInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvResourceInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvResourceInfo@@0@Z PROC ; std::_Ptr_cat<CvResourceInfo * *,CvResourceInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvResourceInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvResourceInfo@@0@Z ENDP ; std::_Ptr_cat<CvResourceInfo * *,CvResourceInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvResourceInfo@@@std@@@std@@YAXPAPAVCvResourceInfo@@0AAV?$allocator@PAVCvResourceInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvResourceInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvResourceInfo@@@std@@@std@@YAXPAPAVCvResourceInfo@@0AAV?$allocator@PAVCvResourceInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvResourceInfo@@@std@@@std@@YAXPAPAVCvResourceInfo@@0AAV?$allocator@PAVCvResourceInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvResourceInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvResourceInfo@@@std@@@std@@YAXPAPAVCvResourceInfo@@0AAV?$allocator@PAVCvResourceInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvResourceInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvBuildInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBuildInfo@@0@Z ; std::_Ptr_cat<CvBuildInfo * *,CvBuildInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvBuildInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBuildInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvBuildInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBuildInfo@@0@Z PROC ; std::_Ptr_cat<CvBuildInfo * *,CvBuildInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvBuildInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBuildInfo@@0@Z ENDP ; std::_Ptr_cat<CvBuildInfo * *,CvBuildInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvBuildInfo@@@std@@@std@@YAXPAPAVCvBuildInfo@@0AAV?$allocator@PAVCvBuildInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvBuildInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvBuildInfo@@@std@@@std@@YAXPAPAVCvBuildInfo@@0AAV?$allocator@PAVCvBuildInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvBuildInfo@@@std@@@std@@YAXPAPAVCvBuildInfo@@0AAV?$allocator@PAVCvBuildInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvBuildInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvBuildInfo@@@std@@@std@@YAXPAPAVCvBuildInfo@@0AAV?$allocator@PAVCvBuildInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvBuildInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvHandicapInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvHandicapInfo@@0@Z ; std::_Ptr_cat<CvHandicapInfo * *,CvHandicapInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvHandicapInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvHandicapInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvHandicapInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvHandicapInfo@@0@Z PROC ; std::_Ptr_cat<CvHandicapInfo * *,CvHandicapInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvHandicapInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvHandicapInfo@@0@Z ENDP ; std::_Ptr_cat<CvHandicapInfo * *,CvHandicapInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@YAXPAPAVCvHandicapInfo@@0AAV?$allocator@PAVCvHandicapInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvHandicapInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@YAXPAPAVCvHandicapInfo@@0AAV?$allocator@PAVCvHandicapInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@YAXPAPAVCvHandicapInfo@@0AAV?$allocator@PAVCvHandicapInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvHandicapInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@YAXPAPAVCvHandicapInfo@@0AAV?$allocator@PAVCvHandicapInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvHandicapInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvGameSpeedInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvGameSpeedInfo@@0@Z ; std::_Ptr_cat<CvGameSpeedInfo * *,CvGameSpeedInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvGameSpeedInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvGameSpeedInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvGameSpeedInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvGameSpeedInfo@@0@Z PROC ; std::_Ptr_cat<CvGameSpeedInfo * *,CvGameSpeedInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvGameSpeedInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvGameSpeedInfo@@0@Z ENDP ; std::_Ptr_cat<CvGameSpeedInfo * *,CvGameSpeedInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@YAXPAPAVCvGameSpeedInfo@@0AAV?$allocator@PAVCvGameSpeedInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvGameSpeedInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@YAXPAPAVCvGameSpeedInfo@@0AAV?$allocator@PAVCvGameSpeedInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@YAXPAPAVCvGameSpeedInfo@@0AAV?$allocator@PAVCvGameSpeedInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvGameSpeedInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@YAXPAPAVCvGameSpeedInfo@@0AAV?$allocator@PAVCvGameSpeedInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvGameSpeedInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvTurnTimerInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTurnTimerInfo@@0@Z ; std::_Ptr_cat<CvTurnTimerInfo * *,CvTurnTimerInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvTurnTimerInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTurnTimerInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvTurnTimerInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTurnTimerInfo@@0@Z PROC ; std::_Ptr_cat<CvTurnTimerInfo * *,CvTurnTimerInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvTurnTimerInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTurnTimerInfo@@0@Z ENDP ; std::_Ptr_cat<CvTurnTimerInfo * *,CvTurnTimerInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@YAXPAPAVCvTurnTimerInfo@@0AAV?$allocator@PAVCvTurnTimerInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvTurnTimerInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@YAXPAPAVCvTurnTimerInfo@@0AAV?$allocator@PAVCvTurnTimerInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@YAXPAPAVCvTurnTimerInfo@@0AAV?$allocator@PAVCvTurnTimerInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTurnTimerInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@YAXPAPAVCvTurnTimerInfo@@0AAV?$allocator@PAVCvTurnTimerInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTurnTimerInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvCivilizationInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCivilizationInfo@@0@Z ; std::_Ptr_cat<CvCivilizationInfo * *,CvCivilizationInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvCivilizationInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCivilizationInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvCivilizationInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCivilizationInfo@@0@Z PROC ; std::_Ptr_cat<CvCivilizationInfo * *,CvCivilizationInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvCivilizationInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCivilizationInfo@@0@Z ENDP ; std::_Ptr_cat<CvCivilizationInfo * *,CvCivilizationInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@YAXPAPAVCvCivilizationInfo@@0AAV?$allocator@PAVCvCivilizationInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvCivilizationInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@YAXPAPAVCvCivilizationInfo@@0AAV?$allocator@PAVCvCivilizationInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@YAXPAPAVCvCivilizationInfo@@0AAV?$allocator@PAVCvCivilizationInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCivilizationInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@YAXPAPAVCvCivilizationInfo@@0AAV?$allocator@PAVCvCivilizationInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCivilizationInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvMinorCivInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMinorCivInfo@@0@Z ; std::_Ptr_cat<CvMinorCivInfo * *,CvMinorCivInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvMinorCivInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMinorCivInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvMinorCivInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMinorCivInfo@@0@Z PROC ; std::_Ptr_cat<CvMinorCivInfo * *,CvMinorCivInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvMinorCivInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMinorCivInfo@@0@Z ENDP ; std::_Ptr_cat<CvMinorCivInfo * *,CvMinorCivInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@YAXPAPAVCvMinorCivInfo@@0AAV?$allocator@PAVCvMinorCivInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvMinorCivInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@YAXPAPAVCvMinorCivInfo@@0AAV?$allocator@PAVCvMinorCivInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@YAXPAPAVCvMinorCivInfo@@0AAV?$allocator@PAVCvMinorCivInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvMinorCivInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@YAXPAPAVCvMinorCivInfo@@0AAV?$allocator@PAVCvMinorCivInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvMinorCivInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvLeaderHeadInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvLeaderHeadInfo@@0@Z ; std::_Ptr_cat<CvLeaderHeadInfo * *,CvLeaderHeadInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvLeaderHeadInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvLeaderHeadInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvLeaderHeadInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvLeaderHeadInfo@@0@Z PROC ; std::_Ptr_cat<CvLeaderHeadInfo * *,CvLeaderHeadInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvLeaderHeadInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvLeaderHeadInfo@@0@Z ENDP ; std::_Ptr_cat<CvLeaderHeadInfo * *,CvLeaderHeadInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@YAXPAPAVCvLeaderHeadInfo@@0AAV?$allocator@PAVCvLeaderHeadInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvLeaderHeadInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@YAXPAPAVCvLeaderHeadInfo@@0AAV?$allocator@PAVCvLeaderHeadInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@YAXPAPAVCvLeaderHeadInfo@@0AAV?$allocator@PAVCvLeaderHeadInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvLeaderHeadInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@YAXPAPAVCvLeaderHeadInfo@@0AAV?$allocator@PAVCvLeaderHeadInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvLeaderHeadInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvProcessInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvProcessInfo@@0@Z ; std::_Ptr_cat<CvProcessInfo * *,CvProcessInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvProcessInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvProcessInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvProcessInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvProcessInfo@@0@Z PROC ; std::_Ptr_cat<CvProcessInfo * *,CvProcessInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvProcessInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvProcessInfo@@0@Z ENDP ; std::_Ptr_cat<CvProcessInfo * *,CvProcessInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvProcessInfo@@@std@@@std@@YAXPAPAVCvProcessInfo@@0AAV?$allocator@PAVCvProcessInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvProcessInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvProcessInfo@@@std@@@std@@YAXPAPAVCvProcessInfo@@0AAV?$allocator@PAVCvProcessInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvProcessInfo@@@std@@@std@@YAXPAPAVCvProcessInfo@@0AAV?$allocator@PAVCvProcessInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvProcessInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvProcessInfo@@@std@@@std@@YAXPAPAVCvProcessInfo@@0AAV?$allocator@PAVCvProcessInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvProcessInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvVoteInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvVoteInfo@@0@Z ; std::_Ptr_cat<CvVoteInfo * *,CvVoteInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvVoteInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvVoteInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvVoteInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvVoteInfo@@0@Z PROC ; std::_Ptr_cat<CvVoteInfo * *,CvVoteInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvVoteInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvVoteInfo@@0@Z ENDP ; std::_Ptr_cat<CvVoteInfo * *,CvVoteInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvVoteInfo@@@std@@@std@@YAXPAPAVCvVoteInfo@@0AAV?$allocator@PAVCvVoteInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvVoteInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvVoteInfo@@@std@@@std@@YAXPAPAVCvVoteInfo@@0AAV?$allocator@PAVCvVoteInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvVoteInfo@@@std@@@std@@YAXPAPAVCvVoteInfo@@0AAV?$allocator@PAVCvVoteInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvVoteInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvVoteInfo@@@std@@@std@@YAXPAPAVCvVoteInfo@@0AAV?$allocator@PAVCvVoteInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvVoteInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvBuildingClassInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBuildingClassInfo@@0@Z ; std::_Ptr_cat<CvBuildingClassInfo * *,CvBuildingClassInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvBuildingClassInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBuildingClassInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvBuildingClassInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBuildingClassInfo@@0@Z PROC ; std::_Ptr_cat<CvBuildingClassInfo * *,CvBuildingClassInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvBuildingClassInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBuildingClassInfo@@0@Z ENDP ; std::_Ptr_cat<CvBuildingClassInfo * *,CvBuildingClassInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@YAXPAPAVCvBuildingClassInfo@@0AAV?$allocator@PAVCvBuildingClassInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvBuildingClassInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@YAXPAPAVCvBuildingClassInfo@@0AAV?$allocator@PAVCvBuildingClassInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@YAXPAPAVCvBuildingClassInfo@@0AAV?$allocator@PAVCvBuildingClassInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvBuildingClassInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@YAXPAPAVCvBuildingClassInfo@@0AAV?$allocator@PAVCvBuildingClassInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvBuildingClassInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvUnitClassInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvUnitClassInfo@@0@Z ; std::_Ptr_cat<CvUnitClassInfo * *,CvUnitClassInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvUnitClassInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvUnitClassInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvUnitClassInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvUnitClassInfo@@0@Z PROC ; std::_Ptr_cat<CvUnitClassInfo * *,CvUnitClassInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvUnitClassInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvUnitClassInfo@@0@Z ENDP ; std::_Ptr_cat<CvUnitClassInfo * *,CvUnitClassInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@YAXPAPAVCvUnitClassInfo@@0AAV?$allocator@PAVCvUnitClassInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvUnitClassInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@YAXPAPAVCvUnitClassInfo@@0AAV?$allocator@PAVCvUnitClassInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@YAXPAPAVCvUnitClassInfo@@0AAV?$allocator@PAVCvUnitClassInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvUnitClassInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@YAXPAPAVCvUnitClassInfo@@0AAV?$allocator@PAVCvUnitClassInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvUnitClassInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvSpecialUnitInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvSpecialUnitInfo@@0@Z ; std::_Ptr_cat<CvSpecialUnitInfo * *,CvSpecialUnitInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvSpecialUnitInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvSpecialUnitInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvSpecialUnitInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvSpecialUnitInfo@@0@Z PROC ; std::_Ptr_cat<CvSpecialUnitInfo * *,CvSpecialUnitInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvSpecialUnitInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvSpecialUnitInfo@@0@Z ENDP ; std::_Ptr_cat<CvSpecialUnitInfo * *,CvSpecialUnitInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@YAXPAPAVCvSpecialUnitInfo@@0AAV?$allocator@PAVCvSpecialUnitInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvSpecialUnitInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@YAXPAPAVCvSpecialUnitInfo@@0AAV?$allocator@PAVCvSpecialUnitInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@YAXPAPAVCvSpecialUnitInfo@@0AAV?$allocator@PAVCvSpecialUnitInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvSpecialUnitInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@YAXPAPAVCvSpecialUnitInfo@@0AAV?$allocator@PAVCvSpecialUnitInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvSpecialUnitInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvVoteSourceInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvVoteSourceInfo@@0@Z ; std::_Ptr_cat<CvVoteSourceInfo * *,CvVoteSourceInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvVoteSourceInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvVoteSourceInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvVoteSourceInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvVoteSourceInfo@@0@Z PROC ; std::_Ptr_cat<CvVoteSourceInfo * *,CvVoteSourceInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvVoteSourceInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvVoteSourceInfo@@0@Z ENDP ; std::_Ptr_cat<CvVoteSourceInfo * *,CvVoteSourceInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@YAXPAPAVCvVoteSourceInfo@@0AAV?$allocator@PAVCvVoteSourceInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvVoteSourceInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@YAXPAPAVCvVoteSourceInfo@@0AAV?$allocator@PAVCvVoteSourceInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@YAXPAPAVCvVoteSourceInfo@@0AAV?$allocator@PAVCvVoteSourceInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvVoteSourceInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@YAXPAPAVCvVoteSourceInfo@@0AAV?$allocator@PAVCvVoteSourceInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvVoteSourceInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvBaseInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBaseInfo@@0@Z ; std::_Ptr_cat<CvBaseInfo * *,CvBaseInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvBaseInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBaseInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvBaseInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBaseInfo@@0@Z PROC ; std::_Ptr_cat<CvBaseInfo * *,CvBaseInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvBaseInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBaseInfo@@0@Z ENDP ; std::_Ptr_cat<CvBaseInfo * *,CvBaseInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvBaseInfo@@@std@@@std@@YAXPAPAVCvBaseInfo@@0AAV?$allocator@PAVCvBaseInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvBaseInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvBaseInfo@@@std@@@std@@YAXPAPAVCvBaseInfo@@0AAV?$allocator@PAVCvBaseInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvBaseInfo@@@std@@@std@@YAXPAPAVCvBaseInfo@@0AAV?$allocator@PAVCvBaseInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvBaseInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvBaseInfo@@@std@@@std@@YAXPAPAVCvBaseInfo@@0AAV?$allocator@PAVCvBaseInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvBaseInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvGameOptionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvGameOptionInfo@@0@Z ; std::_Ptr_cat<CvGameOptionInfo * *,CvGameOptionInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvGameOptionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvGameOptionInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvGameOptionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvGameOptionInfo@@0@Z PROC ; std::_Ptr_cat<CvGameOptionInfo * *,CvGameOptionInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvGameOptionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvGameOptionInfo@@0@Z ENDP ; std::_Ptr_cat<CvGameOptionInfo * *,CvGameOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@YAXPAPAVCvGameOptionInfo@@0AAV?$allocator@PAVCvGameOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvGameOptionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@YAXPAPAVCvGameOptionInfo@@0AAV?$allocator@PAVCvGameOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@YAXPAPAVCvGameOptionInfo@@0AAV?$allocator@PAVCvGameOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvGameOptionInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@YAXPAPAVCvGameOptionInfo@@0AAV?$allocator@PAVCvGameOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvGameOptionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvMPOptionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMPOptionInfo@@0@Z ; std::_Ptr_cat<CvMPOptionInfo * *,CvMPOptionInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvMPOptionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMPOptionInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvMPOptionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMPOptionInfo@@0@Z PROC ; std::_Ptr_cat<CvMPOptionInfo * *,CvMPOptionInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvMPOptionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMPOptionInfo@@0@Z ENDP ; std::_Ptr_cat<CvMPOptionInfo * *,CvMPOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@YAXPAPAVCvMPOptionInfo@@0AAV?$allocator@PAVCvMPOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvMPOptionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@YAXPAPAVCvMPOptionInfo@@0AAV?$allocator@PAVCvMPOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@YAXPAPAVCvMPOptionInfo@@0AAV?$allocator@PAVCvMPOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvMPOptionInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@YAXPAPAVCvMPOptionInfo@@0AAV?$allocator@PAVCvMPOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvMPOptionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvPlayerOptionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlayerOptionInfo@@0@Z ; std::_Ptr_cat<CvPlayerOptionInfo * *,CvPlayerOptionInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvPlayerOptionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlayerOptionInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvPlayerOptionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlayerOptionInfo@@0@Z PROC ; std::_Ptr_cat<CvPlayerOptionInfo * *,CvPlayerOptionInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvPlayerOptionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlayerOptionInfo@@0@Z ENDP ; std::_Ptr_cat<CvPlayerOptionInfo * *,CvPlayerOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@YAXPAPAVCvPlayerOptionInfo@@0AAV?$allocator@PAVCvPlayerOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvPlayerOptionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@YAXPAPAVCvPlayerOptionInfo@@0AAV?$allocator@PAVCvPlayerOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@YAXPAPAVCvPlayerOptionInfo@@0AAV?$allocator@PAVCvPlayerOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPlayerOptionInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@YAXPAPAVCvPlayerOptionInfo@@0AAV?$allocator@PAVCvPlayerOptionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPlayerOptionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvSpecialistInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvSpecialistInfo@@0@Z ; std::_Ptr_cat<CvSpecialistInfo * *,CvSpecialistInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvSpecialistInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvSpecialistInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvSpecialistInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvSpecialistInfo@@0@Z PROC ; std::_Ptr_cat<CvSpecialistInfo * *,CvSpecialistInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvSpecialistInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvSpecialistInfo@@0@Z ENDP ; std::_Ptr_cat<CvSpecialistInfo * *,CvSpecialistInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@YAXPAPAVCvSpecialistInfo@@0AAV?$allocator@PAVCvSpecialistInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvSpecialistInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@YAXPAPAVCvSpecialistInfo@@0AAV?$allocator@PAVCvSpecialistInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@YAXPAPAVCvSpecialistInfo@@0AAV?$allocator@PAVCvSpecialistInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvSpecialistInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@YAXPAPAVCvSpecialistInfo@@0AAV?$allocator@PAVCvSpecialistInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvSpecialistInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvActionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvActionInfo@@0@Z ; std::_Ptr_cat<CvActionInfo * *,CvActionInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvActionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvActionInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvActionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvActionInfo@@0@Z PROC ; std::_Ptr_cat<CvActionInfo * *,CvActionInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvActionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvActionInfo@@0@Z ENDP ; std::_Ptr_cat<CvActionInfo * *,CvActionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvActionInfo@@@std@@@std@@YAXPAPAVCvActionInfo@@0AAV?$allocator@PAVCvActionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvActionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvActionInfo@@@std@@@std@@YAXPAPAVCvActionInfo@@0AAV?$allocator@PAVCvActionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvActionInfo@@@std@@@std@@YAXPAPAVCvActionInfo@@0AAV?$allocator@PAVCvActionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvActionInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvActionInfo@@@std@@@std@@YAXPAPAVCvActionInfo@@0AAV?$allocator@PAVCvActionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvActionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvMissionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMissionInfo@@0@Z ; std::_Ptr_cat<CvMissionInfo * *,CvMissionInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvMissionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMissionInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvMissionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMissionInfo@@0@Z PROC ; std::_Ptr_cat<CvMissionInfo * *,CvMissionInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvMissionInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMissionInfo@@0@Z ENDP ; std::_Ptr_cat<CvMissionInfo * *,CvMissionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvMissionInfo@@@std@@@std@@YAXPAPAVCvMissionInfo@@0AAV?$allocator@PAVCvMissionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvMissionInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvMissionInfo@@@std@@@std@@YAXPAPAVCvMissionInfo@@0AAV?$allocator@PAVCvMissionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvMissionInfo@@@std@@@std@@YAXPAPAVCvMissionInfo@@0AAV?$allocator@PAVCvMissionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvMissionInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvMissionInfo@@@std@@@std@@YAXPAPAVCvMissionInfo@@0AAV?$allocator@PAVCvMissionInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvMissionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvControlInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvControlInfo@@0@Z ; std::_Ptr_cat<CvControlInfo * *,CvControlInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvControlInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvControlInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvControlInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvControlInfo@@0@Z PROC ; std::_Ptr_cat<CvControlInfo * *,CvControlInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvControlInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvControlInfo@@0@Z ENDP ; std::_Ptr_cat<CvControlInfo * *,CvControlInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvControlInfo@@@std@@@std@@YAXPAPAVCvControlInfo@@0AAV?$allocator@PAVCvControlInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvControlInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvControlInfo@@@std@@@std@@YAXPAPAVCvControlInfo@@0AAV?$allocator@PAVCvControlInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvControlInfo@@@std@@@std@@YAXPAPAVCvControlInfo@@0AAV?$allocator@PAVCvControlInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvControlInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvControlInfo@@@std@@@std@@YAXPAPAVCvControlInfo@@0AAV?$allocator@PAVCvControlInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvControlInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvCommandInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCommandInfo@@0@Z ; std::_Ptr_cat<CvCommandInfo * *,CvCommandInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvCommandInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCommandInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvCommandInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCommandInfo@@0@Z PROC ; std::_Ptr_cat<CvCommandInfo * *,CvCommandInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvCommandInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCommandInfo@@0@Z ENDP ; std::_Ptr_cat<CvCommandInfo * *,CvCommandInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCommandInfo@@@std@@@std@@YAXPAPAVCvCommandInfo@@0AAV?$allocator@PAVCvCommandInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvCommandInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCommandInfo@@@std@@@std@@YAXPAPAVCvCommandInfo@@0AAV?$allocator@PAVCvCommandInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvCommandInfo@@@std@@@std@@YAXPAPAVCvCommandInfo@@0AAV?$allocator@PAVCvCommandInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCommandInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCommandInfo@@@std@@@std@@YAXPAPAVCvCommandInfo@@0AAV?$allocator@PAVCvCommandInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCommandInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvAutomateInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvAutomateInfo@@0@Z ; std::_Ptr_cat<CvAutomateInfo * *,CvAutomateInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvAutomateInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvAutomateInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvAutomateInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvAutomateInfo@@0@Z PROC ; std::_Ptr_cat<CvAutomateInfo * *,CvAutomateInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvAutomateInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvAutomateInfo@@0@Z ENDP ; std::_Ptr_cat<CvAutomateInfo * *,CvAutomateInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@YAXPAPAVCvAutomateInfo@@0AAV?$allocator@PAVCvAutomateInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvAutomateInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@YAXPAPAVCvAutomateInfo@@0AAV?$allocator@PAVCvAutomateInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@YAXPAPAVCvAutomateInfo@@0AAV?$allocator@PAVCvAutomateInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvAutomateInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@YAXPAPAVCvAutomateInfo@@0AAV?$allocator@PAVCvAutomateInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvAutomateInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvEraInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEraInfo@@0@Z ; std::_Ptr_cat<CvEraInfo * *,CvEraInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvEraInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEraInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvEraInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEraInfo@@0@Z PROC ; std::_Ptr_cat<CvEraInfo * *,CvEraInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvEraInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEraInfo@@0@Z ENDP ; std::_Ptr_cat<CvEraInfo * *,CvEraInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvEraInfo@@@std@@@std@@YAXPAPAVCvEraInfo@@0AAV?$allocator@PAVCvEraInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvEraInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvEraInfo@@@std@@@std@@YAXPAPAVCvEraInfo@@0AAV?$allocator@PAVCvEraInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvEraInfo@@@std@@@std@@YAXPAPAVCvEraInfo@@0AAV?$allocator@PAVCvEraInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvEraInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvEraInfo@@@std@@@std@@YAXPAPAVCvEraInfo@@0AAV?$allocator@PAVCvEraInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvEraInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvHurryInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvHurryInfo@@0@Z ; std::_Ptr_cat<CvHurryInfo * *,CvHurryInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvHurryInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvHurryInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvHurryInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvHurryInfo@@0@Z PROC ; std::_Ptr_cat<CvHurryInfo * *,CvHurryInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvHurryInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvHurryInfo@@0@Z ENDP ; std::_Ptr_cat<CvHurryInfo * *,CvHurryInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvHurryInfo@@@std@@@std@@YAXPAPAVCvHurryInfo@@0AAV?$allocator@PAVCvHurryInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvHurryInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvHurryInfo@@@std@@@std@@YAXPAPAVCvHurryInfo@@0AAV?$allocator@PAVCvHurryInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvHurryInfo@@@std@@@std@@YAXPAPAVCvHurryInfo@@0AAV?$allocator@PAVCvHurryInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvHurryInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvHurryInfo@@@std@@@std@@YAXPAPAVCvHurryInfo@@0AAV?$allocator@PAVCvHurryInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvHurryInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvVictoryInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvVictoryInfo@@0@Z ; std::_Ptr_cat<CvVictoryInfo * *,CvVictoryInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvVictoryInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvVictoryInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvVictoryInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvVictoryInfo@@0@Z PROC ; std::_Ptr_cat<CvVictoryInfo * *,CvVictoryInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvVictoryInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvVictoryInfo@@0@Z ENDP ; std::_Ptr_cat<CvVictoryInfo * *,CvVictoryInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@YAXPAPAVCvVictoryInfo@@0AAV?$allocator@PAVCvVictoryInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvVictoryInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@YAXPAPAVCvVictoryInfo@@0AAV?$allocator@PAVCvVictoryInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@YAXPAPAVCvVictoryInfo@@0AAV?$allocator@PAVCvVictoryInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvVictoryInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@YAXPAPAVCvVictoryInfo@@0AAV?$allocator@PAVCvVictoryInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvVictoryInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvSmallAwardInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvSmallAwardInfo@@0@Z ; std::_Ptr_cat<CvSmallAwardInfo * *,CvSmallAwardInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvSmallAwardInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvSmallAwardInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvSmallAwardInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvSmallAwardInfo@@0@Z PROC ; std::_Ptr_cat<CvSmallAwardInfo * *,CvSmallAwardInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvSmallAwardInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvSmallAwardInfo@@0@Z ENDP ; std::_Ptr_cat<CvSmallAwardInfo * *,CvSmallAwardInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@YAXPAPAVCvSmallAwardInfo@@0AAV?$allocator@PAVCvSmallAwardInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvSmallAwardInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@YAXPAPAVCvSmallAwardInfo@@0AAV?$allocator@PAVCvSmallAwardInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@YAXPAPAVCvSmallAwardInfo@@0AAV?$allocator@PAVCvSmallAwardInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvSmallAwardInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@YAXPAPAVCvSmallAwardInfo@@0AAV?$allocator@PAVCvSmallAwardInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvSmallAwardInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvEntityEventInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEntityEventInfo@@0@Z ; std::_Ptr_cat<CvEntityEventInfo * *,CvEntityEventInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvEntityEventInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEntityEventInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvEntityEventInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEntityEventInfo@@0@Z PROC ; std::_Ptr_cat<CvEntityEventInfo * *,CvEntityEventInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvEntityEventInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEntityEventInfo@@0@Z ENDP ; std::_Ptr_cat<CvEntityEventInfo * *,CvEntityEventInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@YAXPAPAVCvEntityEventInfo@@0AAV?$allocator@PAVCvEntityEventInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvEntityEventInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@YAXPAPAVCvEntityEventInfo@@0AAV?$allocator@PAVCvEntityEventInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@YAXPAPAVCvEntityEventInfo@@0AAV?$allocator@PAVCvEntityEventInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvEntityEventInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@YAXPAPAVCvEntityEventInfo@@0AAV?$allocator@PAVCvEntityEventInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvEntityEventInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvMultiUnitFormationInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMultiUnitFormationInfo@@0@Z ; std::_Ptr_cat<CvMultiUnitFormationInfo * *,CvMultiUnitFormationInfo * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvMultiUnitFormationInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMultiUnitFormationInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvMultiUnitFormationInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMultiUnitFormationInfo@@0@Z PROC ; std::_Ptr_cat<CvMultiUnitFormationInfo * *,CvMultiUnitFormationInfo * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvMultiUnitFormationInfo@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMultiUnitFormationInfo@@0@Z ENDP ; std::_Ptr_cat<CvMultiUnitFormationInfo * *,CvMultiUnitFormationInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@YAXPAPAVCvMultiUnitFormationInfo@@0AAV?$allocator@PAVCvMultiUnitFormationInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvMultiUnitFormationInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@YAXPAPAVCvMultiUnitFormationInfo@@0AAV?$allocator@PAVCvMultiUnitFormationInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@YAXPAPAVCvMultiUnitFormationInfo@@0AAV?$allocator@PAVCvMultiUnitFormationInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvMultiUnitFormationInfo *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@YAXPAPAVCvMultiUnitFormationInfo@@0AAV?$allocator@PAVCvMultiUnitFormationInfo@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvMultiUnitFormationInfo *> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0@Z ; std::_Ptr_cat<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0@Z PROC ; std::_Ptr_cat<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0@Z ENDP ; std::_Ptr_cat<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z ; std::_Iter_cat<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z PROC ; std::_Iter_cat<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0> >, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z ENDP ; std::_Iter_cat<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0@Z ; std::_Iter_random<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0@Z PROC ; std::_Iter_random<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0@Z ENDP ; std::_Iter_random<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@Urandom_access_iterator_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@Urandom_access_iterator_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@Urandom_access_iterator_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@Urandom_access_iterator_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0ABV120@@Z ; std::_Fill<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0ABV120@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0ABV120@@Z PROC ; std::_Fill<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0ABV120@@Z ENDP ; std::_Fill<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YA?AU_Undefined_move_tag@0@ABQAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z ; std::_Move_cat<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YA?AU_Undefined_move_tag@0@ABQAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YA?AU_Undefined_move_tag@0@ABQAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z PROC ; std::_Move_cat<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YA?AU_Undefined_move_tag@0@ABQAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z ENDP ; std::_Move_cat<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??1CvGameOptionInfo@@QAE@XZ			; CvGameOptionInfo::~CvGameOptionInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvGameOptionInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvGameOptionInfo@@QAE@XZ PROC			; CvGameOptionInfo::~CvGameOptionInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvGameOptionInfo@@QAE@XZ ENDP			; CvGameOptionInfo::~CvGameOptionInfo
_TEXT	ENDS
PUBLIC	??1CvMPOptionInfo@@QAE@XZ			; CvMPOptionInfo::~CvMPOptionInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvMPOptionInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvMPOptionInfo@@QAE@XZ PROC				; CvMPOptionInfo::~CvMPOptionInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvMPOptionInfo@@QAE@XZ ENDP				; CvMPOptionInfo::~CvMPOptionInfo
_TEXT	ENDS
PUBLIC	??1CvPlayerOptionInfo@@QAE@XZ			; CvPlayerOptionInfo::~CvPlayerOptionInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvPlayerOptionInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvPlayerOptionInfo@@QAE@XZ PROC			; CvPlayerOptionInfo::~CvPlayerOptionInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvPlayerOptionInfo@@QAE@XZ ENDP			; CvPlayerOptionInfo::~CvPlayerOptionInfo
_TEXT	ENDS
PUBLIC	??1CvYieldInfo@@QAE@XZ				; CvYieldInfo::~CvYieldInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvYieldInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvYieldInfo@@QAE@XZ PROC				; CvYieldInfo::~CvYieldInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvYieldInfo@@QAE@XZ ENDP				; CvYieldInfo::~CvYieldInfo
_TEXT	ENDS
PUBLIC	??1CvResourceClassInfo@@QAE@XZ			; CvResourceClassInfo::~CvResourceClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvResourceClassInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvResourceClassInfo@@QAE@XZ PROC			; CvResourceClassInfo::~CvResourceClassInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvResourceClassInfo@@QAE@XZ ENDP			; CvResourceClassInfo::~CvResourceClassInfo
_TEXT	ENDS
PUBLIC	??1CvHotKeyInfo@@QAE@XZ				; CvHotKeyInfo::~CvHotKeyInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvHotKeyInfo@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1CvHotKeyInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvHotKeyInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$5
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvHotKeyInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvHotKeyInfo@@QAE@XZ PROC				; CvHotKeyInfo::~CvHotKeyInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvHotKeyInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+432]
	mov	DWORD PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+404]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+376]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+348]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+320]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+292]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 320				; 00000140H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 348				; 0000015cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvHotKeyInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvHotKeyInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvHotKeyInfo@@QAE@XZ ENDP				; CvHotKeyInfo::~CvHotKeyInfo
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@I@Z ; std::allocator<enum AnimationPathTypes>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@I@Z PROC ; std::allocator<enum AnimationPathTypes>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@I@Z ENDP ; std::allocator<enum AnimationPathTypes>::deallocate
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@Urandom_access_iterator_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@Urandom_access_iterator_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@Urandom_access_iterator_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@Urandom_access_iterator_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvInterfaceModeInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvInterfaceModeInfo@@0@Z ; std::_Iter_random<CvInterfaceModeInfo * *,CvInterfaceModeInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvInterfaceModeInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvInterfaceModeInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvInterfaceModeInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvInterfaceModeInfo@@0@Z PROC ; std::_Iter_random<CvInterfaceModeInfo * *,CvInterfaceModeInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvInterfaceModeInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvInterfaceModeInfo@@0@Z ENDP ; std::_Iter_random<CvInterfaceModeInfo * *,CvInterfaceModeInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvInterfaceModeInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvInterfaceModeInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvInterfaceModeInfo * *,CvInterfaceModeInfo * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvInterfaceModeInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvInterfaceModeInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvInterfaceModeInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvInterfaceModeInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvInterfaceModeInfo * *,CvInterfaceModeInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@2:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvInterfaceModeInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvInterfaceModeInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvInterfaceModeInfo * *,CvInterfaceModeInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvColorInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvColorInfo@@0@Z ; std::_Iter_random<CvColorInfo * *,CvColorInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvColorInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvColorInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvColorInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvColorInfo@@0@Z PROC ; std::_Iter_random<CvColorInfo * *,CvColorInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvColorInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvColorInfo@@0@Z ENDP ; std::_Iter_random<CvColorInfo * *,CvColorInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvColorInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvColorInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvColorInfo * *,CvColorInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvColorInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvColorInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvColorInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvColorInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvColorInfo * *,CvColorInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@3

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@3:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvColorInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvColorInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvColorInfo * *,CvColorInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvPlayerColorInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlayerColorInfo@@0@Z ; std::_Iter_random<CvPlayerColorInfo * *,CvPlayerColorInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvPlayerColorInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlayerColorInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvPlayerColorInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlayerColorInfo@@0@Z PROC ; std::_Iter_random<CvPlayerColorInfo * *,CvPlayerColorInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvPlayerColorInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlayerColorInfo@@0@Z ENDP ; std::_Iter_random<CvPlayerColorInfo * *,CvPlayerColorInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvPlayerColorInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlayerColorInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPlayerColorInfo * *,CvPlayerColorInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvPlayerColorInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlayerColorInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvPlayerColorInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlayerColorInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvPlayerColorInfo * *,CvPlayerColorInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@4

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@4:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvPlayerColorInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlayerColorInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvPlayerColorInfo * *,CvPlayerColorInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvTerrainInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTerrainInfo@@0@Z ; std::_Iter_random<CvTerrainInfo * *,CvTerrainInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvTerrainInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTerrainInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvTerrainInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTerrainInfo@@0@Z PROC ; std::_Iter_random<CvTerrainInfo * *,CvTerrainInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvTerrainInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTerrainInfo@@0@Z ENDP ; std::_Iter_random<CvTerrainInfo * *,CvTerrainInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvTerrainInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTerrainInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTerrainInfo * *,CvTerrainInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvTerrainInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTerrainInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvTerrainInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTerrainInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTerrainInfo * *,CvTerrainInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@5

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@5:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvTerrainInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTerrainInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTerrainInfo * *,CvTerrainInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvYieldInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvYieldInfo@@0@Z ; std::_Iter_random<CvYieldInfo * *,CvYieldInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvYieldInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvYieldInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvYieldInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvYieldInfo@@0@Z PROC ; std::_Iter_random<CvYieldInfo * *,CvYieldInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvYieldInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvYieldInfo@@0@Z ENDP ; std::_Iter_random<CvYieldInfo * *,CvYieldInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvYieldInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvYieldInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvYieldInfo * *,CvYieldInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvYieldInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvYieldInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvYieldInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvYieldInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvYieldInfo * *,CvYieldInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@6

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@6:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvYieldInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvYieldInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvYieldInfo * *,CvYieldInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvRouteInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvRouteInfo@@0@Z ; std::_Iter_random<CvRouteInfo * *,CvRouteInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvRouteInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvRouteInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvRouteInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvRouteInfo@@0@Z PROC ; std::_Iter_random<CvRouteInfo * *,CvRouteInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvRouteInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvRouteInfo@@0@Z ENDP ; std::_Iter_random<CvRouteInfo * *,CvRouteInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvRouteInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvRouteInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvRouteInfo * *,CvRouteInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvRouteInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvRouteInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvRouteInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvRouteInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvRouteInfo * *,CvRouteInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@7

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@7:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvRouteInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvRouteInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvRouteInfo * *,CvRouteInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvFeatureInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvFeatureInfo@@0@Z ; std::_Iter_random<CvFeatureInfo * *,CvFeatureInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvFeatureInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvFeatureInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvFeatureInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvFeatureInfo@@0@Z PROC ; std::_Iter_random<CvFeatureInfo * *,CvFeatureInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvFeatureInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvFeatureInfo@@0@Z ENDP ; std::_Iter_random<CvFeatureInfo * *,CvFeatureInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvFeatureInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvFeatureInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvFeatureInfo * *,CvFeatureInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvFeatureInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvFeatureInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvFeatureInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvFeatureInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvFeatureInfo * *,CvFeatureInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@8

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@8:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvFeatureInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvFeatureInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvFeatureInfo * *,CvFeatureInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvResourceClassInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvResourceClassInfo@@0@Z ; std::_Iter_random<CvResourceClassInfo * *,CvResourceClassInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvResourceClassInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvResourceClassInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvResourceClassInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvResourceClassInfo@@0@Z PROC ; std::_Iter_random<CvResourceClassInfo * *,CvResourceClassInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvResourceClassInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvResourceClassInfo@@0@Z ENDP ; std::_Iter_random<CvResourceClassInfo * *,CvResourceClassInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvResourceClassInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvResourceClassInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvResourceClassInfo * *,CvResourceClassInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvResourceClassInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvResourceClassInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvResourceClassInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvResourceClassInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvResourceClassInfo * *,CvResourceClassInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@9

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@9:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvResourceClassInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvResourceClassInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvResourceClassInfo * *,CvResourceClassInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvResourceInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvResourceInfo@@0@Z ; std::_Iter_random<CvResourceInfo * *,CvResourceInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvResourceInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvResourceInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvResourceInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvResourceInfo@@0@Z PROC ; std::_Iter_random<CvResourceInfo * *,CvResourceInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvResourceInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvResourceInfo@@0@Z ENDP ; std::_Iter_random<CvResourceInfo * *,CvResourceInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvResourceInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvResourceInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvResourceInfo * *,CvResourceInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvResourceInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvResourceInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvResourceInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvResourceInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvResourceInfo * *,CvResourceInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@10

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@10:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvResourceInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvResourceInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvResourceInfo * *,CvResourceInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvBuildInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBuildInfo@@0@Z ; std::_Iter_random<CvBuildInfo * *,CvBuildInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvBuildInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBuildInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvBuildInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBuildInfo@@0@Z PROC ; std::_Iter_random<CvBuildInfo * *,CvBuildInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvBuildInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBuildInfo@@0@Z ENDP ; std::_Iter_random<CvBuildInfo * *,CvBuildInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvBuildInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBuildInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvBuildInfo * *,CvBuildInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvBuildInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBuildInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvBuildInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBuildInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvBuildInfo * *,CvBuildInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@11

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@11:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvBuildInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBuildInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvBuildInfo * *,CvBuildInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvHandicapInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvHandicapInfo@@0@Z ; std::_Iter_random<CvHandicapInfo * *,CvHandicapInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvHandicapInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvHandicapInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvHandicapInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvHandicapInfo@@0@Z PROC ; std::_Iter_random<CvHandicapInfo * *,CvHandicapInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvHandicapInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvHandicapInfo@@0@Z ENDP ; std::_Iter_random<CvHandicapInfo * *,CvHandicapInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvHandicapInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvHandicapInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHandicapInfo * *,CvHandicapInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvHandicapInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvHandicapInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvHandicapInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvHandicapInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvHandicapInfo * *,CvHandicapInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@12

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@12:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvHandicapInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvHandicapInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvHandicapInfo * *,CvHandicapInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvGameSpeedInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvGameSpeedInfo@@0@Z ; std::_Iter_random<CvGameSpeedInfo * *,CvGameSpeedInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvGameSpeedInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvGameSpeedInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvGameSpeedInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvGameSpeedInfo@@0@Z PROC ; std::_Iter_random<CvGameSpeedInfo * *,CvGameSpeedInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvGameSpeedInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvGameSpeedInfo@@0@Z ENDP ; std::_Iter_random<CvGameSpeedInfo * *,CvGameSpeedInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvGameSpeedInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvGameSpeedInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvGameSpeedInfo * *,CvGameSpeedInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvGameSpeedInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvGameSpeedInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvGameSpeedInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvGameSpeedInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvGameSpeedInfo * *,CvGameSpeedInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@13

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@13:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvGameSpeedInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvGameSpeedInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvGameSpeedInfo * *,CvGameSpeedInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvTurnTimerInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTurnTimerInfo@@0@Z ; std::_Iter_random<CvTurnTimerInfo * *,CvTurnTimerInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvTurnTimerInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTurnTimerInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvTurnTimerInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTurnTimerInfo@@0@Z PROC ; std::_Iter_random<CvTurnTimerInfo * *,CvTurnTimerInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvTurnTimerInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTurnTimerInfo@@0@Z ENDP ; std::_Iter_random<CvTurnTimerInfo * *,CvTurnTimerInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvTurnTimerInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTurnTimerInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTurnTimerInfo * *,CvTurnTimerInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvTurnTimerInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTurnTimerInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvTurnTimerInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTurnTimerInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTurnTimerInfo * *,CvTurnTimerInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@14

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@14:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvTurnTimerInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTurnTimerInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTurnTimerInfo * *,CvTurnTimerInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvCivilizationInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCivilizationInfo@@0@Z ; std::_Iter_random<CvCivilizationInfo * *,CvCivilizationInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvCivilizationInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCivilizationInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvCivilizationInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCivilizationInfo@@0@Z PROC ; std::_Iter_random<CvCivilizationInfo * *,CvCivilizationInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvCivilizationInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCivilizationInfo@@0@Z ENDP ; std::_Iter_random<CvCivilizationInfo * *,CvCivilizationInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvCivilizationInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCivilizationInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvCivilizationInfo * *,CvCivilizationInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvCivilizationInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCivilizationInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvCivilizationInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCivilizationInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvCivilizationInfo * *,CvCivilizationInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@15

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@15:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvCivilizationInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCivilizationInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvCivilizationInfo * *,CvCivilizationInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvMinorCivInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMinorCivInfo@@0@Z ; std::_Iter_random<CvMinorCivInfo * *,CvMinorCivInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvMinorCivInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMinorCivInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvMinorCivInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMinorCivInfo@@0@Z PROC ; std::_Iter_random<CvMinorCivInfo * *,CvMinorCivInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvMinorCivInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMinorCivInfo@@0@Z ENDP ; std::_Iter_random<CvMinorCivInfo * *,CvMinorCivInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvMinorCivInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMinorCivInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvMinorCivInfo * *,CvMinorCivInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvMinorCivInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMinorCivInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvMinorCivInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMinorCivInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvMinorCivInfo * *,CvMinorCivInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@16

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@16:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvMinorCivInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMinorCivInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvMinorCivInfo * *,CvMinorCivInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvLeaderHeadInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvLeaderHeadInfo@@0@Z ; std::_Iter_random<CvLeaderHeadInfo * *,CvLeaderHeadInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvLeaderHeadInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvLeaderHeadInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvLeaderHeadInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvLeaderHeadInfo@@0@Z PROC ; std::_Iter_random<CvLeaderHeadInfo * *,CvLeaderHeadInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvLeaderHeadInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvLeaderHeadInfo@@0@Z ENDP ; std::_Iter_random<CvLeaderHeadInfo * *,CvLeaderHeadInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvLeaderHeadInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvLeaderHeadInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvLeaderHeadInfo * *,CvLeaderHeadInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvLeaderHeadInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvLeaderHeadInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvLeaderHeadInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvLeaderHeadInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvLeaderHeadInfo * *,CvLeaderHeadInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@17

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@17:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvLeaderHeadInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvLeaderHeadInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvLeaderHeadInfo * *,CvLeaderHeadInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvProcessInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvProcessInfo@@0@Z ; std::_Iter_random<CvProcessInfo * *,CvProcessInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvProcessInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvProcessInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvProcessInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvProcessInfo@@0@Z PROC ; std::_Iter_random<CvProcessInfo * *,CvProcessInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvProcessInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvProcessInfo@@0@Z ENDP ; std::_Iter_random<CvProcessInfo * *,CvProcessInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvProcessInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvProcessInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvProcessInfo * *,CvProcessInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvProcessInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvProcessInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvProcessInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvProcessInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvProcessInfo * *,CvProcessInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@18

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@18:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvProcessInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvProcessInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvProcessInfo * *,CvProcessInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvVoteInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvVoteInfo@@0@Z ; std::_Iter_random<CvVoteInfo * *,CvVoteInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvVoteInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvVoteInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvVoteInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvVoteInfo@@0@Z PROC ; std::_Iter_random<CvVoteInfo * *,CvVoteInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvVoteInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvVoteInfo@@0@Z ENDP ; std::_Iter_random<CvVoteInfo * *,CvVoteInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvVoteInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvVoteInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvVoteInfo * *,CvVoteInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvVoteInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvVoteInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvVoteInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvVoteInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvVoteInfo * *,CvVoteInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@19

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@19:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvVoteInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvVoteInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvVoteInfo * *,CvVoteInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvBuildingClassInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBuildingClassInfo@@0@Z ; std::_Iter_random<CvBuildingClassInfo * *,CvBuildingClassInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvBuildingClassInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBuildingClassInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvBuildingClassInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBuildingClassInfo@@0@Z PROC ; std::_Iter_random<CvBuildingClassInfo * *,CvBuildingClassInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvBuildingClassInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBuildingClassInfo@@0@Z ENDP ; std::_Iter_random<CvBuildingClassInfo * *,CvBuildingClassInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvBuildingClassInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBuildingClassInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvBuildingClassInfo * *,CvBuildingClassInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvBuildingClassInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBuildingClassInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvBuildingClassInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBuildingClassInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvBuildingClassInfo * *,CvBuildingClassInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@20

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@20:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvBuildingClassInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBuildingClassInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvBuildingClassInfo * *,CvBuildingClassInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvUnitClassInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvUnitClassInfo@@0@Z ; std::_Iter_random<CvUnitClassInfo * *,CvUnitClassInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvUnitClassInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvUnitClassInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvUnitClassInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvUnitClassInfo@@0@Z PROC ; std::_Iter_random<CvUnitClassInfo * *,CvUnitClassInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvUnitClassInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvUnitClassInfo@@0@Z ENDP ; std::_Iter_random<CvUnitClassInfo * *,CvUnitClassInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvUnitClassInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvUnitClassInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvUnitClassInfo * *,CvUnitClassInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvUnitClassInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvUnitClassInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvUnitClassInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvUnitClassInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvUnitClassInfo * *,CvUnitClassInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@21

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@21:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvUnitClassInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvUnitClassInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvUnitClassInfo * *,CvUnitClassInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvSpecialUnitInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvSpecialUnitInfo@@0@Z ; std::_Iter_random<CvSpecialUnitInfo * *,CvSpecialUnitInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvSpecialUnitInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvSpecialUnitInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvSpecialUnitInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvSpecialUnitInfo@@0@Z PROC ; std::_Iter_random<CvSpecialUnitInfo * *,CvSpecialUnitInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvSpecialUnitInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvSpecialUnitInfo@@0@Z ENDP ; std::_Iter_random<CvSpecialUnitInfo * *,CvSpecialUnitInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvSpecialUnitInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvSpecialUnitInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvSpecialUnitInfo * *,CvSpecialUnitInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvSpecialUnitInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvSpecialUnitInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvSpecialUnitInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvSpecialUnitInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvSpecialUnitInfo * *,CvSpecialUnitInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@22

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@22:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvSpecialUnitInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvSpecialUnitInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvSpecialUnitInfo * *,CvSpecialUnitInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvVoteSourceInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvVoteSourceInfo@@0@Z ; std::_Iter_random<CvVoteSourceInfo * *,CvVoteSourceInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvVoteSourceInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvVoteSourceInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvVoteSourceInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvVoteSourceInfo@@0@Z PROC ; std::_Iter_random<CvVoteSourceInfo * *,CvVoteSourceInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvVoteSourceInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvVoteSourceInfo@@0@Z ENDP ; std::_Iter_random<CvVoteSourceInfo * *,CvVoteSourceInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvVoteSourceInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvVoteSourceInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvVoteSourceInfo * *,CvVoteSourceInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvVoteSourceInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvVoteSourceInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvVoteSourceInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvVoteSourceInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvVoteSourceInfo * *,CvVoteSourceInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@23

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@23:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvVoteSourceInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvVoteSourceInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvVoteSourceInfo * *,CvVoteSourceInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvBaseInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBaseInfo@@0@Z ; std::_Iter_random<CvBaseInfo * *,CvBaseInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvBaseInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBaseInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvBaseInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBaseInfo@@0@Z PROC ; std::_Iter_random<CvBaseInfo * *,CvBaseInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvBaseInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBaseInfo@@0@Z ENDP ; std::_Iter_random<CvBaseInfo * *,CvBaseInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvBaseInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBaseInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvBaseInfo * *,CvBaseInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvBaseInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBaseInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvBaseInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBaseInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvBaseInfo * *,CvBaseInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@24

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@24:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvBaseInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBaseInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvBaseInfo * *,CvBaseInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvGameOptionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvGameOptionInfo@@0@Z ; std::_Iter_random<CvGameOptionInfo * *,CvGameOptionInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvGameOptionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvGameOptionInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvGameOptionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvGameOptionInfo@@0@Z PROC ; std::_Iter_random<CvGameOptionInfo * *,CvGameOptionInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvGameOptionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvGameOptionInfo@@0@Z ENDP ; std::_Iter_random<CvGameOptionInfo * *,CvGameOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvGameOptionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvGameOptionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvGameOptionInfo * *,CvGameOptionInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvGameOptionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvGameOptionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvGameOptionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvGameOptionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvGameOptionInfo * *,CvGameOptionInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@25

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@25:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvGameOptionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvGameOptionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvGameOptionInfo * *,CvGameOptionInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvMPOptionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMPOptionInfo@@0@Z ; std::_Iter_random<CvMPOptionInfo * *,CvMPOptionInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvMPOptionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMPOptionInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvMPOptionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMPOptionInfo@@0@Z PROC ; std::_Iter_random<CvMPOptionInfo * *,CvMPOptionInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvMPOptionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMPOptionInfo@@0@Z ENDP ; std::_Iter_random<CvMPOptionInfo * *,CvMPOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvMPOptionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMPOptionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvMPOptionInfo * *,CvMPOptionInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvMPOptionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMPOptionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvMPOptionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMPOptionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvMPOptionInfo * *,CvMPOptionInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@26

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@26:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvMPOptionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMPOptionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvMPOptionInfo * *,CvMPOptionInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvPlayerOptionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlayerOptionInfo@@0@Z ; std::_Iter_random<CvPlayerOptionInfo * *,CvPlayerOptionInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvPlayerOptionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlayerOptionInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvPlayerOptionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlayerOptionInfo@@0@Z PROC ; std::_Iter_random<CvPlayerOptionInfo * *,CvPlayerOptionInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvPlayerOptionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlayerOptionInfo@@0@Z ENDP ; std::_Iter_random<CvPlayerOptionInfo * *,CvPlayerOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvPlayerOptionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlayerOptionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPlayerOptionInfo * *,CvPlayerOptionInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvPlayerOptionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlayerOptionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvPlayerOptionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlayerOptionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvPlayerOptionInfo * *,CvPlayerOptionInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@27

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@27:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvPlayerOptionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlayerOptionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvPlayerOptionInfo * *,CvPlayerOptionInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvSpecialistInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvSpecialistInfo@@0@Z ; std::_Iter_random<CvSpecialistInfo * *,CvSpecialistInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvSpecialistInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvSpecialistInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvSpecialistInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvSpecialistInfo@@0@Z PROC ; std::_Iter_random<CvSpecialistInfo * *,CvSpecialistInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvSpecialistInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvSpecialistInfo@@0@Z ENDP ; std::_Iter_random<CvSpecialistInfo * *,CvSpecialistInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvSpecialistInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvSpecialistInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvSpecialistInfo * *,CvSpecialistInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvSpecialistInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvSpecialistInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvSpecialistInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvSpecialistInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvSpecialistInfo * *,CvSpecialistInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@28

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@28:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvSpecialistInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvSpecialistInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvSpecialistInfo * *,CvSpecialistInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvActionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvActionInfo@@0@Z ; std::_Iter_random<CvActionInfo * *,CvActionInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvActionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvActionInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvActionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvActionInfo@@0@Z PROC ; std::_Iter_random<CvActionInfo * *,CvActionInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvActionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvActionInfo@@0@Z ENDP ; std::_Iter_random<CvActionInfo * *,CvActionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvActionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvActionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvActionInfo * *,CvActionInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvActionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvActionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvActionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvActionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvActionInfo * *,CvActionInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@29

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@29:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvActionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvActionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvActionInfo * *,CvActionInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvMissionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMissionInfo@@0@Z ; std::_Iter_random<CvMissionInfo * *,CvMissionInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvMissionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMissionInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvMissionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMissionInfo@@0@Z PROC ; std::_Iter_random<CvMissionInfo * *,CvMissionInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvMissionInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMissionInfo@@0@Z ENDP ; std::_Iter_random<CvMissionInfo * *,CvMissionInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvMissionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMissionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvMissionInfo * *,CvMissionInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvMissionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMissionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvMissionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMissionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvMissionInfo * *,CvMissionInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@30

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@30:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvMissionInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMissionInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvMissionInfo * *,CvMissionInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvControlInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvControlInfo@@0@Z ; std::_Iter_random<CvControlInfo * *,CvControlInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvControlInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvControlInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvControlInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvControlInfo@@0@Z PROC ; std::_Iter_random<CvControlInfo * *,CvControlInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvControlInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvControlInfo@@0@Z ENDP ; std::_Iter_random<CvControlInfo * *,CvControlInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvControlInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvControlInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvControlInfo * *,CvControlInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvControlInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvControlInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvControlInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvControlInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvControlInfo * *,CvControlInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@31

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@31:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvControlInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvControlInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvControlInfo * *,CvControlInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvCommandInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCommandInfo@@0@Z ; std::_Iter_random<CvCommandInfo * *,CvCommandInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvCommandInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCommandInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvCommandInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCommandInfo@@0@Z PROC ; std::_Iter_random<CvCommandInfo * *,CvCommandInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvCommandInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCommandInfo@@0@Z ENDP ; std::_Iter_random<CvCommandInfo * *,CvCommandInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvCommandInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCommandInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvCommandInfo * *,CvCommandInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvCommandInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCommandInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvCommandInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCommandInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvCommandInfo * *,CvCommandInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@32

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@32:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvCommandInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCommandInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvCommandInfo * *,CvCommandInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvAutomateInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvAutomateInfo@@0@Z ; std::_Iter_random<CvAutomateInfo * *,CvAutomateInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvAutomateInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvAutomateInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvAutomateInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvAutomateInfo@@0@Z PROC ; std::_Iter_random<CvAutomateInfo * *,CvAutomateInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvAutomateInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvAutomateInfo@@0@Z ENDP ; std::_Iter_random<CvAutomateInfo * *,CvAutomateInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvAutomateInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvAutomateInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvAutomateInfo * *,CvAutomateInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvAutomateInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvAutomateInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvAutomateInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvAutomateInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvAutomateInfo * *,CvAutomateInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@33

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@33:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvAutomateInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvAutomateInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvAutomateInfo * *,CvAutomateInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvEraInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEraInfo@@0@Z ; std::_Iter_random<CvEraInfo * *,CvEraInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvEraInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEraInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvEraInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEraInfo@@0@Z PROC ; std::_Iter_random<CvEraInfo * *,CvEraInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvEraInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEraInfo@@0@Z ENDP ; std::_Iter_random<CvEraInfo * *,CvEraInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvEraInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEraInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvEraInfo * *,CvEraInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvEraInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEraInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvEraInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEraInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvEraInfo * *,CvEraInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@34

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@34:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvEraInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEraInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvEraInfo * *,CvEraInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvHurryInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvHurryInfo@@0@Z ; std::_Iter_random<CvHurryInfo * *,CvHurryInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvHurryInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvHurryInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvHurryInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvHurryInfo@@0@Z PROC ; std::_Iter_random<CvHurryInfo * *,CvHurryInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvHurryInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvHurryInfo@@0@Z ENDP ; std::_Iter_random<CvHurryInfo * *,CvHurryInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvHurryInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvHurryInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHurryInfo * *,CvHurryInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvHurryInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvHurryInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvHurryInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvHurryInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvHurryInfo * *,CvHurryInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@35

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@35:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvHurryInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvHurryInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvHurryInfo * *,CvHurryInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvVictoryInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvVictoryInfo@@0@Z ; std::_Iter_random<CvVictoryInfo * *,CvVictoryInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvVictoryInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvVictoryInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvVictoryInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvVictoryInfo@@0@Z PROC ; std::_Iter_random<CvVictoryInfo * *,CvVictoryInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvVictoryInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvVictoryInfo@@0@Z ENDP ; std::_Iter_random<CvVictoryInfo * *,CvVictoryInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvVictoryInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvVictoryInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvVictoryInfo * *,CvVictoryInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvVictoryInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvVictoryInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvVictoryInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvVictoryInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvVictoryInfo * *,CvVictoryInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@36

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@36:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvVictoryInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvVictoryInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvVictoryInfo * *,CvVictoryInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvSmallAwardInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvSmallAwardInfo@@0@Z ; std::_Iter_random<CvSmallAwardInfo * *,CvSmallAwardInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvSmallAwardInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvSmallAwardInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvSmallAwardInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvSmallAwardInfo@@0@Z PROC ; std::_Iter_random<CvSmallAwardInfo * *,CvSmallAwardInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvSmallAwardInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvSmallAwardInfo@@0@Z ENDP ; std::_Iter_random<CvSmallAwardInfo * *,CvSmallAwardInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvSmallAwardInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvSmallAwardInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvSmallAwardInfo * *,CvSmallAwardInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvSmallAwardInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvSmallAwardInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvSmallAwardInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvSmallAwardInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvSmallAwardInfo * *,CvSmallAwardInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@37

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@37:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvSmallAwardInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvSmallAwardInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvSmallAwardInfo * *,CvSmallAwardInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvEntityEventInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEntityEventInfo@@0@Z ; std::_Iter_random<CvEntityEventInfo * *,CvEntityEventInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvEntityEventInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEntityEventInfo@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvEntityEventInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEntityEventInfo@@0@Z PROC ; std::_Iter_random<CvEntityEventInfo * *,CvEntityEventInfo * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvEntityEventInfo@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEntityEventInfo@@0@Z ENDP ; std::_Iter_random<CvEntityEventInfo * *,CvEntityEventInfo * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvEntityEventInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEntityEventInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvEntityEventInfo * *,CvEntityEventInfo * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvEntityEventInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEntityEventInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvEntityEventInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEntityEventInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvEntityEventInfo * *,CvEntityEventInfo * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@38

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@38:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvEntityEventInfo@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEntityEventInfo@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvEntityEventInfo * *,CvEntityEventInfo * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@ABV120@@Z ; std::_Construct<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@ABV120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@ABV120@@Z PROC ; std::_Construct<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@3:

; 53   : 	}

	ret	0
??$_Construct@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@ABV120@@Z ENDP ; std::_Construct<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
_TEXT	ENDS
PUBLIC	??$_Destroy@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z ; std::_Destroy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z PROC ; std::_Destroy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z ENDP ; std::_Destroy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAW4AnimationPathTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4AnimationPathTypes@@0@Z ; std::_Ptr_cat<enum AnimationPathTypes *,enum AnimationPathTypes *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAW4AnimationPathTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4AnimationPathTypes@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4AnimationPathTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4AnimationPathTypes@@0@Z PROC ; std::_Ptr_cat<enum AnimationPathTypes *,enum AnimationPathTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAW4AnimationPathTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4AnimationPathTypes@@0@Z ENDP ; std::_Ptr_cat<enum AnimationPathTypes *,enum AnimationPathTypes *>
_TEXT	ENDS
PUBLIC	??$_Destroy@W4AnimationPathTypes@@@std@@YAXPAW4AnimationPathTypes@@@Z ; std::_Destroy<enum AnimationPathTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@W4AnimationPathTypes@@@std@@YAXPAW4AnimationPathTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4AnimationPathTypes@@@std@@YAXPAW4AnimationPathTypes@@@Z PROC ; std::_Destroy<enum AnimationPathTypes>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@W4AnimationPathTypes@@@std@@YAXPAW4AnimationPathTypes@@@Z ENDP ; std::_Destroy<enum AnimationPathTypes>
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??R?$less@I@std@@QBE_NABI0@Z			; std::less<unsigned int>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@I@std@@QBE_NABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@I@std@@QBE_NABI0@Z PROC			; std::less<unsigned int>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [edx]
	sbb	eax, eax
	neg	eax

; 144  : 		}

	ret	8
??R?$less@I@std@@QBE_NABI0@Z ENDP			; std::less<unsigned int>::operator()
_TEXT	ENDS
PUBLIC	??$_Hash_value@PBD@stdext@@YAIPBD0@Z		; stdext::_Hash_value<char const *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ??$_Hash_value@PBD@stdext@@YAIPBD0@Z
_TEXT	SEGMENT
__Begin$ = 8						; size = 4
__End$ = 12						; size = 4
??$_Hash_value@PBD@stdext@@YAIPBD0@Z PROC		; stdext::_Hash_value<char const *>, COMDAT

; 55   : 	size_t _Val = 2166136261U;
; 56   : 	while(_Begin != _End)

	mov	ecx, DWORD PTR __Begin$[esp-4]
	mov	edx, DWORD PTR __End$[esp-4]
	mov	eax, -2128831035			; 811c9dc5H
	cmp	ecx, edx
	je	SHORT $LN1@Hash_value
	push	esi
$LL2@Hash_value:

; 57   : 		_Val = 16777619U * _Val ^ (size_t)*_Begin++;

	movsx	esi, BYTE PTR [ecx]
	imul	eax, 16777619				; 01000193H
	inc	ecx
	xor	eax, esi
	cmp	ecx, edx
	jne	SHORT $LL2@Hash_value
	pop	esi
$LN1@Hash_value:

; 58   : 	return (_Val);
; 59   : 	}

	ret	0
??$_Hash_value@PBD@stdext@@YAIPBD0@Z ENDP		; stdext::_Hash_value<char const *>
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	dl, BYTE PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	bl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], bl

; 23   : 		_Right = _Tmp;

	mov	BYTE PTR [ecx], dl
	pop	ebx
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ ; CvGlobals::getDatabaseLoadUtility
EXTRN	??3CvDllDatabaseUtility@@SAXPAX@Z:PROC		; CvDllDatabaseUtility::operator delete
EXTRN	??0CvDllDatabaseUtility@@QAE@AAVConnection@Database@@@Z:PROC ; CvDllDatabaseUtility::CvDllDatabaseUtility
EXTRN	??2CvDllDatabaseUtility@@SAPAXI@Z:PROC		; CvDllDatabaseUtility::operator new
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\icvdlldatabaseutility.h
xdata$x	SEGMENT
__unwindtable$?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ$0
__ehfuncinfo$?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ
_TEXT	SEGMENT
$T257853 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ PROC ; CvGlobals::getDatabaseLoadUtility, COMDAT
; _this$ = ecx

; 2423 : {

	push	-1
	push	__ehhandler$?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 2424 : 	if(m_pkDatabaseLoadUtility == NULL)

	cmp	DWORD PTR [esi+108], 0
	jne	SHORT $LN1@getDatabas

; 2425 : 		m_pkDatabaseLoadUtility = new CvDllDatabaseUtility(DB);

	push	16					; 00000010H
	call	??2CvDllDatabaseUtility@@SAPAXI@Z	; CvDllDatabaseUtility::operator new
	add	esp, 4
	mov	DWORD PTR $T257853[esp+20], eax
	mov	DWORD PTR __$EHRec$[esp+28], 0
	test	eax, eax
	je	SHORT $LN4@getDatabas
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	push	ecx
	mov	ecx, eax
	call	??0CvDllDatabaseUtility@@QAE@AAVConnection@Database@@@Z ; CvDllDatabaseUtility::CvDllDatabaseUtility
	jmp	SHORT $LN5@getDatabas
$LN4@getDatabas:
	xor	eax, eax
$LN5@getDatabas:
	mov	DWORD PTR __$EHRec$[esp+28], -1
	mov	DWORD PTR [esi+108], eax
$LN1@getDatabas:

; 2426 : 
; 2427 : 	//By using query interface, we implicitly increment the reference count and avoid
; 2428 : 	//a new allocation.
; 2429 : 	return m_pkDatabaseLoadUtility->QueryInterface<ICvDLLDatabaseUtility1>();

	mov	ecx, DWORD PTR [esi+108]
	mov	esi, DWORD PTR _guidICvDLLDatabaseUtility1
	mov	edx, DWORD PTR [ecx]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR _guidICvDLLDatabaseUtility1+4
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR _guidICvDLLDatabaseUtility1+8
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR _guidICvDLLDatabaseUtility1+12
	mov	DWORD PTR [eax+12], esi
	mov	eax, DWORD PTR [edx]
	push	ecx
	call	eax

; 2430 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ$0:
	mov	eax, DWORD PTR $T257853[ebp]
	push	eax
	call	??3CvDllDatabaseUtility@@SAXPAX@Z	; CvDllDatabaseUtility::operator delete
	pop	ecx
	ret	0
__ehhandler$?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ ENDP ; CvGlobals::getDatabaseLoadUtility
PUBLIC	?getInterfaceModeInfo@CvGlobals@@QAEPAVCvInterfaceModeInfo@@W4InterfaceModeTypes@@@Z ; CvGlobals::getInterfaceModeInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getInterfaceModeInfo@CvGlobals@@QAEPAVCvInterfaceModeInfo@@W4InterfaceModeTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getInterfaceModeInfo@CvGlobals@@QAEPAVCvInterfaceModeInfo@@W4InterfaceModeTypes@@@Z PROC ; CvGlobals::getInterfaceModeInfo, COMDAT
; _this$ = ecx

; 2439 : 	CvAssert(e > -1);
; 2440 : 	CvAssert(e < NUM_INTERFACEMODE_TYPES);
; 2441 : 	if(e > -1 && e < (int)m_paInterfaceModeInfo.size())

	mov	eax, DWORD PTR _e$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getInterfa
	mov	edx, DWORD PTR [ecx+904]
	sub	edx, DWORD PTR [ecx+900]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getInterfa

; 2442 : 		return m_paInterfaceModeInfo[e];

	mov	ecx, DWORD PTR [ecx+900]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2445 : }

	ret	4
$LN2@getInterfa:

; 2443 : 	else
; 2444 : 		return NULL;

	xor	eax, eax

; 2445 : }

	ret	4
?getInterfaceModeInfo@CvGlobals@@QAEPAVCvInterfaceModeInfo@@W4InterfaceModeTypes@@@Z ENDP ; CvGlobals::getInterfaceModeInfo
_TEXT	ENDS
PUBLIC	?getNumWorldInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumWorldInfos
EXTRN	__imp_?Count@Connection@Database@@QAEHPBD_N@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?getNumWorldInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumWorldInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumWorldInfos, COMDAT
; _this$ = ecx

; 2598 : 	return GetGameDatabase()->Count("Worlds");

	mov	ecx, DWORD PTR [ecx+912]
	push	1
	push	OFFSET $SG229207
	call	DWORD PTR __imp_?Count@Connection@Database@@QAEHPBD_N@Z

; 2599 : }

	ret	0
?getNumWorldInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumWorldInfos
_TEXT	ENDS
PUBLIC	?getNumClimateInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumClimateInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumClimateInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumClimateInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumClimateInfos, COMDAT
; _this$ = ecx

; 2603 : 	return GetGameDatabase()->Count("Climates");

	mov	ecx, DWORD PTR [ecx+912]
	push	1
	push	OFFSET $SG229211
	call	DWORD PTR __imp_?Count@Connection@Database@@QAEHPBD_N@Z

; 2604 : }

	ret	0
?getNumClimateInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumClimateInfos
_TEXT	ENDS
PUBLIC	?getNumSeaLevelInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumSeaLevelInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumSeaLevelInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumSeaLevelInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumSeaLevelInfos, COMDAT
; _this$ = ecx

; 2608 : 	return GetGameDatabase()->Count("SeaLevels");

	mov	ecx, DWORD PTR [ecx+912]
	push	1
	push	OFFSET $SG229215
	call	DWORD PTR __imp_?Count@Connection@Database@@QAEHPBD_N@Z

; 2609 : }

	ret	0
?getNumSeaLevelInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumSeaLevelInfos
_TEXT	ENDS
PUBLIC	?GetNumColorInfos@CvGlobals@@QAEHXZ		; CvGlobals::GetNumColorInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumColorInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?GetNumColorInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::GetNumColorInfos, COMDAT
; _this$ = ecx

; 2618 : 	return (int)m_paColorInfo.size();

	mov	eax, DWORD PTR [ecx+1044]
	sub	eax, DWORD PTR [ecx+1040]
	sar	eax, 2

; 2619 : #endif
; 2620 : }

	ret	0
?GetNumColorInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::GetNumColorInfos
_TEXT	ENDS
PUBLIC	?GetColorInfo@CvGlobals@@QAEPAVCvColorInfo@@W4ColorTypes@@@Z ; CvGlobals::GetColorInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetColorInfo@CvGlobals@@QAEPAVCvColorInfo@@W4ColorTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?GetColorInfo@CvGlobals@@QAEPAVCvColorInfo@@W4ColorTypes@@@Z PROC ; CvGlobals::GetColorInfo, COMDAT
; _this$ = ecx

; 2633 : 	CvAssert(e > -1);
; 2634 : 	CvAssert(e < GetNumColorInfos());
; 2635 : 	if(e > -1 && e < (int)m_paColorInfo.size())

	mov	eax, DWORD PTR _e$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@GetColorIn
	mov	edx, DWORD PTR [ecx+1044]
	sub	edx, DWORD PTR [ecx+1040]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@GetColorIn

; 2636 : 		return m_paColorInfo[e];

	mov	ecx, DWORD PTR [ecx+1040]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2639 : }

	ret	4
$LN2@GetColorIn:

; 2637 : 	else
; 2638 : 		return NULL;

	xor	eax, eax

; 2639 : }

	ret	4
?GetColorInfo@CvGlobals@@QAEPAVCvColorInfo@@W4ColorTypes@@@Z ENDP ; CvGlobals::GetColorInfo
_TEXT	ENDS
PUBLIC	?GetNumPlayerColorInfos@CvGlobals@@QAEHXZ	; CvGlobals::GetNumPlayerColorInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPlayerColorInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?GetNumPlayerColorInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::GetNumPlayerColorInfos, COMDAT
; _this$ = ecx

; 2649 : 	return (int)m_paPlayerColorInfo.size();

	mov	eax, DWORD PTR [ecx+1060]
	sub	eax, DWORD PTR [ecx+1056]
	sar	eax, 2

; 2650 : #endif
; 2651 : }

	ret	0
?GetNumPlayerColorInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::GetNumPlayerColorInfos
_TEXT	ENDS
PUBLIC	?GetPlayerColorInfo@CvGlobals@@QAEPAVCvPlayerColorInfo@@W4PlayerColorTypes@@@Z ; CvGlobals::GetPlayerColorInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerColorInfo@CvGlobals@@QAEPAVCvPlayerColorInfo@@W4PlayerColorTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?GetPlayerColorInfo@CvGlobals@@QAEPAVCvPlayerColorInfo@@W4PlayerColorTypes@@@Z PROC ; CvGlobals::GetPlayerColorInfo, COMDAT
; _this$ = ecx

; 2664 : 	CvAssert(e > -1);
; 2665 : 	CvAssert(e < GetNumPlayerColorInfos());
; 2666 : 	if(e > -1 && e < (int)m_paPlayerColorInfo.size())

	mov	eax, DWORD PTR _e$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@GetPlayerC
	mov	edx, DWORD PTR [ecx+1060]
	sub	edx, DWORD PTR [ecx+1056]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@GetPlayerC

; 2667 : 		return m_paPlayerColorInfo[e];

	mov	ecx, DWORD PTR [ecx+1056]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2670 : }

	ret	4
$LN2@GetPlayerC:

; 2668 : 	else
; 2669 : 		return NULL;

	xor	eax, eax

; 2670 : }

	ret	4
?GetPlayerColorInfo@CvGlobals@@QAEPAVCvPlayerColorInfo@@W4PlayerColorTypes@@@Z ENDP ; CvGlobals::GetPlayerColorInfo
_TEXT	ENDS
PUBLIC	?getNumEntityEventInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEntityEventInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumEntityEventInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumEntityEventInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumEntityEventInfos, COMDAT
; _this$ = ecx

; 2679 : 	return (int)m_paEntityEventInfo.size();

	mov	eax, DWORD PTR [ecx+1628]
	sub	eax, DWORD PTR [ecx+1624]
	sar	eax, 2

; 2680 : #endif
; 2681 : }

	ret	0
?getNumEntityEventInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumEntityEventInfos
_TEXT	ENDS
PUBLIC	?getEntityEventInfo@CvGlobals@@QAEPAVCvEntityEventInfo@@W4EntityEventTypes@@@Z ; CvGlobals::getEntityEventInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getEntityEventInfo@CvGlobals@@QAEPAVCvEntityEventInfo@@W4EntityEventTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getEntityEventInfo@CvGlobals@@QAEPAVCvEntityEventInfo@@W4EntityEventTypes@@@Z PROC ; CvGlobals::getEntityEventInfo, COMDAT
; _this$ = ecx

; 2694 : 	CvAssert(e > -1);
; 2695 : 	CvAssert(e < GC.getNumEntityEventInfos());
; 2696 : 	if(e > -1 && e < (int)m_paEntityEventInfo.size())

	mov	eax, DWORD PTR _e$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getEntityE
	mov	edx, DWORD PTR [ecx+1628]
	sub	edx, DWORD PTR [ecx+1624]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getEntityE

; 2697 : 		return m_paEntityEventInfo[e];

	mov	ecx, DWORD PTR [ecx+1624]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2700 : }

	ret	4
$LN2@getEntityE:

; 2698 : 	else
; 2699 : 		return NULL;

	xor	eax, eax

; 2700 : }

	ret	4
?getEntityEventInfo@CvGlobals@@QAEPAVCvEntityEventInfo@@W4EntityEventTypes@@@Z ENDP ; CvGlobals::getEntityEventInfo
_TEXT	ENDS
PUBLIC	?getNumMultiUnitFormationInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumMultiUnitFormationInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumMultiUnitFormationInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumMultiUnitFormationInfos@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNumMultiUnitFormationInfos, COMDAT
; _this$ = ecx

; 2709 : 	return (int)m_paMultiUnitFormationInfo.size();

	mov	eax, DWORD PTR [ecx+1660]
	sub	eax, DWORD PTR [ecx+1656]
	sar	eax, 2

; 2710 : #endif
; 2711 : }

	ret	0
?getNumMultiUnitFormationInfos@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNumMultiUnitFormationInfos
_TEXT	ENDS
PUBLIC	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z PROC ; CvGlobals::getMultiUnitFormationInfo, COMDAT
; _this$ = ecx

; 2724 : 	CvAssert(i > -1);
; 2725 : 	CvAssert(i < GC.getNumMultiUnitFormationInfos());
; 2726 : 	if(i > -1 && i < (int)m_paMultiUnitFormationInfo.size())

	mov	eax, DWORD PTR _i$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getMultiUn
	mov	edx, DWORD PTR [ecx+1660]
	sub	edx, DWORD PTR [ecx+1656]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getMultiUn

; 2727 : 		return m_paMultiUnitFormationInfo[i];

	mov	ecx, DWORD PTR [ecx+1656]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2730 : }

	ret	4
$LN2@getMultiUn:

; 2728 : 	else
; 2729 : 		return NULL;

	xor	eax, eax

; 2730 : }

	ret	4
?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ENDP ; CvGlobals::getMultiUnitFormationInfo
_TEXT	ENDS
PUBLIC	?getNumTerrainInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumTerrainInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumTerrainInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumTerrainInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumTerrainInfos, COMDAT
; _this$ = ecx

; 2739 : 	return (int)m_paTerrainInfo.size();

	mov	eax, DWORD PTR [ecx+1076]
	sub	eax, DWORD PTR [ecx+1072]
	sar	eax, 2

; 2740 : #endif
; 2741 : }

	ret	0
?getNumTerrainInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumTerrainInfos
_TEXT	ENDS
PUBLIC	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z
_TEXT	SEGMENT
_eTerrainNum$ = 8					; size = 4
?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z PROC ; CvGlobals::getTerrainInfo, COMDAT
; _this$ = ecx

; 2750 : 	CvAssert(eTerrainNum > -1);
; 2751 : 	CvAssert(eTerrainNum < GC.getNumTerrainInfos());
; 2752 : 	if(eTerrainNum > -1 && eTerrainNum < (int)m_paTerrainInfo.size())

	mov	eax, DWORD PTR _eTerrainNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getTerrain@2
	mov	edx, DWORD PTR [ecx+1076]
	sub	edx, DWORD PTR [ecx+1072]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getTerrain@2

; 2753 : 		return m_paTerrainInfo[eTerrainNum];

	mov	ecx, DWORD PTR [ecx+1072]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2756 : }

	ret	4
$LN2@getTerrain@2:

; 2754 : 	else
; 2755 : 		return NULL;

	xor	eax, eax

; 2756 : }

	ret	4
?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ENDP ; CvGlobals::getTerrainInfo
_TEXT	ENDS
PUBLIC	?getNumResourceClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceClassInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumResourceClassInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumResourceClassInfos@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNumResourceClassInfos, COMDAT
; _this$ = ecx

; 2765 : 	return (int)m_paResourceClassInfo.size();

	mov	eax, DWORD PTR [ecx+1140]
	sub	eax, DWORD PTR [ecx+1136]
	sar	eax, 2

; 2766 : #endif
; 2767 : }

	ret	0
?getNumResourceClassInfos@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNumResourceClassInfos
_TEXT	ENDS
PUBLIC	?getResourceClassInfo@CvGlobals@@QAEPAVCvResourceClassInfo@@W4ResourceClassTypes@@@Z ; CvGlobals::getResourceClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getResourceClassInfo@CvGlobals@@QAEPAVCvResourceClassInfo@@W4ResourceClassTypes@@@Z
_TEXT	SEGMENT
_eResourceNum$ = 8					; size = 4
?getResourceClassInfo@CvGlobals@@QAEPAVCvResourceClassInfo@@W4ResourceClassTypes@@@Z PROC ; CvGlobals::getResourceClassInfo, COMDAT
; _this$ = ecx

; 2780 : 	CvAssert(eResourceNum > -1);
; 2781 : 	CvAssert(eResourceNum < GC.getNumResourceClassInfos());
; 2782 : 	if(eResourceNum > -1 && eResourceNum < (int)m_paResourceClassInfo.size())

	mov	eax, DWORD PTR _eResourceNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getResourc
	mov	edx, DWORD PTR [ecx+1140]
	sub	edx, DWORD PTR [ecx+1136]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getResourc

; 2783 : 		return m_paResourceClassInfo[eResourceNum];

	mov	ecx, DWORD PTR [ecx+1136]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2786 : }

	ret	4
$LN2@getResourc:

; 2784 : 	else
; 2785 : 		return NULL;

	xor	eax, eax

; 2786 : }

	ret	4
?getResourceClassInfo@CvGlobals@@QAEPAVCvResourceClassInfo@@W4ResourceClassTypes@@@Z ENDP ; CvGlobals::getResourceClassInfo
_TEXT	ENDS
PUBLIC	?getNumResourceInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumResourceInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumResourceInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumResourceInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumResourceInfos, COMDAT
; _this$ = ecx

; 2796 : 	return (int)m_paResourceInfo.size();

	mov	eax, DWORD PTR [ecx+1156]
	sub	eax, DWORD PTR [ecx+1152]
	sar	eax, 2

; 2797 : #endif
; 2798 : }

	ret	0
?getNumResourceInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumResourceInfos
_TEXT	ENDS
PUBLIC	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z
_TEXT	SEGMENT
_eResourceNum$ = 8					; size = 4
?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z PROC ; CvGlobals::getResourceInfo, COMDAT
; _this$ = ecx

; 2807 : 	CvAssert(eResourceNum > -1);
; 2808 : 	CvAssert(eResourceNum < GC.getNumResourceInfos());
; 2809 : 	if(eResourceNum > -1 && eResourceNum < (int)m_paResourceInfo.size())

	mov	eax, DWORD PTR _eResourceNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getResourc@2
	mov	edx, DWORD PTR [ecx+1156]
	sub	edx, DWORD PTR [ecx+1152]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getResourc@2

; 2810 : 		return m_paResourceInfo[eResourceNum];

	mov	ecx, DWORD PTR [ecx+1152]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2813 : }

	ret	4
$LN2@getResourc@2:

; 2811 : 	else
; 2812 : 		return NULL;

	xor	eax, eax

; 2813 : }

	ret	4
?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ENDP ; CvGlobals::getResourceInfo
_TEXT	ENDS
PUBLIC	?getNumFeatureInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumFeatureInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFeatureInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFeatureInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFeatureInfos, COMDAT
; _this$ = ecx

; 2822 : 	return (int)m_paFeatureInfo.size();

	mov	eax, DWORD PTR [ecx+1124]
	sub	eax, DWORD PTR [ecx+1120]
	sar	eax, 2

; 2823 : #endif
; 2824 : }

	ret	0
?getNumFeatureInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFeatureInfos
_TEXT	ENDS
PUBLIC	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z
_TEXT	SEGMENT
_eFeatureNum$ = 8					; size = 4
?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z PROC ; CvGlobals::getFeatureInfo, COMDAT
; _this$ = ecx

; 2833 : 	CvAssert(eFeatureNum > -1);
; 2834 : 	CvAssert(eFeatureNum < GC.getNumFeatureInfos());
; 2835 : 	if(eFeatureNum > -1 && eFeatureNum < (int)m_paFeatureInfo.size())

	mov	eax, DWORD PTR _eFeatureNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getFeature
	mov	edx, DWORD PTR [ecx+1124]
	sub	edx, DWORD PTR [ecx+1120]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getFeature

; 2836 : 		return m_paFeatureInfo[eFeatureNum];

	mov	ecx, DWORD PTR [ecx+1120]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2839 : }

	ret	4
$LN2@getFeature:

; 2837 : 	else
; 2838 : 		return NULL;

	xor	eax, eax

; 2839 : }

	ret	4
?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ENDP ; CvGlobals::getFeatureInfo
_TEXT	ENDS
PUBLIC	?getNumCivilizationInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumCivilizationInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumCivilizationInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumCivilizationInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumCivilizationInfos, COMDAT
; _this$ = ecx

; 2858 : 	return (int)m_paCivilizationInfo.size();

	mov	eax, DWORD PTR [ecx+1236]
	sub	eax, DWORD PTR [ecx+1232]
	sar	eax, 2

; 2859 : #endif
; 2860 : }

	ret	0
?getNumCivilizationInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumCivilizationInfos
_TEXT	ENDS
PUBLIC	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z
_TEXT	SEGMENT
_eCivilizationNum$ = 8					; size = 4
?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z PROC ; CvGlobals::getCivilizationInfo, COMDAT
; _this$ = ecx

; 2873 : 	CvAssert(eCivilizationNum > -1);
; 2874 : 	CvAssert(eCivilizationNum < GC.getNumCivilizationInfos());
; 2875 : 	if(eCivilizationNum > -1 && eCivilizationNum < (int)m_paCivilizationInfo.size())

	mov	eax, DWORD PTR _eCivilizationNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getCiviliz
	mov	edx, DWORD PTR [ecx+1236]
	sub	edx, DWORD PTR [ecx+1232]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getCiviliz

; 2876 : 		return m_paCivilizationInfo[eCivilizationNum];

	mov	ecx, DWORD PTR [ecx+1232]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2879 : }

	ret	4
$LN2@getCiviliz:

; 2877 : 	else
; 2878 : 		return NULL;

	xor	eax, eax

; 2879 : }

	ret	4
?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ENDP ; CvGlobals::getCivilizationInfo
_TEXT	ENDS
PUBLIC	?getNumMinorCivInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumMinorCivInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumMinorCivInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumMinorCivInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumMinorCivInfos, COMDAT
; _this$ = ecx

; 2904 : 	return (int)m_paMinorCivInfo.size();

	mov	eax, DWORD PTR [ecx+1260]
	sub	eax, DWORD PTR [ecx+1256]
	sar	eax, 2

; 2905 : #endif
; 2906 : }

	ret	0
?getNumMinorCivInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumMinorCivInfos
_TEXT	ENDS
PUBLIC	?GetNumPlayableMinorCivs@CvGlobals@@QBEHXZ	; CvGlobals::GetNumPlayableMinorCivs
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPlayableMinorCivs@CvGlobals@@QBEHXZ
_TEXT	SEGMENT
?GetNumPlayableMinorCivs@CvGlobals@@QBEHXZ PROC		; CvGlobals::GetNumPlayableMinorCivs, COMDAT
; _this$ = ecx

; 2916 : {

	push	esi

; 2917 : 	int iFound = 0;
; 2918 : 	int iCurrentMinorIndex = 0;
; 2919 : 
; 2920 : 	for(; iCurrentMinorIndex < (int)m_paMinorCivInfo.size(); iCurrentMinorIndex++)

	mov	esi, DWORD PTR [ecx+1260]
	sub	esi, DWORD PTR [ecx+1256]
	xor	eax, eax
	xor	edx, edx
	test	esi, -4					; fffffffcH
	jle	SHORT $LN2@GetNumPlay
	mov	esi, DWORD PTR [ecx+1260]
	sub	esi, DWORD PTR [ecx+1256]
	mov	ecx, DWORD PTR [ecx+1256]
	sar	esi, 2
	npad	2
$LL4@GetNumPlay:

; 2921 : #endif
; 2922 : 	{
; 2923 : 		if(m_paMinorCivInfo[iCurrentMinorIndex] != NULL)

	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@GetNumPlay

; 2924 : 		{
; 2925 : 			iFound++;

	inc	eax
$LN3@GetNumPlay:

; 2917 : 	int iFound = 0;
; 2918 : 	int iCurrentMinorIndex = 0;
; 2919 : 
; 2920 : 	for(; iCurrentMinorIndex < (int)m_paMinorCivInfo.size(); iCurrentMinorIndex++)

	inc	edx
	add	ecx, 4
	cmp	edx, esi
	jl	SHORT $LL4@GetNumPlay
$LN2@GetNumPlay:
	pop	esi

; 2926 : 		}
; 2927 : 	}
; 2928 : 
; 2929 : 	return iFound;
; 2930 : }

	ret	0
?GetNumPlayableMinorCivs@CvGlobals@@QBEHXZ ENDP		; CvGlobals::GetNumPlayableMinorCivs
_TEXT	ENDS
PUBLIC	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z
_TEXT	SEGMENT
_eMinorCivNum$ = 8					; size = 4
?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z PROC ; CvGlobals::getMinorCivInfo, COMDAT
; _this$ = ecx

; 2939 : 	CvAssert(eMinorCivNum > -1);
; 2940 : 	CvAssert(eMinorCivNum < GC.getNumMinorCivInfos());
; 2941 : 	if(eMinorCivNum > -1 && eMinorCivNum < (int)m_paMinorCivInfo.size())

	mov	eax, DWORD PTR _eMinorCivNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getMinorCi
	mov	edx, DWORD PTR [ecx+1260]
	sub	edx, DWORD PTR [ecx+1256]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getMinorCi

; 2942 : 		return m_paMinorCivInfo[eMinorCivNum];

	mov	ecx, DWORD PTR [ecx+1256]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2945 : }

	ret	4
$LN2@getMinorCi:

; 2943 : 	else
; 2944 : 		return NULL;

	xor	eax, eax

; 2945 : }

	ret	4
?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ENDP ; CvGlobals::getMinorCivInfo
_TEXT	ENDS
PUBLIC	?getNumLeaderHeadInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumLeaderHeadInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumLeaderHeadInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumLeaderHeadInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumLeaderHeadInfos, COMDAT
; _this$ = ecx

; 2954 : 	return (int)m_paLeaderHeadInfo.size();

	mov	eax, DWORD PTR [ecx+1276]
	sub	eax, DWORD PTR [ecx+1272]
	sar	eax, 2

; 2955 : #endif
; 2956 : }

	ret	0
?getNumLeaderHeadInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumLeaderHeadInfos
_TEXT	ENDS
PUBLIC	?getLeaderHeadInfo@CvGlobals@@QAEPAVCvLeaderHeadInfo@@W4LeaderHeadTypes@@@Z ; CvGlobals::getLeaderHeadInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getLeaderHeadInfo@CvGlobals@@QAEPAVCvLeaderHeadInfo@@W4LeaderHeadTypes@@@Z
_TEXT	SEGMENT
_eLeaderHeadNum$ = 8					; size = 4
?getLeaderHeadInfo@CvGlobals@@QAEPAVCvLeaderHeadInfo@@W4LeaderHeadTypes@@@Z PROC ; CvGlobals::getLeaderHeadInfo, COMDAT
; _this$ = ecx

; 2969 : 	CvAssert(eLeaderHeadNum > -1);
; 2970 : 	CvAssert(eLeaderHeadNum < GC.getNumLeaderHeadInfos());
; 2971 : 	if(eLeaderHeadNum > -1 && eLeaderHeadNum < (int)m_paLeaderHeadInfo.size())

	mov	eax, DWORD PTR _eLeaderHeadNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getLeaderH
	mov	edx, DWORD PTR [ecx+1276]
	sub	edx, DWORD PTR [ecx+1272]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getLeaderH

; 2972 : 		return m_paLeaderHeadInfo[eLeaderHeadNum];

	mov	ecx, DWORD PTR [ecx+1272]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2975 : }

	ret	4
$LN2@getLeaderH:

; 2973 : 	else
; 2974 : 		return NULL;

	xor	eax, eax

; 2975 : }

	ret	4
?getLeaderHeadInfo@CvGlobals@@QAEPAVCvLeaderHeadInfo@@W4LeaderHeadTypes@@@Z ENDP ; CvGlobals::getLeaderHeadInfo
_TEXT	ENDS
PUBLIC	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z
_TEXT	SEGMENT
_eUnitNum$ = 8						; size = 4
?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z PROC ; CvGlobals::getUnitInfo, COMDAT
; _this$ = ecx

; 2996 : {

	push	esi

; 2997 : #ifdef AUI_WARNING_FIXES
; 2998 : 	uint uiIndex = uint(eUnitNum);
; 2999 : 	CvAssert(uiIndex < GC.getNumUnitInfos());
; 3000 : 	if (uiIndex < GC.getNumUnitInfos())
; 3001 : 		return m_pUnits->GetUnitEntries()[uiIndex];
; 3002 : #else
; 3003 : 	CvAssert(eUnitNum > -1);
; 3004 : 	CvAssert(eUnitNum < GC.getNumUnitInfos());
; 3005 : 	if(eUnitNum > -1 && eUnitNum < GC.getNumUnitInfos())

	mov	esi, DWORD PTR _eUnitNum$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN2@getUnitInf
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1704
	call	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ	; CvUnitXMLEntries::GetNumUnits
	cmp	esi, eax
	jge	SHORT $LN2@getUnitInf

; 3006 : 		return m_pUnits->GetUnitEntries()[eUnitNum];

	mov	ecx, DWORD PTR [edi+1704]
	call	?GetUnitEntries@CvUnitXMLEntries@@QAEAAV?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@XZ ; CvUnitXMLEntries::GetUnitEntries
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 3010 : }

	ret	4
$LN2@getUnitInf:
	pop	edi

; 3007 : #endif
; 3008 : 	else
; 3009 : 		return NULL;

	xor	eax, eax
	pop	esi

; 3010 : }

	ret	4
?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ENDP ; CvGlobals::getUnitInfo
_TEXT	ENDS
PUBLIC	?getNumSpecialUnitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumSpecialUnitInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumSpecialUnitInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumSpecialUnitInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumSpecialUnitInfos, COMDAT
; _this$ = ecx

; 3024 : 	return (int)m_paSpecialUnitInfo.size();

	mov	eax, DWORD PTR [ecx+1356]
	sub	eax, DWORD PTR [ecx+1352]
	sar	eax, 2

; 3025 : #endif
; 3026 : }

	ret	0
?getNumSpecialUnitInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumSpecialUnitInfos
_TEXT	ENDS
PUBLIC	?getSpecialUnitInfo@CvGlobals@@QAEPAVCvSpecialUnitInfo@@W4SpecialUnitTypes@@@Z ; CvGlobals::getSpecialUnitInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getSpecialUnitInfo@CvGlobals@@QAEPAVCvSpecialUnitInfo@@W4SpecialUnitTypes@@@Z
_TEXT	SEGMENT
_eSpecialUnitNum$ = 8					; size = 4
?getSpecialUnitInfo@CvGlobals@@QAEPAVCvSpecialUnitInfo@@W4SpecialUnitTypes@@@Z PROC ; CvGlobals::getSpecialUnitInfo, COMDAT
; _this$ = ecx

; 3043 : 	CvAssert(eSpecialUnitNum > -1);
; 3044 : 	CvAssert(eSpecialUnitNum < GC.getNumSpecialUnitInfos());
; 3045 : 	if(eSpecialUnitNum > -1 && eSpecialUnitNum < (int)m_paSpecialUnitInfo.size())

	mov	eax, DWORD PTR _eSpecialUnitNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getSpecial
	mov	edx, DWORD PTR [ecx+1356]
	sub	edx, DWORD PTR [ecx+1352]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getSpecial

; 3046 : 		return m_paSpecialUnitInfo[eSpecialUnitNum];

	mov	ecx, DWORD PTR [ecx+1352]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3050 : }

	ret	4
$LN2@getSpecial:

; 3047 : #endif
; 3048 : 	else
; 3049 : 		return NULL;

	xor	eax, eax

; 3050 : }

	ret	4
?getSpecialUnitInfo@CvGlobals@@QAEPAVCvSpecialUnitInfo@@W4SpecialUnitTypes@@@Z ENDP ; CvGlobals::getSpecialUnitInfo
_TEXT	ENDS
PUBLIC	?getNumVoteSourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVoteSourceInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumVoteSourceInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumVoteSourceInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumVoteSourceInfos, COMDAT
; _this$ = ecx

; 3059 : 	return (int)m_paVoteSourceInfo.size();

	mov	eax, DWORD PTR [ecx+1372]
	sub	eax, DWORD PTR [ecx+1368]
	sar	eax, 2

; 3060 : #endif
; 3061 : }

	ret	0
?getNumVoteSourceInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumVoteSourceInfos
_TEXT	ENDS
PUBLIC	?getVoteSourceInfo@CvGlobals@@QAEPAVCvVoteSourceInfo@@W4VoteSourceTypes@@@Z ; CvGlobals::getVoteSourceInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getVoteSourceInfo@CvGlobals@@QAEPAVCvVoteSourceInfo@@W4VoteSourceTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getVoteSourceInfo@CvGlobals@@QAEPAVCvVoteSourceInfo@@W4VoteSourceTypes@@@Z PROC ; CvGlobals::getVoteSourceInfo, COMDAT
; _this$ = ecx

; 3078 : 	CvAssert(e > -1);
; 3079 : 	CvAssert(e < GC.getNumVoteSourceInfos());
; 3080 : 	if(e > -1 && e < (int)m_paVoteSourceInfo.size())

	mov	eax, DWORD PTR _e$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getVoteSou
	mov	edx, DWORD PTR [ecx+1372]
	sub	edx, DWORD PTR [ecx+1368]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getVoteSou

; 3081 : 		return m_paVoteSourceInfo[e];

	mov	ecx, DWORD PTR [ecx+1368]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3085 : }

	ret	4
$LN2@getVoteSou:

; 3082 : #endif
; 3083 : 	else
; 3084 : 		return NULL;

	xor	eax, eax

; 3085 : }

	ret	4
?getVoteSourceInfo@CvGlobals@@QAEPAVCvVoteSourceInfo@@W4VoteSourceTypes@@@Z ENDP ; CvGlobals::getVoteSourceInfo
_TEXT	ENDS
PUBLIC	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitCombatClassInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNumUnitCombatClassInfos, COMDAT
; _this$ = ecx

; 3094 : 	return (int)m_paUnitCombatClassInfo.size();

	mov	eax, DWORD PTR [ecx+1388]
	sub	eax, DWORD PTR [ecx+1384]
	sar	eax, 2

; 3095 : #endif
; 3096 : }

	ret	0
?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNumUnitCombatClassInfos
_TEXT	ENDS
PUBLIC	?getUnitCombatClassInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4UnitCombatTypes@@@Z ; CvGlobals::getUnitCombatClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitCombatClassInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4UnitCombatTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getUnitCombatClassInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4UnitCombatTypes@@@Z PROC ; CvGlobals::getUnitCombatClassInfo, COMDAT
; _this$ = ecx

; 3113 : 	CvAssert(e > -1);
; 3114 : 	CvAssert(e < GC.getNumUnitCombatClassInfos());
; 3115 : 	if(e > -1 && e < (int)m_paUnitCombatClassInfo.size())

	mov	eax, DWORD PTR _e$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getUnitCom
	mov	edx, DWORD PTR [ecx+1388]
	sub	edx, DWORD PTR [ecx+1384]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getUnitCom

; 3116 : 		return m_paUnitCombatClassInfo[e];

	mov	ecx, DWORD PTR [ecx+1384]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3120 : }

	ret	4
$LN2@getUnitCom:

; 3117 : #endif
; 3118 : 	else
; 3119 : 		return NULL;

	xor	eax, eax

; 3120 : }

	ret	4
?getUnitCombatClassInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4UnitCombatTypes@@@Z ENDP ; CvGlobals::getUnitCombatClassInfo
_TEXT	ENDS
PUBLIC	?getUnitAIInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4UnitAITypes@@@Z ; CvGlobals::getUnitAIInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitAIInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4UnitAITypes@@@Z
_TEXT	SEGMENT
_eUnitAINum$ = 8					; size = 4
?getUnitAIInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4UnitAITypes@@@Z PROC ; CvGlobals::getUnitAIInfo, COMDAT
; _this$ = ecx

; 3137 : 	CvAssert(eUnitAINum >= 0);
; 3138 : 	CvAssert(eUnitAINum < NUM_UNITAI_TYPES);
; 3139 : 	if(eUnitAINum > -1 && eUnitAINum < (int)m_paUnitAIInfos.size())

	mov	eax, DWORD PTR _eUnitAINum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getUnitAII
	mov	edx, DWORD PTR [ecx+1404]
	sub	edx, DWORD PTR [ecx+1400]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getUnitAII

; 3140 : 		return m_paUnitAIInfos[eUnitAINum];

	mov	ecx, DWORD PTR [ecx+1400]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3144 : }

	ret	4
$LN2@getUnitAII:

; 3141 : #endif
; 3142 : 	else
; 3143 : 		return NULL;

	xor	eax, eax

; 3144 : }

	ret	4
?getUnitAIInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4UnitAITypes@@@Z ENDP ; CvGlobals::getUnitAIInfo
_TEXT	ENDS
PUBLIC	?getNumGameOptionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumGameOptionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumGameOptionInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumGameOptionInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumGameOptionInfos, COMDAT
; _this$ = ecx

; 3153 : 	return (int)m_paGameOptionInfos.size();

	mov	eax, DWORD PTR [ecx+1420]
	sub	eax, DWORD PTR [ecx+1416]
	sar	eax, 2

; 3154 : #endif
; 3155 : }

	ret	0
?getNumGameOptionInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumGameOptionInfos
_TEXT	ENDS
PUBLIC	?getGameOptionInfo@CvGlobals@@QAEPAVCvGameOptionInfo@@W4GameOptionTypes@@@Z ; CvGlobals::getGameOptionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getGameOptionInfo@CvGlobals@@QAEPAVCvGameOptionInfo@@W4GameOptionTypes@@@Z
_TEXT	SEGMENT
_eGameOptionNum$ = 8					; size = 4
?getGameOptionInfo@CvGlobals@@QAEPAVCvGameOptionInfo@@W4GameOptionTypes@@@Z PROC ; CvGlobals::getGameOptionInfo, COMDAT
; _this$ = ecx

; 3172 : 	CvAssert(eGameOptionNum >= 0);
; 3173 : 	CvAssert(eGameOptionNum < GC.getNumGameOptionInfos());
; 3174 : 	if(eGameOptionNum > -1 && eGameOptionNum < (int)m_paGameOptionInfos.size())

	mov	eax, DWORD PTR _eGameOptionNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getGameOpt
	mov	edx, DWORD PTR [ecx+1420]
	sub	edx, DWORD PTR [ecx+1416]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getGameOpt

; 3175 : 		return m_paGameOptionInfos[eGameOptionNum];

	mov	ecx, DWORD PTR [ecx+1416]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3179 : }

	ret	4
$LN2@getGameOpt:

; 3176 : #endif
; 3177 : 	else
; 3178 : 		return NULL;

	xor	eax, eax

; 3179 : }

	ret	4
?getGameOptionInfo@CvGlobals@@QAEPAVCvGameOptionInfo@@W4GameOptionTypes@@@Z ENDP ; CvGlobals::getGameOptionInfo
_TEXT	ENDS
PUBLIC	?getNumMPOptionInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumMPOptionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumMPOptionInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumMPOptionInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumMPOptionInfos, COMDAT
; _this$ = ecx

; 3188 : 	return (int)m_paMPOptionInfos.size();

	mov	eax, DWORD PTR [ecx+1436]
	sub	eax, DWORD PTR [ecx+1432]
	sar	eax, 2

; 3189 : #endif
; 3190 : }

	ret	0
?getNumMPOptionInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumMPOptionInfos
_TEXT	ENDS
PUBLIC	?getMPOptionInfo@CvGlobals@@QAEPAVCvMPOptionInfo@@W4MultiplayerOptionTypes@@@Z ; CvGlobals::getMPOptionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getMPOptionInfo@CvGlobals@@QAEPAVCvMPOptionInfo@@W4MultiplayerOptionTypes@@@Z
_TEXT	SEGMENT
_eMPOptionNum$ = 8					; size = 4
?getMPOptionInfo@CvGlobals@@QAEPAVCvMPOptionInfo@@W4MultiplayerOptionTypes@@@Z PROC ; CvGlobals::getMPOptionInfo, COMDAT
; _this$ = ecx

; 3207 : 	CvAssert(eMPOptionNum >= 0);
; 3208 : 	CvAssert(eMPOptionNum < GC.getNumMPOptionInfos());
; 3209 : 	if(eMPOptionNum > -1 && eMPOptionNum < (int)m_paMPOptionInfos.size())

	mov	eax, DWORD PTR _eMPOptionNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getMPOptio
	mov	edx, DWORD PTR [ecx+1436]
	sub	edx, DWORD PTR [ecx+1432]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getMPOptio

; 3210 : 		return m_paMPOptionInfos[eMPOptionNum];

	mov	ecx, DWORD PTR [ecx+1432]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3214 : }

	ret	4
$LN2@getMPOptio:

; 3211 : #endif
; 3212 : 	else
; 3213 : 		return NULL;

	xor	eax, eax

; 3214 : }

	ret	4
?getMPOptionInfo@CvGlobals@@QAEPAVCvMPOptionInfo@@W4MultiplayerOptionTypes@@@Z ENDP ; CvGlobals::getMPOptionInfo
_TEXT	ENDS
PUBLIC	?getPlayerOptionInfo@CvGlobals@@QAEPAVCvPlayerOptionInfo@@W4PlayerOptionTypes@@@Z ; CvGlobals::getPlayerOptionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerOptionInfo@CvGlobals@@QAEPAVCvPlayerOptionInfo@@W4PlayerOptionTypes@@@Z
_TEXT	SEGMENT
_ePlayerOptionNum$ = 8					; size = 4
?getPlayerOptionInfo@CvGlobals@@QAEPAVCvPlayerOptionInfo@@W4PlayerOptionTypes@@@Z PROC ; CvGlobals::getPlayerOptionInfo, COMDAT
; _this$ = ecx

; 3231 : 	CvAssert(ePlayerOptionNum >= 0);
; 3232 : 	if(ePlayerOptionNum > -1 && ePlayerOptionNum < (int)m_paPlayerOptionInfos.size())

	mov	eax, DWORD PTR _ePlayerOptionNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getPlayerO
	mov	edx, DWORD PTR [ecx+1452]
	sub	edx, DWORD PTR [ecx+1448]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getPlayerO

; 3233 : 		return m_paPlayerOptionInfos[ePlayerOptionNum];

	mov	ecx, DWORD PTR [ecx+1448]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3237 : }

	ret	4
$LN2@getPlayerO:

; 3234 : #endif
; 3235 : 	else
; 3236 : 		return NULL;

	xor	eax, eax

; 3237 : }

	ret	4
?getPlayerOptionInfo@CvGlobals@@QAEPAVCvPlayerOptionInfo@@W4PlayerOptionTypes@@@Z ENDP ; CvGlobals::getPlayerOptionInfo
_TEXT	ENDS
PUBLIC	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z ; CvGlobals::getYieldInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eYieldNum$ = 8						; size = 4
?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z PROC ; CvGlobals::getYieldInfo, COMDAT
; _this$ = ecx

; 3258 : 	CvAssert(eYieldNum > -1);
; 3259 : 	CvAssert(eYieldNum < NUM_YIELD_TYPES);
; 3260 : 	if(eYieldNum > -1 && eYieldNum < (int)m_paYieldInfo.size())

	mov	eax, DWORD PTR _eYieldNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getYieldIn
	mov	edx, DWORD PTR [ecx+1092]
	sub	edx, DWORD PTR [ecx+1088]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getYieldIn

; 3261 : 		return m_paYieldInfo[eYieldNum];

	mov	ecx, DWORD PTR [ecx+1088]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3265 : }

	ret	4
$LN2@getYieldIn:

; 3262 : #endif
; 3263 : 	else
; 3264 : 		return NULL;

	xor	eax, eax

; 3265 : }

	ret	4
?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z ENDP ; CvGlobals::getYieldInfo
_TEXT	ENDS
PUBLIC	?getNumRouteInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumRouteInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumRouteInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumRouteInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumRouteInfos, COMDAT
; _this$ = ecx

; 3274 : 	return (int)m_paRouteInfo.size();

	mov	eax, DWORD PTR [ecx+1108]
	sub	eax, DWORD PTR [ecx+1104]
	sar	eax, 2

; 3275 : #endif
; 3276 : }

	ret	0
?getNumRouteInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumRouteInfos
_TEXT	ENDS
PUBLIC	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z
_TEXT	SEGMENT
_eRouteNum$ = 8						; size = 4
?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z PROC ; CvGlobals::getRouteInfo, COMDAT
; _this$ = ecx

; 3293 : 	CvAssert(eRouteNum > -1);
; 3294 : 	CvAssert(eRouteNum < GC.getNumRouteInfos());
; 3295 : 	if(eRouteNum > -1 && eRouteNum < (int)m_paRouteInfo.size())

	mov	eax, DWORD PTR _eRouteNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getRouteIn
	mov	edx, DWORD PTR [ecx+1108]
	sub	edx, DWORD PTR [ecx+1104]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getRouteIn

; 3296 : 		return m_paRouteInfo[eRouteNum];

	mov	ecx, DWORD PTR [ecx+1104]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3300 : }

	ret	4
$LN2@getRouteIn:

; 3297 : #endif
; 3298 : 	else
; 3299 : 		return NULL;

	xor	eax, eax

; 3300 : }

	ret	4
?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ENDP ; CvGlobals::getRouteInfo
_TEXT	ENDS
PUBLIC	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z
_TEXT	SEGMENT
_eImprovementNum$ = 8					; size = 4
?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z PROC ; CvGlobals::getImprovementInfo, COMDAT
; _this$ = ecx

; 3317 : {

	push	esi

; 3318 : #ifdef AUI_WARNING_FIXES
; 3319 : 	uint uiIndex = uint(eImprovementNum);
; 3320 : 	CvAssert(uiIndex < GC.getNumImprovementInfos());
; 3321 : 	if (uiIndex < GC.getNumImprovementInfos())
; 3322 : 		return m_pImprovements->GetImprovementEntries()[uiIndex];
; 3323 : #else
; 3324 : 	CvAssert(eImprovementNum > -1);
; 3325 : 	CvAssert(eImprovementNum < GC.getNumImprovementInfos());
; 3326 : 	if(eImprovementNum > -1 && eImprovementNum < GC.getNumImprovementInfos())

	mov	esi, DWORD PTR _eImprovementNum$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN2@getImprove
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1716
	call	?GetNumImprovements@CvImprovementXMLEntries@@QAEHXZ ; CvImprovementXMLEntries::GetNumImprovements
	cmp	esi, eax
	jge	SHORT $LN2@getImprove

; 3327 : 		return m_pImprovements->GetImprovementEntries()[eImprovementNum];

	mov	ecx, DWORD PTR [edi+1716]
	call	?GetImprovementEntries@CvImprovementXMLEntries@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ ; CvImprovementXMLEntries::GetImprovementEntries
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 3331 : }

	ret	4
$LN2@getImprove:
	pop	edi

; 3328 : #endif
; 3329 : 	else
; 3330 : 		return NULL;

	xor	eax, eax
	pop	esi

; 3331 : }

	ret	4
?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ENDP ; CvGlobals::getImprovementInfo
_TEXT	ENDS
PUBLIC	?getNumBuildInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumBuildInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumBuildInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumBuildInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumBuildInfos, COMDAT
; _this$ = ecx

; 3345 : 	return (int)m_paBuildInfo.size();

	mov	eax, DWORD PTR [ecx+1172]
	sub	eax, DWORD PTR [ecx+1168]
	sar	eax, 2

; 3346 : #endif
; 3347 : }

	ret	0
?getNumBuildInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumBuildInfos
_TEXT	ENDS
PUBLIC	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z
_TEXT	SEGMENT
_eBuildNum$ = 8						; size = 4
?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z PROC ; CvGlobals::getBuildInfo, COMDAT
; _this$ = ecx

; 3356 : #ifdef AUI_WARNING_FIXES
; 3357 : 	uint uiIndex = uint(eBuildNum);
; 3358 : 	CvAssert(uiIndex < GC.getNumBuildInfos());
; 3359 : 	if (uiIndex < m_paBuildInfo.size())
; 3360 : 		return m_paBuildInfo[uiIndex];
; 3361 : #else
; 3362 : 	CvAssert(eBuildNum > -1);
; 3363 : 	CvAssert(eBuildNum < GC.getNumBuildInfos());
; 3364 : 	if(eBuildNum > -1 && eBuildNum < (int)m_paBuildInfo.size())

	mov	eax, DWORD PTR _eBuildNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getBuildIn
	mov	edx, DWORD PTR [ecx+1172]
	sub	edx, DWORD PTR [ecx+1168]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getBuildIn

; 3365 : 		return m_paBuildInfo[eBuildNum];

	mov	ecx, DWORD PTR [ecx+1168]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3369 : }

	ret	4
$LN2@getBuildIn:

; 3366 : #endif
; 3367 : 	else
; 3368 : 		return NULL;

	xor	eax, eax

; 3369 : }

	ret	4
?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ENDP ; CvGlobals::getBuildInfo
_TEXT	ENDS
PUBLIC	?getNumHandicapInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumHandicapInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumHandicapInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumHandicapInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumHandicapInfos, COMDAT
; _this$ = ecx

; 3378 : 	return (int)m_paHandicapInfo.size();

	mov	eax, DWORD PTR [ecx+1188]
	sub	eax, DWORD PTR [ecx+1184]
	sar	eax, 2

; 3379 : #endif
; 3380 : }

	ret	0
?getNumHandicapInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumHandicapInfos
_TEXT	ENDS
PUBLIC	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ; CvGlobals::getHandicapInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z
_TEXT	SEGMENT
_eHandicapNum$ = 8					; size = 4
?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z PROC ; CvGlobals::getHandicapInfo, COMDAT
; _this$ = ecx

; 3397 : 	CvAssert(eHandicapNum > -1);
; 3398 : 	CvAssert(eHandicapNum < GC.getNumHandicapInfos());
; 3399 : 	if(eHandicapNum > -1 && eHandicapNum < (int)m_paHandicapInfo.size())

	mov	eax, DWORD PTR _eHandicapNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getHandica
	mov	edx, DWORD PTR [ecx+1188]
	sub	edx, DWORD PTR [ecx+1184]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getHandica

; 3400 : 		return m_paHandicapInfo[eHandicapNum];

	mov	ecx, DWORD PTR [ecx+1184]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3404 : }

	ret	4
$LN2@getHandica:

; 3401 : #endif
; 3402 : 	else
; 3403 : 		return NULL;

	xor	eax, eax

; 3404 : }

	ret	4
?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ENDP ; CvGlobals::getHandicapInfo
_TEXT	ENDS
PUBLIC	?getNumGameSpeedInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumGameSpeedInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumGameSpeedInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumGameSpeedInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumGameSpeedInfos, COMDAT
; _this$ = ecx

; 3413 : 	return (int)m_paGameSpeedInfo.size();

	mov	eax, DWORD PTR [ecx+1204]
	sub	eax, DWORD PTR [ecx+1200]
	sar	eax, 2

; 3414 : #endif
; 3415 : }

	ret	0
?getNumGameSpeedInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumGameSpeedInfos
_TEXT	ENDS
PUBLIC	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z ; CvGlobals::getGameSpeedInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z
_TEXT	SEGMENT
_eGameSpeedNum$ = 8					; size = 4
?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z PROC ; CvGlobals::getGameSpeedInfo, COMDAT
; _this$ = ecx

; 3432 : 	CvAssert(eGameSpeedNum > -1);
; 3433 : 	CvAssert(eGameSpeedNum < GC.getNumGameSpeedInfos());
; 3434 : 	if(eGameSpeedNum > -1 && eGameSpeedNum < (int)m_paGameSpeedInfo.size())

	mov	eax, DWORD PTR _eGameSpeedNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getGameSpe
	mov	edx, DWORD PTR [ecx+1204]
	sub	edx, DWORD PTR [ecx+1200]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getGameSpe

; 3435 : 		return m_paGameSpeedInfo[eGameSpeedNum];

	mov	ecx, DWORD PTR [ecx+1200]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3439 : }

	ret	4
$LN2@getGameSpe:

; 3436 : #endif
; 3437 : 	else
; 3438 : 		return NULL;

	xor	eax, eax

; 3439 : }

	ret	4
?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z ENDP ; CvGlobals::getGameSpeedInfo
_TEXT	ENDS
PUBLIC	?getNumProcessInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumProcessInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumProcessInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumProcessInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumProcessInfos, COMDAT
; _this$ = ecx

; 3448 : 	return (int)m_paProcessInfo.size();

	mov	eax, DWORD PTR [ecx+1292]
	sub	eax, DWORD PTR [ecx+1288]
	sar	eax, 2

; 3449 : #endif
; 3450 : }

	ret	0
?getNumProcessInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumProcessInfos
_TEXT	ENDS
PUBLIC	?getProcessInfo@CvGlobals@@QAEPAVCvProcessInfo@@W4ProcessTypes@@@Z ; CvGlobals::getProcessInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getProcessInfo@CvGlobals@@QAEPAVCvProcessInfo@@W4ProcessTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getProcessInfo@CvGlobals@@QAEPAVCvProcessInfo@@W4ProcessTypes@@@Z PROC ; CvGlobals::getProcessInfo, COMDAT
; _this$ = ecx

; 3459 : #ifdef AUI_WARNING_FIXES
; 3460 : 	uint uiIndex = uint(e);
; 3461 : 	CvAssert(uiIndex < GC.getNumProcessInfos());
; 3462 : 	if (uiIndex < m_paProcessInfo.size())
; 3463 : 		return m_paProcessInfo[uiIndex];
; 3464 : #else
; 3465 : 	CvAssert(e > -1);
; 3466 : 	CvAssert(e < GC.getNumProcessInfos());
; 3467 : 	if(e > -1 && e < (int)m_paProcessInfo.size())

	mov	eax, DWORD PTR _e$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getProcess
	mov	edx, DWORD PTR [ecx+1292]
	sub	edx, DWORD PTR [ecx+1288]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getProcess

; 3468 : 		return m_paProcessInfo[e];

	mov	ecx, DWORD PTR [ecx+1288]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3472 : }

	ret	4
$LN2@getProcess:

; 3469 : #endif
; 3470 : 	else
; 3471 : 		return NULL;

	xor	eax, eax

; 3472 : }

	ret	4
?getProcessInfo@CvGlobals@@QAEPAVCvProcessInfo@@W4ProcessTypes@@@Z ENDP ; CvGlobals::getProcessInfo
_TEXT	ENDS
PUBLIC	?getNumVoteInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumVoteInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumVoteInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumVoteInfos@CvGlobals@@QAEHXZ PROC			; CvGlobals::getNumVoteInfos, COMDAT
; _this$ = ecx

; 3481 : 	return (int)m_paVoteInfo.size();

	mov	eax, DWORD PTR [ecx+1308]
	sub	eax, DWORD PTR [ecx+1304]
	sar	eax, 2

; 3482 : #endif
; 3483 : }

	ret	0
?getNumVoteInfos@CvGlobals@@QAEHXZ ENDP			; CvGlobals::getNumVoteInfos
_TEXT	ENDS
PUBLIC	?getVoteInfo@CvGlobals@@QAEPAVCvVoteInfo@@W4VoteTypes@@@Z ; CvGlobals::getVoteInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getVoteInfo@CvGlobals@@QAEPAVCvVoteInfo@@W4VoteTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getVoteInfo@CvGlobals@@QAEPAVCvVoteInfo@@W4VoteTypes@@@Z PROC ; CvGlobals::getVoteInfo, COMDAT
; _this$ = ecx

; 3492 : #ifdef AUI_WARNING_FIXES
; 3493 : 	uint uiIndex = uint(e);
; 3494 : 	CvAssert(uiIndex < GC.getNumVoteInfos());
; 3495 : 	if (uiIndex < m_paVoteInfo.size())
; 3496 : 		return m_paVoteInfo[uiIndex];
; 3497 : #else
; 3498 : 	CvAssert(e > -1);
; 3499 : 	CvAssert(e < GC.getNumVoteInfos());
; 3500 : 	if(e > -1 && e < (int)m_paVoteInfo.size())

	mov	eax, DWORD PTR _e$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getVoteInf
	mov	edx, DWORD PTR [ecx+1308]
	sub	edx, DWORD PTR [ecx+1304]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getVoteInf

; 3501 : 		return m_paVoteInfo[e];

	mov	ecx, DWORD PTR [ecx+1304]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3505 : }

	ret	4
$LN2@getVoteInf:

; 3502 : #endif
; 3503 : 	else
; 3504 : 		return NULL;

	xor	eax, eax

; 3505 : }

	ret	4
?getVoteInfo@CvGlobals@@QAEPAVCvVoteInfo@@W4VoteTypes@@@Z ENDP ; CvGlobals::getVoteInfo
_TEXT	ENDS
PUBLIC	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z PROC ; CvGlobals::getProjectInfo, COMDAT
; _this$ = ecx

; 3522 : {

	push	esi

; 3523 : #ifdef AUI_WARNING_FIXES
; 3524 : 	uint uiIndex = uint(e);
; 3525 : 	CvAssert(uiIndex < GC.getNumProjectInfos());
; 3526 : 	if (uiIndex < GC.getNumProjectInfos())
; 3527 : 		return m_pProjects->GetProjectEntries()[uiIndex];
; 3528 : #else
; 3529 : 	CvAssert(e > -1);
; 3530 : 	CvAssert(e < GC.getNumProjectInfos());
; 3531 : 	if(e > -1 && e < GC.getNumProjectInfos())

	mov	esi, DWORD PTR _e$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN2@getProject
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1708
	call	?GetNumProjects@CvProjectXMLEntries@@QAEHXZ ; CvProjectXMLEntries::GetNumProjects
	cmp	esi, eax
	jge	SHORT $LN2@getProject

; 3532 : 		return m_pProjects->GetProjectEntries()[e];

	mov	ecx, DWORD PTR [edi+1708]
	call	?GetProjectEntries@CvProjectXMLEntries@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ ; CvProjectXMLEntries::GetProjectEntries
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 3536 : }

	ret	4
$LN2@getProject:
	pop	edi

; 3533 : #endif
; 3534 : 	else
; 3535 : 		return NULL;

	xor	eax, eax
	pop	esi

; 3536 : }

	ret	4
?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ENDP ; CvGlobals::getProjectInfo
_TEXT	ENDS
PUBLIC	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingClassInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumBuildingClassInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumBuildingClassInfos@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNumBuildingClassInfos, COMDAT
; _this$ = ecx

; 3550 : 	return (int)m_paBuildingClassInfo.size();

	mov	eax, DWORD PTR [ecx+1324]
	sub	eax, DWORD PTR [ecx+1320]
	sar	eax, 2

; 3551 : #endif
; 3552 : }

	ret	0
?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNumBuildingClassInfos
_TEXT	ENDS
PUBLIC	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_eBuildingClassNum$ = 8					; size = 4
?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z PROC ; CvGlobals::getBuildingClassInfo, COMDAT
; _this$ = ecx

; 3569 : 	CvAssert(eBuildingClassNum > -1);
; 3570 : 	CvAssert(eBuildingClassNum < GC.getNumBuildingClassInfos());
; 3571 : 	if(eBuildingClassNum > -1 && eBuildingClassNum < (int)m_paBuildingClassInfo.size())

	mov	eax, DWORD PTR _eBuildingClassNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getBuildin
	mov	edx, DWORD PTR [ecx+1324]
	sub	edx, DWORD PTR [ecx+1320]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getBuildin

; 3572 : 		return m_paBuildingClassInfo[eBuildingClassNum];

	mov	ecx, DWORD PTR [ecx+1320]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3576 : }

	ret	4
$LN2@getBuildin:

; 3573 : #endif
; 3574 : 	else
; 3575 : 		return NULL;

	xor	eax, eax

; 3576 : }

	ret	4
?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ENDP ; CvGlobals::getBuildingClassInfo
_TEXT	ENDS
PUBLIC	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z
_TEXT	SEGMENT
_eBuildingNum$ = 8					; size = 4
?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z PROC ; CvGlobals::getBuildingInfo, COMDAT
; _this$ = ecx

; 3601 : {

	push	esi

; 3602 : 	CvAssert(eBuildingNum > -1);
; 3603 : 	CvAssert(eBuildingNum < GC.getNumBuildingInfos());
; 3604 : 	if(eBuildingNum > -1 && eBuildingNum < GC.getNumBuildingInfos())

	mov	esi, DWORD PTR _eBuildingNum$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN2@getBuildin@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1700
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	esi, eax
	jge	SHORT $LN2@getBuildin@2

; 3605 : 		return m_pBuildings->GetBuildingEntries()[eBuildingNum];

	mov	ecx, DWORD PTR [edi+1700]
	call	?GetBuildingEntries@CvBuildingXMLEntries@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ ; CvBuildingXMLEntries::GetBuildingEntries
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 3609 : }

	ret	4
$LN2@getBuildin@2:
	pop	edi

; 3606 : #endif
; 3607 : 	else
; 3608 : 		return NULL;

	xor	eax, eax
	pop	esi

; 3609 : }

	ret	4
?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ENDP ; CvGlobals::getBuildingInfo
_TEXT	ENDS
PUBLIC	?getNumUnitClassInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumUnitClassInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumUnitClassInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumUnitClassInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumUnitClassInfos, COMDAT
; _this$ = ecx

; 3623 : 	return (int)m_paUnitClassInfo.size();

	mov	eax, DWORD PTR [ecx+1340]
	sub	eax, DWORD PTR [ecx+1336]
	sar	eax, 2

; 3624 : #endif
; 3625 : }

	ret	0
?getNumUnitClassInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumUnitClassInfos
_TEXT	ENDS
PUBLIC	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z
_TEXT	SEGMENT
_eUnitClassNum$ = 8					; size = 4
?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z PROC ; CvGlobals::getUnitClassInfo, COMDAT
; _this$ = ecx

; 3638 : #ifdef AUI_WARNING_FIXES
; 3639 : 	uint uiIndex = uint(eUnitClassNum);
; 3640 : 	CvAssert(uiIndex < GC.getNumUnitClassInfos());
; 3641 : 	if (uiIndex < m_paUnitClassInfo.size())
; 3642 : 		return m_paUnitClassInfo[uiIndex];
; 3643 : #else
; 3644 : 	CvAssert(eUnitClassNum > -1);
; 3645 : 	CvAssert(eUnitClassNum < GC.getNumUnitClassInfos());
; 3646 : 	if(eUnitClassNum > -1 && eUnitClassNum < (int)m_paUnitClassInfo.size())

	mov	eax, DWORD PTR _eUnitClassNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getUnitCla
	mov	edx, DWORD PTR [ecx+1340]
	sub	edx, DWORD PTR [ecx+1336]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getUnitCla

; 3647 : 		return m_paUnitClassInfo[eUnitClassNum];

	mov	ecx, DWORD PTR [ecx+1336]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3651 : }

	ret	4
$LN2@getUnitCla:

; 3648 : #endif
; 3649 : 	else
; 3650 : 		return NULL;

	xor	eax, eax

; 3651 : }

	ret	4
?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ENDP ; CvGlobals::getUnitClassInfo
_TEXT	ENDS
PUBLIC	?getNumActionInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumActionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumActionInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumActionInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumActionInfos, COMDAT
; _this$ = ecx

; 3660 : 	return (int)m_paActionInfo.size();

	mov	eax, DWORD PTR [ecx+1484]
	sub	eax, DWORD PTR [ecx+1480]
	sar	eax, 2

; 3661 : #endif
; 3662 : }

	ret	0
?getNumActionInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumActionInfos
_TEXT	ENDS
PUBLIC	?getActionInfo@CvGlobals@@QAEPAVCvActionInfo@@H@Z ; CvGlobals::getActionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getActionInfo@CvGlobals@@QAEPAVCvActionInfo@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getActionInfo@CvGlobals@@QAEPAVCvActionInfo@@H@Z PROC	; CvGlobals::getActionInfo, COMDAT
; _this$ = ecx

; 3677 : 	CvAssertMsg(i < getNumActionInfos(), "Index out of bounds");
; 3678 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3679 : 	if(i > -1 && i < (int)m_paActionInfo.size())

	mov	eax, DWORD PTR _i$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getActionI
	mov	edx, DWORD PTR [ecx+1484]
	sub	edx, DWORD PTR [ecx+1480]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getActionI

; 3680 : #endif
; 3681 : 		return m_paActionInfo[i];

	mov	ecx, DWORD PTR [ecx+1480]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3684 : }

	ret	4
$LN2@getActionI:

; 3682 : 	else
; 3683 : 		return NULL;

	xor	eax, eax

; 3684 : }

	ret	4
?getActionInfo@CvGlobals@@QAEPAVCvActionInfo@@H@Z ENDP	; CvGlobals::getActionInfo
_TEXT	ENDS
PUBLIC	?getMissionInfo@CvGlobals@@QAEPAVCvMissionInfo@@W4MissionTypes@@@Z ; CvGlobals::getMissionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getMissionInfo@CvGlobals@@QAEPAVCvMissionInfo@@W4MissionTypes@@@Z
_TEXT	SEGMENT
_eMissionNum$ = 8					; size = 4
?getMissionInfo@CvGlobals@@QAEPAVCvMissionInfo@@W4MissionTypes@@@Z PROC ; CvGlobals::getMissionInfo, COMDAT
; _this$ = ecx

; 3701 : 	CvAssert(eMissionNum > -1);
; 3702 : 	CvAssert(static_cast<unsigned int>(eMissionNum) < CvTypes::getNUM_MISSION_TYPES());
; 3703 : 	if(eMissionNum > -1 && eMissionNum < (int)m_paMissionInfo.size())

	mov	eax, DWORD PTR _eMissionNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getMission
	mov	edx, DWORD PTR [ecx+1500]
	sub	edx, DWORD PTR [ecx+1496]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getMission

; 3704 : 		return m_paMissionInfo[eMissionNum];

	mov	ecx, DWORD PTR [ecx+1496]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3708 : }

	ret	4
$LN2@getMission:

; 3705 : #endif
; 3706 : 	else
; 3707 : 		return NULL;

	xor	eax, eax

; 3708 : }

	ret	4
?getMissionInfo@CvGlobals@@QAEPAVCvMissionInfo@@W4MissionTypes@@@Z ENDP ; CvGlobals::getMissionInfo
_TEXT	ENDS
PUBLIC	?getControlInfo@CvGlobals@@QAEPAVCvControlInfo@@W4ControlTypes@@@Z ; CvGlobals::getControlInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getControlInfo@CvGlobals@@QAEPAVCvControlInfo@@W4ControlTypes@@@Z
_TEXT	SEGMENT
_eControlNum$ = 8					; size = 4
?getControlInfo@CvGlobals@@QAEPAVCvControlInfo@@W4ControlTypes@@@Z PROC ; CvGlobals::getControlInfo, COMDAT
; _this$ = ecx

; 3725 : 	CvAssert(eControlNum > -1);
; 3726 : 	CvAssert(eControlNum < NUM_CONTROL_TYPES);
; 3727 : 	if(eControlNum > -1 && eControlNum < (int)m_paControlInfo.size())

	mov	eax, DWORD PTR _eControlNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getControl
	mov	edx, DWORD PTR [ecx+1516]
	sub	edx, DWORD PTR [ecx+1512]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getControl

; 3728 : 		return m_paControlInfo[eControlNum];

	mov	ecx, DWORD PTR [ecx+1512]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3732 : }

	ret	4
$LN2@getControl:

; 3729 : #endif
; 3730 : 	else
; 3731 : 		return NULL;

	xor	eax, eax

; 3732 : }

	ret	4
?getControlInfo@CvGlobals@@QAEPAVCvControlInfo@@W4ControlTypes@@@Z ENDP ; CvGlobals::getControlInfo
_TEXT	ENDS
PUBLIC	?getCommandInfo@CvGlobals@@QAEPAVCvCommandInfo@@W4CommandTypes@@@Z ; CvGlobals::getCommandInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getCommandInfo@CvGlobals@@QAEPAVCvCommandInfo@@W4CommandTypes@@@Z
_TEXT	SEGMENT
_eCommandNum$ = 8					; size = 4
?getCommandInfo@CvGlobals@@QAEPAVCvCommandInfo@@W4CommandTypes@@@Z PROC ; CvGlobals::getCommandInfo, COMDAT
; _this$ = ecx

; 3749 : 	CvAssert(eCommandNum > -1);
; 3750 : 	CvAssert(eCommandNum < NUM_COMMAND_TYPES);
; 3751 : 	if(eCommandNum > -1 && eCommandNum < (int)m_paCommandInfo.size())

	mov	eax, DWORD PTR _eCommandNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getCommand
	mov	edx, DWORD PTR [ecx+1532]
	sub	edx, DWORD PTR [ecx+1528]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getCommand

; 3752 : 		return m_paCommandInfo[eCommandNum];

	mov	ecx, DWORD PTR [ecx+1528]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3756 : }

	ret	4
$LN2@getCommand:

; 3753 : #endif
; 3754 : 	else
; 3755 : 		return NULL;

	xor	eax, eax

; 3756 : }

	ret	4
?getCommandInfo@CvGlobals@@QAEPAVCvCommandInfo@@W4CommandTypes@@@Z ENDP ; CvGlobals::getCommandInfo
_TEXT	ENDS
PUBLIC	?getNumAutomateInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumAutomateInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumAutomateInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumAutomateInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumAutomateInfos, COMDAT
; _this$ = ecx

; 3765 : 	return (int)m_paAutomateInfo.size();

	mov	eax, DWORD PTR [ecx+1548]
	sub	eax, DWORD PTR [ecx+1544]
	sar	eax, 2

; 3766 : #endif
; 3767 : }

	ret	0
?getNumAutomateInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumAutomateInfos
_TEXT	ENDS
PUBLIC	?getAutomateInfo@CvGlobals@@QAEPAVCvAutomateInfo@@H@Z ; CvGlobals::getAutomateInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getAutomateInfo@CvGlobals@@QAEPAVCvAutomateInfo@@H@Z
_TEXT	SEGMENT
_iAutomateNum$ = 8					; size = 4
?getAutomateInfo@CvGlobals@@QAEPAVCvAutomateInfo@@H@Z PROC ; CvGlobals::getAutomateInfo, COMDAT
; _this$ = ecx

; 3780 : 	CvAssertMsg(iAutomateNum < getNumAutomateInfos(), "Index out of bounds");
; 3781 : 	CvAssertMsg(iAutomateNum > -1, "Index out of bounds");
; 3782 : #ifdef AUI_WARNING_FIXES
; 3783 : 	if (iAutomateNum < m_paAutomateInfo.size())
; 3784 : #else
; 3785 : 	if(iAutomateNum > -1 && iAutomateNum < (int)m_paAutomateInfo.size())

	mov	eax, DWORD PTR _iAutomateNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getAutomat
	mov	edx, DWORD PTR [ecx+1548]
	sub	edx, DWORD PTR [ecx+1544]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getAutomat

; 3786 : #endif
; 3787 : 		return m_paAutomateInfo[iAutomateNum];

	mov	ecx, DWORD PTR [ecx+1544]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3790 : }

	ret	4
$LN2@getAutomat:

; 3788 : 	else
; 3789 : 		return NULL;

	xor	eax, eax

; 3790 : }

	ret	4
?getAutomateInfo@CvGlobals@@QAEPAVCvAutomateInfo@@H@Z ENDP ; CvGlobals::getAutomateInfo
_TEXT	ENDS
PUBLIC	?getNumPromotionInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumPromotionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumPromotionInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumPromotionInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumPromotionInfos, COMDAT
; _this$ = ecx

; 3799 : 	return (int)m_pPromotions->GetPromotionEntries().size();

	mov	ecx, DWORD PTR [ecx+1712]
	call	?GetPromotionEntries@CvPromotionXMLEntries@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ ; CvPromotionXMLEntries::GetPromotionEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 3800 : #endif
; 3801 : }

	ret	0
?getNumPromotionInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumPromotionInfos
_TEXT	ENDS
PUBLIC	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z
_TEXT	SEGMENT
_ePromotionNum$ = 8					; size = 4
?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z PROC ; CvGlobals::getPromotionInfo, COMDAT
; _this$ = ecx

; 3817 : {

	push	esi

; 3818 : 	CvAssert(ePromotionNum > -1);
; 3819 : 	CvAssert(ePromotionNum < GC.getNumPromotionInfos());
; 3820 : 	if(ePromotionNum > -1 && ePromotionNum < GC.getNumPromotionInfos())

	mov	esi, DWORD PTR _ePromotionNum$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN2@getPromoti
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1712
	call	?GetPromotionEntries@CvPromotionXMLEntries@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ ; CvPromotionXMLEntries::GetPromotionEntries
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	esi, ecx
	jge	SHORT $LN2@getPromoti

; 3821 : 		return m_pPromotions->GetPromotionEntries()[ePromotionNum];

	mov	ecx, DWORD PTR [edi+1712]
	call	?GetPromotionEntries@CvPromotionXMLEntries@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ ; CvPromotionXMLEntries::GetPromotionEntries
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+esi*4]
	pop	edi
	pop	esi

; 3825 : }

	ret	4
$LN2@getPromoti:
	pop	edi

; 3822 : #endif
; 3823 : 	else
; 3824 : 		return NULL;

	xor	eax, eax
	pop	esi

; 3825 : }

	ret	4
?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ENDP ; CvGlobals::getPromotionInfo
_TEXT	ENDS
PUBLIC	?getNumSpecialistInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumSpecialistInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumSpecialistInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumSpecialistInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumSpecialistInfos, COMDAT
; _this$ = ecx

; 3839 : 	return (int)m_paSpecialistInfo.size();

	mov	eax, DWORD PTR [ecx+1468]
	sub	eax, DWORD PTR [ecx+1464]
	sar	eax, 2

; 3840 : #endif
; 3841 : }

	ret	0
?getNumSpecialistInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumSpecialistInfos
_TEXT	ENDS
PUBLIC	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z
_TEXT	SEGMENT
_eSpecialistNum$ = 8					; size = 4
?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z PROC ; CvGlobals::getSpecialistInfo, COMDAT
; _this$ = ecx

; 3858 : 	CvAssert(eSpecialistNum > -1);
; 3859 : 	CvAssert(eSpecialistNum < GC.getNumSpecialistInfos());
; 3860 : 	if(eSpecialistNum > -1 && eSpecialistNum < (int)m_paSpecialistInfo.size())

	mov	eax, DWORD PTR _eSpecialistNum$[esp-4]
	cmp	eax, -1
	jle	SHORT $LN2@getSpecial@2
	mov	edx, DWORD PTR [ecx+1468]
	sub	edx, DWORD PTR [ecx+1464]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN2@getSpecial@2

; 3861 : 		return m_paSpecialistInfo[eSpecialistNum];

	mov	ecx, DWORD PTR [ecx+1464]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3865 : }

	ret	4
$LN2@getSpecial@2:

; 3862 : #endif
; 3863 : 	else
; 3864 : 		return NULL;

	xor	eax, eax

; 3865 : }

	ret	4
?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ENDP ; CvGlobals::getSpecialistInfo
_TEXT	ENDS
PUBLIC	?getNumEconomicAIStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumEconomicAIStrategyInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumEconomicAIStrategyInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumEconomicAIStrategyInfos@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNumEconomicAIStrategyInfos, COMDAT
; _this$ = ecx

; 3874 : 	return (int)m_pEconomicAIStrategies->GetEconomicAIStrategyEntries().size();

	mov	ecx, DWORD PTR [ecx+1668]
	call	?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ ; CvEconomicAIStrategyXMLEntries::GetEconomicAIStrategyEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 3875 : #endif
; 3876 : }

	ret	0
?getNumEconomicAIStrategyInfos@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNumEconomicAIStrategyInfos
_TEXT	ENDS
PUBLIC	?getEconomicAIStrategyInfo@CvGlobals@@QAEPAVCvEconomicAIStrategyXMLEntry@@W4EconomicAIStrategyTypes@@@Z ; CvGlobals::getEconomicAIStrategyInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getEconomicAIStrategyInfo@CvGlobals@@QAEPAVCvEconomicAIStrategyXMLEntry@@W4EconomicAIStrategyTypes@@@Z
_TEXT	SEGMENT
_eAIStrategyNum$ = 8					; size = 4
?getEconomicAIStrategyInfo@CvGlobals@@QAEPAVCvEconomicAIStrategyXMLEntry@@W4EconomicAIStrategyTypes@@@Z PROC ; CvGlobals::getEconomicAIStrategyInfo, COMDAT
; _this$ = ecx

; 3892 : {

	push	esi

; 3893 : 	FAssert(eAIStrategyNum > -1);
; 3894 : 	FAssert(eAIStrategyNum < GC.getNumEconomicAIStrategyInfos());
; 3895 : 	if(eAIStrategyNum > -1 && eAIStrategyNum < GC.getNumEconomicAIStrategyInfos())

	mov	esi, DWORD PTR _eAIStrategyNum$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN2@getEconomi
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1668
	call	?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ ; CvEconomicAIStrategyXMLEntries::GetEconomicAIStrategyEntries
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	esi, ecx
	jge	SHORT $LN2@getEconomi

; 3896 : 		return m_pEconomicAIStrategies->GetEconomicAIStrategyEntries()[eAIStrategyNum];

	mov	ecx, DWORD PTR [edi+1668]
	call	?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ ; CvEconomicAIStrategyXMLEntries::GetEconomicAIStrategyEntries
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+esi*4]
	pop	edi
	pop	esi

; 3900 : }

	ret	4
$LN2@getEconomi:
	pop	edi

; 3897 : #endif
; 3898 : 	else
; 3899 : 		return NULL;

	xor	eax, eax
	pop	esi

; 3900 : }

	ret	4
?getEconomicAIStrategyInfo@CvGlobals@@QAEPAVCvEconomicAIStrategyXMLEntry@@W4EconomicAIStrategyTypes@@@Z ENDP ; CvGlobals::getEconomicAIStrategyInfo
_TEXT	ENDS
PUBLIC	?getNumCitySpecializationInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumCitySpecializationInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumCitySpecializationInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumCitySpecializationInfos@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNumCitySpecializationInfos, COMDAT
; _this$ = ecx

; 3914 : 	return (int)m_pCitySpecializations->GetCitySpecializationEntries().size();

	mov	ecx, DWORD PTR [ecx+1672]
	call	?GetCitySpecializationEntries@CvCitySpecializationXMLEntries@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ ; CvCitySpecializationXMLEntries::GetCitySpecializationEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 3915 : #endif
; 3916 : }

	ret	0
?getNumCitySpecializationInfos@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNumCitySpecializationInfos
_TEXT	ENDS
PUBLIC	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z ; CvGlobals::getCitySpecializationInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z
_TEXT	SEGMENT
_eCitySpecialization$ = 8				; size = 4
?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z PROC ; CvGlobals::getCitySpecializationInfo, COMDAT
; _this$ = ecx

; 3932 : {

	push	esi

; 3933 : 	CvAssert(eCitySpecialization > -1);
; 3934 : 	CvAssert(eCitySpecialization < GC.getNumCitySpecializationInfos());
; 3935 : 	if(eCitySpecialization > -1 && eCitySpecialization < GC.getNumCitySpecializationInfos())

	mov	esi, DWORD PTR _eCitySpecialization$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN2@getCitySpe
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1672
	call	?GetCitySpecializationEntries@CvCitySpecializationXMLEntries@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ ; CvCitySpecializationXMLEntries::GetCitySpecializationEntries
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	esi, ecx
	jge	SHORT $LN2@getCitySpe

; 3936 : 		return m_pCitySpecializations->GetCitySpecializationEntries()[eCitySpecialization];

	mov	ecx, DWORD PTR [edi+1672]
	call	?GetCitySpecializationEntries@CvCitySpecializationXMLEntries@@QAEAAV?$vector@PAVCvCitySpecializationXMLEntry@@V?$allocator@PAVCvCitySpecializationXMLEntry@@@std@@@std@@XZ ; CvCitySpecializationXMLEntries::GetCitySpecializationEntries
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+esi*4]
	pop	edi
	pop	esi

; 3940 : }

	ret	4
$LN2@getCitySpe:
	pop	edi

; 3937 : #endif
; 3938 : 	else
; 3939 : 		return NULL;

	xor	eax, eax
	pop	esi

; 3940 : }

	ret	4
?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z ENDP ; CvGlobals::getCitySpecializationInfo
_TEXT	ENDS
PUBLIC	?getNumTacticalMoveInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTacticalMoveInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumTacticalMoveInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumTacticalMoveInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumTacticalMoveInfos, COMDAT
; _this$ = ecx

; 3954 : 	return (int)m_pTacticalMoves->GetTacticalMoveEntries().size();

	mov	ecx, DWORD PTR [ecx+1676]
	call	?GetTacticalMoveEntries@CvTacticalMoveXMLEntries@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ ; CvTacticalMoveXMLEntries::GetTacticalMoveEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 3955 : #endif
; 3956 : }

	ret	0
?getNumTacticalMoveInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumTacticalMoveInfos
_TEXT	ENDS
PUBLIC	?getTacticalMoveInfo@CvGlobals@@QAEPAVCvTacticalMoveXMLEntry@@W4TacticalAIMoveTypes@@@Z ; CvGlobals::getTacticalMoveInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getTacticalMoveInfo@CvGlobals@@QAEPAVCvTacticalMoveXMLEntry@@W4TacticalAIMoveTypes@@@Z
_TEXT	SEGMENT
_eTacticalMove$ = 8					; size = 4
?getTacticalMoveInfo@CvGlobals@@QAEPAVCvTacticalMoveXMLEntry@@W4TacticalAIMoveTypes@@@Z PROC ; CvGlobals::getTacticalMoveInfo, COMDAT
; _this$ = ecx

; 3972 : {

	push	esi

; 3973 : 	FAssert(eTacticalMove > -1);
; 3974 : 	FAssert(eTacticalMove < GC.getNumTacticalMoveInfos());
; 3975 : 	if(eTacticalMove > -1 && eTacticalMove < GC.getNumTacticalMoveInfos())

	mov	esi, DWORD PTR _eTacticalMove$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN2@getTactica
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1676
	call	?GetTacticalMoveEntries@CvTacticalMoveXMLEntries@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ ; CvTacticalMoveXMLEntries::GetTacticalMoveEntries
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	esi, ecx
	jge	SHORT $LN2@getTactica

; 3976 : 		return m_pTacticalMoves->GetTacticalMoveEntries()[eTacticalMove];

	mov	ecx, DWORD PTR [edi+1676]
	call	?GetTacticalMoveEntries@CvTacticalMoveXMLEntries@@QAEAAV?$vector@PAVCvTacticalMoveXMLEntry@@V?$allocator@PAVCvTacticalMoveXMLEntry@@@std@@@std@@XZ ; CvTacticalMoveXMLEntries::GetTacticalMoveEntries
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+esi*4]
	pop	edi
	pop	esi

; 3980 : }

	ret	4
$LN2@getTactica:
	pop	edi

; 3977 : #endif
; 3978 : 	else
; 3979 : 		return NULL;

	xor	eax, eax
	pop	esi

; 3980 : }

	ret	4
?getTacticalMoveInfo@CvGlobals@@QAEPAVCvTacticalMoveXMLEntry@@W4TacticalAIMoveTypes@@@Z ENDP ; CvGlobals::getTacticalMoveInfo
_TEXT	ENDS
PUBLIC	?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumMilitaryAIStrategyInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNumMilitaryAIStrategyInfos, COMDAT
; _this$ = ecx

; 3994 : 	return (int)m_pMilitaryAIStrategies->GetMilitaryAIStrategyEntries().size();

	mov	ecx, DWORD PTR [ecx+1680]
	call	?GetMilitaryAIStrategyEntries@CvMilitaryAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ ; CvMilitaryAIStrategyXMLEntries::GetMilitaryAIStrategyEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 3995 : #endif
; 3996 : }

	ret	0
?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNumMilitaryAIStrategyInfos
_TEXT	ENDS
PUBLIC	?getMilitaryAIStrategyInfo@CvGlobals@@QAEPAVCvMilitaryAIStrategyXMLEntry@@W4MilitaryAIStrategyTypes@@@Z ; CvGlobals::getMilitaryAIStrategyInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getMilitaryAIStrategyInfo@CvGlobals@@QAEPAVCvMilitaryAIStrategyXMLEntry@@W4MilitaryAIStrategyTypes@@@Z
_TEXT	SEGMENT
_eAIStrategyNum$ = 8					; size = 4
?getMilitaryAIStrategyInfo@CvGlobals@@QAEPAVCvMilitaryAIStrategyXMLEntry@@W4MilitaryAIStrategyTypes@@@Z PROC ; CvGlobals::getMilitaryAIStrategyInfo, COMDAT
; _this$ = ecx

; 4015 : 	FAssert(eAIStrategyNum < GC.getNumMilitaryAIStrategyInfos());
; 4016 : 	return m_pMilitaryAIStrategies->GetMilitaryAIStrategyEntries()[eAIStrategyNum];

	mov	ecx, DWORD PTR [ecx+1680]
	call	?GetMilitaryAIStrategyEntries@CvMilitaryAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ ; CvMilitaryAIStrategyXMLEntries::GetMilitaryAIStrategyEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eAIStrategyNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4017 : #endif
; 4018 : }

	ret	4
?getMilitaryAIStrategyInfo@CvGlobals@@QAEPAVCvMilitaryAIStrategyXMLEntry@@W4MilitaryAIStrategyTypes@@@Z ENDP ; CvGlobals::getMilitaryAIStrategyInfo
_TEXT	ENDS
PUBLIC	?getNumAIGrandStrategyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumAIGrandStrategyInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumAIGrandStrategyInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumAIGrandStrategyInfos@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNumAIGrandStrategyInfos, COMDAT
; _this$ = ecx

; 4032 : 	return (int)m_pAIGrandStrategies->GetAIGrandStrategyEntries().size();

	mov	ecx, DWORD PTR [ecx+1684]
	call	?GetAIGrandStrategyEntries@CvAIGrandStrategyXMLEntries@@QAEAAV?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@XZ ; CvAIGrandStrategyXMLEntries::GetAIGrandStrategyEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4033 : #endif
; 4034 : }

	ret	0
?getNumAIGrandStrategyInfos@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNumAIGrandStrategyInfos
_TEXT	ENDS
PUBLIC	?getAIGrandStrategyInfo@CvGlobals@@QAEPAVCvAIGrandStrategyXMLEntry@@W4AIGrandStrategyTypes@@@Z ; CvGlobals::getAIGrandStrategyInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getAIGrandStrategyInfo@CvGlobals@@QAEPAVCvAIGrandStrategyXMLEntry@@W4AIGrandStrategyTypes@@@Z
_TEXT	SEGMENT
_eAIGrandStrategyNum$ = 8				; size = 4
?getAIGrandStrategyInfo@CvGlobals@@QAEPAVCvAIGrandStrategyXMLEntry@@W4AIGrandStrategyTypes@@@Z PROC ; CvGlobals::getAIGrandStrategyInfo, COMDAT
; _this$ = ecx

; 4053 : 	CvAssert(eAIGrandStrategyNum > -1);
; 4054 : 	CvAssert(eAIGrandStrategyNum < GC.getNumAIGrandStrategyInfos());
; 4055 : 	return m_pAIGrandStrategies->GetAIGrandStrategyEntries()[eAIGrandStrategyNum];

	mov	ecx, DWORD PTR [ecx+1684]
	call	?GetAIGrandStrategyEntries@CvAIGrandStrategyXMLEntries@@QAEAAV?$vector@PAVCvAIGrandStrategyXMLEntry@@V?$allocator@PAVCvAIGrandStrategyXMLEntry@@@std@@@std@@XZ ; CvAIGrandStrategyXMLEntries::GetAIGrandStrategyEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eAIGrandStrategyNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4056 : #endif
; 4057 : }

	ret	4
?getAIGrandStrategyInfo@CvGlobals@@QAEPAVCvAIGrandStrategyXMLEntry@@W4AIGrandStrategyTypes@@@Z ENDP ; CvGlobals::getAIGrandStrategyInfo
_TEXT	ENDS
PUBLIC	?getNumAICityStrategyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumAICityStrategyInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumAICityStrategyInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumAICityStrategyInfos@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNumAICityStrategyInfos, COMDAT
; _this$ = ecx

; 4071 : 	return (int)m_pAICityStrategies->GetAICityStrategyEntries().size();

	mov	ecx, DWORD PTR [ecx+1688]
	call	?GetAICityStrategyEntries@CvAICityStrategies@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ ; CvAICityStrategies::GetAICityStrategyEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4072 : #endif
; 4073 : }

	ret	0
?getNumAICityStrategyInfos@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNumAICityStrategyInfos
_TEXT	ENDS
PUBLIC	?getAICityStrategyInfo@CvGlobals@@QAEPAVCvAICityStrategyEntry@@W4AICityStrategyTypes@@@Z ; CvGlobals::getAICityStrategyInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getAICityStrategyInfo@CvGlobals@@QAEPAVCvAICityStrategyEntry@@W4AICityStrategyTypes@@@Z
_TEXT	SEGMENT
_eAICityStrategyNum$ = 8				; size = 4
?getAICityStrategyInfo@CvGlobals@@QAEPAVCvAICityStrategyEntry@@W4AICityStrategyTypes@@@Z PROC ; CvGlobals::getAICityStrategyInfo, COMDAT
; _this$ = ecx

; 4092 : 	CvAssert(eAICityStrategyNum > -1);
; 4093 : 	CvAssert(eAICityStrategyNum < GC.getNumAICityStrategyInfos());
; 4094 : 	return m_pAICityStrategies->GetAICityStrategyEntries()[eAICityStrategyNum];

	mov	ecx, DWORD PTR [ecx+1688]
	call	?GetAICityStrategyEntries@CvAICityStrategies@@QAEAAV?$vector@PAVCvAICityStrategyEntry@@V?$allocator@PAVCvAICityStrategyEntry@@@std@@@std@@XZ ; CvAICityStrategies::GetAICityStrategyEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eAICityStrategyNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4095 : #endif
; 4096 : }

	ret	4
?getAICityStrategyInfo@CvGlobals@@QAEPAVCvAICityStrategyEntry@@W4AICityStrategyTypes@@@Z ENDP ; CvGlobals::getAICityStrategyInfo
_TEXT	ENDS
PUBLIC	?getNumPolicyInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumPolicyInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumPolicyInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumPolicyInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumPolicyInfos, COMDAT
; _this$ = ecx

; 4110 : 	return (int)m_pPolicies->GetPolicyEntries().size();

	mov	ecx, DWORD PTR [ecx+1692]
	call	?GetPolicyEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ ; CvPolicyXMLEntries::GetPolicyEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4111 : #endif
; 4112 : }

	ret	0
?getNumPolicyInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumPolicyInfos
_TEXT	ENDS
PUBLIC	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z
_TEXT	SEGMENT
_ePolicyNum$ = 8					; size = 4
?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z PROC ; CvGlobals::getPolicyInfo, COMDAT
; _this$ = ecx

; 4131 : 	CvAssert(ePolicyNum > -1);
; 4132 : 	CvAssert(ePolicyNum < GC.getNumPolicyInfos());
; 4133 : 	return m_pPolicies->GetPolicyEntries()[ePolicyNum];

	mov	ecx, DWORD PTR [ecx+1692]
	call	?GetPolicyEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ ; CvPolicyXMLEntries::GetPolicyEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _ePolicyNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4134 : #endif
; 4135 : }

	ret	4
?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ENDP ; CvGlobals::getPolicyInfo
_TEXT	ENDS
PUBLIC	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyBranchInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumPolicyBranchInfos, COMDAT
; _this$ = ecx

; 4149 : 	return (int)m_pPolicies->GetPolicyBranchEntries().size();

	mov	ecx, DWORD PTR [ecx+1692]
	call	?GetPolicyBranchEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ ; CvPolicyXMLEntries::GetPolicyBranchEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4150 : #endif
; 4151 : }

	ret	0
?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumPolicyBranchInfos
_TEXT	ENDS
PUBLIC	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_ePolicyBranchNum$ = 8					; size = 4
?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z PROC ; CvGlobals::getPolicyBranchInfo, COMDAT
; _this$ = ecx

; 4170 : 	CvAssert(ePolicyBranchNum > -1);
; 4171 : 	CvAssert(ePolicyBranchNum < GC.getNumPolicyBranchInfos());
; 4172 : 	return m_pPolicies->GetPolicyBranchEntries()[ePolicyBranchNum];

	mov	ecx, DWORD PTR [ecx+1692]
	call	?GetPolicyBranchEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ ; CvPolicyXMLEntries::GetPolicyBranchEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _ePolicyBranchNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4173 : #endif
; 4174 : }

	ret	4
?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ENDP ; CvGlobals::getPolicyBranchInfo
_TEXT	ENDS
PUBLIC	?getNumEmphasisInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumEmphasisInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumEmphasisInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumEmphasisInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumEmphasisInfos, COMDAT
; _this$ = ecx

; 4183 : 	return (int)m_pEmphases->GetEmphasisEntries().size();

	mov	ecx, DWORD PTR [ecx+1720]
	call	?GetEmphasisEntries@CvEmphasisXMLEntries@@QAEAAV?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@XZ ; CvEmphasisXMLEntries::GetEmphasisEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4184 : #endif
; 4185 : }

	ret	0
?getNumEmphasisInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumEmphasisInfos
_TEXT	ENDS
PUBLIC	?getEmphasisInfo@CvGlobals@@QAEPAVCvEmphasisEntry@@W4EmphasizeTypes@@@Z ; CvGlobals::getEmphasisInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getEmphasisInfo@CvGlobals@@QAEPAVCvEmphasisEntry@@W4EmphasizeTypes@@@Z
_TEXT	SEGMENT
_eEmphasisNum$ = 8					; size = 4
?getEmphasisInfo@CvGlobals@@QAEPAVCvEmphasisEntry@@W4EmphasizeTypes@@@Z PROC ; CvGlobals::getEmphasisInfo, COMDAT
; _this$ = ecx

; 4204 : 	CvAssert(eEmphasisNum > -1);
; 4205 : 	CvAssert(eEmphasisNum < GC.getNumEmphasisInfos());
; 4206 : 	return m_pEmphases->GetEmphasisEntries()[eEmphasisNum];

	mov	ecx, DWORD PTR [ecx+1720]
	call	?GetEmphasisEntries@CvEmphasisXMLEntries@@QAEAAV?$vector@PAVCvEmphasisEntry@@V?$allocator@PAVCvEmphasisEntry@@@std@@@std@@XZ ; CvEmphasisXMLEntries::GetEmphasisEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eEmphasisNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4207 : #endif
; 4208 : }

	ret	4
?getEmphasisInfo@CvGlobals@@QAEPAVCvEmphasisEntry@@W4EmphasizeTypes@@@Z ENDP ; CvGlobals::getEmphasisInfo
_TEXT	ENDS
PUBLIC	?getNumTraitInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumTraitInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumTraitInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumTraitInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumTraitInfos, COMDAT
; _this$ = ecx

; 4222 : 	return (int)m_pTraits->GetTraitEntries().size();

	mov	ecx, DWORD PTR [ecx+1724]
	call	?GetTraitEntries@CvTraitXMLEntries@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ ; CvTraitXMLEntries::GetTraitEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4223 : #endif
; 4224 : }

	ret	0
?getNumTraitInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumTraitInfos
_TEXT	ENDS
PUBLIC	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z
_TEXT	SEGMENT
_eTraitNum$ = 8						; size = 4
?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z PROC ; CvGlobals::getTraitInfo, COMDAT
; _this$ = ecx

; 4243 : 	CvAssert(eTraitNum > -1);
; 4244 : 	CvAssert(eTraitNum < GC.getNumTraitInfos());
; 4245 : 	return m_pTraits->GetTraitEntries()[eTraitNum];

	mov	ecx, DWORD PTR [ecx+1724]
	call	?GetTraitEntries@CvTraitXMLEntries@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ ; CvTraitXMLEntries::GetTraitEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eTraitNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4246 : #endif
; 4247 : }

	ret	4
?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ENDP ; CvGlobals::getTraitInfo
_TEXT	ENDS
PUBLIC	?getNumReligionInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumReligionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumReligionInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumReligionInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumReligionInfos, COMDAT
; _this$ = ecx

; 4261 : 	return (int)m_pReligions->GetReligionEntries().size();

	mov	ecx, DWORD PTR [ecx+1728]
	call	?GetReligionEntries@CvReligionXMLEntries@@QAEAAV?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@XZ ; CvReligionXMLEntries::GetReligionEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4262 : #endif
; 4263 : }

	ret	0
?getNumReligionInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumReligionInfos
_TEXT	ENDS
PUBLIC	?getReligionInfo@CvGlobals@@QAEPAVCvReligionEntry@@W4ReligionTypes@@@Z ; CvGlobals::getReligionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getReligionInfo@CvGlobals@@QAEPAVCvReligionEntry@@W4ReligionTypes@@@Z
_TEXT	SEGMENT
_eReligionNum$ = 8					; size = 4
?getReligionInfo@CvGlobals@@QAEPAVCvReligionEntry@@W4ReligionTypes@@@Z PROC ; CvGlobals::getReligionInfo, COMDAT
; _this$ = ecx

; 4282 : 	CvAssert(eReligionNum > -1);
; 4283 : 	CvAssert(eReligionNum < GC.getNumReligionInfos());
; 4284 : 	return m_pReligions->GetReligionEntries()[eReligionNum];

	mov	ecx, DWORD PTR [ecx+1728]
	call	?GetReligionEntries@CvReligionXMLEntries@@QAEAAV?$vector@PAVCvReligionEntry@@V?$allocator@PAVCvReligionEntry@@@std@@@std@@XZ ; CvReligionXMLEntries::GetReligionEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eReligionNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4285 : #endif
; 4286 : }

	ret	4
?getReligionInfo@CvGlobals@@QAEPAVCvReligionEntry@@W4ReligionTypes@@@Z ENDP ; CvGlobals::getReligionInfo
_TEXT	ENDS
PUBLIC	?getNumBeliefInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumBeliefInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumBeliefInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumBeliefInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumBeliefInfos, COMDAT
; _this$ = ecx

; 4300 : 	return (int)m_pBeliefs->GetBeliefEntries().size();

	mov	ecx, DWORD PTR [ecx+1732]
	call	?GetBeliefEntries@CvBeliefXMLEntries@@QAEAAV?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@XZ ; CvBeliefXMLEntries::GetBeliefEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4301 : #endif
; 4302 : }

	ret	0
?getNumBeliefInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumBeliefInfos
_TEXT	ENDS
PUBLIC	?getBeliefInfo@CvGlobals@@QAEPAVCvBeliefEntry@@W4BeliefTypes@@@Z ; CvGlobals::getBeliefInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getBeliefInfo@CvGlobals@@QAEPAVCvBeliefEntry@@W4BeliefTypes@@@Z
_TEXT	SEGMENT
_eBeliefNum$ = 8					; size = 4
?getBeliefInfo@CvGlobals@@QAEPAVCvBeliefEntry@@W4BeliefTypes@@@Z PROC ; CvGlobals::getBeliefInfo, COMDAT
; _this$ = ecx

; 4321 : 	CvAssert(eBeliefNum > -1);
; 4322 : 	CvAssert(eBeliefNum < GC.getNumBeliefInfos());
; 4323 : 	return m_pBeliefs->GetBeliefEntries()[eBeliefNum];

	mov	ecx, DWORD PTR [ecx+1732]
	call	?GetBeliefEntries@CvBeliefXMLEntries@@QAEAAV?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@XZ ; CvBeliefXMLEntries::GetBeliefEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eBeliefNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4324 : #endif
; 4325 : }

	ret	4
?getBeliefInfo@CvGlobals@@QAEPAVCvBeliefEntry@@W4BeliefTypes@@@Z ENDP ; CvGlobals::getBeliefInfo
_TEXT	ENDS
PUBLIC	?getNumLeagueSpecialSessionInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumLeagueSpecialSessionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumLeagueSpecialSessionInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumLeagueSpecialSessionInfos@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNumLeagueSpecialSessionInfos, COMDAT
; _this$ = ecx

; 4339 : 	return (int) m_pLeagueSpecialSessions->GetLeagueSpecialSessionEntries().size();

	mov	ecx, DWORD PTR [ecx+1736]
	call	?GetLeagueSpecialSessionEntries@CvLeagueSpecialSessionXMLEntries@@QAEAAV?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@XZ ; CvLeagueSpecialSessionXMLEntries::GetLeagueSpecialSessionEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4340 : #endif
; 4341 : }

	ret	0
?getNumLeagueSpecialSessionInfos@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNumLeagueSpecialSessionInfos
_TEXT	ENDS
PUBLIC	?getLeagueSpecialSessionInfo@CvGlobals@@QAEPAVCvLeagueSpecialSessionEntry@@W4LeagueSpecialSessionTypes@@@Z ; CvGlobals::getLeagueSpecialSessionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getLeagueSpecialSessionInfo@CvGlobals@@QAEPAVCvLeagueSpecialSessionEntry@@W4LeagueSpecialSessionTypes@@@Z
_TEXT	SEGMENT
_eLeagueSpecialSessionNum$ = 8				; size = 4
?getLeagueSpecialSessionInfo@CvGlobals@@QAEPAVCvLeagueSpecialSessionEntry@@W4LeagueSpecialSessionTypes@@@Z PROC ; CvGlobals::getLeagueSpecialSessionInfo, COMDAT
; _this$ = ecx

; 4350 : #ifdef AUI_WARNING_FIXES
; 4351 : 	uint uiIndex = uint(eLeagueSpecialSessionNum);
; 4352 : 	CvAssert(uiIndex < GC.getNumLeagueSpecialSessionInfos());
; 4353 : 	if (uiIndex < GC.getNumLeagueSpecialSessionInfos())
; 4354 : 		return m_pLeagueSpecialSessions->GetLeagueSpecialSessionEntries()[uiIndex];
; 4355 : 	else
; 4356 : 		return NULL;
; 4357 : #else
; 4358 : 	CvAssert(eLeagueSpecialSessionNum > -1);
; 4359 : 	CvAssert(eLeagueSpecialSessionNum < GC.getNumLeagueSpecialSessionInfos());
; 4360 : 	return m_pLeagueSpecialSessions->GetLeagueSpecialSessionEntries()[eLeagueSpecialSessionNum];

	mov	ecx, DWORD PTR [ecx+1736]
	call	?GetLeagueSpecialSessionEntries@CvLeagueSpecialSessionXMLEntries@@QAEAAV?$vector@PAVCvLeagueSpecialSessionEntry@@V?$allocator@PAVCvLeagueSpecialSessionEntry@@@std@@@std@@XZ ; CvLeagueSpecialSessionXMLEntries::GetLeagueSpecialSessionEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eLeagueSpecialSessionNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4361 : #endif
; 4362 : }

	ret	4
?getLeagueSpecialSessionInfo@CvGlobals@@QAEPAVCvLeagueSpecialSessionEntry@@W4LeagueSpecialSessionTypes@@@Z ENDP ; CvGlobals::getLeagueSpecialSessionInfo
_TEXT	ENDS
PUBLIC	?getNumLeagueNameInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumLeagueNameInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumLeagueNameInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumLeagueNameInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumLeagueNameInfos, COMDAT
; _this$ = ecx

; 4376 : 	return (int) m_pLeagueNames->GetLeagueNameEntries().size();

	mov	ecx, DWORD PTR [ecx+1740]
	call	?GetLeagueNameEntries@CvLeagueNameXMLEntries@@QAEAAV?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@XZ ; CvLeagueNameXMLEntries::GetLeagueNameEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4377 : #endif
; 4378 : }

	ret	0
?getNumLeagueNameInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumLeagueNameInfos
_TEXT	ENDS
PUBLIC	?getLeagueNameInfo@CvGlobals@@QAEPAVCvLeagueNameEntry@@W4LeagueNameTypes@@@Z ; CvGlobals::getLeagueNameInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getLeagueNameInfo@CvGlobals@@QAEPAVCvLeagueNameEntry@@W4LeagueNameTypes@@@Z
_TEXT	SEGMENT
_eLeagueNameNum$ = 8					; size = 4
?getLeagueNameInfo@CvGlobals@@QAEPAVCvLeagueNameEntry@@W4LeagueNameTypes@@@Z PROC ; CvGlobals::getLeagueNameInfo, COMDAT
; _this$ = ecx

; 4397 : 	CvAssert(eLeagueNameNum > -1);
; 4398 : 	CvAssert(eLeagueNameNum < GC.getNumLeagueNameInfos());
; 4399 : 	return m_pLeagueNames->GetLeagueNameEntries()[eLeagueNameNum];

	mov	ecx, DWORD PTR [ecx+1740]
	call	?GetLeagueNameEntries@CvLeagueNameXMLEntries@@QAEAAV?$vector@PAVCvLeagueNameEntry@@V?$allocator@PAVCvLeagueNameEntry@@@std@@@std@@XZ ; CvLeagueNameXMLEntries::GetLeagueNameEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eLeagueNameNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4400 : #endif
; 4401 : }

	ret	4
?getLeagueNameInfo@CvGlobals@@QAEPAVCvLeagueNameEntry@@W4LeagueNameTypes@@@Z ENDP ; CvGlobals::getLeagueNameInfo
_TEXT	ENDS
PUBLIC	?getNumLeagueProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumLeagueProjectInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumLeagueProjectInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumLeagueProjectInfos@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNumLeagueProjectInfos, COMDAT
; _this$ = ecx

; 4415 : 	return (int) m_pLeagueProjects->GetLeagueProjectEntries().size();

	mov	ecx, DWORD PTR [ecx+1744]
	call	?GetLeagueProjectEntries@CvLeagueProjectXMLEntries@@QAEAAV?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@XZ ; CvLeagueProjectXMLEntries::GetLeagueProjectEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4416 : #endif
; 4417 : }

	ret	0
?getNumLeagueProjectInfos@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNumLeagueProjectInfos
_TEXT	ENDS
PUBLIC	?getLeagueProjectInfo@CvGlobals@@QAEPAVCvLeagueProjectEntry@@W4LeagueProjectTypes@@@Z ; CvGlobals::getLeagueProjectInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getLeagueProjectInfo@CvGlobals@@QAEPAVCvLeagueProjectEntry@@W4LeagueProjectTypes@@@Z
_TEXT	SEGMENT
_eLeagueProjectNum$ = 8					; size = 4
?getLeagueProjectInfo@CvGlobals@@QAEPAVCvLeagueProjectEntry@@W4LeagueProjectTypes@@@Z PROC ; CvGlobals::getLeagueProjectInfo, COMDAT
; _this$ = ecx

; 4436 : 	CvAssert(eLeagueProjectNum > -1);
; 4437 : 	CvAssert(eLeagueProjectNum < GC.getNumLeagueProjectInfos());
; 4438 : 	return m_pLeagueProjects->GetLeagueProjectEntries()[eLeagueProjectNum];

	mov	ecx, DWORD PTR [ecx+1744]
	call	?GetLeagueProjectEntries@CvLeagueProjectXMLEntries@@QAEAAV?$vector@PAVCvLeagueProjectEntry@@V?$allocator@PAVCvLeagueProjectEntry@@@std@@@std@@XZ ; CvLeagueProjectXMLEntries::GetLeagueProjectEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eLeagueProjectNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4439 : #endif
; 4440 : }

	ret	4
?getLeagueProjectInfo@CvGlobals@@QAEPAVCvLeagueProjectEntry@@W4LeagueProjectTypes@@@Z ENDP ; CvGlobals::getLeagueProjectInfo
_TEXT	ENDS
PUBLIC	?getNumLeagueProjectRewardInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumLeagueProjectRewardInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumLeagueProjectRewardInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumLeagueProjectRewardInfos@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNumLeagueProjectRewardInfos, COMDAT
; _this$ = ecx

; 4454 : 	return (int) m_pLeagueProjectRewards->GetLeagueProjectRewardEntries().size();

	mov	ecx, DWORD PTR [ecx+1748]
	call	?GetLeagueProjectRewardEntries@CvLeagueProjectRewardXMLEntries@@QAEAAV?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@XZ ; CvLeagueProjectRewardXMLEntries::GetLeagueProjectRewardEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4455 : #endif
; 4456 : }

	ret	0
?getNumLeagueProjectRewardInfos@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNumLeagueProjectRewardInfos
_TEXT	ENDS
PUBLIC	?getLeagueProjectRewardInfo@CvGlobals@@QAEPAVCvLeagueProjectRewardEntry@@W4LeagueProjectRewardTypes@@@Z ; CvGlobals::getLeagueProjectRewardInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getLeagueProjectRewardInfo@CvGlobals@@QAEPAVCvLeagueProjectRewardEntry@@W4LeagueProjectRewardTypes@@@Z
_TEXT	SEGMENT
_eLeagueProjectRewardNum$ = 8				; size = 4
?getLeagueProjectRewardInfo@CvGlobals@@QAEPAVCvLeagueProjectRewardEntry@@W4LeagueProjectRewardTypes@@@Z PROC ; CvGlobals::getLeagueProjectRewardInfo, COMDAT
; _this$ = ecx

; 4475 : 	CvAssert(eLeagueProjectRewardNum > -1);
; 4476 : 	CvAssert(eLeagueProjectRewardNum < GC.getNumLeagueProjectRewardInfos());
; 4477 : 	return m_pLeagueProjectRewards->GetLeagueProjectRewardEntries()[eLeagueProjectRewardNum];

	mov	ecx, DWORD PTR [ecx+1748]
	call	?GetLeagueProjectRewardEntries@CvLeagueProjectRewardXMLEntries@@QAEAAV?$vector@PAVCvLeagueProjectRewardEntry@@V?$allocator@PAVCvLeagueProjectRewardEntry@@@std@@@std@@XZ ; CvLeagueProjectRewardXMLEntries::GetLeagueProjectRewardEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eLeagueProjectRewardNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4478 : #endif
; 4479 : }

	ret	4
?getLeagueProjectRewardInfo@CvGlobals@@QAEPAVCvLeagueProjectRewardEntry@@W4LeagueProjectRewardTypes@@@Z ENDP ; CvGlobals::getLeagueProjectRewardInfo
_TEXT	ENDS
PUBLIC	?getNumResolutionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResolutionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumResolutionInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumResolutionInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumResolutionInfos, COMDAT
; _this$ = ecx

; 4493 : 	return (int) m_pResolutions->GetResolutionEntries().size();

	mov	ecx, DWORD PTR [ecx+1752]
	call	?GetResolutionEntries@CvResolutionXMLEntries@@QAEAAV?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@XZ ; CvResolutionXMLEntries::GetResolutionEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4494 : #endif
; 4495 : }

	ret	0
?getNumResolutionInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumResolutionInfos
_TEXT	ENDS
PUBLIC	?getResolutionInfo@CvGlobals@@QAEPAVCvResolutionEntry@@W4ResolutionTypes@@@Z ; CvGlobals::getResolutionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getResolutionInfo@CvGlobals@@QAEPAVCvResolutionEntry@@W4ResolutionTypes@@@Z
_TEXT	SEGMENT
_eResolutionNum$ = 8					; size = 4
?getResolutionInfo@CvGlobals@@QAEPAVCvResolutionEntry@@W4ResolutionTypes@@@Z PROC ; CvGlobals::getResolutionInfo, COMDAT
; _this$ = ecx

; 4514 : 	CvAssert(eResolutionNum > -1);
; 4515 : 	CvAssert(eResolutionNum < GC.getNumResolutionInfos());
; 4516 : 	return m_pResolutions->GetResolutionEntries()[eResolutionNum];

	mov	ecx, DWORD PTR [ecx+1752]
	call	?GetResolutionEntries@CvResolutionXMLEntries@@QAEAAV?$vector@PAVCvResolutionEntry@@V?$allocator@PAVCvResolutionEntry@@@std@@@std@@XZ ; CvResolutionXMLEntries::GetResolutionEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eResolutionNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4517 : #endif
; 4518 : }

	ret	4
?getResolutionInfo@CvGlobals@@QAEPAVCvResolutionEntry@@W4ResolutionTypes@@@Z ENDP ; CvGlobals::getResolutionInfo
_TEXT	ENDS
PUBLIC	?getNumTechInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumTechInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumTechInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumTechInfos@CvGlobals@@QAEHXZ PROC			; CvGlobals::getNumTechInfos, COMDAT
; _this$ = ecx

; 4532 : 	return (int)m_pTechs->GetTechEntries().size();

	mov	ecx, DWORD PTR [ecx+1696]
	call	?GetTechEntries@CvTechXMLEntries@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ ; CvTechXMLEntries::GetTechEntries
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 4533 : #endif
; 4534 : }

	ret	0
?getNumTechInfos@CvGlobals@@QAEHXZ ENDP			; CvGlobals::getNumTechInfos
_TEXT	ENDS
PUBLIC	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z
_TEXT	SEGMENT
_eTechNum$ = 8						; size = 4
?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z PROC ; CvGlobals::getTechInfo, COMDAT
; _this$ = ecx

; 4553 : 	CvAssert(eTechNum > -1);
; 4554 : 	CvAssert(eTechNum < GC.getNumTechInfos());
; 4555 : 	return m_pTechs->GetTechEntries()[eTechNum];

	mov	ecx, DWORD PTR [ecx+1696]
	call	?GetTechEntries@CvTechXMLEntries@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ ; CvTechXMLEntries::GetTechEntries
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _eTechNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4556 : #endif
; 4557 : }

	ret	4
?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ENDP ; CvGlobals::getTechInfo
_TEXT	ENDS
PUBLIC	?getNumEraInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumEraInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumEraInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumEraInfos@CvGlobals@@QAEHXZ PROC			; CvGlobals::getNumEraInfos, COMDAT
; _this$ = ecx

; 4571 : 	return (int)m_aEraInfo.size();

	mov	eax, DWORD PTR [ecx+1564]
	sub	eax, DWORD PTR [ecx+1560]
	sar	eax, 2

; 4572 : #endif
; 4573 : }

	ret	0
?getNumEraInfos@CvGlobals@@QAEHXZ ENDP			; CvGlobals::getNumEraInfos
_TEXT	ENDS
PUBLIC	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z
_TEXT	SEGMENT
_eEraNum$ = 8						; size = 4
?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z PROC ; CvGlobals::getEraInfo, COMDAT
; _this$ = ecx

; 4582 : #ifdef AUI_WARNING_FIXES
; 4583 : 	uint uiIndex = uint(eEraNum);
; 4584 : 	CvAssert(uiIndex < GC.getNumEraInfos());
; 4585 : 	if (uiIndex < GC.getNumEraInfos())
; 4586 : 		return m_aEraInfo[uiIndex];
; 4587 : 	else
; 4588 : 		return NULL;
; 4589 : #else
; 4590 : 	CvAssert(eEraNum > -1);
; 4591 : 	CvAssert(eEraNum < GC.getNumEraInfos());
; 4592 : 	return m_aEraInfo[eEraNum];

	mov	eax, DWORD PTR [ecx+1560]
	mov	ecx, DWORD PTR _eEraNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4593 : #endif
; 4594 : }

	ret	4
?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ENDP ; CvGlobals::getEraInfo
_TEXT	ENDS
PUBLIC	?getNumHurryInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumHurryInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumHurryInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumHurryInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumHurryInfos, COMDAT
; _this$ = ecx

; 4603 : 	return (int)m_paHurryInfo.size();

	mov	eax, DWORD PTR [ecx+1580]
	sub	eax, DWORD PTR [ecx+1576]
	sar	eax, 2

; 4604 : #endif
; 4605 : }

	ret	0
?getNumHurryInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumHurryInfos
_TEXT	ENDS
PUBLIC	?getHurryInfo@CvGlobals@@QAEPAVCvHurryInfo@@W4HurryTypes@@@Z ; CvGlobals::getHurryInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getHurryInfo@CvGlobals@@QAEPAVCvHurryInfo@@W4HurryTypes@@@Z
_TEXT	SEGMENT
_eHurryNum$ = 8						; size = 4
?getHurryInfo@CvGlobals@@QAEPAVCvHurryInfo@@W4HurryTypes@@@Z PROC ; CvGlobals::getHurryInfo, COMDAT
; _this$ = ecx

; 4624 : 	CvAssert(eHurryNum > -1);
; 4625 : 	CvAssert(eHurryNum < GC.getNumHurryInfos());
; 4626 : 	return m_paHurryInfo[eHurryNum];

	mov	eax, DWORD PTR [ecx+1576]
	mov	ecx, DWORD PTR _eHurryNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4627 : #endif
; 4628 : }

	ret	4
?getHurryInfo@CvGlobals@@QAEPAVCvHurryInfo@@W4HurryTypes@@@Z ENDP ; CvGlobals::getHurryInfo
_TEXT	ENDS
PUBLIC	?getNumVictoryInfos@CvGlobals@@QAEHXZ		; CvGlobals::getNumVictoryInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumVictoryInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumVictoryInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumVictoryInfos, COMDAT
; _this$ = ecx

; 4637 : 	return (int)m_paVictoryInfo.size();

	mov	eax, DWORD PTR [ecx+1596]
	sub	eax, DWORD PTR [ecx+1592]
	sar	eax, 2

; 4638 : #endif
; 4639 : }

	ret	0
?getNumVictoryInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumVictoryInfos
_TEXT	ENDS
PUBLIC	?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z ; CvGlobals::getVictoryInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z
_TEXT	SEGMENT
_eVictoryNum$ = 8					; size = 4
?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z PROC ; CvGlobals::getVictoryInfo, COMDAT
; _this$ = ecx

; 4658 : 	CvAssert(eVictoryNum > -1);
; 4659 : 	CvAssert(eVictoryNum < GC.getNumVictoryInfos());
; 4660 : 	return m_paVictoryInfo[eVictoryNum];

	mov	eax, DWORD PTR [ecx+1592]
	mov	ecx, DWORD PTR _eVictoryNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4661 : #endif
; 4662 : }

	ret	4
?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z ENDP ; CvGlobals::getVictoryInfo
_TEXT	ENDS
PUBLIC	?getNumSmallAwardInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumSmallAwardInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumSmallAwardInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumSmallAwardInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumSmallAwardInfos, COMDAT
; _this$ = ecx

; 4671 : 	return (int)m_paSmallAwardInfo.size();

	mov	eax, DWORD PTR [ecx+1612]
	sub	eax, DWORD PTR [ecx+1608]
	sar	eax, 2

; 4672 : #endif
; 4673 : }

	ret	0
?getNumSmallAwardInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumSmallAwardInfos
_TEXT	ENDS
PUBLIC	?getSmallAwardInfo@CvGlobals@@QAEPAVCvSmallAwardInfo@@W4SmallAwardTypes@@@Z ; CvGlobals::getSmallAwardInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getSmallAwardInfo@CvGlobals@@QAEPAVCvSmallAwardInfo@@W4SmallAwardTypes@@@Z
_TEXT	SEGMENT
_eSmallAwardNum$ = 8					; size = 4
?getSmallAwardInfo@CvGlobals@@QAEPAVCvSmallAwardInfo@@W4SmallAwardTypes@@@Z PROC ; CvGlobals::getSmallAwardInfo, COMDAT
; _this$ = ecx

; 4692 : 	CvAssert(eSmallAwardNum > -1);
; 4693 : 	CvAssert(eSmallAwardNum < GC.getNumSmallAwardInfos());
; 4694 : 	return m_paSmallAwardInfo[eSmallAwardNum];

	mov	eax, DWORD PTR [ecx+1608]
	mov	ecx, DWORD PTR _eSmallAwardNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4695 : #endif
; 4696 : }

	ret	4
?getSmallAwardInfo@CvGlobals@@QAEPAVCvSmallAwardInfo@@W4SmallAwardTypes@@@Z ENDP ; CvGlobals::getSmallAwardInfo
_TEXT	ENDS
PUBLIC	?getNumUnitDomainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitDomainInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumUnitDomainInfos@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumUnitDomainInfos@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumUnitDomainInfos, COMDAT
; _this$ = ecx

; 4706 : 	return (int)m_paUnitDomainInfo.size();

	mov	eax, DWORD PTR [ecx+1644]
	sub	eax, DWORD PTR [ecx+1640]
	sar	eax, 2

; 4707 : #endif
; 4708 : }

	ret	0
?getNumUnitDomainInfos@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumUnitDomainInfos
_TEXT	ENDS
PUBLIC	?getUnitDomainInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4DomainTypes@@@Z ; CvGlobals::getUnitDomainInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitDomainInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4DomainTypes@@@Z
_TEXT	SEGMENT
_eDomainNum$ = 8					; size = 4
?getUnitDomainInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4DomainTypes@@@Z PROC ; CvGlobals::getUnitDomainInfo, COMDAT
; _this$ = ecx

; 4727 : 	CvAssert(eDomainNum > -1);
; 4728 : 	CvAssert(eDomainNum < GC.getNumUnitDomainInfos());
; 4729 : 	return m_paUnitDomainInfo[eDomainNum];

	mov	eax, DWORD PTR [ecx+1640]
	mov	ecx, DWORD PTR _eDomainNum$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4730 : #endif
; 4731 : }

	ret	4
?getUnitDomainInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4DomainTypes@@@Z ENDP ; CvGlobals::getUnitDomainInfo
_TEXT	ENDS
PUBLIC	?Hash@FStringA@@SAIPBD@Z			; FStringA::Hash
EXTRN	?Calc@FCRC@@QBEKPBXHK@Z:PROC			; FCRC::Calc
EXTRN	?g_CRC32@@3VFCRC@@A:BYTE			; g_CRC32
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ?Hash@FStringA@@SAIPBD@Z
_TEXT	SEGMENT
_pszStr$ = 8						; size = 4
?Hash@FStringA@@SAIPBD@Z PROC				; FStringA::Hash, COMDAT

; 998  : {

	push	esi

; 999  : 	FAssert(pszStr != NULL);
; 1000 : 	return ( g_CRC32.Calc( ( void* )pszStr, SafeStrlen(pszStr) * sizeof ( char ) ) );

	mov	esi, DWORD PTR _pszStr$[esp]
	test	esi, esi
	je	SHORT $LN5@Hash
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL7@Hash:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL7@Hash
	push	-1
	sub	eax, edx
	push	eax
	push	esi
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc
	pop	esi

; 1001 : }

	ret	0

; 999  : 	FAssert(pszStr != NULL);
; 1000 : 	return ( g_CRC32.Calc( ( void* )pszStr, SafeStrlen(pszStr) * sizeof ( char ) ) );

$LN5@Hash:
	push	-1
	xor	eax, eax
	push	eax
	push	esi
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc
	pop	esi

; 1001 : }

	ret	0
?Hash@FStringA@@SAIPBD@Z ENDP				; FStringA::Hash
_TEXT	ENDS
PUBLIC	?getDefineINT@CvGlobals@@IAEHPBD_N@Z		; CvGlobals::getDefineINT
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
;	COMDAT ?getDefineINT@CvGlobals@@IAEHPBD_N@Z
_TEXT	SEGMENT
_szName$ = 8						; size = 4
_bReportErrors$ = 12					; size = 1
?getDefineINT@CvGlobals@@IAEHPBD_N@Z PROC		; CvGlobals::getDefineINT, COMDAT
; _this$ = ecx

; 6750 : 	int iReturn = 0;
; 6751 : 	getDefineValue(szName, iReturn, bReportErrors);

	mov	eax, DWORD PTR _szName$[esp-4]
	push	esi
	push	edi
	push	1
	lea	esi, DWORD PTR [ecx+916]
	push	eax
	push	1
	mov	ecx, esi
	xor	edi, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
	test	al, al
	je	SHORT $LN4@getDefineI
	mov	ecx, esi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN4@getDefineI
	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	edi, eax
$LN4@getDefineI:
	mov	ecx, esi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 6752 : 	return iReturn;

	mov	eax, edi
	pop	edi
	pop	esi

; 6753 : }

	ret	8
?getDefineINT@CvGlobals@@IAEHPBD_N@Z ENDP		; CvGlobals::getDefineINT
_TEXT	ENDS
PUBLIC	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z		; CvGlobals::getDefineFLOAT
; Function compile flags: /Ogtpy
;	COMDAT ?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z
_TEXT	SEGMENT
_fReturn$ = -4						; size = 4
_szName$ = 8						; size = 4
_bReportErrors$ = 12					; size = 1
?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z PROC		; CvGlobals::getDefineFLOAT, COMDAT
; _this$ = ecx

; 6756 : {

	push	ecx

; 6757 : 	float fReturn = 0.0f;
; 6758 : 	getDefineValue(szName, fReturn, bReportErrors);

	mov	eax, DWORD PTR _szName$[esp]
	push	esi
	push	1
	lea	esi, DWORD PTR [ecx+916]
	push	eax
	push	1
	mov	ecx, esi
	mov	DWORD PTR _fReturn$[esp+20], 0
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
	test	al, al
	je	SHORT $LN4@getDefineF
	mov	ecx, esi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN4@getDefineF
	push	0
	mov	ecx, esi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMH@Z
	fstp	DWORD PTR _fReturn$[esp+8]
$LN4@getDefineF:
	mov	ecx, esi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 6759 : 	return fReturn;

	fld	DWORD PTR _fReturn$[esp+8]
	pop	esi

; 6760 : }

	pop	ecx
	ret	8
?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z ENDP		; CvGlobals::getDefineFLOAT
_TEXT	ENDS
PUBLIC	?getDefineSTRING@CvGlobals@@QAE?AVCvString@@PBD_N@Z ; CvGlobals::getDefineSTRING
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?getDefineSTRING@CvGlobals@@QAE?AVCvString@@PBD_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getDefineSTRING@CvGlobals@@QAE?AVCvString@@PBD_N@Z$0
__ehfuncinfo$?getDefineSTRING@CvGlobals@@QAE?AVCvString@@PBD_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getDefineSTRING@CvGlobals@@QAE?AVCvString@@PBD_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ?getDefineSTRING@CvGlobals@@QAE?AVCvString@@PBD_N@Z
_TEXT	SEGMENT
$T258886 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szName$ = 12						; size = 4
_bReportErrors$ = 16					; size = 1
?getDefineSTRING@CvGlobals@@QAE?AVCvString@@PBD_N@Z PROC ; CvGlobals::getDefineSTRING, COMDAT
; _this$ = ecx

; 6763 : {

	push	-1
	push	__ehhandler$?getDefineSTRING@CvGlobals@@QAE?AVCvString@@PBD_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	DWORD PTR $T258886[esp+20], 0

; 6764 : 	CvString strReturn;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+16]
	push	edi
	mov	edi, ecx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6765 : 	getDefineValue(szName, strReturn, bReportErrors);
; 6766 : 	return strReturn;

	mov	eax, DWORD PTR _bReportErrors$[esp+20]
	mov	ecx, DWORD PTR _szName$[esp+20]
	push	eax
	push	esi
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+44], 0
	mov	DWORD PTR $T258886[esp+36], 1
	call	?getDefineValue@CvGlobals@@IAE_NPBDAAVCvString@@_N@Z ; CvGlobals::getDefineValue

; 6767 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getDefineSTRING@CvGlobals@@QAE?AVCvString@@PBD_N@Z$0:
	mov	eax, DWORD PTR $T258886[ebp]
	and	eax, 1
	je	$LN4@getDefineS
	and	DWORD PTR $T258886[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN4@getDefineS:
	ret	0
__ehhandler$?getDefineSTRING@CvGlobals@@QAE?AVCvString@@PBD_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?getDefineSTRING@CvGlobals@@QAE?AVCvString@@PBD_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getDefineSTRING@CvGlobals@@QAE?AVCvString@@PBD_N@Z ENDP ; CvGlobals::getDefineSTRING
PUBLIC	?getNumPlayerOptionInfos@CvGlobals@@QBEHXZ	; CvGlobals::getNumPlayerOptionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?getNumPlayerOptionInfos@CvGlobals@@QBEHXZ
_TEXT	SEGMENT
?getNumPlayerOptionInfos@CvGlobals@@QBEHXZ PROC		; CvGlobals::getNumPlayerOptionInfos, COMDAT
; _this$ = ecx

; 7038 : 	return m_paPlayerOptionInfos.size();

	mov	eax, DWORD PTR [ecx+1452]
	sub	eax, DWORD PTR [ecx+1448]
	sar	eax, 2

; 7039 : }

	ret	0
?getNumPlayerOptionInfos@CvGlobals@@QBEHXZ ENDP		; CvGlobals::getNumPlayerOptionInfos
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 571  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 572  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	??C?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QBEPAVICvDLLDatabaseUtility1@@XZ ; std::auto_ptr<ICvDLLDatabaseUtility1>::operator->
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??C?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QBEPAVICvDLLDatabaseUtility1@@XZ
_TEXT	SEGMENT
??C?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QBEPAVICvDLLDatabaseUtility1@@XZ PROC ; std::auto_ptr<ICvDLLDatabaseUtility1>::operator->, COMDAT
; _this$ = ecx

; 739  : 
; 740  :  #if _HAS_ITERATOR_DEBUGGING
; 741  : 		if (_Myptr == 0)
; 742  : 			_DEBUG_ERROR("auto_ptr not dereferencable");
; 743  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 744  : 
; 745  : 		return (get());

	mov	eax, DWORD PTR [ecx]

; 746  : 		}

	ret	0
??C?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QBEPAVICvDLLDatabaseUtility1@@XZ ENDP ; std::auto_ptr<ICvDLLDatabaseUtility1>::operator->
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEAAPAVCvCivilizationInfo@@XZ ; std::_Vector_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEAAPAVCvCivilizationInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEAAPAVCvCivilizationInfo@@XZ PROC ; std::_Vector_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEAAPAVCvCivilizationInfo@@XZ ENDP ; std::_Vector_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??9?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??9?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator!=, COMDAT
; _this$ = ecx

; 303  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 304  : 			}

	ret	4
??9?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator!=
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::~_Vector_val<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::~_Vector_val<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::~_Vector_val<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvColorInfo *,std::allocator<CvColorInfo *> >::~_Vector_val<CvColorInfo *,std::allocator<CvColorInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvColorInfo *,std::allocator<CvColorInfo *> >::~_Vector_val<CvColorInfo *,std::allocator<CvColorInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvColorInfo *,std::allocator<CvColorInfo *> >::~_Vector_val<CvColorInfo *,std::allocator<CvColorInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::~_Vector_val<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::~_Vector_val<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::~_Vector_val<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::~_Vector_val<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::~_Vector_val<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::~_Vector_val<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvYieldInfo *,std::allocator<CvYieldInfo *> >::~_Vector_val<CvYieldInfo *,std::allocator<CvYieldInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvYieldInfo *,std::allocator<CvYieldInfo *> >::~_Vector_val<CvYieldInfo *,std::allocator<CvYieldInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvYieldInfo *,std::allocator<CvYieldInfo *> >::~_Vector_val<CvYieldInfo *,std::allocator<CvYieldInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvRouteInfo *,std::allocator<CvRouteInfo *> >::~_Vector_val<CvRouteInfo *,std::allocator<CvRouteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvRouteInfo *,std::allocator<CvRouteInfo *> >::~_Vector_val<CvRouteInfo *,std::allocator<CvRouteInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvRouteInfo *,std::allocator<CvRouteInfo *> >::~_Vector_val<CvRouteInfo *,std::allocator<CvRouteInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::~_Vector_val<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::~_Vector_val<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::~_Vector_val<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::~_Vector_val<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::~_Vector_val<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::~_Vector_val<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvResourceInfo *,std::allocator<CvResourceInfo *> >::~_Vector_val<CvResourceInfo *,std::allocator<CvResourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvResourceInfo *,std::allocator<CvResourceInfo *> >::~_Vector_val<CvResourceInfo *,std::allocator<CvResourceInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvResourceInfo *,std::allocator<CvResourceInfo *> >::~_Vector_val<CvResourceInfo *,std::allocator<CvResourceInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvBuildInfo *,std::allocator<CvBuildInfo *> >::~_Vector_val<CvBuildInfo *,std::allocator<CvBuildInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvBuildInfo *,std::allocator<CvBuildInfo *> >::~_Vector_val<CvBuildInfo *,std::allocator<CvBuildInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvBuildInfo *,std::allocator<CvBuildInfo *> >::~_Vector_val<CvBuildInfo *,std::allocator<CvBuildInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::~_Vector_val<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::~_Vector_val<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::~_Vector_val<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::~_Vector_val<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::~_Vector_val<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::~_Vector_val<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::~_Vector_val<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::~_Vector_val<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::~_Vector_val<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::~_Vector_val<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::~_Vector_val<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::~_Vector_val<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::~_Vector_val<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::~_Vector_val<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::~_Vector_val<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::~_Vector_val<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::~_Vector_val<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::~_Vector_val<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvProcessInfo *,std::allocator<CvProcessInfo *> >::~_Vector_val<CvProcessInfo *,std::allocator<CvProcessInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvProcessInfo *,std::allocator<CvProcessInfo *> >::~_Vector_val<CvProcessInfo *,std::allocator<CvProcessInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvProcessInfo *,std::allocator<CvProcessInfo *> >::~_Vector_val<CvProcessInfo *,std::allocator<CvProcessInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvVoteInfo *,std::allocator<CvVoteInfo *> >::~_Vector_val<CvVoteInfo *,std::allocator<CvVoteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvVoteInfo *,std::allocator<CvVoteInfo *> >::~_Vector_val<CvVoteInfo *,std::allocator<CvVoteInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvVoteInfo *,std::allocator<CvVoteInfo *> >::~_Vector_val<CvVoteInfo *,std::allocator<CvVoteInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::~_Vector_val<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::~_Vector_val<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::~_Vector_val<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::~_Vector_val<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::~_Vector_val<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::~_Vector_val<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::~_Vector_val<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::~_Vector_val<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::~_Vector_val<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::~_Vector_val<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::~_Vector_val<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::~_Vector_val<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvBaseInfo *,std::allocator<CvBaseInfo *> >::~_Vector_val<CvBaseInfo *,std::allocator<CvBaseInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvBaseInfo *,std::allocator<CvBaseInfo *> >::~_Vector_val<CvBaseInfo *,std::allocator<CvBaseInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvBaseInfo *,std::allocator<CvBaseInfo *> >::~_Vector_val<CvBaseInfo *,std::allocator<CvBaseInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::~_Vector_val<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::~_Vector_val<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::~_Vector_val<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::~_Vector_val<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::~_Vector_val<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::~_Vector_val<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::~_Vector_val<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::~_Vector_val<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::~_Vector_val<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::~_Vector_val<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::~_Vector_val<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::~_Vector_val<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvActionInfo *,std::allocator<CvActionInfo *> >::~_Vector_val<CvActionInfo *,std::allocator<CvActionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvActionInfo *,std::allocator<CvActionInfo *> >::~_Vector_val<CvActionInfo *,std::allocator<CvActionInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvActionInfo *,std::allocator<CvActionInfo *> >::~_Vector_val<CvActionInfo *,std::allocator<CvActionInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvMissionInfo *,std::allocator<CvMissionInfo *> >::~_Vector_val<CvMissionInfo *,std::allocator<CvMissionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvMissionInfo *,std::allocator<CvMissionInfo *> >::~_Vector_val<CvMissionInfo *,std::allocator<CvMissionInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvMissionInfo *,std::allocator<CvMissionInfo *> >::~_Vector_val<CvMissionInfo *,std::allocator<CvMissionInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvControlInfo *,std::allocator<CvControlInfo *> >::~_Vector_val<CvControlInfo *,std::allocator<CvControlInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvControlInfo *,std::allocator<CvControlInfo *> >::~_Vector_val<CvControlInfo *,std::allocator<CvControlInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvControlInfo *,std::allocator<CvControlInfo *> >::~_Vector_val<CvControlInfo *,std::allocator<CvControlInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvCommandInfo *,std::allocator<CvCommandInfo *> >::~_Vector_val<CvCommandInfo *,std::allocator<CvCommandInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvCommandInfo *,std::allocator<CvCommandInfo *> >::~_Vector_val<CvCommandInfo *,std::allocator<CvCommandInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvCommandInfo *,std::allocator<CvCommandInfo *> >::~_Vector_val<CvCommandInfo *,std::allocator<CvCommandInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::~_Vector_val<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::~_Vector_val<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::~_Vector_val<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvEraInfo *,std::allocator<CvEraInfo *> >::~_Vector_val<CvEraInfo *,std::allocator<CvEraInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvEraInfo *,std::allocator<CvEraInfo *> >::~_Vector_val<CvEraInfo *,std::allocator<CvEraInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvEraInfo *,std::allocator<CvEraInfo *> >::~_Vector_val<CvEraInfo *,std::allocator<CvEraInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvHurryInfo *,std::allocator<CvHurryInfo *> >::~_Vector_val<CvHurryInfo *,std::allocator<CvHurryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvHurryInfo *,std::allocator<CvHurryInfo *> >::~_Vector_val<CvHurryInfo *,std::allocator<CvHurryInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvHurryInfo *,std::allocator<CvHurryInfo *> >::~_Vector_val<CvHurryInfo *,std::allocator<CvHurryInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::~_Vector_val<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::~_Vector_val<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::~_Vector_val<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::~_Vector_val<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::~_Vector_val<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::~_Vector_val<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::~_Vector_val<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::~_Vector_val<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::~_Vector_val<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::~_Vector_val<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::~_Vector_val<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::~_Vector_val<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::~_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::~_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::~_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
_TEXT	ENDS
PUBLIC	?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::end, COMDAT
; _this$ = ecx

; 575  : 		return (const_iterator(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 576  : 		}

	ret	4
?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE@V?$allocator@PAVCvInterfaceModeInfo@@@1@@Z ; std::_Vector_val<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Vector_val<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE@V?$allocator@PAVCvInterfaceModeInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE@V?$allocator@PAVCvInterfaceModeInfo@@@1@@Z PROC ; std::_Vector_val<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Vector_val<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE@V?$allocator@PAVCvInterfaceModeInfo@@@1@@Z ENDP ; std::_Vector_val<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Vector_val<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Key
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvColorInfo@@@1@@Z ; std::_Vector_val<CvColorInfo *,std::allocator<CvColorInfo *> >::_Vector_val<CvColorInfo *,std::allocator<CvColorInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvColorInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvColorInfo@@@1@@Z PROC ; std::_Vector_val<CvColorInfo *,std::allocator<CvColorInfo *> >::_Vector_val<CvColorInfo *,std::allocator<CvColorInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvColorInfo@@@1@@Z ENDP ; std::_Vector_val<CvColorInfo *,std::allocator<CvColorInfo *> >::_Vector_val<CvColorInfo *,std::allocator<CvColorInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerColorInfo@@@1@@Z ; std::_Vector_val<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Vector_val<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerColorInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerColorInfo@@@1@@Z PROC ; std::_Vector_val<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Vector_val<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerColorInfo@@@1@@Z ENDP ; std::_Vector_val<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Vector_val<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTerrainInfo@@@1@@Z ; std::_Vector_val<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Vector_val<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTerrainInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTerrainInfo@@@1@@Z PROC ; std::_Vector_val<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Vector_val<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTerrainInfo@@@1@@Z ENDP ; std::_Vector_val<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Vector_val<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE@V?$allocator@PAVCvYieldInfo@@@1@@Z ; std::_Vector_val<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Vector_val<CvYieldInfo *,std::allocator<CvYieldInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE@V?$allocator@PAVCvYieldInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE@V?$allocator@PAVCvYieldInfo@@@1@@Z PROC ; std::_Vector_val<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Vector_val<CvYieldInfo *,std::allocator<CvYieldInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE@V?$allocator@PAVCvYieldInfo@@@1@@Z ENDP ; std::_Vector_val<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Vector_val<CvYieldInfo *,std::allocator<CvYieldInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvRouteInfo@@@1@@Z ; std::_Vector_val<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Vector_val<CvRouteInfo *,std::allocator<CvRouteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvRouteInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvRouteInfo@@@1@@Z PROC ; std::_Vector_val<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Vector_val<CvRouteInfo *,std::allocator<CvRouteInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvRouteInfo@@@1@@Z ENDP ; std::_Vector_val<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Vector_val<CvRouteInfo *,std::allocator<CvRouteInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE@V?$allocator@PAVCvFeatureInfo@@@1@@Z ; std::_Vector_val<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Vector_val<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE@V?$allocator@PAVCvFeatureInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE@V?$allocator@PAVCvFeatureInfo@@@1@@Z PROC ; std::_Vector_val<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Vector_val<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE@V?$allocator@PAVCvFeatureInfo@@@1@@Z ENDP ; std::_Vector_val<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Vector_val<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceClassInfo@@@1@@Z ; std::_Vector_val<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Vector_val<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceClassInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceClassInfo@@@1@@Z PROC ; std::_Vector_val<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Vector_val<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceClassInfo@@@1@@Z ENDP ; std::_Vector_val<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Vector_val<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceInfo@@@1@@Z ; std::_Vector_val<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Vector_val<CvResourceInfo *,std::allocator<CvResourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceInfo@@@1@@Z PROC ; std::_Vector_val<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Vector_val<CvResourceInfo *,std::allocator<CvResourceInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvResourceInfo@@@1@@Z ENDP ; std::_Vector_val<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Vector_val<CvResourceInfo *,std::allocator<CvResourceInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildInfo@@@1@@Z ; std::_Vector_val<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Vector_val<CvBuildInfo *,std::allocator<CvBuildInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildInfo@@@1@@Z PROC ; std::_Vector_val<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Vector_val<CvBuildInfo *,std::allocator<CvBuildInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildInfo@@@1@@Z ENDP ; std::_Vector_val<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Vector_val<CvBuildInfo *,std::allocator<CvBuildInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHandicapInfo@@@1@@Z ; std::_Vector_val<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Vector_val<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHandicapInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHandicapInfo@@@1@@Z PROC ; std::_Vector_val<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Vector_val<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHandicapInfo@@@1@@Z ENDP ; std::_Vector_val<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Vector_val<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameSpeedInfo@@@1@@Z ; std::_Vector_val<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Vector_val<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameSpeedInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameSpeedInfo@@@1@@Z PROC ; std::_Vector_val<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Vector_val<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameSpeedInfo@@@1@@Z ENDP ; std::_Vector_val<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Vector_val<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTurnTimerInfo@@@1@@Z ; std::_Vector_val<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Vector_val<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTurnTimerInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTurnTimerInfo@@@1@@Z PROC ; std::_Vector_val<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Vector_val<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE@V?$allocator@PAVCvTurnTimerInfo@@@1@@Z ENDP ; std::_Vector_val<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Vector_val<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCivilizationInfo@@@1@@Z ; std::_Vector_val<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Vector_val<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCivilizationInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCivilizationInfo@@@1@@Z PROC ; std::_Vector_val<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Vector_val<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCivilizationInfo@@@1@@Z ENDP ; std::_Vector_val<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Vector_val<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMinorCivInfo@@@1@@Z ; std::_Vector_val<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Vector_val<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMinorCivInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMinorCivInfo@@@1@@Z PROC ; std::_Vector_val<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Vector_val<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMinorCivInfo@@@1@@Z ENDP ; std::_Vector_val<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Vector_val<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE@V?$allocator@PAVCvLeaderHeadInfo@@@1@@Z ; std::_Vector_val<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Vector_val<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE@V?$allocator@PAVCvLeaderHeadInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE@V?$allocator@PAVCvLeaderHeadInfo@@@1@@Z PROC ; std::_Vector_val<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Vector_val<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE@V?$allocator@PAVCvLeaderHeadInfo@@@1@@Z ENDP ; std::_Vector_val<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Vector_val<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE@V?$allocator@PAVCvProcessInfo@@@1@@Z ; std::_Vector_val<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Vector_val<CvProcessInfo *,std::allocator<CvProcessInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE@V?$allocator@PAVCvProcessInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE@V?$allocator@PAVCvProcessInfo@@@1@@Z PROC ; std::_Vector_val<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Vector_val<CvProcessInfo *,std::allocator<CvProcessInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE@V?$allocator@PAVCvProcessInfo@@@1@@Z ENDP ; std::_Vector_val<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Vector_val<CvProcessInfo *,std::allocator<CvProcessInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteInfo@@@1@@Z ; std::_Vector_val<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Vector_val<CvVoteInfo *,std::allocator<CvVoteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteInfo@@@1@@Z PROC ; std::_Vector_val<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Vector_val<CvVoteInfo *,std::allocator<CvVoteInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteInfo@@@1@@Z ENDP ; std::_Vector_val<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Vector_val<CvVoteInfo *,std::allocator<CvVoteInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingClassInfo@@@1@@Z ; std::_Vector_val<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Vector_val<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingClassInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingClassInfo@@@1@@Z PROC ; std::_Vector_val<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Vector_val<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBuildingClassInfo@@@1@@Z ENDP ; std::_Vector_val<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Vector_val<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvUnitClassInfo@@@1@@Z ; std::_Vector_val<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Vector_val<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvUnitClassInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvUnitClassInfo@@@1@@Z PROC ; std::_Vector_val<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Vector_val<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE@V?$allocator@PAVCvUnitClassInfo@@@1@@Z ENDP ; std::_Vector_val<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Vector_val<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialUnitInfo@@@1@@Z ; std::_Vector_val<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Vector_val<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialUnitInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialUnitInfo@@@1@@Z PROC ; std::_Vector_val<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Vector_val<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialUnitInfo@@@1@@Z ENDP ; std::_Vector_val<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Vector_val<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteSourceInfo@@@1@@Z ; std::_Vector_val<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Vector_val<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteSourceInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteSourceInfo@@@1@@Z PROC ; std::_Vector_val<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Vector_val<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVoteSourceInfo@@@1@@Z ENDP ; std::_Vector_val<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Vector_val<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBaseInfo@@@1@@Z ; std::_Vector_val<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Vector_val<CvBaseInfo *,std::allocator<CvBaseInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBaseInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBaseInfo@@@1@@Z PROC ; std::_Vector_val<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Vector_val<CvBaseInfo *,std::allocator<CvBaseInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE@V?$allocator@PAVCvBaseInfo@@@1@@Z ENDP ; std::_Vector_val<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Vector_val<CvBaseInfo *,std::allocator<CvBaseInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameOptionInfo@@@1@@Z ; std::_Vector_val<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Vector_val<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameOptionInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameOptionInfo@@@1@@Z PROC ; std::_Vector_val<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Vector_val<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvGameOptionInfo@@@1@@Z ENDP ; std::_Vector_val<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Vector_val<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMPOptionInfo@@@1@@Z ; std::_Vector_val<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Vector_val<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMPOptionInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMPOptionInfo@@@1@@Z PROC ; std::_Vector_val<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Vector_val<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMPOptionInfo@@@1@@Z ENDP ; std::_Vector_val<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Vector_val<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerOptionInfo@@@1@@Z ; std::_Vector_val<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Vector_val<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerOptionInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerOptionInfo@@@1@@Z PROC ; std::_Vector_val<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Vector_val<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvPlayerOptionInfo@@@1@@Z ENDP ; std::_Vector_val<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Vector_val<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialistInfo@@@1@@Z ; std::_Vector_val<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Vector_val<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialistInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialistInfo@@@1@@Z PROC ; std::_Vector_val<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Vector_val<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSpecialistInfo@@@1@@Z ENDP ; std::_Vector_val<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Vector_val<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvActionInfo@@@1@@Z ; std::_Vector_val<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_val<CvActionInfo *,std::allocator<CvActionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvActionInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvActionInfo@@@1@@Z PROC ; std::_Vector_val<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_val<CvActionInfo *,std::allocator<CvActionInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvActionInfo@@@1@@Z ENDP ; std::_Vector_val<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_val<CvActionInfo *,std::allocator<CvActionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMissionInfo@@@1@@Z ; std::_Vector_val<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Vector_val<CvMissionInfo *,std::allocator<CvMissionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMissionInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMissionInfo@@@1@@Z PROC ; std::_Vector_val<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Vector_val<CvMissionInfo *,std::allocator<CvMissionInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMissionInfo@@@1@@Z ENDP ; std::_Vector_val<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Vector_val<CvMissionInfo *,std::allocator<CvMissionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE@V?$allocator@PAVCvControlInfo@@@1@@Z ; std::_Vector_val<CvControlInfo *,std::allocator<CvControlInfo *> >::_Vector_val<CvControlInfo *,std::allocator<CvControlInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE@V?$allocator@PAVCvControlInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE@V?$allocator@PAVCvControlInfo@@@1@@Z PROC ; std::_Vector_val<CvControlInfo *,std::allocator<CvControlInfo *> >::_Vector_val<CvControlInfo *,std::allocator<CvControlInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE@V?$allocator@PAVCvControlInfo@@@1@@Z ENDP ; std::_Vector_val<CvControlInfo *,std::allocator<CvControlInfo *> >::_Vector_val<CvControlInfo *,std::allocator<CvControlInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCommandInfo@@@1@@Z ; std::_Vector_val<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Vector_val<CvCommandInfo *,std::allocator<CvCommandInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCommandInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCommandInfo@@@1@@Z PROC ; std::_Vector_val<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Vector_val<CvCommandInfo *,std::allocator<CvCommandInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE@V?$allocator@PAVCvCommandInfo@@@1@@Z ENDP ; std::_Vector_val<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Vector_val<CvCommandInfo *,std::allocator<CvCommandInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE@V?$allocator@PAVCvAutomateInfo@@@1@@Z ; std::_Vector_val<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Vector_val<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE@V?$allocator@PAVCvAutomateInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE@V?$allocator@PAVCvAutomateInfo@@@1@@Z PROC ; std::_Vector_val<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Vector_val<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE@V?$allocator@PAVCvAutomateInfo@@@1@@Z ENDP ; std::_Vector_val<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Vector_val<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEraInfo@@@1@@Z ; std::_Vector_val<CvEraInfo *,std::allocator<CvEraInfo *> >::_Vector_val<CvEraInfo *,std::allocator<CvEraInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEraInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEraInfo@@@1@@Z PROC ; std::_Vector_val<CvEraInfo *,std::allocator<CvEraInfo *> >::_Vector_val<CvEraInfo *,std::allocator<CvEraInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEraInfo@@@1@@Z ENDP ; std::_Vector_val<CvEraInfo *,std::allocator<CvEraInfo *> >::_Vector_val<CvEraInfo *,std::allocator<CvEraInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHurryInfo@@@1@@Z ; std::_Vector_val<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Vector_val<CvHurryInfo *,std::allocator<CvHurryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHurryInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHurryInfo@@@1@@Z PROC ; std::_Vector_val<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Vector_val<CvHurryInfo *,std::allocator<CvHurryInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvHurryInfo@@@1@@Z ENDP ; std::_Vector_val<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Vector_val<CvHurryInfo *,std::allocator<CvHurryInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVictoryInfo@@@1@@Z ; std::_Vector_val<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Vector_val<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVictoryInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVictoryInfo@@@1@@Z PROC ; std::_Vector_val<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Vector_val<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE@V?$allocator@PAVCvVictoryInfo@@@1@@Z ENDP ; std::_Vector_val<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Vector_val<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSmallAwardInfo@@@1@@Z ; std::_Vector_val<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Vector_val<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSmallAwardInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSmallAwardInfo@@@1@@Z PROC ; std::_Vector_val<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Vector_val<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE@V?$allocator@PAVCvSmallAwardInfo@@@1@@Z ENDP ; std::_Vector_val<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Vector_val<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEntityEventInfo@@@1@@Z ; std::_Vector_val<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Vector_val<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEntityEventInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEntityEventInfo@@@1@@Z PROC ; std::_Vector_val<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Vector_val<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE@V?$allocator@PAVCvEntityEventInfo@@@1@@Z ENDP ; std::_Vector_val<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Vector_val<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMultiUnitFormationInfo@@@1@@Z ; std::_Vector_val<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Vector_val<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMultiUnitFormationInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMultiUnitFormationInfo@@@1@@Z PROC ; std::_Vector_val<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Vector_val<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE@V?$allocator@PAVCvMultiUnitFormationInfo@@@1@@Z ENDP ; std::_Vector_val<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Vector_val<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@PAPAVCvCivilizationInfo@@@Z ; std::_Vector_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Vector_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@PAPAVCvCivilizationInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@PAPAVCvCivilizationInfo@@@Z PROC ; std::_Vector_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Vector_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@PAPAVCvCivilizationInfo@@@Z ENDP ; std::_Vector_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Vector_iterator<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
_TEXT	ENDS
PUBLIC	??D?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??D?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ
_TEXT	SEGMENT
??D?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator*, COMDAT
; _this$ = ecx

; 212  : 
; 213  :  #if _HAS_ITERATOR_DEBUGGING
; 214  : 			if (this->_Mycont == 0
; 215  : 				|| _Ptr == 0
; 216  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 217  : 				{
; 218  : 				_DEBUG_ERROR("list iterator not dereferencable");
; 219  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 220  : 				}
; 221  :  #else
; 222  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 223  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 224  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 225  : 
; 226  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 227  : 			}

	ret	0
??D?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator*
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBIH@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBIH@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBIH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBIH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??D?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??D?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ
_TEXT	SEGMENT
??D?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::operator*, COMDAT
; _this$ = ecx

; 394  : 			return ((reference)**(_Mybase_iter *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 395  : 			}

	ret	0
??D?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::operator*
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBIH@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBIH@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBIH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBIH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@XZ ; std::_Vector_val<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::~_Vector_val<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@XZ PROC ; std::_Vector_val<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::~_Vector_val<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@XZ ENDP ; std::_Vector_val<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::~_Vector_val<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	??1?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ PROC ; std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ENDP ; std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
PUBLIC	?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::end, COMDAT
; _this$ = ecx

; 570  : 		return (iterator(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 571  : 		}

	ret	4
?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::end
_TEXT	ENDS
PUBLIC	??R?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ??R?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
_TEXT	SEGMENT
__Keyval1$ = 8						; size = 4
__Keyval2$ = 12						; size = 4
??R?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC ; stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator(), COMDAT
; _this$ = ecx

; 139  : 		return (comp(_Keyval1, _Keyval2));

	mov	eax, DWORD PTR __Keyval2$[esp-4]
	mov	ecx, DWORD PTR __Keyval1$[esp-4]
	push	eax
	push	ecx
	call	DWORD PTR __imp_??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
	add	esp, 8

; 140  : 		}

	ret	8
??R?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEIXZ ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvInterfaceModeInfo@@@std@@QAEPAPAVCvInterfaceModeInfo@@I@Z ; std::allocator<CvInterfaceModeInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvInterfaceModeInfo@@@std@@QAEPAPAVCvInterfaceModeInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvInterfaceModeInfo@@@std@@QAEPAPAVCvInterfaceModeInfo@@I@Z PROC ; std::allocator<CvInterfaceModeInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvInterfaceModeInfo@@@std@@YAPAPAVCvInterfaceModeInfo@@IPAPAV1@@Z ; std::_Allocate<CvInterfaceModeInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvInterfaceModeInfo@@@std@@QAEPAPAVCvInterfaceModeInfo@@I@Z ENDP ; std::allocator<CvInterfaceModeInfo *>::allocate
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lbound
; Function compile flags: /Ogtpy
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN3@Lbound
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Lbound:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jae	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL4@Lbound
$LN3@Lbound:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEIXZ ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvColorInfo@@@std@@QAEPAPAVCvColorInfo@@I@Z ; std::allocator<CvColorInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvColorInfo@@@std@@QAEPAPAVCvColorInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvColorInfo@@@std@@QAEPAPAVCvColorInfo@@I@Z PROC ; std::allocator<CvColorInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvColorInfo@@@std@@YAPAPAVCvColorInfo@@IPAPAV1@@Z ; std::_Allocate<CvColorInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvColorInfo@@@std@@QAEPAPAVCvColorInfo@@I@Z ENDP ; std::allocator<CvColorInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEIXZ ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvPlayerColorInfo@@@std@@QAEPAPAVCvPlayerColorInfo@@I@Z ; std::allocator<CvPlayerColorInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvPlayerColorInfo@@@std@@QAEPAPAVCvPlayerColorInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvPlayerColorInfo@@@std@@QAEPAPAVCvPlayerColorInfo@@I@Z PROC ; std::allocator<CvPlayerColorInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvPlayerColorInfo@@@std@@YAPAPAVCvPlayerColorInfo@@IPAPAV1@@Z ; std::_Allocate<CvPlayerColorInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvPlayerColorInfo@@@std@@QAEPAPAVCvPlayerColorInfo@@I@Z ENDP ; std::allocator<CvPlayerColorInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEIXZ ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvTerrainInfo@@@std@@QAEPAPAVCvTerrainInfo@@I@Z ; std::allocator<CvTerrainInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvTerrainInfo@@@std@@QAEPAPAVCvTerrainInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvTerrainInfo@@@std@@QAEPAPAVCvTerrainInfo@@I@Z PROC ; std::allocator<CvTerrainInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvTerrainInfo@@@std@@YAPAPAVCvTerrainInfo@@IPAPAV1@@Z ; std::_Allocate<CvTerrainInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvTerrainInfo@@@std@@QAEPAPAVCvTerrainInfo@@I@Z ENDP ; std::allocator<CvTerrainInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEIXZ ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvYieldInfo@@@std@@QAEPAPAVCvYieldInfo@@I@Z ; std::allocator<CvYieldInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvYieldInfo@@@std@@QAEPAPAVCvYieldInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvYieldInfo@@@std@@QAEPAPAVCvYieldInfo@@I@Z PROC ; std::allocator<CvYieldInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvYieldInfo@@@std@@YAPAPAVCvYieldInfo@@IPAPAV1@@Z ; std::_Allocate<CvYieldInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvYieldInfo@@@std@@QAEPAPAVCvYieldInfo@@I@Z ENDP ; std::allocator<CvYieldInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEIXZ ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvRouteInfo@@@std@@QAEPAPAVCvRouteInfo@@I@Z ; std::allocator<CvRouteInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvRouteInfo@@@std@@QAEPAPAVCvRouteInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvRouteInfo@@@std@@QAEPAPAVCvRouteInfo@@I@Z PROC ; std::allocator<CvRouteInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvRouteInfo@@@std@@YAPAPAVCvRouteInfo@@IPAPAV1@@Z ; std::_Allocate<CvRouteInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvRouteInfo@@@std@@QAEPAPAVCvRouteInfo@@I@Z ENDP ; std::allocator<CvRouteInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEIXZ ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvFeatureInfo@@@std@@QAEPAPAVCvFeatureInfo@@I@Z ; std::allocator<CvFeatureInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvFeatureInfo@@@std@@QAEPAPAVCvFeatureInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvFeatureInfo@@@std@@QAEPAPAVCvFeatureInfo@@I@Z PROC ; std::allocator<CvFeatureInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvFeatureInfo@@@std@@YAPAPAVCvFeatureInfo@@IPAPAV1@@Z ; std::_Allocate<CvFeatureInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvFeatureInfo@@@std@@QAEPAPAVCvFeatureInfo@@I@Z ENDP ; std::allocator<CvFeatureInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEIXZ ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvResourceClassInfo@@@std@@QAEPAPAVCvResourceClassInfo@@I@Z ; std::allocator<CvResourceClassInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvResourceClassInfo@@@std@@QAEPAPAVCvResourceClassInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvResourceClassInfo@@@std@@QAEPAPAVCvResourceClassInfo@@I@Z PROC ; std::allocator<CvResourceClassInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvResourceClassInfo@@@std@@YAPAPAVCvResourceClassInfo@@IPAPAV1@@Z ; std::_Allocate<CvResourceClassInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvResourceClassInfo@@@std@@QAEPAPAVCvResourceClassInfo@@I@Z ENDP ; std::allocator<CvResourceClassInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEIXZ ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvResourceInfo@@@std@@QAEPAPAVCvResourceInfo@@I@Z ; std::allocator<CvResourceInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvResourceInfo@@@std@@QAEPAPAVCvResourceInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvResourceInfo@@@std@@QAEPAPAVCvResourceInfo@@I@Z PROC ; std::allocator<CvResourceInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvResourceInfo@@@std@@YAPAPAVCvResourceInfo@@IPAPAV1@@Z ; std::_Allocate<CvResourceInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvResourceInfo@@@std@@QAEPAPAVCvResourceInfo@@I@Z ENDP ; std::allocator<CvResourceInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEIXZ ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvBuildInfo@@@std@@QAEPAPAVCvBuildInfo@@I@Z ; std::allocator<CvBuildInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvBuildInfo@@@std@@QAEPAPAVCvBuildInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvBuildInfo@@@std@@QAEPAPAVCvBuildInfo@@I@Z PROC ; std::allocator<CvBuildInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvBuildInfo@@@std@@YAPAPAVCvBuildInfo@@IPAPAV1@@Z ; std::_Allocate<CvBuildInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvBuildInfo@@@std@@QAEPAPAVCvBuildInfo@@I@Z ENDP ; std::allocator<CvBuildInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEIXZ ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvHandicapInfo@@@std@@QAEPAPAVCvHandicapInfo@@I@Z ; std::allocator<CvHandicapInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvHandicapInfo@@@std@@QAEPAPAVCvHandicapInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvHandicapInfo@@@std@@QAEPAPAVCvHandicapInfo@@I@Z PROC ; std::allocator<CvHandicapInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvHandicapInfo@@@std@@YAPAPAVCvHandicapInfo@@IPAPAV1@@Z ; std::_Allocate<CvHandicapInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvHandicapInfo@@@std@@QAEPAPAVCvHandicapInfo@@I@Z ENDP ; std::allocator<CvHandicapInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEIXZ ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvGameSpeedInfo@@@std@@QAEPAPAVCvGameSpeedInfo@@I@Z ; std::allocator<CvGameSpeedInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvGameSpeedInfo@@@std@@QAEPAPAVCvGameSpeedInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvGameSpeedInfo@@@std@@QAEPAPAVCvGameSpeedInfo@@I@Z PROC ; std::allocator<CvGameSpeedInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvGameSpeedInfo@@@std@@YAPAPAVCvGameSpeedInfo@@IPAPAV1@@Z ; std::_Allocate<CvGameSpeedInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvGameSpeedInfo@@@std@@QAEPAPAVCvGameSpeedInfo@@I@Z ENDP ; std::allocator<CvGameSpeedInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBEIXZ ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvTurnTimerInfo@@@std@@QAEPAPAVCvTurnTimerInfo@@I@Z ; std::allocator<CvTurnTimerInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvTurnTimerInfo@@@std@@QAEPAPAVCvTurnTimerInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvTurnTimerInfo@@@std@@QAEPAPAVCvTurnTimerInfo@@I@Z PROC ; std::allocator<CvTurnTimerInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvTurnTimerInfo@@@std@@YAPAPAVCvTurnTimerInfo@@IPAPAV1@@Z ; std::_Allocate<CvTurnTimerInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvTurnTimerInfo@@@std@@QAEPAPAVCvTurnTimerInfo@@I@Z ENDP ; std::allocator<CvTurnTimerInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEIXZ ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvCivilizationInfo@@@std@@QAEPAPAVCvCivilizationInfo@@I@Z ; std::allocator<CvCivilizationInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvCivilizationInfo@@@std@@QAEPAPAVCvCivilizationInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvCivilizationInfo@@@std@@QAEPAPAVCvCivilizationInfo@@I@Z PROC ; std::allocator<CvCivilizationInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvCivilizationInfo@@@std@@YAPAPAVCvCivilizationInfo@@IPAPAV1@@Z ; std::_Allocate<CvCivilizationInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvCivilizationInfo@@@std@@QAEPAPAVCvCivilizationInfo@@I@Z ENDP ; std::allocator<CvCivilizationInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEIXZ ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvMinorCivInfo@@@std@@QAEPAPAVCvMinorCivInfo@@I@Z ; std::allocator<CvMinorCivInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvMinorCivInfo@@@std@@QAEPAPAVCvMinorCivInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvMinorCivInfo@@@std@@QAEPAPAVCvMinorCivInfo@@I@Z PROC ; std::allocator<CvMinorCivInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvMinorCivInfo@@@std@@YAPAPAVCvMinorCivInfo@@IPAPAV1@@Z ; std::_Allocate<CvMinorCivInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvMinorCivInfo@@@std@@QAEPAPAVCvMinorCivInfo@@I@Z ENDP ; std::allocator<CvMinorCivInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEIXZ ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvLeaderHeadInfo@@@std@@QAEPAPAVCvLeaderHeadInfo@@I@Z ; std::allocator<CvLeaderHeadInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvLeaderHeadInfo@@@std@@QAEPAPAVCvLeaderHeadInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvLeaderHeadInfo@@@std@@QAEPAPAVCvLeaderHeadInfo@@I@Z PROC ; std::allocator<CvLeaderHeadInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvLeaderHeadInfo@@@std@@YAPAPAVCvLeaderHeadInfo@@IPAPAV1@@Z ; std::_Allocate<CvLeaderHeadInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvLeaderHeadInfo@@@std@@QAEPAPAVCvLeaderHeadInfo@@I@Z ENDP ; std::allocator<CvLeaderHeadInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEIXZ ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvProcessInfo@@@std@@QAEPAPAVCvProcessInfo@@I@Z ; std::allocator<CvProcessInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvProcessInfo@@@std@@QAEPAPAVCvProcessInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvProcessInfo@@@std@@QAEPAPAVCvProcessInfo@@I@Z PROC ; std::allocator<CvProcessInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvProcessInfo@@@std@@YAPAPAVCvProcessInfo@@IPAPAV1@@Z ; std::_Allocate<CvProcessInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvProcessInfo@@@std@@QAEPAPAVCvProcessInfo@@I@Z ENDP ; std::allocator<CvProcessInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEIXZ ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvVoteInfo@@@std@@QAEPAPAVCvVoteInfo@@I@Z ; std::allocator<CvVoteInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvVoteInfo@@@std@@QAEPAPAVCvVoteInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvVoteInfo@@@std@@QAEPAPAVCvVoteInfo@@I@Z PROC ; std::allocator<CvVoteInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvVoteInfo@@@std@@YAPAPAVCvVoteInfo@@IPAPAV1@@Z ; std::_Allocate<CvVoteInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvVoteInfo@@@std@@QAEPAPAVCvVoteInfo@@I@Z ENDP ; std::allocator<CvVoteInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEIXZ ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvBuildingClassInfo@@@std@@QAEPAPAVCvBuildingClassInfo@@I@Z ; std::allocator<CvBuildingClassInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvBuildingClassInfo@@@std@@QAEPAPAVCvBuildingClassInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvBuildingClassInfo@@@std@@QAEPAPAVCvBuildingClassInfo@@I@Z PROC ; std::allocator<CvBuildingClassInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvBuildingClassInfo@@@std@@YAPAPAVCvBuildingClassInfo@@IPAPAV1@@Z ; std::_Allocate<CvBuildingClassInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvBuildingClassInfo@@@std@@QAEPAPAVCvBuildingClassInfo@@I@Z ENDP ; std::allocator<CvBuildingClassInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEIXZ ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvUnitClassInfo@@@std@@QAEPAPAVCvUnitClassInfo@@I@Z ; std::allocator<CvUnitClassInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvUnitClassInfo@@@std@@QAEPAPAVCvUnitClassInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvUnitClassInfo@@@std@@QAEPAPAVCvUnitClassInfo@@I@Z PROC ; std::allocator<CvUnitClassInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvUnitClassInfo@@@std@@YAPAPAVCvUnitClassInfo@@IPAPAV1@@Z ; std::_Allocate<CvUnitClassInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvUnitClassInfo@@@std@@QAEPAPAVCvUnitClassInfo@@I@Z ENDP ; std::allocator<CvUnitClassInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEIXZ ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvSpecialUnitInfo@@@std@@QAEPAPAVCvSpecialUnitInfo@@I@Z ; std::allocator<CvSpecialUnitInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvSpecialUnitInfo@@@std@@QAEPAPAVCvSpecialUnitInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvSpecialUnitInfo@@@std@@QAEPAPAVCvSpecialUnitInfo@@I@Z PROC ; std::allocator<CvSpecialUnitInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvSpecialUnitInfo@@@std@@YAPAPAVCvSpecialUnitInfo@@IPAPAV1@@Z ; std::_Allocate<CvSpecialUnitInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvSpecialUnitInfo@@@std@@QAEPAPAVCvSpecialUnitInfo@@I@Z ENDP ; std::allocator<CvSpecialUnitInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEIXZ ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvVoteSourceInfo@@@std@@QAEPAPAVCvVoteSourceInfo@@I@Z ; std::allocator<CvVoteSourceInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvVoteSourceInfo@@@std@@QAEPAPAVCvVoteSourceInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvVoteSourceInfo@@@std@@QAEPAPAVCvVoteSourceInfo@@I@Z PROC ; std::allocator<CvVoteSourceInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvVoteSourceInfo@@@std@@YAPAPAVCvVoteSourceInfo@@IPAPAV1@@Z ; std::_Allocate<CvVoteSourceInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvVoteSourceInfo@@@std@@QAEPAPAVCvVoteSourceInfo@@I@Z ENDP ; std::allocator<CvVoteSourceInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEIXZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvBaseInfo@@@std@@QAEPAPAVCvBaseInfo@@I@Z ; std::allocator<CvBaseInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvBaseInfo@@@std@@QAEPAPAVCvBaseInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvBaseInfo@@@std@@QAEPAPAVCvBaseInfo@@I@Z PROC ; std::allocator<CvBaseInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvBaseInfo@@@std@@YAPAPAVCvBaseInfo@@IPAPAV1@@Z ; std::_Allocate<CvBaseInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvBaseInfo@@@std@@QAEPAPAVCvBaseInfo@@I@Z ENDP ; std::allocator<CvBaseInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEIXZ ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvGameOptionInfo@@@std@@QAEPAPAVCvGameOptionInfo@@I@Z ; std::allocator<CvGameOptionInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvGameOptionInfo@@@std@@QAEPAPAVCvGameOptionInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvGameOptionInfo@@@std@@QAEPAPAVCvGameOptionInfo@@I@Z PROC ; std::allocator<CvGameOptionInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvGameOptionInfo@@@std@@YAPAPAVCvGameOptionInfo@@IPAPAV1@@Z ; std::_Allocate<CvGameOptionInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvGameOptionInfo@@@std@@QAEPAPAVCvGameOptionInfo@@I@Z ENDP ; std::allocator<CvGameOptionInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEIXZ ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvMPOptionInfo@@@std@@QAEPAPAVCvMPOptionInfo@@I@Z ; std::allocator<CvMPOptionInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvMPOptionInfo@@@std@@QAEPAPAVCvMPOptionInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvMPOptionInfo@@@std@@QAEPAPAVCvMPOptionInfo@@I@Z PROC ; std::allocator<CvMPOptionInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvMPOptionInfo@@@std@@YAPAPAVCvMPOptionInfo@@IPAPAV1@@Z ; std::_Allocate<CvMPOptionInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvMPOptionInfo@@@std@@QAEPAPAVCvMPOptionInfo@@I@Z ENDP ; std::allocator<CvMPOptionInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEIXZ ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvPlayerOptionInfo@@@std@@QAEPAPAVCvPlayerOptionInfo@@I@Z ; std::allocator<CvPlayerOptionInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvPlayerOptionInfo@@@std@@QAEPAPAVCvPlayerOptionInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvPlayerOptionInfo@@@std@@QAEPAPAVCvPlayerOptionInfo@@I@Z PROC ; std::allocator<CvPlayerOptionInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvPlayerOptionInfo@@@std@@YAPAPAVCvPlayerOptionInfo@@IPAPAV1@@Z ; std::_Allocate<CvPlayerOptionInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvPlayerOptionInfo@@@std@@QAEPAPAVCvPlayerOptionInfo@@I@Z ENDP ; std::allocator<CvPlayerOptionInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEIXZ ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvSpecialistInfo@@@std@@QAEPAPAVCvSpecialistInfo@@I@Z ; std::allocator<CvSpecialistInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvSpecialistInfo@@@std@@QAEPAPAVCvSpecialistInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvSpecialistInfo@@@std@@QAEPAPAVCvSpecialistInfo@@I@Z PROC ; std::allocator<CvSpecialistInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvSpecialistInfo@@@std@@YAPAPAVCvSpecialistInfo@@IPAPAV1@@Z ; std::_Allocate<CvSpecialistInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvSpecialistInfo@@@std@@QAEPAPAVCvSpecialistInfo@@I@Z ENDP ; std::allocator<CvSpecialistInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEIXZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvActionInfo@@@std@@QAEPAPAVCvActionInfo@@I@Z ; std::allocator<CvActionInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvActionInfo@@@std@@QAEPAPAVCvActionInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvActionInfo@@@std@@QAEPAPAVCvActionInfo@@I@Z PROC ; std::allocator<CvActionInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvActionInfo@@@std@@YAPAPAVCvActionInfo@@IPAPAV1@@Z ; std::_Allocate<CvActionInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvActionInfo@@@std@@QAEPAPAVCvActionInfo@@I@Z ENDP ; std::allocator<CvActionInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEIXZ ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvMissionInfo@@@std@@QAEPAPAVCvMissionInfo@@I@Z ; std::allocator<CvMissionInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvMissionInfo@@@std@@QAEPAPAVCvMissionInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvMissionInfo@@@std@@QAEPAPAVCvMissionInfo@@I@Z PROC ; std::allocator<CvMissionInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvMissionInfo@@@std@@YAPAPAVCvMissionInfo@@IPAPAV1@@Z ; std::_Allocate<CvMissionInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvMissionInfo@@@std@@QAEPAPAVCvMissionInfo@@I@Z ENDP ; std::allocator<CvMissionInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEIXZ ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvControlInfo@@@std@@QAEPAPAVCvControlInfo@@I@Z ; std::allocator<CvControlInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvControlInfo@@@std@@QAEPAPAVCvControlInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvControlInfo@@@std@@QAEPAPAVCvControlInfo@@I@Z PROC ; std::allocator<CvControlInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvControlInfo@@@std@@YAPAPAVCvControlInfo@@IPAPAV1@@Z ; std::_Allocate<CvControlInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvControlInfo@@@std@@QAEPAPAVCvControlInfo@@I@Z ENDP ; std::allocator<CvControlInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEIXZ ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvCommandInfo@@@std@@QAEPAPAVCvCommandInfo@@I@Z ; std::allocator<CvCommandInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvCommandInfo@@@std@@QAEPAPAVCvCommandInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvCommandInfo@@@std@@QAEPAPAVCvCommandInfo@@I@Z PROC ; std::allocator<CvCommandInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvCommandInfo@@@std@@YAPAPAVCvCommandInfo@@IPAPAV1@@Z ; std::_Allocate<CvCommandInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvCommandInfo@@@std@@QAEPAPAVCvCommandInfo@@I@Z ENDP ; std::allocator<CvCommandInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEIXZ ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvAutomateInfo@@@std@@QAEPAPAVCvAutomateInfo@@I@Z ; std::allocator<CvAutomateInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvAutomateInfo@@@std@@QAEPAPAVCvAutomateInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvAutomateInfo@@@std@@QAEPAPAVCvAutomateInfo@@I@Z PROC ; std::allocator<CvAutomateInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvAutomateInfo@@@std@@YAPAPAVCvAutomateInfo@@IPAPAV1@@Z ; std::_Allocate<CvAutomateInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvAutomateInfo@@@std@@QAEPAPAVCvAutomateInfo@@I@Z ENDP ; std::allocator<CvAutomateInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEIXZ ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvEraInfo@@@std@@QAEPAPAVCvEraInfo@@I@Z ; std::allocator<CvEraInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvEraInfo@@@std@@QAEPAPAVCvEraInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvEraInfo@@@std@@QAEPAPAVCvEraInfo@@I@Z PROC ; std::allocator<CvEraInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvEraInfo@@@std@@YAPAPAVCvEraInfo@@IPAPAV1@@Z ; std::_Allocate<CvEraInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvEraInfo@@@std@@QAEPAPAVCvEraInfo@@I@Z ENDP ; std::allocator<CvEraInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEIXZ ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvHurryInfo@@@std@@QAEPAPAVCvHurryInfo@@I@Z ; std::allocator<CvHurryInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvHurryInfo@@@std@@QAEPAPAVCvHurryInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvHurryInfo@@@std@@QAEPAPAVCvHurryInfo@@I@Z PROC ; std::allocator<CvHurryInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvHurryInfo@@@std@@YAPAPAVCvHurryInfo@@IPAPAV1@@Z ; std::_Allocate<CvHurryInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvHurryInfo@@@std@@QAEPAPAVCvHurryInfo@@I@Z ENDP ; std::allocator<CvHurryInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEIXZ ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvVictoryInfo@@@std@@QAEPAPAVCvVictoryInfo@@I@Z ; std::allocator<CvVictoryInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvVictoryInfo@@@std@@QAEPAPAVCvVictoryInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvVictoryInfo@@@std@@QAEPAPAVCvVictoryInfo@@I@Z PROC ; std::allocator<CvVictoryInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvVictoryInfo@@@std@@YAPAPAVCvVictoryInfo@@IPAPAV1@@Z ; std::_Allocate<CvVictoryInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvVictoryInfo@@@std@@QAEPAPAVCvVictoryInfo@@I@Z ENDP ; std::allocator<CvVictoryInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEIXZ ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvSmallAwardInfo@@@std@@QAEPAPAVCvSmallAwardInfo@@I@Z ; std::allocator<CvSmallAwardInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvSmallAwardInfo@@@std@@QAEPAPAVCvSmallAwardInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvSmallAwardInfo@@@std@@QAEPAPAVCvSmallAwardInfo@@I@Z PROC ; std::allocator<CvSmallAwardInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvSmallAwardInfo@@@std@@YAPAPAVCvSmallAwardInfo@@IPAPAV1@@Z ; std::_Allocate<CvSmallAwardInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvSmallAwardInfo@@@std@@QAEPAPAVCvSmallAwardInfo@@I@Z ENDP ; std::allocator<CvSmallAwardInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEIXZ ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvEntityEventInfo@@@std@@QAEPAPAVCvEntityEventInfo@@I@Z ; std::allocator<CvEntityEventInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvEntityEventInfo@@@std@@QAEPAPAVCvEntityEventInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvEntityEventInfo@@@std@@QAEPAPAVCvEntityEventInfo@@I@Z PROC ; std::allocator<CvEntityEventInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvEntityEventInfo@@@std@@YAPAPAVCvEntityEventInfo@@IPAPAV1@@Z ; std::_Allocate<CvEntityEventInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvEntityEventInfo@@@std@@QAEPAPAVCvEntityEventInfo@@I@Z ENDP ; std::allocator<CvEntityEventInfo *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QBEIXZ ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAEPAPAVCvMultiUnitFormationInfo@@I@Z ; std::allocator<CvMultiUnitFormationInfo *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAEPAPAVCvMultiUnitFormationInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAEPAPAVCvMultiUnitFormationInfo@@I@Z PROC ; std::allocator<CvMultiUnitFormationInfo *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvMultiUnitFormationInfo@@@std@@YAPAPAVCvMultiUnitFormationInfo@@IPAPAV1@@Z ; std::_Allocate<CvMultiUnitFormationInfo *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvMultiUnitFormationInfo@@@std@@QAEPAPAVCvMultiUnitFormationInfo@@I@Z ENDP ; std::allocator<CvMultiUnitFormationInfo *>::allocate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z PROC ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ENDP ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEIXZ ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEIXZ PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBEIXZ ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAE@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@1@@Z ; std::_Vector_val<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Vector_val<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAE@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAE@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@1@@Z PROC ; std::_Vector_val<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Vector_val<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAE@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@1@@Z ENDP ; std::_Vector_val<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Vector_val<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN43@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN24@Dec
	npad	1
$LL25@Dec:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL25@Dec
$LN24@Dec:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Dec
$LL4@Dec:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN1@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN34@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN17@Inc
	npad	7
$LL18@Inc:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL18@Inc
$LN17@Inc:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN1@Inc
$LL2@Inc:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??F?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??F?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??F?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::operator--, COMDAT
; _this$ = ecx

; 416  : 			{	// predecrement

	mov	eax, ecx

; 417  : 			--(*(_Mybase_iter *)this);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 418  : 			return (*this);
; 419  : 			}

	ret	0
??F?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>::operator--
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z PROC ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z ENDP ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@ABQAU342@@Z PROC ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::allocate
; Function compile flags: /Ogtpy
;	COMDAT ?allocate@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z PROC ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IPAV120@@Z ; std::_Allocate<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@I@Z ENDP ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::allocate
_TEXT	ENDS
PUBLIC	?size@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEIXZ ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?size@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEIXZ PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::size, COMDAT
; _this$ = ecx

; 417  : 		return (_List.size());

	mov	eax, DWORD PTR [ecx+12]

; 418  : 		}

	ret	0
?size@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEIXZ ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??0?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ; std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??0?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z PROC ; std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct allocator from _Al

	mov	eax, ecx

; 48   : 		}

	ret	4
??0?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ENDP ; std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	mov	eax, ecx

; 40   : 		}

	ret	8
??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@@Z ; std::_Vector_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Vector_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@@Z PROC ; std::_Vector_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Vector_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@@Z ENDP ; std::_Vector_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Vector_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::operator!=
_TEXT	ENDS
PUBLIC	?max_size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEIXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::max_size, COMDAT
; _this$ = ecx

; 625  : 		return (this->_Alval.max_size());

	mov	eax, 134217727				; 07ffffffH

; 626  : 		}

	ret	0
?max_size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::max_size
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvEconomicAIStrategyXMLEntries@@@@YAXAAPAVCvEconomicAIStrategyXMLEntries@@@Z ; SAFE_DELETE<CvEconomicAIStrategyXMLEntries>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvEconomicAIStrategyXMLEntries@@@@YAXAAPAVCvEconomicAIStrategyXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvEconomicAIStrategyXMLEntries@@@@YAXAAPAVCvEconomicAIStrategyXMLEntries@@@Z PROC ; SAFE_DELETE<CvEconomicAIStrategyXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@22
	mov	ecx, esi
	call	??1CvEconomicAIStrategyXMLEntries@@QAE@XZ ; CvEconomicAIStrategyXMLEntries::~CvEconomicAIStrategyXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@22:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvEconomicAIStrategyXMLEntries@@@@YAXAAPAVCvEconomicAIStrategyXMLEntries@@@Z ENDP ; SAFE_DELETE<CvEconomicAIStrategyXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvCitySpecializationXMLEntries@@@@YAXAAPAVCvCitySpecializationXMLEntries@@@Z ; SAFE_DELETE<CvCitySpecializationXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvCitySpecializationXMLEntries@@@@YAXAAPAVCvCitySpecializationXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvCitySpecializationXMLEntries@@@@YAXAAPAVCvCitySpecializationXMLEntries@@@Z PROC ; SAFE_DELETE<CvCitySpecializationXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@23
	mov	ecx, esi
	call	??1CvCitySpecializationXMLEntries@@QAE@XZ ; CvCitySpecializationXMLEntries::~CvCitySpecializationXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@23:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvCitySpecializationXMLEntries@@@@YAXAAPAVCvCitySpecializationXMLEntries@@@Z ENDP ; SAFE_DELETE<CvCitySpecializationXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvTacticalMoveXMLEntries@@@@YAXAAPAVCvTacticalMoveXMLEntries@@@Z ; SAFE_DELETE<CvTacticalMoveXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvTacticalMoveXMLEntries@@@@YAXAAPAVCvTacticalMoveXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvTacticalMoveXMLEntries@@@@YAXAAPAVCvTacticalMoveXMLEntries@@@Z PROC ; SAFE_DELETE<CvTacticalMoveXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@24
	mov	ecx, esi
	call	??1CvTacticalMoveXMLEntries@@QAE@XZ	; CvTacticalMoveXMLEntries::~CvTacticalMoveXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@24:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvTacticalMoveXMLEntries@@@@YAXAAPAVCvTacticalMoveXMLEntries@@@Z ENDP ; SAFE_DELETE<CvTacticalMoveXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvMilitaryAIStrategyXMLEntries@@@@YAXAAPAVCvMilitaryAIStrategyXMLEntries@@@Z ; SAFE_DELETE<CvMilitaryAIStrategyXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvMilitaryAIStrategyXMLEntries@@@@YAXAAPAVCvMilitaryAIStrategyXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvMilitaryAIStrategyXMLEntries@@@@YAXAAPAVCvMilitaryAIStrategyXMLEntries@@@Z PROC ; SAFE_DELETE<CvMilitaryAIStrategyXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@25
	mov	ecx, esi
	call	??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ ; CvMilitaryAIStrategyXMLEntries::~CvMilitaryAIStrategyXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@25:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvMilitaryAIStrategyXMLEntries@@@@YAXAAPAVCvMilitaryAIStrategyXMLEntries@@@Z ENDP ; SAFE_DELETE<CvMilitaryAIStrategyXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvAIGrandStrategyXMLEntries@@@@YAXAAPAVCvAIGrandStrategyXMLEntries@@@Z ; SAFE_DELETE<CvAIGrandStrategyXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvAIGrandStrategyXMLEntries@@@@YAXAAPAVCvAIGrandStrategyXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvAIGrandStrategyXMLEntries@@@@YAXAAPAVCvAIGrandStrategyXMLEntries@@@Z PROC ; SAFE_DELETE<CvAIGrandStrategyXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@26
	mov	ecx, esi
	call	??1CvAIGrandStrategyXMLEntries@@QAE@XZ	; CvAIGrandStrategyXMLEntries::~CvAIGrandStrategyXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@26:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvAIGrandStrategyXMLEntries@@@@YAXAAPAVCvAIGrandStrategyXMLEntries@@@Z ENDP ; SAFE_DELETE<CvAIGrandStrategyXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvPolicyXMLEntries@@@@YAXAAPAVCvPolicyXMLEntries@@@Z ; SAFE_DELETE<CvPolicyXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvPolicyXMLEntries@@@@YAXAAPAVCvPolicyXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvPolicyXMLEntries@@@@YAXAAPAVCvPolicyXMLEntries@@@Z PROC ; SAFE_DELETE<CvPolicyXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@27
	mov	ecx, esi
	call	??1CvPolicyXMLEntries@@QAE@XZ		; CvPolicyXMLEntries::~CvPolicyXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@27:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvPolicyXMLEntries@@@@YAXAAPAVCvPolicyXMLEntries@@@Z ENDP ; SAFE_DELETE<CvPolicyXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvBuildingXMLEntries@@@@YAXAAPAVCvBuildingXMLEntries@@@Z ; SAFE_DELETE<CvBuildingXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvBuildingXMLEntries@@@@YAXAAPAVCvBuildingXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvBuildingXMLEntries@@@@YAXAAPAVCvBuildingXMLEntries@@@Z PROC ; SAFE_DELETE<CvBuildingXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@28
	mov	ecx, esi
	call	??1CvBuildingXMLEntries@@QAE@XZ		; CvBuildingXMLEntries::~CvBuildingXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@28:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvBuildingXMLEntries@@@@YAXAAPAVCvBuildingXMLEntries@@@Z ENDP ; SAFE_DELETE<CvBuildingXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvUnitXMLEntries@@@@YAXAAPAVCvUnitXMLEntries@@@Z ; SAFE_DELETE<CvUnitXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvUnitXMLEntries@@@@YAXAAPAVCvUnitXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvUnitXMLEntries@@@@YAXAAPAVCvUnitXMLEntries@@@Z PROC ; SAFE_DELETE<CvUnitXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@29
	mov	ecx, esi
	call	??1CvUnitXMLEntries@@QAE@XZ		; CvUnitXMLEntries::~CvUnitXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@29:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvUnitXMLEntries@@@@YAXAAPAVCvUnitXMLEntries@@@Z ENDP ; SAFE_DELETE<CvUnitXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvProjectXMLEntries@@@@YAXAAPAVCvProjectXMLEntries@@@Z ; SAFE_DELETE<CvProjectXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvProjectXMLEntries@@@@YAXAAPAVCvProjectXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvProjectXMLEntries@@@@YAXAAPAVCvProjectXMLEntries@@@Z PROC ; SAFE_DELETE<CvProjectXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@30
	mov	ecx, esi
	call	??1CvProjectXMLEntries@@QAE@XZ		; CvProjectXMLEntries::~CvProjectXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@30:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvProjectXMLEntries@@@@YAXAAPAVCvProjectXMLEntries@@@Z ENDP ; SAFE_DELETE<CvProjectXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvPromotionXMLEntries@@@@YAXAAPAVCvPromotionXMLEntries@@@Z ; SAFE_DELETE<CvPromotionXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvPromotionXMLEntries@@@@YAXAAPAVCvPromotionXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvPromotionXMLEntries@@@@YAXAAPAVCvPromotionXMLEntries@@@Z PROC ; SAFE_DELETE<CvPromotionXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@31
	mov	ecx, esi
	call	??1CvPromotionXMLEntries@@QAE@XZ	; CvPromotionXMLEntries::~CvPromotionXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@31:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvPromotionXMLEntries@@@@YAXAAPAVCvPromotionXMLEntries@@@Z ENDP ; SAFE_DELETE<CvPromotionXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvEmphasisXMLEntries@@@@YAXAAPAVCvEmphasisXMLEntries@@@Z ; SAFE_DELETE<CvEmphasisXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvEmphasisXMLEntries@@@@YAXAAPAVCvEmphasisXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvEmphasisXMLEntries@@@@YAXAAPAVCvEmphasisXMLEntries@@@Z PROC ; SAFE_DELETE<CvEmphasisXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@32
	mov	ecx, esi
	call	??1CvEmphasisXMLEntries@@QAE@XZ		; CvEmphasisXMLEntries::~CvEmphasisXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@32:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvEmphasisXMLEntries@@@@YAXAAPAVCvEmphasisXMLEntries@@@Z ENDP ; SAFE_DELETE<CvEmphasisXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvTraitXMLEntries@@@@YAXAAPAVCvTraitXMLEntries@@@Z ; SAFE_DELETE<CvTraitXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvTraitXMLEntries@@@@YAXAAPAVCvTraitXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvTraitXMLEntries@@@@YAXAAPAVCvTraitXMLEntries@@@Z PROC ; SAFE_DELETE<CvTraitXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@33
	mov	ecx, esi
	call	??1CvTraitXMLEntries@@QAE@XZ		; CvTraitXMLEntries::~CvTraitXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@33:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvTraitXMLEntries@@@@YAXAAPAVCvTraitXMLEntries@@@Z ENDP ; SAFE_DELETE<CvTraitXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvReligionXMLEntries@@@@YAXAAPAVCvReligionXMLEntries@@@Z ; SAFE_DELETE<CvReligionXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvReligionXMLEntries@@@@YAXAAPAVCvReligionXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvReligionXMLEntries@@@@YAXAAPAVCvReligionXMLEntries@@@Z PROC ; SAFE_DELETE<CvReligionXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@34
	mov	ecx, esi
	call	??1CvReligionXMLEntries@@QAE@XZ		; CvReligionXMLEntries::~CvReligionXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@34:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvReligionXMLEntries@@@@YAXAAPAVCvReligionXMLEntries@@@Z ENDP ; SAFE_DELETE<CvReligionXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvBeliefXMLEntries@@@@YAXAAPAVCvBeliefXMLEntries@@@Z ; SAFE_DELETE<CvBeliefXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvBeliefXMLEntries@@@@YAXAAPAVCvBeliefXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvBeliefXMLEntries@@@@YAXAAPAVCvBeliefXMLEntries@@@Z PROC ; SAFE_DELETE<CvBeliefXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@35
	mov	ecx, esi
	call	??1CvBeliefXMLEntries@@QAE@XZ		; CvBeliefXMLEntries::~CvBeliefXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@35:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvBeliefXMLEntries@@@@YAXAAPAVCvBeliefXMLEntries@@@Z ENDP ; SAFE_DELETE<CvBeliefXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvLeagueSpecialSessionXMLEntries@@@@YAXAAPAVCvLeagueSpecialSessionXMLEntries@@@Z ; SAFE_DELETE<CvLeagueSpecialSessionXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvLeagueSpecialSessionXMLEntries@@@@YAXAAPAVCvLeagueSpecialSessionXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvLeagueSpecialSessionXMLEntries@@@@YAXAAPAVCvLeagueSpecialSessionXMLEntries@@@Z PROC ; SAFE_DELETE<CvLeagueSpecialSessionXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@36
	mov	ecx, esi
	call	??1CvLeagueSpecialSessionXMLEntries@@QAE@XZ ; CvLeagueSpecialSessionXMLEntries::~CvLeagueSpecialSessionXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@36:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvLeagueSpecialSessionXMLEntries@@@@YAXAAPAVCvLeagueSpecialSessionXMLEntries@@@Z ENDP ; SAFE_DELETE<CvLeagueSpecialSessionXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvLeagueNameXMLEntries@@@@YAXAAPAVCvLeagueNameXMLEntries@@@Z ; SAFE_DELETE<CvLeagueNameXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvLeagueNameXMLEntries@@@@YAXAAPAVCvLeagueNameXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvLeagueNameXMLEntries@@@@YAXAAPAVCvLeagueNameXMLEntries@@@Z PROC ; SAFE_DELETE<CvLeagueNameXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@37
	mov	ecx, esi
	call	??1CvLeagueNameXMLEntries@@QAE@XZ	; CvLeagueNameXMLEntries::~CvLeagueNameXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@37:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvLeagueNameXMLEntries@@@@YAXAAPAVCvLeagueNameXMLEntries@@@Z ENDP ; SAFE_DELETE<CvLeagueNameXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvLeagueProjectXMLEntries@@@@YAXAAPAVCvLeagueProjectXMLEntries@@@Z ; SAFE_DELETE<CvLeagueProjectXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvLeagueProjectXMLEntries@@@@YAXAAPAVCvLeagueProjectXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvLeagueProjectXMLEntries@@@@YAXAAPAVCvLeagueProjectXMLEntries@@@Z PROC ; SAFE_DELETE<CvLeagueProjectXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@38
	mov	ecx, esi
	call	??1CvLeagueProjectXMLEntries@@QAE@XZ	; CvLeagueProjectXMLEntries::~CvLeagueProjectXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@38:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvLeagueProjectXMLEntries@@@@YAXAAPAVCvLeagueProjectXMLEntries@@@Z ENDP ; SAFE_DELETE<CvLeagueProjectXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvLeagueProjectRewardXMLEntries@@@@YAXAAPAVCvLeagueProjectRewardXMLEntries@@@Z ; SAFE_DELETE<CvLeagueProjectRewardXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvLeagueProjectRewardXMLEntries@@@@YAXAAPAVCvLeagueProjectRewardXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvLeagueProjectRewardXMLEntries@@@@YAXAAPAVCvLeagueProjectRewardXMLEntries@@@Z PROC ; SAFE_DELETE<CvLeagueProjectRewardXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@39
	mov	ecx, esi
	call	??1CvLeagueProjectRewardXMLEntries@@QAE@XZ ; CvLeagueProjectRewardXMLEntries::~CvLeagueProjectRewardXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@39:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvLeagueProjectRewardXMLEntries@@@@YAXAAPAVCvLeagueProjectRewardXMLEntries@@@Z ENDP ; SAFE_DELETE<CvLeagueProjectRewardXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvResolutionXMLEntries@@@@YAXAAPAVCvResolutionXMLEntries@@@Z ; SAFE_DELETE<CvResolutionXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvResolutionXMLEntries@@@@YAXAAPAVCvResolutionXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvResolutionXMLEntries@@@@YAXAAPAVCvResolutionXMLEntries@@@Z PROC ; SAFE_DELETE<CvResolutionXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@40
	mov	ecx, esi
	call	??1CvResolutionXMLEntries@@QAE@XZ	; CvResolutionXMLEntries::~CvResolutionXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@40:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvResolutionXMLEntries@@@@YAXAAPAVCvResolutionXMLEntries@@@Z ENDP ; SAFE_DELETE<CvResolutionXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvNotificationXMLEntries@@@@YAXAAPAVCvNotificationXMLEntries@@@Z ; SAFE_DELETE<CvNotificationXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvNotificationXMLEntries@@@@YAXAAPAVCvNotificationXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvNotificationXMLEntries@@@@YAXAAPAVCvNotificationXMLEntries@@@Z PROC ; SAFE_DELETE<CvNotificationXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@41
	mov	ecx, esi
	call	??1CvNotificationXMLEntries@@QAE@XZ	; CvNotificationXMLEntries::~CvNotificationXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@41:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvNotificationXMLEntries@@@@YAXAAPAVCvNotificationXMLEntries@@@Z ENDP ; SAFE_DELETE<CvNotificationXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvImprovementXMLEntries@@@@YAXAAPAVCvImprovementXMLEntries@@@Z ; SAFE_DELETE<CvImprovementXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvImprovementXMLEntries@@@@YAXAAPAVCvImprovementXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvImprovementXMLEntries@@@@YAXAAPAVCvImprovementXMLEntries@@@Z PROC ; SAFE_DELETE<CvImprovementXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@42
	mov	ecx, esi
	call	??1CvImprovementXMLEntries@@QAE@XZ	; CvImprovementXMLEntries::~CvImprovementXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@42:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvImprovementXMLEntries@@@@YAXAAPAVCvImprovementXMLEntries@@@Z ENDP ; SAFE_DELETE<CvImprovementXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvTechXMLEntries@@@@YAXAAPAVCvTechXMLEntries@@@Z ; SAFE_DELETE<CvTechXMLEntries>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvTechXMLEntries@@@@YAXAAPAVCvTechXMLEntries@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvTechXMLEntries@@@@YAXAAPAVCvTechXMLEntries@@@Z PROC ; SAFE_DELETE<CvTechXMLEntries>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@43
	mov	ecx, esi
	call	??1CvTechXMLEntries@@QAE@XZ		; CvTechXMLEntries::~CvTechXMLEntries
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@43:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvTechXMLEntries@@@@YAXAAPAVCvTechXMLEntries@@@Z ENDP ; SAFE_DELETE<CvTechXMLEntries>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvGame@@@@YAXAAPAVCvGame@@@Z	; SAFE_DELETE<CvGame>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvGame@@@@YAXAAPAVCvGame@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvGame@@@@YAXAAPAVCvGame@@@Z PROC	; SAFE_DELETE<CvGame>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@44
	mov	ecx, esi
	call	??1CvGame@@QAE@XZ			; CvGame::~CvGame
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@44:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvGame@@@@YAXAAPAVCvGame@@@Z ENDP	; SAFE_DELETE<CvGame>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvTwoLayerPathFinder@@@@YAXAAPAVCvTwoLayerPathFinder@@@Z ; SAFE_DELETE<CvTwoLayerPathFinder>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvTwoLayerPathFinder@@@@YAXAAPAVCvTwoLayerPathFinder@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvTwoLayerPathFinder@@@@YAXAAPAVCvTwoLayerPathFinder@@@Z PROC ; SAFE_DELETE<CvTwoLayerPathFinder>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@45
	mov	ecx, esi
	call	??1CvTwoLayerPathFinder@@QAE@XZ		; CvTwoLayerPathFinder::~CvTwoLayerPathFinder
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@45:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvTwoLayerPathFinder@@@@YAXAAPAVCvTwoLayerPathFinder@@@Z ENDP ; SAFE_DELETE<CvTwoLayerPathFinder>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvAStar@@@@YAXAAPAVCvAStar@@@Z	; SAFE_DELETE<CvAStar>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvAStar@@@@YAXAAPAVCvAStar@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvAStar@@@@YAXAAPAVCvAStar@@@Z PROC	; SAFE_DELETE<CvAStar>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@46
	mov	ecx, esi
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@46:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvAStar@@@@YAXAAPAVCvAStar@@@Z ENDP	; SAFE_DELETE<CvAStar>
_TEXT	ENDS
PUBLIC	??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ ; std::auto_ptr<ICvCity1>::operator<ICvCity1> std::auto_ptr_ref<ICvCity1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ PROC ; std::auto_ptr<ICvCity1>::operator<ICvCity1> std::auto_ptr_ref<ICvCity1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvCity1@@@?$auto_ptr@VICvCity1@@@std@@QAE?AU?$auto_ptr_ref@VICvCity1@@@1@XZ ENDP ; std::auto_ptr<ICvCity1>::operator<ICvCity1> std::auto_ptr_ref<ICvCity1>
_TEXT	ENDS
PUBLIC	??$?BVICvDeal1@@@?$auto_ptr@VICvDeal1@@@std@@QAE?AU?$auto_ptr_ref@VICvDeal1@@@1@XZ ; std::auto_ptr<ICvDeal1>::operator<ICvDeal1> std::auto_ptr_ref<ICvDeal1>
; Function compile flags: /Ogtpy
;	COMDAT ??$?BVICvDeal1@@@?$auto_ptr@VICvDeal1@@@std@@QAE?AU?$auto_ptr_ref@VICvDeal1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvDeal1@@@?$auto_ptr@VICvDeal1@@@std@@QAE?AU?$auto_ptr_ref@VICvDeal1@@@1@XZ PROC ; std::auto_ptr<ICvDeal1>::operator<ICvDeal1> std::auto_ptr_ref<ICvDeal1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvDeal1@@@?$auto_ptr@VICvDeal1@@@std@@QAE?AU?$auto_ptr_ref@VICvDeal1@@@1@XZ ENDP ; std::auto_ptr<ICvDeal1>::operator<ICvDeal1> std::auto_ptr_ref<ICvDeal1>
_TEXT	ENDS
PUBLIC	??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ PROC ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ ENDP ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>
_TEXT	ENDS
PUBLIC	??$?BVICvRandom1@@@?$auto_ptr@VICvRandom1@@@std@@QAE?AU?$auto_ptr_ref@VICvRandom1@@@1@XZ ; std::auto_ptr<ICvRandom1>::operator<ICvRandom1> std::auto_ptr_ref<ICvRandom1>
; Function compile flags: /Ogtpy
;	COMDAT ??$?BVICvRandom1@@@?$auto_ptr@VICvRandom1@@@std@@QAE?AU?$auto_ptr_ref@VICvRandom1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvRandom1@@@?$auto_ptr@VICvRandom1@@@std@@QAE?AU?$auto_ptr_ref@VICvRandom1@@@1@XZ PROC ; std::auto_ptr<ICvRandom1>::operator<ICvRandom1> std::auto_ptr_ref<ICvRandom1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvRandom1@@@?$auto_ptr@VICvRandom1@@@std@@QAE?AU?$auto_ptr_ref@VICvRandom1@@@1@XZ ENDP ; std::auto_ptr<ICvRandom1>::operator<ICvRandom1> std::auto_ptr_ref<ICvRandom1>
_TEXT	ENDS
PUBLIC	??$?BVICvUnit1@@@?$auto_ptr@VICvUnit1@@@std@@QAE?AU?$auto_ptr_ref@VICvUnit1@@@1@XZ ; std::auto_ptr<ICvUnit1>::operator<ICvUnit1> std::auto_ptr_ref<ICvUnit1>
; Function compile flags: /Ogtpy
;	COMDAT ??$?BVICvUnit1@@@?$auto_ptr@VICvUnit1@@@std@@QAE?AU?$auto_ptr_ref@VICvUnit1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvUnit1@@@?$auto_ptr@VICvUnit1@@@std@@QAE?AU?$auto_ptr_ref@VICvUnit1@@@1@XZ PROC ; std::auto_ptr<ICvUnit1>::operator<ICvUnit1> std::auto_ptr_ref<ICvUnit1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvUnit1@@@?$auto_ptr@VICvUnit1@@@std@@QAE?AU?$auto_ptr_ref@VICvUnit1@@@1@XZ ENDP ; std::auto_ptr<ICvUnit1>::operator<ICvUnit1> std::auto_ptr_ref<ICvUnit1>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@VCvString@@@@YAXAAPAVCvString@@@Z ; SAFE_DELETE_ARRAY<CvString>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@VCvString@@@@YAXAAPAVCvString@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@VCvString@@@@YAXAAPAVCvString@@@Z PROC ; SAFE_DELETE_ARRAY<CvString>, COMDAT

; 311  : {

	push	edi

; 312  : 	delete[] pkInstanceArray;

	mov	edi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN13@SAFE_DELET@47
	mov	ecx, DWORD PTR [eax-4]
	push	esi
	lea	esi, DWORD PTR [eax-4]
	push	OFFSET ??1CvString@@QAE@XZ		; CvString::~CvString
	push	ecx
	push	28					; 0000001cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	esi
$LN13@SAFE_DELET@47:

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@VCvString@@@@YAXAAPAVCvString@@@Z ENDP ; SAFE_DELETE_ARRAY<CvString>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@YAXPAPAVCvInterfaceModeInfo@@0AAV?$allocator@PAVCvInterfaceModeInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvInterfaceModeInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@YAXPAPAVCvInterfaceModeInfo@@0AAV?$allocator@PAVCvInterfaceModeInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@YAXPAPAVCvInterfaceModeInfo@@0AAV?$allocator@PAVCvInterfaceModeInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvInterfaceModeInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@YAXPAPAVCvInterfaceModeInfo@@0AAV?$allocator@PAVCvInterfaceModeInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvInterfaceModeInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvColorInfo@@@std@@@std@@YAXPAPAVCvColorInfo@@0AAV?$allocator@PAVCvColorInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvColorInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvColorInfo@@@std@@@std@@YAXPAPAVCvColorInfo@@0AAV?$allocator@PAVCvColorInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvColorInfo@@@std@@@std@@YAXPAPAVCvColorInfo@@0AAV?$allocator@PAVCvColorInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvColorInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvColorInfo@@@std@@@std@@YAXPAPAVCvColorInfo@@0AAV?$allocator@PAVCvColorInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvColorInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@YAXPAPAVCvPlayerColorInfo@@0AAV?$allocator@PAVCvPlayerColorInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvPlayerColorInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@YAXPAPAVCvPlayerColorInfo@@0AAV?$allocator@PAVCvPlayerColorInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@YAXPAPAVCvPlayerColorInfo@@0AAV?$allocator@PAVCvPlayerColorInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPlayerColorInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@YAXPAPAVCvPlayerColorInfo@@0AAV?$allocator@PAVCvPlayerColorInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPlayerColorInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@YAXPAPAVCvTerrainInfo@@0AAV?$allocator@PAVCvTerrainInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvTerrainInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@YAXPAPAVCvTerrainInfo@@0AAV?$allocator@PAVCvTerrainInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@YAXPAPAVCvTerrainInfo@@0AAV?$allocator@PAVCvTerrainInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTerrainInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@YAXPAPAVCvTerrainInfo@@0AAV?$allocator@PAVCvTerrainInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTerrainInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvYieldInfo@@@std@@@std@@YAXPAPAVCvYieldInfo@@0AAV?$allocator@PAVCvYieldInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvYieldInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvYieldInfo@@@std@@@std@@YAXPAPAVCvYieldInfo@@0AAV?$allocator@PAVCvYieldInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvYieldInfo@@@std@@@std@@YAXPAPAVCvYieldInfo@@0AAV?$allocator@PAVCvYieldInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvYieldInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvYieldInfo@@@std@@@std@@YAXPAPAVCvYieldInfo@@0AAV?$allocator@PAVCvYieldInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvYieldInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvRouteInfo@@@std@@@std@@YAXPAPAVCvRouteInfo@@0AAV?$allocator@PAVCvRouteInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvRouteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvRouteInfo@@@std@@@std@@YAXPAPAVCvRouteInfo@@0AAV?$allocator@PAVCvRouteInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvRouteInfo@@@std@@@std@@YAXPAPAVCvRouteInfo@@0AAV?$allocator@PAVCvRouteInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvRouteInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvRouteInfo@@@std@@@std@@YAXPAPAVCvRouteInfo@@0AAV?$allocator@PAVCvRouteInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvRouteInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@YAXPAPAVCvFeatureInfo@@0AAV?$allocator@PAVCvFeatureInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvFeatureInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@YAXPAPAVCvFeatureInfo@@0AAV?$allocator@PAVCvFeatureInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@YAXPAPAVCvFeatureInfo@@0AAV?$allocator@PAVCvFeatureInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvFeatureInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@YAXPAPAVCvFeatureInfo@@0AAV?$allocator@PAVCvFeatureInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvFeatureInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@YAXPAPAVCvResourceClassInfo@@0AAV?$allocator@PAVCvResourceClassInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvResourceClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@YAXPAPAVCvResourceClassInfo@@0AAV?$allocator@PAVCvResourceClassInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@YAXPAPAVCvResourceClassInfo@@0AAV?$allocator@PAVCvResourceClassInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvResourceClassInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@YAXPAPAVCvResourceClassInfo@@0AAV?$allocator@PAVCvResourceClassInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvResourceClassInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvResourceInfo@@@std@@@std@@YAXPAPAVCvResourceInfo@@0AAV?$allocator@PAVCvResourceInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvResourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvResourceInfo@@@std@@@std@@YAXPAPAVCvResourceInfo@@0AAV?$allocator@PAVCvResourceInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvResourceInfo@@@std@@@std@@YAXPAPAVCvResourceInfo@@0AAV?$allocator@PAVCvResourceInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvResourceInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvResourceInfo@@@std@@@std@@YAXPAPAVCvResourceInfo@@0AAV?$allocator@PAVCvResourceInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvResourceInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvBuildInfo@@@std@@@std@@YAXPAPAVCvBuildInfo@@0AAV?$allocator@PAVCvBuildInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvBuildInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvBuildInfo@@@std@@@std@@YAXPAPAVCvBuildInfo@@0AAV?$allocator@PAVCvBuildInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvBuildInfo@@@std@@@std@@YAXPAPAVCvBuildInfo@@0AAV?$allocator@PAVCvBuildInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvBuildInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvBuildInfo@@@std@@@std@@YAXPAPAVCvBuildInfo@@0AAV?$allocator@PAVCvBuildInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvBuildInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@YAXPAPAVCvHandicapInfo@@0AAV?$allocator@PAVCvHandicapInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvHandicapInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@YAXPAPAVCvHandicapInfo@@0AAV?$allocator@PAVCvHandicapInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@YAXPAPAVCvHandicapInfo@@0AAV?$allocator@PAVCvHandicapInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvHandicapInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@YAXPAPAVCvHandicapInfo@@0AAV?$allocator@PAVCvHandicapInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvHandicapInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@YAXPAPAVCvGameSpeedInfo@@0AAV?$allocator@PAVCvGameSpeedInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvGameSpeedInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@YAXPAPAVCvGameSpeedInfo@@0AAV?$allocator@PAVCvGameSpeedInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@YAXPAPAVCvGameSpeedInfo@@0AAV?$allocator@PAVCvGameSpeedInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvGameSpeedInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@YAXPAPAVCvGameSpeedInfo@@0AAV?$allocator@PAVCvGameSpeedInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvGameSpeedInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@YAXPAPAVCvTurnTimerInfo@@0AAV?$allocator@PAVCvTurnTimerInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvTurnTimerInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@YAXPAPAVCvTurnTimerInfo@@0AAV?$allocator@PAVCvTurnTimerInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@YAXPAPAVCvTurnTimerInfo@@0AAV?$allocator@PAVCvTurnTimerInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTurnTimerInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@YAXPAPAVCvTurnTimerInfo@@0AAV?$allocator@PAVCvTurnTimerInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTurnTimerInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@YAXPAPAVCvCivilizationInfo@@0AAV?$allocator@PAVCvCivilizationInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvCivilizationInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@YAXPAPAVCvCivilizationInfo@@0AAV?$allocator@PAVCvCivilizationInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@YAXPAPAVCvCivilizationInfo@@0AAV?$allocator@PAVCvCivilizationInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCivilizationInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@YAXPAPAVCvCivilizationInfo@@0AAV?$allocator@PAVCvCivilizationInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCivilizationInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@YAXPAPAVCvMinorCivInfo@@0AAV?$allocator@PAVCvMinorCivInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvMinorCivInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@YAXPAPAVCvMinorCivInfo@@0AAV?$allocator@PAVCvMinorCivInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@YAXPAPAVCvMinorCivInfo@@0AAV?$allocator@PAVCvMinorCivInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvMinorCivInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@YAXPAPAVCvMinorCivInfo@@0AAV?$allocator@PAVCvMinorCivInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvMinorCivInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@YAXPAPAVCvLeaderHeadInfo@@0AAV?$allocator@PAVCvLeaderHeadInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvLeaderHeadInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@YAXPAPAVCvLeaderHeadInfo@@0AAV?$allocator@PAVCvLeaderHeadInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@YAXPAPAVCvLeaderHeadInfo@@0AAV?$allocator@PAVCvLeaderHeadInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvLeaderHeadInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@YAXPAPAVCvLeaderHeadInfo@@0AAV?$allocator@PAVCvLeaderHeadInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvLeaderHeadInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvProcessInfo@@@std@@@std@@YAXPAPAVCvProcessInfo@@0AAV?$allocator@PAVCvProcessInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvProcessInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvProcessInfo@@@std@@@std@@YAXPAPAVCvProcessInfo@@0AAV?$allocator@PAVCvProcessInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvProcessInfo@@@std@@@std@@YAXPAPAVCvProcessInfo@@0AAV?$allocator@PAVCvProcessInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvProcessInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvProcessInfo@@@std@@@std@@YAXPAPAVCvProcessInfo@@0AAV?$allocator@PAVCvProcessInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvProcessInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvVoteInfo@@@std@@@std@@YAXPAPAVCvVoteInfo@@0AAV?$allocator@PAVCvVoteInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvVoteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvVoteInfo@@@std@@@std@@YAXPAPAVCvVoteInfo@@0AAV?$allocator@PAVCvVoteInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvVoteInfo@@@std@@@std@@YAXPAPAVCvVoteInfo@@0AAV?$allocator@PAVCvVoteInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvVoteInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvVoteInfo@@@std@@@std@@YAXPAPAVCvVoteInfo@@0AAV?$allocator@PAVCvVoteInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvVoteInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@YAXPAPAVCvBuildingClassInfo@@0AAV?$allocator@PAVCvBuildingClassInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvBuildingClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@YAXPAPAVCvBuildingClassInfo@@0AAV?$allocator@PAVCvBuildingClassInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@YAXPAPAVCvBuildingClassInfo@@0AAV?$allocator@PAVCvBuildingClassInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvBuildingClassInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@YAXPAPAVCvBuildingClassInfo@@0AAV?$allocator@PAVCvBuildingClassInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvBuildingClassInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@YAXPAPAVCvUnitClassInfo@@0AAV?$allocator@PAVCvUnitClassInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvUnitClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@YAXPAPAVCvUnitClassInfo@@0AAV?$allocator@PAVCvUnitClassInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@YAXPAPAVCvUnitClassInfo@@0AAV?$allocator@PAVCvUnitClassInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvUnitClassInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@YAXPAPAVCvUnitClassInfo@@0AAV?$allocator@PAVCvUnitClassInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvUnitClassInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@YAXPAPAVCvSpecialUnitInfo@@0AAV?$allocator@PAVCvSpecialUnitInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvSpecialUnitInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@YAXPAPAVCvSpecialUnitInfo@@0AAV?$allocator@PAVCvSpecialUnitInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@YAXPAPAVCvSpecialUnitInfo@@0AAV?$allocator@PAVCvSpecialUnitInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvSpecialUnitInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@YAXPAPAVCvSpecialUnitInfo@@0AAV?$allocator@PAVCvSpecialUnitInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvSpecialUnitInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@YAXPAPAVCvVoteSourceInfo@@0AAV?$allocator@PAVCvVoteSourceInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvVoteSourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@YAXPAPAVCvVoteSourceInfo@@0AAV?$allocator@PAVCvVoteSourceInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@YAXPAPAVCvVoteSourceInfo@@0AAV?$allocator@PAVCvVoteSourceInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvVoteSourceInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@YAXPAPAVCvVoteSourceInfo@@0AAV?$allocator@PAVCvVoteSourceInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvVoteSourceInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvBaseInfo@@@std@@@std@@YAXPAPAVCvBaseInfo@@0AAV?$allocator@PAVCvBaseInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvBaseInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvBaseInfo@@@std@@@std@@YAXPAPAVCvBaseInfo@@0AAV?$allocator@PAVCvBaseInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvBaseInfo@@@std@@@std@@YAXPAPAVCvBaseInfo@@0AAV?$allocator@PAVCvBaseInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvBaseInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvBaseInfo@@@std@@@std@@YAXPAPAVCvBaseInfo@@0AAV?$allocator@PAVCvBaseInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvBaseInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@YAXPAPAVCvGameOptionInfo@@0AAV?$allocator@PAVCvGameOptionInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvGameOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@YAXPAPAVCvGameOptionInfo@@0AAV?$allocator@PAVCvGameOptionInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@YAXPAPAVCvGameOptionInfo@@0AAV?$allocator@PAVCvGameOptionInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvGameOptionInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@YAXPAPAVCvGameOptionInfo@@0AAV?$allocator@PAVCvGameOptionInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvGameOptionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@YAXPAPAVCvMPOptionInfo@@0AAV?$allocator@PAVCvMPOptionInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvMPOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@YAXPAPAVCvMPOptionInfo@@0AAV?$allocator@PAVCvMPOptionInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@YAXPAPAVCvMPOptionInfo@@0AAV?$allocator@PAVCvMPOptionInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvMPOptionInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@YAXPAPAVCvMPOptionInfo@@0AAV?$allocator@PAVCvMPOptionInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvMPOptionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@YAXPAPAVCvPlayerOptionInfo@@0AAV?$allocator@PAVCvPlayerOptionInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvPlayerOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@YAXPAPAVCvPlayerOptionInfo@@0AAV?$allocator@PAVCvPlayerOptionInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@YAXPAPAVCvPlayerOptionInfo@@0AAV?$allocator@PAVCvPlayerOptionInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPlayerOptionInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@YAXPAPAVCvPlayerOptionInfo@@0AAV?$allocator@PAVCvPlayerOptionInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPlayerOptionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@YAXPAPAVCvSpecialistInfo@@0AAV?$allocator@PAVCvSpecialistInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvSpecialistInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@YAXPAPAVCvSpecialistInfo@@0AAV?$allocator@PAVCvSpecialistInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@YAXPAPAVCvSpecialistInfo@@0AAV?$allocator@PAVCvSpecialistInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvSpecialistInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@YAXPAPAVCvSpecialistInfo@@0AAV?$allocator@PAVCvSpecialistInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvSpecialistInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvActionInfo@@@std@@@std@@YAXPAPAVCvActionInfo@@0AAV?$allocator@PAVCvActionInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvActionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvActionInfo@@@std@@@std@@YAXPAPAVCvActionInfo@@0AAV?$allocator@PAVCvActionInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvActionInfo@@@std@@@std@@YAXPAPAVCvActionInfo@@0AAV?$allocator@PAVCvActionInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvActionInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvActionInfo@@@std@@@std@@YAXPAPAVCvActionInfo@@0AAV?$allocator@PAVCvActionInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvActionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvMissionInfo@@@std@@@std@@YAXPAPAVCvMissionInfo@@0AAV?$allocator@PAVCvMissionInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvMissionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvMissionInfo@@@std@@@std@@YAXPAPAVCvMissionInfo@@0AAV?$allocator@PAVCvMissionInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvMissionInfo@@@std@@@std@@YAXPAPAVCvMissionInfo@@0AAV?$allocator@PAVCvMissionInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvMissionInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvMissionInfo@@@std@@@std@@YAXPAPAVCvMissionInfo@@0AAV?$allocator@PAVCvMissionInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvMissionInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvControlInfo@@@std@@@std@@YAXPAPAVCvControlInfo@@0AAV?$allocator@PAVCvControlInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvControlInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvControlInfo@@@std@@@std@@YAXPAPAVCvControlInfo@@0AAV?$allocator@PAVCvControlInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvControlInfo@@@std@@@std@@YAXPAPAVCvControlInfo@@0AAV?$allocator@PAVCvControlInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvControlInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvControlInfo@@@std@@@std@@YAXPAPAVCvControlInfo@@0AAV?$allocator@PAVCvControlInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvControlInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCommandInfo@@@std@@@std@@YAXPAPAVCvCommandInfo@@0AAV?$allocator@PAVCvCommandInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvCommandInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCommandInfo@@@std@@@std@@YAXPAPAVCvCommandInfo@@0AAV?$allocator@PAVCvCommandInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvCommandInfo@@@std@@@std@@YAXPAPAVCvCommandInfo@@0AAV?$allocator@PAVCvCommandInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCommandInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCommandInfo@@@std@@@std@@YAXPAPAVCvCommandInfo@@0AAV?$allocator@PAVCvCommandInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCommandInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@YAXPAPAVCvAutomateInfo@@0AAV?$allocator@PAVCvAutomateInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvAutomateInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@YAXPAPAVCvAutomateInfo@@0AAV?$allocator@PAVCvAutomateInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@YAXPAPAVCvAutomateInfo@@0AAV?$allocator@PAVCvAutomateInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvAutomateInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@YAXPAPAVCvAutomateInfo@@0AAV?$allocator@PAVCvAutomateInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvAutomateInfo *> >
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvEraInfo@@@std@@@std@@YAXPAPAVCvEraInfo@@0AAV?$allocator@PAVCvEraInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvEraInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvEraInfo@@@std@@@std@@YAXPAPAVCvEraInfo@@0AAV?$allocator@PAVCvEraInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvEraInfo@@@std@@@std@@YAXPAPAVCvEraInfo@@0AAV?$allocator@PAVCvEraInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvEraInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvEraInfo@@@std@@@std@@YAXPAPAVCvEraInfo@@0AAV?$allocator@PAVCvEraInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvEraInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvHurryInfo@@@std@@@std@@YAXPAPAVCvHurryInfo@@0AAV?$allocator@PAVCvHurryInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvHurryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvHurryInfo@@@std@@@std@@YAXPAPAVCvHurryInfo@@0AAV?$allocator@PAVCvHurryInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvHurryInfo@@@std@@@std@@YAXPAPAVCvHurryInfo@@0AAV?$allocator@PAVCvHurryInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvHurryInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvHurryInfo@@@std@@@std@@YAXPAPAVCvHurryInfo@@0AAV?$allocator@PAVCvHurryInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvHurryInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@YAXPAPAVCvVictoryInfo@@0AAV?$allocator@PAVCvVictoryInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvVictoryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@YAXPAPAVCvVictoryInfo@@0AAV?$allocator@PAVCvVictoryInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@YAXPAPAVCvVictoryInfo@@0AAV?$allocator@PAVCvVictoryInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvVictoryInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@YAXPAPAVCvVictoryInfo@@0AAV?$allocator@PAVCvVictoryInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvVictoryInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@YAXPAPAVCvSmallAwardInfo@@0AAV?$allocator@PAVCvSmallAwardInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvSmallAwardInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@YAXPAPAVCvSmallAwardInfo@@0AAV?$allocator@PAVCvSmallAwardInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@YAXPAPAVCvSmallAwardInfo@@0AAV?$allocator@PAVCvSmallAwardInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvSmallAwardInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@YAXPAPAVCvSmallAwardInfo@@0AAV?$allocator@PAVCvSmallAwardInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvSmallAwardInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@YAXPAPAVCvEntityEventInfo@@0AAV?$allocator@PAVCvEntityEventInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvEntityEventInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@YAXPAPAVCvEntityEventInfo@@0AAV?$allocator@PAVCvEntityEventInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@YAXPAPAVCvEntityEventInfo@@0AAV?$allocator@PAVCvEntityEventInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvEntityEventInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@YAXPAPAVCvEntityEventInfo@@0AAV?$allocator@PAVCvEntityEventInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvEntityEventInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@YAXPAPAVCvMultiUnitFormationInfo@@0AAV?$allocator@PAVCvMultiUnitFormationInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CvMultiUnitFormationInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@YAXPAPAVCvMultiUnitFormationInfo@@0AAV?$allocator@PAVCvMultiUnitFormationInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@YAXPAPAVCvMultiUnitFormationInfo@@0AAV?$allocator@PAVCvMultiUnitFormationInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvMultiUnitFormationInfo *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@YAXPAPAVCvMultiUnitFormationInfo@@0AAV?$allocator@PAVCvMultiUnitFormationInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvMultiUnitFormationInfo *> >
_TEXT	ENDS
PUBLIC	??$hash_value@DU?$char_traits@D@std@@V?$allocator@D@2@@stdext@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stdext::hash_value<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ??$hash_value@DU?$char_traits@D@std@@V?$allocator@D@2@@stdext@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
??$hash_value@DU?$char_traits@D@std@@V?$allocator@D@2@@stdext@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; stdext::hash_value<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 65   : 	{	// hash string to size_t value

	push	esi
	push	edi

; 66   : 	const _Elem *_Ptr = _Str.c_str();

	mov	edi, DWORD PTR __Str$[esp+4]
	mov	ecx, edi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 67   : 
; 68   : 	return (_Hash_value(_Ptr, _Ptr + _Str.size()));

	mov	ecx, edi
	mov	esi, eax
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	mov	edx, eax
	add	edx, esi
	mov	ecx, esi
	mov	eax, -2128831035			; 811c9dc5H
	cmp	esi, edx
	je	SHORT $LN3@hash_value
	npad	9
$LL4@hash_value:
	movsx	esi, BYTE PTR [ecx]
	imul	eax, 16777619				; 01000193H
	inc	ecx
	xor	eax, esi
	cmp	ecx, edx
	jne	SHORT $LL4@hash_value
$LN3@hash_value:
	pop	edi
	pop	esi

; 69   : 	}

	ret	0
??$hash_value@DU?$char_traits@D@std@@V?$allocator@D@2@@stdext@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; stdext::hash_value<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00@Z ; stdext::unchecked_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00@Z PROC ; stdext::unchecked_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_
	push	esi
$LL9@unchecked_:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_
	pop	esi
$LN7@unchecked_:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00@Z ENDP ; stdext::unchecked_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>
_TEXT	ENDS
PUBLIC	??$fill@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0ABV120@@Z ; std::fill<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0ABV120@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0ABV120@@Z PROC ; std::fill<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0ABV120@@Z ENDP ; std::fill<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
_TEXT	ENDS
PUBLIC	??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z ; std::_Construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z$0
__ehfuncinfo$??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z
_TEXT	SEGMENT
$T261717 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z PROC ; std::_Construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	esi, DWORD PTR __Ptr$[esp+16]
	mov	DWORD PTR __Vptr$[esp+16], esi

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T261717[esp+20], esi
	mov	DWORD PTR __$EHRec$[esp+28], 0
	test	esi, esi
	je	SHORT $LN3@Construct@4
	push	edi
	mov	edi, DWORD PTR __Val$[esp+20]
	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], eax
	pop	edi
$LN3@Construct@4:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T261717[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z ENDP ; std::_Construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
PUBLIC	??_GCvIgnoreUnitsPathFinder@@QAEPAXI@Z		; CvIgnoreUnitsPathFinder::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvIgnoreUnitsPathFinder@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvIgnoreUnitsPathFinder@@QAEPAXI@Z PROC		; CvIgnoreUnitsPathFinder::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@30
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@30:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvIgnoreUnitsPathFinder@@QAEPAXI@Z ENDP		; CvIgnoreUnitsPathFinder::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvStepPathFinder@@QAEPAXI@Z			; CvStepPathFinder::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvStepPathFinder@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvStepPathFinder@@QAEPAXI@Z PROC			; CvStepPathFinder::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@31
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@31:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvStepPathFinder@@QAEPAXI@Z ENDP			; CvStepPathFinder::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_G_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAXI@Z ; std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_G_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAXI@Z PROC ; std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+8]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@32
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@32:
	mov	eax, esi
	pop	esi
	ret	4
??_G_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAXI@Z ENDP ; std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isVisible
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 210  : 		if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible

; 211  : 			return false;

	xor	al, al

; 214  : 	}

	ret	4
$LN1@isVisible:

; 212  : 
; 213  : 		return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [ecx+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	setg	dl
	mov	al, dl

; 214  : 	}

	ret	4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEAAPAVCvBuildingClassInfo@@XZ ; std::_Vector_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEAAPAVCvBuildingClassInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEAAPAVCvBuildingClassInfo@@XZ PROC ; std::_Vector_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBEAAPAVCvBuildingClassInfo@@XZ ENDP ; std::_Vector_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEAAPAVCvLeaderHeadInfo@@XZ ; std::_Vector_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEAAPAVCvLeaderHeadInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEAAPAVCvLeaderHeadInfo@@XZ PROC ; std::_Vector_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBEAAPAVCvLeaderHeadInfo@@XZ ENDP ; std::_Vector_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEAAPAVCvMinorCivInfo@@XZ ; std::_Vector_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEAAPAVCvMinorCivInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEAAPAVCvMinorCivInfo@@XZ PROC ; std::_Vector_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBEAAPAVCvMinorCivInfo@@XZ ENDP ; std::_Vector_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEAAPAVCvVoteSourceInfo@@XZ ; std::_Vector_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEAAPAVCvVoteSourceInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEAAPAVCvVoteSourceInfo@@XZ PROC ; std::_Vector_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBEAAPAVCvVoteSourceInfo@@XZ ENDP ; std::_Vector_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEAAPAVCvHandicapInfo@@XZ ; std::_Vector_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEAAPAVCvHandicapInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEAAPAVCvHandicapInfo@@XZ PROC ; std::_Vector_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBEAAPAVCvHandicapInfo@@XZ ENDP ; std::_Vector_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEAAPAVCvGameSpeedInfo@@XZ ; std::_Vector_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEAAPAVCvGameSpeedInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEAAPAVCvGameSpeedInfo@@XZ PROC ; std::_Vector_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBEAAPAVCvGameSpeedInfo@@XZ ENDP ; std::_Vector_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBEAAPAVCvTurnTimerInfo@@XZ ; std::_Vector_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBEAAPAVCvTurnTimerInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBEAAPAVCvTurnTimerInfo@@XZ PROC ; std::_Vector_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBEAAPAVCvTurnTimerInfo@@XZ ENDP ; std::_Vector_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEAAPAVCvVictoryInfo@@XZ ; std::_Vector_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEAAPAVCvVictoryInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEAAPAVCvVictoryInfo@@XZ PROC ; std::_Vector_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBEAAPAVCvVictoryInfo@@XZ ENDP ; std::_Vector_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEAAPAVCvSmallAwardInfo@@XZ ; std::_Vector_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEAAPAVCvSmallAwardInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEAAPAVCvSmallAwardInfo@@XZ PROC ; std::_Vector_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBEAAPAVCvSmallAwardInfo@@XZ ENDP ; std::_Vector_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEAAPAVCvHurryInfo@@XZ ; std::_Vector_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEAAPAVCvHurryInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEAAPAVCvHurryInfo@@XZ PROC ; std::_Vector_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBEAAPAVCvHurryInfo@@XZ ENDP ; std::_Vector_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEAAPAVCvProcessInfo@@XZ ; std::_Vector_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEAAPAVCvProcessInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEAAPAVCvProcessInfo@@XZ PROC ; std::_Vector_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBEAAPAVCvProcessInfo@@XZ ENDP ; std::_Vector_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEAAPAVCvVoteInfo@@XZ ; std::_Vector_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEAAPAVCvVoteInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEAAPAVCvVoteInfo@@XZ PROC ; std::_Vector_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBEAAPAVCvVoteInfo@@XZ ENDP ; std::_Vector_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEAAPAVCvColorInfo@@XZ ; std::_Vector_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEAAPAVCvColorInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEAAPAVCvColorInfo@@XZ PROC ; std::_Vector_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBEAAPAVCvColorInfo@@XZ ENDP ; std::_Vector_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEAAPAVCvPlayerColorInfo@@XZ ; std::_Vector_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEAAPAVCvPlayerColorInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEAAPAVCvPlayerColorInfo@@XZ PROC ; std::_Vector_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBEAAPAVCvPlayerColorInfo@@XZ ENDP ; std::_Vector_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEAAPAVCvInterfaceModeInfo@@XZ ; std::_Vector_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEAAPAVCvInterfaceModeInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEAAPAVCvInterfaceModeInfo@@XZ PROC ; std::_Vector_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBEAAPAVCvInterfaceModeInfo@@XZ ENDP ; std::_Vector_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEAAPAVCvRouteInfo@@XZ ; std::_Vector_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEAAPAVCvRouteInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEAAPAVCvRouteInfo@@XZ PROC ; std::_Vector_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBEAAPAVCvRouteInfo@@XZ ENDP ; std::_Vector_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEAAPAVCvEraInfo@@XZ ; std::_Vector_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEAAPAVCvEraInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEAAPAVCvEraInfo@@XZ PROC ; std::_Vector_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBEAAPAVCvEraInfo@@XZ ENDP ; std::_Vector_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEAAPAVCvBuildInfo@@XZ ; std::_Vector_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEAAPAVCvBuildInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEAAPAVCvBuildInfo@@XZ PROC ; std::_Vector_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBEAAPAVCvBuildInfo@@XZ ENDP ; std::_Vector_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEAAPAVCvUnitClassInfo@@XZ ; std::_Vector_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEAAPAVCvUnitClassInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEAAPAVCvUnitClassInfo@@XZ PROC ; std::_Vector_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBEAAPAVCvUnitClassInfo@@XZ ENDP ; std::_Vector_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEAAPAVCvSpecialUnitInfo@@XZ ; std::_Vector_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEAAPAVCvSpecialUnitInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEAAPAVCvSpecialUnitInfo@@XZ PROC ; std::_Vector_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBEAAPAVCvSpecialUnitInfo@@XZ ENDP ; std::_Vector_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEAAPAVCvSpecialistInfo@@XZ ; std::_Vector_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEAAPAVCvSpecialistInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEAAPAVCvSpecialistInfo@@XZ PROC ; std::_Vector_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBEAAPAVCvSpecialistInfo@@XZ ENDP ; std::_Vector_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEAAPAVCvActionInfo@@XZ ; std::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEAAPAVCvActionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEAAPAVCvActionInfo@@XZ PROC ; std::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEAAPAVCvActionInfo@@XZ ENDP ; std::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEAAPAVCvMissionInfo@@XZ ; std::_Vector_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEAAPAVCvMissionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEAAPAVCvMissionInfo@@XZ PROC ; std::_Vector_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBEAAPAVCvMissionInfo@@XZ ENDP ; std::_Vector_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEAAPAVCvControlInfo@@XZ ; std::_Vector_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEAAPAVCvControlInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEAAPAVCvControlInfo@@XZ PROC ; std::_Vector_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBEAAPAVCvControlInfo@@XZ ENDP ; std::_Vector_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEAAPAVCvCommandInfo@@XZ ; std::_Vector_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEAAPAVCvCommandInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEAAPAVCvCommandInfo@@XZ PROC ; std::_Vector_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBEAAPAVCvCommandInfo@@XZ ENDP ; std::_Vector_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEAAPAVCvAutomateInfo@@XZ ; std::_Vector_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEAAPAVCvAutomateInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEAAPAVCvAutomateInfo@@XZ PROC ; std::_Vector_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBEAAPAVCvAutomateInfo@@XZ ENDP ; std::_Vector_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEAAPAVCvBaseInfo@@XZ ; std::_Vector_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEAAPAVCvBaseInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEAAPAVCvBaseInfo@@XZ PROC ; std::_Vector_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBEAAPAVCvBaseInfo@@XZ ENDP ; std::_Vector_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEAAPAVCvGameOptionInfo@@XZ ; std::_Vector_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEAAPAVCvGameOptionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEAAPAVCvGameOptionInfo@@XZ PROC ; std::_Vector_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBEAAPAVCvGameOptionInfo@@XZ ENDP ; std::_Vector_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEAAPAVCvMPOptionInfo@@XZ ; std::_Vector_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEAAPAVCvMPOptionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEAAPAVCvMPOptionInfo@@XZ PROC ; std::_Vector_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBEAAPAVCvMPOptionInfo@@XZ ENDP ; std::_Vector_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEAAPAVCvPlayerOptionInfo@@XZ ; std::_Vector_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEAAPAVCvPlayerOptionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEAAPAVCvPlayerOptionInfo@@XZ PROC ; std::_Vector_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBEAAPAVCvPlayerOptionInfo@@XZ ENDP ; std::_Vector_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEAAPAVCvYieldInfo@@XZ ; std::_Vector_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEAAPAVCvYieldInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEAAPAVCvYieldInfo@@XZ PROC ; std::_Vector_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBEAAPAVCvYieldInfo@@XZ ENDP ; std::_Vector_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEAAPAVCvTerrainInfo@@XZ ; std::_Vector_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEAAPAVCvTerrainInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEAAPAVCvTerrainInfo@@XZ PROC ; std::_Vector_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBEAAPAVCvTerrainInfo@@XZ ENDP ; std::_Vector_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEAAPAVCvFeatureInfo@@XZ ; std::_Vector_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEAAPAVCvFeatureInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEAAPAVCvFeatureInfo@@XZ PROC ; std::_Vector_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBEAAPAVCvFeatureInfo@@XZ ENDP ; std::_Vector_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEAAPAVCvResourceClassInfo@@XZ ; std::_Vector_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEAAPAVCvResourceClassInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEAAPAVCvResourceClassInfo@@XZ PROC ; std::_Vector_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBEAAPAVCvResourceClassInfo@@XZ ENDP ; std::_Vector_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEAAPAVCvResourceInfo@@XZ ; std::_Vector_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEAAPAVCvResourceInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEAAPAVCvResourceInfo@@XZ PROC ; std::_Vector_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBEAAPAVCvResourceInfo@@XZ ENDP ; std::_Vector_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEAAPAVCvEntityEventInfo@@XZ ; std::_Vector_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEAAPAVCvEntityEventInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEAAPAVCvEntityEventInfo@@XZ PROC ; std::_Vector_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBEAAPAVCvEntityEventInfo@@XZ ENDP ; std::_Vector_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@PAPAVCvBuildingClassInfo@@@Z ; std::_Vector_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Vector_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@PAPAVCvBuildingClassInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@PAPAVCvBuildingClassInfo@@@Z PROC ; std::_Vector_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Vector_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@PAPAVCvBuildingClassInfo@@@Z ENDP ; std::_Vector_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Vector_iterator<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@PAPAVCvLeaderHeadInfo@@@Z ; std::_Vector_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Vector_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@PAPAVCvLeaderHeadInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@PAPAVCvLeaderHeadInfo@@@Z PROC ; std::_Vector_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Vector_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@PAPAVCvLeaderHeadInfo@@@Z ENDP ; std::_Vector_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Vector_iterator<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@PAPAVCvMinorCivInfo@@@Z ; std::_Vector_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Vector_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@PAPAVCvMinorCivInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@PAPAVCvMinorCivInfo@@@Z PROC ; std::_Vector_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Vector_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@PAPAVCvMinorCivInfo@@@Z ENDP ; std::_Vector_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Vector_iterator<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@PAPAVCvVoteSourceInfo@@@Z ; std::_Vector_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Vector_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@PAPAVCvVoteSourceInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@PAPAVCvVoteSourceInfo@@@Z PROC ; std::_Vector_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Vector_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@PAPAVCvVoteSourceInfo@@@Z ENDP ; std::_Vector_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Vector_iterator<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@PAPAVCvHandicapInfo@@@Z ; std::_Vector_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Vector_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@PAPAVCvHandicapInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@PAPAVCvHandicapInfo@@@Z PROC ; std::_Vector_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Vector_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@PAPAVCvHandicapInfo@@@Z ENDP ; std::_Vector_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Vector_iterator<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@PAPAVCvGameSpeedInfo@@@Z ; std::_Vector_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Vector_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@PAPAVCvGameSpeedInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@PAPAVCvGameSpeedInfo@@@Z PROC ; std::_Vector_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Vector_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@PAPAVCvGameSpeedInfo@@@Z ENDP ; std::_Vector_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Vector_iterator<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@PAPAVCvTurnTimerInfo@@@Z ; std::_Vector_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Vector_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@PAPAVCvTurnTimerInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@PAPAVCvTurnTimerInfo@@@Z PROC ; std::_Vector_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Vector_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@PAPAVCvTurnTimerInfo@@@Z ENDP ; std::_Vector_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Vector_iterator<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@PAPAVCvVictoryInfo@@@Z ; std::_Vector_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Vector_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@PAPAVCvVictoryInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@PAPAVCvVictoryInfo@@@Z PROC ; std::_Vector_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Vector_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@PAPAVCvVictoryInfo@@@Z ENDP ; std::_Vector_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Vector_iterator<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@PAPAVCvSmallAwardInfo@@@Z ; std::_Vector_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Vector_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@PAPAVCvSmallAwardInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@PAPAVCvSmallAwardInfo@@@Z PROC ; std::_Vector_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Vector_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@PAPAVCvSmallAwardInfo@@@Z ENDP ; std::_Vector_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Vector_iterator<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@PAPAVCvHurryInfo@@@Z ; std::_Vector_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Vector_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@PAPAVCvHurryInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@PAPAVCvHurryInfo@@@Z PROC ; std::_Vector_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Vector_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@PAPAVCvHurryInfo@@@Z ENDP ; std::_Vector_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Vector_iterator<CvHurryInfo *,std::allocator<CvHurryInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@PAPAVCvProcessInfo@@@Z ; std::_Vector_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Vector_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@PAPAVCvProcessInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@PAPAVCvProcessInfo@@@Z PROC ; std::_Vector_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Vector_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@PAPAVCvProcessInfo@@@Z ENDP ; std::_Vector_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Vector_iterator<CvProcessInfo *,std::allocator<CvProcessInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@PAPAVCvVoteInfo@@@Z ; std::_Vector_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Vector_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@PAPAVCvVoteInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@PAPAVCvVoteInfo@@@Z PROC ; std::_Vector_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Vector_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@PAPAVCvVoteInfo@@@Z ENDP ; std::_Vector_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Vector_iterator<CvVoteInfo *,std::allocator<CvVoteInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@PAPAVCvColorInfo@@@Z ; std::_Vector_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::_Vector_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@PAPAVCvColorInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@PAPAVCvColorInfo@@@Z PROC ; std::_Vector_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::_Vector_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@PAPAVCvColorInfo@@@Z ENDP ; std::_Vector_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >::_Vector_iterator<CvColorInfo *,std::allocator<CvColorInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@PAPAVCvPlayerColorInfo@@@Z ; std::_Vector_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Vector_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@PAPAVCvPlayerColorInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@PAPAVCvPlayerColorInfo@@@Z PROC ; std::_Vector_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Vector_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@PAPAVCvPlayerColorInfo@@@Z ENDP ; std::_Vector_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Vector_iterator<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@PAPAVCvInterfaceModeInfo@@@Z ; std::_Vector_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Vector_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@PAPAVCvInterfaceModeInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@PAPAVCvInterfaceModeInfo@@@Z PROC ; std::_Vector_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Vector_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@PAPAVCvInterfaceModeInfo@@@Z ENDP ; std::_Vector_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Vector_iterator<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@PAPAVCvRouteInfo@@@Z ; std::_Vector_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Vector_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@PAPAVCvRouteInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@PAPAVCvRouteInfo@@@Z PROC ; std::_Vector_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Vector_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@PAPAVCvRouteInfo@@@Z ENDP ; std::_Vector_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Vector_iterator<CvRouteInfo *,std::allocator<CvRouteInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@PAPAVCvEraInfo@@@Z ; std::_Vector_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::_Vector_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@PAPAVCvEraInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@PAPAVCvEraInfo@@@Z PROC ; std::_Vector_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::_Vector_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@PAPAVCvEraInfo@@@Z ENDP ; std::_Vector_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >::_Vector_iterator<CvEraInfo *,std::allocator<CvEraInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@PAPAVCvBuildInfo@@@Z ; std::_Vector_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Vector_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@PAPAVCvBuildInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@PAPAVCvBuildInfo@@@Z PROC ; std::_Vector_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Vector_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@PAPAVCvBuildInfo@@@Z ENDP ; std::_Vector_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Vector_iterator<CvBuildInfo *,std::allocator<CvBuildInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@PAPAVCvUnitClassInfo@@@Z ; std::_Vector_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Vector_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@PAPAVCvUnitClassInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@PAPAVCvUnitClassInfo@@@Z PROC ; std::_Vector_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Vector_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@PAPAVCvUnitClassInfo@@@Z ENDP ; std::_Vector_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Vector_iterator<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@PAPAVCvSpecialUnitInfo@@@Z ; std::_Vector_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Vector_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@PAPAVCvSpecialUnitInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@PAPAVCvSpecialUnitInfo@@@Z PROC ; std::_Vector_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Vector_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@PAPAVCvSpecialUnitInfo@@@Z ENDP ; std::_Vector_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Vector_iterator<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@PAPAVCvSpecialistInfo@@@Z ; std::_Vector_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Vector_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@PAPAVCvSpecialistInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@PAPAVCvSpecialistInfo@@@Z PROC ; std::_Vector_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Vector_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@PAPAVCvSpecialistInfo@@@Z ENDP ; std::_Vector_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Vector_iterator<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z ; std::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z PROC ; std::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z ENDP ; std::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@PAPAVCvMissionInfo@@@Z ; std::_Vector_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Vector_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@PAPAVCvMissionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@PAPAVCvMissionInfo@@@Z PROC ; std::_Vector_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Vector_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@PAPAVCvMissionInfo@@@Z ENDP ; std::_Vector_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Vector_iterator<CvMissionInfo *,std::allocator<CvMissionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@PAPAVCvControlInfo@@@Z ; std::_Vector_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::_Vector_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@PAPAVCvControlInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@PAPAVCvControlInfo@@@Z PROC ; std::_Vector_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::_Vector_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@PAPAVCvControlInfo@@@Z ENDP ; std::_Vector_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >::_Vector_iterator<CvControlInfo *,std::allocator<CvControlInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@PAPAVCvCommandInfo@@@Z ; std::_Vector_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Vector_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@PAPAVCvCommandInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@PAPAVCvCommandInfo@@@Z PROC ; std::_Vector_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Vector_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@PAPAVCvCommandInfo@@@Z ENDP ; std::_Vector_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Vector_iterator<CvCommandInfo *,std::allocator<CvCommandInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@PAPAVCvAutomateInfo@@@Z ; std::_Vector_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Vector_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@PAPAVCvAutomateInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@PAPAVCvAutomateInfo@@@Z PROC ; std::_Vector_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Vector_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@PAPAVCvAutomateInfo@@@Z ENDP ; std::_Vector_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Vector_iterator<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@PAPAVCvBaseInfo@@@Z ; std::_Vector_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Vector_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@PAPAVCvBaseInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@PAPAVCvBaseInfo@@@Z PROC ; std::_Vector_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Vector_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@PAPAVCvBaseInfo@@@Z ENDP ; std::_Vector_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Vector_iterator<CvBaseInfo *,std::allocator<CvBaseInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@PAPAVCvGameOptionInfo@@@Z ; std::_Vector_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Vector_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@PAPAVCvGameOptionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@PAPAVCvGameOptionInfo@@@Z PROC ; std::_Vector_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Vector_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@PAPAVCvGameOptionInfo@@@Z ENDP ; std::_Vector_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Vector_iterator<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@PAPAVCvMPOptionInfo@@@Z ; std::_Vector_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Vector_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@PAPAVCvMPOptionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@PAPAVCvMPOptionInfo@@@Z PROC ; std::_Vector_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Vector_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@PAPAVCvMPOptionInfo@@@Z ENDP ; std::_Vector_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Vector_iterator<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@PAPAVCvPlayerOptionInfo@@@Z ; std::_Vector_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Vector_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@PAPAVCvPlayerOptionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@PAPAVCvPlayerOptionInfo@@@Z PROC ; std::_Vector_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Vector_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@PAPAVCvPlayerOptionInfo@@@Z ENDP ; std::_Vector_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Vector_iterator<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@PAPAVCvYieldInfo@@@Z ; std::_Vector_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Vector_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@PAPAVCvYieldInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@PAPAVCvYieldInfo@@@Z PROC ; std::_Vector_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Vector_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@PAPAVCvYieldInfo@@@Z ENDP ; std::_Vector_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Vector_iterator<CvYieldInfo *,std::allocator<CvYieldInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@PAPAVCvTerrainInfo@@@Z ; std::_Vector_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Vector_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@PAPAVCvTerrainInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@PAPAVCvTerrainInfo@@@Z PROC ; std::_Vector_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Vector_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@PAPAVCvTerrainInfo@@@Z ENDP ; std::_Vector_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Vector_iterator<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@PAPAVCvFeatureInfo@@@Z ; std::_Vector_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Vector_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@PAPAVCvFeatureInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@PAPAVCvFeatureInfo@@@Z PROC ; std::_Vector_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Vector_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@PAPAVCvFeatureInfo@@@Z ENDP ; std::_Vector_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Vector_iterator<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@PAPAVCvResourceClassInfo@@@Z ; std::_Vector_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Vector_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@PAPAVCvResourceClassInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@PAPAVCvResourceClassInfo@@@Z PROC ; std::_Vector_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Vector_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@PAPAVCvResourceClassInfo@@@Z ENDP ; std::_Vector_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Vector_iterator<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@PAPAVCvResourceInfo@@@Z ; std::_Vector_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Vector_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@PAPAVCvResourceInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@PAPAVCvResourceInfo@@@Z PROC ; std::_Vector_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Vector_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@PAPAVCvResourceInfo@@@Z ENDP ; std::_Vector_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Vector_iterator<CvResourceInfo *,std::allocator<CvResourceInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@PAPAVCvEntityEventInfo@@@Z ; std::_Vector_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Vector_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@PAPAVCvEntityEventInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@PAPAVCvEntityEventInfo@@@Z PROC ; std::_Vector_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Vector_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@PAPAVCvEntityEventInfo@@@Z ENDP ; std::_Vector_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Vector_iterator<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@@Z ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@@Z PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@@Z ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@@Z ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@@Z PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@@Z ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@@Z ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@@Z PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@@Z ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@@Z ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@@Z PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@@Z ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@@Z ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@@Z PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@@Z ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@@Z ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@@Z PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@@Z ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@@Z ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@@Z PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@@Z ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@@Z ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@@Z PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@@Z ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@@Z ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@@Z PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@@Z ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@@Z ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@@Z PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@@Z ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@@Z ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@@Z PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@@Z ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@@Z ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@@Z PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@@Z ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@@Z ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@@Z PROC ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@@Z ENDP ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@@Z ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@@Z PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@@Z ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@@Z ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@@Z PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@@Z ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@@Z ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@@Z PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@@Z ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@@Z ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@@Z PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@@Z ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@@Z ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@@Z PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@@Z ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@@Z ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@@Z PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@@Z ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@@Z ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@@Z PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@@Z ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@@Z ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@@Z PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@@Z ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@@Z ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@@Z PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@@Z ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@@Z ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@@Z PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@@Z ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@@Z ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@@Z PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@@Z ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@@Z ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@@Z PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@@Z ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@@Z ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@@Z PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@@Z ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@@Z ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@@Z PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@@Z ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@@Z ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@@Z PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@@Z ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@@Z ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@@Z PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@@Z ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@@Z ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@@Z PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@@Z ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@@Z ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@@Z PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@@Z ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@@Z ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@@Z PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@@Z ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@@Z ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@@Z PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@@Z ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@@Z ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@@Z PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@@Z ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@@Z ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@@Z PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@@Z ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@@Z ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@@Z PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@@Z ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@@Z ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@@Z PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@@Z ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@Urandom_access_iterator_tag@3@U_Undefined_move_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_backward_opt@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@Urandom_access_iterator_tag@3@U_Undefined_move_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@Urandom_access_iterator_tag@3@U_Undefined_move_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@Urandom_access_iterator_tag@3@U_Undefined_move_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvInterfaceModeInfo@@PAPAV1@@stdext@@YAPAPAVCvInterfaceModeInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvInterfaceModeInfo * *,CvInterfaceModeInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvInterfaceModeInfo@@PAPAV1@@stdext@@YAPAPAVCvInterfaceModeInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvInterfaceModeInfo@@PAPAV1@@stdext@@YAPAPAVCvInterfaceModeInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvInterfaceModeInfo * *,CvInterfaceModeInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvInterfaceModeInfo@@PAPAV1@@stdext@@YAPAPAVCvInterfaceModeInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvInterfaceModeInfo * *,CvInterfaceModeInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvColorInfo@@PAPAV1@@stdext@@YAPAPAVCvColorInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvColorInfo * *,CvColorInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvColorInfo@@PAPAV1@@stdext@@YAPAPAVCvColorInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvColorInfo@@PAPAV1@@stdext@@YAPAPAVCvColorInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvColorInfo * *,CvColorInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvColorInfo@@PAPAV1@@stdext@@YAPAPAVCvColorInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvColorInfo * *,CvColorInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvPlayerColorInfo@@PAPAV1@@stdext@@YAPAPAVCvPlayerColorInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvPlayerColorInfo * *,CvPlayerColorInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvPlayerColorInfo@@PAPAV1@@stdext@@YAPAPAVCvPlayerColorInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvPlayerColorInfo@@PAPAV1@@stdext@@YAPAPAVCvPlayerColorInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvPlayerColorInfo * *,CvPlayerColorInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@4
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@4:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvPlayerColorInfo@@PAPAV1@@stdext@@YAPAPAVCvPlayerColorInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvPlayerColorInfo * *,CvPlayerColorInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvTerrainInfo@@PAPAV1@@stdext@@YAPAPAVCvTerrainInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvTerrainInfo * *,CvTerrainInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvTerrainInfo@@PAPAV1@@stdext@@YAPAPAVCvTerrainInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvTerrainInfo@@PAPAV1@@stdext@@YAPAPAVCvTerrainInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvTerrainInfo * *,CvTerrainInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@5
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvTerrainInfo@@PAPAV1@@stdext@@YAPAPAVCvTerrainInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvTerrainInfo * *,CvTerrainInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvYieldInfo@@PAPAV1@@stdext@@YAPAPAVCvYieldInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvYieldInfo * *,CvYieldInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvYieldInfo@@PAPAV1@@stdext@@YAPAPAVCvYieldInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvYieldInfo@@PAPAV1@@stdext@@YAPAPAVCvYieldInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvYieldInfo * *,CvYieldInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@6
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@6:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvYieldInfo@@PAPAV1@@stdext@@YAPAPAVCvYieldInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvYieldInfo * *,CvYieldInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvRouteInfo@@PAPAV1@@stdext@@YAPAPAVCvRouteInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvRouteInfo * *,CvRouteInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvRouteInfo@@PAPAV1@@stdext@@YAPAPAVCvRouteInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvRouteInfo@@PAPAV1@@stdext@@YAPAPAVCvRouteInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvRouteInfo * *,CvRouteInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@7
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@7:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvRouteInfo@@PAPAV1@@stdext@@YAPAPAVCvRouteInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvRouteInfo * *,CvRouteInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvFeatureInfo@@PAPAV1@@stdext@@YAPAPAVCvFeatureInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvFeatureInfo * *,CvFeatureInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvFeatureInfo@@PAPAV1@@stdext@@YAPAPAVCvFeatureInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvFeatureInfo@@PAPAV1@@stdext@@YAPAPAVCvFeatureInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvFeatureInfo * *,CvFeatureInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@8
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@8:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvFeatureInfo@@PAPAV1@@stdext@@YAPAPAVCvFeatureInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvFeatureInfo * *,CvFeatureInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvResourceClassInfo@@PAPAV1@@stdext@@YAPAPAVCvResourceClassInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvResourceClassInfo * *,CvResourceClassInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvResourceClassInfo@@PAPAV1@@stdext@@YAPAPAVCvResourceClassInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvResourceClassInfo@@PAPAV1@@stdext@@YAPAPAVCvResourceClassInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvResourceClassInfo * *,CvResourceClassInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@9
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@9:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvResourceClassInfo@@PAPAV1@@stdext@@YAPAPAVCvResourceClassInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvResourceClassInfo * *,CvResourceClassInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvResourceInfo@@PAPAV1@@stdext@@YAPAPAVCvResourceInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvResourceInfo * *,CvResourceInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvResourceInfo@@PAPAV1@@stdext@@YAPAPAVCvResourceInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvResourceInfo@@PAPAV1@@stdext@@YAPAPAVCvResourceInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvResourceInfo * *,CvResourceInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@10
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@10:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvResourceInfo@@PAPAV1@@stdext@@YAPAPAVCvResourceInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvResourceInfo * *,CvResourceInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvBuildInfo@@PAPAV1@@stdext@@YAPAPAVCvBuildInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvBuildInfo * *,CvBuildInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvBuildInfo@@PAPAV1@@stdext@@YAPAPAVCvBuildInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvBuildInfo@@PAPAV1@@stdext@@YAPAPAVCvBuildInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvBuildInfo * *,CvBuildInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@11
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@11:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvBuildInfo@@PAPAV1@@stdext@@YAPAPAVCvBuildInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvBuildInfo * *,CvBuildInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvHandicapInfo@@PAPAV1@@stdext@@YAPAPAVCvHandicapInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvHandicapInfo * *,CvHandicapInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvHandicapInfo@@PAPAV1@@stdext@@YAPAPAVCvHandicapInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvHandicapInfo@@PAPAV1@@stdext@@YAPAPAVCvHandicapInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvHandicapInfo * *,CvHandicapInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@12
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@12:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvHandicapInfo@@PAPAV1@@stdext@@YAPAPAVCvHandicapInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvHandicapInfo * *,CvHandicapInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvGameSpeedInfo@@PAPAV1@@stdext@@YAPAPAVCvGameSpeedInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvGameSpeedInfo * *,CvGameSpeedInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvGameSpeedInfo@@PAPAV1@@stdext@@YAPAPAVCvGameSpeedInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvGameSpeedInfo@@PAPAV1@@stdext@@YAPAPAVCvGameSpeedInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvGameSpeedInfo * *,CvGameSpeedInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@13
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@13:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvGameSpeedInfo@@PAPAV1@@stdext@@YAPAPAVCvGameSpeedInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvGameSpeedInfo * *,CvGameSpeedInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvTurnTimerInfo@@PAPAV1@@stdext@@YAPAPAVCvTurnTimerInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvTurnTimerInfo * *,CvTurnTimerInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvTurnTimerInfo@@PAPAV1@@stdext@@YAPAPAVCvTurnTimerInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvTurnTimerInfo@@PAPAV1@@stdext@@YAPAPAVCvTurnTimerInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvTurnTimerInfo * *,CvTurnTimerInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@14
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@14:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvTurnTimerInfo@@PAPAV1@@stdext@@YAPAPAVCvTurnTimerInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvTurnTimerInfo * *,CvTurnTimerInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvCivilizationInfo@@PAPAV1@@stdext@@YAPAPAVCvCivilizationInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCivilizationInfo * *,CvCivilizationInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvCivilizationInfo@@PAPAV1@@stdext@@YAPAPAVCvCivilizationInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvCivilizationInfo@@PAPAV1@@stdext@@YAPAPAVCvCivilizationInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvCivilizationInfo * *,CvCivilizationInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@15
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@15:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvCivilizationInfo@@PAPAV1@@stdext@@YAPAPAVCvCivilizationInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvCivilizationInfo * *,CvCivilizationInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvMinorCivInfo@@PAPAV1@@stdext@@YAPAPAVCvMinorCivInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvMinorCivInfo * *,CvMinorCivInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvMinorCivInfo@@PAPAV1@@stdext@@YAPAPAVCvMinorCivInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvMinorCivInfo@@PAPAV1@@stdext@@YAPAPAVCvMinorCivInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvMinorCivInfo * *,CvMinorCivInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@16
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@16:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvMinorCivInfo@@PAPAV1@@stdext@@YAPAPAVCvMinorCivInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvMinorCivInfo * *,CvMinorCivInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvLeaderHeadInfo@@PAPAV1@@stdext@@YAPAPAVCvLeaderHeadInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvLeaderHeadInfo * *,CvLeaderHeadInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvLeaderHeadInfo@@PAPAV1@@stdext@@YAPAPAVCvLeaderHeadInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvLeaderHeadInfo@@PAPAV1@@stdext@@YAPAPAVCvLeaderHeadInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvLeaderHeadInfo * *,CvLeaderHeadInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@17
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@17:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvLeaderHeadInfo@@PAPAV1@@stdext@@YAPAPAVCvLeaderHeadInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvLeaderHeadInfo * *,CvLeaderHeadInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvProcessInfo@@PAPAV1@@stdext@@YAPAPAVCvProcessInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvProcessInfo * *,CvProcessInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvProcessInfo@@PAPAV1@@stdext@@YAPAPAVCvProcessInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvProcessInfo@@PAPAV1@@stdext@@YAPAPAVCvProcessInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvProcessInfo * *,CvProcessInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@18
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@18:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvProcessInfo@@PAPAV1@@stdext@@YAPAPAVCvProcessInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvProcessInfo * *,CvProcessInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvVoteInfo@@PAPAV1@@stdext@@YAPAPAVCvVoteInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvVoteInfo * *,CvVoteInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvVoteInfo@@PAPAV1@@stdext@@YAPAPAVCvVoteInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvVoteInfo@@PAPAV1@@stdext@@YAPAPAVCvVoteInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvVoteInfo * *,CvVoteInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@19
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@19:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvVoteInfo@@PAPAV1@@stdext@@YAPAPAVCvVoteInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvVoteInfo * *,CvVoteInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvBuildingClassInfo@@PAPAV1@@stdext@@YAPAPAVCvBuildingClassInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvBuildingClassInfo * *,CvBuildingClassInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvBuildingClassInfo@@PAPAV1@@stdext@@YAPAPAVCvBuildingClassInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvBuildingClassInfo@@PAPAV1@@stdext@@YAPAPAVCvBuildingClassInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvBuildingClassInfo * *,CvBuildingClassInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@20
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@20:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvBuildingClassInfo@@PAPAV1@@stdext@@YAPAPAVCvBuildingClassInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvBuildingClassInfo * *,CvBuildingClassInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvUnitClassInfo@@PAPAV1@@stdext@@YAPAPAVCvUnitClassInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvUnitClassInfo * *,CvUnitClassInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvUnitClassInfo@@PAPAV1@@stdext@@YAPAPAVCvUnitClassInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvUnitClassInfo@@PAPAV1@@stdext@@YAPAPAVCvUnitClassInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvUnitClassInfo * *,CvUnitClassInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@21
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@21:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvUnitClassInfo@@PAPAV1@@stdext@@YAPAPAVCvUnitClassInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvUnitClassInfo * *,CvUnitClassInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvSpecialUnitInfo@@PAPAV1@@stdext@@YAPAPAVCvSpecialUnitInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvSpecialUnitInfo * *,CvSpecialUnitInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvSpecialUnitInfo@@PAPAV1@@stdext@@YAPAPAVCvSpecialUnitInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvSpecialUnitInfo@@PAPAV1@@stdext@@YAPAPAVCvSpecialUnitInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvSpecialUnitInfo * *,CvSpecialUnitInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@22
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@22:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvSpecialUnitInfo@@PAPAV1@@stdext@@YAPAPAVCvSpecialUnitInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvSpecialUnitInfo * *,CvSpecialUnitInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvVoteSourceInfo@@PAPAV1@@stdext@@YAPAPAVCvVoteSourceInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvVoteSourceInfo * *,CvVoteSourceInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvVoteSourceInfo@@PAPAV1@@stdext@@YAPAPAVCvVoteSourceInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvVoteSourceInfo@@PAPAV1@@stdext@@YAPAPAVCvVoteSourceInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvVoteSourceInfo * *,CvVoteSourceInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@23
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@23:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvVoteSourceInfo@@PAPAV1@@stdext@@YAPAPAVCvVoteSourceInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvVoteSourceInfo * *,CvVoteSourceInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvBaseInfo@@PAPAV1@@stdext@@YAPAPAVCvBaseInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvBaseInfo * *,CvBaseInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvBaseInfo@@PAPAV1@@stdext@@YAPAPAVCvBaseInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvBaseInfo@@PAPAV1@@stdext@@YAPAPAVCvBaseInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvBaseInfo * *,CvBaseInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@24
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@24:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvBaseInfo@@PAPAV1@@stdext@@YAPAPAVCvBaseInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvBaseInfo * *,CvBaseInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvGameOptionInfo@@PAPAV1@@stdext@@YAPAPAVCvGameOptionInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvGameOptionInfo * *,CvGameOptionInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvGameOptionInfo@@PAPAV1@@stdext@@YAPAPAVCvGameOptionInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvGameOptionInfo@@PAPAV1@@stdext@@YAPAPAVCvGameOptionInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvGameOptionInfo * *,CvGameOptionInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@25
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@25:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvGameOptionInfo@@PAPAV1@@stdext@@YAPAPAVCvGameOptionInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvGameOptionInfo * *,CvGameOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvMPOptionInfo@@PAPAV1@@stdext@@YAPAPAVCvMPOptionInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvMPOptionInfo * *,CvMPOptionInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvMPOptionInfo@@PAPAV1@@stdext@@YAPAPAVCvMPOptionInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvMPOptionInfo@@PAPAV1@@stdext@@YAPAPAVCvMPOptionInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvMPOptionInfo * *,CvMPOptionInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@26
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@26:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvMPOptionInfo@@PAPAV1@@stdext@@YAPAPAVCvMPOptionInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvMPOptionInfo * *,CvMPOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvPlayerOptionInfo@@PAPAV1@@stdext@@YAPAPAVCvPlayerOptionInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvPlayerOptionInfo * *,CvPlayerOptionInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvPlayerOptionInfo@@PAPAV1@@stdext@@YAPAPAVCvPlayerOptionInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvPlayerOptionInfo@@PAPAV1@@stdext@@YAPAPAVCvPlayerOptionInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvPlayerOptionInfo * *,CvPlayerOptionInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@27
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@27:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvPlayerOptionInfo@@PAPAV1@@stdext@@YAPAPAVCvPlayerOptionInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvPlayerOptionInfo * *,CvPlayerOptionInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvSpecialistInfo@@PAPAV1@@stdext@@YAPAPAVCvSpecialistInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvSpecialistInfo * *,CvSpecialistInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvSpecialistInfo@@PAPAV1@@stdext@@YAPAPAVCvSpecialistInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvSpecialistInfo@@PAPAV1@@stdext@@YAPAPAVCvSpecialistInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvSpecialistInfo * *,CvSpecialistInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@28
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@28:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvSpecialistInfo@@PAPAV1@@stdext@@YAPAPAVCvSpecialistInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvSpecialistInfo * *,CvSpecialistInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvActionInfo@@PAPAV1@@stdext@@YAPAPAVCvActionInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvActionInfo * *,CvActionInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvActionInfo@@PAPAV1@@stdext@@YAPAPAVCvActionInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvActionInfo@@PAPAV1@@stdext@@YAPAPAVCvActionInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvActionInfo * *,CvActionInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@29
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@29:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvActionInfo@@PAPAV1@@stdext@@YAPAPAVCvActionInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvActionInfo * *,CvActionInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvMissionInfo@@PAPAV1@@stdext@@YAPAPAVCvMissionInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvMissionInfo * *,CvMissionInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvMissionInfo@@PAPAV1@@stdext@@YAPAPAVCvMissionInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvMissionInfo@@PAPAV1@@stdext@@YAPAPAVCvMissionInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvMissionInfo * *,CvMissionInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@30
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@30:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvMissionInfo@@PAPAV1@@stdext@@YAPAPAVCvMissionInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvMissionInfo * *,CvMissionInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvControlInfo@@PAPAV1@@stdext@@YAPAPAVCvControlInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvControlInfo * *,CvControlInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvControlInfo@@PAPAV1@@stdext@@YAPAPAVCvControlInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvControlInfo@@PAPAV1@@stdext@@YAPAPAVCvControlInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvControlInfo * *,CvControlInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@31
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@31:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvControlInfo@@PAPAV1@@stdext@@YAPAPAVCvControlInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvControlInfo * *,CvControlInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvCommandInfo@@PAPAV1@@stdext@@YAPAPAVCvCommandInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCommandInfo * *,CvCommandInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvCommandInfo@@PAPAV1@@stdext@@YAPAPAVCvCommandInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvCommandInfo@@PAPAV1@@stdext@@YAPAPAVCvCommandInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvCommandInfo * *,CvCommandInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@32
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@32:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvCommandInfo@@PAPAV1@@stdext@@YAPAPAVCvCommandInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvCommandInfo * *,CvCommandInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvAutomateInfo@@PAPAV1@@stdext@@YAPAPAVCvAutomateInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvAutomateInfo * *,CvAutomateInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvAutomateInfo@@PAPAV1@@stdext@@YAPAPAVCvAutomateInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvAutomateInfo@@PAPAV1@@stdext@@YAPAPAVCvAutomateInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvAutomateInfo * *,CvAutomateInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@33
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@33:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvAutomateInfo@@PAPAV1@@stdext@@YAPAPAVCvAutomateInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvAutomateInfo * *,CvAutomateInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvEraInfo@@PAPAV1@@stdext@@YAPAPAVCvEraInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvEraInfo * *,CvEraInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvEraInfo@@PAPAV1@@stdext@@YAPAPAVCvEraInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvEraInfo@@PAPAV1@@stdext@@YAPAPAVCvEraInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvEraInfo * *,CvEraInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@34
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@34:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvEraInfo@@PAPAV1@@stdext@@YAPAPAVCvEraInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvEraInfo * *,CvEraInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvHurryInfo@@PAPAV1@@stdext@@YAPAPAVCvHurryInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvHurryInfo * *,CvHurryInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvHurryInfo@@PAPAV1@@stdext@@YAPAPAVCvHurryInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvHurryInfo@@PAPAV1@@stdext@@YAPAPAVCvHurryInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvHurryInfo * *,CvHurryInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@35
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@35:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvHurryInfo@@PAPAV1@@stdext@@YAPAPAVCvHurryInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvHurryInfo * *,CvHurryInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvVictoryInfo@@PAPAV1@@stdext@@YAPAPAVCvVictoryInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvVictoryInfo * *,CvVictoryInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvVictoryInfo@@PAPAV1@@stdext@@YAPAPAVCvVictoryInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvVictoryInfo@@PAPAV1@@stdext@@YAPAPAVCvVictoryInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvVictoryInfo * *,CvVictoryInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@36
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@36:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvVictoryInfo@@PAPAV1@@stdext@@YAPAPAVCvVictoryInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvVictoryInfo * *,CvVictoryInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvSmallAwardInfo@@PAPAV1@@stdext@@YAPAPAVCvSmallAwardInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvSmallAwardInfo * *,CvSmallAwardInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvSmallAwardInfo@@PAPAV1@@stdext@@YAPAPAVCvSmallAwardInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvSmallAwardInfo@@PAPAV1@@stdext@@YAPAPAVCvSmallAwardInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvSmallAwardInfo * *,CvSmallAwardInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@37
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@37:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvSmallAwardInfo@@PAPAV1@@stdext@@YAPAPAVCvSmallAwardInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvSmallAwardInfo * *,CvSmallAwardInfo * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvEntityEventInfo@@PAPAV1@@stdext@@YAPAPAVCvEntityEventInfo@@PAPAV1@00@Z ; stdext::unchecked_copy<CvEntityEventInfo * *,CvEntityEventInfo * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvEntityEventInfo@@PAPAV1@@stdext@@YAPAPAVCvEntityEventInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvEntityEventInfo@@PAPAV1@@stdext@@YAPAPAVCvEntityEventInfo@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvEntityEventInfo * *,CvEntityEventInfo * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@38
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@38:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvEntityEventInfo@@PAPAV1@@stdext@@YAPAPAVCvEntityEventInfo@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvEntityEventInfo * *,CvEntityEventInfo * *>
_TEXT	ENDS
PUBLIC	??_GCvBaseInfo@@QAEPAXI@Z			; CvBaseInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvBaseInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvBaseInfo@@QAEPAXI@Z PROC				; CvBaseInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@33
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@33:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvBaseInfo@@QAEPAXI@Z ENDP				; CvBaseInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvGameOptionInfo@@QAEPAXI@Z			; CvGameOptionInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvGameOptionInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvGameOptionInfo@@QAEPAXI@Z PROC			; CvGameOptionInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@34
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@34:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvGameOptionInfo@@QAEPAXI@Z ENDP			; CvGameOptionInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvMPOptionInfo@@QAEPAXI@Z			; CvMPOptionInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvMPOptionInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvMPOptionInfo@@QAEPAXI@Z PROC			; CvMPOptionInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@35
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@35:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvMPOptionInfo@@QAEPAXI@Z ENDP			; CvMPOptionInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvPlayerOptionInfo@@QAEPAXI@Z		; CvPlayerOptionInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvPlayerOptionInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvPlayerOptionInfo@@QAEPAXI@Z PROC			; CvPlayerOptionInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@36
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@36:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvPlayerOptionInfo@@QAEPAXI@Z ENDP			; CvPlayerOptionInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvYieldInfo@@QAEPAXI@Z			; CvYieldInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvYieldInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvYieldInfo@@QAEPAXI@Z PROC				; CvYieldInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@37
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@37:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvYieldInfo@@QAEPAXI@Z ENDP				; CvYieldInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvResourceClassInfo@@QAEPAXI@Z		; CvResourceClassInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvResourceClassInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvResourceClassInfo@@QAEPAXI@Z PROC			; CvResourceClassInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@38
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@38:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvResourceClassInfo@@QAEPAXI@Z ENDP			; CvResourceClassInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CvTurnTimerInfo@@QAE@XZ			; CvTurnTimerInfo::~CvTurnTimerInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvTurnTimerInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvTurnTimerInfo@@QAE@XZ PROC				; CvTurnTimerInfo::~CvTurnTimerInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvTurnTimerInfo@@QAE@XZ ENDP				; CvTurnTimerInfo::~CvTurnTimerInfo
_TEXT	ENDS
PUBLIC	??1CvHurryInfo@@QAE@XZ				; CvHurryInfo::~CvHurryInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvHurryInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvHurryInfo@@QAE@XZ PROC				; CvHurryInfo::~CvHurryInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvHurryInfo@@QAE@XZ ENDP				; CvHurryInfo::~CvHurryInfo
_TEXT	ENDS
PUBLIC	??1CvColorInfo@@QAE@XZ				; CvColorInfo::~CvColorInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvColorInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvColorInfo@@QAE@XZ PROC				; CvColorInfo::~CvColorInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvColorInfo@@QAE@XZ ENDP				; CvColorInfo::~CvColorInfo
_TEXT	ENDS
PUBLIC	??1CvPlayerColorInfo@@QAE@XZ			; CvPlayerColorInfo::~CvPlayerColorInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvPlayerColorInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvPlayerColorInfo@@QAE@XZ PROC			; CvPlayerColorInfo::~CvPlayerColorInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvPlayerColorInfo@@QAE@XZ ENDP			; CvPlayerColorInfo::~CvPlayerColorInfo
_TEXT	ENDS
PUBLIC	??1CvInterfaceModeInfo@@QAE@XZ			; CvInterfaceModeInfo::~CvInterfaceModeInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvInterfaceModeInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvInterfaceModeInfo@@QAE@XZ PROC			; CvInterfaceModeInfo::~CvInterfaceModeInfo, COMDAT
; _this$ = ecx
	jmp	??1CvHotKeyInfo@@QAE@XZ
??1CvInterfaceModeInfo@@QAE@XZ ENDP			; CvInterfaceModeInfo::~CvInterfaceModeInfo
_TEXT	ENDS
PUBLIC	??1CvUnitClassInfo@@QAE@XZ			; CvUnitClassInfo::~CvUnitClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvUnitClassInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvUnitClassInfo@@QAE@XZ PROC				; CvUnitClassInfo::~CvUnitClassInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvUnitClassInfo@@QAE@XZ ENDP				; CvUnitClassInfo::~CvUnitClassInfo
_TEXT	ENDS
PUBLIC	??1CvMissionInfo@@QAE@XZ			; CvMissionInfo::~CvMissionInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvMissionInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvMissionInfo@@QAE@XZ$0
__ehfuncinfo$??1CvMissionInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvMissionInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvMissionInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvMissionInfo@@QAE@XZ PROC				; CvMissionInfo::~CvMissionInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvMissionInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+472]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvHotKeyInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvMissionInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvHotKeyInfo@@QAE@XZ
__ehhandler$??1CvMissionInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvMissionInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvMissionInfo@@QAE@XZ ENDP				; CvMissionInfo::~CvMissionInfo
PUBLIC	??1CvControlInfo@@QAE@XZ			; CvControlInfo::~CvControlInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvControlInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvControlInfo@@QAE@XZ PROC				; CvControlInfo::~CvControlInfo, COMDAT
; _this$ = ecx
	jmp	??1CvHotKeyInfo@@QAE@XZ
??1CvControlInfo@@QAE@XZ ENDP				; CvControlInfo::~CvControlInfo
_TEXT	ENDS
PUBLIC	??1CvCommandInfo@@QAE@XZ			; CvCommandInfo::~CvCommandInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvCommandInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvCommandInfo@@QAE@XZ PROC				; CvCommandInfo::~CvCommandInfo, COMDAT
; _this$ = ecx
	jmp	??1CvHotKeyInfo@@QAE@XZ
??1CvCommandInfo@@QAE@XZ ENDP				; CvCommandInfo::~CvCommandInfo
_TEXT	ENDS
PUBLIC	??1CvAutomateInfo@@QAE@XZ			; CvAutomateInfo::~CvAutomateInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvAutomateInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvAutomateInfo@@QAE@XZ PROC				; CvAutomateInfo::~CvAutomateInfo, COMDAT
; _this$ = ecx
	jmp	??1CvHotKeyInfo@@QAE@XZ
??1CvAutomateInfo@@QAE@XZ ENDP				; CvAutomateInfo::~CvAutomateInfo
_TEXT	ENDS
PUBLIC	?construct@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@ABV342@@Z ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@ABV342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@ABV342@@Z PROC ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@3:

; 156  : 		}

	ret	8
?construct@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@ABV342@@Z ENDP ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z PROC ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ENDP ; std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >::destroy
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::~_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::~_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::~_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@@Z ; std::allocator<enum AnimationPathTypes>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@@Z PROC ; std::allocator<enum AnimationPathTypes>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@@Z ENDP ; std::allocator<enum AnimationPathTypes>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop
	push	esi
$LL6@Uninit_cop:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop:
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop
	pop	esi
$LN4@Uninit_cop:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	?init@CvGlobals@@QAEXXZ				; CvGlobals::init
EXTRN	??0CvTwoLayerPathFinder@@QAE@XZ:PROC		; CvTwoLayerPathFinder::CvTwoLayerPathFinder
EXTRN	?initStatics@CvTeam@@SAXXZ:PROC			; CvTeam::initStatics
EXTRN	?initStatics@CvPlayerAI@@SAXXZ:PROC		; CvPlayerAI::initStatics
EXTRN	__imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z:PROC
EXTRN	??0CvNotificationXMLEntries@@QAE@XZ:PROC	; CvNotificationXMLEntries::CvNotificationXMLEntries
EXTRN	??0CvResolutionXMLEntries@@QAE@XZ:PROC		; CvResolutionXMLEntries::CvResolutionXMLEntries
EXTRN	??0CvLeagueProjectRewardXMLEntries@@QAE@XZ:PROC	; CvLeagueProjectRewardXMLEntries::CvLeagueProjectRewardXMLEntries
EXTRN	??0CvLeagueProjectXMLEntries@@QAE@XZ:PROC	; CvLeagueProjectXMLEntries::CvLeagueProjectXMLEntries
EXTRN	??0CvLeagueNameXMLEntries@@QAE@XZ:PROC		; CvLeagueNameXMLEntries::CvLeagueNameXMLEntries
EXTRN	??0CvLeagueSpecialSessionXMLEntries@@QAE@XZ:PROC ; CvLeagueSpecialSessionXMLEntries::CvLeagueSpecialSessionXMLEntries
EXTRN	??0CvBeliefXMLEntries@@QAE@XZ:PROC		; CvBeliefXMLEntries::CvBeliefXMLEntries
EXTRN	??0CvReligionXMLEntries@@QAE@XZ:PROC		; CvReligionXMLEntries::CvReligionXMLEntries
EXTRN	??0CvTraitXMLEntries@@QAE@XZ:PROC		; CvTraitXMLEntries::CvTraitXMLEntries
EXTRN	??0CvEmphasisXMLEntries@@QAE@XZ:PROC		; CvEmphasisXMLEntries::CvEmphasisXMLEntries
EXTRN	??0CvImprovementXMLEntries@@QAE@XZ:PROC		; CvImprovementXMLEntries::CvImprovementXMLEntries
EXTRN	??0CvPromotionXMLEntries@@QAE@XZ:PROC		; CvPromotionXMLEntries::CvPromotionXMLEntries
EXTRN	??0CvProjectXMLEntries@@QAE@XZ:PROC		; CvProjectXMLEntries::CvProjectXMLEntries
EXTRN	??0CvUnitXMLEntries@@QAE@XZ:PROC		; CvUnitXMLEntries::CvUnitXMLEntries
EXTRN	??0CvBuildingXMLEntries@@QAE@XZ:PROC		; CvBuildingXMLEntries::CvBuildingXMLEntries
EXTRN	??0CvTechXMLEntries@@QAE@XZ:PROC		; CvTechXMLEntries::CvTechXMLEntries
EXTRN	??0CvPolicyXMLEntries@@QAE@XZ:PROC		; CvPolicyXMLEntries::CvPolicyXMLEntries
EXTRN	??0CvAICityStrategies@@QAE@XZ:PROC		; CvAICityStrategies::CvAICityStrategies
EXTRN	??0CvAIGrandStrategyXMLEntries@@QAE@XZ:PROC	; CvAIGrandStrategyXMLEntries::CvAIGrandStrategyXMLEntries
EXTRN	??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ:PROC	; CvMilitaryAIStrategyXMLEntries::CvMilitaryAIStrategyXMLEntries
EXTRN	??0CvTacticalMoveXMLEntries@@QAE@XZ:PROC	; CvTacticalMoveXMLEntries::CvTacticalMoveXMLEntries
EXTRN	??0CvCitySpecializationXMLEntries@@QAE@XZ:PROC	; CvCitySpecializationXMLEntries::CvCitySpecializationXMLEntries
EXTRN	??0CvEconomicAIStrategyXMLEntries@@QAE@XZ:PROC	; CvEconomicAIStrategyXMLEntries::CvEconomicAIStrategyXMLEntries
EXTRN	??0CvMap@@QAE@XZ:PROC				; CvMap::CvMap
EXTRN	??0CvGame@@QAE@XZ:PROC				; CvGame::CvGame
EXTRN	??0CvRandom@@QAE@XZ:PROC			; CvRandom::CvRandom
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__ehfuncinfo$?init@CvGlobals@@QAEXXZ DD 019930522H
	DD	027H
	DD	FLAT:__unwindtable$?init@CvGlobals@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?init@CvGlobals@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$21
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$22
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$24
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$25
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$26
	DD	01aH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$27
	DD	01aH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$28
	DD	01aH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$29
	DD	01aH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$30
	DD	01aH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$31
	DD	01aH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$32
	DD	01aH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$33
	DD	01aH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$34
	DD	01aH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$35
	DD	01aH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$36
	DD	01aH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$37
	DD	01aH
	DD	FLAT:__unwindfunclet$?init@CvGlobals@@QAEXXZ$38
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ?init@CvGlobals@@QAEXXZ
_TEXT	SEGMENT
_pkLoader$ = -660					; size = 4
$T264345 = -660						; size = 4
$T264341 = -660						; size = 4
$T264337 = -660						; size = 4
$T264333 = -660						; size = 4
$T264329 = -660						; size = 4
$T264325 = -660						; size = 4
$T264321 = -660						; size = 4
$T264317 = -660						; size = 4
$T264313 = -660						; size = 4
$T264309 = -660						; size = 4
$T264305 = -660						; size = 4
$T264301 = -660						; size = 4
$T264297 = -660						; size = 4
$T264293 = -660						; size = 4
$T264289 = -660						; size = 4
$T264285 = -660						; size = 4
$T264281 = -660						; size = 4
$T264277 = -660						; size = 4
$T264273 = -660						; size = 4
$T264269 = -660						; size = 4
$T264265 = -660						; size = 4
$T264261 = -660						; size = 4
$T264257 = -660						; size = 4
$T264253 = -660						; size = 4
$T264249 = -660						; size = 4
$T264245 = -660						; size = 4
$T264393 = -656						; size = 4
$T264389 = -656						; size = 4
$T264385 = -656						; size = 4
$T264381 = -656						; size = 4
$T264377 = -656						; size = 4
$T264373 = -656						; size = 4
$T264369 = -656						; size = 4
$T264365 = -656						; size = 4
$T264361 = -656						; size = 4
$T264357 = -656						; size = 4
$T264353 = -656						; size = 4
$T264349 = -656						; size = 4
_aiCityPlotX$ = -652					; size = 148
_aiCityPlotPriority$ = -504				; size = 148
_aiCityPlotY$ = -356					; size = 148
_aaiXYCityPlot$ = -208					; size = 196
__$EHRec$ = -12						; size = 12
?init@CvGlobals@@QAEXXZ PROC				; CvGlobals::init, COMDAT
; _this$ = ecx

; 2014 : {

	push	-1
	push	__ehhandler$?init@CvGlobals@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 648				; 00000288H

; 2015 : 	//
; 2016 : 	// These vars are used to initialize the globals.
; 2017 : 	//
; 2018 : 	int aiPlotDirectionX[NUM_DIRECTION_TYPES] =
; 2019 : 	{
; 2020 : 		0,	// DIRECTION_NORTHEAST
; 2021 : 		1,	// DIRECTION_EAST
; 2022 : 		1,	// DIRECTION_SOUTHEAST
; 2023 : 		0,	// DIRECTION_SOUTHWEST
; 2024 : 		-1,	// DIRECTION_WEST
; 2025 : 		-1,	// DIRECTION_NORTHWEST
; 2026 : 	};
; 2027 : 
; 2028 : 	int aiPlotDirectionY[NUM_DIRECTION_TYPES] =
; 2029 : 	{
; 2030 : 		1,	// DIRECTION_NORTHEAST
; 2031 : 		0,	// DIRECTION_EAST
; 2032 : 		-1,	// DIRECTION_SOUTHEAST
; 2033 : 		-1,	// DIRECTION_SOUTHWEST
; 2034 : 		0,	// DIRECTION_WEST
; 2035 : 		1,	// DIRECTION_NORTHWEST
; 2036 : 	};
; 2037 : 
; 2038 : 	// these are now in hex-space coords
; 2039 : 	int aiCityPlotX[NUM_CITY_PLOTS] =
; 2040 : 	{
; 2041 : 		//	0
; 2042 : 		0,
; 2043 : 		//	1	2	3	4	5	6
; 2044 : 		0,  1,  1,  0, -1, -1,
; 2045 : 		//	7	8	9	10	11	12	13	14	15	16	17	18
; 2046 : 		0,  1,  2,  2,  2,  1,  0,  -1, -2, -2, -2, -1,

	mov	eax, -2					; fffffffeH
	push	ebx
	or	ebx, -1
	mov	edx, 1
	push	ebp
	mov	ebp, ecx
	xor	ecx, ecx
	push	esi

; 2047 : 		//	19	20	21	22	23	24	25	26	27	28	29	30	31	32	33	34	35	36
; 2048 : 		0,  1,  2,  3,  3,  3,  3,  2,  1,  0,  -1, -2, -3, -3, -3, -3, -2, -1,

	mov	esi, 3
	push	edi
	mov	edi, 2
	mov	DWORD PTR _aiCityPlotX$[esp+676], ecx
	mov	DWORD PTR _aiCityPlotX$[esp+680], ecx
	mov	DWORD PTR _aiCityPlotX$[esp+692], ecx
	mov	DWORD PTR _aiCityPlotX$[esp+704], ecx
	mov	DWORD PTR _aiCityPlotX$[esp+728], ecx
	mov	DWORD PTR _aiCityPlotX$[esp+752], ecx
	mov	DWORD PTR _aiCityPlotX$[esp+788], ecx
	mov	ecx, -3					; fffffffdH
	mov	DWORD PTR _aiCityPlotX$[esp+736], eax
	mov	DWORD PTR _aiCityPlotX$[esp+740], eax
	mov	DWORD PTR _aiCityPlotX$[esp+744], eax
	mov	DWORD PTR _aiCityPlotX$[esp+796], eax
	mov	DWORD PTR _aiCityPlotX$[esp+816], eax

; 2049 : 		//	37	38	39	40	41	42	43	44	45	46	47	48	49	50	51	52	53	54	55	56	57	58	59	60
; 2050 : 		//	0,  1,  2,  3,  4,  4,  4,  4,  4,  3,  2,  1,  0,  -1,  -2, -3, -4, -4, -4, -4, -4, -3, -2, -1,
; 2051 : 	};
; 2052 : 
; 2053 : 	int aiCityPlotY[NUM_CITY_PLOTS] =
; 2054 : 	{
; 2055 : 		//	0
; 2056 : 		0,
; 2057 : 		//	1	2	3	4	5	6
; 2058 : 		1,  0, -1, -1,  0,  1,
; 2059 : 		//	7	8	9	10	11	12	13	14	15	16	17	18
; 2060 : 		2,  1,  0, -1,	-2, -2, -2, -1,  0,  1,  2,  2,

	mov	DWORD PTR _aiCityPlotY$[esp+720], eax
	mov	DWORD PTR _aiCityPlotY$[esp+724], eax
	mov	DWORD PTR _aiCityPlotY$[esp+728], eax

; 2061 : 		//	19	20	21	22	23	24	25	26	27	28	29	30	31	32	33	34	35	36
; 2062 : 		3,  2,  1,  0,  -1, -2, -3, -3, -3, -3, -2, -1,  0,  1,  2,  3,  3,  3,

	mov	DWORD PTR _aiCityPlotY$[esp+772], eax
	mov	DWORD PTR _aiCityPlotY$[esp+792], eax
	mov	DWORD PTR _aiCityPlotX$[esp+684], edx
	mov	DWORD PTR _aiCityPlotX$[esp+688], edx
	mov	DWORD PTR _aiCityPlotX$[esp+696], ebx
	mov	DWORD PTR _aiCityPlotX$[esp+700], ebx
	mov	DWORD PTR _aiCityPlotX$[esp+708], edx
	mov	DWORD PTR _aiCityPlotX$[esp+712], edi
	mov	DWORD PTR _aiCityPlotX$[esp+716], edi
	mov	DWORD PTR _aiCityPlotX$[esp+720], edi
	mov	DWORD PTR _aiCityPlotX$[esp+724], edx
	mov	DWORD PTR _aiCityPlotX$[esp+732], ebx
	mov	DWORD PTR _aiCityPlotX$[esp+748], ebx
	mov	DWORD PTR _aiCityPlotX$[esp+756], edx
	mov	DWORD PTR _aiCityPlotX$[esp+760], edi
	mov	DWORD PTR _aiCityPlotX$[esp+764], esi
	mov	DWORD PTR _aiCityPlotX$[esp+768], esi
	mov	DWORD PTR _aiCityPlotX$[esp+772], esi
	mov	DWORD PTR _aiCityPlotX$[esp+776], esi
	mov	DWORD PTR _aiCityPlotX$[esp+780], edi
	mov	DWORD PTR _aiCityPlotX$[esp+784], edx
	mov	DWORD PTR _aiCityPlotX$[esp+792], ebx
	mov	DWORD PTR _aiCityPlotX$[esp+800], ecx
	mov	DWORD PTR _aiCityPlotX$[esp+804], ecx
	mov	DWORD PTR _aiCityPlotX$[esp+808], ecx
	mov	DWORD PTR _aiCityPlotX$[esp+812], ecx
	mov	DWORD PTR _aiCityPlotX$[esp+820], ebx
	mov	DWORD PTR _aiCityPlotY$[esp+676], 0
	mov	DWORD PTR _aiCityPlotY$[esp+680], edx
	mov	DWORD PTR _aiCityPlotY$[esp+684], 0
	mov	DWORD PTR _aiCityPlotY$[esp+688], ebx
	mov	DWORD PTR _aiCityPlotY$[esp+692], ebx
	mov	DWORD PTR _aiCityPlotY$[esp+696], 0
	mov	DWORD PTR _aiCityPlotY$[esp+700], edx
	mov	DWORD PTR _aiCityPlotY$[esp+704], edi
	mov	DWORD PTR _aiCityPlotY$[esp+708], edx
	mov	DWORD PTR _aiCityPlotY$[esp+712], 0
	mov	DWORD PTR _aiCityPlotY$[esp+716], ebx
	mov	DWORD PTR _aiCityPlotY$[esp+732], ebx
	mov	DWORD PTR _aiCityPlotY$[esp+736], 0
	mov	DWORD PTR _aiCityPlotY$[esp+740], edx
	mov	DWORD PTR _aiCityPlotY$[esp+744], edi
	mov	DWORD PTR _aiCityPlotY$[esp+748], edi
	mov	DWORD PTR _aiCityPlotY$[esp+752], esi
	mov	DWORD PTR _aiCityPlotY$[esp+756], edi
	mov	DWORD PTR _aiCityPlotY$[esp+760], edx
	mov	DWORD PTR _aiCityPlotY$[esp+764], 0
	mov	DWORD PTR _aiCityPlotY$[esp+768], ebx
	mov	DWORD PTR _aiCityPlotY$[esp+776], ecx
	mov	DWORD PTR _aiCityPlotY$[esp+780], ecx
	mov	DWORD PTR _aiCityPlotY$[esp+784], ecx
	mov	DWORD PTR _aiCityPlotY$[esp+788], ecx
	mov	DWORD PTR _aiCityPlotY$[esp+796], ebx
	xor	eax, eax
	mov	DWORD PTR _aiCityPlotY$[esp+800], eax
	mov	DWORD PTR _aiCityPlotY$[esp+804], edx
	mov	DWORD PTR _aiCityPlotY$[esp+808], edi
	mov	DWORD PTR _aiCityPlotY$[esp+812], esi
	mov	DWORD PTR _aiCityPlotY$[esp+816], esi
	mov	DWORD PTR _aiCityPlotY$[esp+820], esi

; 2063 : 		//	37	38	39	40	41	42	43	44	45	46	47	48	49	50	51	52	53	54	55	56	57	58	59	60
; 2064 : 		//	4,  3,  2,  1,  0, -1, -2, -3, -4, -4, -4, -4, -4, -3, -2, -1,  0,  1,  2,  3,  4,  4,  4,  4,
; 2065 : 	};
; 2066 : 
; 2067 : 	int aiCityPlotPriority[NUM_CITY_PLOTS] =
; 2068 : 	{
; 2069 : 		0,

	mov	DWORD PTR _aiCityPlotPriority$[esp+676], eax

; 2070 : 		1,  1,  1,  1,  1,  1,

	mov	DWORD PTR _aiCityPlotPriority$[esp+680], edx
	mov	DWORD PTR _aiCityPlotPriority$[esp+684], edx
	mov	DWORD PTR _aiCityPlotPriority$[esp+688], edx
	mov	DWORD PTR _aiCityPlotPriority$[esp+692], edx
	mov	DWORD PTR _aiCityPlotPriority$[esp+696], edx
	mov	DWORD PTR _aiCityPlotPriority$[esp+700], edx

; 2071 : 		2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,

	mov	DWORD PTR _aiCityPlotPriority$[esp+704], edi
	mov	DWORD PTR _aiCityPlotPriority$[esp+708], edi
	mov	DWORD PTR _aiCityPlotPriority$[esp+712], edi
	mov	DWORD PTR _aiCityPlotPriority$[esp+716], edi
	mov	DWORD PTR _aiCityPlotPriority$[esp+720], edi
	mov	DWORD PTR _aiCityPlotPriority$[esp+724], edi
	mov	DWORD PTR _aiCityPlotPriority$[esp+728], edi
	mov	DWORD PTR _aiCityPlotPriority$[esp+732], edi
	mov	DWORD PTR _aiCityPlotPriority$[esp+736], edi
	mov	DWORD PTR _aiCityPlotPriority$[esp+740], edi
	mov	DWORD PTR _aiCityPlotPriority$[esp+744], edi
	mov	DWORD PTR _aiCityPlotPriority$[esp+748], edi

; 2072 : 		3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,

	mov	DWORD PTR _aiCityPlotPriority$[esp+752], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+756], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+760], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+764], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+768], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+772], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+776], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+780], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+784], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+788], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+792], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+796], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+800], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+804], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+808], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+812], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+816], esi
	mov	DWORD PTR _aiCityPlotPriority$[esp+820], esi

; 2073 : 		//4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
; 2074 : 	};
; 2075 : 
; 2076 : 	int aaiXYCityPlot[CITY_PLOTS_DIAMETER][CITY_PLOTS_DIAMETER] =
; 2077 : 	{
; 2078 : 		// this is the 4 ring layout
; 2079 : 		/*
; 2080 : 		//	 -4  -3  -2  -1   0   1   2   3  4  -- in the Y direction
; 2081 : 		{-1, -1, -1, -1, 53, 54, 55, 56, 57,}, // -4 hex-space x
; 2082 : 		{-1, -1, -1, 52, 31, 32, 33, 34, 58,}, // -3 hex-space x
; 2083 : 		{-1, -1, 51, 30, 15, 16, 17, 35, 59,}, // -2 hex-space x
; 2084 : 		{-1, 50, 29, 14,  5,  6, 18, 36, 60,}, // -1 hex-space x
; 2085 : 		{49, 28, 13,  4,  0,  1,  7, 19, 37,}, //  0 hex-space x
; 2086 : 		{48, 27, 12,  3,  2,  8, 20, 38, -1,}, //  1 hex-space x
; 2087 : 		{47, 26, 11, 10,  9, 21, 39, -1, -1,}, //  2 hex-space x
; 2088 : 		{46, 25, 24, 23, 22, 40, -1, -1, -1,}, //  3 hex-space x
; 2089 : 		{45, 44, 43, 42, 41, -1, -1, -1, -1,}, //  4 hex-space x
; 2090 : 		*/
; 2091 : 		// this is the 3 ring layout
; 2092 : 		//	 -3  -2  -1   0   1   2   3    -- in the Y direction
; 2093 : 		{-1, -1, -1, 31, 32, 33, 34,}, // -3 hex-space x

	mov	DWORD PTR _aaiXYCityPlot$[esp+676], ebx
	mov	DWORD PTR _aaiXYCityPlot$[esp+680], ebx
	mov	DWORD PTR _aaiXYCityPlot$[esp+684], ebx
	mov	DWORD PTR _aaiXYCityPlot$[esp+688], 31	; 0000001fH
	mov	DWORD PTR _aaiXYCityPlot$[esp+692], 32	; 00000020H
	mov	DWORD PTR _aaiXYCityPlot$[esp+696], 33	; 00000021H
	mov	DWORD PTR _aaiXYCityPlot$[esp+700], 34	; 00000022H

; 2094 : 		{-1, -1, 30, 15, 16, 17, 35,}, // -2 hex-space x

	mov	DWORD PTR _aaiXYCityPlot$[esp+704], ebx
	mov	DWORD PTR _aaiXYCityPlot$[esp+708], ebx
	mov	DWORD PTR _aaiXYCityPlot$[esp+712], 30	; 0000001eH
	mov	DWORD PTR _aaiXYCityPlot$[esp+716], 15	; 0000000fH
	mov	DWORD PTR _aaiXYCityPlot$[esp+720], 16	; 00000010H
	mov	DWORD PTR _aaiXYCityPlot$[esp+724], 17	; 00000011H
	mov	DWORD PTR _aaiXYCityPlot$[esp+728], 35	; 00000023H

; 2095 : 		{-1, 29, 14,  5,  6, 18, 36,}, // -1 hex-space x

	mov	DWORD PTR _aaiXYCityPlot$[esp+732], ebx
	mov	DWORD PTR _aaiXYCityPlot$[esp+736], 29	; 0000001dH
	mov	DWORD PTR _aaiXYCityPlot$[esp+740], 14	; 0000000eH
	mov	DWORD PTR _aaiXYCityPlot$[esp+744], 5
	mov	DWORD PTR _aaiXYCityPlot$[esp+748], 6
	mov	DWORD PTR _aaiXYCityPlot$[esp+752], 18	; 00000012H
	mov	DWORD PTR _aaiXYCityPlot$[esp+756], 36	; 00000024H

; 2096 : 		{28, 13,  4,  0,  1,  7, 19,}, //  0 hex-space x

	mov	DWORD PTR _aaiXYCityPlot$[esp+760], 28	; 0000001cH
	mov	DWORD PTR _aaiXYCityPlot$[esp+764], 13	; 0000000dH
	mov	DWORD PTR _aaiXYCityPlot$[esp+768], 4
	mov	DWORD PTR _aaiXYCityPlot$[esp+772], eax
	mov	DWORD PTR _aaiXYCityPlot$[esp+776], edx
	mov	DWORD PTR _aaiXYCityPlot$[esp+780], 7
	mov	DWORD PTR _aaiXYCityPlot$[esp+784], 19	; 00000013H

; 2097 : 		{27, 12,  3,  2,  8, 20, -1,}, //  1 hex-space x

	mov	DWORD PTR _aaiXYCityPlot$[esp+788], 27	; 0000001bH
	mov	DWORD PTR _aaiXYCityPlot$[esp+792], 12	; 0000000cH
	mov	DWORD PTR _aaiXYCityPlot$[esp+796], esi
	mov	DWORD PTR _aaiXYCityPlot$[esp+800], edi
	mov	DWORD PTR _aaiXYCityPlot$[esp+804], 8
	mov	DWORD PTR _aaiXYCityPlot$[esp+808], 20	; 00000014H
	mov	DWORD PTR _aaiXYCityPlot$[esp+812], ebx

; 2098 : 		{26, 11, 10,  9, 21, -1, -1,}, //  2 hex-space x

	mov	DWORD PTR _aaiXYCityPlot$[esp+816], 26	; 0000001aH
	mov	DWORD PTR _aaiXYCityPlot$[esp+820], 11	; 0000000bH
	mov	DWORD PTR _aaiXYCityPlot$[esp+824], 10	; 0000000aH

; 2099 : 		{25, 24, 23, 22, -1, -1, -1,}, //  3 hex-space x
; 2100 : 		/*
; 2101 : 		// this is the 2 ring layout
; 2102 : 		//	-2   -1   0   1   2      -- in the Y direction
; 2103 : 		{-1, -1, 16, 17, 18,}, // -2 hex-space x
; 2104 : 		{-1, 15,  5,  6,  7,}, // -1 hex-space x
; 2105 : 		{14,  4,  0,  1,  8,}, //  0 hex-space x
; 2106 : 		{13,  3,  2,  9, -1,}, //  1 hex-space x
; 2107 : 		{12, 11, 10, -1, -1,}, //  2 hex-space x
; 2108 : 		*/
; 2109 : 	};
; 2110 : 
; 2111 : 	DirectionTypes aeTurnRightDirection[NUM_DIRECTION_TYPES] =
; 2112 : 	{
; 2113 : 		DIRECTION_EAST,			// DIRECTION_NORTHEAST or DIRECTION_NORTH (deprecated)
; 2114 : 		DIRECTION_SOUTHEAST,	// DIRECTION_EAST
; 2115 : 		DIRECTION_SOUTHWEST,	// DIRECTION_SOUTHEAST
; 2116 : 		DIRECTION_WEST,			// DIRECTION_SOUTHWEST or DIRECTION_SOUTH (deprecated)
; 2117 : 		DIRECTION_NORTHWEST,	// DIRECTION_WEST
; 2118 : 		DIRECTION_NORTHEAST,	// DIRECTION_NORTHWEST
; 2119 : 	};
; 2120 : 
; 2121 : 	DirectionTypes aeTurnLeftDirection[NUM_DIRECTION_TYPES] =
; 2122 : 	{
; 2123 : 		DIRECTION_NORTHWEST,	// DIRECTION_NORTHEAST or DIRECTION_NORTH (deprecated)
; 2124 : 		DIRECTION_NORTHEAST,	// DIRECTION_EAST
; 2125 : 		DIRECTION_EAST,			// DIRECTION_SOUTHEAST
; 2126 : 		DIRECTION_SOUTHEAST,	// DIRECTION_SOUTHWEST or DIRECTION_SOUTH (deprecated)
; 2127 : 		DIRECTION_SOUTHWEST,	// DIRECTION_WEST
; 2128 : 		DIRECTION_WEST,			// DIRECTION_NORTHWEST
; 2129 : 	};
; 2130 : 
; 2131 : 	CvAssertMsg(gDLL != NULL, "Civ app needs to set gDLL");
; 2132 : #ifdef AUI_WARNING_FIXES
; 2133 : 	m_asyncRand = new(_aligned_malloc(sizeof(CvRandom), 16)) CvRandom();
; 2134 : #else
; 2135 : 	m_asyncRand = FNEW(CvRandom, c_eCiv5GameplayDLL, 0);

	push	20					; 00000014H
	mov	DWORD PTR _aaiXYCityPlot$[esp+832], 9
	mov	DWORD PTR _aaiXYCityPlot$[esp+836], 21	; 00000015H
	mov	DWORD PTR _aaiXYCityPlot$[esp+840], ebx
	mov	DWORD PTR _aaiXYCityPlot$[esp+844], ebx
	mov	DWORD PTR _aaiXYCityPlot$[esp+848], 25	; 00000019H
	mov	DWORD PTR _aaiXYCityPlot$[esp+852], 24	; 00000018H
	mov	DWORD PTR _aaiXYCityPlot$[esp+856], 23	; 00000017H
	mov	DWORD PTR _aaiXYCityPlot$[esp+860], 22	; 00000016H
	mov	DWORD PTR _aaiXYCityPlot$[esp+864], ebx
	mov	DWORD PTR _aaiXYCityPlot$[esp+868], ebx
	mov	DWORD PTR _aaiXYCityPlot$[esp+872], ebx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264245[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 0
	test	eax, eax
	je	SHORT $LN3@init
	mov	ecx, eax
	call	??0CvRandom@@QAE@XZ			; CvRandom::CvRandom
	jmp	SHORT $LN4@init
$LN3@init:
	xor	eax, eax
$LN4@init:
	mov	DWORD PTR [ebp+44], eax

; 2136 : #endif
; 2137 : 
; 2138 : 	gDLL->InitGlobals();	// some globals need to be allocated outside the dll

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+488]
	mov	DWORD PTR __$EHRec$[esp+684], ebx
	call	edx

; 2139 : 
; 2140 : #ifdef AUI_WARNING_FIXES
; 2141 : 	m_game = new(_aligned_malloc(sizeof(CvGame), 16)) CvGame();
; 2142 : #else
; 2143 : 	m_game = FNEW(CvGame, c_eCiv5GameplayDLL, 0);

	push	5368					; 000014f8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264249[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 1
	test	eax, eax
	je	SHORT $LN5@init
	mov	ecx, eax
	call	??0CvGame@@QAE@XZ			; CvGame::CvGame
	jmp	SHORT $LN6@init
$LN5@init:
	xor	eax, eax
$LN6@init:

; 2144 : #endif
; 2145 : 	m_map = FNEW(CvMap, c_eCiv5GameplayDLL, 0);

	push	4332					; 000010ecH
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+48], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264253[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], edi
	test	eax, eax
	je	SHORT $LN7@init
	mov	ecx, eax
	call	??0CvMap@@QAE@XZ			; CvMap::CvMap
	jmp	SHORT $LN8@init
$LN7@init:
	xor	eax, eax
$LN8@init:

; 2146 : 
; 2147 : 	m_pEconomicAIStrategies = FNEW(CvEconomicAIStrategyXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+52], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264257[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], esi
	test	eax, eax
	je	SHORT $LN9@init
	mov	ecx, eax
	call	??0CvEconomicAIStrategyXMLEntries@@QAE@XZ ; CvEconomicAIStrategyXMLEntries::CvEconomicAIStrategyXMLEntries
	jmp	SHORT $LN10@init
$LN9@init:
	xor	eax, eax
$LN10@init:

; 2148 : 	m_pCitySpecializations = FNEW(CvCitySpecializationXMLEntries, c_eCiv5GameplayDLL, 0);

	push	24					; 00000018H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1668], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264261[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 4
	test	eax, eax
	je	SHORT $LN11@init
	mov	ecx, eax
	call	??0CvCitySpecializationXMLEntries@@QAE@XZ ; CvCitySpecializationXMLEntries::CvCitySpecializationXMLEntries
	jmp	SHORT $LN12@init
$LN11@init:
	xor	eax, eax
$LN12@init:

; 2149 : 	m_pTacticalMoves = FNEW(CvTacticalMoveXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1672], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264265[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 5
	test	eax, eax
	je	SHORT $LN13@init
	mov	ecx, eax
	call	??0CvTacticalMoveXMLEntries@@QAE@XZ	; CvTacticalMoveXMLEntries::CvTacticalMoveXMLEntries
	jmp	SHORT $LN14@init
$LN13@init:
	xor	eax, eax
$LN14@init:

; 2150 : 	m_pMilitaryAIStrategies = FNEW(CvMilitaryAIStrategyXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1676], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264269[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 6
	test	eax, eax
	je	SHORT $LN15@init
	mov	ecx, eax
	call	??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ ; CvMilitaryAIStrategyXMLEntries::CvMilitaryAIStrategyXMLEntries
	jmp	SHORT $LN16@init
$LN15@init:
	xor	eax, eax
$LN16@init:

; 2151 : 	m_pAIGrandStrategies = FNEW(CvAIGrandStrategyXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1680], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264273[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 7
	test	eax, eax
	je	SHORT $LN17@init
	mov	ecx, eax
	call	??0CvAIGrandStrategyXMLEntries@@QAE@XZ	; CvAIGrandStrategyXMLEntries::CvAIGrandStrategyXMLEntries
	jmp	SHORT $LN18@init
$LN17@init:
	xor	eax, eax
$LN18@init:

; 2152 : 	m_pAICityStrategies = FNEW(CvAICityStrategies, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1684], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264277[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 8
	test	eax, eax
	je	SHORT $LN19@init
	mov	ecx, eax
	call	??0CvAICityStrategies@@QAE@XZ		; CvAICityStrategies::CvAICityStrategies
	jmp	SHORT $LN20@init
$LN19@init:
	xor	eax, eax
$LN20@init:

; 2153 : 	m_pPolicies = FNEW(CvPolicyXMLEntries, c_eCiv5GameplayDLL, 0);

	push	32					; 00000020H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1688], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264281[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 9
	test	eax, eax
	je	SHORT $LN21@init
	mov	ecx, eax
	call	??0CvPolicyXMLEntries@@QAE@XZ		; CvPolicyXMLEntries::CvPolicyXMLEntries
	jmp	SHORT $LN22@init
$LN21@init:
	xor	eax, eax
$LN22@init:

; 2154 : 	m_pTechs = FNEW(CvTechXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1692], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264285[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 10	; 0000000aH
	test	eax, eax
	je	SHORT $LN23@init
	mov	ecx, eax
	call	??0CvTechXMLEntries@@QAE@XZ		; CvTechXMLEntries::CvTechXMLEntries
	jmp	SHORT $LN24@init
$LN23@init:
	xor	eax, eax
$LN24@init:

; 2155 : 	m_pBuildings = FNEW(CvBuildingXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1696], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264289[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 11	; 0000000bH
	test	eax, eax
	je	SHORT $LN25@init
	mov	ecx, eax
	call	??0CvBuildingXMLEntries@@QAE@XZ		; CvBuildingXMLEntries::CvBuildingXMLEntries
	jmp	SHORT $LN26@init
$LN25@init:
	xor	eax, eax
$LN26@init:

; 2156 : 	m_pUnits = FNEW(CvUnitXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1700], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264293[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 12	; 0000000cH
	test	eax, eax
	je	SHORT $LN27@init
	mov	ecx, eax
	call	??0CvUnitXMLEntries@@QAE@XZ		; CvUnitXMLEntries::CvUnitXMLEntries
	jmp	SHORT $LN28@init
$LN27@init:
	xor	eax, eax
$LN28@init:

; 2157 : 	m_pProjects = FNEW(CvProjectXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1704], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264297[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 13	; 0000000dH
	test	eax, eax
	je	SHORT $LN29@init
	mov	ecx, eax
	call	??0CvProjectXMLEntries@@QAE@XZ		; CvProjectXMLEntries::CvProjectXMLEntries
	jmp	SHORT $LN30@init
$LN29@init:
	xor	eax, eax
$LN30@init:

; 2158 : 	m_pPromotions = FNEW(CvPromotionXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1708], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264301[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 14	; 0000000eH
	test	eax, eax
	je	SHORT $LN31@init
	mov	ecx, eax
	call	??0CvPromotionXMLEntries@@QAE@XZ	; CvPromotionXMLEntries::CvPromotionXMLEntries
	jmp	SHORT $LN32@init
$LN31@init:
	xor	eax, eax
$LN32@init:

; 2159 : 	m_pImprovements = FNEW(CvImprovementXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1712], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264305[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 15	; 0000000fH
	test	eax, eax
	je	SHORT $LN33@init
	mov	ecx, eax
	call	??0CvImprovementXMLEntries@@QAE@XZ	; CvImprovementXMLEntries::CvImprovementXMLEntries
	jmp	SHORT $LN34@init
$LN33@init:
	xor	eax, eax
$LN34@init:

; 2160 : 	m_pEmphases = FNEW(CvEmphasisXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1716], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264309[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 16	; 00000010H
	test	eax, eax
	je	SHORT $LN35@init
	mov	ecx, eax
	call	??0CvEmphasisXMLEntries@@QAE@XZ		; CvEmphasisXMLEntries::CvEmphasisXMLEntries
	jmp	SHORT $LN36@init
$LN35@init:
	xor	eax, eax
$LN36@init:

; 2161 : 	m_pTraits = FNEW(CvTraitXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1720], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264313[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 17	; 00000011H
	test	eax, eax
	je	SHORT $LN37@init
	mov	ecx, eax
	call	??0CvTraitXMLEntries@@QAE@XZ		; CvTraitXMLEntries::CvTraitXMLEntries
	jmp	SHORT $LN38@init
$LN37@init:
	xor	eax, eax
$LN38@init:

; 2162 : 	m_pReligions = FNEW(CvReligionXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1724], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264317[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 18	; 00000012H
	test	eax, eax
	je	SHORT $LN39@init
	mov	ecx, eax
	call	??0CvReligionXMLEntries@@QAE@XZ		; CvReligionXMLEntries::CvReligionXMLEntries
	jmp	SHORT $LN40@init
$LN39@init:
	xor	eax, eax
$LN40@init:

; 2163 : 	m_pBeliefs = FNEW(CvBeliefXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1728], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264321[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 19	; 00000013H
	test	eax, eax
	je	SHORT $LN41@init
	mov	ecx, eax
	call	??0CvBeliefXMLEntries@@QAE@XZ		; CvBeliefXMLEntries::CvBeliefXMLEntries
	jmp	SHORT $LN42@init
$LN41@init:
	xor	eax, eax
$LN42@init:

; 2164 : 	m_pLeagueSpecialSessions = FNEW(CvLeagueSpecialSessionXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1732], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264325[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 20	; 00000014H
	test	eax, eax
	je	SHORT $LN43@init
	mov	ecx, eax
	call	??0CvLeagueSpecialSessionXMLEntries@@QAE@XZ ; CvLeagueSpecialSessionXMLEntries::CvLeagueSpecialSessionXMLEntries
	jmp	SHORT $LN44@init
$LN43@init:
	xor	eax, eax
$LN44@init:

; 2165 : 	m_pLeagueNames = FNEW(CvLeagueNameXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1736], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264329[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 21	; 00000015H
	test	eax, eax
	je	SHORT $LN45@init
	mov	ecx, eax
	call	??0CvLeagueNameXMLEntries@@QAE@XZ	; CvLeagueNameXMLEntries::CvLeagueNameXMLEntries
	jmp	SHORT $LN46@init
$LN45@init:
	xor	eax, eax
$LN46@init:

; 2166 : 	m_pLeagueProjects = FNEW(CvLeagueProjectXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1740], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264333[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 22	; 00000016H
	test	eax, eax
	je	SHORT $LN47@init
	mov	ecx, eax
	call	??0CvLeagueProjectXMLEntries@@QAE@XZ	; CvLeagueProjectXMLEntries::CvLeagueProjectXMLEntries
	jmp	SHORT $LN48@init
$LN47@init:
	xor	eax, eax
$LN48@init:

; 2167 : 	m_pLeagueProjectRewards = FNEW(CvLeagueProjectRewardXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1744], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264337[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 23	; 00000017H
	test	eax, eax
	je	SHORT $LN49@init
	mov	ecx, eax
	call	??0CvLeagueProjectRewardXMLEntries@@QAE@XZ ; CvLeagueProjectRewardXMLEntries::CvLeagueProjectRewardXMLEntries
	jmp	SHORT $LN50@init
$LN49@init:
	xor	eax, eax
$LN50@init:

; 2168 : 	m_pResolutions = FNEW(CvResolutionXMLEntries, c_eCiv5GameplayDLL, 0);

	push	16					; 00000010H
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1748], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264341[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 24	; 00000018H
	test	eax, eax
	je	SHORT $LN51@init
	mov	ecx, eax
	call	??0CvResolutionXMLEntries@@QAE@XZ	; CvResolutionXMLEntries::CvResolutionXMLEntries
	jmp	SHORT $LN52@init
$LN51@init:
	xor	eax, eax
$LN52@init:

; 2169 : 	m_pNotifications = FNEW(CvNotificationXMLEntries, c_eCiv5GameplayDLL, 0);

	push	28					; 0000001cH
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	mov	DWORD PTR [ebp+1752], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264345[esp+676], eax
	mov	DWORD PTR __$EHRec$[esp+684], 25	; 00000019H
	test	eax, eax
	je	SHORT $LN53@init
	mov	ecx, eax
	call	??0CvNotificationXMLEntries@@QAE@XZ	; CvNotificationXMLEntries::CvNotificationXMLEntries
	jmp	SHORT $LN54@init
$LN53@init:
	xor	eax, eax
$LN54@init:

; 2170 : 
; 2171 : 	auto_ptr<ICvDLLDatabaseUtility1> pkLoader(getDatabaseLoadUtility());

	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+684], ebx
	mov	DWORD PTR [ebp+1756], eax
	call	?getDatabaseLoadUtility@CvGlobals@@QAEPAVICvDLLDatabaseUtility1@@XZ ; CvGlobals::getDatabaseLoadUtility
	mov	esi, eax
	mov	DWORD PTR _pkLoader$[esp+676], esi

; 2172 : 
; 2173 : 	Database::Connection* pDB = GetGameDatabase();

	mov	ecx, DWORD PTR [ebp+912]

; 2174 : 	pDB->Execute(m_kGlobalDefinesLookup, "SELECT Value from Defines where Name = ? LIMIT 1");

	push	ebx
	push	OFFSET $SG228460
	lea	eax, DWORD PTR [ebp+916]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+696], 26	; 0000001aH
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z

; 2175 : 
; 2176 : 	pkLoader->PerformDatabasePostProcessing();

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+16]
	push	esi
	call	edx

; 2177 : 	pkLoader->CacheGameDatabaseData();

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+8]
	push	esi
	call	ecx

; 2178 : 
; 2179 : 	CvPlayerAI::initStatics();

	call	?initStatics@CvPlayerAI@@SAXXZ		; CvPlayerAI::initStatics

; 2180 : 	CvTeam::initStatics();

	call	?initStatics@CvTeam@@SAXXZ		; CvTeam::initStatics

; 2181 : 
; 2182 : 	memcpy(m_aiPlotDirectionX, aiPlotDirectionX, sizeof(m_aiPlotDirectionX));

	xor	eax, eax
	mov	DWORD PTR [ebp+112], eax
	mov	eax, 1
	mov	DWORD PTR [ebp+116], eax
	mov	DWORD PTR [ebp+120], eax
	xor	eax, eax
	mov	DWORD PTR [ebp+124], eax
	or	eax, -1
	mov	DWORD PTR [ebp+128], eax
	or	eax, eax
	mov	DWORD PTR [ebp+132], eax

; 2183 : 	memcpy(m_aiPlotDirectionY, aiPlotDirectionY, sizeof(m_aiPlotDirectionY));

	mov	eax, 1
	mov	DWORD PTR [ebp+136], eax
	xor	eax, eax
	mov	DWORD PTR [ebp+140], eax
	or	eax, -1
	mov	DWORD PTR [ebp+144], eax
	or	eax, eax
	mov	DWORD PTR [ebp+148], eax
	xor	eax, eax
	mov	DWORD PTR [ebp+152], eax
	mov	eax, 1
	mov	DWORD PTR [ebp+156], eax

; 2184 : 	memcpy(m_aiCityPlotX, aiCityPlotX, sizeof(m_aiCityPlotX));
; 2185 : 	memcpy(m_aiCityPlotY, aiCityPlotY, sizeof(m_aiCityPlotY));
; 2186 : 	memcpy(m_aiCityPlotPriority, aiCityPlotPriority, sizeof(m_aiCityPlotPriority));
; 2187 : 	memcpy(m_aeTurnLeftDirection, aeTurnLeftDirection, sizeof(m_aeTurnLeftDirection));

	mov	eax, 5
	mov	DWORD PTR [ebp+800], eax
	xor	eax, eax
	mov	DWORD PTR [ebp+804], eax
	mov	eax, 1
	mov	DWORD PTR [ebp+808], eax
	mov	eax, 2
	mov	DWORD PTR [ebp+812], eax
	mov	eax, 3
	mov	DWORD PTR [ebp+816], eax
	mov	eax, 4
	mov	DWORD PTR [ebp+820], eax

; 2188 : 	memcpy(m_aeTurnRightDirection, aeTurnRightDirection, sizeof(m_aeTurnRightDirection));

	mov	eax, 1
	mov	DWORD PTR [ebp+824], eax
	mov	eax, 2
	mov	DWORD PTR [ebp+828], eax
	mov	eax, 3
	mov	DWORD PTR [ebp+832], eax
	lea	edi, DWORD PTR [ebp+160]
	mov	ecx, 37					; 00000025H
	lea	esi, DWORD PTR _aiCityPlotX$[esp+676]
	rep movsd
	mov	eax, 4
	lea	edi, DWORD PTR [ebp+308]
	mov	ecx, 37					; 00000025H
	lea	esi, DWORD PTR _aiCityPlotY$[esp+676]
	rep movsd
	mov	DWORD PTR [ebp+836], eax
	lea	edi, DWORD PTR [ebp+456]
	mov	ecx, 37					; 00000025H
	lea	esi, DWORD PTR _aiCityPlotPriority$[esp+676]
	mov	eax, 5
	rep movsd
	mov	DWORD PTR [ebp+840], eax
	xor	eax, eax

; 2189 : 	memcpy(m_aaiXYCityPlot, aaiXYCityPlot, sizeof(m_aaiXYCityPlot));

	lea	edi, DWORD PTR [ebp+604]
	mov	ecx, 49					; 00000031H
	lea	esi, DWORD PTR _aaiXYCityPlot$[esp+676]

; 2190 : 
; 2191 : 	setPathFinder(FNEW(CvTwoLayerPathFinder, c_eCiv5GameplayDLL, 0));

	push	632					; 00000278H
	mov	DWORD PTR [ebp+844], eax
	rep movsd
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264349[esp+676], eax
	mov	BYTE PTR __$EHRec$[esp+684], 27		; 0000001bH
	test	eax, eax
	je	SHORT $LN55@init
	mov	ecx, eax
	call	??0CvTwoLayerPathFinder@@QAE@XZ		; CvTwoLayerPathFinder::CvTwoLayerPathFinder
	jmp	SHORT $LN56@init
$LN55@init:
	xor	eax, eax
$LN56@init:

; 2192 : 	setInterfacePathFinder(FNEW(CvTwoLayerPathFinder, c_eCiv5GameplayDLL, 0));

	push	632					; 00000278H
	mov	BYTE PTR __$EHRec$[esp+688], 26		; 0000001aH
	mov	DWORD PTR [ebp+56], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264353[esp+676], eax
	mov	BYTE PTR __$EHRec$[esp+684], 28		; 0000001cH
	test	eax, eax
	je	SHORT $LN57@init
	mov	ecx, eax
	call	??0CvTwoLayerPathFinder@@QAE@XZ		; CvTwoLayerPathFinder::CvTwoLayerPathFinder
	jmp	SHORT $LN58@init
$LN57@init:
	xor	eax, eax
$LN58@init:

; 2193 : 	setIgnoreUnitsPathFinder(FNEW(CvIgnoreUnitsPathFinder, c_eCiv5GameplayDLL, 0));

	push	632					; 00000278H
	mov	BYTE PTR __$EHRec$[esp+688], 26		; 0000001aH
	mov	DWORD PTR [ebp+60], eax
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T264357[esp+676], esi
	mov	BYTE PTR __$EHRec$[esp+684], 29		; 0000001dH
	test	esi, esi
	je	SHORT $LN59@init
	mov	ecx, esi
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	jmp	SHORT $LN60@init
$LN59@init:
	xor	esi, esi
$LN60@init:

; 2194 : 	setStepFinder(FNEW(CvStepPathFinder, c_eCiv5GameplayDLL, 0));

	push	628					; 00000274H
	mov	BYTE PTR __$EHRec$[esp+688], 26		; 0000001aH
	mov	DWORD PTR [ebp+64], esi
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T264361[esp+676], esi
	mov	BYTE PTR __$EHRec$[esp+684], 30		; 0000001eH
	test	esi, esi
	je	SHORT $LN61@init
	mov	ecx, esi
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	jmp	SHORT $LN62@init
$LN61@init:
	xor	esi, esi
$LN62@init:

; 2195 : 	setRouteFinder(FNEW(CvAStar, c_eCiv5GameplayDLL, 0));

	push	628					; 00000274H
	mov	BYTE PTR __$EHRec$[esp+688], 26		; 0000001aH
	mov	DWORD PTR [ebp+68], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264365[esp+676], eax
	mov	BYTE PTR __$EHRec$[esp+684], 31		; 0000001fH
	test	eax, eax
	je	SHORT $LN63@init
	mov	ecx, eax
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	jmp	SHORT $LN64@init
$LN63@init:
	xor	eax, eax
$LN64@init:

; 2196 : 	SetWaterRouteFinder(FNEW(CvAStar, c_eCiv5GameplayDLL, 0));

	push	628					; 00000274H
	mov	BYTE PTR __$EHRec$[esp+688], 26		; 0000001aH
	mov	DWORD PTR [ebp+72], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264369[esp+676], eax
	mov	BYTE PTR __$EHRec$[esp+684], 32		; 00000020H
	test	eax, eax
	je	SHORT $LN65@init
	mov	ecx, eax
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	jmp	SHORT $LN66@init
$LN65@init:
	xor	eax, eax
$LN66@init:

; 2197 : 	setAreaFinder(FNEW(CvAStar, c_eCiv5GameplayDLL, 0));

	push	628					; 00000274H
	mov	BYTE PTR __$EHRec$[esp+688], 26		; 0000001aH
	mov	DWORD PTR [ebp+76], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264373[esp+676], eax
	mov	BYTE PTR __$EHRec$[esp+684], 33		; 00000021H
	test	eax, eax
	je	SHORT $LN67@init
	mov	ecx, eax
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	jmp	SHORT $LN68@init
$LN67@init:
	xor	eax, eax
$LN68@init:

; 2198 : 	setInfluenceFinder(FNEW(CvAStar, c_eCiv5GameplayDLL, 0));

	push	628					; 00000274H
	mov	BYTE PTR __$EHRec$[esp+688], 26		; 0000001aH
	mov	DWORD PTR [ebp+84], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264377[esp+676], eax
	mov	BYTE PTR __$EHRec$[esp+684], 34		; 00000022H
	test	eax, eax
	je	SHORT $LN69@init
	mov	ecx, eax
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	jmp	SHORT $LN70@init
$LN69@init:
	xor	eax, eax
$LN70@init:

; 2199 : 	SetBuildRouteFinder(FNEW(CvAStar, c_eCiv5GameplayDLL, 0));

	push	628					; 00000274H
	mov	BYTE PTR __$EHRec$[esp+688], 26		; 0000001aH
	mov	DWORD PTR [ebp+88], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264381[esp+676], eax
	mov	BYTE PTR __$EHRec$[esp+684], 35		; 00000023H
	test	eax, eax
	je	SHORT $LN71@init
	mov	ecx, eax
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	jmp	SHORT $LN72@init
$LN71@init:
	xor	eax, eax
$LN72@init:

; 2200 : 	SetInternationalTradeRouteLandFinder(FNEW(CvAStar, c_eCiv5GameplayDLL, 0));

	push	628					; 00000274H
	mov	BYTE PTR __$EHRec$[esp+688], 26		; 0000001aH
	mov	DWORD PTR [ebp+92], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264385[esp+676], eax
	mov	BYTE PTR __$EHRec$[esp+684], 36		; 00000024H
	test	eax, eax
	je	SHORT $LN73@init
	mov	ecx, eax
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	jmp	SHORT $LN74@init
$LN73@init:
	xor	eax, eax
$LN74@init:

; 2201 : 	SetInternationalTradeRouteWaterFinder(FNEW(CvAStar, c_eCiv5GameplayDLL, 0));

	push	628					; 00000274H
	mov	BYTE PTR __$EHRec$[esp+688], 26		; 0000001aH
	mov	DWORD PTR [ebp+96], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264389[esp+676], eax
	mov	BYTE PTR __$EHRec$[esp+684], 37		; 00000025H
	test	eax, eax
	je	SHORT $LN75@init
	mov	ecx, eax
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	jmp	SHORT $LN76@init
$LN75@init:
	xor	eax, eax
$LN76@init:

; 2202 : 	SetTacticalAnalysisMapFinder(FNEW(CvTwoLayerPathFinder, c_eCiv5GameplayDLL, 0));

	push	632					; 00000278H
	mov	BYTE PTR __$EHRec$[esp+688], 26		; 0000001aH
	mov	DWORD PTR [ebp+100], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T264393[esp+676], eax
	mov	BYTE PTR __$EHRec$[esp+684], 38		; 00000026H
	test	eax, eax
	je	SHORT $LN77@init
	mov	ecx, eax
	call	??0CvTwoLayerPathFinder@@QAE@XZ		; CvTwoLayerPathFinder::CvTwoLayerPathFinder
	jmp	SHORT $LN78@init
$LN77@init:
	xor	eax, eax
$LN78@init:
	mov	DWORD PTR [ebp+104], eax

; 2203 : #ifdef AUI_DANGER_PLOTS_REMADE
; 2204 : 	setDangerPathFinder(FNEW(CvTwoLayerPathFinder, c_eCiv5GameplayDLL, 0));
; 2205 : #endif
; 2206 : }

	mov	eax, DWORD PTR _pkLoader$[esp+676]
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __$EHRec$[esp+688], ebx
	call	eax
	mov	ecx, DWORD PTR __$EHRec$[esp+676]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 660				; 00000294H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?init@CvGlobals@@QAEXXZ$0:
	mov	eax, DWORD PTR $T264245[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$1:
	mov	eax, DWORD PTR $T264249[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$2:
	mov	eax, DWORD PTR $T264253[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$3:
	mov	eax, DWORD PTR $T264257[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$4:
	mov	eax, DWORD PTR $T264261[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$5:
	mov	eax, DWORD PTR $T264265[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$6:
	mov	eax, DWORD PTR $T264269[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$7:
	mov	eax, DWORD PTR $T264273[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$8:
	mov	eax, DWORD PTR $T264277[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$9:
	mov	eax, DWORD PTR $T264281[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$10:
	mov	eax, DWORD PTR $T264285[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$11:
	mov	eax, DWORD PTR $T264289[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$12:
	mov	eax, DWORD PTR $T264293[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$13:
	mov	eax, DWORD PTR $T264297[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$14:
	mov	eax, DWORD PTR $T264301[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$15:
	mov	eax, DWORD PTR $T264305[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$16:
	mov	eax, DWORD PTR $T264309[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$17:
	mov	eax, DWORD PTR $T264313[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$18:
	mov	eax, DWORD PTR $T264317[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$19:
	mov	eax, DWORD PTR $T264321[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$20:
	mov	eax, DWORD PTR $T264325[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$21:
	mov	eax, DWORD PTR $T264329[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$22:
	mov	eax, DWORD PTR $T264333[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$23:
	mov	eax, DWORD PTR $T264337[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$24:
	mov	eax, DWORD PTR $T264341[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$25:
	mov	eax, DWORD PTR $T264345[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$26:
	lea	ecx, DWORD PTR _pkLoader$[ebp]
	jmp	??1?$auto_ptr@VICvDLLDatabaseUtility1@@@std@@QAE@XZ ; std::auto_ptr<ICvDLLDatabaseUtility1>::~auto_ptr<ICvDLLDatabaseUtility1>
__unwindfunclet$?init@CvGlobals@@QAEXXZ$27:
	mov	eax, DWORD PTR $T264349[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$28:
	mov	eax, DWORD PTR $T264353[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$29:
	mov	eax, DWORD PTR $T264357[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$30:
	mov	eax, DWORD PTR $T264361[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$31:
	mov	eax, DWORD PTR $T264365[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$32:
	mov	eax, DWORD PTR $T264369[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$33:
	mov	eax, DWORD PTR $T264373[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$34:
	mov	eax, DWORD PTR $T264377[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$35:
	mov	eax, DWORD PTR $T264381[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$36:
	mov	eax, DWORD PTR $T264385[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$37:
	mov	eax, DWORD PTR $T264389[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?init@CvGlobals@@QAEXXZ$38:
	mov	eax, DWORD PTR $T264393[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?init@CvGlobals@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?init@CvGlobals@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?init@CvGlobals@@QAEXXZ ENDP				; CvGlobals::init
PUBLIC	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z ; CvGlobals::WrapCityPointer
EXTRN	??3CvDllCity@@SAXPAX@Z:PROC			; CvDllCity::operator delete
EXTRN	??0CvDllCity@@QAE@PAVCvCity@@@Z:PROC		; CvDllCity::CvDllCity
EXTRN	??2CvDllCity@@SAPAXI@Z:PROC			; CvDllCity::operator new
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z$0
__ehfuncinfo$?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z
_TEXT	SEGMENT
$T264540 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T264531 = 12						; size = 4
_pCity$ = 12						; size = 4
?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z PROC ; CvGlobals::WrapCityPointer, COMDAT
; _this$ = ecx

; 2301 : {

	push	-1
	push	__ehhandler$?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	DWORD PTR $T264540[esp+20], 0

; 2302 : 	return auto_ptr<ICvCity1>((NULL != pCity)? new CvDllCity(pCity) : NULL);

	mov	esi, DWORD PTR _pCity$[esp+16]
	test	esi, esi
	je	SHORT $LN5@WrapCityPo
	push	12					; 0000000cH
	call	??2CvDllCity@@SAPAXI@Z			; CvDllCity::operator new
	add	esp, 4
	mov	DWORD PTR $T264531[esp+16], eax
	mov	DWORD PTR __$EHRec$[esp+28], 1
	test	eax, eax
	je	SHORT $LN5@WrapCityPo
	push	esi
	mov	ecx, eax
	call	??0CvDllCity@@QAE@PAVCvCity@@@Z		; CvDllCity::CvDllCity
	jmp	SHORT $LN6@WrapCityPo
$LN5@WrapCityPo:
	xor	eax, eax
$LN6@WrapCityPo:
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx

; 2303 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z$0:
	mov	eax, DWORD PTR $T264531[ebp-4]
	push	eax
	call	??3CvDllCity@@SAXPAX@Z			; CvDllCity::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z$2:
	mov	eax, DWORD PTR $T264540[ebp]
	and	eax, 1
	je	$LN10@WrapCityPo
	and	DWORD PTR $T264540[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
$LN10@WrapCityPo:
	ret	0
__ehhandler$?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z ENDP ; CvGlobals::WrapCityPointer
PUBLIC	?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z ; CvGlobals::WrapDealPointer
EXTRN	??3CvDllDeal@@SAXPAX@Z:PROC			; CvDllDeal::operator delete
EXTRN	??0CvDllDeal@@QAE@PAVCvDeal@@@Z:PROC		; CvDllDeal::CvDllDeal
EXTRN	??2CvDllDeal@@SAPAXI@Z:PROC			; CvDllDeal::operator new
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z$0
__ehfuncinfo$?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z
_TEXT	SEGMENT
$T264596 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T264587 = 12						; size = 4
_pDeal$ = 12						; size = 4
?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z PROC ; CvGlobals::WrapDealPointer, COMDAT
; _this$ = ecx

; 2311 : {

	push	-1
	push	__ehhandler$?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	DWORD PTR $T264596[esp+20], 0

; 2312 : 	return auto_ptr<ICvDeal1>((NULL != pDeal)? new CvDllDeal(pDeal) : NULL);

	mov	esi, DWORD PTR _pDeal$[esp+16]
	test	esi, esi
	je	SHORT $LN5@WrapDealPo
	push	12					; 0000000cH
	call	??2CvDllDeal@@SAPAXI@Z			; CvDllDeal::operator new
	add	esp, 4
	mov	DWORD PTR $T264587[esp+16], eax
	mov	DWORD PTR __$EHRec$[esp+28], 1
	test	eax, eax
	je	SHORT $LN5@WrapDealPo
	push	esi
	mov	ecx, eax
	call	??0CvDllDeal@@QAE@PAVCvDeal@@@Z		; CvDllDeal::CvDllDeal
	jmp	SHORT $LN6@WrapDealPo
$LN5@WrapDealPo:
	xor	eax, eax
$LN6@WrapDealPo:
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx

; 2313 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z$0:
	mov	eax, DWORD PTR $T264587[ebp-4]
	push	eax
	call	??3CvDllDeal@@SAXPAX@Z			; CvDllDeal::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z$2:
	mov	eax, DWORD PTR $T264596[ebp]
	and	eax, 1
	je	$LN10@WrapDealPo
	and	DWORD PTR $T264596[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ	; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
$LN10@WrapDealPo:
	ret	0
__ehhandler$?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z ENDP ; CvGlobals::WrapDealPointer
PUBLIC	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
EXTRN	??3CvDllPlot@@SAXPAX@Z:PROC			; CvDllPlot::operator delete
EXTRN	??0CvDllPlot@@QAE@PAVCvPlot@@@Z:PROC		; CvDllPlot::CvDllPlot
EXTRN	??2CvDllPlot@@SAPAXI@Z:PROC			; CvDllPlot::operator new
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z$0
__ehfuncinfo$?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z
_TEXT	SEGMENT
$T264652 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T264643 = 12						; size = 4
_pPlot$ = 12						; size = 4
?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z PROC ; CvGlobals::WrapPlotPointer, COMDAT
; _this$ = ecx

; 2321 : {

	push	-1
	push	__ehhandler$?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	DWORD PTR $T264652[esp+20], 0

; 2322 : 	return auto_ptr<ICvPlot1>((NULL != pPlot)? new CvDllPlot(pPlot) : NULL);

	mov	esi, DWORD PTR _pPlot$[esp+16]
	test	esi, esi
	je	SHORT $LN5@WrapPlotPo
	push	12					; 0000000cH
	call	??2CvDllPlot@@SAPAXI@Z			; CvDllPlot::operator new
	add	esp, 4
	mov	DWORD PTR $T264643[esp+16], eax
	mov	DWORD PTR __$EHRec$[esp+28], 1
	test	eax, eax
	je	SHORT $LN5@WrapPlotPo
	push	esi
	mov	ecx, eax
	call	??0CvDllPlot@@QAE@PAVCvPlot@@@Z		; CvDllPlot::CvDllPlot
	jmp	SHORT $LN6@WrapPlotPo
$LN5@WrapPlotPo:
	xor	eax, eax
$LN6@WrapPlotPo:
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx

; 2323 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z$0:
	mov	eax, DWORD PTR $T264643[ebp-4]
	push	eax
	call	??3CvDllPlot@@SAXPAX@Z			; CvDllPlot::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z$2:
	mov	eax, DWORD PTR $T264652[ebp]
	and	eax, 1
	je	$LN10@WrapPlotPo
	and	DWORD PTR $T264652[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
$LN10@WrapPlotPo:
	ret	0
__ehhandler$?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ENDP ; CvGlobals::WrapPlotPointer
PUBLIC	?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z ; CvGlobals::WrapRandomPointer
EXTRN	??3CvDllRandom@@SAXPAX@Z:PROC			; CvDllRandom::operator delete
EXTRN	??0CvDllRandom@@QAE@PAVCvRandom@@@Z:PROC	; CvDllRandom::CvDllRandom
EXTRN	??2CvDllRandom@@SAPAXI@Z:PROC			; CvDllRandom::operator new
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z$0
__ehfuncinfo$?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z
_TEXT	SEGMENT
$T264708 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T264699 = 12						; size = 4
_pRandom$ = 12						; size = 4
?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z PROC ; CvGlobals::WrapRandomPointer, COMDAT
; _this$ = ecx

; 2331 : {

	push	-1
	push	__ehhandler$?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	DWORD PTR $T264708[esp+20], 0

; 2332 : 	return auto_ptr<ICvRandom1>((NULL != pRandom)? new CvDllRandom(pRandom) : NULL);

	mov	esi, DWORD PTR _pRandom$[esp+16]
	test	esi, esi
	je	SHORT $LN5@WrapRandom
	push	12					; 0000000cH
	call	??2CvDllRandom@@SAPAXI@Z		; CvDllRandom::operator new
	add	esp, 4
	mov	DWORD PTR $T264699[esp+16], eax
	mov	DWORD PTR __$EHRec$[esp+28], 1
	test	eax, eax
	je	SHORT $LN5@WrapRandom
	push	esi
	mov	ecx, eax
	call	??0CvDllRandom@@QAE@PAVCvRandom@@@Z	; CvDllRandom::CvDllRandom
	jmp	SHORT $LN6@WrapRandom
$LN5@WrapRandom:
	xor	eax, eax
$LN6@WrapRandom:
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx

; 2333 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z$0:
	mov	eax, DWORD PTR $T264699[ebp-4]
	push	eax
	call	??3CvDllRandom@@SAXPAX@Z		; CvDllRandom::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z$2:
	mov	eax, DWORD PTR $T264708[ebp]
	and	eax, 1
	je	$LN10@WrapRandom
	and	DWORD PTR $T264708[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$auto_ptr@VICvRandom1@@@std@@QAE@XZ	; std::auto_ptr<ICvRandom1>::~auto_ptr<ICvRandom1>
$LN10@WrapRandom:
	ret	0
__ehhandler$?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?WrapRandomPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvRandom1@@@std@@PAVCvRandom@@@Z ENDP ; CvGlobals::WrapRandomPointer
PUBLIC	?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z ; CvGlobals::WrapUnitPointer
EXTRN	??3CvDllUnit@@SAXPAX@Z:PROC			; CvDllUnit::operator delete
EXTRN	??0CvDllUnit@@QAE@PAVCvUnit@@@Z:PROC		; CvDllUnit::CvDllUnit
EXTRN	??2CvDllUnit@@SAPAXI@Z:PROC			; CvDllUnit::operator new
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z$0
__ehfuncinfo$?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z
_TEXT	SEGMENT
$T264764 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T264755 = 12						; size = 4
_pUnit$ = 12						; size = 4
?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z PROC ; CvGlobals::WrapUnitPointer, COMDAT
; _this$ = ecx

; 2336 : {

	push	-1
	push	__ehhandler$?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	DWORD PTR $T264764[esp+20], 0

; 2337 : 	return auto_ptr<ICvUnit1>((NULL != pUnit)? new CvDllUnit(pUnit) : NULL);

	mov	esi, DWORD PTR _pUnit$[esp+16]
	test	esi, esi
	je	SHORT $LN5@WrapUnitPo
	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T264755[esp+16], eax
	mov	DWORD PTR __$EHRec$[esp+28], 1
	test	eax, eax
	je	SHORT $LN5@WrapUnitPo
	push	esi
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	jmp	SHORT $LN6@WrapUnitPo
$LN5@WrapUnitPo:
	xor	eax, eax
$LN6@WrapUnitPo:
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx

; 2338 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z$0:
	mov	eax, DWORD PTR $T264755[ebp-4]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z$2:
	mov	eax, DWORD PTR $T264764[ebp]
	and	eax, 1
	je	$LN10@WrapUnitPo
	and	DWORD PTR $T264764[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
$LN10@WrapUnitPo:
	ret	0
__ehhandler$?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?WrapUnitPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvUnit1@@@std@@PAVCvUnit@@@Z ENDP ; CvGlobals::WrapUnitPointer
PUBLIC	?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z ; CvGlobals::GetHexDebugLayerString
EXTRN	?GetLastTargetingPathIndex@@YAHH@Z:PROC		; GetLastTargetingPathIndex
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ:PROC ; CvGame::GetTacticalAnalysisMap
EXTRN	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ:PROC ; CvPlot::GetArchaeologicalRecord
EXTRN	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z:PROC	; CvPlayer::GetPlotDanger
EXTRN	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ:PROC ; CvGame::GetSettlerSiteEvaluator
EXTRN	__imp__sprintf_s:PROC
EXTRN	?GetStartSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForStart@@XZ:PROC ; CvGame::GetStartSiteEvaluator
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
xdata$x	SEGMENT
__unwindtable$?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z$1
__ehfuncinfo$?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z
_TEXT	SEGMENT
_szTmp$230600 = -88					; size = 16
_szTmp$230592 = -88					; size = 16
$T264809 = -88						; size = 20
_strOut$230561 = -68					; size = 28
_strLayerName$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_pkPlot$ = 8						; size = 4
_szLayerName$ = 12					; size = 4
_ePlayer$ = 16						; size = 4
_szBuffer$ = 20						; size = 4
_uiBufferLength$ = 24					; size = 4
?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z PROC ; CvGlobals::GetHexDebugLayerString, COMDAT
; _this$ = ecx

; 4796 : {

	push	-1
	push	__ehhandler$?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH

; 4797 : 	std::string strLayerName = szLayerName;

	mov	eax, DWORD PTR _szLayerName$[esp+84]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _strLayerName$[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 4798 : 	if(strLayerName == "StartSiteEvaluationLayer")

	mov	esi, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	lea	ecx, DWORD PTR _strLayerName$[esp+100]
	push	OFFSET $SG230518
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+116], ebx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN41@GetHexDebu@2

; 4799 : 	{
; 4800 : 		if(!pkPlot->isWater())

	mov	esi, DWORD PTR _pkPlot$[esp+96]
	cmp	BYTE PTR [esi+5], 3
	je	$LN1@GetHexDebu@2

; 4801 : 		{
; 4802 : 			const int iValue = GC.getGame().GetStartSiteEvaluator()->PlotFoundValue(pkPlot, NULL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetStartSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForStart@@XZ ; CvGame::GetStartSiteEvaluator
	mov	edx, DWORD PTR [eax]
	push	1
	push	-1
	push	ebx
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	push	esi
	call	eax

; 4803 : 			sprintf_s(szBuffer, uiBufferLength, "%d", iValue);

	mov	ecx, DWORD PTR _uiBufferLength$[esp+96]
	mov	edx, DWORD PTR _szBuffer$[esp+96]
	push	eax
	push	OFFSET $SG230521
	push	ecx
	push	edx

; 4858 : 		sprintf_s(szBuffer, uiBufferLength, "%d", iValue);

	call	DWORD PTR __imp__sprintf_s
	add	esp, 16					; 00000010H
	jmp	$LN1@GetHexDebu@2
$LN41@GetHexDebu@2:

; 4804 : 		}
; 4805 : 	}
; 4806 : 	else if(strLayerName == "SettlerSiteEvaluationLayer")

	lea	eax, DWORD PTR _strLayerName$[esp+100]
	push	OFFSET $SG230524
	push	eax
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN38@GetHexDebu@2

; 4807 : 	{
; 4808 : 		if(!pkPlot->isWater() && ePlayer != NO_PLAYER)

	mov	edi, DWORD PTR _pkPlot$[esp+96]
	cmp	BYTE PTR [edi+5], 3
	je	$LN1@GetHexDebu@2
	mov	eax, DWORD PTR _ePlayer$[esp+96]
	cmp	eax, -1
	je	$LN1@GetHexDebu@2

; 4809 : 		{
; 4810 : 			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
; 4811 : 			const int iValue = GC.getGame().GetSettlerSiteEvaluator()->PlotFoundValue(pkPlot, &kPlayer);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax
	call	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ ; CvGame::GetSettlerSiteEvaluator
	mov	edx, DWORD PTR [eax]
	push	1
	push	-1
	push	esi
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	push	edi
	call	eax

; 4812 : 			sprintf_s(szBuffer, uiBufferLength, "%d", iValue);

	mov	ecx, DWORD PTR _uiBufferLength$[esp+96]
	mov	edx, DWORD PTR _szBuffer$[esp+96]
	push	eax
	push	OFFSET $SG230528
	push	ecx
	push	edx

; 4858 : 		sprintf_s(szBuffer, uiBufferLength, "%d", iValue);

	call	DWORD PTR __imp__sprintf_s
	add	esp, 16					; 00000010H
	jmp	$LN1@GetHexDebu@2
$LN38@GetHexDebu@2:

; 4813 : 		}
; 4814 : 	}
; 4815 : 	else if(strLayerName == "VisibilityLayer")

	lea	eax, DWORD PTR _strLayerName$[esp+100]
	push	OFFSET $SG230531
	push	eax
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN35@GetHexDebu@2

; 4816 : 	{
; 4817 : 		if(ePlayer != NO_PLAYER)

	mov	eax, DWORD PTR _ePlayer$[esp+96]
	cmp	eax, -1
	je	$LN1@GetHexDebu@2

; 4818 : 		{
; 4819 : 			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 4820 : 			const TeamTypes eTeam = kPlayer.getTeam();

	mov	esi, DWORD PTR [eax+44]
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN62@GetHexDebu@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN63@GetHexDebu@2
$LN62@GetHexDebu@2:
	or	eax, -1
$LN63@GetHexDebu@2:

; 4821 : 
; 4822 : 			if(pkPlot->isVisible(eTeam))

	mov	ecx, DWORD PTR _pkPlot$[esp+96]
	push	eax
	call	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isVisible
	test	al, al
	je	$LN1@GetHexDebu@2

; 4823 : 			{
; 4824 : 				sprintf_s(szBuffer, uiBufferLength, "Vis %d", kPlayer.GetID());

	push	esi
	push	OFFSET $SG230536

; 4825 : 			}
; 4826 : 		}
; 4827 : 	}

	jmp	$LN153@GetHexDebu@2
$LN35@GetHexDebu@2:

; 4828 : 	else if(strLayerName == "RevealedLayer")

	lea	edx, DWORD PTR _strLayerName$[esp+100]
	push	OFFSET $SG230539
	push	edx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN31@GetHexDebu@2

; 4829 : 	{
; 4830 : 		if(ePlayer != NO_PLAYER)

	mov	eax, DWORD PTR _ePlayer$[esp+96]
	cmp	eax, -1
	je	$LN1@GetHexDebu@2

; 4831 : 		{
; 4832 : 			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax

; 4833 : 			const TeamTypes eTeam = kPlayer.getTeam();

	mov	ecx, esi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam

; 4834 : 			if(pkPlot->isRevealed(eTeam))

	mov	ecx, DWORD PTR _pkPlot$[esp+96]
	push	eax
	call	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isRevealed
	test	al, al
	je	$LN1@GetHexDebu@2

; 4835 : 			{
; 4836 : 				sprintf_s(szBuffer, uiBufferLength, "Rev %d", kPlayer.GetID());

	mov	esi, DWORD PTR [esi+44]
	push	esi
	push	OFFSET $SG230544

; 4837 : 
; 4838 : 			}
; 4839 : 		}
; 4840 : 	}

	jmp	SHORT $LN153@GetHexDebu@2
$LN31@GetHexDebu@2:

; 4841 : 	else if(strLayerName == "DangerLayer")

	lea	edx, DWORD PTR _strLayerName$[esp+100]
	push	OFFSET $SG230547
	push	edx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN27@GetHexDebu@2

; 4842 : 	{
; 4843 : 		if(ePlayer != NO_PLAYER)

	mov	eax, DWORD PTR _ePlayer$[esp+96]
	cmp	eax, -1
	je	$LN1@GetHexDebu@2

; 4844 : 		{
; 4845 : 			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
; 4846 : #ifdef AUI_DANGER_PLOTS_REMADE
; 4847 : 			const int iValue = kPlayer.GetPlotDanger(*pkPlot, ePlayer);
; 4848 : #else
; 4849 : 			const int iValue = kPlayer.GetPlotDanger(*pkPlot);

	mov	ecx, DWORD PTR _pkPlot$[esp+96]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger

; 4850 : #endif
; 4851 : 
; 4852 : 			sprintf_s(szBuffer, uiBufferLength, "%d", iValue);

	mov	edx, DWORD PTR _uiBufferLength$[esp+96]
	push	eax
	mov	eax, DWORD PTR _szBuffer$[esp+100]
	push	OFFSET $SG230551
	push	edx
	push	eax
	call	DWORD PTR __imp__sprintf_s
	add	esp, 16					; 00000010H

; 4853 : 		}
; 4854 : 	}

	jmp	$LN1@GetHexDebu@2
$LN27@GetHexDebu@2:

; 4855 : 	else if(strLayerName == "ArtifactLayer")

	lea	ecx, DWORD PTR _strLayerName$[esp+100]
	push	OFFSET $SG230554
	push	ecx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN24@GetHexDebu@2

; 4856 : 	{
; 4857 : 		const int iValue = pkPlot->GetArchaeologicalRecord().m_eArtifactType; // this is a copy

	mov	ecx, DWORD PTR _pkPlot$[esp+96]
	lea	edx, DWORD PTR $T264809[esp+100]
	push	edx
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	eax, DWORD PTR [eax]

; 4858 : 		sprintf_s(szBuffer, uiBufferLength, "%d", iValue);

	push	eax
	push	OFFSET $SG230557
$LN153@GetHexDebu@2:
	mov	eax, DWORD PTR _uiBufferLength$[esp+104]
	mov	ecx, DWORD PTR _szBuffer$[esp+104]
	push	eax
	push	ecx
	call	DWORD PTR __imp__sprintf_s
	add	esp, 16					; 00000010H
	jmp	$LN1@GetHexDebu@2
$LN24@GetHexDebu@2:

; 4859 : 	}
; 4860 : 	else if(strLayerName == "TacticalAnalysisLayer")

	lea	edx, DWORD PTR _strLayerName$[esp+100]
	push	OFFSET $SG230560
	push	edx
	call	esi
	add	esp, 8
	test	al, al
	je	$LN22@GetHexDebu@2

; 4861 : 	{
; 4862 : 		std::string strOut;

	lea	ecx, DWORD PTR _strOut$230561[esp+100]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4863 : 
; 4864 : 		int iIndex = GC.getMap().plotNum(pkPlot->getX(), pkPlot->getY());

	mov	ecx, DWORD PTR _pkPlot$[esp+96]
	movsx	esi, WORD PTR [ecx+2]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [eax+4020]
	movsx	ecx, WORD PTR [ecx]
	imul	esi, eax
	add	esi, ecx

; 4865 : 		CvTacticalAnalysisMap* pTactMap = GC.getGame().GetTacticalAnalysisMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR __$EHRec$[esp+108], 1
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap

; 4866 : 		CvTacticalAnalysisCell* pCell = pTactMap->GetCell(iIndex);

	imul	esi, 44					; 0000002cH
	add	esi, DWORD PTR [eax+12]

; 4867 : 
; 4868 : 		if(pCell->IsImpassableTerrain())

	mov	eax, DWORD PTR [esi]
	mov	edx, eax
	shr	edx, 2
	test	dl, 1
	je	SHORT $LN21@GetHexDebu@2

; 4869 : 		{
; 4870 : 			strOut += "X Terrain";

	push	OFFSET $SG230566

; 4871 : 		}
; 4872 : 		else

	jmp	$LN150@GetHexDebu@2
$LN21@GetHexDebu@2:

; 4873 : 		{
; 4874 : 			if(pCell->IsImpassableTerritory())

	shr	eax, 3
	test	al, 1
	je	SHORT $LN19@GetHexDebu@2

; 4875 : 			{
; 4876 : 				strOut += "X Territory";

	push	OFFSET $SG230569

; 4877 : 			}
; 4878 : 			else

	jmp	$LN150@GetHexDebu@2
$LN19@GetHexDebu@2:

; 4879 : 			{
; 4880 : 				if(pCell->IsRevealed())

	test	BYTE PTR [esi], 1
	je	SHORT $LN17@GetHexDebu@2

; 4881 : 				{
; 4882 : 					strOut += "R ";

	push	OFFSET $SG230572
	lea	ecx, DWORD PTR _strOut$230561[esp+104]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN17@GetHexDebu@2:

; 4883 : 				}
; 4884 : 				if(pCell->IsVisible())

	mov	eax, DWORD PTR [esi]
	shr	eax, 1
	test	al, 1
	je	SHORT $LN16@GetHexDebu@2

; 4885 : 				{
; 4886 : 					strOut += "V ";

	push	OFFSET $SG230574
	lea	ecx, DWORD PTR _strOut$230561[esp+104]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN16@GetHexDebu@2:

; 4887 : 				}
; 4888 : 				if(pCell->IsEnemyCanMovePast())

	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	shr	ecx, 6
	test	cl, 1
	je	SHORT $LN15@GetHexDebu@2

; 4889 : 				{
; 4890 : 					strOut += "A+ ";

	push	OFFSET $SG230576
	jmp	SHORT $LN151@GetHexDebu@2
$LN15@GetHexDebu@2:

; 4891 : 				}
; 4892 : 				else if(pCell->IsNotVisibleToEnemy())

	mov	edx, eax
	shr	edx, 4
	test	dl, 1
	je	SHORT $LN13@GetHexDebu@2

; 4893 : 				{
; 4894 : 					strOut += "N ";

	push	OFFSET $SG230579
	jmp	SHORT $LN151@GetHexDebu@2
$LN13@GetHexDebu@2:

; 4895 : 				}
; 4896 : 				else if(pCell->IsSubjectToAttack())

	shr	eax, 5
	test	al, 1
	je	SHORT $LN11@GetHexDebu@2

; 4897 : 				{
; 4898 : 					strOut += "A ";

	push	OFFSET $SG230582
$LN151@GetHexDebu@2:
	lea	ecx, DWORD PTR _strOut$230561[esp+104]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN11@GetHexDebu@2:

; 4899 : 				}
; 4900 : 				if(pCell->IsFriendlyTurnEndTile())

	mov	eax, DWORD PTR [esi]
	shr	eax, 7
	test	al, 1
	je	SHORT $LN10@GetHexDebu@2

; 4901 : 				{
; 4902 : 					strOut += "E ";

	push	OFFSET $SG230584
	lea	ecx, DWORD PTR _strOut$230561[esp+104]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN10@GetHexDebu@2:

; 4903 : 				}
; 4904 : 				if(pCell->IsWithinRangeOfTarget())

	mov	ecx, DWORD PTR [esi]
	shr	ecx, 17					; 00000011H
	test	cl, 1
	je	SHORT $LN9@GetHexDebu@2

; 4905 : 				{
; 4906 : 					strOut += "T ";

	push	OFFSET $SG230586
	lea	ecx, DWORD PTR _strOut$230561[esp+104]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN9@GetHexDebu@2:

; 4907 : 				}
; 4908 : 				if(pCell->IsHelpsProvidesFlankBonus())

	mov	edx, DWORD PTR [esi]
	shr	edx, 18					; 00000012H
	test	dl, 1
	je	SHORT $LN8@GetHexDebu@2

; 4909 : 				{
; 4910 : 					strOut += "F ";

	push	OFFSET $SG230588
	lea	ecx, DWORD PTR _strOut$230561[esp+104]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN8@GetHexDebu@2:

; 4911 : 				}
; 4912 : 				if(pCell->GetDefenseModifier() > 0)

	cmp	DWORD PTR [esi+28], ebx
	jle	SHORT $LN7@GetHexDebu@2

; 4913 : 				{
; 4914 : 					strOut += "D ";

	push	OFFSET $SG230590
	lea	ecx, DWORD PTR _strOut$230561[esp+104]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN7@GetHexDebu@2:

; 4915 : 				}
; 4916 : 				if(pCell->GetDominanceZone() != -1)

	mov	ecx, DWORD PTR [esi+40]
	cmp	ecx, -1
	je	SHORT $LN6@GetHexDebu@2

; 4917 : 				{
; 4918 : 					char szTmp[16] = {0};

	xor	eax, eax

; 4919 : 					sprintf_s(szTmp, "%d ", pCell->GetDominanceZone());

	push	ecx
	mov	DWORD PTR _szTmp$230592[esp+105], eax
	mov	DWORD PTR _szTmp$230592[esp+109], eax
	mov	DWORD PTR _szTmp$230592[esp+113], eax
	mov	WORD PTR _szTmp$230592[esp+117], ax
	mov	BYTE PTR _szTmp$230592[esp+119], al
	lea	eax, DWORD PTR _szTmp$230592[esp+104]
	push	OFFSET $SG230598
	push	eax
	mov	BYTE PTR _szTmp$230592[esp+112], bl
	call	??$sprintf_s@$0BA@@@YAHAAY0BA@DPBDZZ	; sprintf_s<16>
	add	esp, 12					; 0000000cH

; 4920 : 
; 4921 : 					strOut += szTmp;

	lea	ecx, DWORD PTR _szTmp$230592[esp+100]
	push	ecx
	lea	ecx, DWORD PTR _strOut$230561[esp+104]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN6@GetHexDebu@2:

; 4922 : 				}
; 4923 : 				if(pCell->GetDeploymentScore() > 0)

	mov	ecx, DWORD PTR [esi+32]
	cmp	ecx, ebx
	jle	SHORT $LN5@GetHexDebu@2

; 4924 : 				{
; 4925 : 					char szTmp[16] = {0};
; 4926 : 					if(pCell->IsSafeForDeployment())

	mov	edx, DWORD PTR [esi]
	xor	eax, eax
	shr	edx, 19					; 00000013H
	mov	BYTE PTR _szTmp$230600[esp+100], bl
	mov	DWORD PTR _szTmp$230600[esp+101], eax
	mov	DWORD PTR _szTmp$230600[esp+105], eax
	mov	DWORD PTR _szTmp$230600[esp+109], eax
	mov	WORD PTR _szTmp$230600[esp+113], ax
	mov	BYTE PTR _szTmp$230600[esp+115], al

; 4927 : 					{
; 4928 : 						sprintf_s(szTmp, "[S%d] ", pCell->GetDeploymentScore());

	push	ecx
	test	dl, 1
	je	SHORT $LN4@GetHexDebu@2
	push	OFFSET $SG230602
	lea	eax, DWORD PTR _szTmp$230600[esp+108]
	push	eax

; 4929 : 					}
; 4930 : 					else

	jmp	SHORT $LN152@GetHexDebu@2
$LN4@GetHexDebu@2:

; 4931 : 					{
; 4932 : 						sprintf_s(szTmp, "[%d] ", pCell->GetDeploymentScore());

	push	OFFSET $SG230604
	lea	ecx, DWORD PTR _szTmp$230600[esp+108]
	push	ecx
$LN152@GetHexDebu@2:
	call	??$sprintf_s@$0BA@@@YAHAAY0BA@DPBDZZ	; sprintf_s<16>
	add	esp, 12					; 0000000cH

; 4933 : 					}
; 4934 : 
; 4935 : 					strOut += szTmp;

	lea	edx, DWORD PTR _szTmp$230600[esp+100]
	push	edx
$LN150@GetHexDebu@2:
	lea	ecx, DWORD PTR _strOut$230561[esp+104]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN5@GetHexDebu@2:

; 4936 : 				}
; 4937 : 			}
; 4938 : 		}
; 4939 : 
; 4940 : 		sprintf_s(szBuffer, uiBufferLength, "%s", strOut.c_str());

	lea	ecx, DWORD PTR _strOut$230561[esp+100]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _szBuffer$[esp+96]
	push	eax
	mov	eax, DWORD PTR _uiBufferLength$[esp+100]
	push	OFFSET $SG230605
	push	eax
	push	ecx
	call	DWORD PTR __imp__sprintf_s
	add	esp, 16					; 00000010H

; 4941 : 	}

	lea	ecx, DWORD PTR _strOut$230561[esp+100]
	mov	BYTE PTR __$EHRec$[esp+108], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	SHORT $LN1@GetHexDebu@2
$LN22@GetHexDebu@2:

; 4942 : 	else if(strLayerName == "TargetingPathLayer")

	lea	edx, DWORD PTR _strLayerName$[esp+100]
	push	OFFSET $SG230608
	push	edx
	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN1@GetHexDebu@2

; 4943 : 	{
; 4944 : 		extern int GetLastTargetingPathIndex(int plotIndex);
; 4945 : 		sprintf_s(szBuffer, uiBufferLength, "%d", GetLastTargetingPathIndex(pkPlot->GetPlotIndex()));

	mov	ecx, DWORD PTR _pkPlot$[esp+96]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	push	eax
	call	?GetLastTargetingPathIndex@@YAHH@Z	; GetLastTargetingPathIndex
	mov	ecx, DWORD PTR _szBuffer$[esp+100]
	push	eax
	mov	eax, DWORD PTR _uiBufferLength$[esp+104]
	push	OFFSET $SG230611
	push	eax
	push	ecx
	call	DWORD PTR __imp__sprintf_s
	add	esp, 20					; 00000014H
$LN1@GetHexDebu@2:

; 4946 : 	}
; 4947 : 
; 4948 : 	return true;

	lea	ecx, DWORD PTR _strLayerName$[esp+100]
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4949 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z$0:
	lea	ecx, DWORD PTR _strLayerName$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z$1:
	lea	ecx, DWORD PTR _strOut$230561[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetHexDebugLayerString@CvGlobals@@QAE_NPAVCvPlot@@PBDW4PlayerTypes@@PADI@Z ENDP ; CvGlobals::GetHexDebugLayerString
PUBLIC	?cacheGlobals@CvGlobals@@QAEXXZ			; CvGlobals::cacheGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?cacheGlobals@CvGlobals@@QAEXXZ
_TEXT	SEGMENT
?cacheGlobals@CvGlobals@@QAEXXZ PROC			; CvGlobals::cacheGlobals, COMDAT
; _this$ = ecx

; 4953 : {

	push	esi

; 4954 : 
; 4955 : #ifdef AUI_DIPLOMACY_AI_LEADERHEAD_DEALS_IN_MULTIPLAYER
; 4956 : 	GD_INT_CACHE(MULTIPLAYER_AI_DIPLOMACY_NOTIFICATIONS_ONLY_SIMULTANEOUS);
; 4957 : #endif
; 4958 : #ifdef AUI_UNIT_PRODUCTION_AI_LUA_FLAVOR_WEIGHTS
; 4959 : 	GD_INT_CACHE(DISABLE_UNIT_AI_FLAVOR_LUA_MODDING);
; 4960 : #endif
; 4961 : #ifdef AUI_BUILDING_PRODUCTION_AI_LUA_FLAVOR_WEIGHTS
; 4962 : 	GD_INT_CACHE(DISABLE_BUILDING_AI_FLAVOR_LUA_MODDING);
; 4963 : #endif
; 4964 : #ifdef AUI_PROJECT_PRODUCTION_AI_LUA_FLAVOR_WEIGHTS
; 4965 : 	GD_INT_CACHE(DISABLE_PROJECT_AI_FLAVOR_LUA_MODDING);
; 4966 : #endif
; 4967 : #ifdef AUI_PROCESS_PRODUCTION_AI_LUA_FLAVOR_WEIGHTS
; 4968 : 	GD_INT_CACHE(DISABLE_PROCESS_AI_FLAVOR_LUA_MODDING);
; 4969 : #endif
; 4970 : #ifdef NQM_OPTIONAL_SCORING_TWEAKS
; 4971 : 	GD_INT_CACHE(NEW_SCORE_CITY_MULTIPLIER);

	push	1
	push	OFFSET $SG230616
	mov	esi, ecx
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4972 : 	GD_INT_CACHE(NEW_SCORE_POPULATION_MULTIPLIER);

	push	1
	push	OFFSET $SG230617
	mov	ecx, esi
	mov	DWORD PTR [esi+1776], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4973 : 	GD_INT_CACHE(NEW_SCORE_WONDER_MULTIPLIER);

	push	1
	push	OFFSET $SG230618
	mov	ecx, esi
	mov	DWORD PTR [esi+1780], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4974 : 	GD_INT_CACHE(NEW_SCORE_TECH_MULTIPLIER);

	push	1
	push	OFFSET $SG230619
	mov	ecx, esi
	mov	DWORD PTR [esi+1784], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4975 : 	GD_INT_CACHE(NEW_SCORE_FUTURE_TECH_MULTIPLIER);

	push	1
	push	OFFSET $SG230620
	mov	ecx, esi
	mov	DWORD PTR [esi+1788], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4976 : 	GD_INT_CACHE(NEW_SCORE_POLICY_MULTIPLIER);

	push	1
	push	OFFSET $SG230621
	mov	ecx, esi
	mov	DWORD PTR [esi+1792], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4977 : 	GD_INT_CACHE(NEW_SCORE_GREAT_WORK_MULTIPLIER);

	push	1
	push	OFFSET $SG230622
	mov	ecx, esi
	mov	DWORD PTR [esi+1796], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4978 : 	GD_INT_CACHE(NEW_SCORE_BELIEF_MULTIPLIER);

	push	1
	push	OFFSET $SG230623
	mov	ecx, esi
	mov	DWORD PTR [esi+1800], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4979 : #endif
; 4980 : 	// -- ints --
; 4981 : 
; 4982 : 	m_iAI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD = getDefineINT("AI_ATTEMPT_RUSH_OVER_X_TURNS_TO_BUILD");

	push	1
	push	OFFSET $SG230624
	mov	ecx, esi
	mov	DWORD PTR [esi+1804], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4983 : 	m_iINITIAL_AI_CITY_PRODUCTION = getDefineINT("INITIAL_AI_CITY_PRODUCTION");

	push	1
	push	OFFSET $SG230625
	mov	ecx, esi
	mov	DWORD PTR [esi+1808], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4984 : 	m_iAI_CAN_DISBAND_UNITS = getDefineINT("AI_CAN_DISBAND_UNITS");

	push	1
	push	OFFSET $SG230626
	mov	ecx, esi
	mov	DWORD PTR [esi+1812], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4985 : 	m_iAI_SHOULDNT_MANAGE_PLOT_ASSIGNMENT = getDefineINT("AI_SHOULDNT_MANAGE_PLOT_ASSIGNMENT");

	push	1
	push	OFFSET $SG230627
	mov	ecx, esi
	mov	DWORD PTR [esi+1816], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4986 : 	m_iPOLICY_WEIGHT_PROPAGATION_PERCENT = getDefineINT("POLICY_WEIGHT_PROPAGATION_PERCENT");

	push	1
	push	OFFSET $SG230628
	mov	ecx, esi
	mov	DWORD PTR [esi+1820], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4987 : 	m_iPOLICY_WEIGHT_PROPAGATION_LEVELS = getDefineINT("POLICY_WEIGHT_PROPAGATION_LEVELS");

	push	1
	push	OFFSET $SG230629
	mov	ecx, esi
	mov	DWORD PTR [esi+1824], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4988 : 	m_iPOLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH = getDefineINT("POLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH");

	push	1
	push	OFFSET $SG230630
	mov	ecx, esi
	mov	DWORD PTR [esi+1828], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4989 : 	m_iTECH_WEIGHT_PROPAGATION_PERCENT = getDefineINT("TECH_WEIGHT_PROPAGATION_PERCENT");

	push	1
	push	OFFSET $SG230631
	mov	ecx, esi
	mov	DWORD PTR [esi+1832], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+1836], eax

; 4990 : 	m_iTECH_WEIGHT_PROPAGATION_LEVELS = getDefineINT("TECH_WEIGHT_PROPAGATION_LEVELS");

	push	1
	push	OFFSET $SG230632
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4991 : 	m_iTECH_PRIORITY_UNIQUE_ITEM = getDefineINT("TECH_PRIORITY_UNIQUE_ITEM");

	push	1
	push	OFFSET $SG230633
	mov	ecx, esi
	mov	DWORD PTR [esi+1840], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4992 : 	m_iTECH_PRIORITY_MAYA_CALENDAR_BONUS = getDefineINT("TECH_PRIORITY_MAYA_CALENDAR_BONUS");

	push	1
	push	OFFSET $SG230634
	mov	ecx, esi
	mov	DWORD PTR [esi+1844], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4993 : 	m_iAI_VALUE_OF_YIELD_GOLD = getDefineINT("AI_VALUE_OF_YIELD_GOLD");

	push	1
	push	OFFSET $SG230635
	mov	ecx, esi
	mov	DWORD PTR [esi+1848], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4994 : 	m_iAI_VALUE_OF_YIELD_PRODUCTION = getDefineINT("AI_VALUE_OF_YIELD_PRODUCTION");

	push	1
	push	OFFSET $SG230636
	mov	ecx, esi
	mov	DWORD PTR [esi+1852], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4995 : 	m_iAI_VALUE_OF_YIELD_SCIENCE = getDefineINT("AI_VALUE_OF_YIELD_SCIENCE");

	push	1
	push	OFFSET $SG230637
	mov	ecx, esi
	mov	DWORD PTR [esi+1856], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4996 : 	m_iDEFAULT_FLAVOR_VALUE = getDefineINT("DEFAULT_FLAVOR_VALUE");

	push	1
	push	OFFSET $SG230638
	mov	ecx, esi
	mov	DWORD PTR [esi+1860], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4997 : 	m_iPERSONALITY_FLAVOR_MAX_VALUE = getDefineINT("PERSONALITY_FLAVOR_MAX_VALUE");

	push	1
	push	OFFSET $SG230639
	mov	ecx, esi
	mov	DWORD PTR [esi+1864], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4998 : 	m_iPERSONALITY_FLAVOR_MIN_VALUE = getDefineINT("PERSONALITY_FLAVOR_MIN_VALUE");

	push	1
	push	OFFSET $SG230640
	mov	ecx, esi
	mov	DWORD PTR [esi+1868], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 4999 : 	m_iFLAVOR_MIN_VALUE = getDefineINT("FLAVOR_MIN_VALUE");

	push	1
	push	OFFSET $SG230641
	mov	ecx, esi
	mov	DWORD PTR [esi+1872], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5000 : 	m_iFLAVOR_MAX_VALUE = getDefineINT("FLAVOR_MAX_VALUE");

	push	1
	push	OFFSET $SG230642
	mov	ecx, esi
	mov	DWORD PTR [esi+1876], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5001 : 	m_iFLAVOR_RANDOMIZATION_RANGE = getDefineINT("FLAVOR_RANDOMIZATION_RANGE");

	push	1
	push	OFFSET $SG230643
	mov	ecx, esi
	mov	DWORD PTR [esi+1880], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5002 : 	m_iFLAVOR_EXPANDGROW_COEFFICIENT = getDefineINT("FLAVOR_EXPANDGROW_COEFFICIENT");

	push	1
	push	OFFSET $SG230644
	mov	ecx, esi
	mov	DWORD PTR [esi+1884], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5003 : 	m_iAI_GRAND_STRATEGY_NUM_TURNS_STRATEGY_MUST_BE_ACTIVE = getDefineINT("AI_GRAND_STRATEGY_NUM_TURNS_STRATEGY_MUST_BE_ACTIVE");

	push	1
	push	OFFSET $SG230645
	mov	ecx, esi
	mov	DWORD PTR [esi+1888], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5004 : 	m_iAI_GS_RAND_ROLL = getDefineINT("AI_GS_RAND_ROLL");

	push	1
	push	OFFSET $SG230646
	mov	ecx, esi
	mov	DWORD PTR [esi+1892], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5005 : 	m_iAI_GRAND_STRATEGY_CURRENT_STRATEGY_WEIGHT = getDefineINT("AI_GRAND_STRATEGY_CURRENT_STRATEGY_WEIGHT");

	push	1
	push	OFFSET $SG230647
	mov	ecx, esi
	mov	DWORD PTR [esi+1896], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+1900], eax

; 5006 : 	m_iAI_GRAND_STRATEGY_GUESS_NO_CLUE_WEIGHT = getDefineINT("AI_GRAND_STRATEGY_GUESS_NO_CLUE_WEIGHT");

	push	1
	push	OFFSET $SG230648
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5007 : 	m_iAI_GRAND_STRATEGY_GUESS_POSITIVE_THRESHOLD = getDefineINT("AI_GRAND_STRATEGY_GUESS_POSITIVE_THRESHOLD");

	push	1
	push	OFFSET $SG230649
	mov	ecx, esi
	mov	DWORD PTR [esi+1904], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5008 : 	m_iAI_GRAND_STRATEGY_GUESS_LIKELY_THRESHOLD = getDefineINT("AI_GRAND_STRATEGY_GUESS_LIKELY_THRESHOLD");

	push	1
	push	OFFSET $SG230650
	mov	ecx, esi
	mov	DWORD PTR [esi+1908], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5009 : 	m_iAI_GRAND_STRATEGY_OTHER_PLAYERS_GS_MULTIPLIER = getDefineINT("AI_GRAND_STRATEGY_OTHER_PLAYERS_GS_MULTIPLIER");

	push	1
	push	OFFSET $SG230651
	mov	ecx, esi
	mov	DWORD PTR [esi+1912], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5010 : 	m_iAI_GS_CONQUEST_NOBODY_MET_FIRST_TURN = getDefineINT("AI_GS_CONQUEST_NOBODY_MET_FIRST_TURN");

	push	1
	push	OFFSET $SG230652
	mov	ecx, esi
	mov	DWORD PTR [esi+1916], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5011 : 	m_iAI_GRAND_STRATEGY_CONQUEST_NOBODY_MET_WEIGHT = getDefineINT("AI_GRAND_STRATEGY_CONQUEST_NOBODY_MET_WEIGHT");

	push	1
	push	OFFSET $SG230653
	mov	ecx, esi
	mov	DWORD PTR [esi+1920], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5012 : 	m_iAI_GRAND_STRATEGY_CONQUEST_AT_WAR_WEIGHT = getDefineINT("AI_GRAND_STRATEGY_CONQUEST_AT_WAR_WEIGHT");

	push	1
	push	OFFSET $SG230654
	mov	ecx, esi
	mov	DWORD PTR [esi+1924], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5013 : 	m_iAI_GS_CONQUEST_MILITARY_STRENGTH_FIRST_TURN = getDefineINT("AI_GS_CONQUEST_MILITARY_STRENGTH_FIRST_TURN");

	push	1
	push	OFFSET $SG230655
	mov	ecx, esi
	mov	DWORD PTR [esi+1928], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5014 : 	m_iAI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER = getDefineINT("AI_GRAND_STRATEGY_CONQUEST_POWER_RATIO_MULTIPLIER");

	push	1
	push	OFFSET $SG230656
	mov	ecx, esi
	mov	DWORD PTR [esi+1932], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5015 : 	m_iAI_GRAND_STRATEGY_CONQUEST_CRAMPED_WEIGHT = getDefineINT("AI_GRAND_STRATEGY_CONQUEST_CRAMPED_WEIGHT");

	push	1
	push	OFFSET $SG230657
	mov	ecx, esi
	mov	DWORD PTR [esi+1936], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5016 : 	m_iAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_ATTACKED = getDefineINT("AI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_ATTACKED");

	push	1
	push	OFFSET $SG230658
	mov	ecx, esi
	mov	DWORD PTR [esi+1940], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5017 : 	m_iAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_CONQUERED = getDefineINT("AI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MINOR_CONQUERED");

	push	1
	push	OFFSET $SG230659
	mov	ecx, esi
	mov	DWORD PTR [esi+1944], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5018 : 	m_iAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_ATTACKED = getDefineINT("AI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_ATTACKED");

	push	1
	push	OFFSET $SG230660
	mov	ecx, esi
	mov	DWORD PTR [esi+1948], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5019 : 	m_iAI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_CONQUERED = getDefineINT("AI_GRAND_STRATEGY_CONQUEST_WEIGHT_PER_MAJOR_CONQUERED");

	push	1
	push	OFFSET $SG230661
	mov	ecx, esi
	mov	DWORD PTR [esi+1952], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5020 : 	m_iAI_GS_CULTURE_RATIO_MULTIPLIER = getDefineINT("AI_GS_CULTURE_RATIO_MULTIPLIER");

	push	1
	push	OFFSET $SG230662
	mov	ecx, esi
	mov	DWORD PTR [esi+1956], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5021 : 	m_iAI_GS_TOURISM_RATIO_MULTIPLIER = getDefineINT("AI_GS_TOURISM_RATIO_MULTIPLIER");

	push	1
	push	OFFSET $SG230663
	mov	ecx, esi
	mov	DWORD PTR [esi+1960], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5022 : 	m_iAI_GS_CULTURE_AHEAD_WEIGHT = getDefineINT("AI_GS_CULTURE_AHEAD_WEIGHT");

	push	1
	mov	DWORD PTR [esi+1964], eax
	push	OFFSET $SG230664
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5023 : 	m_iAI_GS_CULTURE_TOURISM_AHEAD_WEIGHT = getDefineINT("AI_GS_CULTURE_TOURISM_AHEAD_WEIGHT");

	push	1
	push	OFFSET $SG230665
	mov	ecx, esi
	mov	DWORD PTR [esi+1968], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5024 : 	m_iAI_GS_CULTURE_INFLUENTIAL_CIV_MOD = getDefineINT("AI_GS_CULTURE_INFLUENTIAL_CIV_MOD");

	push	1
	push	OFFSET $SG230666
	mov	ecx, esi
	mov	DWORD PTR [esi+1972], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5025 : 	m_iAI_GRAND_STRATEGY_UN_EACH_MINOR_ATTACKED_WEIGHT = getDefineINT("AI_GRAND_STRATEGY_UN_EACH_MINOR_ATTACKED_WEIGHT");

	push	1
	push	OFFSET $SG230667
	mov	ecx, esi
	mov	DWORD PTR [esi+1976], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5026 : 	m_iAI_GS_UN_SECURED_VOTE_MOD = getDefineINT("AI_GS_UN_SECURED_VOTE_MOD");

	push	1
	push	OFFSET $SG230668
	mov	ecx, esi
	mov	DWORD PTR [esi+1980], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5027 : 	m_iAI_GS_SS_HAS_APOLLO_PROGRAM = getDefineINT("AI_GS_SS_HAS_APOLLO_PROGRAM");

	push	1
	push	OFFSET $SG230669
	mov	ecx, esi
	mov	DWORD PTR [esi+1984], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5028 : 	m_iAI_GS_SS_TECH_PROGRESS_MOD = getDefineINT("AI_GS_SS_TECH_PROGRESS_MOD");

	push	1
	push	OFFSET $SG230670
	mov	ecx, esi
	mov	DWORD PTR [esi+1988], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5029 : 	m_iAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT = getDefineINT("AI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT");

	push	1
	push	OFFSET $SG230671
	mov	ecx, esi
	mov	DWORD PTR [esi+1992], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5030 : 	m_iAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR = getDefineINT("AI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR");

	push	1
	push	OFFSET $SG230672
	mov	ecx, esi
	mov	DWORD PTR [esi+1996], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5031 : 	m_iAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR = getDefineINT("AI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR");

	push	1
	push	OFFSET $SG230673
	mov	ecx, esi
	mov	DWORD PTR [esi+2000], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5032 : 	m_iAI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED = getDefineINT("AI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED");

	push	1
	push	OFFSET $SG230674
	mov	ecx, esi
	mov	DWORD PTR [esi+2004], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5033 : 	m_iAI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT = getDefineINT("AI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT");

	push	1
	push	OFFSET $SG230675
	mov	ecx, esi
	mov	DWORD PTR [esi+2008], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5034 : 	m_fAI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO = getDefineFLOAT("AI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO");

	push	1
	push	OFFSET $SG230676
	mov	ecx, esi
	mov	DWORD PTR [esi+2012], eax
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+2016]

; 5035 : 	m_iAI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT = getDefineINT("AI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT");

	push	1
	push	OFFSET $SG230677
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5036 : 	m_iAI_STRATEGY_AREA_IS_FULL_PERCENT = getDefineINT("AI_STRATEGY_AREA_IS_FULL_PERCENT");

	push	1
	push	OFFSET $SG230678
	mov	ecx, esi
	mov	DWORD PTR [esi+2020], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5037 : 	m_iAI_STRATEGY_MINIMUM_SETTLE_FERTILITY = getDefineINT("AI_STRATEGY_MINIMUM_SETTLE_FERTILITY");

	push	1
	push	OFFSET $SG230679
	mov	ecx, esi
	mov	DWORD PTR [esi+2024], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5038 : 	m_iAI_BUY_PLOT_TEST_PROBES = getDefineINT("AI_BUY_PLOT_TEST_PROBES");

	push	1
	mov	DWORD PTR [esi+2028], eax
	push	OFFSET $SG230680
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5039 : 	m_iAI_PLOT_VALUE_STRATEGIC_RESOURCE = getDefineINT("AI_PLOT_VALUE_STRATEGIC_RESOURCE");

	push	1
	push	OFFSET $SG230681
	mov	ecx, esi
	mov	DWORD PTR [esi+2032], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5040 : 	m_iAI_PLOT_VALUE_LUXURY_RESOURCE = getDefineINT("AI_PLOT_VALUE_LUXURY_RESOURCE");

	push	1
	push	OFFSET $SG230682
	mov	ecx, esi
	mov	DWORD PTR [esi+2036], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5041 : 	m_iAI_PLOT_VALUE_SPECIALIZATION_MULTIPLIER = getDefineINT("AI_PLOT_VALUE_SPECIALIZATION_MULTIPLIER");

	push	1
	push	OFFSET $SG230683
	mov	ecx, esi
	mov	DWORD PTR [esi+2040], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5042 : 	m_iAI_PLOT_VALUE_YIELD_MULTIPLIER = getDefineINT("AI_PLOT_VALUE_YIELD_MULTIPLIER");

	push	1
	push	OFFSET $SG230684
	mov	ecx, esi
	mov	DWORD PTR [esi+2044], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5043 : 	m_iAI_PLOT_VALUE_DEFICIENT_YIELD_MULTIPLIER = getDefineINT("AI_PLOT_VALUE_DEFICIENT_YIELD_MULTIPLIER");

	push	1
	push	OFFSET $SG230685
	mov	ecx, esi
	mov	DWORD PTR [esi+2048], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5044 : 	m_iAI_PLOT_VALUE_FIERCE_DISPUTE = getDefineINT("AI_PLOT_VALUE_FIERCE_DISPUTE");

	push	1
	push	OFFSET $SG230686
	mov	ecx, esi
	mov	DWORD PTR [esi+2052], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5045 : 	m_iAI_PLOT_VALUE_STRONG_DISPUTE = getDefineINT("AI_PLOT_VALUE_STRONG_DISPUTE");

	push	1
	push	OFFSET $SG230687
	mov	ecx, esi
	mov	DWORD PTR [esi+2056], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5046 : 	m_iAI_PLOT_VALUE_WEAK_DISPUTE = getDefineINT("AI_PLOT_VALUE_WEAK_DISPUTE");

	push	1
	push	OFFSET $SG230688
	mov	ecx, esi
	mov	DWORD PTR [esi+2060], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5047 : 	m_iAI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE = getDefineINT("AI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE");

	push	1
	push	OFFSET $SG230689
	mov	ecx, esi
	mov	DWORD PTR [esi+2064], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5048 : 	m_iAI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM = getDefineINT("AI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM");

	push	1
	push	OFFSET $SG230690
	mov	ecx, esi
	mov	DWORD PTR [esi+2068], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5049 : 	m_iAI_GOLD_PRIORITY_UPGRADE_BASE = getDefineINT("AI_GOLD_PRIORITY_UPGRADE_BASE");

	push	1
	push	OFFSET $SG230691
	mov	ecx, esi
	mov	DWORD PTR [esi+2072], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5050 : 	m_iAI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT = getDefineINT("AI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT");

	push	1
	push	OFFSET $SG230692
	mov	ecx, esi
	mov	DWORD PTR [esi+2076], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5051 : 	m_iAI_GOLD_PRIORITY_DIPLOMACY_BASE = getDefineINT("AI_GOLD_PRIORITY_DIPLOMACY_BASE");

	push	1
	push	OFFSET $SG230693
	mov	ecx, esi
	mov	DWORD PTR [esi+2080], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5052 : 	m_iAI_GOLD_PRIORITY_DIPLOMACY_PER_FLAVOR_POINT = getDefineINT("AI_GOLD_PRIORITY_DIPLOMACY_PER_FLAVOR_POINT");

	push	1
	push	OFFSET $SG230694
	mov	ecx, esi
	mov	DWORD PTR [esi+2084], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5053 : 	m_iAI_GOLD_PRIORITY_UNIT = getDefineINT("AI_GOLD_PRIORITY_UNIT");

	push	1
	push	OFFSET $SG230695
	mov	ecx, esi
	mov	DWORD PTR [esi+2088], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5054 : 	m_iAI_GOLD_PRIORITY_DEFENSIVE_BUILDING = getDefineINT("AI_GOLD_PRIORITY_DEFENSIVE_BUILDING");

	push	1
	push	OFFSET $SG230696
	mov	ecx, esi
	mov	DWORD PTR [esi+2092], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5055 : 	m_iAI_GOLD_PRIORITY_BUYOUT_CITY_STATE = getDefineINT("AI_GOLD_PRIORITY_BUYOUT_CITY_STATE");

	push	1
	push	OFFSET $SG230697
	mov	ecx, esi
	mov	DWORD PTR [esi+2096], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5056 : 	m_iBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD = getDefineINT("BUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD");

	push	1
	push	OFFSET $SG230698
	mov	ecx, esi
	mov	DWORD PTR [esi+2100], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5057 : 	m_iBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION = getDefineINT("BUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION");

	push	1
	push	OFFSET $SG230699
	mov	ecx, esi
	mov	DWORD PTR [esi+2104], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5058 : 	m_iBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD = getDefineINT("BUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD");

	push	1
	push	OFFSET $SG230700
	mov	ecx, esi
	mov	DWORD PTR [esi+2108], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5059 : 	m_iBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE = getDefineINT("BUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE");

	push	1
	push	OFFSET $SG230701
	mov	ecx, esi
	mov	DWORD PTR [esi+2112], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5060 : 	m_iBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE = getDefineINT("BUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE");

	push	1
	push	OFFSET $SG230702
	mov	ecx, esi
	mov	DWORD PTR [esi+2116], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5061 : 	m_iBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE = getDefineINT("BUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE");

	push	1
	push	OFFSET $SG230703
	mov	ecx, esi
	mov	DWORD PTR [esi+2120], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5062 : 	m_iBUILDER_TASKING_IMPROVE_RESOURCE_TENDENCY = getDefineINT("BUILDER_TASKING_IMPROVE_RESOURCE_TENDENCY");

	push	1
	push	OFFSET $SG230704
	mov	ecx, esi
	mov	DWORD PTR [esi+2124], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5063 : 	m_iBUILDER_TASKING_BUILD_ROUTE_TENDENCY = getDefineINT("BUILDER_TASKING_BUILD_ROUTE_TENDENCY");

	push	1
	push	OFFSET $SG230705
	mov	ecx, esi
	mov	DWORD PTR [esi+2128], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5064 : 	m_iBUILDER_TASKING_DIRECTIVES_TO_EVALUATE = getDefineINT("BUILDER_TASKING_DIRECTIVES_TO_EVALUATE");

	push	1
	push	OFFSET $SG230706
	mov	ecx, esi
	mov	DWORD PTR [esi+2132], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5065 : 	m_iBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS = getDefineINT("BUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS");

	push	1
	push	OFFSET $SG230707
	mov	ecx, esi
	mov	DWORD PTR [esi+2136], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5066 : 	m_iBUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS = getDefineINT("BUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS");

	push	1
	push	OFFSET $SG230708
	mov	ecx, esi
	mov	DWORD PTR [esi+2140], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5067 : 	m_iBUILDER_TASKING_BASELINE_BUILD_ROUTES = getDefineINT("BUILDER_TASKING_BASELINE_BUILD_ROUTES");

	push	1
	push	OFFSET $SG230709
	mov	ecx, esi
	mov	DWORD PTR [esi+2144], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5068 : 	m_iBUILDER_TASKING_BASELINE_REPAIR = getDefineINT("BUILDER_TASKING_BASELINE_REPAIR");

	push	1
	push	OFFSET $SG230710
	mov	ecx, esi
	mov	DWORD PTR [esi+2148], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5069 : 	m_iBUILDER_TASKING_BASELINE_SCRUB_FALLOUT = getDefineINT("BUILDER_TASKING_BASELINE_SCRUB_FALLOUT");

	push	1
	push	OFFSET $SG230711
	mov	ecx, esi
	mov	DWORD PTR [esi+2152], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5070 : 	m_iBUILDER_TASKING_BASELINE_ADDS_CULTURE = getDefineINT("BUILDER_TASKING_BASELINE_ADDS_CULTURE");

	push	1
	push	OFFSET $SG230712
	mov	ecx, esi
	mov	DWORD PTR [esi+2156], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+2160], eax

; 5071 : 	m_iAI_MILITARY_THREAT_WEIGHT_MINOR = getDefineINT("AI_MILITARY_THREAT_WEIGHT_MINOR");

	push	1
	push	OFFSET $SG230713
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5072 : 	m_iAI_MILITARY_THREAT_WEIGHT_MAJOR = getDefineINT("AI_MILITARY_THREAT_WEIGHT_MAJOR");

	push	1
	push	OFFSET $SG230714
	mov	ecx, esi
	mov	DWORD PTR [esi+2164], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5073 : 	m_iAI_MILITARY_THREAT_WEIGHT_SEVERE = getDefineINT("AI_MILITARY_THREAT_WEIGHT_SEVERE");

	push	1
	push	OFFSET $SG230715
	mov	ecx, esi
	mov	DWORD PTR [esi+2168], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5074 : 	m_iAI_MILITARY_THREAT_WEIGHT_CRITICAL = getDefineINT("AI_MILITARY_THREAT_WEIGHT_CRITICAL");

	push	1
	push	OFFSET $SG230716
	mov	ecx, esi
	mov	DWORD PTR [esi+2172], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5075 : 	m_iAI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS = getDefineINT("AI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS");

	push	1
	push	OFFSET $SG230717
	mov	ecx, esi
	mov	DWORD PTR [esi+2176], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5076 : 	m_iAI_STRATEGY_MILITARY_RESERVE_PERCENTAGE = getDefineINT("AI_STRATEGY_MILITARY_RESERVE_PERCENTAGE");

	push	1
	push	OFFSET $SG230718
	mov	ecx, esi
	mov	DWORD PTR [esi+2180], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5077 : 	m_iAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL = getDefineINT("AI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL");

	push	1
	push	OFFSET $SG230719
	mov	ecx, esi
	mov	DWORD PTR [esi+2184], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5078 : 	m_iAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT = getDefineINT("AI_MILITARY_BARBARIANS_FOR_MINOR_THREAT");

	push	1
	push	OFFSET $SG230720
	mov	ecx, esi
	mov	DWORD PTR [esi+2188], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5079 : 	m_iAI_MILITARY_IGNORE_BAD_ODDS = getDefineINT("AI_MILITARY_IGNORE_BAD_ODDS");

	push	1
	push	OFFSET $SG230721
	mov	ecx, esi
	mov	DWORD PTR [esi+2192], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5080 : 	m_iAI_MILITARY_RECAPTURING_OWN_CITY = getDefineINT("AI_MILITARY_RECAPTURING_OWN_CITY");

	push	1
	push	OFFSET $SG230722
	mov	ecx, esi
	mov	DWORD PTR [esi+2196], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5081 : 	m_iAI_MILITARY_CAPTURING_ORIGINAL_CAPITAL = getDefineINT("AI_MILITARY_CAPTURING_ORIGINAL_CAPITAL");

	push	1
	push	OFFSET $SG230723
	mov	ecx, esi
	mov	DWORD PTR [esi+2200], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5082 : 	m_iAI_CITY_SPECIALIZATION_EARLIEST_TURN = getDefineINT("AI_CITY_SPECIALIZATION_EARLIEST_TURN");

	push	1
	push	OFFSET $SG230724
	mov	ecx, esi
	mov	DWORD PTR [esi+2204], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5083 : 	m_iAI_CITY_SPECIALIZATION_REEVALUATION_INTERVAL = getDefineINT("AI_CITY_SPECIALIZATION_REEVALUATION_INTERVAL");

	push	1
	push	OFFSET $SG230725
	mov	ecx, esi
	mov	DWORD PTR [esi+2208], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5084 : 	m_iAI_CITY_SPECIALIZATION_GENERAL_ECONOMIC_WEIGHT = getDefineINT("AI_CITY_SPECIALIZATION_GENERAL_ECONOMIC_WEIGHT");

	push	1
	push	OFFSET $SG230726
	mov	ecx, esi
	mov	DWORD PTR [esi+2212], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5085 : 	m_iAI_CITY_SPECIALIZATION_FOOD_WEIGHT_FLAVOR_EXPANSION = getDefineINT("AI_CITY_SPECIALIZATION_FOOD_WEIGHT_FLAVOR_EXPANSION");

	push	1
	push	OFFSET $SG230727
	mov	ecx, esi
	mov	DWORD PTR [esi+2216], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5086 : 	m_iAI_CITY_SPECIALIZATION_FOOD_WEIGHT_PERCENT_CONTINENT_UNOWNED = getDefineINT("AI_CITY_SPECIALIZATION_FOOD_WEIGHT_PERCENT_CONTINENT_UNOWNED");

	push	1
	push	OFFSET $SG230728
	mov	ecx, esi
	mov	DWORD PTR [esi+2220], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+2224], eax

; 5087 : 	m_iAI_CITY_SPECIALIZATION_FOOD_WEIGHT_NUM_CITIES = getDefineINT("AI_CITY_SPECIALIZATION_FOOD_WEIGHT_NUM_CITIES");

	push	1
	push	OFFSET $SG230729
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5088 : 	m_iAI_CITY_SPECIALIZATION_FOOD_WEIGHT_NUM_SETTLERS = getDefineINT("AI_CITY_SPECIALIZATION_FOOD_WEIGHT_NUM_SETTLERS");

	push	1
	push	OFFSET $SG230730
	mov	ecx, esi
	mov	DWORD PTR [esi+2228], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5089 : 	m_iAI_CITY_SPECIALIZATION_FOOD_WEIGHT_EARLY_EXPANSION = getDefineINT("AI_CITY_SPECIALIZATION_FOOD_WEIGHT_EARLY_EXPANSION");

	push	1
	push	OFFSET $SG230731
	mov	ecx, esi
	mov	DWORD PTR [esi+2232], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5090 : 	m_iAI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_OPERATIONAL_UNITS_REQUESTED = getDefineINT("AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_OPERATIONAL_UNITS_REQUESTED");

	push	1
	push	OFFSET $SG230732
	mov	ecx, esi
	mov	DWORD PTR [esi+2236], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5091 : 	m_iAI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_CIVS_AT_WAR_WITH = getDefineINT("AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_CIVS_AT_WAR_WITH");

	push	1
	push	OFFSET $SG230733
	mov	ecx, esi
	mov	DWORD PTR [esi+2240], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5092 : 	m_iAI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_WAR_MOBILIZATION = getDefineINT("AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_WAR_MOBILIZATION");

	push	1
	push	OFFSET $SG230734
	mov	ecx, esi
	mov	DWORD PTR [esi+2244], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5093 : 	m_iAI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_EMPIRE_DEFENSE = getDefineINT("AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_EMPIRE_DEFENSE");

	push	1
	push	OFFSET $SG230735
	mov	ecx, esi
	mov	DWORD PTR [esi+2248], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5094 : 	m_iAI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_EMPIRE_DEFENSE_CRITICAL = getDefineINT("AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_EMPIRE_DEFENSE_CRITICAL");

	push	1
	push	OFFSET $SG230736
	mov	ecx, esi
	mov	DWORD PTR [esi+2252], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5095 : 	m_iAI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_CAPITAL_THREAT = getDefineINT("AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_CAPITAL_THREAT");

	push	1
	push	OFFSET $SG230737
	mov	ecx, esi
	mov	DWORD PTR [esi+2256], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5096 : 	m_iAI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_NEED_NAVAL_UNITS = getDefineINT("AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_NEED_NAVAL_UNITS");

	push	1
	push	OFFSET $SG230738
	mov	ecx, esi
	mov	DWORD PTR [esi+2260], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5097 : 	m_iAI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_NEED_NAVAL_UNITS_CRITICAL = getDefineINT("AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_NEED_NAVAL_UNITS_CRITICAL");

	push	1
	push	OFFSET $SG230739
	mov	ecx, esi
	mov	DWORD PTR [esi+2264], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5098 : 	m_iAI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_FLAVOR_WONDER = getDefineINT("AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_FLAVOR_WONDER");

	push	1
	push	OFFSET $SG230740
	mov	ecx, esi
	mov	DWORD PTR [esi+2268], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5099 : 	m_iAI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_FLAVOR_SPACESHIP = getDefineINT("AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_FLAVOR_SPACESHIP");

	push	1
	push	OFFSET $SG230741
	mov	ecx, esi
	mov	DWORD PTR [esi+2272], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5100 : 	m_iAI_CITY_SPECIALIZATION_PRODUCTION_TRAINING_PER_OFFENSE = getDefineINT("AI_CITY_SPECIALIZATION_PRODUCTION_TRAINING_PER_OFFENSE");

	push	1
	push	OFFSET $SG230742
	mov	ecx, esi
	mov	DWORD PTR [esi+2276], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5101 : 	m_iAI_CITY_SPECIALIZATION_PRODUCTION_TRAINING_PER_PERSONALITY = getDefineINT("AI_CITY_SPECIALIZATION_PRODUCTION_TRAINING_PER_PERSONALITY");

	push	1
	push	OFFSET $SG230743
	mov	ecx, esi
	mov	DWORD PTR [esi+2280], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5102 : 	m_iAI_CITY_SPECIALIZATION_GOLD_WEIGHT_FLAVOR_GOLD = getDefineINT("AI_CITY_SPECIALIZATION_GOLD_WEIGHT_FLAVOR_GOLD");

	push	1
	push	OFFSET $SG230744
	mov	ecx, esi
	mov	DWORD PTR [esi+2284], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5103 : 	m_iAI_CITY_SPECIALIZATION_GOLD_WEIGHT_LAND_DISPUTE = getDefineINT("AI_CITY_SPECIALIZATION_GOLD_WEIGHT_LAND_DISPUTE");

	push	1
	mov	DWORD PTR [esi+2288], eax
	push	OFFSET $SG230745
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5104 : 	m_iAI_CITY_SPECIALIZATION_SCIENCE_WEIGHT_FLAVOR_SCIENCE = getDefineINT("AI_CITY_SPECIALIZATION_SCIENCE_WEIGHT_FLAVOR_SCIENCE");

	push	1
	push	OFFSET $SG230746
	mov	ecx, esi
	mov	DWORD PTR [esi+2292], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5105 : 	m_iAI_CITY_SPECIALIZATION_SCIENCE_WEIGHT_FLAVOR_SPACESHIP = getDefineINT("AI_CITY_SPECIALIZATION_SCIENCE_WEIGHT_FLAVOR_SPACESHIP");

	push	1
	push	OFFSET $SG230747
	mov	ecx, esi
	mov	DWORD PTR [esi+2296], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5106 : 	m_iAI_CITY_SPECIALIZATION_YIELD_WEIGHT_FIRST_RING = getDefineINT("AI_CITY_SPECIALIZATION_YIELD_WEIGHT_FIRST_RING");

	push	1
	push	OFFSET $SG230748
	mov	ecx, esi
	mov	DWORD PTR [esi+2300], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5107 : 	m_iAI_CITY_SPECIALIZATION_YIELD_WEIGHT_SECOND_RING = getDefineINT("AI_CITY_SPECIALIZATION_YIELD_WEIGHT_SECOND_RING");

	push	1
	push	OFFSET $SG230749
	mov	ecx, esi
	mov	DWORD PTR [esi+2304], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5108 : 	m_iAI_CITY_SPECIALIZATION_YIELD_WEIGHT_THIRD_RING = getDefineINT("AI_CITY_SPECIALIZATION_YIELD_WEIGHT_THIRD_RING");

	push	1
	push	OFFSET $SG230750
	mov	ecx, esi
	mov	DWORD PTR [esi+2308], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5109 : 	m_iAI_CITY_SPECIALIZATION_YIELD_NUM_TILES_CONSIDERED = getDefineINT("AI_CITY_SPECIALIZATION_YIELD_NUM_TILES_CONSIDERED");

	push	1
	push	OFFSET $SG230751
	mov	ecx, esi
	mov	DWORD PTR [esi+2312], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5110 : 	m_iAI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD = getDefineINT("AI_CITYSTRATEGY_SMALL_CITY_POP_THRESHOLD");

	push	1
	push	OFFSET $SG230752
	mov	ecx, esi
	mov	DWORD PTR [esi+2316], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5111 : 	m_iAI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD = getDefineINT("AI_CITYSTRATEGY_MEDIUM_CITY_POP_THRESHOLD");

	push	1
	push	OFFSET $SG230753
	mov	ecx, esi
	mov	DWORD PTR [esi+2320], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5112 : 	m_iAI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD = getDefineINT("AI_CITYSTRATEGY_LARGE_CITY_POP_THRESHOLD");

	push	1
	push	OFFSET $SG230754
	mov	ecx, esi
	mov	DWORD PTR [esi+2324], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5113 : 	m_iAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_CITY_THRESHOLD = getDefineINT("AI_CITYSTRATEGY_NEED_TILE_IMPROVERS_CITY_THRESHOLD");

	push	1
	push	OFFSET $SG230755
	mov	ecx, esi
	mov	DWORD PTR [esi+2328], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5114 : 	m_iAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_WORKER_MOD = getDefineINT("AI_CITYSTRATEGY_NEED_TILE_IMPROVERS_WORKER_MOD");

	push	1
	push	OFFSET $SG230756
	mov	ecx, esi
	mov	DWORD PTR [esi+2332], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5115 : 	m_iAI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN = getDefineINT("AI_CITYSTRATEGY_NEED_TILE_IMPROVERS_DESPERATE_TURN");

	push	1
	push	OFFSET $SG230757
	mov	ecx, esi
	mov	DWORD PTR [esi+2336], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5116 : 	m_iAI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE = getDefineINT("AI_CITYSTRATEGY_WANT_TILE_IMPROVERS_MINIMUM_SIZE");

	push	1
	push	OFFSET $SG230758
	mov	ecx, esi
	mov	DWORD PTR [esi+2340], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5117 : 	m_fAI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD = getDefineFLOAT("AI_CITYSTRATEGY_YIELD_DEFICIENT_FOOD");

	push	1
	push	OFFSET $SG230759
	mov	ecx, esi
	mov	DWORD PTR [esi+2344], eax
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+2348]

; 5118 : 	m_fAI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION = getDefineFLOAT("AI_CITYSTRATEGY_YIELD_DEFICIENT_PRODUCTION");

	push	1
	push	OFFSET $SG230760
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+2352]

; 5119 : 	m_fAI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD = getDefineFLOAT("AI_CITYSTRATEGY_YIELD_DEFICIENT_GOLD");

	push	1
	push	OFFSET $SG230761
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+2356]

; 5120 : 	m_fAI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE = getDefineFLOAT("AI_CITYSTRATEGY_YIELD_DEFICIENT_SCIENCE");

	push	1
	push	OFFSET $SG230762
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+2360]

; 5121 : 	m_iAI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT = getDefineINT("AI_CITYSTRATEGY_OPERATION_UNIT_BASE_WEIGHT");

	push	1
	push	OFFSET $SG230763
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5122 : 	m_iAI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER = getDefineINT("AI_CITYSTRATEGY_OPERATION_UNIT_FLAVOR_MULTIPLIER");

	push	1
	push	OFFSET $SG230764
	mov	ecx, esi
	mov	DWORD PTR [esi+2364], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5123 : 	m_iAI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT = getDefineINT("AI_CITYSTRATEGY_ARMY_UNIT_BASE_WEIGHT");

	push	1
	push	OFFSET $SG230765
	mov	ecx, esi
	mov	DWORD PTR [esi+2368], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5124 : 	m_iAI_CITIZEN_VALUE_FOOD = getDefineINT("AI_CITIZEN_VALUE_FOOD");

	push	1
	push	OFFSET $SG230766
	mov	ecx, esi
	mov	DWORD PTR [esi+2372], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5125 : 	m_iAI_CITIZEN_VALUE_PRODUCTION = getDefineINT("AI_CITIZEN_VALUE_PRODUCTION");

	push	1
	push	OFFSET $SG230767
	mov	ecx, esi
	mov	DWORD PTR [esi+2376], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5126 : 	m_iAI_CITIZEN_VALUE_GOLD = getDefineINT("AI_CITIZEN_VALUE_GOLD");

	push	1
	push	OFFSET $SG230768
	mov	ecx, esi
	mov	DWORD PTR [esi+2380], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5127 : 	m_iAI_CITIZEN_VALUE_SCIENCE = getDefineINT("AI_CITIZEN_VALUE_SCIENCE");

	push	1
	push	OFFSET $SG230769
	mov	ecx, esi
	mov	DWORD PTR [esi+2384], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5128 : 	m_iAI_CITIZEN_VALUE_CULTURE = getDefineINT("AI_CITIZEN_VALUE_CULTURE");

	push	1
	push	OFFSET $SG230770
	mov	ecx, esi
	mov	DWORD PTR [esi+2388], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5129 : 	m_iAI_CITIZEN_VALUE_FAITH = getDefineINT("AI_CITIZEN_VALUE_FAITH");

	push	1
	push	OFFSET $SG230771
	mov	ecx, esi
	mov	DWORD PTR [esi+2392], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5130 : 	m_iAI_CITIZEN_FOOD_MOD_SIZE_CUTOFF = getDefineINT("AI_CITIZEN_FOOD_MOD_SIZE_CUTOFF");

	push	1
	push	OFFSET $SG230772
	mov	ecx, esi
	mov	DWORD PTR [esi+2396], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5131 : 	m_iAI_CITIZEN_FOOD_MOD_SIZE_EXPONENT = getDefineINT("AI_CITIZEN_FOOD_MOD_SIZE_EXPONENT");

	push	1
	push	OFFSET $SG230773
	mov	ecx, esi
	mov	DWORD PTR [esi+2400], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5132 : 	m_iAI_CITIZEN_MOD_FOOD_DEFICIT = getDefineINT("AI_CITIZEN_MOD_FOOD_DEFICIT");

	push	1
	push	OFFSET $SG230774
	mov	ecx, esi
	mov	DWORD PTR [esi+2404], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5133 : 	m_iAI_CITIZEN_MOD_PRODUCTION_DEFICIT = getDefineINT("AI_CITIZEN_MOD_PRODUCTION_DEFICIT");

	push	1
	push	OFFSET $SG230775
	mov	ecx, esi
	mov	DWORD PTR [esi+2408], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5134 : 	m_iAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE = getDefineINT("AI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE");

	push	1
	push	OFFSET $SG230776
	mov	ecx, esi
	mov	DWORD PTR [esi+2412], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5135 : 	m_iAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE = getDefineINT("AI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE");

	push	1
	push	OFFSET $SG230777
	mov	ecx, esi
	mov	DWORD PTR [esi+2416], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5136 : 	m_iAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE = getDefineINT("AI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE");

	push	1
	push	OFFSET $SG230778
	mov	ecx, esi
	mov	DWORD PTR [esi+2420], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5137 : 	m_iAI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE = getDefineINT("AI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE");

	push	1
	push	OFFSET $SG230779
	mov	ecx, esi
	mov	DWORD PTR [esi+2424], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5138 : 	m_iAI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER = getDefineINT("AI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER");

	push	1
	push	OFFSET $SG230780
	mov	ecx, esi
	mov	DWORD PTR [esi+2428], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5139 : 	m_iAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION = getDefineINT("AI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION");

	push	1
	push	OFFSET $SG230781
	mov	ecx, esi
	mov	DWORD PTR [esi+2432], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5140 : 	m_iAI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER = getDefineINT("AI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER");

	push	1
	push	OFFSET $SG230782
	mov	ecx, esi
	mov	DWORD PTR [esi+2436], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5141 : 	m_iAI_TACTICAL_MAP_DOMINANCE_PERCENTAGE = getDefineINT("AI_TACTICAL_MAP_DOMINANCE_PERCENTAGE");

	push	1
	push	OFFSET $SG230783
	mov	ecx, esi
	mov	DWORD PTR [esi+2440], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5142 : 	m_iAI_TACTICAL_MAP_TEMP_ZONE_RADIUS = getDefineINT("AI_TACTICAL_MAP_TEMP_ZONE_RADIUS");

	push	1
	push	OFFSET $SG230784
	mov	ecx, esi
	mov	DWORD PTR [esi+2444], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5143 : 	m_iAI_TACTICAL_MAP_TEMP_ZONE_TURNS = getDefineINT("AI_TACTICAL_MAP_TEMP_ZONE_TURNS");

	push	1
	push	OFFSET $SG230785
	mov	ecx, esi
	mov	DWORD PTR [esi+2448], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5144 : 	m_iAI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS = getDefineINT("AI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS");

	push	1
	push	OFFSET $SG230786
	mov	ecx, esi
	mov	DWORD PTR [esi+2452], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5145 : 	m_iAI_TACTICAL_RECRUIT_RANGE = getDefineINT("AI_TACTICAL_RECRUIT_RANGE");

	push	1
	push	OFFSET $SG230787
	mov	ecx, esi
	mov	DWORD PTR [esi+2456], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5146 : 	m_iAI_TACTICAL_REPOSITION_RANGE = getDefineINT("AI_TACTICAL_REPOSITION_RANGE");

	push	1
	push	OFFSET $SG230788
	mov	ecx, esi
	mov	DWORD PTR [esi+2460], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5147 : 	m_iAI_TACTICAL_OVERKILL_PERCENT = getDefineINT("AI_TACTICAL_OVERKILL_PERCENT");

	push	1
	push	OFFSET $SG230789
	mov	ecx, esi
	mov	DWORD PTR [esi+2464], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5148 : 	m_iAI_TACTICAL_BARBARIAN_RELEASE_VARIATION = getDefineINT("AI_TACTICAL_BARBARIAN_RELEASE_VARIATION");

	push	1
	push	OFFSET $SG230790
	mov	ecx, esi
	mov	DWORD PTR [esi+2468], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5149 : 	m_iAI_TACTICAL_MOVE_PRIORITY_RANDOMNESS = getDefineINT("AI_TACTICAL_MOVE_PRIORITY_RANDOMNESS");

	push	1
	push	OFFSET $SG230791
	mov	ecx, esi
	mov	DWORD PTR [esi+2472], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5150 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_CAPTURE_CITY = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_CAPTURE_CITY");

	push	1
	push	OFFSET $SG230792
	mov	ecx, esi
	mov	DWORD PTR [esi+2476], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5151 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_DAMAGE_CITY = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_DAMAGE_CITY");

	push	1
	push	OFFSET $SG230793
	mov	ecx, esi
	mov	DWORD PTR [esi+2480], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+2484], eax

; 5152 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_HIGH_UNIT = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_HIGH_UNIT");

	push	1
	push	OFFSET $SG230794
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5153 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_MEDIUM_UNIT = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_MEDIUM_UNIT");

	push	1
	push	OFFSET $SG230795
	mov	ecx, esi
	mov	DWORD PTR [esi+2488], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5154 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_LOW_UNIT = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_DESTROY_LOW_UNIT");

	push	1
	push	OFFSET $SG230796
	mov	ecx, esi
	mov	DWORD PTR [esi+2492], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5155 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_TO_SAFETY = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_TO_SAFETY");

	push	1
	push	OFFSET $SG230797
	mov	ecx, esi
	mov	DWORD PTR [esi+2496], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5156 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_HIGH_UNIT = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_HIGH_UNIT");

	push	1
	push	OFFSET $SG230798
	mov	ecx, esi
	mov	DWORD PTR [esi+2500], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5157 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_MEDIUM_UNIT = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_MEDIUM_UNIT");

	push	1
	push	OFFSET $SG230799
	mov	ecx, esi
	mov	DWORD PTR [esi+2504], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5158 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_LOW_UNIT = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_ATTRIT_LOW_UNIT");

	push	1
	push	OFFSET $SG230800
	mov	ecx, esi
	mov	DWORD PTR [esi+2508], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5159 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_DESPERATE_ATTACK = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_DESPERATE_ATTACK");

	push	1
	push	OFFSET $SG230801
	mov	ecx, esi
	mov	DWORD PTR [esi+2512], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5160 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE");

	push	1
	push	OFFSET $SG230802
	mov	ecx, esi
	mov	DWORD PTR [esi+2516], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5161 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_CITADEL = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_CITADEL");

	push	1
	push	OFFSET $SG230803
	mov	ecx, esi
	mov	DWORD PTR [esi+2520], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5162 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_NEXT_TURN = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_PILLAGE_NEXT_TURN");

	push	1
	push	OFFSET $SG230804
	mov	ecx, esi
	mov	DWORD PTR [esi+2524], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5163 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_BLOCKADE_RESOURCE");

	push	1
	push	OFFSET $SG230805
	mov	ecx, esi
	mov	DWORD PTR [esi+2528], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5164 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_CIVILIAN_ATTACK = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_CIVILIAN_ATTACK");

	push	1
	push	OFFSET $SG230806
	mov	ecx, esi
	mov	DWORD PTR [esi+2532], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5165 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_PASSIVE_MOVE = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_PASSIVE_MOVE");

	push	1
	push	OFFSET $SG230807
	mov	ecx, esi
	mov	DWORD PTR [esi+2536], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5166 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_AGGRESSIVE_MOVE = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_AGGRESSIVE_MOVE");

	push	1
	push	OFFSET $SG230808
	mov	ecx, esi
	mov	DWORD PTR [esi+2540], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5167 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_CAMP_DEFENSE = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_CAMP_DEFENSE");

	push	1
	push	OFFSET $SG230809
	mov	ecx, esi
	mov	DWORD PTR [esi+2544], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+2548], eax

; 5168 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_ESCORT_CIVILIAN = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_ESCORT_CIVILIAN");

	push	1
	push	OFFSET $SG230810
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5169 : 	m_iAI_TACTICAL_BARBARIAN_PRIORITY_PLUNDER_TRADE_UNIT = getDefineINT("AI_TACTICAL_BARBARIAN_PRIORITY_PLUNDER_TRADE_UNIT");

	push	1
	push	OFFSET $SG230811
	mov	ecx, esi
	mov	DWORD PTR [esi+2552], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5170 : 	m_iAI_HOMELAND_MOVE_PRIORITY_RANDOMNESS = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_RANDOMNESS");

	push	1
	push	OFFSET $SG230812
	mov	ecx, esi
	mov	DWORD PTR [esi+2556], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5171 : 	m_iAI_HOMELAND_MAX_UPGRADE_MOVE_TURNS = getDefineINT("AI_HOMELAND_MAX_UPGRADE_MOVE_TURNS");

	push	1
	push	OFFSET $SG230813
	mov	ecx, esi
	mov	DWORD PTR [esi+2560], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5172 : 	m_iAI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS = getDefineINT("AI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS");

	push	1
	push	OFFSET $SG230814
	mov	ecx, esi
	mov	DWORD PTR [esi+2564], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5173 : 	m_iAI_HOMELAND_ESTIMATE_TURNS_DISTANCE = getDefineINT("AI_HOMELAND_ESTIMATE_TURNS_DISTANCE");

	push	1
	push	OFFSET $SG230815
	mov	ecx, esi
	mov	DWORD PTR [esi+2568], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5174 : 	m_iAI_HOMELAND_MOVE_PRIORITY_SETTLE = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_SETTLE");

	push	1
	push	OFFSET $SG230816
	mov	ecx, esi
	mov	DWORD PTR [esi+2572], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5175 : 	m_iAI_HOMELAND_MOVE_PRIORITY_HEAL = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_HEAL");

	push	1
	push	OFFSET $SG230817
	mov	ecx, esi
	mov	DWORD PTR [esi+2576], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5176 : 	m_iAI_HOMELAND_MOVE_PRIORITY_TO_SAFETY = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_TO_SAFETY");

	push	1
	push	OFFSET $SG230818
	mov	ecx, esi
	mov	DWORD PTR [esi+2580], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5177 : 	m_iAI_HOMELAND_MOVE_PRIORITY_WORKER = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_WORKER");

	push	1
	push	OFFSET $SG230819
	mov	ecx, esi
	mov	DWORD PTR [esi+2584], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5178 : 	m_iAI_HOMELAND_MOVE_PRIORITY_WORKER_SEA = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_WORKER_SEA");

	push	1
	push	OFFSET $SG230820
	mov	ecx, esi
	mov	DWORD PTR [esi+2588], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5179 : 	m_iAI_HOMELAND_MOVE_PRIORITY_EXPLORE = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_EXPLORE");

	push	1
	push	OFFSET $SG230821
	mov	ecx, esi
	mov	DWORD PTR [esi+2592], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5180 : 	m_iAI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA");

	push	1
	push	OFFSET $SG230822
	mov	ecx, esi
	mov	DWORD PTR [esi+2596], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5181 : 	m_iAI_HOMELAND_MOVE_PRIORITY_SENTRY = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_SENTRY");

	push	1
	push	OFFSET $SG230823
	mov	ecx, esi
	mov	DWORD PTR [esi+2600], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5182 : 	m_iAI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE");

	push	1
	push	OFFSET $SG230824
	mov	ecx, esi
	mov	DWORD PTR [esi+2604], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5183 : 	m_iAI_HOMELAND_MOVE_PRIORITY_GARRISON = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_GARRISON");

	push	1
	push	OFFSET $SG230825
	mov	ecx, esi
	mov	DWORD PTR [esi+2608], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5184 : 	m_iAI_HOMELAND_MOVE_PRIORITY_PATROL = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_PATROL");

	push	1
	mov	DWORD PTR [esi+2612], eax
	push	OFFSET $SG230826
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5185 : 	m_iAI_HOMELAND_MOVE_PRIORITY_UPGRADE = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_UPGRADE");

	push	1
	push	OFFSET $SG230827
	mov	ecx, esi
	mov	DWORD PTR [esi+2616], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5186 : 	m_iAI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS");

	push	1
	push	OFFSET $SG230828
	mov	ecx, esi
	mov	DWORD PTR [esi+2620], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5187 : 	m_iAI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE");

	push	1
	push	OFFSET $SG230829
	mov	ecx, esi
	mov	DWORD PTR [esi+2624], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5188 : 	m_iAI_HOMELAND_MOVE_PRIORITY_WRITER = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_WRITER");

	push	1
	push	OFFSET $SG230830
	mov	ecx, esi
	mov	DWORD PTR [esi+2628], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5189 : 	m_iAI_HOMELAND_MOVE_PRIORITY_ARTIST = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_ARTIST");

	push	1
	push	OFFSET $SG230831
	mov	ecx, esi
	mov	DWORD PTR [esi+2632], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5190 : 	m_iAI_HOMELAND_MOVE_PRIORITY_MUSICIAN = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_MUSICIAN");

	push	1
	push	OFFSET $SG230832
	mov	ecx, esi
	mov	DWORD PTR [esi+2636], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5191 : 	m_iAI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH");

	push	1
	push	OFFSET $SG230833
	mov	ecx, esi
	mov	DWORD PTR [esi+2640], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5192 : 	m_iAI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY");

	push	1
	push	OFFSET $SG230834
	mov	ecx, esi
	mov	DWORD PTR [esi+2644], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5193 : 	m_iAI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON");

	push	1
	push	OFFSET $SG230835
	mov	ecx, esi
	mov	DWORD PTR [esi+2648], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5194 : 	m_iAI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON");

	push	1
	push	OFFSET $SG230836
	mov	ecx, esi
	mov	DWORD PTR [esi+2652], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5195 : 	m_iAI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION");

	push	1
	push	OFFSET $SG230837
	mov	ecx, esi
	mov	DWORD PTR [esi+2656], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5196 : 	m_iAI_HOMELAND_MOVE_PRIORITY_MISSIONARY = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_MISSIONARY");

	push	1
	push	OFFSET $SG230838
	mov	ecx, esi
	mov	DWORD PTR [esi+2660], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5197 : 	m_iAI_HOMELAND_MOVE_PRIORITY_INQUISITOR = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_INQUISITOR");

	push	1
	push	OFFSET $SG230839
	mov	ecx, esi
	mov	DWORD PTR [esi+2664], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5198 : 	m_iAI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT");

	push	1
	push	OFFSET $SG230840
	mov	ecx, esi
	mov	DWORD PTR [esi+2668], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5199 : 	m_iAI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART");

	push	1
	push	OFFSET $SG230841
	mov	ecx, esi
	mov	DWORD PTR [esi+2680], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5200 : 	m_iAI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART");

	push	1
	mov	DWORD PTR [esi+2672], eax
	push	OFFSET $SG230842
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5201 : 	m_iAI_HOMELAND_MOVE_PRIORITY_TREASURE = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_TREASURE");

	push	1
	push	OFFSET $SG230843
	mov	ecx, esi
	mov	DWORD PTR [esi+2676], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5202 : 	m_iAI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT");

	push	1
	push	OFFSET $SG230844
	mov	ecx, esi
	mov	DWORD PTR [esi+2684], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5203 : 	m_iAI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST");

	push	1
	push	OFFSET $SG230845
	mov	ecx, esi
	mov	DWORD PTR [esi+2688], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5204 : 	m_iAI_HOMELAND_MOVE_PRIORITY_AIRLIFT = getDefineINT("AI_HOMELAND_MOVE_PRIORITY_AIRLIFT");

	push	1
	push	OFFSET $SG230846
	mov	ecx, esi
	mov	DWORD PTR [esi+2692], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5205 : 	m_iAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT = getDefineINT("AI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT");

	push	1
	push	OFFSET $SG230847
	mov	ecx, esi
	mov	DWORD PTR [esi+2696], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5206 : 	m_iAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT = getDefineINT("AI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT");

	push	1
	push	OFFSET $SG230848
	mov	ecx, esi
	mov	DWORD PTR [esi+2700], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5207 : 	m_iAI_DIPLO_LAND_DISPUTE_WEIGHT_WEAK = getDefineINT("AI_DIPLO_LAND_DISPUTE_WEIGHT_WEAK");

	push	1
	push	OFFSET $SG230849
	mov	ecx, esi
	mov	DWORD PTR [esi+2704], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5208 : 	m_iAI_DIPLO_LAND_DISPUTE_WEIGHT_STRONG = getDefineINT("AI_DIPLO_LAND_DISPUTE_WEIGHT_STRONG");

	push	1
	push	OFFSET $SG230850
	mov	ecx, esi
	mov	DWORD PTR [esi+2708], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5209 : 	m_iAI_DIPLO_LAND_DISPUTE_WEIGHT_FIERCE = getDefineINT("AI_DIPLO_LAND_DISPUTE_WEIGHT_FIERCE");

	push	1
	push	OFFSET $SG230851
	mov	ecx, esi
	mov	DWORD PTR [esi+2712], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5210 : 	m_iMINOR_BULLY_GOLD = getDefineINT("MINOR_BULLY_GOLD");

	push	1
	push	OFFSET $SG230852
	mov	ecx, esi
	mov	DWORD PTR [esi+2716], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5211 : 	m_iMINOR_FRIENDSHIP_RATE_MOD_MAXIMUM = getDefineINT("MINOR_FRIENDSHIP_RATE_MOD_MAXIMUM");

	push	1
	push	OFFSET $SG230853
	mov	ecx, esi
	mov	DWORD PTR [esi+2720], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5212 : 	m_iMINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION = getDefineINT("MINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION");

	push	1
	push	OFFSET $SG230854
	mov	ecx, esi
	mov	DWORD PTR [esi+2724], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5213 : 	m_iMINOR_FRIENDSHIP_DROP_PER_TURN = getDefineINT("MINOR_FRIENDSHIP_DROP_PER_TURN");

	push	1
	push	OFFSET $SG230855
	mov	ecx, esi
	mov	DWORD PTR [esi+2728], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5214 : 	m_iMINOR_FRIENDSHIP_DROP_PER_TURN_HOSTILE = getDefineINT("MINOR_FRIENDSHIP_DROP_PER_TURN_HOSTILE");

	push	1
	push	OFFSET $SG230856
	mov	ecx, esi
	mov	DWORD PTR [esi+2732], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5215 : 	m_iMINOR_FRIENDSHIP_DROP_PER_TURN_AGGRESSOR = getDefineINT("MINOR_FRIENDSHIP_DROP_PER_TURN_AGGRESSOR");

	push	1
	push	OFFSET $SG230857
	mov	ecx, esi
	mov	DWORD PTR [esi+2736], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5216 : 	m_iMINOR_FRIENDSHIP_DROP_DISHONOR_PLEDGE_TO_PROTECT = getDefineINT("MINOR_FRIENDSHIP_DROP_DISHONOR_PLEDGE_TO_PROTECT");

	push	1
	push	OFFSET $SG230858
	mov	ecx, esi
	mov	DWORD PTR [esi+2740], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5217 : 	m_iMINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS = getDefineINT("MINOR_FRIENDSHIP_DROP_BULLY_GOLD_SUCCESS");

	push	1
	push	OFFSET $SG230859
	mov	ecx, esi
	mov	DWORD PTR [esi+2744], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5218 : 	m_iMINOR_FRIENDSHIP_DROP_BULLY_GOLD_FAILURE = getDefineINT("MINOR_FRIENDSHIP_DROP_BULLY_GOLD_FAILURE");

	push	1
	push	OFFSET $SG230860
	mov	ecx, esi
	mov	DWORD PTR [esi+2748], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5219 : 	m_iMINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS = getDefineINT("MINOR_FRIENDSHIP_DROP_BULLY_WORKER_SUCCESS");

	push	1
	push	OFFSET $SG230861
	mov	ecx, esi
	mov	DWORD PTR [esi+2752], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5220 : 	m_iMINOR_FRIENDSHIP_DROP_BULLY_WORKER_FAILURE = getDefineINT("MINOR_FRIENDSHIP_DROP_BULLY_WORKER_FAILURE");

	push	1
	push	OFFSET $SG230862
	mov	ecx, esi
	mov	DWORD PTR [esi+2756], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5221 : 	m_iMINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN = getDefineINT("MINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN");

	push	1
	push	OFFSET $SG230863
	mov	ecx, esi
	mov	DWORD PTR [esi+2760], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5222 : 	m_iMINOR_FRIENDSHIP_AT_WAR = getDefineINT("MINOR_FRIENDSHIP_AT_WAR");

	push	1
	push	OFFSET $SG230864
	mov	ecx, esi
	mov	DWORD PTR [esi+2764], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5223 : 	m_iMINOR_CIV_AGGRESSOR_THRESHOLD = getDefineINT("MINOR_CIV_AGGRESSOR_THRESHOLD");

	push	1
	push	OFFSET $SG230865
	mov	ecx, esi
	mov	DWORD PTR [esi+2768], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5224 : 	m_iMINOR_CIV_WARMONGER_THRESHOLD = getDefineINT("MINOR_CIV_WARMONGER_THRESHOLD");

	push	1
	push	OFFSET $SG230866
	mov	ecx, esi
	mov	DWORD PTR [esi+2772], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5225 : 	m_iPERMANENT_WAR_AGGRESSOR_CHANCE = getDefineINT("PERMANENT_WAR_AGGRESSOR_CHANCE");

	push	1
	push	OFFSET $SG230867
	mov	ecx, esi
	mov	DWORD PTR [esi+2776], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5226 : 	m_iPERMANENT_WAR_OTHER_WARMONGER_CHANCE_DISTANT = getDefineINT("PERMANENT_WAR_OTHER_WARMONGER_CHANCE_DISTANT");

	push	1
	push	OFFSET $SG230868
	mov	ecx, esi
	mov	DWORD PTR [esi+2780], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5227 : 	m_iPERMANENT_WAR_OTHER_WARMONGER_CHANCE_FAR = getDefineINT("PERMANENT_WAR_OTHER_WARMONGER_CHANCE_FAR");

	push	1
	push	OFFSET $SG230869
	mov	ecx, esi
	mov	DWORD PTR [esi+2784], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5228 : 	m_iPERMANENT_WAR_OTHER_WARMONGER_CHANCE_CLOSE = getDefineINT("PERMANENT_WAR_OTHER_WARMONGER_CHANCE_CLOSE");

	push	1
	push	OFFSET $SG230870
	mov	ecx, esi
	mov	DWORD PTR [esi+2788], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5229 : 	m_iPERMANENT_WAR_OTHER_WARMONGER_CHANCE_NEIGHBORS = getDefineINT("PERMANENT_WAR_OTHER_WARMONGER_CHANCE_NEIGHBORS");

	push	1
	push	OFFSET $SG230871
	mov	ecx, esi
	mov	DWORD PTR [esi+2792], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5230 : 	m_iPERMANENT_WAR_OTHER_CHANCE_DISTANT = getDefineINT("PERMANENT_WAR_OTHER_CHANCE_DISTANT");

	push	1
	push	OFFSET $SG230872
	mov	ecx, esi
	mov	DWORD PTR [esi+2796], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5231 : 	m_iPERMANENT_WAR_OTHER_CHANCE_FAR = getDefineINT("PERMANENT_WAR_OTHER_CHANCE_FAR");

	push	1
	push	OFFSET $SG230873
	mov	ecx, esi
	mov	DWORD PTR [esi+2800], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5232 : 	m_iPERMANENT_WAR_OTHER_CHANCE_CLOSE = getDefineINT("PERMANENT_WAR_OTHER_CHANCE_CLOSE");

	push	1
	push	OFFSET $SG230874
	mov	ecx, esi
	mov	DWORD PTR [esi+2804], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+2808], eax

; 5233 : 	m_iPERMANENT_WAR_OTHER_CHANCE_NEIGHBORS = getDefineINT("PERMANENT_WAR_OTHER_CHANCE_NEIGHBORS");

	push	1
	push	OFFSET $SG230875
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5234 : 	m_iPERMANENT_WAR_OTHER_AT_WAR = getDefineINT("PERMANENT_WAR_OTHER_AT_WAR");

	push	1
	push	OFFSET $SG230876
	mov	ecx, esi
	mov	DWORD PTR [esi+2812], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5235 : 	m_iFRIENDSHIP_NEUTRAL_ON_DEATH = getDefineINT("FRIENDSHIP_NEUTRAL_ON_DEATH");

	push	1
	push	OFFSET $SG230877
	mov	ecx, esi
	mov	DWORD PTR [esi+2816], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5236 : 	m_iFRIENDSHIP_THRESHOLD_NEUTRAL = getDefineINT("FRIENDSHIP_THRESHOLD_NEUTRAL");

	push	1
	push	OFFSET $SG230878
	mov	ecx, esi
	mov	DWORD PTR [esi+2820], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5237 : 	m_iFRIENDSHIP_FRIENDS_ON_DEATH = getDefineINT("FRIENDSHIP_FRIENDS_ON_DEATH");

	push	1
	push	OFFSET $SG230879
	mov	ecx, esi
	mov	DWORD PTR [esi+2824], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5238 : 	m_iFRIENDSHIP_THRESHOLD_FRIENDS = getDefineINT("FRIENDSHIP_THRESHOLD_FRIENDS");

	push	1
	push	OFFSET $SG230880
	mov	ecx, esi
	mov	DWORD PTR [esi+2828], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5239 : 	m_iFRIENDSHIP_ALLIES_ON_DEATH = getDefineINT("FRIENDSHIP_ALLIES_ON_DEATH");

	push	1
	push	OFFSET $SG230881
	mov	ecx, esi
	mov	DWORD PTR [esi+2832], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5240 : 	m_iFRIENDSHIP_THRESHOLD_ALLIES = getDefineINT("FRIENDSHIP_THRESHOLD_ALLIES");

	push	1
	push	OFFSET $SG230882
	mov	ecx, esi
	mov	DWORD PTR [esi+2836], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5241 : 	m_iFRIENDSHIP_THRESHOLD_MAX = getDefineINT("FRIENDSHIP_THRESHOLD_MAX");

	push	1
	push	OFFSET $SG230883
	mov	ecx, esi
	mov	DWORD PTR [esi+2840], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5242 : 	m_iFRIENDSHIP_THRESHOLD_CAN_BULLY = getDefineINT("FRIENDSHIP_THRESHOLD_CAN_BULLY");

	push	1
	push	OFFSET $SG230884
	mov	ecx, esi
	mov	DWORD PTR [esi+2844], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5243 : 	m_iFRIENDSHIP_THRESHOLD_CAN_PLEDGE_TO_PROTECT = getDefineINT("FRIENDSHIP_THRESHOLD_CAN_PLEDGE_TO_PROTECT");

	push	1
	push	OFFSET $SG230885
	mov	ecx, esi
	mov	DWORD PTR [esi+2848], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5244 : 	m_iMINOR_FRIENDSHIP_CLOSE_AMOUNT = getDefineINT("MINOR_FRIENDSHIP_CLOSE_AMOUNT");

	push	1
	push	OFFSET $SG230886
	mov	ecx, esi
	mov	DWORD PTR [esi+2852], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5245 : 	m_iMINOR_CIV_SCIENCE_BONUS_MULTIPLIER = getDefineINT("MINOR_CIV_SCIENCE_BONUS_MULTIPLIER");

	push	1
	push	OFFSET $SG230887
	mov	ecx, esi
	mov	DWORD PTR [esi+2856], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5246 : 	m_iFRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT = getDefineINT("FRIENDS_CULTURE_BONUS_AMOUNT_ANCIENT");

	push	1
	push	OFFSET $SG230888
	mov	ecx, esi
	mov	DWORD PTR [esi+2860], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5247 : 	m_iFRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL = getDefineINT("FRIENDS_CULTURE_BONUS_AMOUNT_MEDIEVAL");

	push	1
	push	OFFSET $SG230889
	mov	ecx, esi
	mov	DWORD PTR [esi+2864], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5248 : 	m_iFRIENDS_CULTURE_BONUS_AMOUNT_INDUSTRIAL = getDefineINT("FRIENDS_CULTURE_BONUS_AMOUNT_INDUSTRIAL");

	push	1
	push	OFFSET $SG230890
	mov	ecx, esi
	mov	DWORD PTR [esi+2868], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+2872], eax

; 5249 : 	m_iALLIES_CULTURE_BONUS_AMOUNT_ANCIENT = getDefineINT("ALLIES_CULTURE_BONUS_AMOUNT_ANCIENT");

	push	1
	push	OFFSET $SG230891
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5250 : 	m_iALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL = getDefineINT("ALLIES_CULTURE_BONUS_AMOUNT_MEDIEVAL");

	push	1
	push	OFFSET $SG230892
	mov	ecx, esi
	mov	DWORD PTR [esi+2876], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5251 : 	m_iALLIES_CULTURE_BONUS_AMOUNT_INDUSTRIAL = getDefineINT("ALLIES_CULTURE_BONUS_AMOUNT_INDUSTRIAL");

	push	1
	push	OFFSET $SG230893
	mov	ecx, esi
	mov	DWORD PTR [esi+2880], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5252 : 	m_iFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE = getDefineINT("FRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE");

	push	1
	push	OFFSET $SG230894
	mov	ecx, esi
	mov	DWORD PTR [esi+2884], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5253 : 	m_iFRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_POST_RENAISSANCE = getDefineINT("FRIENDS_CAPITAL_FOOD_BONUS_AMOUNT_POST_RENAISSANCE");

	push	1
	push	OFFSET $SG230895
	mov	ecx, esi
	mov	DWORD PTR [esi+2888], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5254 : 	m_iFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE = getDefineINT("FRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_PRE_RENAISSANCE");

	push	1
	push	OFFSET $SG230896
	mov	ecx, esi
	mov	DWORD PTR [esi+2892], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5255 : 	m_iFRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_POST_RENAISSANCE = getDefineINT("FRIENDS_OTHER_CITIES_FOOD_BONUS_AMOUNT_POST_RENAISSANCE");

	push	1
	push	OFFSET $SG230897
	mov	ecx, esi
	mov	DWORD PTR [esi+2896], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5256 : 	m_iALLIES_CAPITAL_FOOD_BONUS_AMOUNT = getDefineINT("ALLIES_CAPITAL_FOOD_BONUS_AMOUNT");

	push	1
	push	OFFSET $SG230898
	mov	ecx, esi
	mov	DWORD PTR [esi+2900], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5257 : 	m_iALLIES_OTHER_CITIES_FOOD_BONUS_AMOUNT = getDefineINT("ALLIES_OTHER_CITIES_FOOD_BONUS_AMOUNT");

	push	1
	push	OFFSET $SG230899
	mov	ecx, esi
	mov	DWORD PTR [esi+2904], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5258 : 	m_iFRIENDS_BASE_TURNS_UNIT_SPAWN = getDefineINT("FRIENDS_BASE_TURNS_UNIT_SPAWN");

	push	1
	push	OFFSET $SG230900
	mov	ecx, esi
	mov	DWORD PTR [esi+2908], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5259 : 	m_iFRIENDS_RAND_TURNS_UNIT_SPAWN = getDefineINT("FRIENDS_RAND_TURNS_UNIT_SPAWN");

	push	1
	push	OFFSET $SG230901
	mov	ecx, esi
	mov	DWORD PTR [esi+2912], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5260 : 	m_iALLIES_EXTRA_TURNS_UNIT_SPAWN = getDefineINT("ALLIES_EXTRA_TURNS_UNIT_SPAWN");

	push	1
	push	OFFSET $SG230902
	mov	ecx, esi
	mov	DWORD PTR [esi+2916], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5261 : 	m_iUNIT_SPAWN_BIAS_MULTIPLIER = getDefineINT("UNIT_SPAWN_BIAS_MULTIPLIER");

	push	1
	push	OFFSET $SG230903
	mov	ecx, esi
	mov	DWORD PTR [esi+2920], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5262 : 	m_iUNIT_SPAWN_NUM_CHOICES = getDefineINT("UNIT_SPAWN_NUM_CHOICES");

	push	1
	push	OFFSET $SG230904
	mov	ecx, esi
	mov	DWORD PTR [esi+2924], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5263 : 	m_iFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT = getDefineINT("FRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT");

	push	1
	push	OFFSET $SG230905
	mov	ecx, esi
	mov	DWORD PTR [esi+2928], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5264 : 	m_iFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL = getDefineINT("FRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL");

	push	1
	push	OFFSET $SG230906
	mov	ecx, esi
	mov	DWORD PTR [esi+2932], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5265 : 	m_iFRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL = getDefineINT("FRIENDS_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL");

	push	1
	mov	DWORD PTR [esi+2936], eax
	push	OFFSET $SG230907
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5266 : 	m_iALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT = getDefineINT("ALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_ANCIENT");

	push	1
	push	OFFSET $SG230908
	mov	ecx, esi
	mov	DWORD PTR [esi+2940], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5267 : 	m_iALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL = getDefineINT("ALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_MEDIEVAL");

	push	1
	push	OFFSET $SG230909
	mov	ecx, esi
	mov	DWORD PTR [esi+2944], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5268 : 	m_iALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL = getDefineINT("ALLIES_HAPPINESS_FLAT_BONUS_AMOUNT_INDUSTRIAL");

	push	1
	push	OFFSET $SG230910
	mov	ecx, esi
	mov	DWORD PTR [esi+2948], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5269 : 	m_iFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT = getDefineINT("FRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT");

	push	1
	push	OFFSET $SG230911
	mov	ecx, esi
	mov	DWORD PTR [esi+2952], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5270 : 	m_iFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL = getDefineINT("FRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL");

	push	1
	push	OFFSET $SG230912
	mov	ecx, esi
	mov	DWORD PTR [esi+2956], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5271 : 	m_iFRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL = getDefineINT("FRIENDS_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL");

	push	1
	push	OFFSET $SG230913
	mov	ecx, esi
	mov	DWORD PTR [esi+2960], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5272 : 	m_iALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT = getDefineINT("ALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_ANCIENT");

	push	1
	push	OFFSET $SG230914
	mov	ecx, esi
	mov	DWORD PTR [esi+2964], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5273 : 	m_iALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL = getDefineINT("ALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_MEDIEVAL");

	push	1
	push	OFFSET $SG230915
	mov	ecx, esi
	mov	DWORD PTR [esi+2968], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5274 : 	m_iALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL = getDefineINT("ALLIES_HAPPINESS_PER_LUXURY_BONUS_AMOUNT_INDUSTRIAL");

	push	1
	push	OFFSET $SG230916
	mov	ecx, esi
	mov	DWORD PTR [esi+2972], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5275 : 	m_iFRIENDS_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL = getDefineINT("FRIENDS_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL");

	push	1
	push	OFFSET $SG230917
	mov	ecx, esi
	mov	DWORD PTR [esi+2976], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5276 : 	m_iFRIENDS_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE = getDefineINT("FRIENDS_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE");

	push	1
	push	OFFSET $SG230918
	mov	ecx, esi
	mov	DWORD PTR [esi+2980], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5277 : 	m_iFRIENDS_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL = getDefineINT("FRIENDS_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL");

	push	1
	push	OFFSET $SG230919
	mov	ecx, esi
	mov	DWORD PTR [esi+2984], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5278 : 	m_iFRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL = getDefineINT("FRIENDS_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL");

	push	1
	push	OFFSET $SG230920
	mov	ecx, esi
	mov	DWORD PTR [esi+2988], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5279 : 	m_iFRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT = getDefineINT("FRIENDS_FAITH_FLAT_BONUS_AMOUNT_ANCIENT");

	push	1
	push	OFFSET $SG230921
	mov	ecx, esi
	mov	DWORD PTR [esi+2992], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5280 : 	m_iALLIES_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL = getDefineINT("ALLIES_FAITH_FLAT_BONUS_AMOUNT_INDUSTRIAL");

	push	1
	push	OFFSET $SG230922
	mov	ecx, esi
	mov	DWORD PTR [esi+2996], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5281 : 	m_iALLIES_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE = getDefineINT("ALLIES_FAITH_FLAT_BONUS_AMOUNT_RENAISSANCE");

	push	1
	mov	DWORD PTR [esi+3000], eax
	push	OFFSET $SG230923
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5282 : 	m_iALLIES_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL = getDefineINT("ALLIES_FAITH_FLAT_BONUS_AMOUNT_MEDIEVAL");

	push	1
	push	OFFSET $SG230924
	mov	ecx, esi
	mov	DWORD PTR [esi+3004], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5283 : 	m_iALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL = getDefineINT("ALLIES_FAITH_FLAT_BONUS_AMOUNT_CLASSICAL");

	push	1
	push	OFFSET $SG230925
	mov	ecx, esi
	mov	DWORD PTR [esi+3008], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5284 : 	m_iALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT = getDefineINT("ALLIES_FAITH_FLAT_BONUS_AMOUNT_ANCIENT");

	push	1
	push	OFFSET $SG230926
	mov	ecx, esi
	mov	DWORD PTR [esi+3012], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5285 : 	m_iMINOR_TURNS_GREAT_PEOPLE_SPAWN_BASE = getDefineINT("MINOR_TURNS_GREAT_PEOPLE_SPAWN_BASE");

	push	1
	push	OFFSET $SG230927
	mov	ecx, esi
	mov	DWORD PTR [esi+3016], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5286 : 	m_iMINOR_TURNS_GREAT_PEOPLE_SPAWN_RAND = getDefineINT("MINOR_TURNS_GREAT_PEOPLE_SPAWN_RAND");

	push	1
	push	OFFSET $SG230928
	mov	ecx, esi
	mov	DWORD PTR [esi+3020], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5287 : 	m_iMINOR_TURNS_GREAT_PEOPLE_SPAWN_BIAS_MULTIPLY = getDefineINT("MINOR_TURNS_GREAT_PEOPLE_SPAWN_BIAS_MULTIPLY");

	push	1
	push	OFFSET $SG230929
	mov	ecx, esi
	mov	DWORD PTR [esi+3024], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5288 : 	m_iMINOR_ADDITIONAL_ALLIES_GP_CHANGE = getDefineINT("MINOR_ADDITIONAL_ALLIES_GP_CHANGE");

	push	1
	push	OFFSET $SG230930
	mov	ecx, esi
	mov	DWORD PTR [esi+3028], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5289 : 	m_iMAX_MINOR_ADDITIONAL_ALLIES_GP_CHANGE = getDefineINT("MAX_MINOR_ADDITIONAL_ALLIES_GP_CHANGE");

	push	1
	push	OFFSET $SG230931
	mov	ecx, esi
	mov	DWORD PTR [esi+3032], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5290 : 	m_iMAX_DISTANCE_MINORS_BARB_QUEST = getDefineINT("MAX_DISTANCE_MINORS_BARB_QUEST");

	push	1
	push	OFFSET $SG230932
	mov	ecx, esi
	mov	DWORD PTR [esi+3036], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5291 : 	m_iTXT_KEY_MINOR_GIFT_UNITS_REMINDER = getDefineINT("TXT_KEY_MINOR_GIFT_UNITS_REMINDER");

	push	1
	push	OFFSET $SG230933
	mov	ecx, esi
	mov	DWORD PTR [esi+3040], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5292 : 	m_iWAR_QUEST_COMPLETE_FRIENDSHIP = getDefineINT("WAR_QUEST_COMPLETE_FRIENDSHIP");

	push	1
	push	OFFSET $SG230934
	mov	ecx, esi
	mov	DWORD PTR [esi+3044], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5293 : 	m_iWAR_QUEST_UNITS_TO_KILL_DIVISOR = getDefineINT("WAR_QUEST_UNITS_TO_KILL_DIVISOR");

	push	1
	push	OFFSET $SG230935
	mov	ecx, esi
	mov	DWORD PTR [esi+3048], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5294 : 	m_iWAR_QUEST_MIN_UNITS_TO_KILL = getDefineINT("WAR_QUEST_MIN_UNITS_TO_KILL");

	push	1
	push	OFFSET $SG230936
	mov	ecx, esi
	mov	DWORD PTR [esi+3052], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5295 : 	m_iMINOR_QUEST_FRIENDSHIP_ROUTE = getDefineINT("MINOR_QUEST_FRIENDSHIP_ROUTE");

	push	1
	push	OFFSET $SG230937
	mov	ecx, esi
	mov	DWORD PTR [esi+3056], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5296 : 	m_iMINOR_QUEST_FRIENDSHIP_KILL_CAMP = getDefineINT("MINOR_QUEST_FRIENDSHIP_KILL_CAMP");

	push	1
	push	OFFSET $SG230938
	mov	ecx, esi
	mov	DWORD PTR [esi+3060], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5297 : 	m_iMINOR_QUEST_FRIENDSHIP_CONNECT_RESOURCE = getDefineINT("MINOR_QUEST_FRIENDSHIP_CONNECT_RESOURCE");

	push	1
	push	OFFSET $SG230939
	mov	ecx, esi
	mov	DWORD PTR [esi+3064], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5298 : 	m_iMINOR_QUEST_FRIENDSHIP_CONSTRUCT_WONDER = getDefineINT("MINOR_QUEST_FRIENDSHIP_CONSTRUCT_WONDER");

	push	1
	push	OFFSET $SG230940
	mov	ecx, esi
	mov	DWORD PTR [esi+3068], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5299 : 	m_iMINOR_QUEST_FRIENDSHIP_GREAT_PERSON = getDefineINT("MINOR_QUEST_FRIENDSHIP_GREAT_PERSON");

	push	1
	push	OFFSET $SG230941
	mov	ecx, esi
	mov	DWORD PTR [esi+3072], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5300 : 	m_iMINOR_QUEST_FRIENDSHIP_KILL_CITY_STATE = getDefineINT("MINOR_QUEST_FRIENDSHIP_KILL_CITY_STATE");

	push	1
	push	OFFSET $SG230942
	mov	ecx, esi
	mov	DWORD PTR [esi+3076], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5301 : 	m_iMINOR_QUEST_FRIENDSHIP_FIND_PLAYER = getDefineINT("MINOR_QUEST_FRIENDSHIP_FIND_PLAYER");

	push	1
	push	OFFSET $SG230943
	mov	ecx, esi
	mov	DWORD PTR [esi+3080], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5302 : 	m_iMINOR_QUEST_FRIENDSHIP_FIND_NATURAL_WONDER = getDefineINT("MINOR_QUEST_FRIENDSHIP_FIND_NATURAL_WONDER");

	push	1
	push	OFFSET $SG230944
	mov	ecx, esi
	mov	DWORD PTR [esi+3084], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5303 : 	m_iMINOR_QUEST_FRIENDSHIP_GIVE_GOLD = getDefineINT("MINOR_QUEST_FRIENDSHIP_GIVE_GOLD");

	push	1
	push	OFFSET $SG230945
	mov	ecx, esi
	mov	DWORD PTR [esi+3088], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5304 : 	m_iMINOR_QUEST_FRIENDSHIP_PLEDGE_TO_PROTECT = getDefineINT("MINOR_QUEST_FRIENDSHIP_PLEDGE_TO_PROTECT");

	push	1
	push	OFFSET $SG230946
	mov	ecx, esi
	mov	DWORD PTR [esi+3092], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5305 : 	m_iMINOR_QUEST_FRIENDSHIP_CONTEST_CULTURE = getDefineINT("MINOR_QUEST_FRIENDSHIP_CONTEST_CULTURE");

	push	1
	push	OFFSET $SG230947
	mov	ecx, esi
	mov	DWORD PTR [esi+3096], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5306 : 	m_iMINOR_QUEST_FRIENDSHIP_CONTEST_FAITH = getDefineINT("MINOR_QUEST_FRIENDSHIP_CONTEST_FAITH");

	push	1
	push	OFFSET $SG230948
	mov	ecx, esi
	mov	DWORD PTR [esi+3100], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5307 : 	m_iMINOR_QUEST_FRIENDSHIP_CONTEST_TECHS = getDefineINT("MINOR_QUEST_FRIENDSHIP_CONTEST_TECHS");

	push	1
	push	OFFSET $SG230949
	mov	ecx, esi
	mov	DWORD PTR [esi+3104], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5308 : 	m_iMINOR_QUEST_FRIENDSHIP_INVEST = getDefineINT("MINOR_QUEST_FRIENDSHIP_INVEST");

	push	1
	push	OFFSET $SG230950
	mov	ecx, esi
	mov	DWORD PTR [esi+3108], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5309 : 	m_iMINOR_QUEST_FRIENDSHIP_BULLY_CITY_STATE = getDefineINT("MINOR_QUEST_FRIENDSHIP_BULLY_CITY_STATE");

	push	1
	push	OFFSET $SG230951
	mov	ecx, esi
	mov	DWORD PTR [esi+3112], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5310 : 	m_iMINOR_QUEST_FRIENDSHIP_DENOUNCE_MAJOR = getDefineINT("MINOR_QUEST_FRIENDSHIP_DENOUNCE_MAJOR");

	push	1
	push	OFFSET $SG230952
	mov	ecx, esi
	mov	DWORD PTR [esi+3116], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5311 : 	m_iMINOR_QUEST_FRIENDSHIP_SPREAD_RELIGION = getDefineINT("MINOR_QUEST_FRIENDSHIP_SPREAD_RELIGION");

	push	1
	push	OFFSET $SG230953
	mov	ecx, esi
	mov	DWORD PTR [esi+3120], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5312 : 	m_iMINOR_QUEST_FRIENDSHIP_TRADE_ROUTE = getDefineINT("MINOR_QUEST_FRIENDSHIP_TRADE_ROUTE");

	push	1
	push	OFFSET $SG230954
	mov	ecx, esi
	mov	DWORD PTR [esi+3124], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5313 : 	m_iMINOR_QUEST_STANDARD_CONTEST_LENGTH = getDefineINT("MINOR_QUEST_STANDARD_CONTEST_LENGTH");

	push	1
	push	OFFSET $SG230955
	mov	ecx, esi
	mov	DWORD PTR [esi+3128], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+3132], eax

; 5314 : 	m_iMINOR_CIV_GOLD_GIFT_GAME_MULTIPLIER = getDefineINT("MINOR_CIV_GOLD_GIFT_GAME_MULTIPLIER");

	push	1
	push	OFFSET $SG230956
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5315 : 	m_iMINOR_CIV_GOLD_GIFT_GAME_DIVISOR = getDefineINT("MINOR_CIV_GOLD_GIFT_GAME_DIVISOR");

	push	1
	push	OFFSET $SG230957
	mov	ecx, esi
	mov	DWORD PTR [esi+3136], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5316 : 	m_iMINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR = getDefineINT("MINOR_CIV_GOLD_GIFT_VISIBLE_DIVISOR");

	push	1
	push	OFFSET $SG230958
	mov	ecx, esi
	mov	DWORD PTR [esi+3140], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5317 : 	m_iMINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD = getDefineINT("MINOR_CIV_GOLD_GIFT_MINIMUM_FRIENDSHIP_REWARD");

	push	1
	push	OFFSET $SG230959
	mov	ecx, esi
	mov	DWORD PTR [esi+3144], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5318 : 	m_iMINOR_CIV_BEST_RELATIONS_HAPPINESS_BONUS = getDefineINT("MINOR_CIV_BEST_RELATIONS_HAPPINESS_BONUS");

	push	1
	push	OFFSET $SG230960
	mov	ecx, esi
	mov	DWORD PTR [esi+3148], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5319 : 	m_iMINOR_CIV_RESOURCE_SEARCH_RADIUS = getDefineINT("MINOR_CIV_RESOURCE_SEARCH_RADIUS");

	push	1
	push	OFFSET $SG230961
	mov	ecx, esi
	mov	DWORD PTR [esi+3152], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5320 : 	m_iFRIENDSHIP_PER_UNIT_INTRUDING = getDefineINT("FRIENDSHIP_PER_UNIT_INTRUDING");

	push	1
	push	OFFSET $SG230962
	mov	ecx, esi
	mov	DWORD PTR [esi+3156], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5321 : 	m_iFRIENDSHIP_PER_BARB_KILLED = getDefineINT("FRIENDSHIP_PER_BARB_KILLED");

	push	1
	push	OFFSET $SG230963
	mov	ecx, esi
	mov	DWORD PTR [esi+3160], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5322 : 	m_iFRIENDSHIP_PER_UNIT_GIFTED = getDefineINT("FRIENDSHIP_PER_UNIT_GIFTED");

	push	1
	push	OFFSET $SG230964
	mov	ecx, esi
	mov	DWORD PTR [esi+3164], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5323 : 	m_iMAX_INFLUENCE_FROM_MINOR_GIFTS = getDefineINT("MAX_INFLUENCE_FROM_MINOR_GIFTS");

	push	1
	push	OFFSET $SG230965
	mov	ecx, esi
	mov	DWORD PTR [esi+3168], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5324 : 	m_iMINOR_LIBERATION_FRIENDSHIP = getDefineINT("MINOR_LIBERATION_FRIENDSHIP");

	push	1
	push	OFFSET $SG230966
	mov	ecx, esi
	mov	DWORD PTR [esi+3172], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5325 : 	m_iRETURN_CIVILIAN_FRIENDSHIP = getDefineINT("RETURN_CIVILIAN_FRIENDSHIP");

	push	1
	push	OFFSET $SG230967
	mov	ecx, esi
	mov	DWORD PTR [esi+3176], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5326 : 	m_iMINOR_CIV_MAX_GLOBAL_QUESTS_FOR_PLAYER = getDefineINT("MINOR_CIV_MAX_GLOBAL_QUESTS_FOR_PLAYER");

	push	1
	push	OFFSET $SG230968
	mov	ecx, esi
	mov	DWORD PTR [esi+3180], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5327 : 	m_iMINOR_CIV_MAX_PERSONAL_QUESTS_FOR_PLAYER = getDefineINT("MINOR_CIV_MAX_PERSONAL_QUESTS_FOR_PLAYER");

	push	1
	push	OFFSET $SG230969
	mov	ecx, esi
	mov	DWORD PTR [esi+3184], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5328 : 	m_iMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN = getDefineINT("MINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN");

	push	1
	push	OFFSET $SG230970
	mov	ecx, esi
	mov	DWORD PTR [esi+3188], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5329 : 	m_iMINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN_RAND = getDefineINT("MINOR_CIV_GLOBAL_QUEST_FIRST_POSSIBLE_TURN_RAND");

	push	1
	push	OFFSET $SG230971
	mov	ecx, esi
	mov	DWORD PTR [esi+3192], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+3196], eax

; 5330 : 	m_iMINOR_CIV_GLOBAL_QUEST_MIN_TURNS_BETWEEN = getDefineINT("MINOR_CIV_GLOBAL_QUEST_MIN_TURNS_BETWEEN");

	push	1
	push	OFFSET $SG230972
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5331 : 	m_iMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN = getDefineINT("MINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN");

	push	1
	push	OFFSET $SG230973
	mov	ecx, esi
	mov	DWORD PTR [esi+3200], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5332 : 	m_iMINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER = getDefineINT("MINOR_CIV_GLOBAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER");

	push	1
	push	OFFSET $SG230974
	mov	ecx, esi
	mov	DWORD PTR [esi+3204], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5333 : 	m_iMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN = getDefineINT("MINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN");

	push	1
	push	OFFSET $SG230975
	mov	ecx, esi
	mov	DWORD PTR [esi+3208], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5334 : 	m_iMINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN_RAND = getDefineINT("MINOR_CIV_PERSONAL_QUEST_FIRST_POSSIBLE_TURN_RAND");

	push	1
	push	OFFSET $SG230976
	mov	ecx, esi
	mov	DWORD PTR [esi+3212], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5335 : 	m_iMINOR_CIV_PERSONAL_QUEST_MIN_TURNS_BETWEEN = getDefineINT("MINOR_CIV_PERSONAL_QUEST_MIN_TURNS_BETWEEN");

	push	1
	push	OFFSET $SG230977
	mov	ecx, esi
	mov	DWORD PTR [esi+3216], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5336 : 	m_iMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN = getDefineINT("MINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN");

	push	1
	push	OFFSET $SG230978
	mov	ecx, esi
	mov	DWORD PTR [esi+3220], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5337 : 	m_iMINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER = getDefineINT("MINOR_CIV_PERSONAL_QUEST_RAND_TURNS_BETWEEN_HOSTILE_MULTIPLIER");

	push	1
	push	OFFSET $SG230979
	mov	ecx, esi
	mov	DWORD PTR [esi+3224], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5338 : 	m_iMINOR_CIV_QUEST_KILL_CAMP_RANGE = getDefineINT("MINOR_CIV_QUEST_KILL_CAMP_RANGE");

	push	1
	push	OFFSET $SG230980
	mov	ecx, esi
	mov	DWORD PTR [esi+3228], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5339 : 	m_iMINOR_CIV_QUEST_WONDER_COMPLETION_THRESHOLD = getDefineINT("MINOR_CIV_QUEST_WONDER_COMPLETION_THRESHOLD");

	push	1
	push	OFFSET $SG230981
	mov	ecx, esi
	mov	DWORD PTR [esi+3232], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5340 : 	m_iMINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD = getDefineINT("MINOR_CIV_THREATENED_BY_BARBS_NOTIF_THRESHOLD");

	push	1
	push	OFFSET $SG230982
	mov	ecx, esi
	mov	DWORD PTR [esi+3236], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5341 : 	m_iMINOR_CIV_MERCANTILE_RESOURCES_QUANTITY = getDefineINT("MINOR_CIV_MERCANTILE_RESOURCES_QUANTITY");

	push	1
	push	OFFSET $SG230983
	mov	ecx, esi
	mov	DWORD PTR [esi+3240], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5342 : 	m_iMINOR_CIV_MERCANTILE_RESOURCES_KEEP_ON_CAPTURE_DISABLED = getDefineINT("MINOR_CIV_MERCANTILE_RESOURCES_KEEP_ON_CAPTURE_DISABLED");

	push	1
	push	OFFSET $SG230984
	mov	ecx, esi
	mov	DWORD PTR [esi+3244], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5343 : 	m_iQUEST_DISABLED_ROUTE = getDefineINT("QUEST_DISABLED_ROUTE");

	push	1
	push	OFFSET $SG230985
	mov	ecx, esi
	mov	DWORD PTR [esi+3248], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5344 : 	m_iQUEST_DISABLED_KILL_CAMP = getDefineINT("QUEST_DISABLED_KILL_CAMP");

	push	1
	push	OFFSET $SG230986
	mov	ecx, esi
	mov	DWORD PTR [esi+3252], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5345 : 	m_iQUEST_DISABLED_CONNECT_RESOURCE = getDefineINT("QUEST_DISABLED_CONNECT_RESOURCE");

	push	1
	push	OFFSET $SG230987
	mov	ecx, esi
	mov	DWORD PTR [esi+3256], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5346 : 	m_iQUEST_DISABLED_CONSTRUCT_WONDER = getDefineINT("QUEST_DISABLED_CONSTRUCT_WONDER");

	push	1
	mov	DWORD PTR [esi+3260], eax
	push	OFFSET $SG230988
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5347 : 	m_iQUEST_DISABLED_GREAT_PERSON = getDefineINT("QUEST_DISABLED_GREAT_PERSON");

	push	1
	push	OFFSET $SG230989
	mov	ecx, esi
	mov	DWORD PTR [esi+3264], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5348 : 	m_iQUEST_DISABLED_KILL_CITY_STATE = getDefineINT("QUEST_DISABLED_KILL_CITY_STATE");

	push	1
	push	OFFSET $SG230990
	mov	ecx, esi
	mov	DWORD PTR [esi+3268], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5349 : 	m_iQUEST_DISABLED_FIND_PLAYER = getDefineINT("QUEST_DISABLED_FIND_PLAYER");

	push	1
	push	OFFSET $SG230991
	mov	ecx, esi
	mov	DWORD PTR [esi+3272], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5350 : 	m_iQUEST_DISABLED_NATURAL_WONDER = getDefineINT("QUEST_DISABLED_NATURAL_WONDER");

	push	1
	push	OFFSET $SG230992
	mov	ecx, esi
	mov	DWORD PTR [esi+3276], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5351 : 	m_iQUEST_DISABLED_GIVE_GOLD = getDefineINT("QUEST_DISABLED_GIVE_GOLD");

	push	1
	push	OFFSET $SG230993
	mov	ecx, esi
	mov	DWORD PTR [esi+3280], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5352 : 	m_iQUEST_DISABLED_PLEDGE_TO_PROTECT = getDefineINT("QUEST_DISABLED_PLEDGE_TO_PROTECT");

	push	1
	push	OFFSET $SG230994
	mov	ecx, esi
	mov	DWORD PTR [esi+3284], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5353 : 	m_iQUEST_DISABLED_CONTEST_CULTURE = getDefineINT("QUEST_DISABLED_CONTEST_CULTURE");

	push	1
	push	OFFSET $SG230995
	mov	ecx, esi
	mov	DWORD PTR [esi+3288], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5354 : 	m_iQUEST_DISABLED_CONTEST_FAITH = getDefineINT("QUEST_DISABLED_CONTEST_FAITH");

	push	1
	push	OFFSET $SG230996
	mov	ecx, esi
	mov	DWORD PTR [esi+3292], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5355 : 	m_iQUEST_DISABLED_CONTEST_TECHS = getDefineINT("QUEST_DISABLED_CONTEST_TECHS");

	push	1
	push	OFFSET $SG230997
	mov	ecx, esi
	mov	DWORD PTR [esi+3296], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5356 : 	m_iQUEST_DISABLED_INVEST = getDefineINT("QUEST_DISABLED_INVEST");

	push	1
	push	OFFSET $SG230998
	mov	ecx, esi
	mov	DWORD PTR [esi+3300], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5357 : 	m_iQUEST_DISABLED_BULLY_CITY_STATE = getDefineINT("QUEST_DISABLED_BULLY_CITY_STATE");

	push	1
	push	OFFSET $SG230999
	mov	ecx, esi
	mov	DWORD PTR [esi+3304], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5358 : 	m_iQUEST_DISABLED_DENOUNCE_MAJOR = getDefineINT("QUEST_DISABLED_DENOUNCE_MAJOR");

	push	1
	push	OFFSET $SG231000
	mov	ecx, esi
	mov	DWORD PTR [esi+3308], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5359 : 	m_iQUEST_DISABLED_SPREAD_RELIGION = getDefineINT("QUEST_DISABLED_SPREAD_RELIGION");

	push	1
	push	OFFSET $SG231001
	mov	ecx, esi
	mov	DWORD PTR [esi+3312], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5360 : 	m_iQUEST_DISABLED_TRADE_ROUTE = getDefineINT("QUEST_DISABLED_TRADE_ROUTE");

	push	1
	push	OFFSET $SG231002
	mov	ecx, esi
	mov	DWORD PTR [esi+3316], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5361 : 	m_iMINOR_CIV_QUEST_WEIGHT_DEFAULT = getDefineINT("MINOR_CIV_QUEST_WEIGHT_DEFAULT");

	push	1
	push	OFFSET $SG231003
	mov	ecx, esi
	mov	DWORD PTR [esi+3320], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5362 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_FRIENDLY_ROUTE = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_FRIENDLY_ROUTE");

	push	1
	mov	DWORD PTR [esi+3324], eax
	push	OFFSET $SG231004
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5363 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_ROUTE = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_ROUTE");

	push	1
	push	OFFSET $SG231005
	mov	ecx, esi
	mov	DWORD PTR [esi+3328], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5364 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_ROUTE = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_ROUTE");

	push	1
	push	OFFSET $SG231006
	mov	ecx, esi
	mov	DWORD PTR [esi+3332], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5365 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_ROUTE = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_ROUTE");

	push	1
	push	OFFSET $SG231007
	mov	ecx, esi
	mov	DWORD PTR [esi+3336], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5366 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CAMP = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CAMP");

	push	1
	push	OFFSET $SG231008
	mov	ecx, esi
	mov	DWORD PTR [esi+3340], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5367 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_CONNECT_RESOURCE = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_CONNECT_RESOURCE");

	push	1
	push	OFFSET $SG231009
	mov	ecx, esi
	mov	DWORD PTR [esi+3344], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5368 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_CONNECT_RESOURCE = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_CONNECT_RESOURCE");

	push	1
	push	OFFSET $SG231010
	mov	ecx, esi
	mov	DWORD PTR [esi+3348], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5369 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_CONSTRUCT_WONDER = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_CONSTRUCT_WONDER");

	push	1
	push	OFFSET $SG231011
	mov	ecx, esi
	mov	DWORD PTR [esi+3352], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5370 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_GREAT_PERSON = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_GREAT_PERSON");

	push	1
	push	OFFSET $SG231012
	mov	ecx, esi
	mov	DWORD PTR [esi+3356], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5371 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CITY_STATE = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_KILL_CITY_STATE");

	push	1
	push	OFFSET $SG231013
	mov	ecx, esi
	mov	DWORD PTR [esi+3360], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5372 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_KILL_CITY_STATE = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_KILL_CITY_STATE");

	push	1
	push	OFFSET $SG231014
	mov	ecx, esi
	mov	DWORD PTR [esi+3364], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5373 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_NEUTRAL_KILL_CITY_STATE = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_NEUTRAL_KILL_CITY_STATE");

	push	1
	push	OFFSET $SG231015
	mov	ecx, esi
	mov	DWORD PTR [esi+3368], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5374 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_FIND_PLAYER = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MARITIME_FIND_PLAYER");

	push	1
	push	OFFSET $SG231016
	mov	ecx, esi
	mov	DWORD PTR [esi+3372], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5375 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_FIND_PLAYER = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_FIND_PLAYER");

	push	1
	push	OFFSET $SG231017
	mov	ecx, esi
	mov	DWORD PTR [esi+3376], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5376 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_FIND_NATURAL_WONDER = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_FIND_NATURAL_WONDER");

	push	1
	push	OFFSET $SG231018
	mov	ecx, esi
	mov	DWORD PTR [esi+3380], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5377 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_FIND_NATURAL_WONDER = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_HOSTILE_FIND_NATURAL_WONDER");

	push	1
	push	OFFSET $SG231019
	mov	ecx, esi
	mov	DWORD PTR [esi+3384], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5378 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_GIVE_GOLD = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_GIVE_GOLD");

	push	1
	push	OFFSET $SG231020
	mov	ecx, esi
	mov	DWORD PTR [esi+3388], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5379 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_GIVE_GOLD = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MERCANTILE_GIVE_GOLD");

	push	1
	push	OFFSET $SG231021
	mov	ecx, esi
	mov	DWORD PTR [esi+3392], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5380 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_GIVE_GOLD = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_GIVE_GOLD");

	push	1
	push	OFFSET $SG231022
	mov	ecx, esi
	mov	DWORD PTR [esi+3396], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5381 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_PLEDGE_TO_PROTECT = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_MILITARISTIC_PLEDGE_TO_PROTECT");

	push	1
	push	OFFSET $SG231023
	mov	ecx, esi
	mov	DWORD PTR [esi+3400], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5382 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_PLEDGE_TO_PROTECT = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_CULTURED_PLEDGE_TO_PROTECT");

	push	1
	push	OFFSET $SG231024
	mov	ecx, esi
	mov	DWORD PTR [esi+3404], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5383 : 	m_iMINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_PLEDGE_TO_PROTECT = getDefineINT("MINOR_CIV_QUEST_WEIGHT_MULTIPLIER_OTHER_PLEDGE_TO_PROTECT");

	push	1
	push	OFFSET $SG231025
	mov	ecx, esi
	mov	DWORD PTR [esi+3408], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5384 : 	m_iRELIGION_BELIEF_SCORE_CITY_MULTIPLIER = getDefineINT("RELIGION_BELIEF_SCORE_CITY_MULTIPLIER");

	push	1
	push	OFFSET $SG231026
	mov	ecx, esi
	mov	DWORD PTR [esi+3412], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5385 : 	m_iRELIGION_BELIEF_SCORE_WORKED_PLOT_MULTIPLIER = getDefineINT("RELIGION_BELIEF_SCORE_WORKED_PLOT_MULTIPLIER");

	push	1
	push	OFFSET $SG231027
	mov	ecx, esi
	mov	DWORD PTR [esi+3416], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5386 : 	m_iRELIGION_BELIEF_SCORE_OWNED_PLOT_MULTIPLIER = getDefineINT("RELIGION_BELIEF_SCORE_OWNED_PLOT_MULTIPLIER");

	push	1
	push	OFFSET $SG231028
	mov	ecx, esi
	mov	DWORD PTR [esi+3420], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5387 : 	m_iRELIGION_BELIEF_SCORE_UNOWNED_PLOT_MULTIPLIER = getDefineINT("RELIGION_BELIEF_SCORE_UNOWNED_PLOT_MULTIPLIER");

	push	1
	push	OFFSET $SG231029
	mov	ecx, esi
	mov	DWORD PTR [esi+3424], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5388 : 	m_iRELIGION_MISSIONARY_RANGE_IN_TURNS = getDefineINT("RELIGION_MISSIONARY_RANGE_IN_TURNS");

	push	1
	push	OFFSET $SG231030
	mov	ecx, esi
	mov	DWORD PTR [esi+3428], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5389 : 	m_iRELIGION_MAX_MISSIONARIES = getDefineINT("RELIGION_MAX_MISSIONARIES");

	push	1
	push	OFFSET $SG231031
	mov	ecx, esi
	mov	DWORD PTR [esi+3432], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5390 : 	m_fNORMAL_ANNEX = getDefineFLOAT("NORMAL_ANNEX");

	push	1
	push	OFFSET $SG231032
	mov	ecx, esi
	mov	DWORD PTR [esi+3436], eax
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8192]

; 5391 : 	m_fAGGRESSIVE_ANNEX = getDefineFLOAT("AGGRESSIVE_ANNEX");

	push	1
	push	OFFSET $SG231033
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8196]

; 5392 : 	m_iMC_GIFT_WEIGHT_THRESHOLD = getDefineINT("MC_GIFT_WEIGHT_THRESHOLD");

	push	1
	push	OFFSET $SG231034
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5393 : 	m_iMC_ALWAYS_GIFT_DIPLO_THRESHOLD = getDefineINT("MC_ALWAYS_GIFT_DIPLO_THRESHOLD");

	push	1
	push	OFFSET $SG231035
	mov	ecx, esi
	mov	DWORD PTR [esi+3440], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5394 : 	m_iMC_SOMETIMES_GIFT_RAND_MULTIPLIER = getDefineINT("MC_SOMETIMES_GIFT_RAND_MULTIPLIER");

	push	1
	push	OFFSET $SG231036
	mov	ecx, esi
	mov	DWORD PTR [esi+3444], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+3448], eax

; 5395 : 	m_iMC_SMALL_GIFT_WEIGHT_PASS_OTHER_PLAYER = getDefineINT("MC_SMALL_GIFT_WEIGHT_PASS_OTHER_PLAYER");

	push	1
	push	OFFSET $SG231037
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5396 : 	m_iMC_GIFT_WEIGHT_PASS_OTHER_PLAYER = getDefineINT("MC_GIFT_WEIGHT_PASS_OTHER_PLAYER");

	push	1
	push	OFFSET $SG231038
	mov	ecx, esi
	mov	DWORD PTR [esi+3452], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5397 : 	m_iMC_GIFT_WEIGHT_MARITIME_GROWTH = getDefineINT("MC_GIFT_WEIGHT_MARITIME_GROWTH");

	push	1
	push	OFFSET $SG231039
	mov	ecx, esi
	mov	DWORD PTR [esi+3456], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5398 : 	m_iMC_GIFT_WEIGHT_DIPLO_VICTORY = getDefineINT("MC_GIFT_WEIGHT_DIPLO_VICTORY");

	push	1
	push	OFFSET $SG231040
	mov	ecx, esi
	mov	DWORD PTR [esi+3460], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5399 : 	m_iMC_GIFT_WEIGHT_CULTURE_VICTORY = getDefineINT("MC_GIFT_WEIGHT_CULTURE_VICTORY");

	push	1
	push	OFFSET $SG231041
	mov	ecx, esi
	mov	DWORD PTR [esi+3464], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5400 : 	m_iMC_GIFT_WEIGHT_CONQUEST_VICTORY = getDefineINT("MC_GIFT_WEIGHT_CONQUEST_VICTORY");

	push	1
	push	OFFSET $SG231042
	mov	ecx, esi
	mov	DWORD PTR [esi+3468], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5401 : 	m_iMC_GIFT_WEIGHT_MILITARISTIC = getDefineINT("MC_GIFT_WEIGHT_MILITARISTIC");

	push	1
	push	OFFSET $SG231043
	mov	ecx, esi
	mov	DWORD PTR [esi+3472], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5402 : 	m_iMC_GIFT_WEIGHT_RESOURCE_WE_NEED = getDefineINT("MC_GIFT_WEIGHT_RESOURCE_WE_NEED");

	push	1
	push	OFFSET $SG231044
	mov	ecx, esi
	mov	DWORD PTR [esi+3476], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5403 : 	m_iMC_GIFT_WEIGHT_NEUTRAL_VICTORY_ROLL = getDefineINT("MC_GIFT_WEIGHT_NEUTRAL_VICTORY_ROLL");

	push	1
	push	OFFSET $SG231045
	mov	ecx, esi
	mov	DWORD PTR [esi+3480], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5404 : 	m_iMC_GIFT_WEIGHT_PROTECTIVE = getDefineINT("MC_GIFT_WEIGHT_PROTECTIVE");

	push	1
	push	OFFSET $SG231046
	mov	ecx, esi
	mov	DWORD PTR [esi+3484], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5405 : 	m_iMC_GIFT_WEIGHT_HOSTILE = getDefineINT("MC_GIFT_WEIGHT_HOSTILE");

	push	1
	push	OFFSET $SG231047
	mov	ecx, esi
	mov	DWORD PTR [esi+3488], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5406 : 	m_iMC_GIFT_WEIGHT_NEIGHBORS = getDefineINT("MC_GIFT_WEIGHT_NEIGHBORS");

	push	1
	push	OFFSET $SG231048
	mov	ecx, esi
	mov	DWORD PTR [esi+3492], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5407 : 	m_iMC_GIFT_WEIGHT_CLOSE = getDefineINT("MC_GIFT_WEIGHT_CLOSE");

	push	1
	push	OFFSET $SG231049
	mov	ecx, esi
	mov	DWORD PTR [esi+3496], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5408 : 	m_iMC_GIFT_WEIGHT_FAR = getDefineINT("MC_GIFT_WEIGHT_FAR");

	push	1
	push	OFFSET $SG231050
	mov	ecx, esi
	mov	DWORD PTR [esi+3500], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5409 : 	m_iMC_GIFT_WEIGHT_ALMOST_NOT_ALLIES = getDefineINT("MC_GIFT_WEIGHT_ALMOST_NOT_ALLIES");

	push	1
	push	OFFSET $SG231051
	mov	ecx, esi
	mov	DWORD PTR [esi+3504], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5410 : 	m_iMC_GIFT_WEIGHT_ALMOST_NOT_FRIENDS = getDefineINT("MC_GIFT_WEIGHT_ALMOST_NOT_FRIENDS");

	push	1
	push	OFFSET $SG231052
	mov	ecx, esi
	mov	DWORD PTR [esi+3508], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+3512], eax

; 5411 : 	m_iOPINION_WEIGHT_LAND_FIERCE = getDefineINT("OPINION_WEIGHT_LAND_FIERCE");

	push	1
	push	OFFSET $SG231053
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5412 : 	m_iOPINION_WEIGHT_LAND_STRONG = getDefineINT("OPINION_WEIGHT_LAND_STRONG");

	push	1
	push	OFFSET $SG231054
	mov	ecx, esi
	mov	DWORD PTR [esi+3516], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5413 : 	m_iOPINION_WEIGHT_LAND_WEAK = getDefineINT("OPINION_WEIGHT_LAND_WEAK");

	push	1
	push	OFFSET $SG231055
	mov	ecx, esi
	mov	DWORD PTR [esi+3520], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5414 : 	m_iOPINION_WEIGHT_LAND_NONE = getDefineINT("OPINION_WEIGHT_LAND_NONE");

	push	1
	push	OFFSET $SG231056
	mov	ecx, esi
	mov	DWORD PTR [esi+3524], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5415 : 	m_iOPINION_WEIGHT_VICTORY_FIERCE = getDefineINT("OPINION_WEIGHT_VICTORY_FIERCE");

	push	1
	push	OFFSET $SG231057
	mov	ecx, esi
	mov	DWORD PTR [esi+3528], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5416 : 	m_iOPINION_WEIGHT_VICTORY_STRONG = getDefineINT("OPINION_WEIGHT_VICTORY_STRONG");

	push	1
	push	OFFSET $SG231058
	mov	ecx, esi
	mov	DWORD PTR [esi+3532], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5417 : 	m_iOPINION_WEIGHT_VICTORY_WEAK = getDefineINT("OPINION_WEIGHT_VICTORY_WEAK");

	push	1
	push	OFFSET $SG231059
	mov	ecx, esi
	mov	DWORD PTR [esi+3536], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5418 : 	m_iOPINION_WEIGHT_VICTORY_NONE = getDefineINT("OPINION_WEIGHT_VICTORY_NONE");

	push	1
	push	OFFSET $SG231060
	mov	ecx, esi
	mov	DWORD PTR [esi+3540], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5419 : 	m_iOPINION_WEIGHT_WONDER_FIERCE = getDefineINT("OPINION_WEIGHT_WONDER_FIERCE");

	push	1
	push	OFFSET $SG231061
	mov	ecx, esi
	mov	DWORD PTR [esi+3544], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5420 : 	m_iOPINION_WEIGHT_WONDER_STRONG = getDefineINT("OPINION_WEIGHT_WONDER_STRONG");

	push	1
	push	OFFSET $SG231062
	mov	ecx, esi
	mov	DWORD PTR [esi+3548], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5421 : 	m_iOPINION_WEIGHT_WONDER_WEAK = getDefineINT("OPINION_WEIGHT_WONDER_WEAK");

	push	1
	push	OFFSET $SG231063
	mov	ecx, esi
	mov	DWORD PTR [esi+3552], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5422 : 	m_iOPINION_WEIGHT_WONDER_NONE = getDefineINT("OPINION_WEIGHT_WONDER_NONE");

	push	1
	push	OFFSET $SG231064
	mov	ecx, esi
	mov	DWORD PTR [esi+3556], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5423 : 	m_iOPINION_WEIGHT_MINOR_CIV_FIERCE = getDefineINT("OPINION_WEIGHT_MINOR_CIV_FIERCE");

	push	1
	push	OFFSET $SG231065
	mov	ecx, esi
	mov	DWORD PTR [esi+3560], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5424 : 	m_iOPINION_WEIGHT_MINOR_CIV_STRONG = getDefineINT("OPINION_WEIGHT_MINOR_CIV_STRONG");

	push	1
	push	OFFSET $SG231066
	mov	ecx, esi
	mov	DWORD PTR [esi+3564], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5425 : 	m_iOPINION_WEIGHT_MINOR_CIV_WEAK = getDefineINT("OPINION_WEIGHT_MINOR_CIV_WEAK");

	push	1
	push	OFFSET $SG231067
	mov	ecx, esi
	mov	DWORD PTR [esi+3568], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5426 : 	m_iOPINION_WEIGHT_MINOR_CIV_NONE = getDefineINT("OPINION_WEIGHT_MINOR_CIV_NONE");

	push	1
	push	OFFSET $SG231068
	mov	ecx, esi
	mov	DWORD PTR [esi+3572], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5427 : 	m_iOPINION_WEIGHT_WARMONGER_CRITICAL = getDefineINT("OPINION_WEIGHT_WARMONGER_CRITICAL");

	push	1
	mov	DWORD PTR [esi+3576], eax
	push	OFFSET $SG231069
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5428 : 	m_iOPINION_WEIGHT_WARMONGER_SEVERE = getDefineINT("OPINION_WEIGHT_WARMONGER_SEVERE");

	push	1
	push	OFFSET $SG231070
	mov	ecx, esi
	mov	DWORD PTR [esi+3580], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5429 : 	m_iOPINION_WEIGHT_WARMONGER_MAJOR = getDefineINT("OPINION_WEIGHT_WARMONGER_MAJOR");

	push	1
	push	OFFSET $SG231071
	mov	ecx, esi
	mov	DWORD PTR [esi+3584], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5430 : 	m_iOPINION_WEIGHT_WARMONGER_MINOR = getDefineINT("OPINION_WEIGHT_WARMONGER_MINOR");

	push	1
	push	OFFSET $SG231072
	mov	ecx, esi
	mov	DWORD PTR [esi+3588], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5431 : 	m_iOPINION_WEIGHT_WARMONGER_NONE = getDefineINT("OPINION_WEIGHT_WARMONGER_NONE");

	push	1
	push	OFFSET $SG231073
	mov	ecx, esi
	mov	DWORD PTR [esi+3592], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5432 : 	m_iOPINION_WEIGHT_ASKED_NO_SETTLE = getDefineINT("OPINION_WEIGHT_ASKED_NO_SETTLE");

	push	1
	push	OFFSET $SG231074
	mov	ecx, esi
	mov	DWORD PTR [esi+3596], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5433 : 	m_iOPINION_WEIGHT_ASKED_STOP_SPYING = getDefineINT("OPINION_WEIGHT_ASKED_STOP_SPYING");

	push	1
	push	OFFSET $SG231075
	mov	ecx, esi
	mov	DWORD PTR [esi+3600], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5434 : 	m_iOPINION_WEIGHT_MADE_DEMAND_OF_US = getDefineINT("OPINION_WEIGHT_MADE_DEMAND_OF_US");

	push	1
	push	OFFSET $SG231076
	mov	ecx, esi
	mov	DWORD PTR [esi+3604], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5435 : 	m_iOPINION_WEIGHT_RETURNED_CIVILIAN = getDefineINT("OPINION_WEIGHT_RETURNED_CIVILIAN");

	push	1
	push	OFFSET $SG231077
	mov	ecx, esi
	mov	DWORD PTR [esi+3608], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5436 : 	m_iOPINION_WEIGHT_BUILT_LANDMARK = getDefineINT("OPINION_WEIGHT_BUILT_LANDMARK");

	push	1
	push	OFFSET $SG231078
	mov	ecx, esi
	mov	DWORD PTR [esi+3612], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5437 : 	m_iOPINION_WEIGHT_RESURRECTED = getDefineINT("OPINION_WEIGHT_RESURRECTED");

	push	1
	push	OFFSET $SG231079
	mov	ecx, esi
	mov	DWORD PTR [esi+3616], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5438 : 	m_iOPINION_WEIGHT_LIBERATED_ONE_CITY = getDefineINT("OPINION_WEIGHT_LIBERATED_ONE_CITY");

	push	1
	push	OFFSET $SG231080
	mov	ecx, esi
	mov	DWORD PTR [esi+3620], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5439 : 	m_iOPINION_WEIGHT_LIBERATED_TWO_CITIES = getDefineINT("OPINION_WEIGHT_LIBERATED_TWO_CITIES");

	push	1
	push	OFFSET $SG231081
	mov	ecx, esi
	mov	DWORD PTR [esi+3624], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5440 : 	m_iOPINION_WEIGHT_LIBERATED_THREE_CITIES = getDefineINT("OPINION_WEIGHT_LIBERATED_THREE_CITIES");

	push	1
	push	OFFSET $SG231082
	mov	ecx, esi
	mov	DWORD PTR [esi+3628], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5441 : 	m_iOPINION_WEIGHT_EMBASSY = getDefineINT("OPINION_WEIGHT_EMBASSY");

	push	1
	push	OFFSET $SG231083
	mov	ecx, esi
	mov	DWORD PTR [esi+3632], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5442 : 	m_iOPINION_WEIGHT_CULTURE_BOMBED = getDefineINT("OPINION_WEIGHT_CULTURE_BOMBED");

	push	1
	push	OFFSET $SG231084
	mov	ecx, esi
	mov	DWORD PTR [esi+3636], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5443 : 	m_iOPINION_WEIGHT_PER_NEGATIVE_CONVERSION = getDefineINT("OPINION_WEIGHT_PER_NEGATIVE_CONVERSION");

	push	1
	mov	DWORD PTR [esi+3640], eax
	push	OFFSET $SG231085
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5444 : 	m_iOPINION_WEIGHT_ADOPTING_HIS_RELIGION = getDefineINT("OPINION_WEIGHT_ADOPTING_HIS_RELIGION");

	push	1
	push	OFFSET $SG231086
	mov	ecx, esi
	mov	DWORD PTR [esi+3644], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5445 : 	m_iOPINION_WEIGHT_ADOPTING_MY_RELIGION = getDefineINT("OPINION_WEIGHT_ADOPTING_MY_RELIGION");

	push	1
	push	OFFSET $SG231087
	mov	ecx, esi
	mov	DWORD PTR [esi+3648], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5446 : 	m_iOPINION_WEIGHT_SAME_LATE_POLICIES = getDefineINT("OPINION_WEIGHT_SAME_LATE_POLICIES");

	push	1
	push	OFFSET $SG231088
	mov	ecx, esi
	mov	DWORD PTR [esi+3652], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5447 : 	m_iOPINION_WEIGHT_DIFFERENT_LATE_POLICIES = getDefineINT("OPINION_WEIGHT_DIFFERENT_LATE_POLICIES");

	push	1
	push	OFFSET $SG231089
	mov	ecx, esi
	mov	DWORD PTR [esi+3656], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5448 : 	m_iOPINION_WEIGHT_BROKEN_MILITARY_PROMISE = getDefineINT("OPINION_WEIGHT_BROKEN_MILITARY_PROMISE");

	push	1
	push	OFFSET $SG231090
	mov	ecx, esi
	mov	DWORD PTR [esi+3660], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5449 : 	m_iOPINION_WEIGHT_BROKEN_MILITARY_PROMISE_WORLD = getDefineINT("OPINION_WEIGHT_BROKEN_MILITARY_PROMISE_WORLD");

	push	1
	push	OFFSET $SG231091
	mov	ecx, esi
	mov	DWORD PTR [esi+3664], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5450 : 	m_iOPINION_WEIGHT_IGNORED_MILITARY_PROMISE = getDefineINT("OPINION_WEIGHT_IGNORED_MILITARY_PROMISE");

	push	1
	push	OFFSET $SG231092
	mov	ecx, esi
	mov	DWORD PTR [esi+3668], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5451 : 	m_iOPINION_WEIGHT_BROKEN_EXPANSION_PROMISE = getDefineINT("OPINION_WEIGHT_BROKEN_EXPANSION_PROMISE");

	push	1
	push	OFFSET $SG231093
	mov	ecx, esi
	mov	DWORD PTR [esi+3672], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5452 : 	m_iOPINION_WEIGHT_IGNORED_EXPANSION_PROMISE = getDefineINT("OPINION_WEIGHT_IGNORED_EXPANSION_PROMISE");

	push	1
	push	OFFSET $SG231094
	mov	ecx, esi
	mov	DWORD PTR [esi+3676], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5453 : 	m_iOPINION_WEIGHT_BROKEN_BORDER_PROMISE = getDefineINT("OPINION_WEIGHT_BROKEN_BORDER_PROMISE");

	push	1
	push	OFFSET $SG231095
	mov	ecx, esi
	mov	DWORD PTR [esi+3680], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5454 : 	m_iOPINION_WEIGHT_IGNORED_BORDER_PROMISE = getDefineINT("OPINION_WEIGHT_IGNORED_BORDER_PROMISE");

	push	1
	push	OFFSET $SG231096
	mov	ecx, esi
	mov	DWORD PTR [esi+3684], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5455 : 	m_iOPINION_WEIGHT_BROKEN_CITY_STATE_PROMISE = getDefineINT("OPINION_WEIGHT_BROKEN_CITY_STATE_PROMISE");

	push	1
	push	OFFSET $SG231097
	mov	ecx, esi
	mov	DWORD PTR [esi+3688], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5456 : 	m_iOPINION_WEIGHT_BROKEN_CITY_STATE_PROMISE_WORLD = getDefineINT("OPINION_WEIGHT_BROKEN_CITY_STATE_PROMISE_WORLD");

	push	1
	push	OFFSET $SG231098
	mov	ecx, esi
	mov	DWORD PTR [esi+3692], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5457 : 	m_iOPINION_WEIGHT_IGNORED_CITY_STATE_PROMISE = getDefineINT("OPINION_WEIGHT_IGNORED_CITY_STATE_PROMISE");

	push	1
	push	OFFSET $SG231099
	mov	ecx, esi
	mov	DWORD PTR [esi+3696], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5458 : 	m_iOPINION_WEIGHT_BROKEN_SPY_PROMISE = getDefineINT("OPINION_WEIGHT_BROKEN_SPY_PROMISE");

	push	1
	push	OFFSET $SG231100
	mov	ecx, esi
	mov	DWORD PTR [esi+3700], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5459 : 	m_iOPINION_WEIGHT_IGNORED_SPY_PROMISE = getDefineINT("OPINION_WEIGHT_IGNORED_SPY_PROMISE");

	push	1
	push	OFFSET $SG231101
	mov	ecx, esi
	mov	DWORD PTR [esi+3704], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5460 : 	m_iOPINION_WEIGHT_FORGAVE_FOR_SPYING = getDefineINT("OPINION_WEIGHT_FORGAVE_FOR_SPYING");

	push	1
	push	OFFSET $SG231102
	mov	ecx, esi
	mov	DWORD PTR [esi+3708], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5461 : 	m_iOPINION_WEIGHT_BROKEN_NO_CONVERT_PROMISE = getDefineINT("OPINION_WEIGHT_BROKEN_NO_CONVERT_PROMISE");

	push	1
	push	OFFSET $SG231103
	mov	ecx, esi
	mov	DWORD PTR [esi+3712], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5462 : 	m_iOPINION_WEIGHT_IGNORED_NO_CONVERT_PROMISE = getDefineINT("OPINION_WEIGHT_IGNORED_NO_CONVERT_PROMISE");

	push	1
	push	OFFSET $SG231104
	mov	ecx, esi
	mov	DWORD PTR [esi+3716], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5463 : 	m_iOPINION_WEIGHT_BROKEN_NO_DIG_PROMISE = getDefineINT("OPINION_WEIGHT_BROKEN_NO_DIG_PROMISE");

	push	1
	push	OFFSET $SG231105
	mov	ecx, esi
	mov	DWORD PTR [esi+3720], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5464 : 	m_iOPINION_WEIGHT_IGNORED_NO_DIG_PROMISE = getDefineINT("OPINION_WEIGHT_IGNORED_NO_DIG_PROMISE");

	push	1
	push	OFFSET $SG231106
	mov	ecx, esi
	mov	DWORD PTR [esi+3724], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5465 : 	m_iOPINION_WEIGHT_BROKEN_COOP_WAR_PROMISE = getDefineINT("OPINION_WEIGHT_BROKEN_COOP_WAR_PROMISE");

	push	1
	push	OFFSET $SG231107
	mov	ecx, esi
	mov	DWORD PTR [esi+3728], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5466 : 	m_iOPINION_WEIGHT_KILLED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN = getDefineINT("OPINION_WEIGHT_KILLED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN");

	push	1
	push	OFFSET $SG231108
	mov	ecx, esi
	mov	DWORD PTR [esi+3732], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5467 : 	m_iOPINION_WEIGHT_KILLED_PROTECTED_MINOR = getDefineINT("OPINION_WEIGHT_KILLED_PROTECTED_MINOR");

	push	1
	push	OFFSET $SG231109
	mov	ecx, esi
	mov	DWORD PTR [esi+3736], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5468 : 	m_iOPINION_WEIGHT_KILLED_MANY_PROTECTED_MINORS = getDefineINT("OPINION_WEIGHT_KILLED_MANY_PROTECTED_MINORS");

	push	1
	push	OFFSET $SG231110
	mov	ecx, esi
	mov	DWORD PTR [esi+3740], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5469 : 	m_iOPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN = getDefineINT("OPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN");

	push	1
	push	OFFSET $SG231111
	mov	ecx, esi
	mov	DWORD PTR [esi+3744], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5470 : 	m_iOPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_RECENTLY_NUM_TURNS = getDefineINT("OPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_RECENTLY_NUM_TURNS");

	push	1
	push	OFFSET $SG231112
	mov	ecx, esi
	mov	DWORD PTR [esi+3748], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5471 : 	m_iOPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_RECENTLY = getDefineINT("OPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_RECENTLY");

	push	1
	push	OFFSET $SG231113
	mov	ecx, esi
	mov	DWORD PTR [esi+3752], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5472 : 	m_iOPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_WHILE_AGO = getDefineINT("OPINION_WEIGHT_ATTACKED_PROTECTED_MINOR_WHILE_AGO");

	push	1
	push	OFFSET $SG231114
	mov	ecx, esi
	mov	DWORD PTR [esi+3756], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5473 : 	m_iOPINION_WEIGHT_ATTACKED_MANY_PROTECTED_MINORS = getDefineINT("OPINION_WEIGHT_ATTACKED_MANY_PROTECTED_MINORS");

	push	1
	push	OFFSET $SG231115
	mov	ecx, esi
	mov	DWORD PTR [esi+3760], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5474 : 	m_iOPINION_WEIGHT_BULLIED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN = getDefineINT("OPINION_WEIGHT_BULLIED_PROTECTED_MINOR_NUM_TURNS_UNTIL_FORGIVEN");

	push	1
	push	OFFSET $SG231116
	mov	ecx, esi
	mov	DWORD PTR [esi+3764], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5475 : 	m_iOPINION_WEIGHT_BULLIED_PROTECTED_MINOR_RECENTLY_NUM_TURNS = getDefineINT("OPINION_WEIGHT_BULLIED_PROTECTED_MINOR_RECENTLY_NUM_TURNS");

	push	1
	push	OFFSET $SG231117
	mov	ecx, esi
	mov	DWORD PTR [esi+3768], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+3772], eax

; 5476 : 	m_iOPINION_WEIGHT_BULLIED_PROTECTED_MINOR_RECENTLY = getDefineINT("OPINION_WEIGHT_BULLIED_PROTECTED_MINOR_RECENTLY");

	push	1
	push	OFFSET $SG231118
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5477 : 	m_iOPINION_WEIGHT_BULLIED_PROTECTED_MINOR_WHILE_AGO = getDefineINT("OPINION_WEIGHT_BULLIED_PROTECTED_MINOR_WHILE_AGO");

	push	1
	push	OFFSET $SG231119
	mov	ecx, esi
	mov	DWORD PTR [esi+3776], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5478 : 	m_iOPINION_WEIGHT_BULLIED_MANY_PROTECTED_MINORS = getDefineINT("OPINION_WEIGHT_BULLIED_MANY_PROTECTED_MINORS");

	push	1
	push	OFFSET $SG231120
	mov	ecx, esi
	mov	DWORD PTR [esi+3780], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5479 : 	m_iOPINION_WEIGHT_SIDED_WITH_THEIR_MINOR_NUM_TURNS_UNTIL_FORGIVEN = getDefineINT("OPINION_WEIGHT_SIDED_WITH_THEIR_MINOR_NUM_TURNS_UNTIL_FORGIVEN");

	push	1
	push	OFFSET $SG231121
	mov	ecx, esi
	mov	DWORD PTR [esi+3784], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5480 : 	m_iOPINION_WEIGHT_SIDED_WITH_THEIR_MINOR = getDefineINT("OPINION_WEIGHT_SIDED_WITH_THEIR_MINOR");

	push	1
	push	OFFSET $SG231122
	mov	ecx, esi
	mov	DWORD PTR [esi+3788], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5481 : 	m_iOPINION_WEIGHT_DOF = getDefineINT("OPINION_WEIGHT_DOF");

	push	1
	push	OFFSET $SG231123
	mov	ecx, esi
	mov	DWORD PTR [esi+3792], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5482 : 	m_iOPINION_WEIGHT_DOF_WITH_FRIEND = getDefineINT("OPINION_WEIGHT_DOF_WITH_FRIEND");

	push	1
	push	OFFSET $SG231124
	mov	ecx, esi
	mov	DWORD PTR [esi+3796], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5483 : 	m_iOPINION_WEIGHT_DOF_WITH_ENEMY = getDefineINT("OPINION_WEIGHT_DOF_WITH_ENEMY");

	push	1
	push	OFFSET $SG231125
	mov	ecx, esi
	mov	DWORD PTR [esi+3800], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5484 : 	m_iOPINION_WEIGHT_DENOUNCED_BY_FRIEND_EACH = getDefineINT("OPINION_WEIGHT_DENOUNCED_BY_FRIEND_EACH");

	push	1
	push	OFFSET $SG231126
	mov	ecx, esi
	mov	DWORD PTR [esi+3804], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5485 : 	m_iOPINION_WEIGHT_DENOUNCED_BY_FRIEND_DONT_LIKE = getDefineINT("OPINION_WEIGHT_DENOUNCED_BY_FRIEND_DONT_LIKE");

	push	1
	push	OFFSET $SG231127
	mov	ecx, esi
	mov	DWORD PTR [esi+3808], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5486 : 	m_iOPINION_WEIGHT_DENOUNCED_FRIEND_EACH = getDefineINT("OPINION_WEIGHT_DENOUNCED_FRIEND_EACH");

	push	1
	push	OFFSET $SG231128
	mov	ecx, esi
	mov	DWORD PTR [esi+3812], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5487 : 	m_iOPINION_WEIGHT_DENOUNCED_ME_FRIENDS = getDefineINT("OPINION_WEIGHT_DENOUNCED_ME_FRIENDS");

	push	1
	push	OFFSET $SG231129
	mov	ecx, esi
	mov	DWORD PTR [esi+3816], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5488 : 	m_iOPINION_WEIGHT_WAR_FRIEND_EACH = getDefineINT("OPINION_WEIGHT_WAR_FRIEND_EACH");

	push	1
	push	OFFSET $SG231130
	mov	ecx, esi
	mov	DWORD PTR [esi+3820], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5489 : 	m_iOPINION_WEIGHT_WAR_ME_FRIENDS = getDefineINT("OPINION_WEIGHT_WAR_ME_FRIENDS");

	push	1
	push	OFFSET $SG231131
	mov	ecx, esi
	mov	DWORD PTR [esi+3824], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5490 : 	m_iOPINION_WEIGHT_REFUSED_REQUEST_EACH = getDefineINT("OPINION_WEIGHT_REFUSED_REQUEST_EACH");

	push	1
	push	OFFSET $SG231132
	mov	ecx, esi
	mov	DWORD PTR [esi+3828], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5491 : 	m_iOPINION_WEIGHT_DENOUNCED_ME = getDefineINT("OPINION_WEIGHT_DENOUNCED_ME");

	push	1
	push	OFFSET $SG231133
	mov	ecx, esi
	mov	DWORD PTR [esi+3832], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+3836], eax

; 5492 : 	m_iOPINION_WEIGHT_DENOUNCED_THEM = getDefineINT("OPINION_WEIGHT_DENOUNCED_THEM");

	push	1
	push	OFFSET $SG231134
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5493 : 	m_iOPINION_WEIGHT_DENOUNCED_FRIEND = getDefineINT("OPINION_WEIGHT_DENOUNCED_FRIEND");

	push	1
	push	OFFSET $SG231135
	mov	ecx, esi
	mov	DWORD PTR [esi+3840], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5494 : 	m_iOPINION_WEIGHT_DENOUNCED_ENEMY = getDefineINT("OPINION_WEIGHT_DENOUNCED_ENEMY");

	push	1
	push	OFFSET $SG231136
	mov	ecx, esi
	mov	DWORD PTR [esi+3844], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5495 : 	m_iOPINION_WEIGHT_RECKLESS_EXPANDER = getDefineINT("OPINION_WEIGHT_RECKLESS_EXPANDER");

	push	1
	push	OFFSET $SG231137
	mov	ecx, esi
	mov	DWORD PTR [esi+3848], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5496 : 	m_iOPINION_WEIGHT_TRADE_MAX = getDefineINT("OPINION_WEIGHT_TRADE_MAX");

	push	1
	push	OFFSET $SG231138
	mov	ecx, esi
	mov	DWORD PTR [esi+3852], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5497 : 	m_iOPINION_WEIGHT_COMMON_FOE_MAX = getDefineINT("OPINION_WEIGHT_COMMON_FOE_MAX");

	push	1
	push	OFFSET $SG231139
	mov	ecx, esi
	mov	DWORD PTR [esi+3856], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5498 : 	m_iOPINION_WEIGHT_ASSIST_MAX = getDefineINT("OPINION_WEIGHT_ASSIST_MAX");

	push	1
	push	OFFSET $SG231140
	mov	ecx, esi
	mov	DWORD PTR [esi+3860], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5499 : 	m_iOPINION_WEIGHT_LIBERATED_CAPITAL = getDefineINT("OPINION_WEIGHT_LIBERATED_CAPITAL");

	push	1
	push	OFFSET $SG231141
	mov	ecx, esi
	mov	DWORD PTR [esi+3864], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5500 : 	m_iOPINION_WEIGHT_LIBERATED_CITY = getDefineINT("OPINION_WEIGHT_LIBERATED_CITY");

	push	1
	push	OFFSET $SG231142
	mov	ecx, esi
	mov	DWORD PTR [esi+3868], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5501 : 	m_iOPINION_WEIGHT_GAVE_ASSISTANCE = getDefineINT("OPINION_WEIGHT_GAVE_ASSISTANCE");

	push	1
	push	OFFSET $SG231143
	mov	ecx, esi
	mov	DWORD PTR [esi+3872], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5502 : 	m_iOPINION_WEIGHT_PAID_TRIBUTE = getDefineINT("OPINION_WEIGHT_PAID_TRIBUTE");

	push	1
	push	OFFSET $SG231144
	mov	ecx, esi
	mov	DWORD PTR [esi+3876], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5503 : 	m_iOPINION_WEIGHT_NUKED_MAX = getDefineINT("OPINION_WEIGHT_NUKED_MAX");

	push	1
	push	OFFSET $SG231145
	mov	ecx, esi
	mov	DWORD PTR [esi+3880], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5504 : 	m_iOPINION_WEIGHT_ROBBED_BY = getDefineINT("OPINION_WEIGHT_ROBBED_BY");

	push	1
	push	OFFSET $SG231146
	mov	ecx, esi
	mov	DWORD PTR [esi+3884], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5505 : 	m_iOPINION_WEIGHT_INTRIGUE_SHARED_BY = getDefineINT("OPINION_WEIGHT_INTRIGUE_SHARED_BY");

	push	1
	push	OFFSET $SG231147
	mov	ecx, esi
	mov	DWORD PTR [esi+3888], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5506 : 	m_iOPINION_WEIGHT_CAPTURED_CAPITAL = getDefineINT("OPINION_WEIGHT_CAPTURED_CAPITAL");

	push	1
	push	OFFSET $SG231148
	mov	ecx, esi
	mov	DWORD PTR [esi+3892], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5507 : 	m_iOPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL = getDefineINT("OPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL");

	push	1
	push	OFFSET $SG231149
	mov	ecx, esi
	mov	DWORD PTR [esi+3896], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5508 : 	m_iOPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL_NUM_TURNS = getDefineINT("OPINION_WEIGHT_WE_LIKED_THEIR_PROPOSAL_NUM_TURNS");

	push	1
	mov	DWORD PTR [esi+3900], eax
	push	OFFSET $SG231150
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5509 : 	m_iOPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL = getDefineINT("OPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL");

	push	1
	push	OFFSET $SG231151
	mov	ecx, esi
	mov	DWORD PTR [esi+3904], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5510 : 	m_iOPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL_NUM_TURNS = getDefineINT("OPINION_WEIGHT_WE_DISLIKED_THEIR_PROPOSAL_NUM_TURNS");

	push	1
	push	OFFSET $SG231152
	mov	ecx, esi
	mov	DWORD PTR [esi+3908], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5511 : 	m_iOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL = getDefineINT("OPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL");

	push	1
	push	OFFSET $SG231153
	mov	ecx, esi
	mov	DWORD PTR [esi+3912], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5512 : 	m_iOPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL_NUM_TURNS = getDefineINT("OPINION_WEIGHT_THEY_SUPPORTED_OUR_PROPOSAL_NUM_TURNS");

	push	1
	push	OFFSET $SG231154
	mov	ecx, esi
	mov	DWORD PTR [esi+3916], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5513 : 	m_iOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL = getDefineINT("OPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL");

	push	1
	push	OFFSET $SG231155
	mov	ecx, esi
	mov	DWORD PTR [esi+3920], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5514 : 	m_iOPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL_NUM_TURNS = getDefineINT("OPINION_WEIGHT_THEY_FOILED_OUR_PROPOSAL_NUM_TURNS");

	push	1
	push	OFFSET $SG231156
	mov	ecx, esi
	mov	DWORD PTR [esi+3924], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5515 : 	m_iOPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING = getDefineINT("OPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING");

	push	1
	push	OFFSET $SG231157
	mov	ecx, esi
	mov	DWORD PTR [esi+3928], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5516 : 	m_iOPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING_NUM_TURNS = getDefineINT("OPINION_WEIGHT_THEY_SUPPORTED_OUR_HOSTING_NUM_TURNS");

	push	1
	push	OFFSET $SG231158
	mov	ecx, esi
	mov	DWORD PTR [esi+3932], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5517 : 	m_iOPINION_THRESHOLD_UNFORGIVABLE = getDefineINT("OPINION_THRESHOLD_UNFORGIVABLE");

	push	1
	push	OFFSET $SG231159
	mov	ecx, esi
	mov	DWORD PTR [esi+3936], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5518 : 	m_iOPINION_THRESHOLD_ENEMY = getDefineINT("OPINION_THRESHOLD_ENEMY");

	push	1
	push	OFFSET $SG231160
	mov	ecx, esi
	mov	DWORD PTR [esi+3940], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5519 : 	m_iOPINION_THRESHOLD_COMPETITOR = getDefineINT("OPINION_THRESHOLD_COMPETITOR");

	push	1
	push	OFFSET $SG231161
	mov	ecx, esi
	mov	DWORD PTR [esi+3944], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5520 : 	m_iOPINION_THRESHOLD_FAVORABLE = getDefineINT("OPINION_THRESHOLD_FAVORABLE");

	push	1
	push	OFFSET $SG231162
	mov	ecx, esi
	mov	DWORD PTR [esi+3948], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5521 : 	m_iOPINION_THRESHOLD_FRIEND = getDefineINT("OPINION_THRESHOLD_FRIEND");

	push	1
	push	OFFSET $SG231163
	mov	ecx, esi
	mov	DWORD PTR [esi+3952], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5522 : 	m_iOPINION_THRESHOLD_ALLY = getDefineINT("OPINION_THRESHOLD_ALLY");

	push	1
	push	OFFSET $SG231164
	mov	ecx, esi
	mov	DWORD PTR [esi+3956], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5523 : 	m_iAPPROACH_NEUTRAL_DEFAULT = getDefineINT("APPROACH_NEUTRAL_DEFAULT");

	push	1
	push	OFFSET $SG231165
	mov	ecx, esi
	mov	DWORD PTR [esi+3960], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5524 : 	m_iAPPROACH_BIAS_FOR_CURRENT = getDefineINT("APPROACH_BIAS_FOR_CURRENT");

	push	1
	mov	DWORD PTR [esi+3964], eax
	push	OFFSET $SG231166
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5525 : 	m_iAPPROACH_WAR_CURRENTLY_DECEPTIVE = getDefineINT("APPROACH_WAR_CURRENTLY_DECEPTIVE");

	push	1
	push	OFFSET $SG231167
	mov	ecx, esi
	mov	DWORD PTR [esi+3968], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5526 : 	m_iAPPROACH_HOSTILE_CURRENTLY_HOSTILE = getDefineINT("APPROACH_HOSTILE_CURRENTLY_HOSTILE");

	push	1
	push	OFFSET $SG231168
	mov	ecx, esi
	mov	DWORD PTR [esi+3972], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5527 : 	m_iAPPROACH_WAR_CURRENTLY_WAR = getDefineINT("APPROACH_WAR_CURRENTLY_WAR");

	push	1
	push	OFFSET $SG231169
	mov	ecx, esi
	mov	DWORD PTR [esi+3976], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5528 : 	m_iAPPROACH_RANDOM_PERCENT = getDefineINT("APPROACH_RANDOM_PERCENT");

	push	1
	push	OFFSET $SG231170
	mov	ecx, esi
	mov	DWORD PTR [esi+3980], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5529 : 	m_iAPPROACH_WAR_CONQUEST_GRAND_STRATEGY = getDefineINT("APPROACH_WAR_CONQUEST_GRAND_STRATEGY");

	push	1
	push	OFFSET $SG231171
	mov	ecx, esi
	mov	DWORD PTR [esi+3984], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5530 : 	m_iAPPROACH_OPINION_UNFORGIVABLE_WAR = getDefineINT("APPROACH_OPINION_UNFORGIVABLE_WAR");

	push	1
	push	OFFSET $SG231172
	mov	ecx, esi
	mov	DWORD PTR [esi+3988], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5531 : 	m_iAPPROACH_OPINION_UNFORGIVABLE_HOSTILE = getDefineINT("APPROACH_OPINION_UNFORGIVABLE_HOSTILE");

	push	1
	push	OFFSET $SG231173
	mov	ecx, esi
	mov	DWORD PTR [esi+3992], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5532 : 	m_iAPPROACH_OPINION_UNFORGIVABLE_DECEPTIVE = getDefineINT("APPROACH_OPINION_UNFORGIVABLE_DECEPTIVE");

	push	1
	push	OFFSET $SG231174
	mov	ecx, esi
	mov	DWORD PTR [esi+3996], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5533 : 	m_iAPPROACH_OPINION_UNFORGIVABLE_GUARDED = getDefineINT("APPROACH_OPINION_UNFORGIVABLE_GUARDED");

	push	1
	push	OFFSET $SG231175
	mov	ecx, esi
	mov	DWORD PTR [esi+4000], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5534 : 	m_iAPPROACH_OPINION_ENEMY_WAR = getDefineINT("APPROACH_OPINION_ENEMY_WAR");

	push	1
	push	OFFSET $SG231176
	mov	ecx, esi
	mov	DWORD PTR [esi+4004], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5535 : 	m_iAPPROACH_OPINION_ENEMY_HOSTILE = getDefineINT("APPROACH_OPINION_ENEMY_HOSTILE");

	push	1
	push	OFFSET $SG231177
	mov	ecx, esi
	mov	DWORD PTR [esi+4008], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5536 : 	m_iAPPROACH_OPINION_ENEMY_DECEPTIVE = getDefineINT("APPROACH_OPINION_ENEMY_DECEPTIVE");

	push	1
	push	OFFSET $SG231178
	mov	ecx, esi
	mov	DWORD PTR [esi+4012], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5537 : 	m_iAPPROACH_OPINION_ENEMY_GUARDED = getDefineINT("APPROACH_OPINION_ENEMY_GUARDED");

	push	1
	push	OFFSET $SG231179
	mov	ecx, esi
	mov	DWORD PTR [esi+4016], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5538 : 	m_iAPPROACH_OPINION_COMPETITOR_WAR = getDefineINT("APPROACH_OPINION_COMPETITOR_WAR");

	push	1
	push	OFFSET $SG231180
	mov	ecx, esi
	mov	DWORD PTR [esi+4020], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5539 : 	m_iAPPROACH_OPINION_COMPETITOR_HOSTILE = getDefineINT("APPROACH_OPINION_COMPETITOR_HOSTILE");

	push	1
	push	OFFSET $SG231181
	mov	ecx, esi
	mov	DWORD PTR [esi+4024], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5540 : 	m_iAPPROACH_OPINION_COMPETITOR_DECEPTIVE = getDefineINT("APPROACH_OPINION_COMPETITOR_DECEPTIVE");

	push	1
	push	OFFSET $SG231182
	mov	ecx, esi
	mov	DWORD PTR [esi+4028], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5541 : 	m_iAPPROACH_OPINION_COMPETITOR_GUARDED = getDefineINT("APPROACH_OPINION_COMPETITOR_GUARDED");

	push	1
	push	OFFSET $SG231183
	mov	ecx, esi
	mov	DWORD PTR [esi+4032], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5542 : 	m_iAPPROACH_OPINION_NEUTRAL_DECEPTIVE = getDefineINT("APPROACH_OPINION_NEUTRAL_DECEPTIVE");

	push	1
	push	OFFSET $SG231184
	mov	ecx, esi
	mov	DWORD PTR [esi+4036], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5543 : 	m_iAPPROACH_OPINION_NEUTRAL_FRIENDLY = getDefineINT("APPROACH_OPINION_NEUTRAL_FRIENDLY");

	push	1
	push	OFFSET $SG231185
	mov	ecx, esi
	mov	DWORD PTR [esi+4040], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5544 : 	m_iAPPROACH_OPINION_FAVORABLE_HOSTILE = getDefineINT("APPROACH_OPINION_FAVORABLE_HOSTILE");

	push	1
	push	OFFSET $SG231186
	mov	ecx, esi
	mov	DWORD PTR [esi+4044], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5545 : 	m_iAPPROACH_OPINION_FAVORABLE_DECEPTIVE = getDefineINT("APPROACH_OPINION_FAVORABLE_DECEPTIVE");

	push	1
	push	OFFSET $SG231187
	mov	ecx, esi
	mov	DWORD PTR [esi+4048], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5546 : 	m_iAPPROACH_OPINION_FAVORABLE_FRIENDLY = getDefineINT("APPROACH_OPINION_FAVORABLE_FRIENDLY");

	push	1
	push	OFFSET $SG231188
	mov	ecx, esi
	mov	DWORD PTR [esi+4052], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5547 : 	m_iAPPROACH_OPINION_FRIEND_HOSTILE = getDefineINT("APPROACH_OPINION_FRIEND_HOSTILE");

	push	1
	push	OFFSET $SG231189
	mov	ecx, esi
	mov	DWORD PTR [esi+4056], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5548 : 	m_iAPPROACH_OPINION_FRIEND_FRIENDLY = getDefineINT("APPROACH_OPINION_FRIEND_FRIENDLY");

	push	1
	push	OFFSET $SG231190
	mov	ecx, esi
	mov	DWORD PTR [esi+4060], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5549 : 	m_iAPPROACH_OPINION_ALLY_FRIENDLY = getDefineINT("APPROACH_OPINION_ALLY_FRIENDLY");

	push	1
	push	OFFSET $SG231191
	mov	ecx, esi
	mov	DWORD PTR [esi+4064], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5550 : 	m_iAPPROACH_DECEPTIVE_WORKING_WITH_PLAYER = getDefineINT("APPROACH_DECEPTIVE_WORKING_WITH_PLAYER");

	push	1
	push	OFFSET $SG231192
	mov	ecx, esi
	mov	DWORD PTR [esi+4068], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5551 : 	m_iAPPROACH_FRIENDLY_WORKING_WITH_PLAYER = getDefineINT("APPROACH_FRIENDLY_WORKING_WITH_PLAYER");

	push	1
	push	OFFSET $SG231193
	mov	ecx, esi
	mov	DWORD PTR [esi+4072], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5552 : 	m_iAPPROACH_HOSTILE_WORKING_WITH_PLAYER = getDefineINT("APPROACH_HOSTILE_WORKING_WITH_PLAYER");

	push	1
	push	OFFSET $SG231194
	mov	ecx, esi
	mov	DWORD PTR [esi+4076], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5553 : 	m_iAPPROACH_GUARDED_WORKING_WITH_PLAYER = getDefineINT("APPROACH_GUARDED_WORKING_WITH_PLAYER");

	push	1
	push	OFFSET $SG231195
	mov	ecx, esi
	mov	DWORD PTR [esi+4080], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5554 : 	m_iAPPROACH_DECEPTIVE_WORKING_AGAINST_PLAYER = getDefineINT("APPROACH_DECEPTIVE_WORKING_AGAINST_PLAYER");

	push	1
	push	OFFSET $SG231196
	mov	ecx, esi
	mov	DWORD PTR [esi+4084], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5555 : 	m_iAPPROACH_HOSTILE_WORKING_AGAINST_PLAYER = getDefineINT("APPROACH_HOSTILE_WORKING_AGAINST_PLAYER");

	push	1
	push	OFFSET $SG231197
	mov	ecx, esi
	mov	DWORD PTR [esi+4088], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5556 : 	m_iAPPROACH_WAR_WORKING_AGAINST_PLAYER = getDefineINT("APPROACH_WAR_WORKING_AGAINST_PLAYER");

	push	1
	push	OFFSET $SG231198
	mov	ecx, esi
	mov	DWORD PTR [esi+4092], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+4096], eax

; 5557 : 	m_iAPPROACH_WAR_DENOUNCED = getDefineINT("APPROACH_WAR_DENOUNCED");

	push	1
	push	OFFSET $SG231199
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5558 : 	m_iAPPROACH_HOSTILE_DENOUNCED = getDefineINT("APPROACH_HOSTILE_DENOUNCED");

	push	1
	push	OFFSET $SG231200
	mov	ecx, esi
	mov	DWORD PTR [esi+4100], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5559 : 	m_iAPPROACH_GUARDED_DENOUNCED = getDefineINT("APPROACH_GUARDED_DENOUNCED");

	push	1
	push	OFFSET $SG231201
	mov	ecx, esi
	mov	DWORD PTR [esi+4104], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5560 : 	m_iAPPROACH_FRIENDLY_DENOUNCED = getDefineINT("APPROACH_FRIENDLY_DENOUNCED");

	push	1
	push	OFFSET $SG231202
	mov	ecx, esi
	mov	DWORD PTR [esi+4108], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5561 : 	m_iAPPROACH_DECEPTIVE_DENOUNCED = getDefineINT("APPROACH_DECEPTIVE_DENOUNCED");

	push	1
	push	OFFSET $SG231203
	mov	ecx, esi
	mov	DWORD PTR [esi+4112], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5562 : 	m_iAPPROACH_ATTACKED_PROTECTED_MINOR_WAR = getDefineINT("APPROACH_ATTACKED_PROTECTED_MINOR_WAR");

	push	1
	push	OFFSET $SG231204
	mov	ecx, esi
	mov	DWORD PTR [esi+4116], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5563 : 	m_iAPPROACH_ATTACKED_PROTECTED_MINOR_HOSTILE = getDefineINT("APPROACH_ATTACKED_PROTECTED_MINOR_HOSTILE");

	push	1
	push	OFFSET $SG231205
	mov	ecx, esi
	mov	DWORD PTR [esi+4120], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5564 : 	m_iAPPROACH_ATTACKED_PROTECTED_MINOR_GUARDED = getDefineINT("APPROACH_ATTACKED_PROTECTED_MINOR_GUARDED");

	push	1
	push	OFFSET $SG231206
	mov	ecx, esi
	mov	DWORD PTR [esi+4124], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5565 : 	m_iAPPROACH_ATTACKED_PROTECTED_MINOR_PAST_WAR = getDefineINT("APPROACH_ATTACKED_PROTECTED_MINOR_PAST_WAR");

	push	1
	push	OFFSET $SG231207
	mov	ecx, esi
	mov	DWORD PTR [esi+4128], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5566 : 	m_iAPPROACH_ATTACKED_PROTECTED_MINOR_PAST_HOSTILE = getDefineINT("APPROACH_ATTACKED_PROTECTED_MINOR_PAST_HOSTILE");

	push	1
	push	OFFSET $SG231208
	mov	ecx, esi
	mov	DWORD PTR [esi+4132], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5567 : 	m_iAPPROACH_ATTACKED_PROTECTED_MINOR_PAST_GUARDED = getDefineINT("APPROACH_ATTACKED_PROTECTED_MINOR_PAST_GUARDED");

	push	1
	push	OFFSET $SG231209
	mov	ecx, esi
	mov	DWORD PTR [esi+4136], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5568 : 	m_iAPPROACH_DECEPTIVE_MILITARY_THREAT_CRITICAL = getDefineINT("APPROACH_DECEPTIVE_MILITARY_THREAT_CRITICAL");

	push	1
	push	OFFSET $SG231210
	mov	ecx, esi
	mov	DWORD PTR [esi+4140], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5569 : 	m_iAPPROACH_GUARDED_MILITARY_THREAT_CRITICAL = getDefineINT("APPROACH_GUARDED_MILITARY_THREAT_CRITICAL");

	push	1
	push	OFFSET $SG231211
	mov	ecx, esi
	mov	DWORD PTR [esi+4144], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5570 : 	m_iAPPROACH_AFRAID_MILITARY_THREAT_CRITICAL = getDefineINT("APPROACH_AFRAID_MILITARY_THREAT_CRITICAL");

	push	1
	push	OFFSET $SG231212
	mov	ecx, esi
	mov	DWORD PTR [esi+4148], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5571 : 	m_iAPPROACH_DECEPTIVE_DEMAND = getDefineINT("APPROACH_DECEPTIVE_DEMAND");

	push	1
	push	OFFSET $SG231213
	mov	ecx, esi
	mov	DWORD PTR [esi+4152], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5572 : 	m_iAPPROACH_FRIENDLY_DEMAND = getDefineINT("APPROACH_FRIENDLY_DEMAND");

	push	1
	push	OFFSET $SG231214
	mov	ecx, esi
	mov	DWORD PTR [esi+4156], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+4160], eax

; 5573 : 	m_iAPPROACH_WAR_BROKEN_MILITARY_PROMISE = getDefineINT("APPROACH_WAR_BROKEN_MILITARY_PROMISE");

	push	1
	push	OFFSET $SG231215
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5574 : 	m_iAPPROACH_DECEPTIVE_BROKEN_MILITARY_PROMISE = getDefineINT("APPROACH_DECEPTIVE_BROKEN_MILITARY_PROMISE");

	push	1
	push	OFFSET $SG231216
	mov	ecx, esi
	mov	DWORD PTR [esi+4164], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5575 : 	m_iAPPROACH_FRIENDLY_BROKEN_MILITARY_PROMISE = getDefineINT("APPROACH_FRIENDLY_BROKEN_MILITARY_PROMISE");

	push	1
	push	OFFSET $SG231217
	mov	ecx, esi
	mov	DWORD PTR [esi+4168], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5576 : 	m_iAPPROACH_WAR_BROKEN_MILITARY_PROMISE_WORLD = getDefineINT("APPROACH_WAR_BROKEN_MILITARY_PROMISE_WORLD");

	push	1
	push	OFFSET $SG231218
	mov	ecx, esi
	mov	DWORD PTR [esi+4172], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5577 : 	m_iAPPROACH_DECEPTIVE_BROKEN_MILITARY_PROMISE_WORLD = getDefineINT("APPROACH_DECEPTIVE_BROKEN_MILITARY_PROMISE_WORLD");

	push	1
	push	OFFSET $SG231219
	mov	ecx, esi
	mov	DWORD PTR [esi+4176], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5578 : 	m_iAPPROACH_FRIENDLY_BROKEN_MILITARY_PROMISE_WORLD = getDefineINT("APPROACH_FRIENDLY_BROKEN_MILITARY_PROMISE_WORLD");

	push	1
	push	OFFSET $SG231220
	mov	ecx, esi
	mov	DWORD PTR [esi+4180], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5579 : 	m_iAPPROACH_DECEPTIVE_IGNORED_MILITARY_PROMISE = getDefineINT("APPROACH_DECEPTIVE_IGNORED_MILITARY_PROMISE");

	push	1
	push	OFFSET $SG231221
	mov	ecx, esi
	mov	DWORD PTR [esi+4184], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5580 : 	m_iAPPROACH_FRIENDLY_IGNORED_MILITARY_PROMISE = getDefineINT("APPROACH_FRIENDLY_IGNORED_MILITARY_PROMISE");

	push	1
	push	OFFSET $SG231222
	mov	ecx, esi
	mov	DWORD PTR [esi+4188], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5581 : 	m_iAPPROACH_WAR_BROKEN_EXPANSION_PROMISE = getDefineINT("APPROACH_WAR_BROKEN_EXPANSION_PROMISE");

	push	1
	push	OFFSET $SG231223
	mov	ecx, esi
	mov	DWORD PTR [esi+4192], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5582 : 	m_iAPPROACH_DECEPTIVE_BROKEN_EXPANSION_PROMISE = getDefineINT("APPROACH_DECEPTIVE_BROKEN_EXPANSION_PROMISE");

	push	1
	push	OFFSET $SG231224
	mov	ecx, esi
	mov	DWORD PTR [esi+4196], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5583 : 	m_iAPPROACH_FRIENDLY_BROKEN_EXPANSION_PROMISE = getDefineINT("APPROACH_FRIENDLY_BROKEN_EXPANSION_PROMISE");

	push	1
	push	OFFSET $SG231225
	mov	ecx, esi
	mov	DWORD PTR [esi+4200], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5584 : 	m_iAPPROACH_WAR_IGNORED_EXPANSION_PROMISE = getDefineINT("APPROACH_WAR_IGNORED_EXPANSION_PROMISE");

	push	1
	push	OFFSET $SG231226
	mov	ecx, esi
	mov	DWORD PTR [esi+4204], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5585 : 	m_iAPPROACH_DECEPTIVE_IGNORED_EXPANSION_PROMISE = getDefineINT("APPROACH_DECEPTIVE_IGNORED_EXPANSION_PROMISE");

	push	1
	push	OFFSET $SG231227
	mov	ecx, esi
	mov	DWORD PTR [esi+4208], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5586 : 	m_iAPPROACH_FRIENDLY_IGNORED_EXPANSION_PROMISE = getDefineINT("APPROACH_FRIENDLY_IGNORED_EXPANSION_PROMISE");

	push	1
	push	OFFSET $SG231228
	mov	ecx, esi
	mov	DWORD PTR [esi+4212], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5587 : 	m_iAPPROACH_WAR_BROKEN_BORDER_PROMISE = getDefineINT("APPROACH_WAR_BROKEN_BORDER_PROMISE");

	push	1
	push	OFFSET $SG231229
	mov	ecx, esi
	mov	DWORD PTR [esi+4216], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5588 : 	m_iAPPROACH_DECEPTIVE_BROKEN_BORDER_PROMISE = getDefineINT("APPROACH_DECEPTIVE_BROKEN_BORDER_PROMISE");

	push	1
	push	OFFSET $SG231230
	mov	ecx, esi
	mov	DWORD PTR [esi+4220], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5589 : 	m_iAPPROACH_FRIENDLY_BROKEN_BORDER_PROMISE = getDefineINT("APPROACH_FRIENDLY_BROKEN_BORDER_PROMISE");

	push	1
	mov	DWORD PTR [esi+4224], eax
	push	OFFSET $SG231231
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5590 : 	m_iAPPROACH_WAR_IGNORED_BORDER_PROMISE = getDefineINT("APPROACH_WAR_IGNORED_BORDER_PROMISE");

	push	1
	push	OFFSET $SG231232
	mov	ecx, esi
	mov	DWORD PTR [esi+4228], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5591 : 	m_iAPPROACH_DECEPTIVE_IGNORED_BORDER_PROMISE = getDefineINT("APPROACH_DECEPTIVE_IGNORED_BORDER_PROMISE");

	push	1
	push	OFFSET $SG231233
	mov	ecx, esi
	mov	DWORD PTR [esi+4232], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5592 : 	m_iAPPROACH_FRIENDLY_IGNORED_BORDER_PROMISE = getDefineINT("APPROACH_FRIENDLY_IGNORED_BORDER_PROMISE");

	push	1
	push	OFFSET $SG231234
	mov	ecx, esi
	mov	DWORD PTR [esi+4236], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5593 : 	m_iAPPROACH_WAR_BROKEN_CITY_STATE_PROMISE = getDefineINT("APPROACH_WAR_BROKEN_CITY_STATE_PROMISE");

	push	1
	push	OFFSET $SG231235
	mov	ecx, esi
	mov	DWORD PTR [esi+4240], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5594 : 	m_iAPPROACH_DECEPTIVE_BROKEN_CITY_STATE_PROMISE = getDefineINT("APPROACH_DECEPTIVE_BROKEN_CITY_STATE_PROMISE");

	push	1
	push	OFFSET $SG231236
	mov	ecx, esi
	mov	DWORD PTR [esi+4244], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5595 : 	m_iAPPROACH_FRIENDLY_BROKEN_CITY_STATE_PROMISE = getDefineINT("APPROACH_FRIENDLY_BROKEN_CITY_STATE_PROMISE");

	push	1
	push	OFFSET $SG231237
	mov	ecx, esi
	mov	DWORD PTR [esi+4248], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5596 : 	m_iAPPROACH_WAR_BROKEN_CITY_STATE_PROMISE_WORLD = getDefineINT("APPROACH_WAR_BROKEN_CITY_STATE_PROMISE_WORLD");

	push	1
	push	OFFSET $SG231238
	mov	ecx, esi
	mov	DWORD PTR [esi+4252], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5597 : 	m_iAPPROACH_DECEPTIVE_BROKEN_CITY_STATE_PROMISE_WORLD = getDefineINT("APPROACH_DECEPTIVE_BROKEN_CITY_STATE_PROMISE_WORLD");

	push	1
	push	OFFSET $SG231239
	mov	ecx, esi
	mov	DWORD PTR [esi+4256], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5598 : 	m_iAPPROACH_FRIENDLY_BROKEN_CITY_STATE_PROMISE_WORLD = getDefineINT("APPROACH_FRIENDLY_BROKEN_CITY_STATE_PROMISE_WORLD");

	push	1
	push	OFFSET $SG231240
	mov	ecx, esi
	mov	DWORD PTR [esi+4260], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5599 : 	m_iAPPROACH_WAR_IGNORED_CITY_STATE_PROMISE = getDefineINT("APPROACH_WAR_IGNORED_CITY_STATE_PROMISE");

	push	1
	push	OFFSET $SG231241
	mov	ecx, esi
	mov	DWORD PTR [esi+4264], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5600 : 	m_iAPPROACH_DECEPTIVE_IGNORED_CITY_STATE_PROMISE = getDefineINT("APPROACH_DECEPTIVE_IGNORED_CITY_STATE_PROMISE");

	push	1
	push	OFFSET $SG231242
	mov	ecx, esi
	mov	DWORD PTR [esi+4268], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5601 : 	m_iAPPROACH_FRIENDLY_IGNORED_CITY_STATE_PROMISE = getDefineINT("APPROACH_FRIENDLY_IGNORED_CITY_STATE_PROMISE");

	push	1
	push	OFFSET $SG231243
	mov	ecx, esi
	mov	DWORD PTR [esi+4272], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5602 : 	m_iAPPROACH_FRIENDLY_MILITARY_THREAT_CRITICAL = getDefineINT("APPROACH_FRIENDLY_MILITARY_THREAT_CRITICAL");

	push	1
	push	OFFSET $SG231244
	mov	ecx, esi
	mov	DWORD PTR [esi+4276], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5603 : 	m_iAPPROACH_DECEPTIVE_MILITARY_THREAT_SEVERE = getDefineINT("APPROACH_DECEPTIVE_MILITARY_THREAT_SEVERE");

	push	1
	push	OFFSET $SG231245
	mov	ecx, esi
	mov	DWORD PTR [esi+4280], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5604 : 	m_iAPPROACH_GUARDED_MILITARY_THREAT_SEVERE = getDefineINT("APPROACH_GUARDED_MILITARY_THREAT_SEVERE");

	push	1
	push	OFFSET $SG231246
	mov	ecx, esi
	mov	DWORD PTR [esi+4284], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5605 : 	m_iAPPROACH_AFRAID_MILITARY_THREAT_SEVERE = getDefineINT("APPROACH_AFRAID_MILITARY_THREAT_SEVERE");

	push	1
	mov	DWORD PTR [esi+4288], eax
	push	OFFSET $SG231247
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5606 : 	m_iAPPROACH_FRIENDLY_MILITARY_THREAT_SEVERE = getDefineINT("APPROACH_FRIENDLY_MILITARY_THREAT_SEVERE");

	push	1
	push	OFFSET $SG231248
	mov	ecx, esi
	mov	DWORD PTR [esi+4292], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5607 : 	m_iAPPROACH_DECEPTIVE_MILITARY_THREAT_MAJOR = getDefineINT("APPROACH_DECEPTIVE_MILITARY_THREAT_MAJOR");

	push	1
	push	OFFSET $SG231249
	mov	ecx, esi
	mov	DWORD PTR [esi+4296], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5608 : 	m_iAPPROACH_GUARDED_MILITARY_THREAT_MAJOR = getDefineINT("APPROACH_GUARDED_MILITARY_THREAT_MAJOR");

	push	1
	push	OFFSET $SG231250
	mov	ecx, esi
	mov	DWORD PTR [esi+4300], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5609 : 	m_iAPPROACH_AFRAID_MILITARY_THREAT_MAJOR = getDefineINT("APPROACH_AFRAID_MILITARY_THREAT_MAJOR");

	push	1
	push	OFFSET $SG231251
	mov	ecx, esi
	mov	DWORD PTR [esi+4304], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5610 : 	m_iAPPROACH_FRIENDLY_MILITARY_THREAT_MAJOR = getDefineINT("APPROACH_FRIENDLY_MILITARY_THREAT_MAJOR");

	push	1
	push	OFFSET $SG231252
	mov	ecx, esi
	mov	DWORD PTR [esi+4308], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5611 : 	m_iAPPROACH_DECEPTIVE_MILITARY_THREAT_MINOR = getDefineINT("APPROACH_DECEPTIVE_MILITARY_THREAT_MINOR");

	push	1
	push	OFFSET $SG231253
	mov	ecx, esi
	mov	DWORD PTR [esi+4312], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5612 : 	m_iAPPROACH_GUARDED_MILITARY_THREAT_MINOR = getDefineINT("APPROACH_GUARDED_MILITARY_THREAT_MINOR");

	push	1
	push	OFFSET $SG231254
	mov	ecx, esi
	mov	DWORD PTR [esi+4316], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5613 : 	m_iAPPROACH_AFRAID_MILITARY_THREAT_MINOR = getDefineINT("APPROACH_AFRAID_MILITARY_THREAT_MINOR");

	push	1
	push	OFFSET $SG231255
	mov	ecx, esi
	mov	DWORD PTR [esi+4320], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5614 : 	m_iAPPROACH_FRIENDLY_MILITARY_THREAT_MINOR = getDefineINT("APPROACH_FRIENDLY_MILITARY_THREAT_MINOR");

	push	1
	push	OFFSET $SG231256
	mov	ecx, esi
	mov	DWORD PTR [esi+4324], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5615 : 	m_iAPPROACH_HOSTILE_MILITARY_THREAT_NONE = getDefineINT("APPROACH_HOSTILE_MILITARY_THREAT_NONE");

	push	1
	push	OFFSET $SG231257
	mov	ecx, esi
	mov	DWORD PTR [esi+4328], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5616 : 	m_iAPPROACH_WAR_AT_WAR_WITH_PLAYER_WARS_NEUTRAL = getDefineINT("APPROACH_WAR_AT_WAR_WITH_PLAYER_WARS_NEUTRAL");

	push	1
	push	OFFSET $SG231258
	mov	ecx, esi
	mov	DWORD PTR [esi+4332], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5617 : 	m_iAPPROACH_WAR_AT_WAR_WITH_PLAYER_WARS_WINNING = getDefineINT("APPROACH_WAR_AT_WAR_WITH_PLAYER_WARS_WINNING");

	push	1
	push	OFFSET $SG231259
	mov	ecx, esi
	mov	DWORD PTR [esi+4336], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5618 : 	m_iAPPROACH_WAR_AT_WAR_WITH_PLAYER_WARS_LOSING = getDefineINT("APPROACH_WAR_AT_WAR_WITH_PLAYER_WARS_LOSING");

	push	1
	push	OFFSET $SG231260
	mov	ecx, esi
	mov	DWORD PTR [esi+4340], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5619 : 	m_iAPPROACH_HOSTILE_AT_WAR_WITH_PLAYER = getDefineINT("APPROACH_HOSTILE_AT_WAR_WITH_PLAYER");

	push	1
	push	OFFSET $SG231261
	mov	ecx, esi
	mov	DWORD PTR [esi+4344], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5620 : 	m_iAPPROACH_DECEPTIVE_AT_WAR_WITH_PLAYER = getDefineINT("APPROACH_DECEPTIVE_AT_WAR_WITH_PLAYER");

	push	1
	push	OFFSET $SG231262
	mov	ecx, esi
	mov	DWORD PTR [esi+4348], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5621 : 	m_iAPPROACH_GUARDED_AT_WAR_WITH_PLAYER = getDefineINT("APPROACH_GUARDED_AT_WAR_WITH_PLAYER");

	push	1
	push	OFFSET $SG231263
	mov	ecx, esi
	mov	DWORD PTR [esi+4352], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5622 : 	m_iAPPROACH_FRIENDLY_AT_WAR_WITH_PLAYER = getDefineINT("APPROACH_FRIENDLY_AT_WAR_WITH_PLAYER");

	push	1
	push	OFFSET $SG231264
	mov	ecx, esi
	mov	DWORD PTR [esi+4356], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5623 : 	m_iAPPROACH_WAR_PLANNING_WAR_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_WAR_PLANNING_WAR_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231265
	mov	ecx, esi
	mov	DWORD PTR [esi+4360], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5624 : 	m_iAPPROACH_HOSTILE_PLANNING_WAR_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_HOSTILE_PLANNING_WAR_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231266
	mov	ecx, esi
	mov	DWORD PTR [esi+4364], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5625 : 	m_iAPPROACH_DECEPTIVE_PLANNING_WAR_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_DECEPTIVE_PLANNING_WAR_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231267
	mov	ecx, esi
	mov	DWORD PTR [esi+4368], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5626 : 	m_iAPPROACH_GUARDED_PLANNING_WAR_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_GUARDED_PLANNING_WAR_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231268
	mov	ecx, esi
	mov	DWORD PTR [esi+4372], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5627 : 	m_iAPPROACH_FRIENDLY_PLANNING_WAR_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_FRIENDLY_PLANNING_WAR_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231269
	mov	ecx, esi
	mov	DWORD PTR [esi+4376], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5628 : 	m_iAPPROACH_WAR_HOSTILE_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_WAR_HOSTILE_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231270
	mov	ecx, esi
	mov	DWORD PTR [esi+4380], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5629 : 	m_iAPPROACH_HOSTILE_HOSTILE_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_HOSTILE_HOSTILE_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231271
	mov	ecx, esi
	mov	DWORD PTR [esi+4384], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5630 : 	m_iAPPROACH_DECEPTIVE_HOSTILE_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_DECEPTIVE_HOSTILE_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231272
	mov	ecx, esi
	mov	DWORD PTR [esi+4388], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5631 : 	m_iAPPROACH_FRIENDLY_HOSTILE_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_FRIENDLY_HOSTILE_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231273
	mov	ecx, esi
	mov	DWORD PTR [esi+4392], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5632 : 	m_iAPPROACH_WAR_AFRAID_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_WAR_AFRAID_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231274
	mov	ecx, esi
	mov	DWORD PTR [esi+4396], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5633 : 	m_iAPPROACH_HOSTILE_AFRAID_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_HOSTILE_AFRAID_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231275
	mov	ecx, esi
	mov	DWORD PTR [esi+4400], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5634 : 	m_iAPPROACH_DECEPTIVE_AFRAID_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_DECEPTIVE_AFRAID_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231276
	mov	ecx, esi
	mov	DWORD PTR [esi+4404], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5635 : 	m_iAPPROACH_FRIENDLY_AFRAID_WITH_ANOTHER_PLAYER = getDefineINT("APPROACH_FRIENDLY_AFRAID_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231277
	mov	ecx, esi
	mov	DWORD PTR [esi+4408], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5636 : 	m_iAPPROACH_WAR_PROJECTION_DESTRUCTION_PERCENT = getDefineINT("APPROACH_WAR_PROJECTION_DESTRUCTION_PERCENT");

	push	1
	push	OFFSET $SG231278
	mov	ecx, esi
	mov	DWORD PTR [esi+4412], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5637 : 	m_iAPPROACH_WAR_PROJECTION_DEFEAT_PERCENT = getDefineINT("APPROACH_WAR_PROJECTION_DEFEAT_PERCENT");

	push	1
	push	OFFSET $SG231279
	mov	ecx, esi
	mov	DWORD PTR [esi+4416], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+4420], eax

; 5638 : 	m_iAPPROACH_WAR_PROJECTION_STALEMATE_PERCENT = getDefineINT("APPROACH_WAR_PROJECTION_STALEMATE_PERCENT");

	push	1
	push	OFFSET $SG231280
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5639 : 	m_iAPPROACH_WAR_PROJECTION_UNKNOWN_PERCENT = getDefineINT("APPROACH_WAR_PROJECTION_UNKNOWN_PERCENT");

	push	1
	push	OFFSET $SG231281
	mov	ecx, esi
	mov	DWORD PTR [esi+4424], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5640 : 	m_iAPPROACH_WAR_PROJECTION_GOOD_PERCENT = getDefineINT("APPROACH_WAR_PROJECTION_GOOD_PERCENT");

	push	1
	push	OFFSET $SG231282
	mov	ecx, esi
	mov	DWORD PTR [esi+4428], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5641 : 	m_iAPPROACH_WAR_PROJECTION_VERY_GOOD_PERCENT = getDefineINT("APPROACH_WAR_PROJECTION_VERY_GOOD_PERCENT");

	push	1
	push	OFFSET $SG231283
	mov	ecx, esi
	mov	DWORD PTR [esi+4432], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5642 : 	m_iAPPROACH_GUARDED_PROJECTION_DESTRUCTION_PERCENT = getDefineINT("APPROACH_GUARDED_PROJECTION_DESTRUCTION_PERCENT");

	push	1
	push	OFFSET $SG231284
	mov	ecx, esi
	mov	DWORD PTR [esi+4436], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5643 : 	m_iAPPROACH_GUARDED_PROJECTION_DEFEAT_PERCENT = getDefineINT("APPROACH_GUARDED_PROJECTION_DEFEAT_PERCENT");

	push	1
	push	OFFSET $SG231285
	mov	ecx, esi
	mov	DWORD PTR [esi+4440], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5644 : 	m_iAPPROACH_GUARDED_PROJECTION_STALEMATE_PERCENT = getDefineINT("APPROACH_GUARDED_PROJECTION_STALEMATE_PERCENT");

	push	1
	push	OFFSET $SG231286
	mov	ecx, esi
	mov	DWORD PTR [esi+4444], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5645 : 	m_iAPPROACH_GUARDED_PROJECTION_UNKNOWN_PERCENT = getDefineINT("APPROACH_GUARDED_PROJECTION_UNKNOWN_PERCENT");

	push	1
	push	OFFSET $SG231287
	mov	ecx, esi
	mov	DWORD PTR [esi+4448], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5646 : 	m_iAPPROACH_GUARDED_PROJECTION_GOOD_PERCENT = getDefineINT("APPROACH_GUARDED_PROJECTION_GOOD_PERCENT");

	push	1
	push	OFFSET $SG231288
	mov	ecx, esi
	mov	DWORD PTR [esi+4452], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5647 : 	m_iAPPROACH_GUARDED_PROJECTION_VERY_GOOD_PERCENT = getDefineINT("APPROACH_GUARDED_PROJECTION_VERY_GOOD_PERCENT");

	push	1
	push	OFFSET $SG231289
	mov	ecx, esi
	mov	DWORD PTR [esi+4456], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5648 : 	m_iTURNS_SINCE_PEACE_WEIGHT_DAMPENER = getDefineINT("TURNS_SINCE_PEACE_WEIGHT_DAMPENER");

	push	1
	push	OFFSET $SG231290
	mov	ecx, esi
	mov	DWORD PTR [esi+4460], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5649 : 	m_iAPPROACH_WAR_HAS_MADE_PEACE_BEFORE_PERCENT = getDefineINT("APPROACH_WAR_HAS_MADE_PEACE_BEFORE_PERCENT");

	push	1
	push	OFFSET $SG231291
	mov	ecx, esi
	mov	DWORD PTR [esi+4464], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5650 : 	m_iAPPROACH_WAR_RECKLESS_EXPANDER = getDefineINT("APPROACH_WAR_RECKLESS_EXPANDER");

	push	1
	push	OFFSET $SG231292
	mov	ecx, esi
	mov	DWORD PTR [esi+4468], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5651 : 	m_iAPPROACH_WAR_PROXIMITY_NEIGHBORS = getDefineINT("APPROACH_WAR_PROXIMITY_NEIGHBORS");

	push	1
	push	OFFSET $SG231293
	mov	ecx, esi
	mov	DWORD PTR [esi+4472], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5652 : 	m_iAPPROACH_WAR_PROXIMITY_CLOSE = getDefineINT("APPROACH_WAR_PROXIMITY_CLOSE");

	push	1
	push	OFFSET $SG231294
	mov	ecx, esi
	mov	DWORD PTR [esi+4476], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5653 : 	m_iAPPROACH_WAR_PROXIMITY_FAR = getDefineINT("APPROACH_WAR_PROXIMITY_FAR");

	push	1
	push	OFFSET $SG231295
	mov	ecx, esi
	mov	DWORD PTR [esi+4480], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+4484], eax

; 5654 : 	m_iAPPROACH_WAR_PROXIMITY_DISTANT = getDefineINT("APPROACH_WAR_PROXIMITY_DISTANT");

	push	1
	push	OFFSET $SG231296
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5655 : 	m_iMINOR_APPROACH_IGNORE_DEFAULT = getDefineINT("MINOR_APPROACH_IGNORE_DEFAULT");

	push	1
	push	OFFSET $SG231297
	mov	ecx, esi
	mov	DWORD PTR [esi+4488], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5656 : 	m_iMINOR_APPROACH_BIAS_FOR_CURRENT = getDefineINT("MINOR_APPROACH_BIAS_FOR_CURRENT");

	push	1
	push	OFFSET $SG231298
	mov	ecx, esi
	mov	DWORD PTR [esi+4492], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5657 : 	m_iMINOR_APPROACH_IGNORE_CURRENTLY_WAR = getDefineINT("MINOR_APPROACH_IGNORE_CURRENTLY_WAR");

	push	1
	push	OFFSET $SG231299
	mov	ecx, esi
	mov	DWORD PTR [esi+4496], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5658 : 	m_iMINOR_APPROACH_WAR_CONQUEST_GRAND_STRATEGY = getDefineINT("MINOR_APPROACH_WAR_CONQUEST_GRAND_STRATEGY");

	push	1
	push	OFFSET $SG231300
	mov	ecx, esi
	mov	DWORD PTR [esi+4500], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5659 : 	m_iMINOR_APPROACH_PROTECTIVE_CONQUEST_GRAND_STRATEGY = getDefineINT("MINOR_APPROACH_PROTECTIVE_CONQUEST_GRAND_STRATEGY");

	push	1
	push	OFFSET $SG231301
	mov	ecx, esi
	mov	DWORD PTR [esi+4504], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5660 : 	m_iMINOR_APPROACH_FRIENDLY_CONQUEST_GRAND_STRATEGY = getDefineINT("MINOR_APPROACH_FRIENDLY_CONQUEST_GRAND_STRATEGY");

	push	1
	push	OFFSET $SG231302
	mov	ecx, esi
	mov	DWORD PTR [esi+4508], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5661 : 	m_iMINOR_APPROACH_WAR_CONQUEST_GRAND_STRATEGY_NEIGHBORS = getDefineINT("MINOR_APPROACH_WAR_CONQUEST_GRAND_STRATEGY_NEIGHBORS");

	push	1
	push	OFFSET $SG231303
	mov	ecx, esi
	mov	DWORD PTR [esi+4512], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5662 : 	m_iMINOR_APPROACH_WAR_DIPLO_GRAND_STRATEGY = getDefineINT("MINOR_APPROACH_WAR_DIPLO_GRAND_STRATEGY");

	push	1
	push	OFFSET $SG231304
	mov	ecx, esi
	mov	DWORD PTR [esi+4516], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5663 : 	m_iMINOR_APPROACH_IGNORE_DIPLO_GRAND_STRATEGY = getDefineINT("MINOR_APPROACH_IGNORE_DIPLO_GRAND_STRATEGY");

	push	1
	push	OFFSET $SG231305
	mov	ecx, esi
	mov	DWORD PTR [esi+4520], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5664 : 	m_iMINOR_APPROACH_PROTECTIVE_DIPLO_GRAND_STRATEGY_NEIGHBORS = getDefineINT("MINOR_APPROACH_PROTECTIVE_DIPLO_GRAND_STRATEGY_NEIGHBORS");

	push	1
	push	OFFSET $SG231306
	mov	ecx, esi
	mov	DWORD PTR [esi+4524], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5665 : 	m_iMINOR_APPROACH_WAR_CULTURE_GRAND_STRATEGY = getDefineINT("MINOR_APPROACH_WAR_CULTURE_GRAND_STRATEGY");

	push	1
	push	OFFSET $SG231307
	mov	ecx, esi
	mov	DWORD PTR [esi+4528], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5666 : 	m_iMINOR_APPROACH_IGNORE_CULTURE_GRAND_STRATEGY = getDefineINT("MINOR_APPROACH_IGNORE_CULTURE_GRAND_STRATEGY");

	push	1
	push	OFFSET $SG231308
	mov	ecx, esi
	mov	DWORD PTR [esi+4532], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5667 : 	m_iMINOR_APPROACH_PROTECTIVE_CULTURE_GRAND_STRATEGY_CST = getDefineINT("MINOR_APPROACH_PROTECTIVE_CULTURE_GRAND_STRATEGY_CST");

	push	1
	push	OFFSET $SG231309
	mov	ecx, esi
	mov	DWORD PTR [esi+4536], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5668 : 	m_iMINOR_APPROACH_WAR_CURRENTLY_PROTECTIVE = getDefineINT("MINOR_APPROACH_WAR_CURRENTLY_PROTECTIVE");

	push	1
	push	OFFSET $SG231310
	mov	ecx, esi
	mov	DWORD PTR [esi+4540], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5669 : 	m_iMINOR_APPROACH_PROTECTIVE_CURRENTLY_PROTECTIVE = getDefineINT("MINOR_APPROACH_PROTECTIVE_CURRENTLY_PROTECTIVE");

	push	1
	push	OFFSET $SG231311
	mov	ecx, esi
	mov	DWORD PTR [esi+4544], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5670 : 	m_iMINOR_APPROACH_PROTECTIVE_CURRENTLY_WAR = getDefineINT("MINOR_APPROACH_PROTECTIVE_CURRENTLY_WAR");

	push	1
	mov	DWORD PTR [esi+4548], eax
	push	OFFSET $SG231312
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5671 : 	m_iMINOR_APPROACH_FRIENDLY_CURRENTLY_WAR = getDefineINT("MINOR_APPROACH_FRIENDLY_CURRENTLY_WAR");

	push	1
	push	OFFSET $SG231313
	mov	ecx, esi
	mov	DWORD PTR [esi+4552], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5672 : 	m_iMINOR_APPROACH_FRIENDLY_RESOURCES = getDefineINT("MINOR_APPROACH_FRIENDLY_RESOURCES");

	push	1
	push	OFFSET $SG231314
	mov	ecx, esi
	mov	DWORD PTR [esi+4556], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5673 : 	m_iMINOR_APPROACH_PROTECTIVE_RESOURCES = getDefineINT("MINOR_APPROACH_PROTECTIVE_RESOURCES");

	push	1
	push	OFFSET $SG231315
	mov	ecx, esi
	mov	DWORD PTR [esi+4560], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5674 : 	m_iMINOR_APPROACH_WAR_FRIENDS = getDefineINT("MINOR_APPROACH_WAR_FRIENDS");

	push	1
	push	OFFSET $SG231316
	mov	ecx, esi
	mov	DWORD PTR [esi+4564], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5675 : 	m_iMINOR_APPROACH_FRIENDLY_FRIENDS = getDefineINT("MINOR_APPROACH_FRIENDLY_FRIENDS");

	push	1
	push	OFFSET $SG231317
	mov	ecx, esi
	mov	DWORD PTR [esi+4568], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5676 : 	m_iMINOR_APPROACH_PROTECTIVE_FRIENDS = getDefineINT("MINOR_APPROACH_PROTECTIVE_FRIENDS");

	push	1
	push	OFFSET $SG231318
	mov	ecx, esi
	mov	DWORD PTR [esi+4572], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5677 : 	m_iMINOR_APPROACH_IGNORE_PROXIMITY_NEIGHBORS = getDefineINT("MINOR_APPROACH_IGNORE_PROXIMITY_NEIGHBORS");

	push	1
	push	OFFSET $SG231319
	mov	ecx, esi
	mov	DWORD PTR [esi+4576], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5678 : 	m_iMINOR_APPROACH_FRIENDLY_PROXIMITY_NEIGHBORS = getDefineINT("MINOR_APPROACH_FRIENDLY_PROXIMITY_NEIGHBORS");

	push	1
	push	OFFSET $SG231320
	mov	ecx, esi
	mov	DWORD PTR [esi+4580], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5679 : 	m_iMINOR_APPROACH_PROTECTIVE_PROXIMITY_NEIGHBORS = getDefineINT("MINOR_APPROACH_PROTECTIVE_PROXIMITY_NEIGHBORS");

	push	1
	push	OFFSET $SG231321
	mov	ecx, esi
	mov	DWORD PTR [esi+4584], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5680 : 	m_iMINOR_APPROACH_CONQUEST_PROXIMITY_NEIGHBORS = getDefineINT("MINOR_APPROACH_CONQUEST_PROXIMITY_NEIGHBORS");

	push	1
	push	OFFSET $SG231322
	mov	ecx, esi
	mov	DWORD PTR [esi+4588], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5681 : 	m_iMINOR_APPROACH_IGNORE_PROXIMITY_CLOSE = getDefineINT("MINOR_APPROACH_IGNORE_PROXIMITY_CLOSE");

	push	1
	push	OFFSET $SG231323
	mov	ecx, esi
	mov	DWORD PTR [esi+4592], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5682 : 	m_iMINOR_APPROACH_PROTECTIVE_PROXIMITY_CLOSE = getDefineINT("MINOR_APPROACH_PROTECTIVE_PROXIMITY_CLOSE");

	push	1
	push	OFFSET $SG231324
	mov	ecx, esi
	mov	DWORD PTR [esi+4596], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5683 : 	m_iMINOR_APPROACH_CONQUEST_PROXIMITY_CLOSE = getDefineINT("MINOR_APPROACH_CONQUEST_PROXIMITY_CLOSE");

	push	1
	push	OFFSET $SG231325
	mov	ecx, esi
	mov	DWORD PTR [esi+4600], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5684 : 	m_iMINOR_APPROACH_FRIENDLY_PROXIMITY_FAR = getDefineINT("MINOR_APPROACH_FRIENDLY_PROXIMITY_FAR");

	push	1
	push	OFFSET $SG231326
	mov	ecx, esi
	mov	DWORD PTR [esi+4604], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5685 : 	m_iMINOR_APPROACH_CONQUEST_PROXIMITY_FAR = getDefineINT("MINOR_APPROACH_CONQUEST_PROXIMITY_FAR");

	push	1
	push	OFFSET $SG231327
	mov	ecx, esi
	mov	DWORD PTR [esi+4608], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5686 : 	m_iMINOR_APPROACH_FRIENDLY_PROXIMITY_DISTANT = getDefineINT("MINOR_APPROACH_FRIENDLY_PROXIMITY_DISTANT");

	push	1
	mov	DWORD PTR [esi+4612], eax
	push	OFFSET $SG231328
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5687 : 	m_iMINOR_APPROACH_CONQUEST_PROXIMITY_DISTANT = getDefineINT("MINOR_APPROACH_CONQUEST_PROXIMITY_DISTANT");

	push	1
	push	OFFSET $SG231329
	mov	ecx, esi
	mov	DWORD PTR [esi+4616], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5688 : 	m_iMINOR_APPROACH_FRIENDLY_PERSONALITY_FRIENDLY = getDefineINT("MINOR_APPROACH_FRIENDLY_PERSONALITY_FRIENDLY");

	push	1
	push	OFFSET $SG231330
	mov	ecx, esi
	mov	DWORD PTR [esi+4620], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5689 : 	m_iMINOR_APPROACH_PROTECTIVE_PERSONALITY_PROTECTIVE = getDefineINT("MINOR_APPROACH_PROTECTIVE_PERSONALITY_PROTECTIVE");

	push	1
	push	OFFSET $SG231331
	mov	ecx, esi
	mov	DWORD PTR [esi+4624], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5690 : 	m_iMINOR_APPROACH_FRIENDLY_PERSONALITY_NEUTRAL = getDefineINT("MINOR_APPROACH_FRIENDLY_PERSONALITY_NEUTRAL");

	push	1
	push	OFFSET $SG231332
	mov	ecx, esi
	mov	DWORD PTR [esi+4628], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5691 : 	m_iMINOR_APPROACH_PROTECTIVE_PERSONALITY_NEUTRAL = getDefineINT("MINOR_APPROACH_PROTECTIVE_PERSONALITY_NEUTRAL");

	push	1
	push	OFFSET $SG231333
	mov	ecx, esi
	mov	DWORD PTR [esi+4632], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5692 : 	m_iMINOR_APPROACH_FRIENDLY_PERSONALITY_HOSTILE = getDefineINT("MINOR_APPROACH_FRIENDLY_PERSONALITY_HOSTILE");

	push	1
	push	OFFSET $SG231334
	mov	ecx, esi
	mov	DWORD PTR [esi+4636], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5693 : 	m_iMINOR_APPROACH_PROTECTIVE_PERSONALITY_HOSTILE = getDefineINT("MINOR_APPROACH_PROTECTIVE_PERSONALITY_HOSTILE");

	push	1
	push	OFFSET $SG231335
	mov	ecx, esi
	mov	DWORD PTR [esi+4640], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5694 : 	m_iMINOR_APPROACH_CONQUEST_PERSONALITY_HOSTILE = getDefineINT("MINOR_APPROACH_CONQUEST_PERSONALITY_HOSTILE");

	push	1
	push	OFFSET $SG231336
	mov	ecx, esi
	mov	DWORD PTR [esi+4644], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5695 : 	m_iMINOR_APPROACH_FRIENDLY_PERSONALITY_IRRATIONAL = getDefineINT("MINOR_APPROACH_FRIENDLY_PERSONALITY_IRRATIONAL");

	push	1
	push	OFFSET $SG231337
	mov	ecx, esi
	mov	DWORD PTR [esi+4648], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5696 : 	m_iMINOR_APPROACH_PROTECTIVE_PERSONALITY_IRRATIONAL = getDefineINT("MINOR_APPROACH_PROTECTIVE_PERSONALITY_IRRATIONAL");

	push	1
	push	OFFSET $SG231338
	mov	ecx, esi
	mov	DWORD PTR [esi+4652], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5697 : 	m_iMINOR_APPROACH_WAR_PLANNING_WAR_WITH_ANOTHER_PLAYER = getDefineINT("MINOR_APPROACH_WAR_PLANNING_WAR_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231339
	mov	ecx, esi
	mov	DWORD PTR [esi+4656], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5698 : 	m_iMINOR_APPROACH_PROTECTIVE_WITH_ANOTHER_PLAYER = getDefineINT("MINOR_APPROACH_PROTECTIVE_WITH_ANOTHER_PLAYER");

	push	1
	push	OFFSET $SG231340
	mov	ecx, esi
	mov	DWORD PTR [esi+4660], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5699 : 	m_iMINOR_APPROACH_WAR_TARGET_IMPOSSIBLE = getDefineINT("MINOR_APPROACH_WAR_TARGET_IMPOSSIBLE");

	push	1
	push	OFFSET $SG231341
	mov	ecx, esi
	mov	DWORD PTR [esi+4664], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5700 : 	m_iMINOR_APPROACH_WAR_TARGET_BAD = getDefineINT("MINOR_APPROACH_WAR_TARGET_BAD");

	push	1
	push	OFFSET $SG231342
	mov	ecx, esi
	mov	DWORD PTR [esi+4668], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5701 : 	m_iMINOR_APPROACH_WAR_TARGET_AVERAGE = getDefineINT("MINOR_APPROACH_WAR_TARGET_AVERAGE");

	push	1
	push	OFFSET $SG231343
	mov	ecx, esi
	mov	DWORD PTR [esi+4672], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5702 : 	m_iMINOR_APPROACH_WAR_TARGET_FAVORABLE = getDefineINT("MINOR_APPROACH_WAR_TARGET_FAVORABLE");

	push	1
	push	OFFSET $SG231344
	mov	ecx, esi
	mov	DWORD PTR [esi+4676], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5703 : 	m_iMINOR_APPROACH_WAR_TARGET_SOFT = getDefineINT("MINOR_APPROACH_WAR_TARGET_SOFT");

	push	1
	push	OFFSET $SG231345
	mov	ecx, esi
	mov	DWORD PTR [esi+4680], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5704 : 	m_iCOOPERATION_DESIRE_THRESHOLD_EAGER = getDefineINT("COOPERATION_DESIRE_THRESHOLD_EAGER");

	push	1
	push	OFFSET $SG231346
	mov	ecx, esi
	mov	DWORD PTR [esi+4684], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5705 : 	m_iCOOPERATION_DESIRE_THRESHOLD_STRONG = getDefineINT("COOPERATION_DESIRE_THRESHOLD_STRONG");

	push	1
	push	OFFSET $SG231347
	mov	ecx, esi
	mov	DWORD PTR [esi+4688], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5706 : 	m_iCOOPERATION_DESIRE_THRESHOLD_DECENT = getDefineINT("COOPERATION_DESIRE_THRESHOLD_DECENT");

	push	1
	push	OFFSET $SG231348
	mov	ecx, esi
	mov	DWORD PTR [esi+4692], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5707 : 	m_iCOOPERATION_DESIRE_THRESHOLD_WEAK = getDefineINT("COOPERATION_DESIRE_THRESHOLD_WEAK");

	push	1
	push	OFFSET $SG231349
	mov	ecx, esi
	mov	DWORD PTR [esi+4696], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5708 : 	m_iCOOPERATION_DESIRE_WAR_STATE_CALM = getDefineINT("COOPERATION_DESIRE_WAR_STATE_CALM");

	push	1
	push	OFFSET $SG231350
	mov	ecx, esi
	mov	DWORD PTR [esi+4700], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5709 : 	m_iCOOPERATION_DESIRE_WAR_STATE_NEARLY_WON = getDefineINT("COOPERATION_DESIRE_WAR_STATE_NEARLY_WON");

	push	1
	push	OFFSET $SG231351
	mov	ecx, esi
	mov	DWORD PTR [esi+4704], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5710 : 	m_iCOOPERATION_DESIRE_WAR_STATE_OFFENSIVE = getDefineINT("COOPERATION_DESIRE_WAR_STATE_OFFENSIVE");

	push	1
	push	OFFSET $SG231352
	mov	ecx, esi
	mov	DWORD PTR [esi+4708], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5711 : 	m_iCOOPERATION_DESIRE_WAR_STATE_STALEMATE = getDefineINT("COOPERATION_DESIRE_WAR_STATE_STALEMATE");

	push	1
	push	OFFSET $SG231353
	mov	ecx, esi
	mov	DWORD PTR [esi+4712], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5712 : 	m_iCOOPERATION_DESIRE_WAR_STATE_DEFENSIVE = getDefineINT("COOPERATION_DESIRE_WAR_STATE_DEFENSIVE");

	push	1
	push	OFFSET $SG231354
	mov	ecx, esi
	mov	DWORD PTR [esi+4716], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5713 : 	m_iCOOPERATION_DESIRE_WAR_STATE_NEARLY_DEFEATED = getDefineINT("COOPERATION_DESIRE_WAR_STATE_NEARLY_DEFEATED");

	push	1
	push	OFFSET $SG231355
	mov	ecx, esi
	mov	DWORD PTR [esi+4720], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5714 : 	m_iCOOPERATION_DESIRE_MILITARY_STRENGTH_IMMENSE = getDefineINT("COOPERATION_DESIRE_MILITARY_STRENGTH_IMMENSE");

	push	1
	push	OFFSET $SG231356
	mov	ecx, esi
	mov	DWORD PTR [esi+4724], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5715 : 	m_iCOOPERATION_DESIRE_MILITARY_STRENGTH_POWERFUL = getDefineINT("COOPERATION_DESIRE_MILITARY_STRENGTH_POWERFUL");

	push	1
	push	OFFSET $SG231357
	mov	ecx, esi
	mov	DWORD PTR [esi+4728], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5716 : 	m_iCOOPERATION_DESIRE_MILITARY_STRENGTH_STRONG = getDefineINT("COOPERATION_DESIRE_MILITARY_STRENGTH_STRONG");

	push	1
	push	OFFSET $SG231358
	mov	ecx, esi
	mov	DWORD PTR [esi+4732], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5717 : 	m_iCOOPERATION_DESIRE_MILITARY_STRENGTH_AVERAGE = getDefineINT("COOPERATION_DESIRE_MILITARY_STRENGTH_AVERAGE");

	push	1
	push	OFFSET $SG231359
	mov	ecx, esi
	mov	DWORD PTR [esi+4736], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5718 : 	m_iCOOPERATION_DESIRE_MILITARY_STRENGTH_POOR = getDefineINT("COOPERATION_DESIRE_MILITARY_STRENGTH_POOR");

	push	1
	push	OFFSET $SG231360
	mov	ecx, esi
	mov	DWORD PTR [esi+4740], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+4744], eax

; 5719 : 	m_iCOOPERATION_DESIRE_MILITARY_STRENGTH_WEAK = getDefineINT("COOPERATION_DESIRE_MILITARY_STRENGTH_WEAK");

	push	1
	push	OFFSET $SG231361
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5720 : 	m_iCOOPERATION_DESIRE_MILITARY_STRENGTH_PATHETIC = getDefineINT("COOPERATION_DESIRE_MILITARY_STRENGTH_PATHETIC");

	push	1
	push	OFFSET $SG231362
	mov	ecx, esi
	mov	DWORD PTR [esi+4748], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5721 : 	m_iCOOPERATION_DESIRE_OPINION_ALLY = getDefineINT("COOPERATION_DESIRE_OPINION_ALLY");

	push	1
	push	OFFSET $SG231363
	mov	ecx, esi
	mov	DWORD PTR [esi+4752], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5722 : 	m_iCOOPERATION_DESIRE_OPINION_FRIEND = getDefineINT("COOPERATION_DESIRE_OPINION_FRIEND");

	push	1
	push	OFFSET $SG231364
	mov	ecx, esi
	mov	DWORD PTR [esi+4756], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5723 : 	m_iCOOPERATION_DESIRE_OPINION_NEUTRAL = getDefineINT("COOPERATION_DESIRE_OPINION_NEUTRAL");

	push	1
	push	OFFSET $SG231365
	mov	ecx, esi
	mov	DWORD PTR [esi+4760], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5724 : 	m_iCOOPERATION_DESIRE_OPINION_COMPETITOR = getDefineINT("COOPERATION_DESIRE_OPINION_COMPETITOR");

	push	1
	push	OFFSET $SG231366
	mov	ecx, esi
	mov	DWORD PTR [esi+4764], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5725 : 	m_iCOOPERATION_DESIRE_OPINION_ENEMY = getDefineINT("COOPERATION_DESIRE_OPINION_ENEMY");

	push	1
	push	OFFSET $SG231367
	mov	ecx, esi
	mov	DWORD PTR [esi+4768], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5726 : 	m_iCOOPERATION_DESIRE_GAME_THREAT_CRITICAL = getDefineINT("COOPERATION_DESIRE_GAME_THREAT_CRITICAL");

	push	1
	push	OFFSET $SG231368
	mov	ecx, esi
	mov	DWORD PTR [esi+4772], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5727 : 	m_iCOOPERATION_DESIRE_GAME_THREAT_SEVERE = getDefineINT("COOPERATION_DESIRE_GAME_THREAT_SEVERE");

	push	1
	push	OFFSET $SG231369
	mov	ecx, esi
	mov	DWORD PTR [esi+4776], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5728 : 	m_iCOOPERATION_DESIRE_GAME_THREAT_MAJOR = getDefineINT("COOPERATION_DESIRE_GAME_THREAT_MAJOR");

	push	1
	push	OFFSET $SG231370
	mov	ecx, esi
	mov	DWORD PTR [esi+4780], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5729 : 	m_iCOOPERATION_DESIRE_GAME_THREAT_MINOR = getDefineINT("COOPERATION_DESIRE_GAME_THREAT_MINOR");

	push	1
	push	OFFSET $SG231371
	mov	ecx, esi
	mov	DWORD PTR [esi+4784], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5730 : 	m_iCOOPERATION_DESIRE_GAME_THREAT_NONE = getDefineINT("COOPERATION_DESIRE_GAME_THREAT_NONE");

	push	1
	push	OFFSET $SG231372
	mov	ecx, esi
	mov	DWORD PTR [esi+4788], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5731 : 	m_iCOOPERATION_DESIRE_THEM_US_SAME_COMPETITOR = getDefineINT("COOPERATION_DESIRE_THEM_US_SAME_COMPETITOR");

	push	1
	push	OFFSET $SG231373
	mov	ecx, esi
	mov	DWORD PTR [esi+4792], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5732 : 	m_iCOOPERATION_DESIRE_THEM_US_COMPETITOR_ENEMY = getDefineINT("COOPERATION_DESIRE_THEM_US_COMPETITOR_ENEMY");

	push	1
	push	OFFSET $SG231374
	mov	ecx, esi
	mov	DWORD PTR [esi+4796], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5733 : 	m_iCOOPERATION_DESIRE_THEM_US_ENEMY_COMPETITOR = getDefineINT("COOPERATION_DESIRE_THEM_US_ENEMY_COMPETITOR");

	push	1
	push	OFFSET $SG231375
	mov	ecx, esi
	mov	DWORD PTR [esi+4800], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5734 : 	m_iCOOPERATION_DESIRE_THEM_US_SAME_ENEMY = getDefineINT("COOPERATION_DESIRE_THEM_US_SAME_ENEMY");

	push	1
	push	OFFSET $SG231376
	mov	ecx, esi
	mov	DWORD PTR [esi+4804], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+4808], eax

; 5735 : 	m_iEVALUATE_WAR_PLAYER_THRESHOLD = getDefineINT("EVALUATE_WAR_PLAYER_THRESHOLD");

	push	1
	push	OFFSET $SG231377
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5736 : 	m_iEVALUATE_WAR_WILLING_TO_DECLARE_THRESHOLD = getDefineINT("EVALUATE_WAR_WILLING_TO_DECLARE_THRESHOLD");

	push	1
	push	OFFSET $SG231378
	mov	ecx, esi
	mov	DWORD PTR [esi+4812], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5737 : 	m_iEVALUATE_WAR_CONQUEST_GRAND_STRATEGY = getDefineINT("EVALUATE_WAR_CONQUEST_GRAND_STRATEGY");

	push	1
	push	OFFSET $SG231379
	mov	ecx, esi
	mov	DWORD PTR [esi+4816], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5738 : 	m_iEVALUATE_WAR_NOT_PREPARED = getDefineINT("EVALUATE_WAR_NOT_PREPARED");

	push	1
	push	OFFSET $SG231380
	mov	ecx, esi
	mov	DWORD PTR [esi+4820], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5739 : 	m_iEVALUATE_WAR_ALREADY_FIGHTING = getDefineINT("EVALUATE_WAR_ALREADY_FIGHTING");

	push	1
	push	OFFSET $SG231381
	mov	ecx, esi
	mov	DWORD PTR [esi+4824], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5740 : 	m_iEVALUATE_WAR_GAME_THREAT_CRITICAL = getDefineINT("EVALUATE_WAR_GAME_THREAT_CRITICAL");

	push	1
	push	OFFSET $SG231382
	mov	ecx, esi
	mov	DWORD PTR [esi+4828], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5741 : 	m_iEVALUATE_WAR_GAME_THREAT_SEVERE = getDefineINT("EVALUATE_WAR_GAME_THREAT_SEVERE");

	push	1
	push	OFFSET $SG231383
	mov	ecx, esi
	mov	DWORD PTR [esi+4832], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5742 : 	m_iEVALUATE_WAR_GAME_THREAT_MAJOR = getDefineINT("EVALUATE_WAR_GAME_THREAT_MAJOR");

	push	1
	push	OFFSET $SG231384
	mov	ecx, esi
	mov	DWORD PTR [esi+4836], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5743 : 	m_iEVALUATE_WAR_GAME_THREAT_MINOR = getDefineINT("EVALUATE_WAR_GAME_THREAT_MINOR");

	push	1
	push	OFFSET $SG231385
	mov	ecx, esi
	mov	DWORD PTR [esi+4840], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5744 : 	m_iEVALUATE_WAR_GAME_THREAT_NONE = getDefineINT("EVALUATE_WAR_GAME_THREAT_NONE");

	push	1
	push	OFFSET $SG231386
	mov	ecx, esi
	mov	DWORD PTR [esi+4844], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5745 : 	m_iEVALUATE_WAR_SOFT_TARGET = getDefineINT("EVALUATE_WAR_SOFT_TARGET");

	push	1
	push	OFFSET $SG231387
	mov	ecx, esi
	mov	DWORD PTR [esi+4848], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5746 : 	m_iEVALUATE_WAR_FAVORABLE_TARGET = getDefineINT("EVALUATE_WAR_FAVORABLE_TARGET");

	push	1
	push	OFFSET $SG231388
	mov	ecx, esi
	mov	DWORD PTR [esi+4852], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5747 : 	m_iEVALUATE_WAR_AVERAGE_TARGET = getDefineINT("EVALUATE_WAR_AVERAGE_TARGET");

	push	1
	push	OFFSET $SG231389
	mov	ecx, esi
	mov	DWORD PTR [esi+4856], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5748 : 	m_iEVALUATE_WAR_BAD_TARGET = getDefineINT("EVALUATE_WAR_BAD_TARGET");

	push	1
	push	OFFSET $SG231390
	mov	ecx, esi
	mov	DWORD PTR [esi+4860], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5749 : 	m_iEVALUATE_WAR_IMPOSSIBLE_TARGET = getDefineINT("EVALUATE_WAR_IMPOSSIBLE_TARGET");

	push	1
	push	OFFSET $SG231391
	mov	ecx, esi
	mov	DWORD PTR [esi+4864], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5750 : 	m_iREQUEST_PEACE_TURN_THRESHOLD = getDefineINT("REQUEST_PEACE_TURN_THRESHOLD");

	push	1
	push	OFFSET $SG231392
	mov	ecx, esi
	mov	DWORD PTR [esi+4868], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5751 : 	m_iPEACE_WILLINGNESS_OFFER_PROJECTION_DESTRUCTION = getDefineINT("PEACE_WILLINGNESS_OFFER_PROJECTION_DESTRUCTION");

	push	1
	mov	DWORD PTR [esi+4872], eax
	push	OFFSET $SG231393
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5752 : 	m_iPEACE_WILLINGNESS_OFFER_PROJECTION_DEFEAT = getDefineINT("PEACE_WILLINGNESS_OFFER_PROJECTION_DEFEAT");

	push	1
	push	OFFSET $SG231394
	mov	ecx, esi
	mov	DWORD PTR [esi+4876], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5753 : 	m_iPEACE_WILLINGNESS_OFFER_PROJECTION_STALEMATE = getDefineINT("PEACE_WILLINGNESS_OFFER_PROJECTION_STALEMATE");

	push	1
	push	OFFSET $SG231395
	mov	ecx, esi
	mov	DWORD PTR [esi+4880], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5754 : 	m_iPEACE_WILLINGNESS_OFFER_PROJECTION_UNKNOWN = getDefineINT("PEACE_WILLINGNESS_OFFER_PROJECTION_UNKNOWN");

	push	1
	push	OFFSET $SG231396
	mov	ecx, esi
	mov	DWORD PTR [esi+4884], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5755 : 	m_iPEACE_WILLINGNESS_OFFER_PROJECTION_GOOD = getDefineINT("PEACE_WILLINGNESS_OFFER_PROJECTION_GOOD");

	push	1
	push	OFFSET $SG231397
	mov	ecx, esi
	mov	DWORD PTR [esi+4888], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5756 : 	m_iPEACE_WILLINGNESS_OFFER_PROJECTION_VERY_GOOD = getDefineINT("PEACE_WILLINGNESS_OFFER_PROJECTION_VERY_GOOD");

	push	1
	push	OFFSET $SG231398
	mov	ecx, esi
	mov	DWORD PTR [esi+4892], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5757 : 	m_iPEACE_WILLINGNESS_OFFER_WAR_DAMAGE_NONE = getDefineINT("PEACE_WILLINGNESS_OFFER_WAR_DAMAGE_NONE");

	push	1
	push	OFFSET $SG231399
	mov	ecx, esi
	mov	DWORD PTR [esi+4896], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5758 : 	m_iPEACE_WILLINGNESS_OFFER_WAR_DAMAGE_MINOR = getDefineINT("PEACE_WILLINGNESS_OFFER_WAR_DAMAGE_MINOR");

	push	1
	push	OFFSET $SG231400
	mov	ecx, esi
	mov	DWORD PTR [esi+4900], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5759 : 	m_iPEACE_WILLINGNESS_OFFER_WAR_DAMAGE_MAJOR = getDefineINT("PEACE_WILLINGNESS_OFFER_WAR_DAMAGE_MAJOR");

	push	1
	push	OFFSET $SG231401
	mov	ecx, esi
	mov	DWORD PTR [esi+4904], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5760 : 	m_iPEACE_WILLINGNESS_OFFER_WAR_DAMAGE_SERIOUS = getDefineINT("PEACE_WILLINGNESS_OFFER_WAR_DAMAGE_SERIOUS");

	push	1
	push	OFFSET $SG231402
	mov	ecx, esi
	mov	DWORD PTR [esi+4908], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5761 : 	m_iPEACE_WILLINGNESS_OFFER_WAR_DAMAGE_CRIPPLED = getDefineINT("PEACE_WILLINGNESS_OFFER_WAR_DAMAGE_CRIPPLED");

	push	1
	push	OFFSET $SG231403
	mov	ecx, esi
	mov	DWORD PTR [esi+4912], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5762 : 	m_iPEACE_WILLINGNESS_OFFER_THRESHOLD_UN_SURRENDER = getDefineINT("PEACE_WILLINGNESS_OFFER_THRESHOLD_UN_SURRENDER");

	push	1
	push	OFFSET $SG231404
	mov	ecx, esi
	mov	DWORD PTR [esi+4916], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5763 : 	m_iPEACE_WILLINGNESS_OFFER_THRESHOLD_CAPITULATION = getDefineINT("PEACE_WILLINGNESS_OFFER_THRESHOLD_CAPITULATION");

	push	1
	push	OFFSET $SG231405
	mov	ecx, esi
	mov	DWORD PTR [esi+4920], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5764 : 	m_iPEACE_WILLINGNESS_OFFER_THRESHOLD_CESSION = getDefineINT("PEACE_WILLINGNESS_OFFER_THRESHOLD_CESSION");

	push	1
	push	OFFSET $SG231406
	mov	ecx, esi
	mov	DWORD PTR [esi+4924], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5765 : 	m_iPEACE_WILLINGNESS_OFFER_THRESHOLD_SURRENDER = getDefineINT("PEACE_WILLINGNESS_OFFER_THRESHOLD_SURRENDER");

	push	1
	push	OFFSET $SG231407
	mov	ecx, esi
	mov	DWORD PTR [esi+4928], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5766 : 	m_iPEACE_WILLINGNESS_OFFER_THRESHOLD_SUBMISSION = getDefineINT("PEACE_WILLINGNESS_OFFER_THRESHOLD_SUBMISSION");

	push	1
	push	OFFSET $SG231408
	mov	ecx, esi
	mov	DWORD PTR [esi+4932], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5767 : 	m_iPEACE_WILLINGNESS_OFFER_THRESHOLD_BACKDOWN = getDefineINT("PEACE_WILLINGNESS_OFFER_THRESHOLD_BACKDOWN");

	push	1
	mov	DWORD PTR [esi+4936], eax
	push	OFFSET $SG231409
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5768 : 	m_iPEACE_WILLINGNESS_OFFER_THRESHOLD_SETTLEMENT = getDefineINT("PEACE_WILLINGNESS_OFFER_THRESHOLD_SETTLEMENT");

	push	1
	push	OFFSET $SG231410
	mov	ecx, esi
	mov	DWORD PTR [esi+4940], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5769 : 	m_iPEACE_WILLINGNESS_OFFER_THRESHOLD_ARMISTICE = getDefineINT("PEACE_WILLINGNESS_OFFER_THRESHOLD_ARMISTICE");

	push	1
	push	OFFSET $SG231411
	mov	ecx, esi
	mov	DWORD PTR [esi+4944], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5770 : 	m_iPEACE_WILLINGNESS_ACCEPT_PROJECTION_DESTRUCTION = getDefineINT("PEACE_WILLINGNESS_ACCEPT_PROJECTION_DESTRUCTION");

	push	1
	push	OFFSET $SG231412
	mov	ecx, esi
	mov	DWORD PTR [esi+4948], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5771 : 	m_iPEACE_WILLINGNESS_ACCEPT_PROJECTION_DEFEAT = getDefineINT("PEACE_WILLINGNESS_ACCEPT_PROJECTION_DEFEAT");

	push	1
	push	OFFSET $SG231413
	mov	ecx, esi
	mov	DWORD PTR [esi+4952], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5772 : 	m_iPEACE_WILLINGNESS_ACCEPT_PROJECTION_STALEMATE = getDefineINT("PEACE_WILLINGNESS_ACCEPT_PROJECTION_STALEMATE");

	push	1
	push	OFFSET $SG231414
	mov	ecx, esi
	mov	DWORD PTR [esi+4956], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5773 : 	m_iPEACE_WILLINGNESS_ACCEPT_PROJECTION_UNKNOWN = getDefineINT("PEACE_WILLINGNESS_ACCEPT_PROJECTION_UNKNOWN");

	push	1
	push	OFFSET $SG231415
	mov	ecx, esi
	mov	DWORD PTR [esi+4960], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5774 : 	m_iPEACE_WILLINGNESS_ACCEPT_PROJECTION_GOOD = getDefineINT("PEACE_WILLINGNESS_ACCEPT_PROJECTION_GOOD");

	push	1
	push	OFFSET $SG231416
	mov	ecx, esi
	mov	DWORD PTR [esi+4964], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5775 : 	m_iPEACE_WILLINGNESS_ACCEPT_PROJECTION_VERY_GOOD = getDefineINT("PEACE_WILLINGNESS_ACCEPT_PROJECTION_VERY_GOOD");

	push	1
	push	OFFSET $SG231417
	mov	ecx, esi
	mov	DWORD PTR [esi+4968], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5776 : 	m_iPEACE_WILLINGNESS_ACCEPT_TARGET_IMPOSSIBLE = getDefineINT("PEACE_WILLINGNESS_ACCEPT_TARGET_IMPOSSIBLE");

	push	1
	push	OFFSET $SG231418
	mov	ecx, esi
	mov	DWORD PTR [esi+4972], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5777 : 	m_iPEACE_WILLINGNESS_ACCEPT_TARGET_BAD = getDefineINT("PEACE_WILLINGNESS_ACCEPT_TARGET_BAD");

	push	1
	push	OFFSET $SG231419
	mov	ecx, esi
	mov	DWORD PTR [esi+4976], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5778 : 	m_iPEACE_WILLINGNESS_ACCEPT_TARGET_AVERAGE = getDefineINT("PEACE_WILLINGNESS_ACCEPT_TARGET_AVERAGE");

	push	1
	push	OFFSET $SG231420
	mov	ecx, esi
	mov	DWORD PTR [esi+4980], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5779 : 	m_iPEACE_WILLINGNESS_ACCEPT_TARGET_FAVORABLE = getDefineINT("PEACE_WILLINGNESS_ACCEPT_TARGET_FAVORABLE");

	push	1
	push	OFFSET $SG231421
	mov	ecx, esi
	mov	DWORD PTR [esi+4984], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5780 : 	m_iPEACE_WILLINGNESS_ACCEPT_TARGET_SOFT = getDefineINT("PEACE_WILLINGNESS_ACCEPT_TARGET_SOFT");

	push	1
	push	OFFSET $SG231422
	mov	ecx, esi
	mov	DWORD PTR [esi+4988], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5781 : 	m_iPEACE_WILLINGNESS_ACCEPT_THRESHOLD_UN_SURRENDER = getDefineINT("PEACE_WILLINGNESS_ACCEPT_THRESHOLD_UN_SURRENDER");

	push	1
	push	OFFSET $SG231423
	mov	ecx, esi
	mov	DWORD PTR [esi+4992], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5782 : 	m_iPEACE_WILLINGNESS_ACCEPT_THRESHOLD_CAPITULATION = getDefineINT("PEACE_WILLINGNESS_ACCEPT_THRESHOLD_CAPITULATION");

	push	1
	push	OFFSET $SG231424
	mov	ecx, esi
	mov	DWORD PTR [esi+4996], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5783 : 	m_iPEACE_WILLINGNESS_ACCEPT_THRESHOLD_CESSION = getDefineINT("PEACE_WILLINGNESS_ACCEPT_THRESHOLD_CESSION");

	push	1
	push	OFFSET $SG231425
	mov	ecx, esi
	mov	DWORD PTR [esi+5000], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5784 : 	m_iPEACE_WILLINGNESS_ACCEPT_THRESHOLD_SURRENDER = getDefineINT("PEACE_WILLINGNESS_ACCEPT_THRESHOLD_SURRENDER");

	push	1
	push	OFFSET $SG231426
	mov	ecx, esi
	mov	DWORD PTR [esi+5004], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5785 : 	m_iPEACE_WILLINGNESS_ACCEPT_THRESHOLD_SUBMISSION = getDefineINT("PEACE_WILLINGNESS_ACCEPT_THRESHOLD_SUBMISSION");

	push	1
	push	OFFSET $SG231427
	mov	ecx, esi
	mov	DWORD PTR [esi+5008], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5786 : 	m_iPEACE_WILLINGNESS_ACCEPT_THRESHOLD_BACKDOWN = getDefineINT("PEACE_WILLINGNESS_ACCEPT_THRESHOLD_BACKDOWN");

	push	1
	push	OFFSET $SG231428
	mov	ecx, esi
	mov	DWORD PTR [esi+5012], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5787 : 	m_iPEACE_WILLINGNESS_ACCEPT_THRESHOLD_SETTLEMENT = getDefineINT("PEACE_WILLINGNESS_ACCEPT_THRESHOLD_SETTLEMENT");

	push	1
	push	OFFSET $SG231429
	mov	ecx, esi
	mov	DWORD PTR [esi+5016], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5788 : 	m_iPEACE_WILLINGNESS_ACCEPT_THRESHOLD_ARMISTICE = getDefineINT("PEACE_WILLINGNESS_ACCEPT_THRESHOLD_ARMISTICE");

	push	1
	push	OFFSET $SG231430
	mov	ecx, esi
	mov	DWORD PTR [esi+5020], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5789 : 	m_iARMISTICE_GPT_DIVISOR = getDefineINT("ARMISTICE_GPT_DIVISOR");

	push	1
	push	OFFSET $SG231431
	mov	ecx, esi
	mov	DWORD PTR [esi+5024], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5790 : 	m_iARMISTICE_MIN_GOLD = getDefineINT("ARMISTICE_MIN_GOLD");

	push	1
	push	OFFSET $SG231432
	mov	ecx, esi
	mov	DWORD PTR [esi+5028], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5791 : 	m_iWAR_GOAL_THRESHOLD_CONQUEST = getDefineINT("WAR_GOAL_THRESHOLD_CONQUEST");

	push	1
	push	OFFSET $SG231433
	mov	ecx, esi
	mov	DWORD PTR [esi+5032], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5792 : 	m_iWAR_GOAL_THRESHOLD_DAMAGE = getDefineINT("WAR_GOAL_THRESHOLD_DAMAGE");

	push	1
	push	OFFSET $SG231434
	mov	ecx, esi
	mov	DWORD PTR [esi+5036], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5793 : 	m_iWAR_GOAL_THRESHOLD_PEACE = getDefineINT("WAR_GOAL_THRESHOLD_PEACE");

	push	1
	push	OFFSET $SG231435
	mov	ecx, esi
	mov	DWORD PTR [esi+5040], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5794 : 	m_iWAR_GOAL_STATE_CALM = getDefineINT("WAR_GOAL_STATE_CALM");

	push	1
	push	OFFSET $SG231436
	mov	ecx, esi
	mov	DWORD PTR [esi+5044], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5795 : 	m_iWAR_GOAL_STATE_NEARLY_WON = getDefineINT("WAR_GOAL_STATE_NEARLY_WON");

	push	1
	push	OFFSET $SG231437
	mov	ecx, esi
	mov	DWORD PTR [esi+5048], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5796 : 	m_iWAR_GOAL_STATE_OFFENSIVE = getDefineINT("WAR_GOAL_STATE_OFFENSIVE");

	push	1
	push	OFFSET $SG231438
	mov	ecx, esi
	mov	DWORD PTR [esi+5052], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5797 : 	m_iWAR_GOAL_STATE_STALEMATE = getDefineINT("WAR_GOAL_STATE_STALEMATE");

	push	1
	push	OFFSET $SG231439
	mov	ecx, esi
	mov	DWORD PTR [esi+5056], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5798 : 	m_iWAR_GOAL_STATE_DEFENSIVE = getDefineINT("WAR_GOAL_STATE_DEFENSIVE");

	push	1
	push	OFFSET $SG231440
	mov	ecx, esi
	mov	DWORD PTR [esi+5060], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5799 : 	m_iWAR_GOAL_STATE_NEARLY_DEFEATED = getDefineINT("WAR_GOAL_STATE_NEARLY_DEFEATED");

	push	1
	push	OFFSET $SG231441
	mov	ecx, esi
	mov	DWORD PTR [esi+5064], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+5068], eax

; 5800 : 	m_iWAR_GOAL_ANOTHER_PLAYER_STATE_CALM = getDefineINT("WAR_GOAL_ANOTHER_PLAYER_STATE_CALM");

	push	1
	push	OFFSET $SG231442
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5801 : 	m_iWAR_GOAL_ANOTHER_PLAYER_STATE_NEARLY_WON = getDefineINT("WAR_GOAL_ANOTHER_PLAYER_STATE_NEARLY_WON");

	push	1
	push	OFFSET $SG231443
	mov	ecx, esi
	mov	DWORD PTR [esi+5072], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5802 : 	m_iWAR_GOAL_ANOTHER_PLAYER_STATE_OFFENSIVE = getDefineINT("WAR_GOAL_ANOTHER_PLAYER_STATE_OFFENSIVE");

	push	1
	push	OFFSET $SG231444
	mov	ecx, esi
	mov	DWORD PTR [esi+5076], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5803 : 	m_iWAR_GOAL_ANOTHER_PLAYER_STATE_STALEMATE = getDefineINT("WAR_GOAL_ANOTHER_PLAYER_STATE_STALEMATE");

	push	1
	push	OFFSET $SG231445
	mov	ecx, esi
	mov	DWORD PTR [esi+5080], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5804 : 	m_iWAR_GOAL_ANOTHER_PLAYER_STATE_DEFENSIVE = getDefineINT("WAR_GOAL_ANOTHER_PLAYER_STATE_DEFENSIVE");

	push	1
	push	OFFSET $SG231446
	mov	ecx, esi
	mov	DWORD PTR [esi+5084], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5805 : 	m_iWAR_GOAL_ANOTHER_PLAYER_STATE_NEARLY_DEFEATED = getDefineINT("WAR_GOAL_ANOTHER_PLAYER_STATE_NEARLY_DEFEATED");

	push	1
	push	OFFSET $SG231447
	mov	ecx, esi
	mov	DWORD PTR [esi+5088], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5806 : 	m_iWAR_GOAL_DAMAGE_CRIPPLED = getDefineINT("WAR_GOAL_DAMAGE_CRIPPLED");

	push	1
	push	OFFSET $SG231448
	mov	ecx, esi
	mov	DWORD PTR [esi+5092], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5807 : 	m_iWAR_GOAL_DAMAGE_SERIOUS = getDefineINT("WAR_GOAL_DAMAGE_SERIOUS");

	push	1
	push	OFFSET $SG231449
	mov	ecx, esi
	mov	DWORD PTR [esi+5096], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5808 : 	m_iWAR_GOAL_DAMAGE_MAJOR = getDefineINT("WAR_GOAL_DAMAGE_MAJOR");

	push	1
	push	OFFSET $SG231450
	mov	ecx, esi
	mov	DWORD PTR [esi+5100], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5809 : 	m_iWAR_GOAL_DAMAGE_MINOR = getDefineINT("WAR_GOAL_DAMAGE_MINOR");

	push	1
	push	OFFSET $SG231451
	mov	ecx, esi
	mov	DWORD PTR [esi+5104], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5810 : 	m_iWAR_GOAL_DAMAGE_NONE = getDefineINT("WAR_GOAL_DAMAGE_NONE");

	push	1
	push	OFFSET $SG231452
	mov	ecx, esi
	mov	DWORD PTR [esi+5108], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5811 : 	m_iWAR_GOAL_GAME_THREAT_CRITICAL = getDefineINT("WAR_GOAL_GAME_THREAT_CRITICAL");

	push	1
	push	OFFSET $SG231453
	mov	ecx, esi
	mov	DWORD PTR [esi+5112], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5812 : 	m_iWAR_GOAL_GAME_THREAT_SEVERE = getDefineINT("WAR_GOAL_GAME_THREAT_SEVERE");

	push	1
	push	OFFSET $SG231454
	mov	ecx, esi
	mov	DWORD PTR [esi+5116], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5813 : 	m_iWAR_GOAL_GAME_THREAT_MAJOR = getDefineINT("WAR_GOAL_GAME_THREAT_MAJOR");

	push	1
	push	OFFSET $SG231455
	mov	ecx, esi
	mov	DWORD PTR [esi+5120], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5814 : 	m_iWAR_GOAL_GAME_THREAT_MINOR = getDefineINT("WAR_GOAL_GAME_THREAT_MINOR");

	push	1
	push	OFFSET $SG231456
	mov	ecx, esi
	mov	DWORD PTR [esi+5124], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5815 : 	m_iWAR_GOAL_GAME_THREAT_NONE = getDefineINT("WAR_GOAL_GAME_THREAT_NONE");

	push	1
	push	OFFSET $SG231457
	mov	ecx, esi
	mov	DWORD PTR [esi+5128], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+5132], eax

; 5816 : 	m_iWAR_GOAL_TARGET_SOFT = getDefineINT("WAR_GOAL_TARGET_SOFT");

	push	1
	push	OFFSET $SG231458
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5817 : 	m_iWAR_GOAL_TARGET_FAVORABLE = getDefineINT("WAR_GOAL_TARGET_FAVORABLE");

	push	1
	push	OFFSET $SG231459
	mov	ecx, esi
	mov	DWORD PTR [esi+5136], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5818 : 	m_iWAR_GOAL_TARGET_AVERAGE = getDefineINT("WAR_GOAL_TARGET_AVERAGE");

	push	1
	push	OFFSET $SG231460
	mov	ecx, esi
	mov	DWORD PTR [esi+5140], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5819 : 	m_iWAR_GOAL_TARGET_BAD = getDefineINT("WAR_GOAL_TARGET_BAD");

	push	1
	push	OFFSET $SG231461
	mov	ecx, esi
	mov	DWORD PTR [esi+5144], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5820 : 	m_iWAR_GOAL_TARGET_IMPOSSIBLE = getDefineINT("WAR_GOAL_TARGET_IMPOSSIBLE");

	push	1
	push	OFFSET $SG231462
	mov	ecx, esi
	mov	DWORD PTR [esi+5148], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5821 : 	m_iWAR_PROJECTION_THRESHOLD_VERY_GOOD = getDefineINT("WAR_PROJECTION_THRESHOLD_VERY_GOOD");

	push	1
	push	OFFSET $SG231463
	mov	ecx, esi
	mov	DWORD PTR [esi+5152], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5822 : 	m_iWAR_PROJECTION_THRESHOLD_GOOD = getDefineINT("WAR_PROJECTION_THRESHOLD_GOOD");

	push	1
	push	OFFSET $SG231464
	mov	ecx, esi
	mov	DWORD PTR [esi+5156], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5823 : 	m_iWAR_PROJECTION_THRESHOLD_DESTRUCTION = getDefineINT("WAR_PROJECTION_THRESHOLD_DESTRUCTION");

	push	1
	push	OFFSET $SG231465
	mov	ecx, esi
	mov	DWORD PTR [esi+5160], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5824 : 	m_iWAR_PROJECTION_THRESHOLD_DEFEAT = getDefineINT("WAR_PROJECTION_THRESHOLD_DEFEAT");

	push	1
	push	OFFSET $SG231466
	mov	ecx, esi
	mov	DWORD PTR [esi+5164], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5825 : 	m_iWAR_PROJECTION_THRESHOLD_STALEMATE = getDefineINT("WAR_PROJECTION_THRESHOLD_STALEMATE");

	push	1
	push	OFFSET $SG231467
	mov	ecx, esi
	mov	DWORD PTR [esi+5168], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5826 : 	m_iWAR_PROJECTION_THEIR_MILITARY_STRENGTH_PATHETIC = getDefineINT("WAR_PROJECTION_THEIR_MILITARY_STRENGTH_PATHETIC");

	push	1
	push	OFFSET $SG231468
	mov	ecx, esi
	mov	DWORD PTR [esi+5172], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5827 : 	m_iWAR_PROJECTION_THEIR_MILITARY_STRENGTH_WEAK = getDefineINT("WAR_PROJECTION_THEIR_MILITARY_STRENGTH_WEAK");

	push	1
	push	OFFSET $SG231469
	mov	ecx, esi
	mov	DWORD PTR [esi+5176], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5828 : 	m_iWAR_PROJECTION_RECKLESS_EXPANDER = getDefineINT("WAR_PROJECTION_RECKLESS_EXPANDER");

	push	1
	push	OFFSET $SG231470
	mov	ecx, esi
	mov	DWORD PTR [esi+5180], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5829 : 	m_iWAR_PROJECTION_THEIR_MILITARY_STRENGTH_POOR = getDefineINT("WAR_PROJECTION_THEIR_MILITARY_STRENGTH_POOR");

	push	1
	push	OFFSET $SG231471
	mov	ecx, esi
	mov	DWORD PTR [esi+5184], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5830 : 	m_iWAR_PROJECTION_THEIR_MILITARY_STRENGTH_AVERAGE = getDefineINT("WAR_PROJECTION_THEIR_MILITARY_STRENGTH_AVERAGE");

	push	1
	push	OFFSET $SG231472
	mov	ecx, esi
	mov	DWORD PTR [esi+5188], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5831 : 	m_iWAR_PROJECTION_THEIR_MILITARY_STRENGTH_STRONG = getDefineINT("WAR_PROJECTION_THEIR_MILITARY_STRENGTH_STRONG");

	push	1
	push	OFFSET $SG231473
	mov	ecx, esi
	mov	DWORD PTR [esi+5192], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5832 : 	m_iWAR_PROJECTION_THEIR_MILITARY_STRENGTH_POWERFUL = getDefineINT("WAR_PROJECTION_THEIR_MILITARY_STRENGTH_POWERFUL");

	push	1
	mov	DWORD PTR [esi+5196], eax
	push	OFFSET $SG231474
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5833 : 	m_iWAR_PROJECTION_THEIR_MILITARY_STRENGTH_IMMENSE = getDefineINT("WAR_PROJECTION_THEIR_MILITARY_STRENGTH_IMMENSE");

	push	1
	push	OFFSET $SG231475
	mov	ecx, esi
	mov	DWORD PTR [esi+5200], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5834 : 	m_iWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_PATHETIC = getDefineINT("WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_PATHETIC");

	push	1
	push	OFFSET $SG231476
	mov	ecx, esi
	mov	DWORD PTR [esi+5204], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5835 : 	m_iWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_WEAK = getDefineINT("WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_WEAK");

	push	1
	push	OFFSET $SG231477
	mov	ecx, esi
	mov	DWORD PTR [esi+5208], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5836 : 	m_iWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_POOR = getDefineINT("WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_POOR");

	push	1
	push	OFFSET $SG231478
	mov	ecx, esi
	mov	DWORD PTR [esi+5212], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5837 : 	m_iWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_AVERAGE = getDefineINT("WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_AVERAGE");

	push	1
	push	OFFSET $SG231479
	mov	ecx, esi
	mov	DWORD PTR [esi+5216], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5838 : 	m_iWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_STRONG = getDefineINT("WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_STRONG");

	push	1
	push	OFFSET $SG231480
	mov	ecx, esi
	mov	DWORD PTR [esi+5220], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5839 : 	m_iWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_POWERFUL = getDefineINT("WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_POWERFUL");

	push	1
	push	OFFSET $SG231481
	mov	ecx, esi
	mov	DWORD PTR [esi+5224], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5840 : 	m_iWAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_IMMENSE = getDefineINT("WAR_PROJECTION_THEIR_ECONOMIC_STRENGTH_IMMENSE");

	push	1
	push	OFFSET $SG231482
	mov	ecx, esi
	mov	DWORD PTR [esi+5228], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5841 : 	m_iWAR_PROJECTION_WAR_DAMAGE_US_NONE = getDefineINT("WAR_PROJECTION_WAR_DAMAGE_US_NONE");

	push	1
	push	OFFSET $SG231483
	mov	ecx, esi
	mov	DWORD PTR [esi+5232], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5842 : 	m_iWAR_PROJECTION_WAR_DAMAGE_US_MINOR = getDefineINT("WAR_PROJECTION_WAR_DAMAGE_US_MINOR");

	push	1
	push	OFFSET $SG231484
	mov	ecx, esi
	mov	DWORD PTR [esi+5236], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5843 : 	m_iWAR_PROJECTION_WAR_DAMAGE_US_MAJOR = getDefineINT("WAR_PROJECTION_WAR_DAMAGE_US_MAJOR");

	push	1
	push	OFFSET $SG231485
	mov	ecx, esi
	mov	DWORD PTR [esi+5240], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5844 : 	m_iWAR_PROJECTION_WAR_DAMAGE_US_SERIOUS = getDefineINT("WAR_PROJECTION_WAR_DAMAGE_US_SERIOUS");

	push	1
	push	OFFSET $SG231486
	mov	ecx, esi
	mov	DWORD PTR [esi+5244], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5845 : 	m_iWAR_PROJECTION_WAR_DAMAGE_US_CRIPPLED = getDefineINT("WAR_PROJECTION_WAR_DAMAGE_US_CRIPPLED");

	push	1
	push	OFFSET $SG231487
	mov	ecx, esi
	mov	DWORD PTR [esi+5248], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5846 : 	m_iWAR_PROJECTION_WAR_DAMAGE_THEM_NONE = getDefineINT("WAR_PROJECTION_WAR_DAMAGE_THEM_NONE");

	push	1
	push	OFFSET $SG231488
	mov	ecx, esi
	mov	DWORD PTR [esi+5252], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5847 : 	m_iWAR_PROJECTION_WAR_DAMAGE_THEM_MINOR = getDefineINT("WAR_PROJECTION_WAR_DAMAGE_THEM_MINOR");

	push	1
	push	OFFSET $SG231489
	mov	ecx, esi
	mov	DWORD PTR [esi+5256], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5848 : 	m_iWAR_PROJECTION_WAR_DAMAGE_THEM_MAJOR = getDefineINT("WAR_PROJECTION_WAR_DAMAGE_THEM_MAJOR");

	push	1
	mov	DWORD PTR [esi+5260], eax
	push	OFFSET $SG231490
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5849 : 	m_iWAR_PROJECTION_WAR_DAMAGE_THEM_SERIOUS = getDefineINT("WAR_PROJECTION_WAR_DAMAGE_THEM_SERIOUS");

	push	1
	push	OFFSET $SG231491
	mov	ecx, esi
	mov	DWORD PTR [esi+5264], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5850 : 	m_iWAR_PROJECTION_WAR_DAMAGE_THEM_CRIPPLED = getDefineINT("WAR_PROJECTION_WAR_DAMAGE_THEM_CRIPPLED");

	push	1
	push	OFFSET $SG231492
	mov	ecx, esi
	mov	DWORD PTR [esi+5268], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5851 : 	m_iWAR_PROJECTION_WAR_DURATION_SCORE_CAP = getDefineINT("WAR_PROJECTION_WAR_DURATION_SCORE_CAP");

	push	1
	push	OFFSET $SG231493
	mov	ecx, esi
	mov	DWORD PTR [esi+5272], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5852 : 	m_iWAR_STATE_CALM_THRESHOLD_FOREIGN_FORCES = getDefineINT("WAR_STATE_CALM_THRESHOLD_FOREIGN_FORCES");

	push	1
	push	OFFSET $SG231494
	mov	ecx, esi
	mov	DWORD PTR [esi+5276], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5853 : 	m_iWAR_STATE_THRESHOLD_NEARLY_WON = getDefineINT("WAR_STATE_THRESHOLD_NEARLY_WON");

	push	1
	push	OFFSET $SG231495
	mov	ecx, esi
	mov	DWORD PTR [esi+5280], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5854 : 	m_iWAR_STATE_THRESHOLD_OFFENSIVE = getDefineINT("WAR_STATE_THRESHOLD_OFFENSIVE");

	push	1
	push	OFFSET $SG231496
	mov	ecx, esi
	mov	DWORD PTR [esi+5284], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5855 : 	m_iWAR_STATE_THRESHOLD_STALEMATE = getDefineINT("WAR_STATE_THRESHOLD_STALEMATE");

	push	1
	push	OFFSET $SG231497
	mov	ecx, esi
	mov	DWORD PTR [esi+5288], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5856 : 	m_iWAR_STATE_THRESHOLD_DEFENSIVE = getDefineINT("WAR_STATE_THRESHOLD_DEFENSIVE");

	push	1
	push	OFFSET $SG231498
	mov	ecx, esi
	mov	DWORD PTR [esi+5292], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5857 : 	m_iWAR_DAMAGE_LEVEL_THRESHOLD_CRIPPLED = getDefineINT("WAR_DAMAGE_LEVEL_THRESHOLD_CRIPPLED");

	push	1
	push	OFFSET $SG231499
	mov	ecx, esi
	mov	DWORD PTR [esi+5296], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5858 : 	m_iWAR_DAMAGE_LEVEL_THRESHOLD_SERIOUS = getDefineINT("WAR_DAMAGE_LEVEL_THRESHOLD_SERIOUS");

	push	1
	push	OFFSET $SG231500
	mov	ecx, esi
	mov	DWORD PTR [esi+5300], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5859 : 	m_iWAR_DAMAGE_LEVEL_THRESHOLD_MAJOR = getDefineINT("WAR_DAMAGE_LEVEL_THRESHOLD_MAJOR");

	push	1
	push	OFFSET $SG231501
	mov	ecx, esi
	mov	DWORD PTR [esi+5304], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5860 : 	m_iWAR_DAMAGE_LEVEL_THRESHOLD_MINOR = getDefineINT("WAR_DAMAGE_LEVEL_THRESHOLD_MINOR");

	push	1
	push	OFFSET $SG231502
	mov	ecx, esi
	mov	DWORD PTR [esi+5308], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5861 : 	m_iWAR_DAMAGE_LEVEL_CITY_WEIGHT = getDefineINT("WAR_DAMAGE_LEVEL_CITY_WEIGHT");

	push	1
	push	OFFSET $SG231503
	mov	ecx, esi
	mov	DWORD PTR [esi+5312], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5862 : 	m_iWAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER = getDefineINT("WAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER");

	push	1
	push	OFFSET $SG231504
	mov	ecx, esi
	mov	DWORD PTR [esi+5316], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5863 : 	m_iWAR_DAMAGE_LEVEL_UNINVOLVED_CITY_POP_MULTIPLIER = getDefineINT("WAR_DAMAGE_LEVEL_UNINVOLVED_CITY_POP_MULTIPLIER");

	push	1
	push	OFFSET $SG231505
	mov	ecx, esi
	mov	DWORD PTR [esi+5320], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5864 : 	m_iMILITARY_AGGRESSIVE_POSTURE_THRESHOLD_INCREDIBLE = getDefineINT("MILITARY_AGGRESSIVE_POSTURE_THRESHOLD_INCREDIBLE");

	push	1
	push	OFFSET $SG231506
	mov	ecx, esi
	mov	DWORD PTR [esi+5324], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5865 : 	m_iMILITARY_AGGRESSIVE_POSTURE_THRESHOLD_HIGH = getDefineINT("MILITARY_AGGRESSIVE_POSTURE_THRESHOLD_HIGH");

	push	1
	push	OFFSET $SG231507
	mov	ecx, esi
	mov	DWORD PTR [esi+5328], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5866 : 	m_iMILITARY_AGGRESSIVE_POSTURE_THRESHOLD_MEDIUM = getDefineINT("MILITARY_AGGRESSIVE_POSTURE_THRESHOLD_MEDIUM");

	push	1
	push	OFFSET $SG231508
	mov	ecx, esi
	mov	DWORD PTR [esi+5332], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5867 : 	m_iMILITARY_AGGRESSIVE_POSTURE_THRESHOLD_LOW = getDefineINT("MILITARY_AGGRESSIVE_POSTURE_THRESHOLD_LOW");

	push	1
	push	OFFSET $SG231509
	mov	ecx, esi
	mov	DWORD PTR [esi+5336], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5868 : 	m_iEXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_HIGH = getDefineINT("EXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_HIGH");

	push	1
	push	OFFSET $SG231510
	mov	ecx, esi
	mov	DWORD PTR [esi+5340], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5869 : 	m_iEXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_MEDIUM = getDefineINT("EXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_MEDIUM");

	push	1
	push	OFFSET $SG231511
	mov	ecx, esi
	mov	DWORD PTR [esi+5344], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5870 : 	m_iEXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_LOW = getDefineINT("EXPANSION_CAPITAL_DISTANCE_AGGRESSIVE_POSTURE_LOW");

	push	1
	push	OFFSET $SG231512
	mov	ecx, esi
	mov	DWORD PTR [esi+5348], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5871 : 	m_iPLOT_BUYING_POSTURE_INCREDIBLE_THRESHOLD = getDefineINT("PLOT_BUYING_POSTURE_INCREDIBLE_THRESHOLD");

	push	1
	push	OFFSET $SG231513
	mov	ecx, esi
	mov	DWORD PTR [esi+5352], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5872 : 	m_iPLOT_BUYING_POSTURE_HIGH_THRESHOLD = getDefineINT("PLOT_BUYING_POSTURE_HIGH_THRESHOLD");

	push	1
	push	OFFSET $SG231514
	mov	ecx, esi
	mov	DWORD PTR [esi+5356], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5873 : 	m_iPLOT_BUYING_POSTURE_MEDIUM_THRESHOLD = getDefineINT("PLOT_BUYING_POSTURE_MEDIUM_THRESHOLD");

	push	1
	push	OFFSET $SG231515
	mov	ecx, esi
	mov	DWORD PTR [esi+5360], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5874 : 	m_iPLOT_BUYING_POSTURE_LOW_THRESHOLD = getDefineINT("PLOT_BUYING_POSTURE_LOW_THRESHOLD");

	push	1
	push	OFFSET $SG231516
	mov	ecx, esi
	mov	DWORD PTR [esi+5364], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5875 : 	m_iMILITARY_STRENGTH_BASE = getDefineINT("MILITARY_STRENGTH_BASE");

	push	1
	push	OFFSET $SG231517
	mov	ecx, esi
	mov	DWORD PTR [esi+5368], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5876 : 	m_iMILITARY_STRENGTH_RATIO_MULTIPLIER = getDefineINT("MILITARY_STRENGTH_RATIO_MULTIPLIER");

	push	1
	push	OFFSET $SG231518
	mov	ecx, esi
	mov	DWORD PTR [esi+5372], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5877 : 	m_iMILITARY_STRENGTH_CITY_MOD = getDefineINT("MILITARY_STRENGTH_CITY_MOD");

	push	1
	push	OFFSET $SG231519
	mov	ecx, esi
	mov	DWORD PTR [esi+5376], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5878 : 	m_iMILITARY_STRENGTH_IMMENSE_THRESHOLD = getDefineINT("MILITARY_STRENGTH_IMMENSE_THRESHOLD");

	push	1
	push	OFFSET $SG231520
	mov	ecx, esi
	mov	DWORD PTR [esi+5380], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5879 : 	m_iMILITARY_STRENGTH_POWERFUL_THRESHOLD = getDefineINT("MILITARY_STRENGTH_POWERFUL_THRESHOLD");

	push	1
	push	OFFSET $SG231521
	mov	ecx, esi
	mov	DWORD PTR [esi+5384], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5880 : 	m_iMILITARY_STRENGTH_STRONG_THRESHOLD = getDefineINT("MILITARY_STRENGTH_STRONG_THRESHOLD");

	push	1
	push	OFFSET $SG231522
	mov	ecx, esi
	mov	DWORD PTR [esi+5388], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+5392], eax

; 5881 : 	m_iMILITARY_STRENGTH_AVERAGE_THRESHOLD = getDefineINT("MILITARY_STRENGTH_AVERAGE_THRESHOLD");

	push	1
	push	OFFSET $SG231523
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5882 : 	m_iMILITARY_STRENGTH_POOR_THRESHOLD = getDefineINT("MILITARY_STRENGTH_POOR_THRESHOLD");

	push	1
	push	OFFSET $SG231524
	mov	ecx, esi
	mov	DWORD PTR [esi+5396], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5883 : 	m_iMILITARY_STRENGTH_WEAK_THRESHOLD = getDefineINT("MILITARY_STRENGTH_WEAK_THRESHOLD");

	push	1
	push	OFFSET $SG231525
	mov	ecx, esi
	mov	DWORD PTR [esi+5400], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5884 : 	m_iECONOMIC_STRENGTH_RATIO_MULTIPLIER = getDefineINT("ECONOMIC_STRENGTH_RATIO_MULTIPLIER");

	push	1
	push	OFFSET $SG231526
	mov	ecx, esi
	mov	DWORD PTR [esi+5404], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5885 : 	m_iECONOMIC_STRENGTH_IMMENSE_THRESHOLD = getDefineINT("ECONOMIC_STRENGTH_IMMENSE_THRESHOLD");

	push	1
	push	OFFSET $SG231527
	mov	ecx, esi
	mov	DWORD PTR [esi+5408], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5886 : 	m_iECONOMIC_STRENGTH_POWERFUL_THRESHOLD = getDefineINT("ECONOMIC_STRENGTH_POWERFUL_THRESHOLD");

	push	1
	push	OFFSET $SG231528
	mov	ecx, esi
	mov	DWORD PTR [esi+5412], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5887 : 	m_iECONOMIC_STRENGTH_STRONG_THRESHOLD = getDefineINT("ECONOMIC_STRENGTH_STRONG_THRESHOLD");

	push	1
	push	OFFSET $SG231529
	mov	ecx, esi
	mov	DWORD PTR [esi+5416], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5888 : 	m_iECONOMIC_STRENGTH_AVERAGE_THRESHOLD = getDefineINT("ECONOMIC_STRENGTH_AVERAGE_THRESHOLD");

	push	1
	push	OFFSET $SG231530
	mov	ecx, esi
	mov	DWORD PTR [esi+5420], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5889 : 	m_iECONOMIC_STRENGTH_POOR_THRESHOLD = getDefineINT("ECONOMIC_STRENGTH_POOR_THRESHOLD");

	push	1
	push	OFFSET $SG231531
	mov	ecx, esi
	mov	DWORD PTR [esi+5424], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5890 : 	m_iECONOMIC_STRENGTH_WEAK_THRESHOLD = getDefineINT("ECONOMIC_STRENGTH_WEAK_THRESHOLD");

	push	1
	push	OFFSET $SG231532
	mov	ecx, esi
	mov	DWORD PTR [esi+5428], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5891 : 	m_iTARGET_IMPOSSIBLE_THRESHOLD = getDefineINT("TARGET_IMPOSSIBLE_THRESHOLD");

	push	1
	push	OFFSET $SG231533
	mov	ecx, esi
	mov	DWORD PTR [esi+5432], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5892 : 	m_iTARGET_BAD_THRESHOLD = getDefineINT("TARGET_BAD_THRESHOLD");

	push	1
	push	OFFSET $SG231534
	mov	ecx, esi
	mov	DWORD PTR [esi+5436], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5893 : 	m_iTARGET_AVERAGE_THRESHOLD = getDefineINT("TARGET_AVERAGE_THRESHOLD");

	push	1
	push	OFFSET $SG231535
	mov	ecx, esi
	mov	DWORD PTR [esi+5440], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5894 : 	m_iTARGET_FAVORABLE_THRESHOLD = getDefineINT("TARGET_FAVORABLE_THRESHOLD");

	push	1
	push	OFFSET $SG231536
	mov	ecx, esi
	mov	DWORD PTR [esi+5444], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5895 : 	m_iTARGET_INCREASE_WAR_TURNS = getDefineINT("TARGET_INCREASE_WAR_TURNS");

	push	1
	push	OFFSET $SG231537
	mov	ecx, esi
	mov	DWORD PTR [esi+5448], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5896 : 	m_iTARGET_MILITARY_STRENGTH_IMMENSE = getDefineINT("TARGET_MILITARY_STRENGTH_IMMENSE");

	push	1
	push	OFFSET $SG231538
	mov	ecx, esi
	mov	DWORD PTR [esi+5452], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+5456], eax

; 5897 : 	m_iTARGET_MILITARY_STRENGTH_POWERFUL = getDefineINT("TARGET_MILITARY_STRENGTH_POWERFUL");

	push	1
	push	OFFSET $SG231539
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5898 : 	m_iTARGET_MILITARY_STRENGTH_STRONG = getDefineINT("TARGET_MILITARY_STRENGTH_STRONG");

	push	1
	push	OFFSET $SG231540
	mov	ecx, esi
	mov	DWORD PTR [esi+5460], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5899 : 	m_iTARGET_MILITARY_STRENGTH_AVERAGE = getDefineINT("TARGET_MILITARY_STRENGTH_AVERAGE");

	push	1
	push	OFFSET $SG231541
	mov	ecx, esi
	mov	DWORD PTR [esi+5464], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5900 : 	m_iTARGET_MILITARY_STRENGTH_POOR = getDefineINT("TARGET_MILITARY_STRENGTH_POOR");

	push	1
	push	OFFSET $SG231542
	mov	ecx, esi
	mov	DWORD PTR [esi+5468], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5901 : 	m_iTARGET_MILITARY_STRENGTH_WEAK = getDefineINT("TARGET_MILITARY_STRENGTH_WEAK");

	push	1
	push	OFFSET $SG231543
	mov	ecx, esi
	mov	DWORD PTR [esi+5472], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5902 : 	m_iTARGET_MILITARY_STRENGTH_PATHETIC = getDefineINT("TARGET_MILITARY_STRENGTH_PATHETIC");

	push	1
	push	OFFSET $SG231544
	mov	ecx, esi
	mov	DWORD PTR [esi+5476], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5903 : 	m_iTARGET_ALREADY_WAR_EACH_PLAYER = getDefineINT("TARGET_ALREADY_WAR_EACH_PLAYER");

	push	1
	push	OFFSET $SG231545
	mov	ecx, esi
	mov	DWORD PTR [esi+5480], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5904 : 	m_iTARGET_NEIGHBORS = getDefineINT("TARGET_NEIGHBORS");

	push	1
	push	OFFSET $SG231546
	mov	ecx, esi
	mov	DWORD PTR [esi+5484], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5905 : 	m_iTARGET_CLOSE = getDefineINT("TARGET_CLOSE");

	push	1
	push	OFFSET $SG231547
	mov	ecx, esi
	mov	DWORD PTR [esi+5488], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5906 : 	m_iTARGET_FAR = getDefineINT("TARGET_FAR");

	push	1
	push	OFFSET $SG231548
	mov	ecx, esi
	mov	DWORD PTR [esi+5492], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5907 : 	m_iTARGET_DISTANT = getDefineINT("TARGET_DISTANT");

	push	1
	push	OFFSET $SG231549
	mov	ecx, esi
	mov	DWORD PTR [esi+5496], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5908 : 	m_iTARGET_MINOR_BACKUP_PATHETIC = getDefineINT("TARGET_MINOR_BACKUP_PATHETIC");

	push	1
	push	OFFSET $SG231550
	mov	ecx, esi
	mov	DWORD PTR [esi+5500], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5909 : 	m_iTARGET_MINOR_BACKUP_WEAK = getDefineINT("TARGET_MINOR_BACKUP_WEAK");

	push	1
	push	OFFSET $SG231551
	mov	ecx, esi
	mov	DWORD PTR [esi+5504], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5910 : 	m_iTARGET_MINOR_BACKUP_POOR = getDefineINT("TARGET_MINOR_BACKUP_POOR");

	push	1
	push	OFFSET $SG231552
	mov	ecx, esi
	mov	DWORD PTR [esi+5508], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5911 : 	m_iTARGET_MINOR_BACKUP_AVERAGE = getDefineINT("TARGET_MINOR_BACKUP_AVERAGE");

	push	1
	push	OFFSET $SG231553
	mov	ecx, esi
	mov	DWORD PTR [esi+5512], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5912 : 	m_iTARGET_MINOR_BACKUP_STRONG = getDefineINT("TARGET_MINOR_BACKUP_STRONG");

	push	1
	push	OFFSET $SG231554
	mov	ecx, esi
	mov	DWORD PTR [esi+5516], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5913 : 	m_iTARGET_MINOR_BACKUP_POWERFUL = getDefineINT("TARGET_MINOR_BACKUP_POWERFUL");

	push	1
	mov	DWORD PTR [esi+5520], eax
	push	OFFSET $SG231555
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5914 : 	m_iTARGET_MINOR_BACKUP_IMMENSE = getDefineINT("TARGET_MINOR_BACKUP_IMMENSE");

	push	1
	push	OFFSET $SG231556
	mov	ecx, esi
	mov	DWORD PTR [esi+5524], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5915 : 	m_iTARGET_MINOR_BACKUP_DISTANT = getDefineINT("TARGET_MINOR_BACKUP_DISTANT");

	push	1
	push	OFFSET $SG231557
	mov	ecx, esi
	mov	DWORD PTR [esi+5528], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5916 : 	m_iTARGET_MINOR_BACKUP_FAR = getDefineINT("TARGET_MINOR_BACKUP_FAR");

	push	1
	push	OFFSET $SG231558
	mov	ecx, esi
	mov	DWORD PTR [esi+5532], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5917 : 	m_iTARGET_MINOR_BACKUP_CLOSE = getDefineINT("TARGET_MINOR_BACKUP_CLOSE");

	push	1
	push	OFFSET $SG231559
	mov	ecx, esi
	mov	DWORD PTR [esi+5536], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5918 : 	m_iTARGET_MINOR_BACKUP_NEIGHBORS = getDefineINT("TARGET_MINOR_BACKUP_NEIGHBORS");

	push	1
	push	OFFSET $SG231560
	mov	ecx, esi
	mov	DWORD PTR [esi+5540], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5919 : 	m_iGAME_THREAT_CRITICAL_THRESHOLD = getDefineINT("GAME_THREAT_CRITICAL_THRESHOLD");

	push	1
	push	OFFSET $SG231561
	mov	ecx, esi
	mov	DWORD PTR [esi+5544], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5920 : 	m_iGAME_THREAT_SEVERE_THRESHOLD = getDefineINT("GAME_THREAT_SEVERE_THRESHOLD");

	push	1
	push	OFFSET $SG231562
	mov	ecx, esi
	mov	DWORD PTR [esi+5548], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5921 : 	m_iGAME_THREAT_MAJOR_THRESHOLD = getDefineINT("GAME_THREAT_MAJOR_THRESHOLD");

	push	1
	push	OFFSET $SG231563
	mov	ecx, esi
	mov	DWORD PTR [esi+5552], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5922 : 	m_iGAME_THREAT_MINOR_THRESHOLD = getDefineINT("GAME_THREAT_MINOR_THRESHOLD");

	push	1
	push	OFFSET $SG231564
	mov	ecx, esi
	mov	DWORD PTR [esi+5556], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5923 : 	m_iGAME_THREAT_AT_WAR_STALEMATE = getDefineINT("GAME_THREAT_AT_WAR_STALEMATE");

	push	1
	push	OFFSET $SG231565
	mov	ecx, esi
	mov	DWORD PTR [esi+5560], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5924 : 	m_iGAME_THREAT_AT_WAR_DEFENSIVE = getDefineINT("GAME_THREAT_AT_WAR_DEFENSIVE");

	push	1
	push	OFFSET $SG231566
	mov	ecx, esi
	mov	DWORD PTR [esi+5564], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5925 : 	m_iGAME_THREAT_AT_WAR_NEARLY_DEFEATED = getDefineINT("GAME_THREAT_AT_WAR_NEARLY_DEFEATED");

	push	1
	push	OFFSET $SG231567
	mov	ecx, esi
	mov	DWORD PTR [esi+5568], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5926 : 	m_iGAME_THREAT_AT_WAR_MILITARY_STRENGTH_IMMENSE = getDefineINT("GAME_THREAT_AT_WAR_MILITARY_STRENGTH_IMMENSE");

	push	1
	push	OFFSET $SG231568
	mov	ecx, esi
	mov	DWORD PTR [esi+5572], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5927 : 	m_iGAME_THREAT_AT_WAR_MILITARY_STRENGTH_POWERFUL = getDefineINT("GAME_THREAT_AT_WAR_MILITARY_STRENGTH_POWERFUL");

	push	1
	push	OFFSET $SG231569
	mov	ecx, esi
	mov	DWORD PTR [esi+5576], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5928 : 	m_iGAME_THREAT_AT_WAR_MILITARY_STRENGTH_STRONG = getDefineINT("GAME_THREAT_AT_WAR_MILITARY_STRENGTH_STRONG");

	push	1
	push	OFFSET $SG231570
	mov	ecx, esi
	mov	DWORD PTR [esi+5580], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5929 : 	m_iGAME_THREAT_AT_WAR_MILITARY_STRENGTH_AVERAGE = getDefineINT("GAME_THREAT_AT_WAR_MILITARY_STRENGTH_AVERAGE");

	push	1
	mov	DWORD PTR [esi+5584], eax
	push	OFFSET $SG231571
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5930 : 	m_iGAME_THREAT_GUESS_AT_WAR = getDefineINT("GAME_THREAT_GUESS_AT_WAR");

	push	1
	push	OFFSET $SG231572
	mov	ecx, esi
	mov	DWORD PTR [esi+5588], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5931 : 	m_iGAME_THREAT_GUESS_AT_WAR_MILITARY_STRENGTH_IMMENSE = getDefineINT("GAME_THREAT_GUESS_AT_WAR_MILITARY_STRENGTH_IMMENSE");

	push	1
	push	OFFSET $SG231573
	mov	ecx, esi
	mov	DWORD PTR [esi+5592], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5932 : 	m_iGAME_THREAT_GUESS_AT_WAR_MILITARY_STRENGTH_POWERFUL = getDefineINT("GAME_THREAT_GUESS_AT_WAR_MILITARY_STRENGTH_POWERFUL");

	push	1
	push	OFFSET $SG231574
	mov	ecx, esi
	mov	DWORD PTR [esi+5596], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5933 : 	m_iGAME_THREAT_GUESS_AT_WAR_MILITARY_STRENGTH_STRONG = getDefineINT("GAME_THREAT_GUESS_AT_WAR_MILITARY_STRENGTH_STRONG");

	push	1
	push	OFFSET $SG231575
	mov	ecx, esi
	mov	DWORD PTR [esi+5600], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5934 : 	m_iGAME_THREAT_GUESS_AT_WAR_MILITARY_STRENGTH_AVERAGE = getDefineINT("GAME_THREAT_GUESS_AT_WAR_MILITARY_STRENGTH_AVERAGE");

	push	1
	push	OFFSET $SG231576
	mov	ecx, esi
	mov	DWORD PTR [esi+5604], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5935 : 	m_iMILITARY_THREAT_CRITICAL_THRESHOLD = getDefineINT("MILITARY_THREAT_CRITICAL_THRESHOLD");

	push	1
	push	OFFSET $SG231577
	mov	ecx, esi
	mov	DWORD PTR [esi+5608], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5936 : 	m_iMILITARY_THREAT_SEVERE_THRESHOLD = getDefineINT("MILITARY_THREAT_SEVERE_THRESHOLD");

	push	1
	push	OFFSET $SG231578
	mov	ecx, esi
	mov	DWORD PTR [esi+5612], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5937 : 	m_iMILITARY_THREAT_MAJOR_THRESHOLD = getDefineINT("MILITARY_THREAT_MAJOR_THRESHOLD");

	push	1
	push	OFFSET $SG231579
	mov	ecx, esi
	mov	DWORD PTR [esi+5616], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5938 : 	m_iMILITARY_THREAT_MINOR_THRESHOLD = getDefineINT("MILITARY_THREAT_MINOR_THRESHOLD");

	push	1
	push	OFFSET $SG231580
	mov	ecx, esi
	mov	DWORD PTR [esi+5620], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5939 : 	m_iMILITARY_THREAT_STRENGTH_IMMENSE = getDefineINT("MILITARY_THREAT_STRENGTH_IMMENSE");

	push	1
	push	OFFSET $SG231581
	mov	ecx, esi
	mov	DWORD PTR [esi+5624], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5940 : 	m_iMILITARY_THREAT_STRENGTH_POWERFUL = getDefineINT("MILITARY_THREAT_STRENGTH_POWERFUL");

	push	1
	push	OFFSET $SG231582
	mov	ecx, esi
	mov	DWORD PTR [esi+5628], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5941 : 	m_iMILITARY_THREAT_STRENGTH_STRONG = getDefineINT("MILITARY_THREAT_STRENGTH_STRONG");

	push	1
	push	OFFSET $SG231583
	mov	ecx, esi
	mov	DWORD PTR [esi+5632], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5942 : 	m_iMILITARY_THREAT_STRENGTH_AVERAGE = getDefineINT("MILITARY_THREAT_STRENGTH_AVERAGE");

	push	1
	push	OFFSET $SG231584
	mov	ecx, esi
	mov	DWORD PTR [esi+5636], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5943 : 	m_iMILITARY_THREAT_STRENGTH_POOR = getDefineINT("MILITARY_THREAT_STRENGTH_POOR");

	push	1
	push	OFFSET $SG231585
	mov	ecx, esi
	mov	DWORD PTR [esi+5640], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5944 : 	m_iMILITARY_THREAT_STRENGTH_WEAK = getDefineINT("MILITARY_THREAT_STRENGTH_WEAK");

	push	1
	push	OFFSET $SG231586
	mov	ecx, esi
	mov	DWORD PTR [esi+5644], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5945 : 	m_iMILITARY_THREAT_STRENGTH_PATHETIC = getDefineINT("MILITARY_THREAT_STRENGTH_PATHETIC");

	push	1
	push	OFFSET $SG231587
	mov	ecx, esi
	mov	DWORD PTR [esi+5648], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5946 : 	m_iMILITARY_THREAT_WAR_STATE_CALM = getDefineINT("MILITARY_THREAT_WAR_STATE_CALM");

	push	1
	push	OFFSET $SG231588
	mov	ecx, esi
	mov	DWORD PTR [esi+5652], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5947 : 	m_iMILITARY_THREAT_WAR_STATE_NEARLY_WON = getDefineINT("MILITARY_THREAT_WAR_STATE_NEARLY_WON");

	push	1
	push	OFFSET $SG231589
	mov	ecx, esi
	mov	DWORD PTR [esi+5656], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5948 : 	m_iMILITARY_THREAT_WAR_STATE_OFFENSIVE = getDefineINT("MILITARY_THREAT_WAR_STATE_OFFENSIVE");

	push	1
	push	OFFSET $SG231590
	mov	ecx, esi
	mov	DWORD PTR [esi+5660], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5949 : 	m_iMILITARY_THREAT_WAR_STATE_STALEMATE = getDefineINT("MILITARY_THREAT_WAR_STATE_STALEMATE");

	push	1
	push	OFFSET $SG231591
	mov	ecx, esi
	mov	DWORD PTR [esi+5664], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5950 : 	m_iMILITARY_THREAT_WAR_STATE_DEFENSIVE = getDefineINT("MILITARY_THREAT_WAR_STATE_DEFENSIVE");

	push	1
	push	OFFSET $SG231592
	mov	ecx, esi
	mov	DWORD PTR [esi+5668], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5951 : 	m_iMILITARY_THREAT_WAR_STATE_NEARLY_DEFEATED = getDefineINT("MILITARY_THREAT_WAR_STATE_NEARLY_DEFEATED");

	push	1
	push	OFFSET $SG231593
	mov	ecx, esi
	mov	DWORD PTR [esi+5672], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5952 : 	m_iMILITARY_THREAT_NEIGHBORS = getDefineINT("MILITARY_THREAT_NEIGHBORS");

	push	1
	push	OFFSET $SG231594
	mov	ecx, esi
	mov	DWORD PTR [esi+5676], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5953 : 	m_iMILITARY_THREAT_CLOSE = getDefineINT("MILITARY_THREAT_CLOSE");

	push	1
	push	OFFSET $SG231595
	mov	ecx, esi
	mov	DWORD PTR [esi+5680], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5954 : 	m_iMILITARY_THREAT_FAR = getDefineINT("MILITARY_THREAT_FAR");

	push	1
	push	OFFSET $SG231596
	mov	ecx, esi
	mov	DWORD PTR [esi+5684], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5955 : 	m_iMILITARY_THREAT_DISTANT = getDefineINT("MILITARY_THREAT_DISTANT");

	push	1
	push	OFFSET $SG231597
	mov	ecx, esi
	mov	DWORD PTR [esi+5688], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5956 : 	m_iMILITARY_THREAT_PER_MINOR_ATTACKED = getDefineINT("MILITARY_THREAT_PER_MINOR_ATTACKED");

	push	1
	push	OFFSET $SG231598
	mov	ecx, esi
	mov	DWORD PTR [esi+5692], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5957 : 	m_iMILITARY_THREAT_PER_MINOR_CONQUERED = getDefineINT("MILITARY_THREAT_PER_MINOR_CONQUERED");

	push	1
	push	OFFSET $SG231599
	mov	ecx, esi
	mov	DWORD PTR [esi+5696], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5958 : 	m_iMILITARY_THREAT_PER_MAJOR_ATTACKED = getDefineINT("MILITARY_THREAT_PER_MAJOR_ATTACKED");

	push	1
	push	OFFSET $SG231600
	mov	ecx, esi
	mov	DWORD PTR [esi+5700], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5959 : 	m_iMILITARY_THREAT_PER_MAJOR_CONQUERED = getDefineINT("MILITARY_THREAT_PER_MAJOR_CONQUERED");

	push	1
	push	OFFSET $SG231601
	mov	ecx, esi
	mov	DWORD PTR [esi+5704], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5960 : 	m_iMILITARY_THREAT_ALREADY_WAR_EACH_PLAYER_MULTIPLIER = getDefineINT("MILITARY_THREAT_ALREADY_WAR_EACH_PLAYER_MULTIPLIER");

	push	1
	push	OFFSET $SG231602
	mov	ecx, esi
	mov	DWORD PTR [esi+5708], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5961 : 	m_iWARMONGER_THREAT_CRITICAL_THRESHOLD = getDefineINT("WARMONGER_THREAT_CRITICAL_THRESHOLD");

	push	1
	push	OFFSET $SG231603
	mov	ecx, esi
	mov	DWORD PTR [esi+5712], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+5716], eax

; 5962 : 	m_iWARMONGER_THREAT_SEVERE_THRESHOLD = getDefineINT("WARMONGER_THREAT_SEVERE_THRESHOLD");

	push	1
	push	OFFSET $SG231604
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5963 : 	m_iWARMONGER_THREAT_MAJOR_THRESHOLD = getDefineINT("WARMONGER_THREAT_MAJOR_THRESHOLD");

	push	1
	push	OFFSET $SG231605
	mov	ecx, esi
	mov	DWORD PTR [esi+5720], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5964 : 	m_iWARMONGER_THREAT_MINOR_THRESHOLD = getDefineINT("WARMONGER_THREAT_MINOR_THRESHOLD");

	push	1
	push	OFFSET $SG231606
	mov	ecx, esi
	mov	DWORD PTR [esi+5724], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5965 : 	m_iWARMONGER_THREAT_MINOR_ATTACKED_WEIGHT = getDefineINT("WARMONGER_THREAT_MINOR_ATTACKED_WEIGHT");

	push	1
	push	OFFSET $SG231607
	mov	ecx, esi
	mov	DWORD PTR [esi+5728], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5966 : 	m_iWARMONGER_THREAT_MINOR_CONQUERED_WEIGHT = getDefineINT("WARMONGER_THREAT_MINOR_CONQUERED_WEIGHT");

	push	1
	push	OFFSET $SG231608
	mov	ecx, esi
	mov	DWORD PTR [esi+5732], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5967 : 	m_iWARMONGER_THREAT_MAJOR_ATTACKED_WEIGHT = getDefineINT("WARMONGER_THREAT_MAJOR_ATTACKED_WEIGHT");

	push	1
	push	OFFSET $SG231609
	mov	ecx, esi
	mov	DWORD PTR [esi+5736], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5968 : 	m_iWARMONGER_THREAT_MAJOR_CONQUERED_WEIGHT = getDefineINT("WARMONGER_THREAT_MAJOR_CONQUERED_WEIGHT");

	push	1
	push	OFFSET $SG231610
	mov	ecx, esi
	mov	DWORD PTR [esi+5740], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5969 : 	m_iWARMONGER_THREAT_PER_TURN_DECAY = getDefineINT("WARMONGER_THREAT_PER_TURN_DECAY");

	push	1
	push	OFFSET $SG231611
	mov	ecx, esi
	mov	DWORD PTR [esi+5744], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5970 : 	m_iWARMONGER_THREAT_PERSONALITY_MOD = getDefineINT("WARMONGER_THREAT_PERSONALITY_MOD");

	push	1
	push	OFFSET $SG231612
	mov	ecx, esi
	mov	DWORD PTR [esi+5748], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5971 : 	m_iWARMONGER_THREAT_CRITICAL_PERCENT_THRESHOLD = getDefineINT("WARMONGER_THREAT_CRITICAL_PERCENT_THRESHOLD");

	push	1
	push	OFFSET $SG231613
	mov	ecx, esi
	mov	DWORD PTR [esi+5752], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5972 : 	m_iWARMONGER_THREAT_SEVERE_PERCENT_THRESHOLD = getDefineINT("WARMONGER_THREAT_SEVERE_PERCENT_THRESHOLD");

	push	1
	push	OFFSET $SG231614
	mov	ecx, esi
	mov	DWORD PTR [esi+5756], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5973 : 	m_iWARMONGER_ON_CITY_STATE_MULTIPLIER = getDefineINT("WARMONGER_ON_CITY_STATE_MULTIPLIER");

	push	1
	push	OFFSET $SG231615
	mov	ecx, esi
	mov	DWORD PTR [esi+5760], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5974 : 	m_iLAND_DISPUTE_FIERCE_THRESHOLD = getDefineINT("LAND_DISPUTE_FIERCE_THRESHOLD");

	push	1
	push	OFFSET $SG231616
	mov	ecx, esi
	mov	DWORD PTR [esi+5764], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5975 : 	m_iLAND_DISPUTE_STRONG_THRESHOLD = getDefineINT("LAND_DISPUTE_STRONG_THRESHOLD");

	push	1
	push	OFFSET $SG231617
	mov	ecx, esi
	mov	DWORD PTR [esi+5768], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5976 : 	m_iLAND_DISPUTE_WEAK_THRESHOLD = getDefineINT("LAND_DISPUTE_WEAK_THRESHOLD");

	push	1
	push	OFFSET $SG231618
	mov	ecx, esi
	mov	DWORD PTR [esi+5772], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5977 : 	m_iVICTORY_DISPUTE_FIERCE_THRESHOLD = getDefineINT("VICTORY_DISPUTE_FIERCE_THRESHOLD");

	push	1
	push	OFFSET $SG231619
	mov	ecx, esi
	mov	DWORD PTR [esi+5776], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+5780], eax

; 5978 : 	m_iVICTORY_DISPUTE_STRONG_THRESHOLD = getDefineINT("VICTORY_DISPUTE_STRONG_THRESHOLD");

	push	1
	push	OFFSET $SG231620
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5979 : 	m_iVICTORY_DISPUTE_WEAK_THRESHOLD = getDefineINT("VICTORY_DISPUTE_WEAK_THRESHOLD");

	push	1
	push	OFFSET $SG231621
	mov	ecx, esi
	mov	DWORD PTR [esi+5784], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5980 : 	m_iWONDER_DISPUTE_FIERCE_THRESHOLD = getDefineINT("WONDER_DISPUTE_FIERCE_THRESHOLD");

	push	1
	push	OFFSET $SG231622
	mov	ecx, esi
	mov	DWORD PTR [esi+5788], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5981 : 	m_iWONDER_DISPUTE_STRONG_THRESHOLD = getDefineINT("WONDER_DISPUTE_STRONG_THRESHOLD");

	push	1
	push	OFFSET $SG231623
	mov	ecx, esi
	mov	DWORD PTR [esi+5792], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5982 : 	m_iWONDER_DISPUTE_WEAK_THRESHOLD = getDefineINT("WONDER_DISPUTE_WEAK_THRESHOLD");

	push	1
	push	OFFSET $SG231624
	mov	ecx, esi
	mov	DWORD PTR [esi+5796], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5983 : 	m_iMINOR_CIV_DISPUTE_FIERCE_THRESHOLD = getDefineINT("MINOR_CIV_DISPUTE_FIERCE_THRESHOLD");

	push	1
	push	OFFSET $SG231625
	mov	ecx, esi
	mov	DWORD PTR [esi+5800], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5984 : 	m_iMINOR_CIV_DISPUTE_STRONG_THRESHOLD = getDefineINT("MINOR_CIV_DISPUTE_STRONG_THRESHOLD");

	push	1
	push	OFFSET $SG231626
	mov	ecx, esi
	mov	DWORD PTR [esi+5804], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5985 : 	m_iMINOR_CIV_DISPUTE_WEAK_THRESHOLD = getDefineINT("MINOR_CIV_DISPUTE_WEAK_THRESHOLD");

	push	1
	push	OFFSET $SG231627
	mov	ecx, esi
	mov	DWORD PTR [esi+5808], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5986 : 	m_iMINOR_CIV_DISPUTE_ALLIES_WEIGHT = getDefineINT("MINOR_CIV_DISPUTE_ALLIES_WEIGHT");

	push	1
	push	OFFSET $SG231628
	mov	ecx, esi
	mov	DWORD PTR [esi+5812], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5987 : 	m_iMINOR_CIV_DISPUTE_FRIENDS_WEIGHT = getDefineINT("MINOR_CIV_DISPUTE_FRIENDS_WEIGHT");

	push	1
	push	OFFSET $SG231629
	mov	ecx, esi
	mov	DWORD PTR [esi+5816], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5988 : 	m_iLAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_NONE = getDefineINT("LAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_NONE");

	push	1
	push	OFFSET $SG231630
	mov	ecx, esi
	mov	DWORD PTR [esi+5820], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5989 : 	m_iLAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_LOW = getDefineINT("LAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_LOW");

	push	1
	push	OFFSET $SG231631
	mov	ecx, esi
	mov	DWORD PTR [esi+5824], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5990 : 	m_iLAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_MEDIUM = getDefineINT("LAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_MEDIUM");

	push	1
	push	OFFSET $SG231632
	mov	ecx, esi
	mov	DWORD PTR [esi+5828], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5991 : 	m_iLAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_HIGH = getDefineINT("LAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_HIGH");

	push	1
	push	OFFSET $SG231633
	mov	ecx, esi
	mov	DWORD PTR [esi+5832], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5992 : 	m_iLAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_INCREDIBLE = getDefineINT("LAND_DISPUTE_EXP_AGGRESSIVE_POSTURE_INCREDIBLE");

	push	1
	push	OFFSET $SG231634
	mov	ecx, esi
	mov	DWORD PTR [esi+5836], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5993 : 	m_iLAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_NONE = getDefineINT("LAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_NONE");

	push	1
	push	OFFSET $SG231635
	mov	ecx, esi
	mov	DWORD PTR [esi+5840], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5994 : 	m_iLAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_LOW = getDefineINT("LAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_LOW");

	push	1
	mov	DWORD PTR [esi+5844], eax
	push	OFFSET $SG231636
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5995 : 	m_iLAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_MEDIUM = getDefineINT("LAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_MEDIUM");

	push	1
	push	OFFSET $SG231637
	mov	ecx, esi
	mov	DWORD PTR [esi+5848], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5996 : 	m_iLAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_HIGH = getDefineINT("LAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_HIGH");

	push	1
	push	OFFSET $SG231638
	mov	ecx, esi
	mov	DWORD PTR [esi+5852], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5997 : 	m_iLAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_INCREDIBLE = getDefineINT("LAND_DISPUTE_PLOT_BUY_AGGRESSIVE_POSTURE_INCREDIBLE");

	push	1
	push	OFFSET $SG231639
	mov	ecx, esi
	mov	DWORD PTR [esi+5856], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5998 : 	m_iLAND_DISPUTE_DISTANT = getDefineINT("LAND_DISPUTE_DISTANT");

	push	1
	push	OFFSET $SG231640
	mov	ecx, esi
	mov	DWORD PTR [esi+5860], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 5999 : 	m_iLAND_DISPUTE_FAR = getDefineINT("LAND_DISPUTE_FAR");

	push	1
	push	OFFSET $SG231641
	mov	ecx, esi
	mov	DWORD PTR [esi+5864], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6000 : 	m_iLAND_DISPUTE_CLOSE = getDefineINT("LAND_DISPUTE_CLOSE");

	push	1
	push	OFFSET $SG231642
	mov	ecx, esi
	mov	DWORD PTR [esi+5868], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6001 : 	m_iLAND_DISPUTE_NEIGHBORS = getDefineINT("LAND_DISPUTE_NEIGHBORS");

	push	1
	push	OFFSET $SG231643
	mov	ecx, esi
	mov	DWORD PTR [esi+5872], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6002 : 	m_iLAND_DISPUTE_CRAMPED_MULTIPLIER = getDefineINT("LAND_DISPUTE_CRAMPED_MULTIPLIER");

	push	1
	push	OFFSET $SG231644
	mov	ecx, esi
	mov	DWORD PTR [esi+5876], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6003 : 	m_iLAND_DISPUTE_NO_EXPANSION_STRATEGY = getDefineINT("LAND_DISPUTE_NO_EXPANSION_STRATEGY");

	push	1
	push	OFFSET $SG231645
	mov	ecx, esi
	mov	DWORD PTR [esi+5880], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6004 : 	m_iVICTORY_DISPUTE_GRAND_STRATEGY_MATCH_POSITIVE = getDefineINT("VICTORY_DISPUTE_GRAND_STRATEGY_MATCH_POSITIVE");

	push	1
	push	OFFSET $SG231646
	mov	ecx, esi
	mov	DWORD PTR [esi+5884], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6005 : 	m_iVICTORY_DISPUTE_GRAND_STRATEGY_MATCH_LIKELY = getDefineINT("VICTORY_DISPUTE_GRAND_STRATEGY_MATCH_LIKELY");

	push	1
	push	OFFSET $SG231647
	mov	ecx, esi
	mov	DWORD PTR [esi+5888], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6006 : 	m_iVICTORY_DISPUTE_GRAND_STRATEGY_MATCH_UNSURE = getDefineINT("VICTORY_DISPUTE_GRAND_STRATEGY_MATCH_UNSURE");

	push	1
	push	OFFSET $SG231648
	mov	ecx, esi
	mov	DWORD PTR [esi+5892], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6007 : 	m_iLAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_10 = getDefineINT("LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_10");

	push	1
	push	OFFSET $SG231649
	mov	ecx, esi
	mov	DWORD PTR [esi+5896], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6008 : 	m_iLAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_9 = getDefineINT("LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_9");

	push	1
	push	OFFSET $SG231650
	mov	ecx, esi
	mov	DWORD PTR [esi+5900], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6009 : 	m_iLAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_8 = getDefineINT("LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_8");

	push	1
	push	OFFSET $SG231651
	mov	ecx, esi
	mov	DWORD PTR [esi+5904], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6010 : 	m_iLAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_7 = getDefineINT("LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_7");

	push	1
	mov	DWORD PTR [esi+5908], eax
	push	OFFSET $SG231652
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6011 : 	m_iLAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_6 = getDefineINT("LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_6");

	push	1
	push	OFFSET $SG231653
	mov	ecx, esi
	mov	DWORD PTR [esi+5912], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6012 : 	m_iLAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_5 = getDefineINT("LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_5");

	push	1
	push	OFFSET $SG231654
	mov	ecx, esi
	mov	DWORD PTR [esi+5916], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6013 : 	m_iLAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_4 = getDefineINT("LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_4");

	push	1
	push	OFFSET $SG231655
	mov	ecx, esi
	mov	DWORD PTR [esi+5920], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6014 : 	m_iLAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_3 = getDefineINT("LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_3");

	push	1
	push	OFFSET $SG231656
	mov	ecx, esi
	mov	DWORD PTR [esi+5924], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6015 : 	m_iLAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_2 = getDefineINT("LAND_DISPUTE_CITY_RATIO_EXPANSION_GUESS_2");

	push	1
	push	OFFSET $SG231657
	mov	ecx, esi
	mov	DWORD PTR [esi+5928], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6016 : 	m_iVICTORY_DISPUTE_OTHER_PLAYER_FIERCE_THRESHOLD = getDefineINT("VICTORY_DISPUTE_OTHER_PLAYER_FIERCE_THRESHOLD");

	push	1
	push	OFFSET $SG231658
	mov	ecx, esi
	mov	DWORD PTR [esi+5932], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6017 : 	m_iVICTORY_DISPUTE_OTHER_PLAYER_STRONG_THRESHOLD = getDefineINT("VICTORY_DISPUTE_OTHER_PLAYER_STRONG_THRESHOLD");

	push	1
	push	OFFSET $SG231659
	mov	ecx, esi
	mov	DWORD PTR [esi+5936], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6018 : 	m_iVICTORY_DISPUTE_OTHER_PLAYER_WEAK_THRESHOLD = getDefineINT("VICTORY_DISPUTE_OTHER_PLAYER_WEAK_THRESHOLD");

	push	1
	push	OFFSET $SG231660
	mov	ecx, esi
	mov	DWORD PTR [esi+5940], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6019 : 	m_iVICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_POSITIVE = getDefineINT("VICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_POSITIVE");

	push	1
	push	OFFSET $SG231661
	mov	ecx, esi
	mov	DWORD PTR [esi+5944], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6020 : 	m_iVICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_LIKELY = getDefineINT("VICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_LIKELY");

	push	1
	push	OFFSET $SG231662
	mov	ecx, esi
	mov	DWORD PTR [esi+5948], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6021 : 	m_iVICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_UNSURE = getDefineINT("VICTORY_DISPUTE_OTHER_PLAYER_GRAND_STRATEGY_MATCH_UNSURE");

	push	1
	push	OFFSET $SG231663
	mov	ecx, esi
	mov	DWORD PTR [esi+5952], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6022 : 	m_iIC_MEMORY_TURN_EXPIRATION = getDefineINT("IC_MEMORY_TURN_EXPIRATION");

	push	1
	push	OFFSET $SG231664
	mov	ecx, esi
	mov	DWORD PTR [esi+5956], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6023 : 	m_iSTOP_SPYING_MEMORY_TURN_EXPIRATION = getDefineINT("STOP_SPYING_MEMORY_TURN_EXPIRATION");

	push	1
	push	OFFSET $SG231665
	mov	ecx, esi
	mov	DWORD PTR [esi+5960], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6024 : 	m_iCOOP_WAR_SOON_COUNTER = getDefineINT("COOP_WAR_SOON_COUNTER");

	push	1
	push	OFFSET $SG231666
	mov	ecx, esi
	mov	DWORD PTR [esi+5964], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6025 : 	m_iCOOP_WAR_LOCKED_TURNS = getDefineINT("COOP_WAR_LOCKED_TURNS");

	push	1
	push	OFFSET $SG231667
	mov	ecx, esi
	mov	DWORD PTR [esi+5968], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6026 : 	m_iCOOP_WAR_LOCKED_TURNS_WAR_WEIGHT = getDefineINT("COOP_WAR_LOCKED_TURNS_WAR_WEIGHT");

	push	1
	push	OFFSET $SG231668
	mov	ecx, esi
	mov	DWORD PTR [esi+5972], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6027 : 	m_iDEMAND_TURN_LIMIT_MIN = getDefineINT("DEMAND_TURN_LIMIT_MIN");

	push	1
	push	OFFSET $SG231669
	mov	ecx, esi
	mov	DWORD PTR [esi+5976], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6028 : 	m_iDEMAND_TURN_LIMIT_RAND = getDefineINT("DEMAND_TURN_LIMIT_RAND");

	push	1
	push	OFFSET $SG231670
	mov	ecx, esi
	mov	DWORD PTR [esi+5980], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6029 : 	m_iDONT_SETTLE_RAND = getDefineINT("DONT_SETTLE_RAND");

	push	1
	push	OFFSET $SG231671
	mov	ecx, esi
	mov	DWORD PTR [esi+5984], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6030 : 	m_iDONT_SETTLE_FLAVOR_BASE = getDefineINT("DONT_SETTLE_FLAVOR_BASE");

	push	1
	push	OFFSET $SG231672
	mov	ecx, esi
	mov	DWORD PTR [esi+5988], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6031 : 	m_iDONT_SETTLE_FLAVOR_MULTIPLIER = getDefineINT("DONT_SETTLE_FLAVOR_MULTIPLIER");

	push	1
	push	OFFSET $SG231673
	mov	ecx, esi
	mov	DWORD PTR [esi+5992], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6032 : 	m_iDONT_SETTLE_FRIENDLY = getDefineINT("DONT_SETTLE_FRIENDLY");

	push	1
	push	OFFSET $SG231674
	mov	ecx, esi
	mov	DWORD PTR [esi+5996], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6033 : 	m_iDONT_SETTLE_STRENGTH_PATHETIC = getDefineINT("DONT_SETTLE_STRENGTH_PATHETIC");

	push	1
	push	OFFSET $SG231675
	mov	ecx, esi
	mov	DWORD PTR [esi+6000], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6034 : 	m_iDONT_SETTLE_STRENGTH_WEAK = getDefineINT("DONT_SETTLE_STRENGTH_WEAK");

	push	1
	push	OFFSET $SG231676
	mov	ecx, esi
	mov	DWORD PTR [esi+6004], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6035 : 	m_iDONT_SETTLE_STRENGTH_POOR = getDefineINT("DONT_SETTLE_STRENGTH_POOR");

	push	1
	push	OFFSET $SG231677
	mov	ecx, esi
	mov	DWORD PTR [esi+6008], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6036 : 	m_iDONT_SETTLE_STRENGTH_AVERAGE = getDefineINT("DONT_SETTLE_STRENGTH_AVERAGE");

	push	1
	push	OFFSET $SG231678
	mov	ecx, esi
	mov	DWORD PTR [esi+6012], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6037 : 	m_iDONT_SETTLE_STRENGTH_STRONG = getDefineINT("DONT_SETTLE_STRENGTH_STRONG");

	push	1
	push	OFFSET $SG231679
	mov	ecx, esi
	mov	DWORD PTR [esi+6016], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6038 : 	m_iDONT_SETTLE_STRENGTH_POWERFUL = getDefineINT("DONT_SETTLE_STRENGTH_POWERFUL");

	push	1
	push	OFFSET $SG231680
	mov	ecx, esi
	mov	DWORD PTR [esi+6020], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6039 : 	m_iDONT_SETTLE_STRENGTH_IMMENSE = getDefineINT("DONT_SETTLE_STRENGTH_IMMENSE");

	push	1
	push	OFFSET $SG231681
	mov	ecx, esi
	mov	DWORD PTR [esi+6024], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6040 : 	m_iDONT_SETTLE_MOD_MILITARY_POSTURE_NONE = getDefineINT("DONT_SETTLE_MOD_MILITARY_POSTURE_NONE");

	push	1
	push	OFFSET $SG231682
	mov	ecx, esi
	mov	DWORD PTR [esi+6028], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6041 : 	m_iDONT_SETTLE_MOD_MILITARY_POSTURE_LOW = getDefineINT("DONT_SETTLE_MOD_MILITARY_POSTURE_LOW");

	push	1
	push	OFFSET $SG231683
	mov	ecx, esi
	mov	DWORD PTR [esi+6032], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6042 : 	m_iDONT_SETTLE_MOD_MILITARY_POSTURE_MEDIUM = getDefineINT("DONT_SETTLE_MOD_MILITARY_POSTURE_MEDIUM");

	push	1
	push	OFFSET $SG231684
	mov	ecx, esi
	mov	DWORD PTR [esi+6036], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+6040], eax

; 6043 : 	m_iDONT_SETTLE_MOD_MILITARY_POSTURE_HIGH = getDefineINT("DONT_SETTLE_MOD_MILITARY_POSTURE_HIGH");

	push	1
	push	OFFSET $SG231685
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6044 : 	m_iDONT_SETTLE_MOD_MILITARY_POSTURE_INCREDIBLE = getDefineINT("DONT_SETTLE_MOD_MILITARY_POSTURE_INCREDIBLE");

	push	1
	push	OFFSET $SG231686
	mov	ecx, esi
	mov	DWORD PTR [esi+6044], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6045 : 	m_iDOF_TURN_BUFFER = getDefineINT("DOF_TURN_BUFFER");

	push	1
	push	OFFSET $SG231687
	mov	ecx, esi
	mov	DWORD PTR [esi+6048], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6046 : 	m_iDOF_THRESHOLD = getDefineINT("DOF_THRESHOLD");

	push	1
	push	OFFSET $SG231688
	mov	ecx, esi
	mov	DWORD PTR [esi+6052], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6047 : 	m_iDENUNCIATION_EXPIRATION_TIME = getDefineINT("DENUNCIATION_EXPIRATION_TIME");

	push	1
	push	OFFSET $SG231689
	mov	ecx, esi
	mov	DWORD PTR [esi+6056], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6048 : 	m_iDOF_EXPIRATION_TIME = getDefineINT("DOF_EXPIRATION_TIME");

	push	1
	push	OFFSET $SG231690
	mov	ecx, esi
	mov	DWORD PTR [esi+6060], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6049 : 	m_iEACH_GOLD_VALUE_PERCENT = getDefineINT("EACH_GOLD_VALUE_PERCENT");

	push	1
	push	OFFSET $SG231691
	mov	ecx, esi
	mov	DWORD PTR [esi+6064], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6050 : 	m_iEACH_GOLD_PER_TURN_VALUE_PERCENT = getDefineINT("EACH_GOLD_PER_TURN_VALUE_PERCENT");

	push	1
	push	OFFSET $SG231692
	mov	ecx, esi
	mov	DWORD PTR [esi+6068], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6051 : 
; 6052 : 	m_iEXPANSION_BICKER_TIMEOUT = getDefineINT("EXPANSION_BICKER_TIMEOUT");

	push	1
	push	OFFSET $SG231693
	mov	ecx, esi
	mov	DWORD PTR [esi+6072], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6053 : 	m_iEXPANSION_PROMISE_TURNS_EFFECTIVE = getDefineINT("EXPANSION_PROMISE_TURNS_EFFECTIVE");

	push	1
	push	OFFSET $SG231694
	mov	ecx, esi
	mov	DWORD PTR [esi+6076], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6054 : 	m_iEXPANSION_PROMISE_BROKEN_PER_TURN_DECAY = getDefineINT("EXPANSION_PROMISE_BROKEN_PER_TURN_DECAY");

	push	1
	push	OFFSET $SG231695
	mov	ecx, esi
	mov	DWORD PTR [esi+6080], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6055 : 	m_iBROKEN_EXPANSION_PROMISE_PER_OPINION_WEIGHT = getDefineINT("BROKEN_EXPANSION_PROMISE_PER_OPINION_WEIGHT");

	push	1
	push	OFFSET $SG231696
	mov	ecx, esi
	mov	DWORD PTR [esi+6084], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6056 : 	m_iOPINION_WEIGHT_EXPANSION_PROMISE_BROKE_MAX = getDefineINT("OPINION_WEIGHT_EXPANSION_PROMISE_BROKE_MAX");

	push	1
	push	OFFSET $SG231697
	mov	ecx, esi
	mov	DWORD PTR [esi+6088], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6057 : 	m_iEXPANSION_PROMISE_IGNORED_PER_TURN_DECAY = getDefineINT("EXPANSION_PROMISE_IGNORED_PER_TURN_DECAY");

	push	1
	push	OFFSET $SG231698
	mov	ecx, esi
	mov	DWORD PTR [esi+6092], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6058 : 	m_iIGNORED_EXPANSION_PROMISE_PER_OPINION_WEIGHT = getDefineINT("IGNORED_EXPANSION_PROMISE_PER_OPINION_WEIGHT");

	push	1
	push	OFFSET $SG231699
	mov	ecx, esi
	mov	DWORD PTR [esi+6096], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6059 : 	m_iOPINION_WEIGHT_EXPANSION_PROMISE_IGNORED_MAX = getDefineINT("OPINION_WEIGHT_EXPANSION_PROMISE_IGNORED_MAX");

	push	1
	push	OFFSET $SG231700
	mov	ecx, esi
	mov	DWORD PTR [esi+6100], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+6104], eax

; 6060 : 
; 6061 : 	m_iBORDER_PROMISE_TURNS_EFFECTIVE = getDefineINT("BORDER_PROMISE_TURNS_EFFECTIVE");

	push	1
	push	OFFSET $SG231701
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6062 : 	m_iBORDER_PROMISE_BROKEN_PER_TURN_DECAY = getDefineINT("BORDER_PROMISE_BROKEN_PER_TURN_DECAY");

	push	1
	push	OFFSET $SG231702
	mov	ecx, esi
	mov	DWORD PTR [esi+6108], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6063 : 	m_iBROKEN_BORDER_PROMISE_PER_OPINION_WEIGHT = getDefineINT("BROKEN_BORDER_PROMISE_PER_OPINION_WEIGHT");

	push	1
	push	OFFSET $SG231703
	mov	ecx, esi
	mov	DWORD PTR [esi+6112], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6064 : 	m_iOPINION_WEIGHT_BORDER_PROMISE_BROKE_MAX = getDefineINT("OPINION_WEIGHT_BORDER_PROMISE_BROKE_MAX");

	push	1
	push	OFFSET $SG231704
	mov	ecx, esi
	mov	DWORD PTR [esi+6116], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6065 : 	m_iBORDER_PROMISE_IGNORED_PER_TURN_DECAY = getDefineINT("BORDER_PROMISE_IGNORED_PER_TURN_DECAY");

	push	1
	push	OFFSET $SG231705
	mov	ecx, esi
	mov	DWORD PTR [esi+6120], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6066 : 	m_iIGNORED_BORDER_PROMISE_PER_OPINION_WEIGHT = getDefineINT("IGNORED_BORDER_PROMISE_PER_OPINION_WEIGHT");

	push	1
	push	OFFSET $SG231706
	mov	ecx, esi
	mov	DWORD PTR [esi+6124], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6067 : 	m_iOPINION_WEIGHT_BORDER_PROMISE_IGNORED_MAX = getDefineINT("OPINION_WEIGHT_BORDER_PROMISE_IGNORED_MAX");

	push	1
	push	OFFSET $SG231707
	mov	ecx, esi
	mov	DWORD PTR [esi+6128], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6068 : 	m_iDECLARED_WAR_ON_FRIEND_PER_TURN_DECAY = getDefineINT("DECLARED_WAR_ON_FRIEND_PER_TURN_DECAY");

	push	1
	push	OFFSET $SG231708
	mov	ecx, esi
	mov	DWORD PTR [esi+6132], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6069 : 	m_iDECLARED_WAR_ON_FRIEND_PER_OPINION_WEIGHT = getDefineINT("DECLARED_WAR_ON_FRIEND_PER_OPINION_WEIGHT");

	push	1
	push	OFFSET $SG231709
	mov	ecx, esi
	mov	DWORD PTR [esi+6136], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6070 : 
; 6071 : 	m_iDEAL_VALUE_PER_TURN_DECAY = getDefineINT("DEAL_VALUE_PER_TURN_DECAY");

	push	1
	push	OFFSET $SG231710
	mov	ecx, esi
	mov	DWORD PTR [esi+6140], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6072 : 	m_iDEAL_VALUE_PER_OPINION_WEIGHT = getDefineINT("DEAL_VALUE_PER_OPINION_WEIGHT");

	push	1
	push	OFFSET $SG231711
	mov	ecx, esi
	mov	DWORD PTR [esi+6144], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6073 : 	m_iCOMMON_FOE_VALUE_PER_TURN_DECAY = getDefineINT("COMMON_FOE_VALUE_PER_TURN_DECAY");

	push	1
	push	OFFSET $SG231712
	mov	ecx, esi
	mov	DWORD PTR [esi+6148], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6074 : 	m_iCOMMON_FOE_VALUE_PER_OPINION_WEIGHT = getDefineINT("COMMON_FOE_VALUE_PER_OPINION_WEIGHT");

	push	1
	push	OFFSET $SG231713
	mov	ecx, esi
	mov	DWORD PTR [esi+6152], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6075 : 	m_iWANT_RESEARCH_AGREEMENT_RAND = getDefineINT("WANT_RESEARCH_AGREEMENT_RAND");

	push	1
	push	OFFSET $SG231714
	mov	ecx, esi
	mov	DWORD PTR [esi+6156], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6076 : 	m_iDEMAND_RAND = getDefineINT("DEMAND_RAND");

	push	1
	push	OFFSET $SG231715
	mov	ecx, esi
	mov	DWORD PTR [esi+6160], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6077 : 	m_iCAN_WORK_WATER_FROM_GAME_START = getDefineINT("CAN_WORK_WATER_FROM_GAME_START");

	push	1
	push	OFFSET $SG231716
	mov	ecx, esi
	mov	DWORD PTR [esi+6164], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6078 : 	m_iNAVAL_PLOT_BLOCKADE_RANGE = getDefineINT("NAVAL_PLOT_BLOCKADE_RANGE");

	push	1
	mov	DWORD PTR [esi+6168], eax
	push	OFFSET $SG231717
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6079 : 	m_iEVENT_MESSAGE_TIME = getDefineINT("EVENT_MESSAGE_TIME");

	push	1
	push	OFFSET $SG231718
	mov	ecx, esi
	mov	DWORD PTR [esi+6172], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6080 : 	m_iSTART_YEAR = getDefineINT("START_YEAR");

	push	1
	push	OFFSET $SG231719
	mov	ecx, esi
	mov	DWORD PTR [esi+6176], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6081 : 	m_iWEEKS_PER_MONTHS = getDefineINT("WEEKS_PER_MONTHS");

	push	1
	push	OFFSET $SG231720
	mov	ecx, esi
	mov	DWORD PTR [esi+6180], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6082 : 	m_iHIDDEN_START_TURN_OFFSET = getDefineINT("HIDDEN_START_TURN_OFFSET");

	push	1
	push	OFFSET $SG231721
	mov	ecx, esi
	mov	DWORD PTR [esi+6184], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6083 : 	m_iRECON_VISIBILITY_RANGE = getDefineINT("RECON_VISIBILITY_RANGE");

	push	1
	push	OFFSET $SG231722
	mov	ecx, esi
	mov	DWORD PTR [esi+6188], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6084 : 	m_iPLOT_VISIBILITY_RANGE = getDefineINT("PLOT_VISIBILITY_RANGE");

	push	1
	push	OFFSET $SG231723
	mov	ecx, esi
	mov	DWORD PTR [esi+6192], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6085 : 	m_iUNIT_VISIBILITY_RANGE = getDefineINT("UNIT_VISIBILITY_RANGE");

	push	1
	push	OFFSET $SG231724
	mov	ecx, esi
	mov	DWORD PTR [esi+6196], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6086 : 	m_iAIR_UNIT_REBASE_RANGE_MULTIPLIER = getDefineINT("AIR_UNIT_REBASE_RANGE_MULTIPLIER");

	push	1
	push	OFFSET $SG231725
	mov	ecx, esi
	mov	DWORD PTR [esi+6200], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6087 : 	m_iMOUNTAIN_SEE_FROM_CHANGE = getDefineINT("MOUNTAIN_SEE_FROM_CHANGE");

	push	1
	push	OFFSET $SG231726
	mov	ecx, esi
	mov	DWORD PTR [esi+6204], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6088 : 	m_iMOUNTAIN_SEE_THROUGH_CHANGE = getDefineINT("MOUNTAIN_SEE_THROUGH_CHANGE");

	push	1
	push	OFFSET $SG231727
	mov	ecx, esi
	mov	DWORD PTR [esi+6208], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6089 : 	m_iHILLS_SEE_FROM_CHANGE = getDefineINT("HILLS_SEE_FROM_CHANGE");

	push	1
	push	OFFSET $SG231728
	mov	ecx, esi
	mov	DWORD PTR [esi+6212], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6090 : 	m_iHILLS_SEE_THROUGH_CHANGE = getDefineINT("HILLS_SEE_THROUGH_CHANGE");

	push	1
	push	OFFSET $SG231729
	mov	ecx, esi
	mov	DWORD PTR [esi+6216], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6091 : 	m_iSEAWATER_SEE_FROM_CHANGE = getDefineINT("SEAWATER_SEE_FROM_CHANGE");

	push	1
	push	OFFSET $SG231730
	mov	ecx, esi
	mov	DWORD PTR [esi+6220], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6092 : 	m_iSEAWATER_SEE_THROUGH_CHANGE = getDefineINT("SEAWATER_SEE_THROUGH_CHANGE");

	push	1
	push	OFFSET $SG231731
	mov	ecx, esi
	mov	DWORD PTR [esi+6224], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6093 : 	m_iMAX_YIELD_STACK = getDefineINT("MAX_YIELD_STACK");

	push	1
	push	OFFSET $SG231732
	mov	ecx, esi
	mov	DWORD PTR [esi+6228], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6094 : 	m_iMOVE_DENOMINATOR = getDefineINT("MOVE_DENOMINATOR");

	push	1
	mov	DWORD PTR [esi+6232], eax
	push	OFFSET $SG231733
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6095 : 	m_iSTARTING_DISTANCE_PERCENT = getDefineINT("STARTING_DISTANCE_PERCENT");

	push	1
	push	OFFSET $SG231734
	mov	ecx, esi
	mov	DWORD PTR [esi+6236], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6096 : 	m_iMIN_CIV_STARTING_DISTANCE = getDefineINT("MIN_CIV_STARTING_DISTANCE");

	push	1
	push	OFFSET $SG231735
	mov	ecx, esi
	mov	DWORD PTR [esi+6240], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6097 : 	m_iMIN_CITY_RANGE = getDefineINT("MIN_CITY_RANGE");

	push	1
	push	OFFSET $SG231736
	mov	ecx, esi
	mov	DWORD PTR [esi+6244], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6098 : 	m_iOWNERSHIP_SCORE_DURATION_THRESHOLD = getDefineINT("OWNERSHIP_SCORE_DURATION_THRESHOLD");

	push	1
	push	OFFSET $SG231737
	mov	ecx, esi
	mov	DWORD PTR [esi+6248], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6099 : 	m_iNUM_POLICY_BRANCHES_ALLOWED = getDefineINT("NUM_POLICY_BRANCHES_ALLOWED");

	push	1
	push	OFFSET $SG231738
	mov	ecx, esi
	mov	DWORD PTR [esi+6252], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6100 : 	m_iVICTORY_POINTS_NEEDED_TO_WIN = getDefineINT("VICTORY_POINTS_NEEDED_TO_WIN");

	push	1
	push	OFFSET $SG231739
	mov	ecx, esi
	mov	DWORD PTR [esi+6256], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6101 : 	m_iNUM_VICTORY_POINT_AWARDS = getDefineINT("NUM_VICTORY_POINT_AWARDS");

	push	1
	push	OFFSET $SG231740
	mov	ecx, esi
	mov	DWORD PTR [esi+6260], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6102 : 	m_iNUM_OR_TECH_PREREQS = getDefineINT("NUM_OR_TECH_PREREQS");

	push	1
	push	OFFSET $SG231741
	mov	ecx, esi
	mov	DWORD PTR [esi+6264], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6103 : 	m_iNUM_AND_TECH_PREREQS = getDefineINT("NUM_AND_TECH_PREREQS");

	push	1
	push	OFFSET $SG231742
	mov	ecx, esi
	mov	DWORD PTR [esi+6268], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6104 : 	m_iNUM_UNIT_AND_TECH_PREREQS = getDefineINT("NUM_UNIT_AND_TECH_PREREQS");

	push	1
	push	OFFSET $SG231743
	mov	ecx, esi
	mov	DWORD PTR [esi+6272], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6105 : 	m_iNUM_BUILDING_AND_TECH_PREREQS = getDefineINT("NUM_BUILDING_AND_TECH_PREREQS");

	push	1
	push	OFFSET $SG231744
	mov	ecx, esi
	mov	DWORD PTR [esi+6276], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6106 : 	m_iNUM_BUILDING_RESOURCE_PREREQS = getDefineINT("NUM_BUILDING_RESOURCE_PREREQS");

	push	1
	push	OFFSET $SG231745
	mov	ecx, esi
	mov	DWORD PTR [esi+6280], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6107 : 	m_iBASE_RESEARCH_RATE = getDefineINT("BASE_RESEARCH_RATE");

	push	1
	push	OFFSET $SG231746
	mov	ecx, esi
	mov	DWORD PTR [esi+6284], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6108 : 	m_iMAX_WORLD_WONDERS_PER_CITY = getDefineINT("MAX_WORLD_WONDERS_PER_CITY");

	push	1
	push	OFFSET $SG231747
	mov	ecx, esi
	mov	DWORD PTR [esi+6288], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6109 : 	m_iMAX_TEAM_WONDERS_PER_CITY = getDefineINT("MAX_TEAM_WONDERS_PER_CITY");

	push	1
	push	OFFSET $SG231748
	mov	ecx, esi
	mov	DWORD PTR [esi+6292], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6110 : 	m_iMAX_NATIONAL_WONDERS_PER_CITY = getDefineINT("MAX_NATIONAL_WONDERS_PER_CITY");

	push	1
	push	OFFSET $SG231749
	mov	ecx, esi
	mov	DWORD PTR [esi+6296], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6111 : 	m_iMAX_NATIONAL_WONDERS_PER_CITY_FOR_OCC = getDefineINT("MAX_NATIONAL_WONDERS_PER_CITY_FOR_OCC");

	push	1
	push	OFFSET $SG231750
	mov	ecx, esi
	mov	DWORD PTR [esi+6300], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6112 : 	m_iMAX_BUILDINGS_PER_CITY = getDefineINT("MAX_BUILDINGS_PER_CITY");

	push	1
	push	OFFSET $SG231751
	mov	ecx, esi
	mov	DWORD PTR [esi+6304], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6113 : 	m_iINITIAL_CITY_POPULATION = getDefineINT("INITIAL_CITY_POPULATION");

	push	1
	push	OFFSET $SG231752
	mov	ecx, esi
	mov	DWORD PTR [esi+6308], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6114 : 	m_iBASE_CITY_AIR_STACKING = getDefineINT("BASE_CITY_AIR_STACKING");

	push	1
	push	OFFSET $SG231753
	mov	ecx, esi
	mov	DWORD PTR [esi+6312], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6115 : 	m_iCITY_CAPTURE_POPULATION_PERCENT = getDefineINT("CITY_CAPTURE_POPULATION_PERCENT");

	push	1
	push	OFFSET $SG231754
	mov	ecx, esi
	mov	DWORD PTR [esi+6316], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6116 : 	m_iBASE_CITY_GROWTH_THRESHOLD = getDefineINT("BASE_CITY_GROWTH_THRESHOLD");

	push	1
	push	OFFSET $SG231755
	mov	ecx, esi
	mov	DWORD PTR [esi+6320], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6117 : 	m_iFOOD_CONSUMPTION_PER_POPULATION = getDefineINT("FOOD_CONSUMPTION_PER_POPULATION");

	push	1
	push	OFFSET $SG231756
	mov	ecx, esi
	mov	DWORD PTR [esi+6324], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6118 : 	m_iHAPPINESS_PER_CITY_WITH_STATE_RELIGION = getDefineINT("HAPPINESS_PER_CITY_WITH_STATE_RELIGION");

	push	1
	push	OFFSET $SG231757
	mov	ecx, esi
	mov	DWORD PTR [esi+6328], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6119 : 	m_iHAPPINESS_PER_NATURAL_WONDER = getDefineINT("HAPPINESS_PER_NATURAL_WONDER");

	push	1
	push	OFFSET $SG231758
	mov	ecx, esi
	mov	DWORD PTR [esi+6332], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6120 : 	m_iHAPPINESS_PER_EXTRA_LUXURY = getDefineINT("HAPPINESS_PER_EXTRA_LUXURY");

	push	1
	push	OFFSET $SG231759
	mov	ecx, esi
	mov	DWORD PTR [esi+6336], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6121 : 	m_iUNHAPPINESS_PER_POPULATION = getDefineINT("UNHAPPINESS_PER_POPULATION");

	push	1
	push	OFFSET $SG231760
	mov	ecx, esi
	mov	DWORD PTR [esi+6340], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6122 : 	m_fUNHAPPINESS_PER_OCCUPIED_POPULATION = getDefineFLOAT("UNHAPPINESS_PER_OCCUPIED_POPULATION");

	push	1
	push	OFFSET $SG231761
	mov	ecx, esi
	mov	DWORD PTR [esi+6344], eax
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+6348]

; 6123 : 	m_iUNHAPPINESS_PER_CITY = getDefineINT("UNHAPPINESS_PER_CITY");

	push	1
	push	OFFSET $SG231762
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6124 : 	m_iUNHAPPINESS_PER_CAPTURED_CITY = getDefineINT("UNHAPPINESS_PER_CAPTURED_CITY");

	push	1
	push	OFFSET $SG231763
	mov	ecx, esi
	mov	DWORD PTR [esi+6352], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6125 : 	m_iUNHAPPY_GROWTH_PENALTY = getDefineINT("UNHAPPY_GROWTH_PENALTY");

	push	1
	push	OFFSET $SG231764
	mov	ecx, esi
	mov	DWORD PTR [esi+6356], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6126 : 	m_iVERY_UNHAPPY_GROWTH_PENALTY = getDefineINT("VERY_UNHAPPY_GROWTH_PENALTY");

	push	1
	push	OFFSET $SG231765
	mov	ecx, esi
	mov	DWORD PTR [esi+6360], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+6364], eax

; 6127 : 	m_iVERY_UNHAPPY_CANT_TRAIN_SETTLERS = getDefineINT("VERY_UNHAPPY_CANT_TRAIN_SETTLERS");

	push	1
	push	OFFSET $SG231766
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6128 : 	m_iVERY_UNHAPPY_THRESHOLD = getDefineINT("VERY_UNHAPPY_THRESHOLD");

	push	1
	push	OFFSET $SG231767
	mov	ecx, esi
	mov	DWORD PTR [esi+6368], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6129 : 	m_iSUPER_UNHAPPY_THRESHOLD = getDefineINT("SUPER_UNHAPPY_THRESHOLD");

	push	1
	push	OFFSET $SG231768
	mov	ecx, esi
	mov	DWORD PTR [esi+6372], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6130 : 	m_iUPRISING_COUNTER_MIN = getDefineINT("UPRISING_COUNTER_MIN");

	push	1
	push	OFFSET $SG231769
	mov	ecx, esi
	mov	DWORD PTR [esi+6376], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6131 : 	m_iUPRISING_COUNTER_POSSIBLE = getDefineINT("UPRISING_COUNTER_POSSIBLE");

	push	1
	push	OFFSET $SG231770
	mov	ecx, esi
	mov	DWORD PTR [esi+6380], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6132 : 	m_iUPRISING_NUM_BASE = getDefineINT("UPRISING_NUM_BASE");

	push	1
	push	OFFSET $SG231771
	mov	ecx, esi
	mov	DWORD PTR [esi+6384], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6133 : 	m_iUPRISING_NUM_CITY_COUNT = getDefineINT("UPRISING_NUM_CITY_COUNT");

	push	1
	push	OFFSET $SG231772
	mov	ecx, esi
	mov	DWORD PTR [esi+6388], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6134 : 	m_iREVOLT_COUNTER_MIN = getDefineINT("REVOLT_COUNTER_MIN");

	push	1
	push	OFFSET $SG231773
	mov	ecx, esi
	mov	DWORD PTR [esi+6392], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6135 : 	m_iVERY_UNHAPPY_COMBAT_PENALTY_PER_UNHAPPY = getDefineINT("VERY_UNHAPPY_COMBAT_PENALTY_PER_UNHAPPY");

	push	1
	push	OFFSET $SG231774
	mov	ecx, esi
	mov	DWORD PTR [esi+6396], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6136 : 	m_iVERY_UNHAPPY_MAX_COMBAT_PENALTY = getDefineINT("VERY_UNHAPPY_MAX_COMBAT_PENALTY");

	push	1
	push	OFFSET $SG231775
	mov	ecx, esi
	mov	DWORD PTR [esi+6400], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6137 : 	m_iSTRATEGIC_RESOURCE_EXHAUSTED_PENALTY = getDefineINT("STRATEGIC_RESOURCE_EXHAUSTED_PENALTY");

	push	1
	push	OFFSET $SG231776
	mov	ecx, esi
	mov	DWORD PTR [esi+6404], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6138 : 	m_iVERY_UNHAPPY_PRODUCTION_PENALTY_PER_UNHAPPY = getDefineINT("VERY_UNHAPPY_PRODUCTION_PENALTY_PER_UNHAPPY");

	push	1
	push	OFFSET $SG231777
	mov	ecx, esi
	mov	DWORD PTR [esi+6408], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6139 : 	m_iVERY_UNHAPPY_MAX_PRODUCTION_PENALTY = getDefineINT("VERY_UNHAPPY_MAX_PRODUCTION_PENALTY");

	push	1
	push	OFFSET $SG231778
	mov	ecx, esi
	mov	DWORD PTR [esi+6412], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6140 : 	m_iVERY_UNHAPPY_GOLD_PENALTY_PER_UNHAPPY = getDefineINT("VERY_UNHAPPY_GOLD_PENALTY_PER_UNHAPPY");

	push	1
	push	OFFSET $SG231779
	mov	ecx, esi
	mov	DWORD PTR [esi+6416], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6141 : 	m_iVERY_UNHAPPY_MAX_GOLD_PENALTY = getDefineINT("VERY_UNHAPPY_MAX_GOLD_PENALTY");

	push	1
	push	OFFSET $SG231780
	mov	ecx, esi
	mov	DWORD PTR [esi+6420], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6142 : 	m_iWLTKD_GROWTH_MULTIPLIER = getDefineINT("WLTKD_GROWTH_MULTIPLIER");

	push	1
	push	OFFSET $SG231781
	mov	ecx, esi
	mov	DWORD PTR [esi+6424], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+6428], eax

; 6143 : 	m_iINDUSTRIAL_ROUTE_PRODUCTION_MOD = getDefineINT("INDUSTRIAL_ROUTE_PRODUCTION_MOD");

	push	1
	push	OFFSET $SG231782
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6144 : 	m_iRESOURCE_DEMAND_COUNTDOWN_BASE = getDefineINT("RESOURCE_DEMAND_COUNTDOWN_BASE");

	push	1
	push	OFFSET $SG231783
	mov	ecx, esi
	mov	DWORD PTR [esi+6432], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6145 : 	m_iRESOURCE_DEMAND_COUNTDOWN_CAPITAL_ADD = getDefineINT("RESOURCE_DEMAND_COUNTDOWN_CAPITAL_ADD");

	push	1
	push	OFFSET $SG231784
	mov	ecx, esi
	mov	DWORD PTR [esi+6436], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6146 : 	m_iRESOURCE_DEMAND_COUNTDOWN_RAND = getDefineINT("RESOURCE_DEMAND_COUNTDOWN_RAND");

	push	1
	push	OFFSET $SG231785
	mov	ecx, esi
	mov	DWORD PTR [esi+6440], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6147 : 	m_iNEW_HURRY_MODIFIER = getDefineINT("NEW_HURRY_MODIFIER");

	push	1
	push	OFFSET $SG231786
	mov	ecx, esi
	mov	DWORD PTR [esi+6444], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6148 : 	m_iGREAT_GENERAL_RANGE = getDefineINT("GREAT_GENERAL_RANGE");

	push	1
	push	OFFSET $SG231787
	mov	ecx, esi
	mov	DWORD PTR [esi+6448], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6149 : 	m_iGREAT_GENERAL_STRENGTH_MOD = getDefineINT("GREAT_GENERAL_STRENGTH_MOD");

	push	1
	push	OFFSET $SG231788
	mov	ecx, esi
	mov	DWORD PTR [esi+6452], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6150 : 	m_iBONUS_PER_ADJACENT_FRIEND = getDefineINT("BONUS_PER_ADJACENT_FRIEND");

	push	1
	push	OFFSET $SG231789
	mov	ecx, esi
	mov	DWORD PTR [esi+6456], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6151 : 	m_iPOLICY_ATTACK_BONUS_MOD = getDefineINT("POLICY_ATTACK_BONUS_MOD");

	push	1
	push	OFFSET $SG231790
	mov	ecx, esi
	mov	DWORD PTR [esi+6460], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6152 : 	m_iCONSCRIPT_MIN_CITY_POPULATION = getDefineINT("CONSCRIPT_MIN_CITY_POPULATION");

	push	1
	push	OFFSET $SG231791
	mov	ecx, esi
	mov	DWORD PTR [esi+6464], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6153 : 	m_iCONSCRIPT_POPULATION_PER_COST = getDefineINT("CONSCRIPT_POPULATION_PER_COST");

	push	1
	push	OFFSET $SG231792
	mov	ecx, esi
	mov	DWORD PTR [esi+6468], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6154 : 	m_iMIN_TIMER_UNIT_DOUBLE_MOVES = getDefineINT("MIN_TIMER_UNIT_DOUBLE_MOVES");

	push	1
	push	OFFSET $SG231793
	mov	ecx, esi
	mov	DWORD PTR [esi+6472], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6155 : 	m_iCOMBAT_DAMAGE = getDefineINT("COMBAT_DAMAGE");

	push	1
	push	OFFSET $SG231794
	mov	ecx, esi
	mov	DWORD PTR [esi+6476], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6156 : 	m_iNONCOMBAT_UNIT_RANGED_DAMAGE = getDefineINT("NONCOMBAT_UNIT_RANGED_DAMAGE");

	push	1
	push	OFFSET $SG231795
	mov	ecx, esi
	mov	DWORD PTR [esi+6480], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6157 : 	m_iNAVAL_COMBAT_DEFENDER_STRENGTH_MULTIPLIER = getDefineINT("NAVAL_COMBAT_DEFENDER_STRENGTH_MULTIPLIER");

	push	1
	push	OFFSET $SG231796
	mov	ecx, esi
	mov	DWORD PTR [esi+6484], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6158 : 	m_iLAKE_PLOT_RAND = getDefineINT("LAKE_PLOT_RAND");

	push	1
	push	OFFSET $SG231797
	mov	ecx, esi
	mov	DWORD PTR [esi+6488], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6159 : 	m_iPLOTS_PER_RIVER_EDGE = getDefineINT("PLOTS_PER_RIVER_EDGE");

	push	1
	mov	DWORD PTR [esi+6492], eax
	push	OFFSET $SG231798
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6160 : 	m_iRIVER_SOURCE_MIN_RIVER_RANGE = getDefineINT("RIVER_SOURCE_MIN_RIVER_RANGE");

	push	1
	push	OFFSET $SG231799
	mov	ecx, esi
	mov	DWORD PTR [esi+6496], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6161 : 	m_iRIVER_SOURCE_MIN_SEAWATER_RANGE = getDefineINT("RIVER_SOURCE_MIN_SEAWATER_RANGE");

	push	1
	push	OFFSET $SG231800
	mov	ecx, esi
	mov	DWORD PTR [esi+6500], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6162 : 	m_iLAKE_MAX_AREA_SIZE = getDefineINT("LAKE_MAX_AREA_SIZE");

	push	1
	push	OFFSET $SG231801
	mov	ecx, esi
	mov	DWORD PTR [esi+6504], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6163 : 	m_iINITIAL_GOLD_PER_UNIT_TIMES_100 = getDefineINT("INITIAL_GOLD_PER_UNIT_TIMES_100");

	push	1
	push	OFFSET $SG231802
	mov	ecx, esi
	mov	DWORD PTR [esi+6508], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6164 : 	m_iINITIAL_FREE_OUTSIDE_UNITS = getDefineINT("INITIAL_FREE_OUTSIDE_UNITS");

	push	1
	push	OFFSET $SG231803
	mov	ecx, esi
	mov	DWORD PTR [esi+6512], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6165 : 	m_iINITIAL_OUTSIDE_UNIT_GOLD_PERCENT = getDefineINT("INITIAL_OUTSIDE_UNIT_GOLD_PERCENT");

	push	1
	push	OFFSET $SG231804
	mov	ecx, esi
	mov	DWORD PTR [esi+6516], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6166 : 	m_iUNIT_MAINTENANCE_GAME_MULTIPLIER = getDefineINT("UNIT_MAINTENANCE_GAME_MULTIPLIER");

	push	1
	push	OFFSET $SG231805
	mov	ecx, esi
	mov	DWORD PTR [esi+6520], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6167 : 	m_iUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR = getDefineINT("UNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR");

	push	1
	push	OFFSET $SG231806
	mov	ecx, esi
	mov	DWORD PTR [esi+6524], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6168 : 	m_iFREE_UNIT_HAPPINESS = getDefineINT("FREE_UNIT_HAPPINESS");

	push	1
	push	OFFSET $SG231807
	mov	ecx, esi
	mov	DWORD PTR [esi+6528], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6169 : 	m_iTRADE_ROUTE_BASE_GOLD = getDefineINT("TRADE_ROUTE_BASE_GOLD");

	push	1
	push	OFFSET $SG231808
	mov	ecx, esi
	mov	DWORD PTR [esi+6532], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6170 : 	m_iTRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER = getDefineINT("TRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER");

	push	1
	push	OFFSET $SG231809
	mov	ecx, esi
	mov	DWORD PTR [esi+6536], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6171 : 	m_iTRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER = getDefineINT("TRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER");

	push	1
	push	OFFSET $SG231810
	mov	ecx, esi
	mov	DWORD PTR [esi+6540], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6172 : 	m_iDEFICIT_UNIT_DISBANDING_THRESHOLD = getDefineINT("DEFICIT_UNIT_DISBANDING_THRESHOLD");

	push	1
	push	OFFSET $SG231811
	mov	ecx, esi
	mov	DWORD PTR [esi+6544], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6173 : 	m_iGOLDEN_AGE_BASE_THRESHOLD_HAPPINESS = getDefineINT("GOLDEN_AGE_BASE_THRESHOLD_HAPPINESS");

	push	1
	push	OFFSET $SG231812
	mov	ecx, esi
	mov	DWORD PTR [esi+6548], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6174 : 	m_fGOLDEN_AGE_THRESHOLD_CITY_MULTIPLIER = getDefineFLOAT("GOLDEN_AGE_THRESHOLD_CITY_MULTIPLIER");

	push	1
	push	OFFSET $SG231813
	mov	ecx, esi
	mov	DWORD PTR [esi+6552], eax
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+6556]

; 6175 : 	m_iGOLDEN_AGE_EACH_GA_ADDITIONAL_HAPPINESS = getDefineINT("GOLDEN_AGE_EACH_GA_ADDITIONAL_HAPPINESS");

	push	1
	push	OFFSET $SG231814
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6176 : 	m_iGOLDEN_AGE_VISIBLE_THRESHOLD_DIVISOR = getDefineINT("GOLDEN_AGE_VISIBLE_THRESHOLD_DIVISOR");

	push	1
	push	OFFSET $SG231815
	mov	ecx, esi
	mov	DWORD PTR [esi+6560], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6177 : 	m_iBASE_GOLDEN_AGE_UNITS = getDefineINT("BASE_GOLDEN_AGE_UNITS");

	push	1
	push	OFFSET $SG231816
	mov	ecx, esi
	mov	DWORD PTR [esi+6564], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6178 : 	m_iGOLDEN_AGE_UNITS_MULTIPLIER = getDefineINT("GOLDEN_AGE_UNITS_MULTIPLIER");

	push	1
	push	OFFSET $SG231817
	mov	ecx, esi
	mov	DWORD PTR [esi+6568], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6179 : 	m_iGOLDEN_AGE_LENGTH = getDefineINT("GOLDEN_AGE_LENGTH");

	push	1
	push	OFFSET $SG231818
	mov	ecx, esi
	mov	DWORD PTR [esi+6572], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6180 : 	m_iGOLDEN_AGE_GREAT_PEOPLE_MODIFIER = getDefineINT("GOLDEN_AGE_GREAT_PEOPLE_MODIFIER");

	push	1
	push	OFFSET $SG231819
	mov	ecx, esi
	mov	DWORD PTR [esi+6576], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6181 : 	m_iMIN_UNIT_GOLDEN_AGE_TURNS = getDefineINT("MIN_UNIT_GOLDEN_AGE_TURNS");

	push	1
	push	OFFSET $SG231820
	mov	ecx, esi
	mov	DWORD PTR [esi+6580], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6182 : 	m_iGOLDEN_AGE_CULTURE_MODIFIER = getDefineINT("GOLDEN_AGE_CULTURE_MODIFIER");

	push	1
	push	OFFSET $SG231821
	mov	ecx, esi
	mov	DWORD PTR [esi+6584], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6183 : 	m_iHILLS_EXTRA_MOVEMENT = getDefineINT("HILLS_EXTRA_MOVEMENT");

	push	1
	push	OFFSET $SG231822
	mov	ecx, esi
	mov	DWORD PTR [esi+6588], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6184 : 	m_iRIVER_EXTRA_MOVEMENT = getDefineINT("RIVER_EXTRA_MOVEMENT");

	push	1
	push	OFFSET $SG231823
	mov	ecx, esi
	mov	DWORD PTR [esi+6592], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6185 : 	m_iFEATURE_GROWTH_MODIFIER = getDefineINT("FEATURE_GROWTH_MODIFIER");

	push	1
	push	OFFSET $SG231824
	mov	ecx, esi
	mov	DWORD PTR [esi+6596], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6186 : 	m_iROUTE_FEATURE_GROWTH_MODIFIER = getDefineINT("ROUTE_FEATURE_GROWTH_MODIFIER");

	push	1
	push	OFFSET $SG231825
	mov	ecx, esi
	mov	DWORD PTR [esi+6600], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6187 : 	m_iEXTRA_YIELD = getDefineINT("EXTRA_YIELD");

	push	1
	push	OFFSET $SG231826
	mov	ecx, esi
	mov	DWORD PTR [esi+6604], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6188 : 	m_iFORTIFY_MODIFIER_PER_TURN = getDefineINT("FORTIFY_MODIFIER_PER_TURN");

	push	1
	push	OFFSET $SG231827
	mov	ecx, esi
	mov	DWORD PTR [esi+6608], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6189 : 	m_iMAX_FORTIFY_TURNS = getDefineINT("MAX_FORTIFY_TURNS");

	push	1
	push	OFFSET $SG231828
	mov	ecx, esi
	mov	DWORD PTR [esi+6612], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6190 : 	m_iNUKE_FALLOUT_PROB = getDefineINT("NUKE_FALLOUT_PROB");

	push	1
	push	OFFSET $SG231829
	mov	ecx, esi
	mov	DWORD PTR [esi+6616], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6191 : 	m_iNUKE_UNIT_DAMAGE_BASE = getDefineINT("NUKE_UNIT_DAMAGE_BASE");

	push	1
	push	OFFSET $SG231830
	mov	ecx, esi
	mov	DWORD PTR [esi+6620], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6192 : 	m_iNUKE_UNIT_DAMAGE_RAND_1 = getDefineINT("NUKE_UNIT_DAMAGE_RAND_1");

	push	1
	push	OFFSET $SG231831
	mov	ecx, esi
	mov	DWORD PTR [esi+6624], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6193 : 	m_iNUKE_UNIT_DAMAGE_RAND_2 = getDefineINT("NUKE_UNIT_DAMAGE_RAND_2");

	push	1
	push	OFFSET $SG231832
	mov	ecx, esi
	mov	DWORD PTR [esi+6628], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6194 : 	m_iNUKE_NON_COMBAT_DEATH_THRESHOLD = getDefineINT("NUKE_NON_COMBAT_DEATH_THRESHOLD");

	push	1
	push	OFFSET $SG231833
	mov	ecx, esi
	mov	DWORD PTR [esi+6632], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6195 : 	m_iNUKE_LEVEL1_POPULATION_DEATH_BASE = getDefineINT("NUKE_LEVEL1_POPULATION_DEATH_BASE");

	push	1
	push	OFFSET $SG231834
	mov	ecx, esi
	mov	DWORD PTR [esi+6636], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6196 : 	m_iNUKE_LEVEL1_POPULATION_DEATH_RAND_1 = getDefineINT("NUKE_LEVEL1_POPULATION_DEATH_RAND_1");

	push	1
	push	OFFSET $SG231835
	mov	ecx, esi
	mov	DWORD PTR [esi+6640], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6197 : 	m_iNUKE_LEVEL1_POPULATION_DEATH_RAND_2 = getDefineINT("NUKE_LEVEL1_POPULATION_DEATH_RAND_2");

	push	1
	push	OFFSET $SG231836
	mov	ecx, esi
	mov	DWORD PTR [esi+6644], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6198 : 	m_iNUKE_LEVEL2_POPULATION_DEATH_BASE = getDefineINT("NUKE_LEVEL2_POPULATION_DEATH_BASE");

	push	1
	push	OFFSET $SG231837
	mov	ecx, esi
	mov	DWORD PTR [esi+6648], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6199 : 	m_iNUKE_LEVEL2_POPULATION_DEATH_RAND_1 = getDefineINT("NUKE_LEVEL2_POPULATION_DEATH_RAND_1");

	push	1
	push	OFFSET $SG231838
	mov	ecx, esi
	mov	DWORD PTR [esi+6652], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6200 : 	m_iNUKE_LEVEL2_POPULATION_DEATH_RAND_2 = getDefineINT("NUKE_LEVEL2_POPULATION_DEATH_RAND_2");

	push	1
	push	OFFSET $SG231839
	mov	ecx, esi
	mov	DWORD PTR [esi+6656], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6201 : 	m_iNUKE_LEVEL2_ELIM_POPULATION_THRESHOLD = getDefineINT("NUKE_LEVEL2_ELIM_POPULATION_THRESHOLD");

	push	1
	push	OFFSET $SG231840
	mov	ecx, esi
	mov	DWORD PTR [esi+6660], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6202 : 	m_iNUKE_CITY_HIT_POINT_DAMAGE = getDefineINT("NUKE_CITY_HIT_POINT_DAMAGE");

	push	1
	push	OFFSET $SG231841
	mov	ecx, esi
	mov	DWORD PTR [esi+6664], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6203 : 	m_iNUKE_BLAST_RADIUS = getDefineINT("NUKE_BLAST_RADIUS");

	push	1
	push	OFFSET $SG231842
	mov	ecx, esi
	mov	DWORD PTR [esi+6668], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6204 : 	m_iTECH_COST_EXTRA_TEAM_MEMBER_MODIFIER = getDefineINT("TECH_COST_EXTRA_TEAM_MEMBER_MODIFIER");

	push	1
	push	OFFSET $SG231843
	mov	ecx, esi
	mov	DWORD PTR [esi+6672], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6205 : 	m_iTECH_COST_TOTAL_KNOWN_TEAM_MODIFIER = getDefineINT("TECH_COST_TOTAL_KNOWN_TEAM_MODIFIER");

	push	1
	push	OFFSET $SG231844
	mov	ecx, esi
	mov	DWORD PTR [esi+6676], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6206 : 	m_iTECH_COST_KNOWN_PREREQ_MODIFIER = getDefineINT("TECH_COST_KNOWN_PREREQ_MODIFIER");

	push	1
	push	OFFSET $SG231845
	mov	ecx, esi
	mov	DWORD PTR [esi+6680], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6207 : 	m_iPEACE_TREATY_LENGTH = getDefineINT("PEACE_TREATY_LENGTH");

	push	1
	push	OFFSET $SG231846
	mov	ecx, esi
	mov	DWORD PTR [esi+6684], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+6688], eax

; 6208 : 	m_iCOOP_WAR_LOCKED_LENGTH = getDefineINT("COOP_WAR_LOCKED_LENGTH");

	push	1
	push	OFFSET $SG231847
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6209 : 	m_iBASE_FEATURE_PRODUCTION_PERCENT = getDefineINT("BASE_FEATURE_PRODUCTION_PERCENT");

	push	1
	push	OFFSET $SG231848
	mov	ecx, esi
	mov	DWORD PTR [esi+6692], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6210 : 	m_iFEATURE_PRODUCTION_PERCENT_MULTIPLIER = getDefineINT("FEATURE_PRODUCTION_PERCENT_MULTIPLIER");

	push	1
	push	OFFSET $SG231849
	mov	ecx, esi
	mov	DWORD PTR [esi+6696], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6211 : 	m_iDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT = getDefineINT("DIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT");

	push	1
	push	OFFSET $SG231850
	mov	ecx, esi
	mov	DWORD PTR [esi+6700], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6212 : 	m_iDEFAULT_WAR_VALUE_FOR_UNIT = getDefineINT("DEFAULT_WAR_VALUE_FOR_UNIT");

	push	1
	push	OFFSET $SG231851
	mov	ecx, esi
	mov	DWORD PTR [esi+6704], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6213 : 	m_iUNIT_PRODUCTION_PERCENT = getDefineINT("UNIT_PRODUCTION_PERCENT");

	push	1
	push	OFFSET $SG231852
	mov	ecx, esi
	mov	DWORD PTR [esi+6708], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6214 : 	m_iMAX_UNIT_SUPPLY_PRODMOD = getDefineINT("MAX_UNIT_SUPPLY_PRODMOD");

	push	1
	push	OFFSET $SG231853
	mov	ecx, esi
	mov	DWORD PTR [esi+6712], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6215 : 	m_iBUILDING_PRODUCTION_PERCENT = getDefineINT("BUILDING_PRODUCTION_PERCENT");

	push	1
	push	OFFSET $SG231854
	mov	ecx, esi
	mov	DWORD PTR [esi+6716], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6216 : 	m_iPROJECT_PRODUCTION_PERCENT = getDefineINT("PROJECT_PRODUCTION_PERCENT");

	push	1
	push	OFFSET $SG231855
	mov	ecx, esi
	mov	DWORD PTR [esi+6720], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6217 : 	m_iMAXED_UNIT_GOLD_PERCENT = getDefineINT("MAXED_UNIT_GOLD_PERCENT");

	push	1
	push	OFFSET $SG231856
	mov	ecx, esi
	mov	DWORD PTR [esi+6724], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6218 : 	m_iMAXED_BUILDING_GOLD_PERCENT = getDefineINT("MAXED_BUILDING_GOLD_PERCENT");

	push	1
	push	OFFSET $SG231857
	mov	ecx, esi
	mov	DWORD PTR [esi+6728], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6219 : 	m_iMAXED_PROJECT_GOLD_PERCENT = getDefineINT("MAXED_PROJECT_GOLD_PERCENT");

	push	1
	push	OFFSET $SG231858
	mov	ecx, esi
	mov	DWORD PTR [esi+6732], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6220 : 	m_iMAX_CITY_DEFENSE_DAMAGE = getDefineINT("MAX_CITY_DEFENSE_DAMAGE");

	push	1
	push	OFFSET $SG231859
	mov	ecx, esi
	mov	DWORD PTR [esi+6736], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6221 : 	m_iCIRCUMNAVIGATE_FREE_MOVES = getDefineINT("CIRCUMNAVIGATE_FREE_MOVES");

	push	1
	push	OFFSET $SG231860
	mov	ecx, esi
	mov	DWORD PTR [esi+6740], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6222 : 	m_iBASE_CAPTURE_GOLD = getDefineINT("BASE_CAPTURE_GOLD");

	push	1
	push	OFFSET $SG231861
	mov	ecx, esi
	mov	DWORD PTR [esi+6744], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6223 : 	m_iCAPTURE_GOLD_PER_POPULATION = getDefineINT("CAPTURE_GOLD_PER_POPULATION");

	push	1
	push	OFFSET $SG231862
	mov	ecx, esi
	mov	DWORD PTR [esi+6748], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+6752], eax

; 6224 : 	m_iCAPTURE_GOLD_RAND1 = getDefineINT("CAPTURE_GOLD_RAND1");

	push	1
	push	OFFSET $SG231863
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6225 : 	m_iCAPTURE_GOLD_RAND2 = getDefineINT("CAPTURE_GOLD_RAND2");

	push	1
	push	OFFSET $SG231864
	mov	ecx, esi
	mov	DWORD PTR [esi+6756], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6226 : 	m_iCAPTURE_GOLD_MAX_TURNS = getDefineINT("CAPTURE_GOLD_MAX_TURNS");

	push	1
	push	OFFSET $SG231865
	mov	ecx, esi
	mov	DWORD PTR [esi+6760], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6227 : 	m_iBARBARIAN_CITY_ATTACK_MODIFIER = getDefineINT("BARBARIAN_CITY_ATTACK_MODIFIER");

	push	1
	push	OFFSET $SG231866
	mov	ecx, esi
	mov	DWORD PTR [esi+6764], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6228 : 	m_iBUILDING_PRODUCTION_DECAY_TIME = getDefineINT("BUILDING_PRODUCTION_DECAY_TIME");

	push	1
	push	OFFSET $SG231867
	mov	ecx, esi
	mov	DWORD PTR [esi+6768], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6229 : 	m_iBUILDING_PRODUCTION_DECAY_PERCENT = getDefineINT("BUILDING_PRODUCTION_DECAY_PERCENT");

	push	1
	push	OFFSET $SG231868
	mov	ecx, esi
	mov	DWORD PTR [esi+6772], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6230 : 	m_iUNIT_PRODUCTION_DECAY_TIME = getDefineINT("UNIT_PRODUCTION_DECAY_TIME");

	push	1
	push	OFFSET $SG231869
	mov	ecx, esi
	mov	DWORD PTR [esi+6776], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6231 : 	m_iUNIT_PRODUCTION_DECAY_PERCENT = getDefineINT("UNIT_PRODUCTION_DECAY_PERCENT");

	push	1
	push	OFFSET $SG231870
	mov	ecx, esi
	mov	DWORD PTR [esi+6780], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6232 : 	m_iBASE_UNIT_UPGRADE_COST = getDefineINT("BASE_UNIT_UPGRADE_COST");

	push	1
	push	OFFSET $SG231871
	mov	ecx, esi
	mov	DWORD PTR [esi+6784], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6233 : 	m_iUNIT_UPGRADE_COST_PER_PRODUCTION = getDefineINT("UNIT_UPGRADE_COST_PER_PRODUCTION");

	push	1
	push	OFFSET $SG231872
	mov	ecx, esi
	mov	DWORD PTR [esi+6788], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6234 : 	m_iUNIT_UPGRADE_COST_VISIBLE_DIVISOR = getDefineINT("UNIT_UPGRADE_COST_VISIBLE_DIVISOR");

	push	1
	push	OFFSET $SG231873
	mov	ecx, esi
	mov	DWORD PTR [esi+6792], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6235 : 	m_iUNIT_UPGRADE_COST_DISCOUNT_MAX = getDefineINT("UNIT_UPGRADE_COST_DISCOUNT_MAX");

	push	1
	push	OFFSET $SG231874
	mov	ecx, esi
	mov	DWORD PTR [esi+6796], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6236 : 	m_iWAR_SUCCESS_UNIT_CAPTURING = getDefineINT("WAR_SUCCESS_UNIT_CAPTURING");

	push	1
	push	OFFSET $SG231875
	mov	ecx, esi
	mov	DWORD PTR [esi+6800], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6237 : 	m_iWAR_SUCCESS_CITY_CAPTURING = getDefineINT("WAR_SUCCESS_CITY_CAPTURING");

	push	1
	push	OFFSET $SG231876
	mov	ecx, esi
	mov	DWORD PTR [esi+6804], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6238 : 	m_iDIPLO_VOTE_SECRETARY_GENERAL_INTERVAL = getDefineINT("DIPLO_VOTE_SECRETARY_GENERAL_INTERVAL");

	push	1
	push	OFFSET $SG231877
	mov	ecx, esi
	mov	DWORD PTR [esi+6808], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6239 : 	m_iTEAM_VOTE_MIN_CANDIDATES = getDefineINT("TEAM_VOTE_MIN_CANDIDATES");

	push	1
	push	OFFSET $SG231878
	mov	ecx, esi
	mov	DWORD PTR [esi+6812], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6240 : 	m_iRESEARCH_AGREEMENT_TIMER = getDefineINT("RESEARCH_AGREEMENT_TIMER");

	push	1
	mov	DWORD PTR [esi+6816], eax
	push	OFFSET $SG231879
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6241 : 	m_iRESEARCH_AGREEMENT_BOOST_DIVISOR = getDefineINT("RESEARCH_AGREEMENT_BOOST_DIVISOR");

	push	1
	push	OFFSET $SG231880
	mov	ecx, esi
	mov	DWORD PTR [esi+6820], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6242 : 	m_iSCORE_POPULATION_FACTOR = getDefineINT("SCORE_POPULATION_FACTOR");

	push	1
	push	OFFSET $SG231881
	mov	ecx, esi
	mov	DWORD PTR [esi+6824], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6243 : 	m_iSCORE_LAND_FACTOR = getDefineINT("SCORE_LAND_FACTOR");

	push	1
	push	OFFSET $SG231882
	mov	ecx, esi
	mov	DWORD PTR [esi+6828], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6244 : 	m_iSCORE_WONDER_FACTOR = getDefineINT("SCORE_WONDER_FACTOR");

	push	1
	push	OFFSET $SG231883
	mov	ecx, esi
	mov	DWORD PTR [esi+6832], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6245 : 	m_iSCORE_TECH_FACTOR = getDefineINT("SCORE_TECH_FACTOR");

	push	1
	push	OFFSET $SG231884
	mov	ecx, esi
	mov	DWORD PTR [esi+6836], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6246 : 	m_iSCORE_FREE_PERCENT = getDefineINT("SCORE_FREE_PERCENT");

	push	1
	push	OFFSET $SG231885
	mov	ecx, esi
	mov	DWORD PTR [esi+6840], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6247 : 	m_iSCORE_VICTORY_PERCENT = getDefineINT("SCORE_VICTORY_PERCENT");

	push	1
	push	OFFSET $SG231886
	mov	ecx, esi
	mov	DWORD PTR [esi+6844], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6248 : 	m_iSCORE_HANDICAP_PERCENT_OFFSET = getDefineINT("SCORE_HANDICAP_PERCENT_OFFSET");

	push	1
	push	OFFSET $SG231887
	mov	ecx, esi
	mov	DWORD PTR [esi+6848], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6249 : 	m_iSCORE_HANDICAP_PERCENT_PER = getDefineINT("SCORE_HANDICAP_PERCENT_PER");

	push	1
	push	OFFSET $SG231888
	mov	ecx, esi
	mov	DWORD PTR [esi+6852], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6250 : 	m_iMINIMAP_RENDER_SIZE = getDefineINT("MINIMAP_RENDER_SIZE");

	push	1
	push	OFFSET $SG231889
	mov	ecx, esi
	mov	DWORD PTR [esi+6856], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6251 : 	m_iMAX_INTERCEPTION_PROBABILITY = getDefineINT("MAX_INTERCEPTION_PROBABILITY");

	push	1
	push	OFFSET $SG231890
	mov	ecx, esi
	mov	DWORD PTR [esi+6860], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6252 : 	m_iMAX_EVASION_PROBABILITY = getDefineINT("MAX_EVASION_PROBABILITY");

	push	1
	push	OFFSET $SG231891
	mov	ecx, esi
	mov	DWORD PTR [esi+6864], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6253 : 	m_iPLAYER_ALWAYS_RAZES_CITIES = getDefineINT("PLAYER_ALWAYS_RAZES_CITIES");

	push	1
	push	OFFSET $SG231892
	mov	ecx, esi
	mov	DWORD PTR [esi+6868], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6254 : 	m_iMIN_WATER_SIZE_FOR_OCEAN = getDefineINT("MIN_WATER_SIZE_FOR_OCEAN");

	push	1
	push	OFFSET $SG231893
	mov	ecx, esi
	mov	DWORD PTR [esi+6872], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6255 : 	m_iCITY_SCREEN_CLICK_WILL_EXIT = getDefineINT("CITY_SCREEN_CLICK_WILL_EXIT");

	push	1
	push	OFFSET $SG231894
	mov	ecx, esi
	mov	DWORD PTR [esi+6876], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6256 : 	m_iWATER_POTENTIAL_CITY_WORK_FOR_AREA = getDefineINT("WATER_POTENTIAL_CITY_WORK_FOR_AREA");

	push	1
	mov	DWORD PTR [esi+6880], eax
	push	OFFSET $SG231895
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6257 : 	m_iLAND_UNITS_CAN_ATTACK_WATER_CITIES = getDefineINT("LAND_UNITS_CAN_ATTACK_WATER_CITIES");

	push	1
	push	OFFSET $SG231896
	mov	ecx, esi
	mov	DWORD PTR [esi+6884], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6258 : 	m_iCITY_MAX_NUM_BUILDINGS = getDefineINT("CITY_MAX_NUM_BUILDINGS");

	push	1
	push	OFFSET $SG231897
	mov	ecx, esi
	mov	DWORD PTR [esi+6888], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6259 : 	m_iCITY_MIN_SIZE_FOR_SETTLERS = getDefineINT("CITY_MIN_SIZE_FOR_SETTLERS");

	push	1
	push	OFFSET $SG231898
	mov	ecx, esi
	mov	DWORD PTR [esi+6892], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6260 : 	m_iRANGED_ATTACKS_USE_MOVES = getDefineINT("RANGED_ATTACKS_USE_MOVES");

	push	1
	push	OFFSET $SG231899
	mov	ecx, esi
	mov	DWORD PTR [esi+6896], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6261 : 	m_iADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES = getDefineINT("ADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES");

	push	1
	push	OFFSET $SG231900
	mov	ecx, esi
	mov	DWORD PTR [esi+6900], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6262 : 	m_iADVANCED_START_MAX_UNITS_PER_CITY = getDefineINT("ADVANCED_START_MAX_UNITS_PER_CITY");

	push	1
	push	OFFSET $SG231901
	mov	ecx, esi
	mov	DWORD PTR [esi+6904], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6263 : 	m_iADVANCED_START_CITY_COST = getDefineINT("ADVANCED_START_CITY_COST");

	push	1
	push	OFFSET $SG231902
	mov	ecx, esi
	mov	DWORD PTR [esi+6908], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6264 : 	m_iADVANCED_START_CITY_COST_INCREASE = getDefineINT("ADVANCED_START_CITY_COST_INCREASE");

	push	1
	push	OFFSET $SG231903
	mov	ecx, esi
	mov	DWORD PTR [esi+6912], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6265 : 	m_iADVANCED_START_POPULATION_COST = getDefineINT("ADVANCED_START_POPULATION_COST");

	push	1
	push	OFFSET $SG231904
	mov	ecx, esi
	mov	DWORD PTR [esi+6916], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6266 : 	m_iADVANCED_START_POPULATION_COST_INCREASE = getDefineINT("ADVANCED_START_POPULATION_COST_INCREASE");

	push	1
	push	OFFSET $SG231905
	mov	ecx, esi
	mov	DWORD PTR [esi+6920], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6267 : 	m_iADVANCED_START_VISIBILITY_COST = getDefineINT("ADVANCED_START_VISIBILITY_COST");

	push	1
	push	OFFSET $SG231906
	mov	ecx, esi
	mov	DWORD PTR [esi+6924], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6268 : 	m_iADVANCED_START_VISIBILITY_COST_INCREASE = getDefineINT("ADVANCED_START_VISIBILITY_COST_INCREASE");

	push	1
	push	OFFSET $SG231907
	mov	ecx, esi
	mov	DWORD PTR [esi+6928], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6269 : 	m_iADVANCED_START_CITY_PLACEMENT_MAX_RANGE = getDefineINT("ADVANCED_START_CITY_PLACEMENT_MAX_RANGE");

	push	1
	push	OFFSET $SG231908
	mov	ecx, esi
	mov	DWORD PTR [esi+6932], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6270 : 	m_iNEW_CITY_BUILDING_VALUE_MODIFIER = getDefineINT("NEW_CITY_BUILDING_VALUE_MODIFIER");

	push	1
	push	OFFSET $SG231909
	mov	ecx, esi
	mov	DWORD PTR [esi+6936], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6271 : 	m_iPATH_DAMAGE_WEIGHT = getDefineINT("PATH_DAMAGE_WEIGHT");

	push	1
	push	OFFSET $SG231910
	mov	ecx, esi
	mov	DWORD PTR [esi+6940], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6272 : 	m_iPUPPET_SCIENCE_MODIFIER = getDefineINT("PUPPET_SCIENCE_MODIFIER");

	push	1
	push	OFFSET $SG231911
	mov	ecx, esi
	mov	DWORD PTR [esi+6944], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6273 : 	m_iPUPPET_CULTURE_MODIFIER = getDefineINT("PUPPET_CULTURE_MODIFIER");

	push	1
	push	OFFSET $SG231912
	mov	ecx, esi
	mov	DWORD PTR [esi+6948], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6274 : 	m_iPUPPET_GOLD_MODIFIER = getDefineINT("PUPPET_GOLD_MODIFIER");

	push	1
	push	OFFSET $SG231913
	mov	ecx, esi
	mov	DWORD PTR [esi+6952], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6275 : 	m_iPUPPET_FAITH_MODIFIER = getDefineINT("PUPPET_FAITH_MODIFIER");

	push	1
	push	OFFSET $SG231914
	mov	ecx, esi
	mov	DWORD PTR [esi+6956], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6276 : 	m_iBASE_POLICY_COST = getDefineINT("BASE_POLICY_COST");

	push	1
	push	OFFSET $SG231915
	mov	ecx, esi
	mov	DWORD PTR [esi+6960], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6277 : 	m_iPOLICY_COST_INCREASE_TO_BE_EXPONENTED = getDefineINT("POLICY_COST_INCREASE_TO_BE_EXPONENTED");

	push	1
	push	OFFSET $SG231916
	mov	ecx, esi
	mov	DWORD PTR [esi+6964], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6278 : 	m_iPOLICY_COST_VISIBLE_DIVISOR = getDefineINT("POLICY_COST_VISIBLE_DIVISOR");

	push	1
	push	OFFSET $SG231917
	mov	ecx, esi
	mov	DWORD PTR [esi+6968], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6279 : 	m_iSWITCH_POLICY_BRANCHES_ANARCHY_TURNS = getDefineINT("SWITCH_POLICY_BRANCHES_ANARCHY_TURNS");

	push	1
	push	OFFSET $SG231918
	mov	ecx, esi
	mov	DWORD PTR [esi+6972], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6280 : 	m_iSWITCH_POLICY_BRANCHES_TENETS_LOST = getDefineINT("SWITCH_POLICY_BRANCHES_TENETS_LOST");

	push	1
	push	OFFSET $SG231919
	mov	ecx, esi
	mov	DWORD PTR [esi+6976], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6281 : 	m_iPOLICY_COST_DISCOUNT_MAX = getDefineINT("POLICY_COST_DISCOUNT_MAX");

	push	1
	push	OFFSET $SG231920
	mov	ecx, esi
	mov	DWORD PTR [esi+6980], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6282 : 	m_iGOLD_PURCHASE_GOLD_PER_PRODUCTION = getDefineINT("GOLD_PURCHASE_GOLD_PER_PRODUCTION");

	push	1
	push	OFFSET $SG231921
	mov	ecx, esi
	mov	DWORD PTR [esi+6984], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6283 : 	m_iGOLD_PURCHASE_VISIBLE_DIVISOR = getDefineINT("GOLD_PURCHASE_VISIBLE_DIVISOR");

	push	1
	push	OFFSET $SG231922
	mov	ecx, esi
	mov	DWORD PTR [esi+6988], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6284 : 	m_iPROJECT_PURCHASING_DISABLED = getDefineINT("PROJECT_PURCHASING_DISABLED");

	push	1
	push	OFFSET $SG231923
	mov	ecx, esi
	mov	DWORD PTR [esi+6992], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6285 : 	m_iINFLUENCE_MOUNTAIN_COST = getDefineINT("INFLUENCE_MOUNTAIN_COST");

	push	1
	push	OFFSET $SG231924
	mov	ecx, esi
	mov	DWORD PTR [esi+6996], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6286 : 	m_iINFLUENCE_HILL_COST = getDefineINT("INFLUENCE_HILL_COST");

	push	1
	push	OFFSET $SG231925
	mov	ecx, esi
	mov	DWORD PTR [esi+7000], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6287 : 	m_iINFLUENCE_RIVER_COST = getDefineINT("INFLUENCE_RIVER_COST");

	push	1
	push	OFFSET $SG231926
	mov	ecx, esi
	mov	DWORD PTR [esi+7004], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6288 : 	m_iUSE_FIRST_RING_INFLUENCE_TERRAIN_COST = getDefineINT("USE_FIRST_RING_INFLUENCE_TERRAIN_COST");

	push	1
	push	OFFSET $SG231927
	mov	ecx, esi
	mov	DWORD PTR [esi+7008], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+7012], eax

; 6289 : 	m_iNUM_RESOURCE_QUANTITY_TYPES = getDefineINT("NUM_RESOURCE_QUANTITY_TYPES");

	push	1
	push	OFFSET $SG231928
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6290 : 	m_iSPECIALISTS_DIVERT_POPULATION_ENABLED = getDefineINT("SPECIALISTS_DIVERT_POPULATION_ENABLED");

	push	1
	push	OFFSET $SG231929
	mov	ecx, esi
	mov	DWORD PTR [esi+7016], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6291 : 	m_iSCIENCE_PER_POPULATION = getDefineINT("SCIENCE_PER_POPULATION");

	push	1
	push	OFFSET $SG231930
	mov	ecx, esi
	mov	DWORD PTR [esi+7020], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6292 : 	m_iRESEARCH_AGREEMENT_MOD = getDefineINT("RESEARCH_AGREEMENT_MOD");

	push	1
	push	OFFSET $SG231931
	mov	ecx, esi
	mov	DWORD PTR [esi+7024], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6293 : 	m_iBARBARIAN_CAMP_FIRST_TURN_PERCENT_OF_TARGET_TO_ADD = getDefineINT("BARBARIAN_CAMP_FIRST_TURN_PERCENT_OF_TARGET_TO_ADD");

	push	1
	push	OFFSET $SG231932
	mov	ecx, esi
	mov	DWORD PTR [esi+7028], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6294 : 	m_iBARBARIAN_CAMP_ODDS_OF_NEW_CAMP_SPAWNING = getDefineINT("BARBARIAN_CAMP_ODDS_OF_NEW_CAMP_SPAWNING");

	push	1
	push	OFFSET $SG231933
	mov	ecx, esi
	mov	DWORD PTR [esi+7032], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6295 : 	m_iBARBARIAN_CAMP_MINIMUM_DISTANCE_CAPITAL = getDefineINT("BARBARIAN_CAMP_MINIMUM_DISTANCE_CAPITAL");

	push	1
	push	OFFSET $SG231934
	mov	ecx, esi
	mov	DWORD PTR [esi+7036], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6296 : 	m_iBARBARIAN_CAMP_MINIMUM_DISTANCE_ANOTHER_CAMP = getDefineINT("BARBARIAN_CAMP_MINIMUM_DISTANCE_ANOTHER_CAMP");

	push	1
	push	OFFSET $SG231935
	mov	ecx, esi
	mov	DWORD PTR [esi+7040], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6297 : 	m_iBARBARIAN_CAMP_COASTAL_SPAWN_ROLL = getDefineINT("BARBARIAN_CAMP_COASTAL_SPAWN_ROLL");

	push	1
	push	OFFSET $SG231936
	mov	ecx, esi
	mov	DWORD PTR [esi+7044], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6298 : 	m_iBARBARIAN_EXTRA_RAGING_UNIT_SPAWN_CHANCE = getDefineINT("BARBARIAN_EXTRA_RAGING_UNIT_SPAWN_CHANCE");

	push	1
	push	OFFSET $SG231937
	mov	ecx, esi
	mov	DWORD PTR [esi+7048], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6299 : 	m_iBARBARIAN_NAVAL_UNIT_START_TURN_SPAWN = getDefineINT("BARBARIAN_NAVAL_UNIT_START_TURN_SPAWN");

	push	1
	push	OFFSET $SG231938
	mov	ecx, esi
	mov	DWORD PTR [esi+7052], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6300 : 	m_iMAX_BARBARIANS_FROM_CAMP_NEARBY = getDefineINT("MAX_BARBARIANS_FROM_CAMP_NEARBY");

	push	1
	push	OFFSET $SG231939
	mov	ecx, esi
	mov	DWORD PTR [esi+7056], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6301 : 	m_iMAX_BARBARIANS_FROM_CAMP_NEARBY_RANGE = getDefineINT("MAX_BARBARIANS_FROM_CAMP_NEARBY_RANGE");

	push	1
	push	OFFSET $SG231940
	mov	ecx, esi
	mov	DWORD PTR [esi+7060], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6302 : 	m_iGOLD_FROM_BARBARIAN_CONVERSION = getDefineINT("GOLD_FROM_BARBARIAN_CONVERSION");

	push	1
	push	OFFSET $SG231941
	mov	ecx, esi
	mov	DWORD PTR [esi+7064], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6303 : 	m_iBARBARIAN_CITY_GOLD_RANSOM = getDefineINT("BARBARIAN_CITY_GOLD_RANSOM");

	push	1
	push	OFFSET $SG231942
	mov	ecx, esi
	mov	DWORD PTR [esi+7068], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6304 : 	m_iBARBARIAN_UNIT_GOLD_RANSOM = getDefineINT("BARBARIAN_UNIT_GOLD_RANSOM");

	push	1
	push	OFFSET $SG231943
	mov	ecx, esi
	mov	DWORD PTR [esi+7072], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+7076], eax

; 6305 : 	m_iEMBARKED_UNIT_MOVEMENT = getDefineINT("EMBARKED_UNIT_MOVEMENT");

	push	1
	push	OFFSET $SG231944
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6306 : 	m_iEMBARKED_VISIBILITY_RANGE = getDefineINT("EMBARKED_VISIBILITY_RANGE");

	push	1
	push	OFFSET $SG231945
	mov	ecx, esi
	mov	DWORD PTR [esi+7080], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6307 : 	m_iDEFAULT_MAX_NUM_BUILDERS = getDefineINT("DEFAULT_MAX_NUM_BUILDERS");

	push	1
	push	OFFSET $SG231946
	mov	ecx, esi
	mov	DWORD PTR [esi+7084], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6308 : 	m_iBARBARIAN_TECH_PERCENT = getDefineINT("BARBARIAN_TECH_PERCENT");

	push	1
	push	OFFSET $SG231947
	mov	ecx, esi
	mov	DWORD PTR [esi+7088], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6309 : 	m_iCITY_RESOURCE_WLTKD_TURNS = getDefineINT("CITY_RESOURCE_WLTKD_TURNS");

	push	1
	push	OFFSET $SG231948
	mov	ecx, esi
	mov	DWORD PTR [esi+7092], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6310 : 	m_iMAX_SPECIALISTS_FROM_BUILDING = getDefineINT("MAX_SPECIALISTS_FROM_BUILDING");

	push	1
	push	OFFSET $SG231949
	mov	ecx, esi
	mov	DWORD PTR [esi+7096], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6311 : 	m_iGREAT_PERSON_THRESHOLD_BASE = getDefineINT("GREAT_PERSON_THRESHOLD_BASE");

	push	1
	push	OFFSET $SG231950
	mov	ecx, esi
	mov	DWORD PTR [esi+7100], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6312 : 	m_iGREAT_PERSON_THRESHOLD_INCREASE = getDefineINT("GREAT_PERSON_THRESHOLD_INCREASE");

	push	1
	push	OFFSET $SG231951
	mov	ecx, esi
	mov	DWORD PTR [esi+7104], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6313 : 	m_iCULTURE_BOMB_COOLDOWN = getDefineINT("CULTURE_BOMB_COOLDOWN");

	push	1
	push	OFFSET $SG231952
	mov	ecx, esi
	mov	DWORD PTR [esi+7108], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6314 : 	m_iCULTURE_BOMB_MINOR_FRIENDSHIP_CHANGE = getDefineINT("CULTURE_BOMB_MINOR_FRIENDSHIP_CHANGE");

	push	1
	push	OFFSET $SG231953
	mov	ecx, esi
	mov	DWORD PTR [esi+7112], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6315 : 	m_iLANDMARK_MINOR_FRIENDSHIP_CHANGE = getDefineINT("LANDMARK_MINOR_FRIENDSHIP_CHANGE");

	push	1
	push	OFFSET $SG231954
	mov	ecx, esi
	mov	DWORD PTR [esi+7116], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6316 : 	m_iUNIT_AUTO_EXPLORE_DISABLED = getDefineINT("UNIT_AUTO_EXPLORE_DISABLED");

	push	1
	push	OFFSET $SG231955
	mov	ecx, esi
	mov	DWORD PTR [esi+7120], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6317 : 	m_iUNIT_AUTO_EXPLORE_FULL_DISABLED = getDefineINT("UNIT_AUTO_EXPLORE_FULL_DISABLED");

	push	1
	push	OFFSET $SG231956
	mov	ecx, esi
	mov	DWORD PTR [esi+7124], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6318 : 	m_iUNIT_WORKER_AUTOMATION_DISABLED = getDefineINT("UNIT_WORKER_AUTOMATION_DISABLED");

	push	1
	push	OFFSET $SG231957
	mov	ecx, esi
	mov	DWORD PTR [esi+7128], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6319 : 	m_iUNIT_DELETE_DISABLED = getDefineINT("UNIT_DELETE_DISABLED");

	push	1
	push	OFFSET $SG231958
	mov	ecx, esi
	mov	DWORD PTR [esi+7132], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6320 : 	m_iMIN_START_AREA_TILES = getDefineINT("MIN_START_AREA_TILES");

	push	1
	push	OFFSET $SG231959
	mov	ecx, esi
	mov	DWORD PTR [esi+7136], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6321 : 	m_iMIN_DISTANCE_OTHER_AREA_PERCENT = getDefineINT("MIN_DISTANCE_OTHER_AREA_PERCENT");

	push	1
	mov	DWORD PTR [esi+7140], eax
	push	OFFSET $SG231960
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6322 : 	m_iMINOR_CIV_FOOD_REQUIREMENT = getDefineINT("MINOR_CIV_FOOD_REQUIREMENT");

	push	1
	push	OFFSET $SG231961
	mov	ecx, esi
	mov	DWORD PTR [esi+7144], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6323 : 	m_iMAJOR_CIV_FOOD_REQUIREMENT = getDefineINT("MAJOR_CIV_FOOD_REQUIREMENT");

	push	1
	push	OFFSET $SG231962
	mov	ecx, esi
	mov	DWORD PTR [esi+7148], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6324 : 	m_iMIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST = getDefineINT("MIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST");

	push	1
	push	OFFSET $SG231963
	mov	ecx, esi
	mov	DWORD PTR [esi+7152], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6325 : 	m_iSTART_AREA_FOOD_MULTIPLIER = getDefineINT("START_AREA_FOOD_MULTIPLIER");

	push	1
	push	OFFSET $SG231964
	mov	ecx, esi
	mov	DWORD PTR [esi+7156], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6326 : 	m_iSTART_AREA_HAPPINESS_MULTIPLIER = getDefineINT("START_AREA_HAPPINESS_MULTIPLIER");

	push	1
	push	OFFSET $SG231965
	mov	ecx, esi
	mov	DWORD PTR [esi+7160], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6327 : 	m_iSTART_AREA_PRODUCTION_MULTIPLIER = getDefineINT("START_AREA_PRODUCTION_MULTIPLIER");

	push	1
	push	OFFSET $SG231966
	mov	ecx, esi
	mov	DWORD PTR [esi+7164], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6328 : 	m_iSTART_AREA_GOLD_MULTIPLIER = getDefineINT("START_AREA_GOLD_MULTIPLIER");

	push	1
	push	OFFSET $SG231967
	mov	ecx, esi
	mov	DWORD PTR [esi+7168], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6329 : 	m_iSTART_AREA_SCIENCE_MULTIPLIER = getDefineINT("START_AREA_SCIENCE_MULTIPLIER");

	push	1
	push	OFFSET $SG231968
	mov	ecx, esi
	mov	DWORD PTR [esi+7172], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6330 : #ifdef AUI_SITE_EVALUATION_PLOT_FOUND_VALUE_CONSIDER_CULTURE
; 6331 : 	GD_INT_CACHE(START_AREA_CULTURE_MULTIPLIER);
; 6332 : #endif
; 6333 : 	m_iSTART_AREA_FAITH_MULTIPLIER = getDefineINT("START_AREA_FAITH_MULTIPLIER");

	push	1
	push	OFFSET $SG231969
	mov	ecx, esi
	mov	DWORD PTR [esi+7176], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6334 : 	m_iSTART_AREA_RESOURCE_MULTIPLIER = getDefineINT("START_AREA_RESOURCE_MULTIPLIER");

	push	1
	push	OFFSET $SG231970
	mov	ecx, esi
	mov	DWORD PTR [esi+7180], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6335 : 	m_iSTART_AREA_STRATEGIC_MULTIPLIER = getDefineINT("START_AREA_STRATEGIC_MULTIPLIER");

	push	1
	push	OFFSET $SG231971
	mov	ecx, esi
	mov	DWORD PTR [esi+7184], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6336 : 	m_iSTART_AREA_BUILD_ON_COAST_PERCENT = getDefineINT("START_AREA_BUILD_ON_COAST_PERCENT");

	push	1
	push	OFFSET $SG231972
	mov	ecx, esi
	mov	DWORD PTR [esi+7188], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6337 : 	m_iSETTLER_FOOD_MULTIPLIER = getDefineINT("SETTLER_FOOD_MULTIPLIER");

	push	1
	push	OFFSET $SG231973
	mov	ecx, esi
	mov	DWORD PTR [esi+7192], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6338 : 	m_iSETTLER_HAPPINESS_MULTIPLIER = getDefineINT("SETTLER_HAPPINESS_MULTIPLIER");

	push	1
	push	OFFSET $SG231974
	mov	ecx, esi
	mov	DWORD PTR [esi+7196], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6339 : 	m_iSETTLER_PRODUCTION_MULTIPLIER = getDefineINT("SETTLER_PRODUCTION_MULTIPLIER");

	push	1
	push	OFFSET $SG231975
	mov	ecx, esi
	mov	DWORD PTR [esi+7200], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6340 : 	m_iSETTLER_GOLD_MULTIPLIER = getDefineINT("SETTLER_GOLD_MULTIPLIER");

	push	1
	mov	DWORD PTR [esi+7204], eax
	push	OFFSET $SG231976
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6341 : 	m_iSETTLER_SCIENCE_MULTIPLIER = getDefineINT("SETTLER_SCIENCE_MULTIPLIER");

	push	1
	push	OFFSET $SG231977
	mov	ecx, esi
	mov	DWORD PTR [esi+7208], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6342 : #ifdef AUI_SITE_EVALUATION_PLOT_FOUND_VALUE_CONSIDER_CULTURE
; 6343 : 	GD_INT_CACHE(SETTLER_CULTURE_MULTIPLIER);
; 6344 : #endif
; 6345 : 	m_iSETTLER_FAITH_MULTIPLIER = getDefineINT("SETTLER_FAITH_MULTIPLIER");

	push	1
	push	OFFSET $SG231978
	mov	ecx, esi
	mov	DWORD PTR [esi+7212], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6346 : 	m_iSETTLER_RESOURCE_MULTIPLIER = getDefineINT("SETTLER_RESOURCE_MULTIPLIER");

	push	1
	push	OFFSET $SG231979
	mov	ecx, esi
	mov	DWORD PTR [esi+7216], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6347 : 	m_iSETTLER_STRATEGIC_MULTIPLIER = getDefineINT("SETTLER_STRATEGIC_MULTIPLIER");

	push	1
	push	OFFSET $SG231980
	mov	ecx, esi
	mov	DWORD PTR [esi+7220], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6348 : 	m_iSETTLER_BUILD_ON_COAST_PERCENT = getDefineINT("SETTLER_BUILD_ON_COAST_PERCENT");

	push	1
	push	OFFSET $SG231981
	mov	ecx, esi
	mov	DWORD PTR [esi+7224], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6349 : #ifdef AUI_SITE_EVALUATION_PLOT_FOUND_VALUE_CONSIDER_CULTURE
; 6350 : 	GD_INT_CACHE(CITY_RING_0_MULTIPLIER);
; 6351 : #endif
; 6352 : 	m_iCITY_RING_1_MULTIPLIER = getDefineINT("CITY_RING_1_MULTIPLIER");

	push	1
	push	OFFSET $SG231982
	mov	ecx, esi
	mov	DWORD PTR [esi+7228], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6353 : 	m_iCITY_RING_2_MULTIPLIER = getDefineINT("CITY_RING_2_MULTIPLIER");

	push	1
	push	OFFSET $SG231983
	mov	ecx, esi
	mov	DWORD PTR [esi+7232], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6354 : 	m_iCITY_RING_3_MULTIPLIER = getDefineINT("CITY_RING_3_MULTIPLIER");

	push	1
	push	OFFSET $SG231984
	mov	ecx, esi
	mov	DWORD PTR [esi+7236], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6355 : 	m_iCITY_RING_4_MULTIPLIER = getDefineINT("CITY_RING_4_MULTIPLIER");

	push	1
	push	OFFSET $SG231985
	mov	ecx, esi
	mov	DWORD PTR [esi+7240], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6356 : 	m_iCITY_RING_5_MULTIPLIER = getDefineINT("CITY_RING_5_MULTIPLIER");

	push	1
	push	OFFSET $SG231986
	mov	ecx, esi
	mov	DWORD PTR [esi+7244], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6357 : #ifdef AUI_SITE_EVALUATION_YIELD_MULTIPLIER_DISTANCE_DECAY
; 6358 : 	GD_INT_CACHE(SETTLER_FOOD_RING_0_DIVIDER);
; 6359 : 	GD_INT_CACHE(SETTLER_PRODUCTION_RING_0_DIVIDER);
; 6360 : 	GD_INT_CACHE(SETTLER_GOLD_RING_0_DIVIDER);
; 6361 : 	GD_INT_CACHE(SETTLER_SCIENCE_RING_0_DIVIDER);
; 6362 : 	GD_INT_CACHE(SETTLER_CULTURE_RING_0_DIVIDER);
; 6363 : 	GD_INT_CACHE(SETTLER_FAITH_RING_0_DIVIDER);
; 6364 : 	GD_INT_CACHE(SETTLER_HAPPINESS_RING_0_DIVIDER);
; 6365 : 	GD_INT_CACHE(SETTLER_RESOURCES_RING_0_DIVIDER);
; 6366 : 	GD_INT_CACHE(SETTLER_STRATEGIC_RING_0_DIVIDER);
; 6367 : 	GD_INT_CACHE(SETTLER_FOOD_RING_1_DIVIDER);
; 6368 : 	GD_INT_CACHE(SETTLER_PRODUCTION_RING_1_DIVIDER);
; 6369 : 	GD_INT_CACHE(SETTLER_GOLD_RING_1_DIVIDER);
; 6370 : 	GD_INT_CACHE(SETTLER_SCIENCE_RING_1_DIVIDER);
; 6371 : 	GD_INT_CACHE(SETTLER_CULTURE_RING_1_DIVIDER);
; 6372 : 	GD_INT_CACHE(SETTLER_FAITH_RING_1_DIVIDER);
; 6373 : 	GD_INT_CACHE(SETTLER_HAPPINESS_RING_1_DIVIDER);
; 6374 : 	GD_INT_CACHE(SETTLER_RESOURCES_RING_1_DIVIDER);
; 6375 : 	GD_INT_CACHE(SETTLER_STRATEGIC_RING_1_DIVIDER);
; 6376 : 	GD_INT_CACHE(SETTLER_FOOD_RING_2_DIVIDER);
; 6377 : 	GD_INT_CACHE(SETTLER_PRODUCTION_RING_2_DIVIDER);
; 6378 : 	GD_INT_CACHE(SETTLER_GOLD_RING_2_DIVIDER);
; 6379 : 	GD_INT_CACHE(SETTLER_SCIENCE_RING_2_DIVIDER);
; 6380 : 	GD_INT_CACHE(SETTLER_CULTURE_RING_2_DIVIDER);
; 6381 : 	GD_INT_CACHE(SETTLER_FAITH_RING_2_DIVIDER);
; 6382 : 	GD_INT_CACHE(SETTLER_HAPPINESS_RING_2_DIVIDER);
; 6383 : 	GD_INT_CACHE(SETTLER_RESOURCES_RING_2_DIVIDER);
; 6384 : 	GD_INT_CACHE(SETTLER_STRATEGIC_RING_2_DIVIDER);
; 6385 : 	GD_INT_CACHE(SETTLER_FOOD_RING_3_DIVIDER);
; 6386 : 	GD_INT_CACHE(SETTLER_PRODUCTION_RING_3_DIVIDER);
; 6387 : 	GD_INT_CACHE(SETTLER_GOLD_RING_3_DIVIDER);
; 6388 : 	GD_INT_CACHE(SETTLER_SCIENCE_RING_3_DIVIDER);
; 6389 : 	GD_INT_CACHE(SETTLER_CULTURE_RING_3_DIVIDER);
; 6390 : 	GD_INT_CACHE(SETTLER_FAITH_RING_3_DIVIDER);
; 6391 : 	GD_INT_CACHE(SETTLER_HAPPINESS_RING_3_DIVIDER);
; 6392 : 	GD_INT_CACHE(SETTLER_RESOURCES_RING_3_DIVIDER);
; 6393 : 	GD_INT_CACHE(SETTLER_STRATEGIC_RING_3_DIVIDER);
; 6394 : 	GD_INT_CACHE(SETTLER_HAPPINESS_RING_4_DIVIDER);
; 6395 : 	GD_INT_CACHE(SETTLER_RESOURCES_RING_4_DIVIDER);
; 6396 : 	GD_INT_CACHE(SETTLER_STRATEGIC_RING_4_DIVIDER);
; 6397 : 	GD_INT_CACHE(SETTLER_HAPPINESS_RING_5_DIVIDER);
; 6398 : 	GD_INT_CACHE(SETTLER_RESOURCES_RING_5_DIVIDER);
; 6399 : 	GD_INT_CACHE(SETTLER_STRATEGIC_RING_5_DIVIDER);
; 6400 : #endif
; 6401 : 	m_iSETTLER_EVALUATION_DISTANCE = getDefineINT("SETTLER_EVALUATION_DISTANCE");

	push	1
	push	OFFSET $SG231987
	mov	ecx, esi
	mov	DWORD PTR [esi+7248], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6402 : 	m_iSETTLER_DISTANCE_DROPOFF_MODIFIER = getDefineINT("SETTLER_DISTANCE_DROPOFF_MODIFIER");

	push	1
	push	OFFSET $SG231988
	mov	ecx, esi
	mov	DWORD PTR [esi+7252], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6403 : 	m_iBUILD_ON_RESOURCE_PERCENT = getDefineINT("BUILD_ON_RESOURCE_PERCENT");

	push	1
	push	OFFSET $SG231989
	mov	ecx, esi
	mov	DWORD PTR [esi+7256], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6404 : 	m_iBUILD_ON_RIVER_PERCENT = getDefineINT("BUILD_ON_RIVER_PERCENT");

	push	1
	push	OFFSET $SG231990
	mov	ecx, esi
	mov	DWORD PTR [esi+7260], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6405 : 	m_iCHOKEPOINT_STRATEGIC_VALUE = getDefineINT("CHOKEPOINT_STRATEGIC_VALUE");

	push	1
	push	OFFSET $SG231991
	mov	ecx, esi
	mov	DWORD PTR [esi+7264], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6406 : 	m_iHILL_STRATEGIC_VALUE = getDefineINT("HILL_STRATEGIC_VALUE");

	push	1
	push	OFFSET $SG231992
	mov	ecx, esi
	mov	DWORD PTR [esi+7268], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6407 : 	m_iALREADY_OWNED_STRATEGIC_VALUE = getDefineINT("ALREADY_OWNED_STRATEGIC_VALUE");

	push	1
	push	OFFSET $SG231993
	mov	ecx, esi
	mov	DWORD PTR [esi+7272], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6408 : 	m_iMINOR_CIV_CONTACT_GOLD_FIRST = getDefineINT("MINOR_CIV_CONTACT_GOLD_FIRST");

	push	1
	push	OFFSET $SG231994
	mov	ecx, esi
	mov	DWORD PTR [esi+7276], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6409 : 	m_iMINOR_CIV_CONTACT_GOLD_OTHER = getDefineINT("MINOR_CIV_CONTACT_GOLD_OTHER");

	push	1
	push	OFFSET $SG231995
	mov	ecx, esi
	mov	DWORD PTR [esi+7280], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6410 : 	m_iMINOR_CIV_GROWTH_PERCENT = getDefineINT("MINOR_CIV_GROWTH_PERCENT");

	push	1
	push	OFFSET $SG231996
	mov	ecx, esi
	mov	DWORD PTR [esi+7284], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6411 : 	m_iMINOR_CIV_PRODUCTION_PERCENT = getDefineINT("MINOR_CIV_PRODUCTION_PERCENT");

	push	1
	push	OFFSET $SG231997
	mov	ecx, esi
	mov	DWORD PTR [esi+7288], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6412 : 	m_iMINOR_CIV_GOLD_PERCENT = getDefineINT("MINOR_CIV_GOLD_PERCENT");

	push	1
	push	OFFSET $SG231998
	mov	ecx, esi
	mov	DWORD PTR [esi+7292], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6413 : 	m_iMINOR_CIV_TECH_PERCENT = getDefineINT("MINOR_CIV_TECH_PERCENT");

	push	1
	push	OFFSET $SG231999
	mov	ecx, esi
	mov	DWORD PTR [esi+7296], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6414 : 	m_iMINOR_POLICY_RESOURCE_MULTIPLIER = getDefineINT("MINOR_POLICY_RESOURCE_MULTIPLIER");

	push	1
	push	OFFSET $SG232000
	mov	ecx, esi
	mov	DWORD PTR [esi+7300], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6415 : 	m_iMINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER = getDefineINT("MINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER");

	push	1
	push	OFFSET $SG232001
	mov	ecx, esi
	mov	DWORD PTR [esi+7304], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6416 : 	m_iMINOR_GOLD_GIFT_LARGE = getDefineINT("MINOR_GOLD_GIFT_LARGE");

	push	1
	push	OFFSET $SG232002
	mov	ecx, esi
	mov	DWORD PTR [esi+7308], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6417 : 	m_iMINOR_GOLD_GIFT_MEDIUM = getDefineINT("MINOR_GOLD_GIFT_MEDIUM");

	push	1
	push	OFFSET $SG232003
	mov	ecx, esi
	mov	DWORD PTR [esi+7312], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6418 : 	m_iMINOR_GOLD_GIFT_SMALL = getDefineINT("MINOR_GOLD_GIFT_SMALL");

	push	1
	push	OFFSET $SG232004
	mov	ecx, esi
	mov	DWORD PTR [esi+7316], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6419 : 	m_iMINOR_CIV_TILE_IMPROVEMENT_GIFT_COST = getDefineINT("MINOR_CIV_TILE_IMPROVEMENT_GIFT_COST");

	push	1
	push	OFFSET $SG232005
	mov	ecx, esi
	mov	DWORD PTR [esi+7320], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6420 : 	m_iMINOR_CIV_BUYOUT_COST = getDefineINT("MINOR_CIV_BUYOUT_COST");

	push	1
	push	OFFSET $SG232006
	mov	ecx, esi
	mov	DWORD PTR [esi+7324], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6421 : 	m_iMINOR_CIV_BUYOUT_TURNS = getDefineINT("MINOR_CIV_BUYOUT_TURNS");

	push	1
	push	OFFSET $SG232007
	mov	ecx, esi
	mov	DWORD PTR [esi+7328], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6422 : 	m_iMINOR_FRIENDSHIP_FROM_TRADE_MISSION = getDefineINT("MINOR_FRIENDSHIP_FROM_TRADE_MISSION");

	push	1
	push	OFFSET $SG232008
	mov	ecx, esi
	mov	DWORD PTR [esi+7332], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+7336], eax

; 6423 : 	m_iMINOR_FRIENDSHIP_ANCHOR_DEFAULT = getDefineINT("MINOR_FRIENDSHIP_ANCHOR_DEFAULT");

	push	1
	push	OFFSET $SG232009
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6424 : 	m_iMINOR_FRIENDSHIP_ANCHOR_MOD_PROTECTED = getDefineINT("MINOR_FRIENDSHIP_ANCHOR_MOD_PROTECTED");

	push	1
	push	OFFSET $SG232010
	mov	ecx, esi
	mov	DWORD PTR [esi+7340], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6425 : 	m_iMINOR_FRIENDSHIP_ANCHOR_MOD_WARY_OF = getDefineINT("MINOR_FRIENDSHIP_ANCHOR_MOD_WARY_OF");

	push	1
	push	OFFSET $SG232011
	mov	ecx, esi
	mov	DWORD PTR [esi+7344], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6426 : 	m_iMINOR_UNIT_GIFT_TRAVEL_TURNS = getDefineINT("MINOR_UNIT_GIFT_TRAVEL_TURNS");

	push	1
	push	OFFSET $SG232012
	mov	ecx, esi
	mov	DWORD PTR [esi+7348], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6427 : 	m_iPLOT_UNIT_LIMIT = getDefineINT("PLOT_UNIT_LIMIT");

	push	1
	push	OFFSET $SG232013
	mov	ecx, esi
	mov	DWORD PTR [esi+7352], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6428 : 	m_iZONE_OF_CONTROL_ENABLED = getDefineINT("ZONE_OF_CONTROL_ENABLED");

	push	1
	push	OFFSET $SG232014
	mov	ecx, esi
	mov	DWORD PTR [esi+7356], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6429 : 	m_iFIRE_SUPPORT_DISABLED = getDefineINT("FIRE_SUPPORT_DISABLED");

	push	1
	push	OFFSET $SG232015
	mov	ecx, esi
	mov	DWORD PTR [esi+7360], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6430 : 	m_iMAX_HIT_POINTS = getDefineINT("MAX_HIT_POINTS");

	push	1
	push	OFFSET $SG232016
	mov	ecx, esi
	mov	DWORD PTR [esi+7364], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6431 : 	m_iMAX_CITY_HIT_POINTS = getDefineINT("MAX_CITY_HIT_POINTS");

	push	1
	push	OFFSET $SG232017
	mov	ecx, esi
	mov	DWORD PTR [esi+7368], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6432 : 	m_iCITY_HIT_POINTS_HEALED_PER_TURN = getDefineINT("CITY_HIT_POINTS_HEALED_PER_TURN");

	push	1
	push	OFFSET $SG232018
	mov	ecx, esi
	mov	DWORD PTR [esi+7372], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6433 : 	m_iFLAT_LAND_EXTRA_DEFENSE = getDefineINT("FLAT_LAND_EXTRA_DEFENSE");

	push	1
	push	OFFSET $SG232019
	mov	ecx, esi
	mov	DWORD PTR [esi+7376], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6434 : 	m_iHILLS_EXTRA_DEFENSE = getDefineINT("HILLS_EXTRA_DEFENSE");

	push	1
	push	OFFSET $SG232020
	mov	ecx, esi
	mov	DWORD PTR [esi+7380], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6435 : 	m_iRIVER_ATTACK_MODIFIER = getDefineINT("RIVER_ATTACK_MODIFIER");

	push	1
	push	OFFSET $SG232021
	mov	ecx, esi
	mov	DWORD PTR [esi+7384], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6436 : 	m_iAMPHIB_ATTACK_MODIFIER = getDefineINT("AMPHIB_ATTACK_MODIFIER");

	push	1
	push	OFFSET $SG232022
	mov	ecx, esi
	mov	DWORD PTR [esi+7388], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6437 : 	m_iENEMY_HEAL_RATE = getDefineINT("ENEMY_HEAL_RATE");

	push	1
	push	OFFSET $SG232023
	mov	ecx, esi
	mov	DWORD PTR [esi+7392], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6438 : 	m_iNEUTRAL_HEAL_RATE = getDefineINT("NEUTRAL_HEAL_RATE");

	push	1
	push	OFFSET $SG232024
	mov	ecx, esi
	mov	DWORD PTR [esi+7396], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+7400], eax

; 6439 : 	m_iFRIENDLY_HEAL_RATE = getDefineINT("FRIENDLY_HEAL_RATE");

	push	1
	push	OFFSET $SG232025
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6440 : 	m_iINSTA_HEAL_RATE = getDefineINT("INSTA_HEAL_RATE");

	push	1
	push	OFFSET $SG232026
	mov	ecx, esi
	mov	DWORD PTR [esi+7404], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6441 : 	m_iCITY_HEAL_RATE = getDefineINT("CITY_HEAL_RATE");

	push	1
	push	OFFSET $SG232027
	mov	ecx, esi
	mov	DWORD PTR [esi+7408], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6442 : 	m_iATTACK_SAME_STRENGTH_MIN_DAMAGE = getDefineINT("ATTACK_SAME_STRENGTH_MIN_DAMAGE");

	push	1
	push	OFFSET $SG232028
	mov	ecx, esi
	mov	DWORD PTR [esi+7412], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6443 : 	m_iRANGE_ATTACK_RANGED_DEFENDER_MOD = getDefineINT("RANGE_ATTACK_RANGED_DEFENDER_MOD");

	push	1
	push	OFFSET $SG232029
	mov	ecx, esi
	mov	DWORD PTR [esi+7416], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6444 : 	m_iATTACK_SAME_STRENGTH_POSSIBLE_EXTRA_DAMAGE = getDefineINT("ATTACK_SAME_STRENGTH_POSSIBLE_EXTRA_DAMAGE");

	push	1
	push	OFFSET $SG232030
	mov	ecx, esi
	mov	DWORD PTR [esi+7420], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6445 : 	m_iRANGE_ATTACK_SAME_STRENGTH_MIN_DAMAGE = getDefineINT("RANGE_ATTACK_SAME_STRENGTH_MIN_DAMAGE");

	push	1
	push	OFFSET $SG232031
	mov	ecx, esi
	mov	DWORD PTR [esi+7424], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6446 : 	m_iRANGE_ATTACK_SAME_STRENGTH_POSSIBLE_EXTRA_DAMAGE = getDefineINT("RANGE_ATTACK_SAME_STRENGTH_POSSIBLE_EXTRA_DAMAGE");

	push	1
	push	OFFSET $SG232032
	mov	ecx, esi
	mov	DWORD PTR [esi+7428], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6447 : 	m_iAIR_STRIKE_SAME_STRENGTH_MIN_DEFENSE_DAMAGE = getDefineINT("AIR_STRIKE_SAME_STRENGTH_MIN_DEFENSE_DAMAGE");

	push	1
	push	OFFSET $SG232033
	mov	ecx, esi
	mov	DWORD PTR [esi+7432], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6448 : 	m_iAIR_STRIKE_SAME_STRENGTH_POSSIBLE_EXTRA_DEFENSE_DAMAGE = getDefineINT("AIR_STRIKE_SAME_STRENGTH_POSSIBLE_EXTRA_DEFENSE_DAMAGE");

	push	1
	push	OFFSET $SG232034
	mov	ecx, esi
	mov	DWORD PTR [esi+7436], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6449 : 	m_iINTERCEPTION_SAME_STRENGTH_MIN_DAMAGE = getDefineINT("INTERCEPTION_SAME_STRENGTH_MIN_DAMAGE");

	push	1
	push	OFFSET $SG232035
	mov	ecx, esi
	mov	DWORD PTR [esi+7440], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6450 : 	m_iINTERCEPTION_SAME_STRENGTH_POSSIBLE_EXTRA_DAMAGE = getDefineINT("INTERCEPTION_SAME_STRENGTH_POSSIBLE_EXTRA_DAMAGE");

	push	1
	push	OFFSET $SG232036
	mov	ecx, esi
	mov	DWORD PTR [esi+7444], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6451 : 	m_iAIR_SWEEP_INTERCEPTION_DAMAGE_MOD = getDefineINT("AIR_SWEEP_INTERCEPTION_DAMAGE_MOD");

	push	1
	push	OFFSET $SG232037
	mov	ecx, esi
	mov	DWORD PTR [esi+7448], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6452 : 	m_iWOUNDED_DAMAGE_MULTIPLIER = getDefineINT("WOUNDED_DAMAGE_MULTIPLIER");

	push	1
	push	OFFSET $SG232038
	mov	ecx, esi
	mov	DWORD PTR [esi+7452], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6453 : 	m_iTRAIT_WOUNDED_DAMAGE_MOD = getDefineINT("TRAIT_WOUNDED_DAMAGE_MOD");

	push	1
	push	OFFSET $SG232039
	mov	ecx, esi
	mov	DWORD PTR [esi+7456], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6454 : 	m_iCITY_STRENGTH_DEFAULT = getDefineINT("CITY_STRENGTH_DEFAULT");

	push	1
	push	OFFSET $SG232040
	mov	ecx, esi
	mov	DWORD PTR [esi+7460], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6455 : 	m_iCITY_STRENGTH_POPULATION_CHANGE = getDefineINT("CITY_STRENGTH_POPULATION_CHANGE");

	push	1
	mov	DWORD PTR [esi+7464], eax
	push	OFFSET $SG232041
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6456 : 	m_iCITY_STRENGTH_UNIT_DIVISOR = getDefineINT("CITY_STRENGTH_UNIT_DIVISOR");

	push	1
	push	OFFSET $SG232042
	mov	ecx, esi
	mov	DWORD PTR [esi+7468], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6457 : 	m_iCITY_STRENGTH_HILL_CHANGE = getDefineINT("CITY_STRENGTH_HILL_CHANGE");

	push	1
	push	OFFSET $SG232043
	mov	ecx, esi
	mov	DWORD PTR [esi+7472], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6458 : 	m_iCITY_ATTACKING_DAMAGE_MOD = getDefineINT("CITY_ATTACKING_DAMAGE_MOD");

	push	1
	push	OFFSET $SG232044
	mov	ecx, esi
	mov	DWORD PTR [esi+7476], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6459 : 	m_iATTACKING_CITY_MELEE_DAMAGE_MOD = getDefineINT("ATTACKING_CITY_MELEE_DAMAGE_MOD");

	push	1
	push	OFFSET $SG232045
	mov	ecx, esi
	mov	DWORD PTR [esi+7480], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6460 : 	m_iCITY_ATTACK_RANGE = getDefineINT("CITY_ATTACK_RANGE");

	push	1
	push	OFFSET $SG232046
	mov	ecx, esi
	mov	DWORD PTR [esi+7484], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6461 : 	m_iCAN_CITY_USE_INDIRECT_FIRE = getDefineINT("CAN_CITY_USE_INDIRECT_FIRE");

	push	1
	push	OFFSET $SG232047
	mov	ecx, esi
	mov	DWORD PTR [esi+7488], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6462 : 	m_iCITY_RANGED_ATTACK_STRENGTH_MULTIPLIER = getDefineINT("CITY_RANGED_ATTACK_STRENGTH_MULTIPLIER");

	push	1
	push	OFFSET $SG232048
	mov	ecx, esi
	mov	DWORD PTR [esi+7492], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6463 : 	m_iMIN_CITY_STRIKE_DAMAGE = getDefineINT("MIN_CITY_STRIKE_DAMAGE");

	push	1
	push	OFFSET $SG232049
	mov	ecx, esi
	mov	DWORD PTR [esi+7496], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6464 : 	m_iCITY_CAPTURE_DAMAGE_PERCENT = getDefineINT("CITY_CAPTURE_DAMAGE_PERCENT");

	push	1
	push	OFFSET $SG232050
	mov	ecx, esi
	mov	DWORD PTR [esi+7500], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6465 : 	m_iEXPERIENCE_PER_LEVEL = getDefineINT("EXPERIENCE_PER_LEVEL");

	push	1
	push	OFFSET $SG232051
	mov	ecx, esi
	mov	DWORD PTR [esi+7504], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6466 : 	m_iEXPERIENCE_ATTACKING_UNIT_MELEE = getDefineINT("EXPERIENCE_ATTACKING_UNIT_MELEE");

	push	1
	push	OFFSET $SG232052
	mov	ecx, esi
	mov	DWORD PTR [esi+7508], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6467 : 	m_iEXPERIENCE_DEFENDING_UNIT_MELEE = getDefineINT("EXPERIENCE_DEFENDING_UNIT_MELEE");

	push	1
	push	OFFSET $SG232053
	mov	ecx, esi
	mov	DWORD PTR [esi+7512], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6468 : 	m_iEXPERIENCE_ATTACKING_UNIT_AIR = getDefineINT("EXPERIENCE_ATTACKING_UNIT_AIR");

	push	1
	push	OFFSET $SG232054
	mov	ecx, esi
	mov	DWORD PTR [esi+7516], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6469 : 	m_iEXPERIENCE_DEFENDING_UNIT_AIR = getDefineINT("EXPERIENCE_DEFENDING_UNIT_AIR");

	push	1
	push	OFFSET $SG232055
	mov	ecx, esi
	mov	DWORD PTR [esi+7520], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6470 : 	m_iEXPERIENCE_ATTACKING_UNIT_RANGED = getDefineINT("EXPERIENCE_ATTACKING_UNIT_RANGED");

	push	1
	push	OFFSET $SG232056
	mov	ecx, esi
	mov	DWORD PTR [esi+7524], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6471 : 	m_iEXPERIENCE_DEFENDING_UNIT_RANGED = getDefineINT("EXPERIENCE_DEFENDING_UNIT_RANGED");

	push	1
	mov	DWORD PTR [esi+7528], eax
	push	OFFSET $SG232057
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6472 : 	m_iEXPERIENCE_ATTACKING_AIR_SWEEP = getDefineINT("EXPERIENCE_ATTACKING_AIR_SWEEP");

	push	1
	push	OFFSET $SG232058
	mov	ecx, esi
	mov	DWORD PTR [esi+7532], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6473 : 	m_iEXPERIENCE_DEFENDING_AIR_SWEEP_AIR = getDefineINT("EXPERIENCE_DEFENDING_AIR_SWEEP_AIR");

	push	1
	push	OFFSET $SG232059
	mov	ecx, esi
	mov	DWORD PTR [esi+7536], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6474 : 	m_iEXPERIENCE_DEFENDING_AIR_SWEEP_GROUND = getDefineINT("EXPERIENCE_DEFENDING_AIR_SWEEP_GROUND");

	push	1
	push	OFFSET $SG232060
	mov	ecx, esi
	mov	DWORD PTR [esi+7540], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6475 : 	m_iEXPERIENCE_ATTACKING_CITY_MELEE = getDefineINT("EXPERIENCE_ATTACKING_CITY_MELEE");

	push	1
	push	OFFSET $SG232061
	mov	ecx, esi
	mov	DWORD PTR [esi+7544], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6476 : 	m_iEXPERIENCE_ATTACKING_CITY_RANGED = getDefineINT("EXPERIENCE_ATTACKING_CITY_RANGED");

	push	1
	push	OFFSET $SG232062
	mov	ecx, esi
	mov	DWORD PTR [esi+7548], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6477 : 	m_iEXPERIENCE_ATTACKING_CITY_AIR = getDefineINT("EXPERIENCE_ATTACKING_CITY_AIR");

	push	1
	push	OFFSET $SG232063
	mov	ecx, esi
	mov	DWORD PTR [esi+7552], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6478 : 	m_iBARBARIAN_MAX_XP_VALUE = getDefineINT("BARBARIAN_MAX_XP_VALUE");

	push	1
	push	OFFSET $SG232064
	mov	ecx, esi
	mov	DWORD PTR [esi+7556], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6479 : 	m_iCOMBAT_EXPERIENCE_IN_BORDERS_PERCENT = getDefineINT("COMBAT_EXPERIENCE_IN_BORDERS_PERCENT");

	push	1
	push	OFFSET $SG232065
	mov	ecx, esi
	mov	DWORD PTR [esi+7560], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6480 : 	m_iGREAT_GENERALS_THRESHOLD_INCREASE = getDefineINT("GREAT_GENERALS_THRESHOLD_INCREASE");

	push	1
	push	OFFSET $SG232066
	mov	ecx, esi
	mov	DWORD PTR [esi+7564], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6481 : 	m_iGREAT_GENERALS_THRESHOLD_INCREASE_TEAM = getDefineINT("GREAT_GENERALS_THRESHOLD_INCREASE_TEAM");

	push	1
	push	OFFSET $SG232067
	mov	ecx, esi
	mov	DWORD PTR [esi+7568], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6482 : 	m_iGREAT_GENERALS_THRESHOLD = getDefineINT("GREAT_GENERALS_THRESHOLD");

	push	1
	push	OFFSET $SG232068
	mov	ecx, esi
	mov	DWORD PTR [esi+7572], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6483 : 	m_iUNIT_DEATH_XP_GREAT_GENERAL_LOSS = getDefineINT("UNIT_DEATH_XP_GREAT_GENERAL_LOSS");

	push	1
	push	OFFSET $SG232069
	mov	ecx, esi
	mov	DWORD PTR [esi+7576], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6484 : 	m_iMIN_EXPERIENCE_PER_COMBAT = getDefineINT("MIN_EXPERIENCE_PER_COMBAT");

	push	1
	push	OFFSET $SG232070
	mov	ecx, esi
	mov	DWORD PTR [esi+7580], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6485 : 	m_iMAX_EXPERIENCE_PER_COMBAT = getDefineINT("MAX_EXPERIENCE_PER_COMBAT");

	push	1
	push	OFFSET $SG232071
	mov	ecx, esi
	mov	DWORD PTR [esi+7584], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6486 : 	m_iCRAMPED_RANGE_FROM_CITY = getDefineINT("CRAMPED_RANGE_FROM_CITY");

	push	1
	push	OFFSET $SG232072
	mov	ecx, esi
	mov	DWORD PTR [esi+7588], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6487 : 	m_iCRAMPED_USABLE_PLOT_PERCENT = getDefineINT("CRAMPED_USABLE_PLOT_PERCENT");

	push	1
	push	OFFSET $SG232073
	mov	ecx, esi
	mov	DWORD PTR [esi+7592], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6488 : 	m_iPROXIMITY_NEIGHBORS_CLOSEST_CITY_REQUIREMENT = getDefineINT("PROXIMITY_NEIGHBORS_CLOSEST_CITY_REQUIREMENT");

	push	1
	push	OFFSET $SG232074
	mov	ecx, esi
	mov	DWORD PTR [esi+7596], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6489 : 	m_iPROXIMITY_CLOSE_CLOSEST_CITY_POSSIBILITY = getDefineINT("PROXIMITY_CLOSE_CLOSEST_CITY_POSSIBILITY");

	push	1
	push	OFFSET $SG232075
	mov	ecx, esi
	mov	DWORD PTR [esi+7600], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6490 : 	m_iPROXIMITY_CLOSE_DISTANCE_MAP_MULTIPLIER = getDefineINT("PROXIMITY_CLOSE_DISTANCE_MAP_MULTIPLIER");

	push	1
	push	OFFSET $SG232076
	mov	ecx, esi
	mov	DWORD PTR [esi+7604], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6491 : 	m_iPROXIMITY_CLOSE_DISTANCE_MAX = getDefineINT("PROXIMITY_CLOSE_DISTANCE_MAX");

	push	1
	push	OFFSET $SG232077
	mov	ecx, esi
	mov	DWORD PTR [esi+7608], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6492 : 	m_iPROXIMITY_CLOSE_DISTANCE_MIN = getDefineINT("PROXIMITY_CLOSE_DISTANCE_MIN");

	push	1
	push	OFFSET $SG232078
	mov	ecx, esi
	mov	DWORD PTR [esi+7612], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6493 : 	m_iPROXIMITY_FAR_DISTANCE_MAP_MULTIPLIER = getDefineINT("PROXIMITY_FAR_DISTANCE_MAP_MULTIPLIER");

	push	1
	push	OFFSET $SG232079
	mov	ecx, esi
	mov	DWORD PTR [esi+7616], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6494 : 	m_iPROXIMITY_FAR_DISTANCE_MAX = getDefineINT("PROXIMITY_FAR_DISTANCE_MAX");

	push	1
	push	OFFSET $SG232080
	mov	ecx, esi
	mov	DWORD PTR [esi+7620], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6495 : 	m_iPROXIMITY_FAR_DISTANCE_MIN = getDefineINT("PROXIMITY_FAR_DISTANCE_MIN");

	push	1
	push	OFFSET $SG232081
	mov	ecx, esi
	mov	DWORD PTR [esi+7624], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6496 : 	m_iPLOT_BASE_COST = getDefineINT("PLOT_BASE_COST");

	push	1
	push	OFFSET $SG232082
	mov	ecx, esi
	mov	DWORD PTR [esi+7628], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6497 : 	m_iPLOT_ADDITIONAL_COST_PER_PLOT = getDefineINT("PLOT_ADDITIONAL_COST_PER_PLOT");

	push	1
	push	OFFSET $SG232083
	mov	ecx, esi
	mov	DWORD PTR [esi+7632], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6498 : 	m_iPLOT_COST_APPEARANCE_DIVISOR = getDefineINT("PLOT_COST_APPEARANCE_DIVISOR");

	push	1
	push	OFFSET $SG232084
	mov	ecx, esi
	mov	DWORD PTR [esi+7636], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6499 : 	m_iCULTURE_COST_FIRST_PLOT = getDefineINT("CULTURE_COST_FIRST_PLOT");

	push	1
	push	OFFSET $SG232085
	mov	ecx, esi
	mov	DWORD PTR [esi+7640], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6500 : 	m_iCULTURE_COST_LATER_PLOT_MULTIPLIER = getDefineINT("CULTURE_COST_LATER_PLOT_MULTIPLIER");

	push	1
	push	OFFSET $SG232086
	mov	ecx, esi
	mov	DWORD PTR [esi+7644], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6501 : 	m_iCULTURE_COST_VISIBLE_DIVISOR = getDefineINT("CULTURE_COST_VISIBLE_DIVISOR");

	push	1
	push	OFFSET $SG232087
	mov	ecx, esi
	mov	DWORD PTR [esi+7648], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6502 : 	m_iCULTURE_PLOT_COST_MOD_MINIMUM = getDefineINT("CULTURE_PLOT_COST_MOD_MINIMUM");

	push	1
	push	OFFSET $SG232088
	mov	ecx, esi
	mov	DWORD PTR [esi+7652], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6503 : 	m_iMINOR_CIV_PLOT_CULTURE_COST_MULTIPLIER = getDefineINT("MINOR_CIV_PLOT_CULTURE_COST_MULTIPLIER");

	push	1
	push	OFFSET $SG232089
	mov	ecx, esi
	mov	DWORD PTR [esi+7656], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+7660], eax

; 6504 : 	m_iMAXIMUM_BUY_PLOT_DISTANCE = getDefineINT("MAXIMUM_BUY_PLOT_DISTANCE");

	push	1
	push	OFFSET $SG232090
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6505 : 	m_iMAXIMUM_ACQUIRE_PLOT_DISTANCE = getDefineINT("MAXIMUM_ACQUIRE_PLOT_DISTANCE");

	push	1
	push	OFFSET $SG232091
	mov	ecx, esi
	mov	DWORD PTR [esi+7664], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6506 : 	m_iPLOT_INFLUENCE_BASE_MULTIPLIER = getDefineINT("PLOT_INFLUENCE_BASE_MULTIPLIER");

	push	1
	push	OFFSET $SG232092
	mov	ecx, esi
	mov	DWORD PTR [esi+7668], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6507 : 	m_iPLOT_INFLUENCE_DISTANCE_MULTIPLIER = getDefineINT("PLOT_INFLUENCE_DISTANCE_MULTIPLIER");

	push	1
	push	OFFSET $SG232093
	mov	ecx, esi
	mov	DWORD PTR [esi+7672], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6508 : 	m_iPLOT_INFLUENCE_DISTANCE_DIVISOR = getDefineINT("PLOT_INFLUENCE_DISTANCE_DIVISOR");

	push	1
	push	OFFSET $SG232094
	mov	ecx, esi
	mov	DWORD PTR [esi+7676], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6509 : 	m_iPLOT_INFLUENCE_RING_COST = getDefineINT("PLOT_INFLUENCE_RING_COST");

	push	1
	push	OFFSET $SG232095
	mov	ecx, esi
	mov	DWORD PTR [esi+7680], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6510 : 	m_iPLOT_INFLUENCE_WATER_COST = getDefineINT("PLOT_INFLUENCE_WATER_COST");

	push	1
	push	OFFSET $SG232096
	mov	ecx, esi
	mov	DWORD PTR [esi+7684], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6511 : 	m_iPLOT_INFLUENCE_IMPROVEMENT_COST = getDefineINT("PLOT_INFLUENCE_IMPROVEMENT_COST");

	push	1
	push	OFFSET $SG232097
	mov	ecx, esi
	mov	DWORD PTR [esi+7688], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6512 : 	m_iPLOT_INFLUENCE_ROUTE_COST = getDefineINT("PLOT_INFLUENCE_ROUTE_COST");

	push	1
	push	OFFSET $SG232098
	mov	ecx, esi
	mov	DWORD PTR [esi+7692], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6513 : 	m_iPLOT_INFLUENCE_RESOURCE_COST = getDefineINT("PLOT_INFLUENCE_RESOURCE_COST");

	push	1
	push	OFFSET $SG232099
	mov	ecx, esi
	mov	DWORD PTR [esi+7696], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6514 : 	m_iPLOT_INFLUENCE_NW_COST = getDefineINT("PLOT_INFLUENCE_NW_COST");

	push	1
	push	OFFSET $SG232100
	mov	ecx, esi
	mov	DWORD PTR [esi+7700], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6515 : 	m_iPLOT_BUY_RESOURCE_COST = getDefineINT("PLOT_BUY_RESOURCE_COST");

	push	1
	push	OFFSET $SG232101
	mov	ecx, esi
	mov	DWORD PTR [esi+7704], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6516 : 	m_iPLOT_BUY_YIELD_COST = getDefineINT("PLOT_BUY_YIELD_COST");

	push	1
	push	OFFSET $SG232102
	mov	ecx, esi
	mov	DWORD PTR [esi+7708], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6517 : 	m_iPLOT_INFLUENCE_YIELD_POINT_COST = getDefineINT("PLOT_INFLUENCE_YIELD_POINT_COST");

	push	1
	push	OFFSET $SG232103
	mov	ecx, esi
	mov	DWORD PTR [esi+7712], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6518 : 	m_iPLOT_INFLUENCE_NO_ADJACENT_OWNED_COST = getDefineINT("PLOT_INFLUENCE_NO_ADJACENT_OWNED_COST");

	push	1
	push	OFFSET $SG232104
	mov	ecx, esi
	mov	DWORD PTR [esi+7716], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6519 : 	m_iUNITED_NATIONS_COUNTDOWN_TURNS = getDefineINT("UNITED_NATIONS_COUNTDOWN_TURNS");

	push	1
	push	OFFSET $SG232105
	mov	ecx, esi
	mov	DWORD PTR [esi+7720], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+7724], eax

; 6520 : 	m_iOWN_UNITED_NATIONS_VOTE_BONUS = getDefineINT("OWN_UNITED_NATIONS_VOTE_BONUS");

	push	1
	push	OFFSET $SG232106
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6521 : 	m_iDIPLO_VICTORY_ALGORITHM_THRESHOLD = getDefineINT("DIPLO_VICTORY_ALGORITHM_THRESHOLD");

	push	1
	push	OFFSET $SG232107
	mov	ecx, esi
	mov	DWORD PTR [esi+7728], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6522 : 	m_iDIPLO_VICTORY_BEYOND_ALGORITHM_MULTIPLIER = getDefineINT("DIPLO_VICTORY_BEYOND_ALGORITHM_MULTIPLIER");

	push	1
	push	OFFSET $SG232108
	mov	ecx, esi
	mov	DWORD PTR [esi+7732], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6523 : 	m_iDIPLO_VICTORY_DEFAULT_VOTE_PERCENT = getDefineINT("DIPLO_VICTORY_DEFAULT_VOTE_PERCENT");

	push	1
	push	OFFSET $SG232109
	mov	ecx, esi
	mov	DWORD PTR [esi+7736], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6524 : 	m_iSCORE_CITY_MULTIPLIER = getDefineINT("SCORE_CITY_MULTIPLIER");

	push	1
	push	OFFSET $SG232110
	mov	ecx, esi
	mov	DWORD PTR [esi+7740], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6525 : 	m_iSCORE_POPULATION_MULTIPLIER = getDefineINT("SCORE_POPULATION_MULTIPLIER");

	push	1
	push	OFFSET $SG232111
	mov	ecx, esi
	mov	DWORD PTR [esi+7744], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6526 : 	m_iSCORE_LAND_MULTIPLIER = getDefineINT("SCORE_LAND_MULTIPLIER");

	push	1
	push	OFFSET $SG232112
	mov	ecx, esi
	mov	DWORD PTR [esi+7748], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6527 : 	m_iSCORE_WONDER_MULTIPLIER = getDefineINT("SCORE_WONDER_MULTIPLIER");

	push	1
	push	OFFSET $SG232113
	mov	ecx, esi
	mov	DWORD PTR [esi+7752], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6528 : 	m_iSCORE_TECH_MULTIPLIER = getDefineINT("SCORE_TECH_MULTIPLIER");

	push	1
	push	OFFSET $SG232114
	mov	ecx, esi
	mov	DWORD PTR [esi+7756], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6529 : 	m_iSCORE_FUTURE_TECH_MULTIPLIER = getDefineINT("SCORE_FUTURE_TECH_MULTIPLIER");

	push	1
	push	OFFSET $SG232115
	mov	ecx, esi
	mov	DWORD PTR [esi+7760], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6530 : 	m_iSCORE_POLICY_MULTIPLIER = getDefineINT("SCORE_POLICY_MULTIPLIER");

	push	1
	push	OFFSET $SG232116
	mov	ecx, esi
	mov	DWORD PTR [esi+7764], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6531 : 	m_iSCORE_GREAT_WORK_MULTIPLIER = getDefineINT("SCORE_GREAT_WORK_MULTIPLIER");

	push	1
	push	OFFSET $SG232117
	mov	ecx, esi
	mov	DWORD PTR [esi+7768], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6532 : 	m_iSCORE_BELIEF_MULTIPLIER = getDefineINT("SCORE_BELIEF_MULTIPLIER");

	push	1
	push	OFFSET $SG232118
	mov	ecx, esi
	mov	DWORD PTR [esi+7772], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6533 : 	m_iSCORE_RELIGION_CITIES_MULTIPLIER = getDefineINT("SCORE_RELIGION_CITIES_MULTIPLIER");

	push	1
	push	OFFSET $SG232119
	mov	ecx, esi
	mov	DWORD PTR [esi+7776], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6534 : 	m_iVICTORY_POINTS_PER_ERA = getDefineINT("VICTORY_POINTS_PER_ERA");

	push	1
	push	OFFSET $SG232120
	mov	ecx, esi
	mov	DWORD PTR [esi+7780], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6535 : 	m_iMIN_GAME_TURNS_ELAPSED_TO_TEST_VICTORY = getDefineINT("MIN_GAME_TURNS_ELAPSED_TO_TEST_VICTORY");

	push	1
	push	OFFSET $SG232121
	mov	ecx, esi
	mov	DWORD PTR [esi+7784], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6536 : 	m_iZERO_SUM_COMPETITION_WONDERS_VICTORY_POINTS = getDefineINT("ZERO_SUM_COMPETITION_WONDERS_VICTORY_POINTS");

	push	1
	mov	DWORD PTR [esi+7788], eax
	push	OFFSET $SG232122
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6537 : 	m_iZERO_SUM_COMPETITION_POLICIES_VICTORY_POINTS = getDefineINT("ZERO_SUM_COMPETITION_POLICIES_VICTORY_POINTS");

	push	1
	push	OFFSET $SG232123
	mov	ecx, esi
	mov	DWORD PTR [esi+7792], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6538 : 	m_iZERO_SUM_COMPETITION_GREAT_PEOPLE_VICTORY_POINTS = getDefineINT("ZERO_SUM_COMPETITION_GREAT_PEOPLE_VICTORY_POINTS");

	push	1
	push	OFFSET $SG232124
	mov	ecx, esi
	mov	DWORD PTR [esi+7796], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6539 : 	m_iMAX_CITY_DIST_HIGHWATER_MARK = getDefineINT("MAX_CITY_DIST_HIGHWATER_MARK");

	push	1
	push	OFFSET $SG232125
	mov	ecx, esi
	mov	DWORD PTR [esi+7800], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6540 : 	m_iHEAVY_RESOURCE_THRESHOLD = getDefineINT("HEAVY_RESOURCE_THRESHOLD");

	push	1
	push	OFFSET $SG232126
	mov	ecx, esi
	mov	DWORD PTR [esi+7804], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6541 : 	m_iPROGRESS_POPUP_TURN_FREQUENCY = getDefineINT("PROGRESS_POPUP_TURN_FREQUENCY");

	push	1
	push	OFFSET $SG232127
	mov	ecx, esi
	mov	DWORD PTR [esi+7808], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6542 : 	m_iSETTLER_PRODUCTION_SPEED = getDefineINT("SETTLER_PRODUCTION_SPEED");

	push	1
	push	OFFSET $SG232128
	mov	ecx, esi
	mov	DWORD PTR [esi+7812], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6543 : 	m_iBUY_PLOTS_DISABLED = getDefineINT("BUY_PLOTS_DISABLED");

	push	1
	push	OFFSET $SG232129
	mov	ecx, esi
	mov	DWORD PTR [esi+7816], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6544 : 	m_iCITY_STRENGTH_TECH_MULTIPLIER = getDefineINT("CITY_STRENGTH_TECH_MULTIPLIER");

	push	1
	push	OFFSET $SG232130
	mov	ecx, esi
	mov	DWORD PTR [esi+7820], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6545 : 	m_iWARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT = getDefineINT("WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT");

	push	1
	push	OFFSET $SG232131
	mov	ecx, esi
	mov	DWORD PTR [esi+7824], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6546 : 	m_iBUILDING_SALE_DIVISOR = getDefineINT("BUILDING_SALE_DIVISOR");

	push	1
	push	OFFSET $SG232132
	mov	ecx, esi
	mov	DWORD PTR [esi+7828], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6547 : 	m_iDISBAND_UNIT_REFUND_PERCENT = getDefineINT("DISBAND_UNIT_REFUND_PERCENT");

	push	1
	push	OFFSET $SG232133
	mov	ecx, esi
	mov	DWORD PTR [esi+7832], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6548 : 	m_iMINOR_CIV_ROUTE_QUEST_WEIGHT = getDefineINT("MINOR_CIV_ROUTE_QUEST_WEIGHT");

	push	1
	push	OFFSET $SG232134
	mov	ecx, esi
	mov	DWORD PTR [esi+7836], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6549 : 	m_iWITHDRAW_MOD_ENEMY_MOVES = getDefineINT("WITHDRAW_MOD_ENEMY_MOVES");

	push	1
	push	OFFSET $SG232135
	mov	ecx, esi
	mov	DWORD PTR [esi+7840], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6550 : 	m_iWITHDRAW_MOD_BLOCKED_TILE = getDefineINT("WITHDRAW_MOD_BLOCKED_TILE");

	push	1
	push	OFFSET $SG232136
	mov	ecx, esi
	mov	DWORD PTR [esi+7844], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6551 : 	m_iAI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT = getDefineINT("AI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT");

	push	1
	push	OFFSET $SG232137
	mov	ecx, esi
	mov	DWORD PTR [esi+7848], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6552 : 	m_iAI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY = getDefineINT("AI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY");

	push	1
	mov	DWORD PTR [esi+7852], eax
	push	OFFSET $SG232138
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6553 : 
; 6554 : 	// -- floats --
; 6555 : 
; 6556 : 	m_fDIPLO_VICTORY_CIV_DELEGATES_COEFFICIENT = getDefineFLOAT("DIPLO_VICTORY_CIV_DELEGATES_COEFFICIENT");

	push	1
	push	OFFSET $SG232139
	mov	ecx, esi
	mov	DWORD PTR [esi+7856], eax
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+7984]

; 6557 : 	m_fDIPLO_VICTORY_CIV_DELEGATES_CONSTANT = getDefineFLOAT("DIPLO_VICTORY_CIV_DELEGATES_CONSTANT");

	push	1
	push	OFFSET $SG232140
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+7988]

; 6558 : 	m_fDIPLO_VICTORY_CS_DELEGATES_COEFFICIENT = getDefineFLOAT("DIPLO_VICTORY_CS_DELEGATES_COEFFICIENT");

	push	1
	push	OFFSET $SG232141
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+7992]

; 6559 : 	m_fDIPLO_VICTORY_CS_DELEGATES_CONSTANT = getDefineFLOAT("DIPLO_VICTORY_CS_DELEGATES_CONSTANT");

	push	1
	push	OFFSET $SG232142
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+7996]

; 6560 : 	m_fAI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT = getDefineFLOAT("AI_PRODUCTION_WEIGHT_MOD_PER_TURN_LEFT");

	push	1
	push	OFFSET $SG232143
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8000]

; 6561 : 	m_fAI_PRODUCTION_WEIGHT_BASE_MOD = getDefineFLOAT("AI_PRODUCTION_WEIGHT_BASE_MOD");

	push	1
	push	OFFSET $SG232144
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8004]

; 6562 : 	m_fAI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT = getDefineFLOAT("AI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT");

	push	1
	push	OFFSET $SG232145
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8008]

; 6563 : 	m_fAI_RESEARCH_WEIGHT_BASE_MOD = getDefineFLOAT("AI_RESEARCH_WEIGHT_BASE_MOD");

	push	1
	push	OFFSET $SG232146
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8012]

; 6564 : 	m_fHURRY_GOLD_PRODUCTION_EXPONENT = getDefineFLOAT("HURRY_GOLD_PRODUCTION_EXPONENT");

	push	1
	push	OFFSET $SG232147
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8016]

; 6565 : 	m_fCITY_ZOOM_LEVEL_1 = getDefineFLOAT("CITY_ZOOM_LEVEL_1");

	push	1
	push	OFFSET $SG232148
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8020]

; 6566 : 	m_fCITY_ZOOM_LEVEL_2 = getDefineFLOAT("CITY_ZOOM_LEVEL_2");

	push	1
	push	OFFSET $SG232149
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8024]

; 6567 : 	m_fCITY_ZOOM_LEVEL_3 = getDefineFLOAT("CITY_ZOOM_LEVEL_3");

	push	1
	push	OFFSET $SG232150
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8028]

; 6568 : 	m_fCITY_ZOOM_OFFSET = getDefineFLOAT("CITY_ZOOM_OFFSET");

	push	1
	push	OFFSET $SG232151
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8032]

; 6569 : 	m_fCULTURE_COST_LATER_PLOT_EXPONENT = getDefineFLOAT("CULTURE_COST_LATER_PLOT_EXPONENT");

	push	1
	push	OFFSET $SG232152
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8036]

; 6570 : 	m_fPOST_COMBAT_TEXT_DELAY = getDefineFLOAT("POST_COMBAT_TEXT_DELAY");

	push	1
	push	OFFSET $SG232153
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8040]

; 6571 : 	m_fAI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_NEXT_WONDER = getDefineFLOAT("AI_CITY_SPECIALIZATION_PRODUCTION_WEIGHT_NEXT_WONDER");

	push	1
	push	OFFSET $SG232154
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT

; 6572 : 	m_fAI_DANGER_MAJOR_APPROACH_WAR = getDefineFLOAT("AI_DANGER_MAJOR_APPROACH_WAR");

	push	1
	fstp	DWORD PTR [esi+8044]
	push	OFFSET $SG232155
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8048]

; 6573 : 	m_fAI_DANGER_MAJOR_APPROACH_HOSTILE = getDefineFLOAT("AI_DANGER_MAJOR_APPROACH_HOSTILE");

	push	1
	push	OFFSET $SG232156
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8052]

; 6574 : 	m_fAI_DANGER_MAJOR_APPROACH_DECEPTIVE = getDefineFLOAT("AI_DANGER_MAJOR_APPROACH_DECEPTIVE");

	push	1
	push	OFFSET $SG232157
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8056]

; 6575 : 	m_fAI_DANGER_MAJOR_APPROACH_GUARDED = getDefineFLOAT("AI_DANGER_MAJOR_APPROACH_GUARDED");

	push	1
	push	OFFSET $SG232158
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8060]

; 6576 : 	m_fAI_DANGER_MAJOR_APPROACH_AFRAID = getDefineFLOAT("AI_DANGER_MAJOR_APPROACH_AFRAID");

	push	1
	push	OFFSET $SG232159
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8064]

; 6577 : 	m_fAI_DANGER_MAJOR_APPROACH_FRIENDLY = getDefineFLOAT("AI_DANGER_MAJOR_APPROACH_FRIENDLY");

	push	1
	push	OFFSET $SG232160
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8068]

; 6578 : 	m_fAI_DANGER_MAJOR_APPROACH_NEUTRAL = getDefineFLOAT("AI_DANGER_MAJOR_APPROACH_NEUTRAL");

	push	1
	push	OFFSET $SG232161
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8072]

; 6579 : 	m_fAI_DANGER_MINOR_APPROACH_NEUTRAL = getDefineFLOAT("AI_DANGER_MINOR_APPROACH_NEUTRAL");

	push	1
	push	OFFSET $SG232162
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8076]

; 6580 : 	m_fAI_DANGER_MINOR_APPROACH_FRIENDLY = getDefineFLOAT("AI_DANGER_MINOR_APPROACH_FRIENDLY");

	push	1
	push	OFFSET $SG232163
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8080]

; 6581 : 	m_fAI_DANGER_MINOR_APPROACH_BULLY = getDefineFLOAT("AI_DANGER_MINOR_APPROACH_BULLY");

	push	1
	push	OFFSET $SG232164
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8084]

; 6582 : 	m_fAI_DANGER_MINOR_APPROACH_CONQUEST = getDefineFLOAT("AI_DANGER_MINOR_APPROACH_CONQUEST");

	push	1
	push	OFFSET $SG232165
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8088]

; 6583 : 	m_fFLAVOR_STANDARD_LOG10_TILES_PER_PLAYER = getDefineFLOAT("FLAVOR_STANDARD_LOG10_TILES_PER_PLAYER");

	push	1
	push	OFFSET $SG232166
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8092]

; 6584 : 	m_fDIPLO_VICTORY_TEAM_MULTIPLIER = getDefineFLOAT("DIPLO_VICTORY_TEAM_MULTIPLIER");

	push	1
	push	OFFSET $SG232167
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8096]

; 6585 : 	m_fAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION = getDefineFLOAT("AI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION");

	push	1
	push	OFFSET $SG232168
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8100]

; 6586 : 	m_fAI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY = getDefineFLOAT("AI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY");

	push	1
	push	OFFSET $SG232169
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8104]

; 6587 : 	m_fAI_STRATEGY_NAVAL_UNITS_PER_CITY = getDefineFLOAT("AI_STRATEGY_NAVAL_UNITS_PER_CITY");

	push	1
	push	OFFSET $SG232170
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8108]

; 6588 : 	m_fGOLD_GIFT_FRIENDSHIP_EXPONENT = getDefineFLOAT("GOLD_GIFT_FRIENDSHIP_EXPONENT");

	push	1
	push	OFFSET $SG232171
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8112]

; 6589 : 	m_fGOLD_GIFT_FRIENDSHIP_DIVISOR = getDefineFLOAT("GOLD_GIFT_FRIENDSHIP_DIVISOR");

	push	1
	push	OFFSET $SG232172
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8116]

; 6590 : 	m_fHURRY_GOLD_TECH_EXPONENT = getDefineFLOAT("HURRY_GOLD_TECH_EXPONENT");

	push	1
	push	OFFSET $SG232173
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8120]

; 6591 : 	m_fHURRY_GOLD_CULTURE_EXPONENT = getDefineFLOAT("HURRY_GOLD_CULTURE_EXPONENT");

	push	1
	push	OFFSET $SG232174
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8124]

; 6592 : 	m_fCITY_GROWTH_MULTIPLIER = getDefineFLOAT("CITY_GROWTH_MULTIPLIER");

	push	1
	push	OFFSET $SG232175
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8128]

; 6593 : 	m_fCITY_GROWTH_EXPONENT = getDefineFLOAT("CITY_GROWTH_EXPONENT");

	push	1
	push	OFFSET $SG232176
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8132]

; 6594 : 	m_fPOLICY_COST_EXPONENT = getDefineFLOAT("POLICY_COST_EXPONENT");

	push	1
	push	OFFSET $SG232177
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8136]

; 6595 : 	m_fUNIT_UPGRADE_COST_MULTIPLIER_PER_ERA = getDefineFLOAT("UNIT_UPGRADE_COST_MULTIPLIER_PER_ERA");

	push	1
	push	OFFSET $SG232178
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8140]

; 6596 : 	m_fUNIT_UPGRADE_COST_EXPONENT = getDefineFLOAT("UNIT_UPGRADE_COST_EXPONENT");

	push	1
	push	OFFSET $SG232179
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8144]

; 6597 : 	m_fCITY_STRENGTH_TECH_BASE = getDefineFLOAT("CITY_STRENGTH_TECH_BASE");

	push	1
	push	OFFSET $SG232180
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8148]

; 6598 : 	m_fCITY_STRENGTH_TECH_EXPONENT = getDefineFLOAT("CITY_STRENGTH_TECH_EXPONENT");

	push	1
	push	OFFSET $SG232181
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8152]

; 6599 : 	m_fESPIONAGE_COUP_NOBODY_BONUS = getDefineFLOAT("ESPIONAGE_COUP_NOBODY_BONUS");

	push	1
	push	OFFSET $SG232182
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8156]

; 6600 : 	m_fESPIONAGE_COUP_MULTIPLY_CONSTANT = getDefineFLOAT("ESPIONAGE_COUP_MULTIPLY_CONSTANT");

	push	1
	push	OFFSET $SG232183
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8160]

; 6601 : 	m_fESPIONAGE_COUP_SPY_LEVEL_DELTA_ZERO = getDefineFLOAT("ESPIONAGE_COUP_SPY_LEVEL_DELTA_ZERO");

	push	1
	push	OFFSET $SG232184
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8164]

; 6602 : 	m_fESPIONAGE_COUP_SPY_LEVEL_DELTA_ONE = getDefineFLOAT("ESPIONAGE_COUP_SPY_LEVEL_DELTA_ONE");

	push	1
	push	OFFSET $SG232185
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8168]

; 6603 : 	m_fESPIONAGE_COUP_SPY_LEVEL_DELTA_TWO = getDefineFLOAT("ESPIONAGE_COUP_SPY_LEVEL_DELTA_TWO");

	push	1
	push	OFFSET $SG232186
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8172]

; 6604 : 	m_fESPIONAGE_COUP_SPY_LEVEL_DELTA_THREE = getDefineFLOAT("ESPIONAGE_COUP_SPY_LEVEL_DELTA_THREE");

	push	1
	push	OFFSET $SG232187
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8176]

; 6605 : 	m_fESPIONAGE_COUP_SPY_LEVEL_DELTA_FOUR = getDefineFLOAT("ESPIONAGE_COUP_SPY_LEVEL_DELTA_FOUR");

	push	1
	push	OFFSET $SG232188
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8180]

; 6606 : 	m_iINTERNATIONAL_TRADE_BASE = getDefineINT("INTERNATIONAL_TRADE_BASE");

	push	1
	push	OFFSET $SG232189
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6607 : 	m_iINTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION = getDefineINT("INTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION");

	push	1
	push	OFFSET $SG232190
	mov	ecx, esi
	mov	DWORD PTR [esi+7956], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6608 : 	m_iINTERNATIONAL_TRADE_CITY_GPT_DIVISOR = getDefineINT("INTERNATIONAL_TRADE_CITY_GPT_DIVISOR");

	push	1
	push	OFFSET $SG232191
	mov	ecx, esi
	mov	DWORD PTR [esi+7960], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6609 : 	m_iPILLAGE_HEAL_AMOUNT = getDefineINT("PILLAGE_HEAL_AMOUNT");

	push	1
	push	OFFSET $SG232192
	mov	ecx, esi
	mov	DWORD PTR [esi+7964], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6610 : 	m_iCITY_CONNECTIONS_CONNECT_TO_CAPITAL = getDefineINT("CITY_CONNECTIONS_CONNECT_TO_CAPITAL");

	push	1
	push	OFFSET $SG232193
	mov	ecx, esi
	mov	DWORD PTR [esi+8184], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6611 : 	m_fUNRESEARCHED_TECH_FROM_KILLS_SLOPE = getDefineFLOAT("UNRESEARCHED_TECH_BONUS_FROM_KILLS_SLOPE");

	push	1
	push	OFFSET $SG232194
	mov	ecx, esi
	mov	DWORD PTR [esi+8188], eax
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8200]

; 6612 : 	m_fUNRESEARCHED_TECH_FROM_KILLS_INTERCEPT = getDefineFLOAT("UNRESEARCHED_TECH_BONUS_FROM_KILLS_INTERCEPT");

	push	1
	push	OFFSET $SG232195
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8204]

; 6613 : 	m_iBASE_CULTURE_PER_GREAT_WORK = getDefineINT("BASE_CULTURE_PER_GREAT_WORK");

	push	1
	push	OFFSET $SG232196
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6614 : 	m_iBASE_TOURISM_PER_GREAT_WORK = getDefineINT("BASE_TOURISM_PER_GREAT_WORK");

	push	1
	push	OFFSET $SG232197
	mov	ecx, esi
	mov	DWORD PTR [esi+8208], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6615 : 	m_iTOURISM_MODIFIER_SHARED_RELIGION = getDefineINT("TOURISM_MODIFIER_SHARED_RELIGION");

	push	1
	push	OFFSET $SG232198
	mov	ecx, esi
	mov	DWORD PTR [esi+8212], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6616 : 	m_iTOURISM_MODIFIER_TRADE_ROUTE = getDefineINT("TOURISM_MODIFIER_TRADE_ROUTE");

	push	1
	push	OFFSET $SG232199
	mov	ecx, esi
	mov	DWORD PTR [esi+8216], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6617 : 	m_iTOURISM_MODIFIER_OPEN_BORDERS = getDefineINT("TOURISM_MODIFIER_OPEN_BORDERS");

	push	1
	push	OFFSET $SG232200
	mov	ecx, esi
	mov	DWORD PTR [esi+8220], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6618 : 	m_iTOURISM_MODIFIER_DIFFERENT_IDEOLOGIES = getDefineINT("TOURISM_MODIFIER_DIFFERENT_IDEOLOGIES");

	push	1
	push	OFFSET $SG232201
	mov	ecx, esi
	mov	DWORD PTR [esi+8224], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6619 : 	m_iTOURISM_MODIFIER_DIPLOMAT = getDefineINT("TOURISM_MODIFIER_DIPLOMAT");

	push	1
	push	OFFSET $SG232202
	mov	ecx, esi
	mov	DWORD PTR [esi+8228], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6620 : 	m_iMINIUMUM_TOURISM_BLAST_STRENGTH = getDefineINT("MINIUMUM_TOURISM_BLAST_STRENGTH");

	push	1
	mov	DWORD PTR [esi+8232], eax
	push	OFFSET $SG232203
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6621 : 	m_iCULTURE_LEVEL_EXOTIC = getDefineINT("CULTURE_LEVEL_EXOTIC");

	push	1
	push	OFFSET $SG232204
	mov	ecx, esi
	mov	DWORD PTR [esi+8236], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6622 : 	m_iCULTURE_LEVEL_FAMILIAR = getDefineINT("CULTURE_LEVEL_FAMILIAR");

	push	1
	push	OFFSET $SG232205
	mov	ecx, esi
	mov	DWORD PTR [esi+8240], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6623 : 	m_iCULTURE_LEVEL_POPULAR = getDefineINT("CULTURE_LEVEL_POPULAR");

	push	1
	push	OFFSET $SG232206
	mov	ecx, esi
	mov	DWORD PTR [esi+8244], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6624 : 	m_iCULTURE_LEVEL_INFLUENTIAL = getDefineINT("CULTURE_LEVEL_INFLUENTIAL");

	push	1
	push	OFFSET $SG232207
	mov	ecx, esi
	mov	DWORD PTR [esi+8248], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6625 : 	m_iCULTURE_LEVEL_DOMINANT = getDefineINT("CULTURE_LEVEL_DOMINANT");

	push	1
	push	OFFSET $SG232208
	mov	ecx, esi
	mov	DWORD PTR [esi+8252], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6626 : 	m_iMIN_DIG_SITES_PER_MAJOR_CIV = getDefineINT("MIN_DIG_SITES_PER_MAJOR_CIV");

	push	1
	push	OFFSET $SG232209
	mov	ecx, esi
	mov	DWORD PTR [esi+8256], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6627 : 	m_iMAX_DIG_SITES_PER_MAJOR_CIV = getDefineINT("MAX_DIG_SITES_PER_MAJOR_CIV");

	push	1
	push	OFFSET $SG232210
	mov	ecx, esi
	mov	DWORD PTR [esi+8260], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6628 : 	m_iPERCENT_SITES_HIDDEN = getDefineINT("PERCENT_SITES_HIDDEN");

	push	1
	push	OFFSET $SG232211
	mov	ecx, esi
	mov	DWORD PTR [esi+8264], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6629 : 	m_iPERCENT_HIDDEN_SITES_WRITING = getDefineINT("PERCENT_HIDDEN_SITES_WRITING");

	push	1
	push	OFFSET $SG232212
	mov	ecx, esi
	mov	DWORD PTR [esi+8268], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6630 : 	m_iSAPPED_CITY_ATTACK_MODIFIER = getDefineINT("SAPPED_CITY_ATTACK_MODIFIER");

	push	1
	push	OFFSET $SG232213
	mov	ecx, esi
	mov	DWORD PTR [esi+8272], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6631 : 	m_iSAPPER_BONUS_RANGE = getDefineINT("SAPPER_BONUS_RANGE");

	push	1
	push	OFFSET $SG232214
	mov	ecx, esi
	mov	DWORD PTR [esi+8276], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6632 : 	m_iEXOTIC_GOODS_GOLD_MIN = getDefineINT("EXOTIC_GOODS_GOLD_MIN");

	push	1
	push	OFFSET $SG232215
	mov	ecx, esi
	mov	DWORD PTR [esi+8280], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6633 : 	m_iEXOTIC_GOODS_GOLD_MAX = getDefineINT("EXOTIC_GOODS_GOLD_MAX");

	push	1
	push	OFFSET $SG232216
	mov	ecx, esi
	mov	DWORD PTR [esi+8284], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6634 : 	m_iEXOTIC_GOODS_XP_MIN = getDefineINT("EXOTIC_GOODS_XP_MIN");

	push	1
	push	OFFSET $SG232217
	mov	ecx, esi
	mov	DWORD PTR [esi+8288], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6635 : 	m_iEXOTIC_GOODS_XP_MAX = getDefineINT("EXOTIC_GOODS_XP_MAX");

	push	1
	push	OFFSET $SG232218
	mov	ecx, esi
	mov	DWORD PTR [esi+8292], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6636 : 	m_iTEMPORARY_CULTURE_BOOST_MOD = getDefineINT("TEMPORARY_CULTURE_BOOST_MOD");

	push	1
	mov	DWORD PTR [esi+8296], eax
	push	OFFSET $SG232219
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6637 : 	m_iTEMPORARY_TOURISM_BOOST_MOD = getDefineINT("TEMPORARY_TOURISM_BOOST_MOD");

	push	1
	push	OFFSET $SG232220
	mov	ecx, esi
	mov	DWORD PTR [esi+8300], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6638 : 	m_iLEAGUE_SESSION_INTERVAL_BASE_TURNS = getDefineINT("LEAGUE_SESSION_INTERVAL_BASE_TURNS");

	push	1
	push	OFFSET $SG232221
	mov	ecx, esi
	mov	DWORD PTR [esi+8304], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6639 : 	m_iLEAGUE_SESSION_SOON_WARNING_TURNS = getDefineINT("LEAGUE_SESSION_SOON_WARNING_TURNS");

	push	1
	push	OFFSET $SG232222
	mov	ecx, esi
	mov	DWORD PTR [esi+8308], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6640 : 	m_iLEAGUE_MEMBER_PROPOSALS_BASE = getDefineINT("LEAGUE_MEMBER_PROPOSALS_BASE");

	push	1
	push	OFFSET $SG232223
	mov	ecx, esi
	mov	DWORD PTR [esi+8312], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6641 : 	m_iLEAGUE_MEMBER_VOTES_BASE = getDefineINT("LEAGUE_MEMBER_VOTES_BASE");

	push	1
	push	OFFSET $SG232224
	mov	ecx, esi
	mov	DWORD PTR [esi+8316], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6642 : 	m_iLEAGUE_MEMBER_VOTES_FOR_HOST = getDefineINT("LEAGUE_MEMBER_VOTES_FOR_HOST");

	push	1
	push	OFFSET $SG232225
	mov	ecx, esi
	mov	DWORD PTR [esi+8320], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6643 : 	m_iLEAGUE_MEMBER_VOTES_PER_CITY_STATE_ALLY = getDefineINT("LEAGUE_MEMBER_VOTES_PER_CITY_STATE_ALLY");

	push	1
	push	OFFSET $SG232226
	mov	ecx, esi
	mov	DWORD PTR [esi+8324], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6644 : 	m_fLEAGUE_PROJECT_REWARD_TIER_1_THRESHOLD = getDefineFLOAT("LEAGUE_PROJECT_REWARD_TIER_1_THRESHOLD");

	push	1
	push	OFFSET $SG232227
	mov	ecx, esi
	mov	DWORD PTR [esi+8328], eax
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8332]

; 6645 : 	m_fLEAGUE_PROJECT_REWARD_TIER_2_THRESHOLD = getDefineFLOAT("LEAGUE_PROJECT_REWARD_TIER_2_THRESHOLD");

	push	1
	push	OFFSET $SG232228
	mov	ecx, esi
	call	?getDefineFLOAT@CvGlobals@@IAEMPBD_N@Z	; CvGlobals::getDefineFLOAT
	fstp	DWORD PTR [esi+8336]

; 6646 : 
; 6647 : 	// -- post defines --
; 6648 : 
; 6649 : 	m_iLAND_TERRAIN = getDefineINT("LAND_TERRAIN");

	push	1
	push	OFFSET $SG232229
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6650 : 	m_iDEEP_WATER_TERRAIN = getDefineINT("DEEP_WATER_TERRAIN");

	push	1
	push	OFFSET $SG232230
	mov	ecx, esi
	mov	DWORD PTR [esi+8388], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6651 : 	m_iSHALLOW_WATER_TERRAIN = getDefineINT("SHALLOW_WATER_TERRAIN");

	push	1
	push	OFFSET $SG232231
	mov	ecx, esi
	mov	DWORD PTR [esi+8392], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6652 : 	m_iRUINS_IMPROVEMENT = getDefineINT("RUINS_IMPROVEMENT");

	push	1
	push	OFFSET $SG232232
	mov	ecx, esi
	mov	DWORD PTR [esi+8396], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6653 : 	m_iNUKE_FEATURE = getDefineINT("NUKE_FEATURE");

	push	1
	push	OFFSET $SG232233
	mov	ecx, esi
	mov	DWORD PTR [esi+8400], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6654 : 	m_iARTIFACT_RESOURCE = getDefineINT("ARTIFACT_RESOURCE");

	push	1
	push	OFFSET $SG232234
	mov	ecx, esi
	mov	DWORD PTR [esi+8404], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6655 : 	m_iHIDDEN_ARTIFACT_RESOURCE = getDefineINT("HIDDEN_ARTIFACT_RESOURCE");

	push	1
	push	OFFSET $SG232235
	mov	ecx, esi
	mov	DWORD PTR [esi+8408], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6656 : 	m_iCAPITAL_BUILDINGCLASS = getDefineINT("CAPITAL_BUILDINGCLASS");

	push	1
	push	OFFSET $SG232236
	mov	ecx, esi
	mov	DWORD PTR [esi+8412], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6657 : 	m_iDEFAULT_SPECIALIST = getDefineINT("DEFAULT_SPECIALIST");

	push	1
	push	OFFSET $SG232237
	mov	ecx, esi
	mov	DWORD PTR [esi+8416], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6658 : 	m_iSPACE_RACE_TRIGGER_PROJECT = getDefineINT("SPACE_RACE_TRIGGER_PROJECT");

	push	1
	push	OFFSET $SG232238
	mov	ecx, esi
	mov	DWORD PTR [esi+8420], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6659 : 	m_iSPACESHIP_CAPSULE = getDefineINT("SPACESHIP_CAPSULE");

	push	1
	push	OFFSET $SG232239
	mov	ecx, esi
	mov	DWORD PTR [esi+8424], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6660 : 	m_iSPACESHIP_BOOSTER = getDefineINT("SPACESHIP_BOOSTER");

	push	1
	push	OFFSET $SG232240
	mov	ecx, esi
	mov	DWORD PTR [esi+8428], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6661 : 	m_iSPACESHIP_STASIS = getDefineINT("SPACESHIP_STASIS");

	push	1
	push	OFFSET $SG232241
	mov	ecx, esi
	mov	DWORD PTR [esi+8432], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6662 : 	m_iSPACESHIP_ENGINE = getDefineINT("SPACESHIP_ENGINE");

	push	1
	push	OFFSET $SG232242
	mov	ecx, esi
	mov	DWORD PTR [esi+8436], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6663 : 	m_iMANHATTAN_PROJECT = getDefineINT("MANHATTAN_PROJECT");

	push	1
	push	OFFSET $SG232243
	mov	ecx, esi
	mov	DWORD PTR [esi+8440], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6664 : 	m_iINITIAL_CITY_ROUTE_TYPE = getDefineINT("INITIAL_CITY_ROUTE_TYPE");

	push	1
	push	OFFSET $SG232244
	mov	ecx, esi
	mov	DWORD PTR [esi+8444], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6665 : 	m_iSTANDARD_HANDICAP = getDefineINT("STANDARD_HANDICAP");

	push	1
	push	OFFSET $SG232245
	mov	ecx, esi
	mov	DWORD PTR [esi+8448], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6666 : 	m_iMULTIPLAYER_HANDICAP = getDefineINT("MULTIPLAYER_HANDICAP");

	push	1
	push	OFFSET $SG232246
	mov	ecx, esi
	mov	DWORD PTR [esi+8452], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6667 : 	m_iSTANDARD_HANDICAP_QUICK = getDefineINT("STANDARD_HANDICAP_QUICK");

	push	1
	push	OFFSET $SG232247
	mov	ecx, esi
	mov	DWORD PTR [esi+8456], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6668 : 	m_iSTANDARD_GAMESPEED = getDefineINT("STANDARD_GAMESPEED");

	push	1
	push	OFFSET $SG232248
	mov	ecx, esi
	mov	DWORD PTR [esi+8460], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6669 : 	m_iSTANDARD_TURNTIMER = getDefineINT("STANDARD_TURNTIMER");

	push	1
	push	OFFSET $SG232249
	mov	ecx, esi
	mov	DWORD PTR [esi+8464], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6670 : 	m_iSTANDARD_CLIMATE = getDefineINT("STANDARD_CLIMATE");

	push	1
	push	OFFSET $SG232250
	mov	ecx, esi
	mov	DWORD PTR [esi+8468], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6671 : 	m_iSTANDARD_WORLD_SIZE = getDefineINT("STANDARD_WORLD_SIZE");

	push	1
	push	OFFSET $SG232251
	mov	ecx, esi
	mov	DWORD PTR [esi+8472], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+8476], eax

; 6672 : 	m_iSTANDARD_SEALEVEL = getDefineINT("STANDARD_SEALEVEL");

	push	1
	push	OFFSET $SG232252
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6673 : 	m_iSTANDARD_ERA = getDefineINT("STANDARD_ERA");

	push	1
	push	OFFSET $SG232253
	mov	ecx, esi
	mov	DWORD PTR [esi+8480], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6674 : 	m_iLAST_EMBARK_ART_ERA = getDefineINT("LAST_EMBARK_ART_ERA");

	push	1
	push	OFFSET $SG232254
	mov	ecx, esi
	mov	DWORD PTR [esi+8484], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6675 : 	m_iLAST_UNIT_ART_ERA = getDefineINT("LAST_UNIT_ART_ERA");

	push	1
	push	OFFSET $SG232255
	mov	ecx, esi
	mov	DWORD PTR [esi+8488], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6676 : 	m_iLAST_BRIDGE_ART_ERA = getDefineINT("LAST_BRIDGE_ART_ERA");

	push	1
	push	OFFSET $SG232256
	mov	ecx, esi
	mov	DWORD PTR [esi+8492], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6677 : 	m_iSTANDARD_CALENDAR = getDefineINT("STANDARD_CALENDAR");

	push	1
	push	OFFSET $SG232257
	mov	ecx, esi
	mov	DWORD PTR [esi+8496], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6678 : 	m_iBARBARIAN_HANDICAP = getDefineINT("BARBARIAN_HANDICAP");

	push	1
	push	OFFSET $SG232258
	mov	ecx, esi
	mov	DWORD PTR [esi+8500], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6679 : 	m_iBARBARIAN_CIVILIZATION = getDefineINT("BARBARIAN_CIVILIZATION");

	push	1
	push	OFFSET $SG232259
	mov	ecx, esi
	mov	DWORD PTR [esi+8504], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6680 : 	m_iBARBARIAN_LEADER = getDefineINT("BARBARIAN_LEADER");

	push	1
	push	OFFSET $SG232260
	mov	ecx, esi
	mov	DWORD PTR [esi+8508], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6681 : 	m_iMINOR_CIV_HANDICAP = getDefineINT("MINOR_CIV_HANDICAP");

	push	1
	push	OFFSET $SG232261
	mov	ecx, esi
	mov	DWORD PTR [esi+8512], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6682 : 	m_iMINOR_CIVILIZATION = getDefineINT("MINOR_CIVILIZATION");

	push	1
	push	OFFSET $SG232262
	mov	ecx, esi
	mov	DWORD PTR [esi+8516], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6683 : 	m_iPROMOTION_EMBARKATION = getDefineINT("PROMOTION_EMBARKATION");

	push	1
	push	OFFSET $SG232263
	mov	ecx, esi
	mov	DWORD PTR [esi+8520], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6684 : 	m_iPROMOTION_DEFENSIVE_EMBARKATION = getDefineINT("PROMOTION_DEFENSIVE_EMBARKATION");

	push	1
	push	OFFSET $SG232264
	mov	ecx, esi
	mov	DWORD PTR [esi+8524], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6685 : 	m_iPROMOTION_ALLWATER_EMBARKATION = getDefineINT("PROMOTION_ALLWATER_EMBARKATION");

	push	1
	push	OFFSET $SG232265
	mov	ecx, esi
	mov	DWORD PTR [esi+8528], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6686 : 	m_iPROMOTION_OCEAN_IMPASSABLE_UNTIL_ASTRONOMY = getDefineINT("PROMOTION_OCEAN_IMPASSABLE_UNTIL_ASTRONOMY");

	push	1
	push	OFFSET $SG232266
	mov	ecx, esi
	mov	DWORD PTR [esi+8532], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6687 : 	m_iPROMOTION_OCEAN_IMPASSABLE = getDefineINT("PROMOTION_OCEAN_IMPASSABLE");

	push	1
	push	OFFSET $SG232267
	mov	ecx, esi
	mov	DWORD PTR [esi+8536], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+8540], eax

; 6688 : 	m_iAI_HANDICAP = getDefineINT("AI_HANDICAP");

	push	1
	push	OFFSET $SG232268
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6689 : 	m_iBARBARIAN_CAMP_IMPROVEMENT = getDefineINT("BARBARIAN_CAMP_IMPROVEMENT");

	push	1
	push	OFFSET $SG232269
	mov	ecx, esi
	mov	DWORD PTR [esi+8544], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6690 : 	m_iWALLS_BUILDINGCLASS = getDefineINT("WALLS_BUILDINGCLASS");

	push	1
	push	OFFSET $SG232270
	mov	ecx, esi
	mov	DWORD PTR [esi+8548], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6691 : 	m_iPROMOTION_ONLY_DEFENSIVE = getDefineINT("PROMOTION_ONLY_DEFENSIVE");

	push	1
	push	OFFSET $SG232271
	mov	ecx, esi
	mov	DWORD PTR [esi+8552], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6692 : 	m_iPROMOTION_UNWELCOME_EVANGELIST = getDefineINT("PROMOTION_UNWELCOME_EVANGELIST");

	push	1
	push	OFFSET $SG232272
	mov	ecx, esi
	mov	DWORD PTR [esi+8556], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6693 : 	m_iCOMBAT_CAPTURE_HEALTH = getDefineINT("COMBAT_CAPTURE_HEALTH");

	push	1
	push	OFFSET $SG232273
	mov	ecx, esi
	mov	DWORD PTR [esi+8560], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6694 : 	m_iCOMBAT_CAPTURE_MIN_CHANCE = getDefineINT("COMBAT_CAPTURE_MIN_CHANCE");

	push	1
	push	OFFSET $SG232274
	mov	ecx, esi
	mov	DWORD PTR [esi+7968], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6695 : 	m_iCOMBAT_CAPTURE_MAX_CHANCE = getDefineINT("COMBAT_CAPTURE_MAX_CHANCE");

	push	1
	push	OFFSET $SG232275
	mov	ecx, esi
	mov	DWORD PTR [esi+7972], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6696 : 	m_iCOMBAT_CAPTURE_RATIO_MULTIPLIER = getDefineINT("COMBAT_CAPTURE_RATIO_MULTIPLIER");

	push	1
	push	OFFSET $SG232276
	mov	ecx, esi
	mov	DWORD PTR [esi+7976], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6697 : 	m_iRELIGION_MIN_FAITH_FIRST_PANTHEON = GC.getDefineINT("RELIGION_MIN_FAITH_FIRST_PANTHEON");

	push	1
	push	OFFSET $SG232277
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7980], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6698 : 	m_iRELIGION_MIN_FAITH_FIRST_PROPHET = GC.getDefineINT("RELIGION_MIN_FAITH_FIRST_PROPHET");

	push	1
	push	OFFSET $SG232278
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7860], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6699 : 	m_iRELIGION_MIN_FAITH_FIRST_GREAT_PERSON = GC.getDefineINT("RELIGION_MIN_FAITH_FIRST_GREAT_PERSON");

	push	1
	push	OFFSET $SG232279
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7864], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6700 : 	m_iRELIGION_GAME_FAITH_DELTA_NEXT_PANTHEON = GC.getDefineINT("RELIGION_GAME_FAITH_DELTA_NEXT_PANTHEON");

	push	1
	push	OFFSET $SG232280
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7868], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6701 : 	m_iRELIGION_FAITH_DELTA_NEXT_PROPHET = GC.getDefineINT("RELIGION_FAITH_DELTA_NEXT_PROPHET");

	push	1
	push	OFFSET $SG232281
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7872], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6702 : 	m_iRELIGION_FAITH_DELTA_NEXT_GREAT_PERSON = GC.getDefineINT("RELIGION_FAITH_DELTA_NEXT_GREAT_PERSON");

	push	1
	push	OFFSET $SG232282
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7876], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6703 : 	m_iRELIGION_BASE_CHANCE_PROPHET_SPAWN = GC.getDefineINT("RELIGION_BASE_CHANCE_PROPHET_SPAWN");

	push	1
	push	OFFSET $SG232283
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7880], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6704 : 	m_iRELIGION_ATHEISM_PRESSURE_PER_POP = GC.getDefineINT("RELIGION_ATHEISM_PRESSURE_PER_POP");

	push	1
	mov	DWORD PTR [esi+7884], eax
	push	OFFSET $SG232284
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6705 : 	m_iRELIGION_INITIAL_FOUNDING_CITY_PRESSURE = GC.getDefineINT("RELIGION_INITIAL_FOUNDING_CITY_PRESSURE");

	push	1
	push	OFFSET $SG232285
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7888], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6706 : 	m_iRELIGION_PER_TURN_FOUNDING_CITY_PRESSURE = GC.getDefineINT("RELIGION_PER_TURN_FOUNDING_CITY_PRESSURE");

	push	1
	push	OFFSET $SG232286
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7892], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6707 : 	m_iRELIGION_MISSIONARY_PRESSURE_MULTIPLIER = GC.getDefineINT("RELIGION_MISSIONARY_PRESSURE_MULTIPLIER");

	push	1
	push	OFFSET $SG232287
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7896], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6708 : 	m_iRELIGION_ADJACENT_CITY_DISTANCE = GC.getDefineINT("RELIGION_ADJACENT_CITY_DISTANCE");

	push	1
	push	OFFSET $SG232288
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7900], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6709 : 	m_iRELIGION_DIPLO_HIT_INITIAL_CONVERT_FRIENDLY_CITY = GC.getDefineINT("RELIGION_DIPLO_HIT_INITIAL_CONVERT_FRIENDLY_CITY");

	push	1
	push	OFFSET $SG232289
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7904], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6710 : 	m_iRELIGION_DIPLO_HIT_RELIGIOUS_FLIP_FRIENDLY_CITY = GC.getDefineINT("RELIGION_DIPLO_HIT_RELIGIOUS_FLIP_FRIENDLY_CITY");

	push	1
	push	OFFSET $SG232290
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7908], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6711 : 	m_iRELIGION_DIPLO_HIT_CONVERT_HOLY_CITY = GC.getDefineINT("RELIGION_DIPLO_HIT_CONVERT_HOLY_CITY");

	push	1
	push	OFFSET $SG232291
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7912], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6712 : 	m_iRELIGION_DIPLO_HIT_THRESHOLD = GC.getDefineINT("RELIGION_DIPLO_HIT_THRESHOLD");

	push	1
	push	OFFSET $SG232292
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7916], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6713 : 	m_iESPIONAGE_GATHERING_INTEL_COST_PERCENT = GC.getDefineINT("ESPIONAGE_GATHERING_INTEL_COST_PERCENT");

	push	1
	push	OFFSET $SG232293
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7920], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6714 : 	m_iESPIONAGE_GATHERING_INTEL_RATE_BY_SPY_RANK_PERCENT = GC.getDefineINT("ESPIONAGE_GATHERING_INTEL_RATE_BY_SPY_RANK_PERCENT");

	push	1
	push	OFFSET $SG232294
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7924], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6715 : 	m_iESPIONAGE_GATHERING_INTEL_RATE_BASE_PERCENT = GC.getDefineINT("ESPIONAGE_GATHERING_INTEL_RATE_BASE_PERCENT");

	push	1
	push	OFFSET $SG232295
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7928], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6716 : 	m_iESPIONAGE_TURNS_BETWEEN_CITY_STATE_ELECTIONS = GC.getDefineINT("ESPIONAGE_TURNS_BETWEEN_CITY_STATE_ELECTIONS");

	push	1
	push	OFFSET $SG232296
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7932], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6717 : 	m_iESPIONAGE_INFLUENCE_GAINED_FOR_RIGGED_ELECTION = GC.getDefineINT("ESPIONAGE_INFLUENCE_GAINED_FOR_RIGGED_ELECTION");

	push	1
	push	OFFSET $SG232297
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7936], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6718 : 	m_iESPIONAGE_INFLUENCE_LOST_FOR_RIGGED_ELECTION = GC.getDefineINT("ESPIONAGE_INFLUENCE_LOST_FOR_RIGGED_ELECTION");

	push	1
	push	OFFSET $SG232298
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7940], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6719 : 	m_iESPIONAGE_SURVEILLANCE_SIGHT_RANGE = GC.getDefineINT("ESPIONAGE_SURVEILLANCE_SIGHT_RANGE");

	push	1
	push	OFFSET $SG232299
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+7944], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6720 : 	m_iESPIONAGE_COUP_OTHER_PLAYERS_INFLUENCE_DROP = GC.getDefineINT("ESPIONAGE_COUP_OTHER_PLAYERS_INFLUENCE_DROP");

	push	1
	mov	DWORD PTR [esi+7948], eax
	push	OFFSET $SG232300
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6721 : 	m_iPROMOTION_GOODY_HUT_PICKER = getDefineINT("PROMOTION_GOODY_HUT_PICKER");

	push	1
	push	OFFSET $SG232301
	mov	ecx, esi
	mov	DWORD PTR [esi+7952], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6722 : 	m_iIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF = getDefineINT("IDEOLOGY_PERCENT_CLEAR_VICTORY_PREF");

	push	1
	push	OFFSET $SG232302
	mov	ecx, esi
	mov	DWORD PTR [esi+8340], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6723 : 	m_iIDEOLOGY_SCORE_GRAND_STRATS = getDefineINT("IDEOLOGY_SCORE_GRAND_STRATS");

	push	1
	push	OFFSET $SG232303
	mov	ecx, esi
	mov	DWORD PTR [esi+8344], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6724 : 	m_iIDEOLOGY_SCORE_HAPPINESS = getDefineINT("IDEOLOGY_SCORE_HAPPINESS");

	push	1
	push	OFFSET $SG232304
	mov	ecx, esi
	mov	DWORD PTR [esi+8348], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6725 : 	m_iIDEOLOGY_SCORE_PER_FREE_TENET = getDefineINT("IDEOLOGY_SCORE_PER_FREE_TENET");

	push	1
	push	OFFSET $SG232305
	mov	ecx, esi
	mov	DWORD PTR [esi+8352], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6726 : 	m_iIDEOLOGY_SCORE_HOSTILE = getDefineINT("IDEOLOGY_SCORE_HOSTILE");

	push	1
	push	OFFSET $SG232306
	mov	ecx, esi
	mov	DWORD PTR [esi+8356], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6727 : 	m_iIDEOLOGY_SCORE_GUARDED = getDefineINT("IDEOLOGY_SCORE_GUARDED");

	push	1
	push	OFFSET $SG232307
	mov	ecx, esi
	mov	DWORD PTR [esi+8360], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6728 : 	m_iIDEOLOGY_SCORE_AFRAID = getDefineINT("IDEOLOGY_SCORE_AFRAID");

	push	1
	push	OFFSET $SG232308
	mov	ecx, esi
	mov	DWORD PTR [esi+8364], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6729 : 	m_iIDEOLOGY_SCORE_FRIENDLY = getDefineINT("IDEOLOGY_SCORE_FRIENDLY");

	push	1
	push	OFFSET $SG232309
	mov	ecx, esi
	mov	DWORD PTR [esi+8368], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT

; 6730 : 	m_iPOLICY_BRANCH_FREEDOM = getDefineINT("POLICY_BRANCH_FREEDOM", false);

	push	0
	push	OFFSET $SG232310
	mov	ecx, esi
	mov	DWORD PTR [esi+8372], eax
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+8376], eax

; 6731 : 	if (m_iPOLICY_BRANCH_FREEDOM == 0)

	test	eax, eax
	jne	SHORT $LN3@cacheGloba

; 6732 : 	{
; 6733 : 		m_iPOLICY_BRANCH_FREEDOM = NO_POLICY_BRANCH_TYPE;

	mov	DWORD PTR [esi+8376], -1
$LN3@cacheGloba:

; 6734 : 	}
; 6735 : 	m_iPOLICY_BRANCH_AUTOCRACY = getDefineINT("POLICY_BRANCH_AUTOCRACY", false);

	push	0
	push	OFFSET $SG232312
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+8380], eax

; 6736 : 	if (m_iPOLICY_BRANCH_AUTOCRACY == 0)

	test	eax, eax
	jne	SHORT $LN2@cacheGloba

; 6737 : 	{
; 6738 : 		m_iPOLICY_BRANCH_AUTOCRACY = NO_POLICY_BRANCH_TYPE;

	mov	DWORD PTR [esi+8380], -1
$LN2@cacheGloba:

; 6739 : 	}	
; 6740 : 	m_iPOLICY_BRANCH_ORDER = getDefineINT("POLICY_BRANCH_ORDER", false);

	push	0
	push	OFFSET $SG232314
	mov	ecx, esi
	call	?getDefineINT@CvGlobals@@IAEHPBD_N@Z	; CvGlobals::getDefineINT
	mov	DWORD PTR [esi+8384], eax

; 6741 : 	if (m_iPOLICY_BRANCH_ORDER == 0)

	test	eax, eax
	jne	SHORT $LN1@cacheGloba

; 6742 : 	{
; 6743 : 		m_iPOLICY_BRANCH_ORDER = NO_POLICY_BRANCH_TYPE;

	mov	DWORD PTR [esi+8384], -1
$LN1@cacheGloba:
	pop	esi

; 6744 : 	}	
; 6745 : }

	ret	0
?cacheGlobals@CvGlobals@@QAEXXZ ENDP			; CvGlobals::cacheGlobals
_TEXT	ENDS
PUBLIC	?end@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 392  : 		return (_List.end());

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 393  : 		}

	ret	4
?end@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@XZ ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@XZ PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@XZ ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@XZ ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@XZ PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@XZ ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::end
_TEXT	ENDS
PUBLIC	??C?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator->
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??C?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ
_TEXT	SEGMENT
??C?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator->, COMDAT
; _this$ = ecx

; 231  : 			return (&**this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 232  : 			}

	ret	0
??C?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator->
_TEXT	ENDS
PUBLIC	??Cconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBIH@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator->
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Cconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBIH@2@XZ
_TEXT	SEGMENT
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBIH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator->, COMDAT
; _this$ = ecx

; 269  : 			return (&**this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 270  : 			}

	ret	0
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBIH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator->
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?end@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 387  : 		return (_List.end());

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 388  : 		}

	ret	4
?end@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@KAXXZ ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvInterfaceModeInfo@@@std@@YAPAPAVCvInterfaceModeInfo@@IPAPAV1@@Z ; std::_Allocate<CvInterfaceModeInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN32@lower_boun
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun:
	cmp	DWORD PTR [eax+12], edx
	jae	SHORT $LN4@lower_boun
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun
$LN4@lower_boun:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL6@lower_boun
$LN32@lower_boun:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1005 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1009 : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN30@lower_boun@2
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun@2:
	cmp	DWORD PTR [eax+12], edx
	jae	SHORT $LN4@lower_boun@2
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun@2
$LN4@lower_boun@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun@2:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL6@lower_boun@2
$LN30@lower_boun@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1010 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
; Function compile flags: /Ogtpy
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+21], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase
$LL3@Erase:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+21], 0
	mov	edi, esi
	je	SHORT $LL3@Erase
$LN1@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@KAXXZ ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvColorInfo@@@std@@YAPAPAVCvColorInfo@@IPAPAV1@@Z ; std::_Allocate<CvColorInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@KAXXZ ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvPlayerColorInfo@@@std@@YAPAPAVCvPlayerColorInfo@@IPAPAV1@@Z ; std::_Allocate<CvPlayerColorInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@4
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@KAXXZ ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Xlen
$LN16@Buy@4:
$LN2@Buy@4:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvTerrainInfo@@@std@@YAPAPAVCvTerrainInfo@@IPAPAV1@@Z ; std::_Allocate<CvTerrainInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@4:
?_Buy@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@5
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@KAXXZ ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Xlen
$LN16@Buy@5:
$LN2@Buy@5:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvYieldInfo@@@std@@YAPAPAVCvYieldInfo@@IPAPAV1@@Z ; std::_Allocate<CvYieldInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@5:
?_Buy@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@6
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@KAXXZ ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Xlen
$LN16@Buy@6:
$LN2@Buy@6:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvRouteInfo@@@std@@YAPAPAVCvRouteInfo@@IPAPAV1@@Z ; std::_Allocate<CvRouteInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@6:
?_Buy@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@7
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@7:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@7

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@KAXXZ ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Xlen
$LN16@Buy@7:
$LN2@Buy@7:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvFeatureInfo@@@std@@YAPAPAVCvFeatureInfo@@IPAPAV1@@Z ; std::_Allocate<CvFeatureInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@7:
?_Buy@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@8
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@8:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@8

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@KAXXZ ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Xlen
$LN16@Buy@8:
$LN2@Buy@8:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvResourceClassInfo@@@std@@YAPAPAVCvResourceClassInfo@@IPAPAV1@@Z ; std::_Allocate<CvResourceClassInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@8:
?_Buy@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@9
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@9:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@9

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@KAXXZ ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Xlen
$LN16@Buy@9:
$LN2@Buy@9:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvResourceInfo@@@std@@YAPAPAVCvResourceInfo@@IPAPAV1@@Z ; std::_Allocate<CvResourceInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@9:
?_Buy@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@10
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@10:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@10

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@KAXXZ ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Xlen
$LN16@Buy@10:
$LN2@Buy@10:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvBuildInfo@@@std@@YAPAPAVCvBuildInfo@@IPAPAV1@@Z ; std::_Allocate<CvBuildInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@10:
?_Buy@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@11
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@11:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@11

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@KAXXZ ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Xlen
$LN16@Buy@11:
$LN2@Buy@11:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvHandicapInfo@@@std@@YAPAPAVCvHandicapInfo@@IPAPAV1@@Z ; std::_Allocate<CvHandicapInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@11:
?_Buy@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@12
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@12:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@12

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@KAXXZ ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Xlen
$LN16@Buy@12:
$LN2@Buy@12:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvGameSpeedInfo@@@std@@YAPAPAVCvGameSpeedInfo@@IPAPAV1@@Z ; std::_Allocate<CvGameSpeedInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@12:
?_Buy@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@13
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@13:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@13

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@KAXXZ ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Xlen
$LN16@Buy@13:
$LN2@Buy@13:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvTurnTimerInfo@@@std@@YAPAPAVCvTurnTimerInfo@@IPAPAV1@@Z ; std::_Allocate<CvTurnTimerInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@13:
?_Buy@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@14
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@14:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@14

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@KAXXZ ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Xlen
$LN16@Buy@14:
$LN2@Buy@14:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvCivilizationInfo@@@std@@YAPAPAVCvCivilizationInfo@@IPAPAV1@@Z ; std::_Allocate<CvCivilizationInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@14:
?_Buy@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@15
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@15:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@15

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@KAXXZ ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Xlen
$LN16@Buy@15:
$LN2@Buy@15:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvMinorCivInfo@@@std@@YAPAPAVCvMinorCivInfo@@IPAPAV1@@Z ; std::_Allocate<CvMinorCivInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@15:
?_Buy@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@16
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@16:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@16

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@KAXXZ ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Xlen
$LN16@Buy@16:
$LN2@Buy@16:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvLeaderHeadInfo@@@std@@YAPAPAVCvLeaderHeadInfo@@IPAPAV1@@Z ; std::_Allocate<CvLeaderHeadInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@16:
?_Buy@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@17
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@17:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@17

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@KAXXZ ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Xlen
$LN16@Buy@17:
$LN2@Buy@17:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvProcessInfo@@@std@@YAPAPAVCvProcessInfo@@IPAPAV1@@Z ; std::_Allocate<CvProcessInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@17:
?_Buy@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@18
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@18:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@18

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@KAXXZ ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Xlen
$LN16@Buy@18:
$LN2@Buy@18:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvVoteInfo@@@std@@YAPAPAVCvVoteInfo@@IPAPAV1@@Z ; std::_Allocate<CvVoteInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@18:
?_Buy@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@19
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@19:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@19

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@KAXXZ ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Xlen
$LN16@Buy@19:
$LN2@Buy@19:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvBuildingClassInfo@@@std@@YAPAPAVCvBuildingClassInfo@@IPAPAV1@@Z ; std::_Allocate<CvBuildingClassInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@19:
?_Buy@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@20
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@20:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@20

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@KAXXZ ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Xlen
$LN16@Buy@20:
$LN2@Buy@20:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvUnitClassInfo@@@std@@YAPAPAVCvUnitClassInfo@@IPAPAV1@@Z ; std::_Allocate<CvUnitClassInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@20:
?_Buy@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@21
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@21:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@21

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@KAXXZ ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Xlen
$LN16@Buy@21:
$LN2@Buy@21:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvSpecialUnitInfo@@@std@@YAPAPAVCvSpecialUnitInfo@@IPAPAV1@@Z ; std::_Allocate<CvSpecialUnitInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@21:
?_Buy@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@22
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@22:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@22

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@KAXXZ ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Xlen
$LN16@Buy@22:
$LN2@Buy@22:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvVoteSourceInfo@@@std@@YAPAPAVCvVoteSourceInfo@@IPAPAV1@@Z ; std::_Allocate<CvVoteSourceInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@22:
?_Buy@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@23
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@23:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@23

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@KAXXZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Xlen
$LN16@Buy@23:
$LN2@Buy@23:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvBaseInfo@@@std@@YAPAPAVCvBaseInfo@@IPAPAV1@@Z ; std::_Allocate<CvBaseInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@23:
?_Buy@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@24
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@24:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@24

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@KAXXZ ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Xlen
$LN16@Buy@24:
$LN2@Buy@24:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvGameOptionInfo@@@std@@YAPAPAVCvGameOptionInfo@@IPAPAV1@@Z ; std::_Allocate<CvGameOptionInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@24:
?_Buy@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@25
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@25:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@25

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@KAXXZ ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Xlen
$LN16@Buy@25:
$LN2@Buy@25:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvMPOptionInfo@@@std@@YAPAPAVCvMPOptionInfo@@IPAPAV1@@Z ; std::_Allocate<CvMPOptionInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@25:
?_Buy@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@26
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@26:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@26

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@KAXXZ ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Xlen
$LN16@Buy@26:
$LN2@Buy@26:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvPlayerOptionInfo@@@std@@YAPAPAVCvPlayerOptionInfo@@IPAPAV1@@Z ; std::_Allocate<CvPlayerOptionInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@26:
?_Buy@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@27
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@27:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@27

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@KAXXZ ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Xlen
$LN16@Buy@27:
$LN2@Buy@27:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvSpecialistInfo@@@std@@YAPAPAVCvSpecialistInfo@@IPAPAV1@@Z ; std::_Allocate<CvSpecialistInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@27:
?_Buy@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@28
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@28:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@28

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@KAXXZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Xlen
$LN16@Buy@28:
$LN2@Buy@28:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvActionInfo@@@std@@YAPAPAVCvActionInfo@@IPAPAV1@@Z ; std::_Allocate<CvActionInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@28:
?_Buy@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@29
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@29:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@29

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@KAXXZ ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Xlen
$LN16@Buy@29:
$LN2@Buy@29:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvMissionInfo@@@std@@YAPAPAVCvMissionInfo@@IPAPAV1@@Z ; std::_Allocate<CvMissionInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@29:
?_Buy@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@30
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@30:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@30

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@KAXXZ ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Xlen
$LN16@Buy@30:
$LN2@Buy@30:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvControlInfo@@@std@@YAPAPAVCvControlInfo@@IPAPAV1@@Z ; std::_Allocate<CvControlInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@30:
?_Buy@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@31
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@31:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@31

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@KAXXZ ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Xlen
$LN16@Buy@31:
$LN2@Buy@31:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvCommandInfo@@@std@@YAPAPAVCvCommandInfo@@IPAPAV1@@Z ; std::_Allocate<CvCommandInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@31:
?_Buy@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@32
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@32:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@32

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@KAXXZ ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Xlen
$LN16@Buy@32:
$LN2@Buy@32:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvAutomateInfo@@@std@@YAPAPAVCvAutomateInfo@@IPAPAV1@@Z ; std::_Allocate<CvAutomateInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@32:
?_Buy@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@33
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@33:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@33

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@KAXXZ ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Xlen
$LN16@Buy@33:
$LN2@Buy@33:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvEraInfo@@@std@@YAPAPAVCvEraInfo@@IPAPAV1@@Z ; std::_Allocate<CvEraInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@33:
?_Buy@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@34
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@34:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@34

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@KAXXZ ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Xlen
$LN16@Buy@34:
$LN2@Buy@34:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvHurryInfo@@@std@@YAPAPAVCvHurryInfo@@IPAPAV1@@Z ; std::_Allocate<CvHurryInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@34:
?_Buy@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@35
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@35:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@35

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@KAXXZ ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Xlen
$LN16@Buy@35:
$LN2@Buy@35:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvVictoryInfo@@@std@@YAPAPAVCvVictoryInfo@@IPAPAV1@@Z ; std::_Allocate<CvVictoryInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@35:
?_Buy@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@36
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@36:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@36

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@KAXXZ ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Xlen
$LN16@Buy@36:
$LN2@Buy@36:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvSmallAwardInfo@@@std@@YAPAPAVCvSmallAwardInfo@@IPAPAV1@@Z ; std::_Allocate<CvSmallAwardInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@36:
?_Buy@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@37
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@37:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@37

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@KAXXZ ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Xlen
$LN16@Buy@37:
$LN2@Buy@37:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvEntityEventInfo@@@std@@YAPAPAVCvEntityEventInfo@@IPAPAV1@@Z ; std::_Allocate<CvEntityEventInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@37:
?_Buy@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@38
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@38:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@38

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@KAXXZ ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Xlen
$LN16@Buy@38:
$LN2@Buy@38:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvMultiUnitFormationInfo@@@std@@YAPAPAVCvMultiUnitFormationInfo@@IPAPAV1@@Z ; std::_Allocate<CvMultiUnitFormationInfo *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@38:
?_Buy@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Buy
_TEXT	ENDS
PUBLIC	??1?$_List_ptr@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::_List_ptr<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_List_ptr<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_List_ptr@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_ptr@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ PROC ; std::_List_ptr<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_List_ptr<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_List_ptr@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ENDP ; std::_List_ptr<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_List_ptr<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAEXPAPAVCvInterfaceModeInfo@@0@Z ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAEXPAPAVCvInterfaceModeInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAEXPAPAVCvInterfaceModeInfo@@0@Z PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAEXPAPAVCvInterfaceModeInfo@@0@Z ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAEXPAPAVCvColorInfo@@0@Z ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAEXPAPAVCvColorInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAEXPAPAVCvColorInfo@@0@Z PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAEXPAPAVCvColorInfo@@0@Z ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAEXPAPAVCvPlayerColorInfo@@0@Z ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAEXPAPAVCvPlayerColorInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAEXPAPAVCvPlayerColorInfo@@0@Z PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAEXPAPAVCvPlayerColorInfo@@0@Z ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAEXPAPAVCvTerrainInfo@@0@Z ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAEXPAPAVCvTerrainInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAEXPAPAVCvTerrainInfo@@0@Z PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAEXPAPAVCvTerrainInfo@@0@Z ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAEXPAPAVCvYieldInfo@@0@Z ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAEXPAPAVCvYieldInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAEXPAPAVCvYieldInfo@@0@Z PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAEXPAPAVCvYieldInfo@@0@Z ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAEXPAPAVCvRouteInfo@@0@Z ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAEXPAPAVCvRouteInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAEXPAPAVCvRouteInfo@@0@Z PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAEXPAPAVCvRouteInfo@@0@Z ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAEXPAPAVCvFeatureInfo@@0@Z ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAEXPAPAVCvFeatureInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAEXPAPAVCvFeatureInfo@@0@Z PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAEXPAPAVCvFeatureInfo@@0@Z ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAEXPAPAVCvResourceClassInfo@@0@Z ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAEXPAPAVCvResourceClassInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAEXPAPAVCvResourceClassInfo@@0@Z PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAEXPAPAVCvResourceClassInfo@@0@Z ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAEXPAPAVCvResourceInfo@@0@Z ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAEXPAPAVCvResourceInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAEXPAPAVCvResourceInfo@@0@Z PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAEXPAPAVCvResourceInfo@@0@Z ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAEXPAPAVCvBuildInfo@@0@Z ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAEXPAPAVCvBuildInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAEXPAPAVCvBuildInfo@@0@Z PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAEXPAPAVCvBuildInfo@@0@Z ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAEXPAPAVCvHandicapInfo@@0@Z ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAEXPAPAVCvHandicapInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAEXPAPAVCvHandicapInfo@@0@Z PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAEXPAPAVCvHandicapInfo@@0@Z ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAEXPAPAVCvGameSpeedInfo@@0@Z ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAEXPAPAVCvGameSpeedInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAEXPAPAVCvGameSpeedInfo@@0@Z PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAEXPAPAVCvGameSpeedInfo@@0@Z ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAEXPAPAVCvTurnTimerInfo@@0@Z ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAEXPAPAVCvTurnTimerInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAEXPAPAVCvTurnTimerInfo@@0@Z PROC ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAEXPAPAVCvTurnTimerInfo@@0@Z ENDP ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAEXPAPAVCvCivilizationInfo@@0@Z ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAEXPAPAVCvCivilizationInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAEXPAPAVCvCivilizationInfo@@0@Z PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAEXPAPAVCvCivilizationInfo@@0@Z ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAEXPAPAVCvMinorCivInfo@@0@Z ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAEXPAPAVCvMinorCivInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAEXPAPAVCvMinorCivInfo@@0@Z PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAEXPAPAVCvMinorCivInfo@@0@Z ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAEXPAPAVCvLeaderHeadInfo@@0@Z ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAEXPAPAVCvLeaderHeadInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAEXPAPAVCvLeaderHeadInfo@@0@Z PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAEXPAPAVCvLeaderHeadInfo@@0@Z ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAEXPAPAVCvProcessInfo@@0@Z ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAEXPAPAVCvProcessInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAEXPAPAVCvProcessInfo@@0@Z PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAEXPAPAVCvProcessInfo@@0@Z ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAEXPAPAVCvVoteInfo@@0@Z ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAEXPAPAVCvVoteInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAEXPAPAVCvVoteInfo@@0@Z PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAEXPAPAVCvVoteInfo@@0@Z ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAEXPAPAVCvBuildingClassInfo@@0@Z ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAEXPAPAVCvBuildingClassInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAEXPAPAVCvBuildingClassInfo@@0@Z PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAEXPAPAVCvBuildingClassInfo@@0@Z ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAEXPAPAVCvUnitClassInfo@@0@Z ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAEXPAPAVCvUnitClassInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAEXPAPAVCvUnitClassInfo@@0@Z PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAEXPAPAVCvUnitClassInfo@@0@Z ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAEXPAPAVCvSpecialUnitInfo@@0@Z ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAEXPAPAVCvSpecialUnitInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAEXPAPAVCvSpecialUnitInfo@@0@Z PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAEXPAPAVCvSpecialUnitInfo@@0@Z ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAEXPAPAVCvVoteSourceInfo@@0@Z ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAEXPAPAVCvVoteSourceInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAEXPAPAVCvVoteSourceInfo@@0@Z PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAEXPAPAVCvVoteSourceInfo@@0@Z ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAEXPAPAVCvBaseInfo@@0@Z ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAEXPAPAVCvBaseInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAEXPAPAVCvBaseInfo@@0@Z PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAEXPAPAVCvBaseInfo@@0@Z ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAEXPAPAVCvGameOptionInfo@@0@Z ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAEXPAPAVCvGameOptionInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAEXPAPAVCvGameOptionInfo@@0@Z PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAEXPAPAVCvGameOptionInfo@@0@Z ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAEXPAPAVCvMPOptionInfo@@0@Z ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAEXPAPAVCvMPOptionInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAEXPAPAVCvMPOptionInfo@@0@Z PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAEXPAPAVCvMPOptionInfo@@0@Z ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAEXPAPAVCvPlayerOptionInfo@@0@Z ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAEXPAPAVCvPlayerOptionInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAEXPAPAVCvPlayerOptionInfo@@0@Z PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAEXPAPAVCvPlayerOptionInfo@@0@Z ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAEXPAPAVCvSpecialistInfo@@0@Z ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAEXPAPAVCvSpecialistInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAEXPAPAVCvSpecialistInfo@@0@Z PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAEXPAPAVCvSpecialistInfo@@0@Z ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAEXPAPAVCvActionInfo@@0@Z ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAEXPAPAVCvActionInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAEXPAPAVCvActionInfo@@0@Z PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAEXPAPAVCvActionInfo@@0@Z ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAEXPAPAVCvMissionInfo@@0@Z ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAEXPAPAVCvMissionInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAEXPAPAVCvMissionInfo@@0@Z PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAEXPAPAVCvMissionInfo@@0@Z ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAEXPAPAVCvControlInfo@@0@Z ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAEXPAPAVCvControlInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAEXPAPAVCvControlInfo@@0@Z PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAEXPAPAVCvControlInfo@@0@Z ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAEXPAPAVCvCommandInfo@@0@Z ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAEXPAPAVCvCommandInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAEXPAPAVCvCommandInfo@@0@Z PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAEXPAPAVCvCommandInfo@@0@Z ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAEXPAPAVCvAutomateInfo@@0@Z ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAEXPAPAVCvAutomateInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAEXPAPAVCvAutomateInfo@@0@Z PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAEXPAPAVCvAutomateInfo@@0@Z ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAEXPAPAVCvEraInfo@@0@Z ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAEXPAPAVCvEraInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAEXPAPAVCvEraInfo@@0@Z PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAEXPAPAVCvEraInfo@@0@Z ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAEXPAPAVCvHurryInfo@@0@Z ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAEXPAPAVCvHurryInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAEXPAPAVCvHurryInfo@@0@Z PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAEXPAPAVCvHurryInfo@@0@Z ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAEXPAPAVCvVictoryInfo@@0@Z ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAEXPAPAVCvVictoryInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAEXPAPAVCvVictoryInfo@@0@Z PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAEXPAPAVCvVictoryInfo@@0@Z ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAEXPAPAVCvSmallAwardInfo@@0@Z ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAEXPAPAVCvSmallAwardInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAEXPAPAVCvSmallAwardInfo@@0@Z PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAEXPAPAVCvSmallAwardInfo@@0@Z ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAEXPAPAVCvEntityEventInfo@@0@Z ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAEXPAPAVCvEntityEventInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAEXPAPAVCvEntityEventInfo@@0@Z PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAEXPAPAVCvEntityEventInfo@@0@Z ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAEXPAPAVCvMultiUnitFormationInfo@@0@Z ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAEXPAPAVCvMultiUnitFormationInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAEXPAPAVCvMultiUnitFormationInfo@@0@Z PROC ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAEXPAPAVCvMultiUnitFormationInfo@@0@Z ENDP ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Destroy
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode, COMDAT
; _this$ = ecx

; 1172 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1173 : 		int _Linkcnt = 0;
; 1174 : 
; 1175 : 		_TRY_BEGIN
; 1176 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

	test	eax, eax
	je	SHORT $LN26@Buynode
	mov	DWORD PTR [eax], eax
$LN26@Buynode:

; 1177 : 		++_Linkcnt;
; 1178 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN36@Buynode
	mov	DWORD PTR [ecx], eax
$LN36@Buynode:

; 1179 : 		_CATCH_ALL
; 1180 : 		if (0 < _Linkcnt)
; 1181 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1182 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1183 : 		_RERAISE;
; 1184 : 		_CATCH_END
; 1185 : 		return (_Pnode);
; 1186 : 		}

	ret	0
?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAE_NI@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAE_NI@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@39
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@39:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@39

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Xlen
$LN16@Buy@39:
$LN2@Buy@39:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IPAV120@@Z ; std::_Allocate<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@39:
?_Buy@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAE_NI@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Buy
_TEXT	ENDS
PUBLIC	__real@4f800000
PUBLIC	?load_factor@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEMXZ ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::load_factor
;	COMDAT __real@4f800000
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?load_factor@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEMXZ
_TEXT	SEGMENT
tv139 = -4						; size = 4
tv132 = -4						; size = 4
tv129 = -4						; size = 4
?load_factor@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEMXZ PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::load_factor, COMDAT
; _this$ = ecx

; 507  : 		{	// return elements per bucket

	push	ecx

; 508  : 		return ((float)size() / (float)bucket_count());

	mov	eax, DWORD PTR [ecx+12]
	fild	DWORD PTR [ecx+12]
	test	eax, eax
	jge	SHORT $LN9@load_facto
	fadd	DWORD PTR __real@4f800000
$LN9@load_facto:
	mov	ecx, DWORD PTR [ecx+36]
	mov	DWORD PTR tv132[esp+4], ecx
	fild	DWORD PTR tv132[esp+4]
	test	ecx, ecx
	jge	SHORT $LN10@load_facto
	fadd	DWORD PTR __real@4f800000
$LN10@load_facto:
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR tv129[esp+4]
	fld	DWORD PTR tv129[esp+4]

; 509  : 		}

	pop	ecx
	ret	0
?load_factor@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBEMXZ ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::load_factor
_TEXT	ENDS
PUBLIC	??R?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@QBEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()
EXTRN	__imp__ldiv:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??R?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@QBEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??R?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@QBEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator(), COMDAT
; _this$ = ecx

; 128  : 		long _Quot = (long)(hash_value(_Keyval) & LONG_MAX);

	mov	eax, DWORD PTR __Keyval$[esp-4]
	push	eax
	call	??$hash_value@DU?$char_traits@D@std@@V?$allocator@D@2@@stdext@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stdext::hash_value<char,std::char_traits<char>,std::allocator<char> >
	and	eax, 2147483647				; 7fffffffH

; 129  : 		ldiv_t _Qrem = ldiv(_Quot, 127773);

	push	127773					; 0001f31dH
	push	eax
	call	DWORD PTR __imp__ldiv

; 130  : 
; 131  : 		_Qrem.rem = 16807 * _Qrem.rem - 2836 * _Qrem.quot;

	imul	eax, 2836				; 00000b14H
	imul	edx, 16807				; 000041a7H
	add	esp, 12					; 0000000cH
	sub	edx, eax
	mov	eax, edx

; 132  : 		if (_Qrem.rem < 0)

	jns	SHORT $LN1@operator@3

; 133  : 			_Qrem.rem += LONG_MAX;

	add	eax, 2147483647				; 7fffffffH
$LN1@operator@3:

; 134  : 		return ((size_t)_Qrem.rem);
; 135  : 		}

	ret	4
??R?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@QBEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T266467 = -80						; size = 28
$T266466 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+8]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+21], 0
	push	ebp
	mov	ebp, ecx
	je	SHORT $LN40@erase

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T266467[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T266466[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T266467[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T266466[esp+104]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	mov	DWORD PTR $T266466[esp+92], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T266466[esp+92]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR $T266466[esp+96], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN293@erase:
$LN40@erase:
	push	ebx
	push	esi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax
	push	edi

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+100], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LN39@erase

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN288@erase
$LN39@erase:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [edx+21], 0
	je	SHORT $LN37@erase

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN288@erase
$LN37@erase:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+96]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase
$LN288@erase:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+4]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase
$LN33@erase:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase
$LN31@erase:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR __Erasednode$[esp+100]
	jne	SHORT $LN29@erase

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN43@erase
	mov	eax, esi
	jmp	SHORT $LN44@erase
$LN43@erase:
	push	edi
	call	?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
	add	esp, 4
$LN44@erase:
	mov	DWORD PTR [ebx], eax
$LN29@erase:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR __Erasednode$[esp+100]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN173@erase

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN45@erase
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase
$LN45@erase:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase
$LN35@erase:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase
$LN26@erase:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase
$LN23@erase:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase
$LN21@erase:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+20]
	add	eax, 20					; 00000014H
	cmp	eax, ecx
	je	SHORT $LN173@erase
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+100]
	mov	bl, 1
	cmp	BYTE PTR [edx+20], bl
	jne	$LN19@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase
	npad	6
$LL18@erase:
	cmp	BYTE PTR [edi+20], bl
	jne	$LN16@erase

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+20], 0
	jne	SHORT $LN14@erase

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+20], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN14@erase:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+21], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN291@erase

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN11@erase
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+20], bl
	je	SHORT $LN292@erase
$LN11@erase:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN9@erase

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+20], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN9@erase:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+20]
	mov	BYTE PTR [eax+20], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+20], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase
$LN15@erase:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+20], 0
	jne	SHORT $LN7@erase

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+20], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN7@erase:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+21], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN291@erase

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN4@erase
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN4@erase
$LN292@erase:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+20], 0
$LN291@erase:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase
$LN4@erase:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN2@erase

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+20], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN2@erase:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+20]
	mov	BYTE PTR [eax+20], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+20], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
$LN16@erase:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+20], bl
$LN19@erase:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[esp+100]
	push	eax
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+8]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	jbe	SHORT $LN1@erase

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+8], eax
$LN1@erase:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+84]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN290@erase:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T266467[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T266466[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode@2
	mov	DWORD PTR [eax], 0
$LN27@Buynode@2:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@2
	mov	DWORD PTR [ecx], 0
$LN37@Buynode@2:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@2
	mov	DWORD PTR [ecx], 0
$LN47@Buynode@2:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+20], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+21], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode@3
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], dl
	mov	BYTE PTR [eax+21], 0
$LN4@Buynode@3:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	??0?$_List_ptr@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ; std::_List_ptr<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_List_ptr<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??0?$_List_ptr@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_ptr@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z PROC ; std::_List_ptr<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_List_ptr<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx

; 67   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 68   : 		}

	ret	4
??0?$_List_ptr@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ENDP ; std::_List_ptr<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_List_ptr<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@XZ ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@XZ PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@XZ ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@XZ ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@XZ PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@XZ ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::end
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Incsize
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z$2
__ehfuncinfo$?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T267182 = -80						; size = 28
$T267181 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Incsize, COMDAT
; _this$ = ecx

; 1239 : 		{	// alter element count, with checking

	mov	eax, DWORD PTR fs:0

; 1240 : 		if (max_size() - _Mysize < _Count)

	mov	edx, DWORD PTR __Count$[esp-4]
	push	-1
	push	__ehhandler$?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	sub	esp, 68					; 00000044H
	push	esi
	mov	esi, 134217727				; 07ffffffH
	sub	esi, eax
	cmp	esi, edx
	pop	esi
	jae	SHORT $LN1@Incsize

; 1241 : 			_THROW(length_error, "list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T267182[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T267181[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T267182[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T267181[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T267181[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T267181[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T267181[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN20@Incsize:
$LN1@Incsize:

; 1242 : 		_Mysize += _Count;

	add	eax, edx
	mov	DWORD PTR [ecx+8], eax

; 1243 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	4
$LN19@Incsize:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z$0:
	lea	ecx, DWORD PTR $T267182[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z$2:
	lea	ecx, DWORD PTR $T267181[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Incsize
PUBLIC	?_Make_iter@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@V?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@V?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@V?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QBE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@V?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Make_iter
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@ABU32@@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@ABU32@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@ABU32@@Z PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	eax
	push	ecx
	call	??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z ; std::_Construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
	add	esp, 8

; 156  : 		}

	ret	8
?construct@?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@ABU32@@Z ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::construct
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvIgnoreUnitsPathFinder@@@@YAXAAPAVCvIgnoreUnitsPathFinder@@@Z ; SAFE_DELETE<CvIgnoreUnitsPathFinder>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvIgnoreUnitsPathFinder@@@@YAXAAPAVCvIgnoreUnitsPathFinder@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvIgnoreUnitsPathFinder@@@@YAXAAPAVCvIgnoreUnitsPathFinder@@@Z PROC ; SAFE_DELETE<CvIgnoreUnitsPathFinder>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@48
	mov	ecx, esi
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@48:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvIgnoreUnitsPathFinder@@@@YAXAAPAVCvIgnoreUnitsPathFinder@@@Z ENDP ; SAFE_DELETE<CvIgnoreUnitsPathFinder>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvStepPathFinder@@@@YAXAAPAVCvStepPathFinder@@@Z ; SAFE_DELETE<CvStepPathFinder>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvStepPathFinder@@@@YAXAAPAVCvStepPathFinder@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvStepPathFinder@@@@YAXAAPAVCvStepPathFinder@@@Z PROC ; SAFE_DELETE<CvStepPathFinder>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@49
	mov	ecx, esi
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@49:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvStepPathFinder@@@@YAXAAPAVCvStepPathFinder@@@Z ENDP ; SAFE_DELETE<CvStepPathFinder>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAXPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z ; std::_Destroy<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAXPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAXPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z PROC ; std::_Destroy<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	add	ecx, 8
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??$_Destroy@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAXPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@@Z ENDP ; std::_Destroy<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00@Z ; stdext::_Unchecked_move_backward<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00@Z PROC ; stdext::_Unchecked_move_backward<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00@Z ENDP ; stdext::_Unchecked_move_backward<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@XZ ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@XZ PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@XZ ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@XZ ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@XZ PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@XZ ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@XZ ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@XZ PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@XZ ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@XZ ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@XZ PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@XZ ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@XZ ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@XZ PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@XZ ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@XZ ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@XZ PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@XZ ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@XZ ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@XZ PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@XZ ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@XZ ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@XZ PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@XZ ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@XZ ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@XZ PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@XZ ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@XZ ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@XZ PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@XZ ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@XZ ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@XZ PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@XZ ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@XZ ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@XZ PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@XZ ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@XZ ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@XZ PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@XZ ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@XZ ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@XZ PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@XZ ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@XZ ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@XZ PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@XZ ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@XZ ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@XZ PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@XZ ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@XZ ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@XZ PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@XZ ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@XZ ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@XZ PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@XZ ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@XZ ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@XZ PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@XZ ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@XZ ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@XZ PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@XZ ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@XZ ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@XZ PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@XZ ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@XZ ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@XZ PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@XZ ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@XZ ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@XZ PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@XZ ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@XZ ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@XZ PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@XZ ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@XZ ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@XZ PROC ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@XZ ENDP ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@XZ ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@XZ PROC ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@XZ ENDP ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@XZ ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@XZ PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@XZ ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@XZ ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@XZ PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@XZ ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@XZ ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@XZ PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@XZ ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@XZ ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@XZ PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@XZ ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@XZ ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@XZ PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@XZ ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@XZ ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@XZ PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@XZ ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@XZ ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@XZ PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@XZ ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@XZ ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@XZ PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@XZ ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@XZ ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@XZ PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@XZ ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@XZ ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@XZ PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@XZ ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@XZ ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@XZ PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@XZ ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@XZ ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@XZ PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@XZ ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@XZ ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@XZ PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@XZ ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@XZ ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@XZ PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@XZ ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@XZ ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@XZ PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@XZ ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@XZ ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@XZ PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@XZ ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@XZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@XZ PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@XZ ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@XZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@XZ PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@XZ ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@XZ ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@XZ PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@XZ ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@XZ ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@XZ PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@XZ ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@XZ ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@XZ PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@XZ ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@XZ ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@XZ PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@XZ ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@XZ ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@XZ PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@XZ ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@XZ ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@XZ PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@XZ ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@XZ ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@XZ PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@XZ ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@XZ ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@XZ PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@XZ ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@XZ ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@XZ PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@XZ ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@XZ ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@XZ PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@XZ ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@XZ ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@XZ PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@XZ ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@XZ ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@XZ PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@XZ ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@XZ ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@XZ PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@XZ ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@XZ ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@XZ PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@XZ ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@XZ ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@XZ PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@XZ ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@XZ ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@XZ PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@XZ ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@XZ ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@XZ PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@XZ ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@XZ ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@XZ PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@XZ ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@XZ ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@XZ PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@XZ ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@XZ ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@XZ PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@XZ ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@XZ ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@XZ PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@XZ ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@XZ ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@XZ PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@XZ ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@XZ ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@XZ PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@XZ ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@XZ ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@XZ PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@XZ ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@XZ ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@XZ PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@XZ ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@XZ ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@XZ PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@XZ ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::end
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@0@Z ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@0@Z PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@2
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@2:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@2@0@Z ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@0@Z ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@0@Z PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@3
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@3:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@3:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@2@0@Z ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@0@Z ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@0@Z PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@4
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@4:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@4:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@2@0@Z ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@0@Z ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@0@Z PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@5

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@5
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@5:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@5:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@2@0@Z ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@0@Z ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@0@Z PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@6

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@6
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@6:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@6:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@2@0@Z ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@0@Z ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@0@Z PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@7

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@7
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@7:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@7:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@2@0@Z ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@0@Z ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@0@Z PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@8

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@8
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@8:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@8:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@2@0@Z ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@0@Z ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@0@Z PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@9

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@9
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@9:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@9:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@2@0@Z ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@0@Z ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@0@Z PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@10

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@10
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@10:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@10:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@2@0@Z ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@0@Z ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@0@Z PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@11

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@11
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@11:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@11:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@2@0@Z ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@0@Z ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@0@Z PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@12

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@12
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@12:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@12:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@2@0@Z ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@0@Z ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@0@Z PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@13

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@13
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@13:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@13:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@2@0@Z ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@0@Z ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@0@Z PROC ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@14

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@14
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@14:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@14:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@2@0@Z ENDP ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@0@Z ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@0@Z PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@15

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@15
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@15:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@15:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@2@0@Z ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@0@Z ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@0@Z PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@16

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@16
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@16:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@16:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@2@0@Z ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@0@Z ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@0@Z PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@17

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@17
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@17:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@17:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@2@0@Z ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@0@Z ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@0@Z PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@18

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@18
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@18:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@18:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@2@0@Z ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@0@Z ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@0@Z PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@19

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@19
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@19:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@19:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@2@0@Z ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@0@Z ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@0@Z PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@20

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@20
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@20:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@20:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@2@0@Z ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@0@Z ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@0@Z PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@21

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@21
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@21:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@21:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@2@0@Z ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@0@Z ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@0@Z PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@22

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@22
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@22:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@22:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@2@0@Z ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@0@Z ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@0@Z PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@23

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@23
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@23:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@23:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@2@0@Z ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@0@Z ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@0@Z PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@24

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@24
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@24:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@24:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@2@0@Z ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@0@Z ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@0@Z PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@25

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@25
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@25:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@25:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@2@0@Z ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@0@Z ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@0@Z PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@26

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@26
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@26:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@26:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@2@0@Z ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@0@Z ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@0@Z PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@27

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@27
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@27:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@27:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@2@0@Z ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@0@Z ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@0@Z PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@28

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@28
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@28:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@28:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@2@0@Z ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@0@Z ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@0@Z PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@29

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@29
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@29:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@29:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@0@Z ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@0@Z ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@0@Z PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@30

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@30
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@30:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@30:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@2@0@Z ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@0@Z ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@0@Z PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@31

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@31
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@31:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@31:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@2@0@Z ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@0@Z ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@0@Z PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@32

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@32
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@32:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@32:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@2@0@Z ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@0@Z ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@0@Z PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@33

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@33
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@33:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@33:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@2@0@Z ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@0@Z ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@0@Z PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@34

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@34
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@34:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@34:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@2@0@Z ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@0@Z ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@0@Z PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@35

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@35
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@35:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@35:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@2@0@Z ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@0@Z ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@0@Z PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@36

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@36
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@36:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@36:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@2@0@Z ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@0@Z ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@0@Z PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@37

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@37
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@37:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@37:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@2@0@Z ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@0@Z ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@0@Z PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@38

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@38
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@38:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@38:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@V?$_Vector_const_iterator@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@2@0@Z ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::erase
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvBaseInfo@@@@YAXAAPAVCvBaseInfo@@@Z ; SAFE_DELETE<CvBaseInfo>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvBaseInfo@@@@YAXAAPAVCvBaseInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvBaseInfo@@@@YAXAAPAVCvBaseInfo@@@Z PROC ; SAFE_DELETE<CvBaseInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@50
	mov	ecx, esi
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@50:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvBaseInfo@@@@YAXAAPAVCvBaseInfo@@@Z ENDP ; SAFE_DELETE<CvBaseInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvGameOptionInfo@@@@YAXAAPAVCvGameOptionInfo@@@Z ; SAFE_DELETE<CvGameOptionInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvGameOptionInfo@@@@YAXAAPAVCvGameOptionInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvGameOptionInfo@@@@YAXAAPAVCvGameOptionInfo@@@Z PROC ; SAFE_DELETE<CvGameOptionInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@51
	mov	ecx, esi
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@51:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvGameOptionInfo@@@@YAXAAPAVCvGameOptionInfo@@@Z ENDP ; SAFE_DELETE<CvGameOptionInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvMPOptionInfo@@@@YAXAAPAVCvMPOptionInfo@@@Z ; SAFE_DELETE<CvMPOptionInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvMPOptionInfo@@@@YAXAAPAVCvMPOptionInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvMPOptionInfo@@@@YAXAAPAVCvMPOptionInfo@@@Z PROC ; SAFE_DELETE<CvMPOptionInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@52
	mov	ecx, esi
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@52:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvMPOptionInfo@@@@YAXAAPAVCvMPOptionInfo@@@Z ENDP ; SAFE_DELETE<CvMPOptionInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvPlayerOptionInfo@@@@YAXAAPAVCvPlayerOptionInfo@@@Z ; SAFE_DELETE<CvPlayerOptionInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvPlayerOptionInfo@@@@YAXAAPAVCvPlayerOptionInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvPlayerOptionInfo@@@@YAXAAPAVCvPlayerOptionInfo@@@Z PROC ; SAFE_DELETE<CvPlayerOptionInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@53
	mov	ecx, esi
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@53:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvPlayerOptionInfo@@@@YAXAAPAVCvPlayerOptionInfo@@@Z ENDP ; SAFE_DELETE<CvPlayerOptionInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvYieldInfo@@@@YAXAAPAVCvYieldInfo@@@Z ; SAFE_DELETE<CvYieldInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvYieldInfo@@@@YAXAAPAVCvYieldInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvYieldInfo@@@@YAXAAPAVCvYieldInfo@@@Z PROC ; SAFE_DELETE<CvYieldInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@54
	mov	ecx, esi
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@54:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvYieldInfo@@@@YAXAAPAVCvYieldInfo@@@Z ENDP ; SAFE_DELETE<CvYieldInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvResourceClassInfo@@@@YAXAAPAVCvResourceClassInfo@@@Z ; SAFE_DELETE<CvResourceClassInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvResourceClassInfo@@@@YAXAAPAVCvResourceClassInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvResourceClassInfo@@@@YAXAAPAVCvResourceClassInfo@@@Z PROC ; SAFE_DELETE<CvResourceClassInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@55
	mov	ecx, esi
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@55:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvResourceClassInfo@@@@YAXAAPAVCvResourceClassInfo@@@Z ENDP ; SAFE_DELETE<CvResourceClassInfo>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IABV120@AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,unsigned int,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IABV120@AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IABV120@AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,unsigned int,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 4
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IABV120@AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,unsigned int,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	??_GCvTurnTimerInfo@@QAEPAXI@Z			; CvTurnTimerInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvTurnTimerInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvTurnTimerInfo@@QAEPAXI@Z PROC			; CvTurnTimerInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@39
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@39:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvTurnTimerInfo@@QAEPAXI@Z ENDP			; CvTurnTimerInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvHurryInfo@@QAEPAXI@Z			; CvHurryInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvHurryInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvHurryInfo@@QAEPAXI@Z PROC				; CvHurryInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@40
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@40:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvHurryInfo@@QAEPAXI@Z ENDP				; CvHurryInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvColorInfo@@QAEPAXI@Z			; CvColorInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvColorInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvColorInfo@@QAEPAXI@Z PROC				; CvColorInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@41
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@41:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvColorInfo@@QAEPAXI@Z ENDP				; CvColorInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvPlayerColorInfo@@QAEPAXI@Z		; CvPlayerColorInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvPlayerColorInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvPlayerColorInfo@@QAEPAXI@Z PROC			; CvPlayerColorInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@42
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@42:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvPlayerColorInfo@@QAEPAXI@Z ENDP			; CvPlayerColorInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvInterfaceModeInfo@@QAEPAXI@Z		; CvInterfaceModeInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvInterfaceModeInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvInterfaceModeInfo@@QAEPAXI@Z PROC			; CvInterfaceModeInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvHotKeyInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@43
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@43:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvInterfaceModeInfo@@QAEPAXI@Z ENDP			; CvInterfaceModeInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvUnitClassInfo@@QAEPAXI@Z			; CvUnitClassInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvUnitClassInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvUnitClassInfo@@QAEPAXI@Z PROC			; CvUnitClassInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@44
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@44:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvUnitClassInfo@@QAEPAXI@Z ENDP			; CvUnitClassInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvMissionInfo@@QAEPAXI@Z			; CvMissionInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvMissionInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvMissionInfo@@QAEPAXI@Z PROC			; CvMissionInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvMissionInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@45
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@45:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvMissionInfo@@QAEPAXI@Z ENDP			; CvMissionInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvControlInfo@@QAEPAXI@Z			; CvControlInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvControlInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvControlInfo@@QAEPAXI@Z PROC			; CvControlInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvHotKeyInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@46
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@46:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvControlInfo@@QAEPAXI@Z ENDP			; CvControlInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvCommandInfo@@QAEPAXI@Z			; CvCommandInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvCommandInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvCommandInfo@@QAEPAXI@Z PROC			; CvCommandInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvHotKeyInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@47
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@47:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvCommandInfo@@QAEPAXI@Z ENDP			; CvCommandInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_GCvAutomateInfo@@QAEPAXI@Z			; CvAutomateInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvAutomateInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAutomateInfo@@QAEPAXI@Z PROC			; CvAutomateInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvHotKeyInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@48
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@48:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAutomateInfo@@QAEPAXI@Z ENDP			; CvAutomateInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@Z
_TEXT	SEGMENT
$T271498 = -4						; size = 1
__Cat$271503 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T271498[esp+4], 0
	mov	eax, DWORD PTR $T271498[esp+4]
	mov	ecx, DWORD PTR __Cat$271503[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum AnimationPathTypes> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	?uninit@CvGlobals@@QAEXXZ			; CvGlobals::uninit
EXTRN	?freeStatics@CvTeam@@SAXXZ:PROC			; CvTeam::freeStatics
EXTRN	?freeStatics@CvPlayerAI@@SAXXZ:PROC		; CvPlayerAI::freeStatics
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
;	COMDAT ?uninit@CvGlobals@@QAEXXZ
_TEXT	SEGMENT
?uninit@CvGlobals@@QAEXXZ PROC				; CvGlobals::uninit, COMDAT
; _this$ = ecx

; 2212 : {

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 2213 : 	CvPlayerAI::freeStatics();

	call	?freeStatics@CvPlayerAI@@SAXXZ		; CvPlayerAI::freeStatics

; 2214 : 	CvTeam::freeStatics();

	call	?freeStatics@CvTeam@@SAXXZ		; CvTeam::freeStatics

; 2215 : 
; 2216 : 	SAFE_DELETE(m_pEconomicAIStrategies);

	mov	ebx, DWORD PTR [esi+1668]
	xor	edi, edi
	cmp	ebx, edi
	je	SHORT $LN6@uninit
	mov	ecx, ebx
	call	??1CvEconomicAIStrategyXMLEntries@@QAE@XZ ; CvEconomicAIStrategyXMLEntries::~CvEconomicAIStrategyXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@uninit:
	mov	DWORD PTR [esi+1668], edi

; 2217 : 	SAFE_DELETE(m_pCitySpecializations);

	mov	ebx, DWORD PTR [esi+1672]
	cmp	ebx, edi
	je	SHORT $LN13@uninit
	mov	ecx, ebx
	call	??1CvCitySpecializationXMLEntries@@QAE@XZ ; CvCitySpecializationXMLEntries::~CvCitySpecializationXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@uninit:
	mov	DWORD PTR [esi+1672], edi

; 2218 : 	SAFE_DELETE(m_pTacticalMoves);

	mov	ebx, DWORD PTR [esi+1676]
	cmp	ebx, edi
	je	SHORT $LN20@uninit
	mov	ecx, ebx
	call	??1CvTacticalMoveXMLEntries@@QAE@XZ	; CvTacticalMoveXMLEntries::~CvTacticalMoveXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@uninit:
	mov	DWORD PTR [esi+1676], edi

; 2219 : 	SAFE_DELETE(m_pMilitaryAIStrategies);

	mov	ebx, DWORD PTR [esi+1680]
	cmp	ebx, edi
	je	SHORT $LN27@uninit
	mov	ecx, ebx
	call	??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ ; CvMilitaryAIStrategyXMLEntries::~CvMilitaryAIStrategyXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@uninit:
	mov	DWORD PTR [esi+1680], edi

; 2220 : 	SAFE_DELETE(m_pAIGrandStrategies);

	mov	ebx, DWORD PTR [esi+1684]
	cmp	ebx, edi
	je	SHORT $LN34@uninit
	mov	ecx, ebx
	call	??1CvAIGrandStrategyXMLEntries@@QAE@XZ	; CvAIGrandStrategyXMLEntries::~CvAIGrandStrategyXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@uninit:
	mov	DWORD PTR [esi+1684], edi

; 2221 : 	SAFE_DELETE(m_pPolicies);

	mov	ebx, DWORD PTR [esi+1692]
	cmp	ebx, edi
	je	SHORT $LN41@uninit
	mov	ecx, ebx
	call	??1CvPolicyXMLEntries@@QAE@XZ		; CvPolicyXMLEntries::~CvPolicyXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@uninit:
	mov	DWORD PTR [esi+1692], edi

; 2222 : 	SAFE_DELETE(m_pBuildings);

	mov	ebx, DWORD PTR [esi+1700]
	cmp	ebx, edi
	je	SHORT $LN48@uninit
	mov	ecx, ebx
	call	??1CvBuildingXMLEntries@@QAE@XZ		; CvBuildingXMLEntries::~CvBuildingXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN48@uninit:
	mov	DWORD PTR [esi+1700], edi

; 2223 : 	SAFE_DELETE(m_pUnits);

	mov	ebx, DWORD PTR [esi+1704]
	cmp	ebx, edi
	je	SHORT $LN55@uninit
	mov	ecx, ebx
	call	??1CvUnitXMLEntries@@QAE@XZ		; CvUnitXMLEntries::~CvUnitXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN55@uninit:
	mov	DWORD PTR [esi+1704], edi

; 2224 : 	SAFE_DELETE(m_pProjects);

	mov	ebx, DWORD PTR [esi+1708]
	cmp	ebx, edi
	je	SHORT $LN62@uninit
	mov	ecx, ebx
	call	??1CvProjectXMLEntries@@QAE@XZ		; CvProjectXMLEntries::~CvProjectXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN62@uninit:
	mov	DWORD PTR [esi+1708], edi

; 2225 : 	SAFE_DELETE(m_pPromotions);

	mov	ebx, DWORD PTR [esi+1712]
	cmp	ebx, edi
	je	SHORT $LN69@uninit
	mov	ecx, ebx
	call	??1CvPromotionXMLEntries@@QAE@XZ	; CvPromotionXMLEntries::~CvPromotionXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN69@uninit:
	mov	DWORD PTR [esi+1712], edi

; 2226 : 	SAFE_DELETE(m_pEmphases);

	mov	ebx, DWORD PTR [esi+1720]
	cmp	ebx, edi
	je	SHORT $LN76@uninit
	mov	ecx, ebx
	call	??1CvEmphasisXMLEntries@@QAE@XZ		; CvEmphasisXMLEntries::~CvEmphasisXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN76@uninit:
	mov	DWORD PTR [esi+1720], edi

; 2227 : 	SAFE_DELETE(m_pTraits);

	mov	ebx, DWORD PTR [esi+1724]
	cmp	ebx, edi
	je	SHORT $LN83@uninit
	mov	ecx, ebx
	call	??1CvTraitXMLEntries@@QAE@XZ		; CvTraitXMLEntries::~CvTraitXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN83@uninit:
	mov	DWORD PTR [esi+1724], edi

; 2228 : 	SAFE_DELETE(m_pReligions);

	mov	ebx, DWORD PTR [esi+1728]
	cmp	ebx, edi
	je	SHORT $LN90@uninit
	mov	ecx, ebx
	call	??1CvReligionXMLEntries@@QAE@XZ		; CvReligionXMLEntries::~CvReligionXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN90@uninit:
	mov	DWORD PTR [esi+1728], edi

; 2229 : 	SAFE_DELETE(m_pBeliefs);

	mov	ebx, DWORD PTR [esi+1732]
	cmp	ebx, edi
	je	SHORT $LN97@uninit
	mov	ecx, ebx
	call	??1CvBeliefXMLEntries@@QAE@XZ		; CvBeliefXMLEntries::~CvBeliefXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN97@uninit:
	mov	DWORD PTR [esi+1732], edi

; 2230 : 	SAFE_DELETE(m_pLeagueSpecialSessions);

	mov	ebx, DWORD PTR [esi+1736]
	cmp	ebx, edi
	je	SHORT $LN104@uninit
	mov	ecx, ebx
	call	??1CvLeagueSpecialSessionXMLEntries@@QAE@XZ ; CvLeagueSpecialSessionXMLEntries::~CvLeagueSpecialSessionXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN104@uninit:
	mov	DWORD PTR [esi+1736], edi

; 2231 : 	SAFE_DELETE(m_pLeagueNames);

	mov	ebx, DWORD PTR [esi+1740]
	cmp	ebx, edi
	je	SHORT $LN111@uninit
	mov	ecx, ebx
	call	??1CvLeagueNameXMLEntries@@QAE@XZ	; CvLeagueNameXMLEntries::~CvLeagueNameXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN111@uninit:
	mov	DWORD PTR [esi+1740], edi

; 2232 : 	SAFE_DELETE(m_pLeagueProjects);

	mov	ebx, DWORD PTR [esi+1744]
	cmp	ebx, edi
	je	SHORT $LN118@uninit
	mov	ecx, ebx
	call	??1CvLeagueProjectXMLEntries@@QAE@XZ	; CvLeagueProjectXMLEntries::~CvLeagueProjectXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN118@uninit:
	mov	DWORD PTR [esi+1744], edi

; 2233 : 	SAFE_DELETE(m_pLeagueProjectRewards);

	mov	ebx, DWORD PTR [esi+1748]
	cmp	ebx, edi
	je	SHORT $LN125@uninit
	mov	ecx, ebx
	call	??1CvLeagueProjectRewardXMLEntries@@QAE@XZ ; CvLeagueProjectRewardXMLEntries::~CvLeagueProjectRewardXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN125@uninit:
	mov	DWORD PTR [esi+1748], edi

; 2234 : 	SAFE_DELETE(m_pResolutions);

	mov	ebx, DWORD PTR [esi+1752]
	cmp	ebx, edi
	je	SHORT $LN132@uninit
	mov	ecx, ebx
	call	??1CvResolutionXMLEntries@@QAE@XZ	; CvResolutionXMLEntries::~CvResolutionXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN132@uninit:
	mov	DWORD PTR [esi+1752], edi

; 2235 : 	SAFE_DELETE(m_pNotifications);

	mov	ebx, DWORD PTR [esi+1756]
	cmp	ebx, edi
	je	SHORT $LN139@uninit
	mov	ecx, ebx
	call	??1CvNotificationXMLEntries@@QAE@XZ	; CvNotificationXMLEntries::~CvNotificationXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN139@uninit:
	mov	DWORD PTR [esi+1756], edi

; 2236 : 
; 2237 : 	SAFE_DELETE(m_pImprovements); // player uses the improvement count in deallocating.

	mov	ebx, DWORD PTR [esi+1716]
	cmp	ebx, edi
	je	SHORT $LN146@uninit
	mov	ecx, ebx
	call	??1CvImprovementXMLEntries@@QAE@XZ	; CvImprovementXMLEntries::~CvImprovementXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN146@uninit:
	mov	DWORD PTR [esi+1716], edi

; 2238 : 	SAFE_DELETE(m_pTechs);        // improvements uses tech to deallocate. arrghh!

	mov	ebx, DWORD PTR [esi+1696]
	cmp	ebx, edi
	je	SHORT $LN153@uninit
	mov	ecx, ebx
	call	??1CvTechXMLEntries@@QAE@XZ		; CvTechXMLEntries::~CvTechXMLEntries
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN153@uninit:
	mov	DWORD PTR [esi+1696], edi

; 2239 : 
; 2240 : 	SAFE_DELETE(m_map);

	mov	ecx, DWORD PTR [esi+52]
	cmp	ecx, edi
	je	SHORT $LN160@uninit
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN160@uninit:
	mov	DWORD PTR [esi+52], edi

; 2241 : #ifdef AUI_WARNING_FIXES
; 2242 : 	m_game->~CvGame();
; 2243 : 	_aligned_free(m_game);
; 2244 : 	m_game = NULL;
; 2245 : 
; 2246 : 	m_asyncRand->~CvRandom();
; 2247 : 	_aligned_free(m_asyncRand);
; 2248 : 	m_asyncRand = NULL;
; 2249 : #else
; 2250 : 	SAFE_DELETE(m_game);

	mov	ebx, DWORD PTR [esi+48]
	cmp	ebx, edi
	je	SHORT $LN164@uninit
	mov	ecx, ebx
	call	??1CvGame@@QAE@XZ			; CvGame::~CvGame
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN164@uninit:
	mov	DWORD PTR [esi+48], edi

; 2251 : 
; 2252 : 	SAFE_DELETE(m_asyncRand);

	mov	ecx, DWORD PTR [esi+44]
	cmp	ecx, edi
	je	SHORT $LN171@uninit
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN171@uninit:

; 2253 : #endif
; 2254 : 
; 2255 : 	m_kGlobalDefinesLookup.Release();

	lea	ecx, DWORD PTR [esi+916]
	mov	DWORD PTR [esi+44], edi
	call	DWORD PTR __imp_?Release@Results@Database@@QAEXXZ

; 2256 : 
; 2257 : 	if(gDLL)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	cmp	ecx, edi
	je	SHORT $LN1@uninit

; 2258 : 		gDLL->UninitGlobals();	// free globals allocated outside the dll

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+492]
	call	edx
$LN1@uninit:

; 2259 : 
; 2260 : 	SAFE_DELETE(m_pathFinder);

	mov	ebx, DWORD PTR [esi+56]
	cmp	ebx, edi
	je	SHORT $LN179@uninit
	mov	ecx, ebx
	call	??1CvTwoLayerPathFinder@@QAE@XZ		; CvTwoLayerPathFinder::~CvTwoLayerPathFinder
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN179@uninit:
	mov	DWORD PTR [esi+56], edi

; 2261 : 	SAFE_DELETE(m_interfacePathFinder);

	mov	ebx, DWORD PTR [esi+60]
	cmp	ebx, edi
	je	SHORT $LN186@uninit
	mov	ecx, ebx
	call	??1CvTwoLayerPathFinder@@QAE@XZ		; CvTwoLayerPathFinder::~CvTwoLayerPathFinder
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN186@uninit:
	mov	DWORD PTR [esi+60], edi

; 2262 : 	SAFE_DELETE(m_ignoreUnitsPathFinder);

	mov	ebx, DWORD PTR [esi+64]
	cmp	ebx, edi
	je	SHORT $LN193@uninit
	mov	ecx, ebx
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN193@uninit:
	mov	DWORD PTR [esi+64], edi

; 2263 : 	SAFE_DELETE(m_stepFinder);

	mov	ebx, DWORD PTR [esi+68]
	cmp	ebx, edi
	je	SHORT $LN203@uninit
	mov	ecx, ebx
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN203@uninit:
	mov	DWORD PTR [esi+68], edi

; 2264 : 	SAFE_DELETE(m_routeFinder);

	mov	ebx, DWORD PTR [esi+72]
	cmp	ebx, edi
	je	SHORT $LN213@uninit
	mov	ecx, ebx
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN213@uninit:
	mov	DWORD PTR [esi+72], edi

; 2265 : 	SAFE_DELETE(m_waterRouteFinder);

	mov	ebx, DWORD PTR [esi+76]
	cmp	ebx, edi
	je	SHORT $LN220@uninit
	mov	ecx, ebx
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN220@uninit:
	mov	DWORD PTR [esi+76], edi

; 2266 : 	SAFE_DELETE(m_areaFinder);

	mov	ebx, DWORD PTR [esi+84]
	cmp	ebx, edi
	je	SHORT $LN227@uninit
	mov	ecx, ebx
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN227@uninit:
	mov	DWORD PTR [esi+84], edi

; 2267 : 	SAFE_DELETE(m_influenceFinder);

	mov	ebx, DWORD PTR [esi+88]
	cmp	ebx, edi
	je	SHORT $LN234@uninit
	mov	ecx, ebx
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN234@uninit:
	mov	DWORD PTR [esi+88], edi

; 2268 : 	SAFE_DELETE(m_buildRouteFinder);

	mov	ebx, DWORD PTR [esi+92]
	cmp	ebx, edi
	je	SHORT $LN241@uninit
	mov	ecx, ebx
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN241@uninit:
	mov	DWORD PTR [esi+92], edi

; 2269 : 	SAFE_DELETE(m_internationalTradeRouteLandFinder);

	mov	ebx, DWORD PTR [esi+96]
	cmp	ebx, edi
	je	SHORT $LN248@uninit
	mov	ecx, ebx
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN248@uninit:
	mov	DWORD PTR [esi+96], edi

; 2270 : 	SAFE_DELETE(m_internationalTradeRouteWaterFinder);

	mov	ebx, DWORD PTR [esi+100]
	cmp	ebx, edi
	je	SHORT $LN255@uninit
	mov	ecx, ebx
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN255@uninit:
	mov	DWORD PTR [esi+100], edi

; 2271 : 	SAFE_DELETE(m_tacticalAnalysisMapFinder);

	mov	ebx, DWORD PTR [esi+104]
	cmp	ebx, edi
	je	SHORT $LN262@uninit
	mov	ecx, ebx
	call	??1CvTwoLayerPathFinder@@QAE@XZ		; CvTwoLayerPathFinder::~CvTwoLayerPathFinder
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN262@uninit:

; 2272 : 
; 2273 : 	// already deleted outside of the dll, set to null for safety
; 2274 : 	m_pathFinder=NULL;

	mov	DWORD PTR [esi+56], edi

; 2275 : 	m_interfacePathFinder=NULL;

	mov	DWORD PTR [esi+60], edi

; 2276 : 	m_ignoreUnitsPathFinder=NULL;

	mov	DWORD PTR [esi+64], edi

; 2277 : 	m_stepFinder=NULL;

	mov	DWORD PTR [esi+68], edi

; 2278 : 	m_routeFinder=NULL;

	mov	DWORD PTR [esi+72], edi

; 2279 : 	m_waterRouteFinder=NULL;

	mov	DWORD PTR [esi+76], edi

; 2280 : 	m_areaFinder=NULL;

	mov	DWORD PTR [esi+84], edi

; 2281 : 	m_influenceFinder=NULL;

	mov	DWORD PTR [esi+88], edi

; 2282 : 	m_buildRouteFinder = NULL;

	mov	DWORD PTR [esi+92], edi

; 2283 : 	m_internationalTradeRouteLandFinder = NULL;

	mov	DWORD PTR [esi+96], edi

; 2284 : 	m_internationalTradeRouteWaterFinder = NULL;

	mov	DWORD PTR [esi+100], edi

; 2285 : 	m_tacticalAnalysisMapFinder = NULL;

	mov	DWORD PTR [esi+104], edi
	pop	edi
	pop	esi
	pop	ebx

; 2286 : 
; 2287 : #ifdef AUI_DANGER_PLOTS_REMADE
; 2288 : 	SAFE_DELETE(m_pathDangerFinder);
; 2289 : 	m_pathDangerFinder = NULL;
; 2290 : #endif
; 2291 : 
; 2292 : }

	ret	0
?uninit@CvGlobals@@QAEXXZ ENDP				; CvGlobals::uninit
_TEXT	ENDS
PUBLIC	?getCivilizationInfoIndex@CvGlobals@@QAE?AW4CivilizationTypes@@PBD@Z ; CvGlobals::getCivilizationInfoIndex
; Function compile flags: /Ogtpy
;	COMDAT ?getCivilizationInfoIndex@CvGlobals@@QAE?AW4CivilizationTypes@@PBD@Z
_TEXT	SEGMENT
_pszType$ = 8						; size = 4
?getCivilizationInfoIndex@CvGlobals@@QAE?AW4CivilizationTypes@@PBD@Z PROC ; CvGlobals::getCivilizationInfoIndex, COMDAT
; _this$ = ecx

; 2882 : {

	push	ebx
	push	ebp

; 2883 : 	CvAssert(pszType != NULL);
; 2884 : 	if(pszType != NULL)

	mov	ebp, DWORD PTR _pszType$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	test	ebp, ebp
	je	SHORT $LN2@getCiviliz@2

; 2885 : 	{
; 2886 : 		int iIndex = 0;
; 2887 : 		for(std::vector<CvCivilizationInfo*>::iterator itr = m_paCivilizationInfo.begin(); itr != m_paCivilizationInfo.end(); ++itr, ++iIndex)

	mov	esi, DWORD PTR [edi+1232]
	xor	ebx, ebx
	cmp	esi, DWORD PTR [edi+1236]
	je	SHORT $LN2@getCiviliz@2
	npad	2
$LL4@getCiviliz@2:

; 2888 : 		{
; 2889 : 			const char* szType = (*itr)->GetType();

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 2890 : 			if(szType && strcmp(szType, pszType) == 0)

	test	eax, eax
	je	SHORT $LN3@getCiviliz@2
	mov	ecx, ebp
$LL37@getCiviliz@2:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN38@getCiviliz@2
	test	dl, dl
	je	SHORT $LN39@getCiviliz@2
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN38@getCiviliz@2
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL37@getCiviliz@2
$LN39@getCiviliz@2:
	xor	eax, eax
	jmp	SHORT $LN40@getCiviliz@2
$LN38@getCiviliz@2:
	sbb	eax, eax
	sbb	eax, -1
$LN40@getCiviliz@2:
	test	eax, eax
	je	SHORT $LN35@getCiviliz@2
$LN3@getCiviliz@2:

; 2885 : 	{
; 2886 : 		int iIndex = 0;
; 2887 : 		for(std::vector<CvCivilizationInfo*>::iterator itr = m_paCivilizationInfo.begin(); itr != m_paCivilizationInfo.end(); ++itr, ++iIndex)

	add	esi, 4
	inc	ebx
	cmp	esi, DWORD PTR [edi+1236]
	jne	SHORT $LL4@getCiviliz@2
$LN2@getCiviliz@2:
	pop	edi
	pop	esi
	pop	ebp

; 2892 : 		}
; 2893 : 	}
; 2894 : 	return NO_CIVILIZATION;

	or	eax, -1
	pop	ebx

; 2895 : }

	ret	4
$LN35@getCiviliz@2:
	pop	edi
	pop	esi
	pop	ebp

; 2891 : 				return (CivilizationTypes)iIndex;

	mov	eax, ebx
	pop	ebx

; 2895 : }

	ret	4
?getCivilizationInfoIndex@CvGlobals@@QAE?AW4CivilizationTypes@@PBD@Z ENDP ; CvGlobals::getCivilizationInfoIndex
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::find
; Function compile flags: /Ogtpy
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z
_TEXT	SEGMENT
$T272441 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+21], 0
	push	edi
	mov	edi, DWORD PTR __Keyval$[esp+4]
	jne	SHORT $LN9@find
	push	esi
	mov	esi, DWORD PTR [edi]
$LL10@find:
	cmp	DWORD PTR [eax+12], esi
	jae	SHORT $LN8@find
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@find
$LN8@find:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@find:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@find
	pop	esi
$LN9@find:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+4], edx
	cmp	edx, eax
	je	SHORT $LN3@find
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [edx+12]
	jb	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[esp+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
$LN3@find:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	DWORD PTR $T272441[esp+8], eax
	lea	eax, DWORD PTR $T272441[esp+8]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::find
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::vector<CvColorInfo *,std::allocator<CvColorInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::vector<CvColorInfo *,std::allocator<CvColorInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::vector<CvColorInfo *,std::allocator<CvColorInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::vector<CvActionInfo *,std::allocator<CvActionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::vector<CvActionInfo *,std::allocator<CvActionInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::vector<CvActionInfo *,std::allocator<CvActionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::vector<CvControlInfo *,std::allocator<CvControlInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::vector<CvControlInfo *,std::allocator<CvControlInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::vector<CvControlInfo *,std::allocator<CvControlInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::vector<CvEraInfo *,std::allocator<CvEraInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::vector<CvEraInfo *,std::allocator<CvEraInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::vector<CvEraInfo *,std::allocator<CvEraInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAE@XZ ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAEXXZ ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAEXXZ ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAEXXZ ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAEXXZ ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAEXXZ ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAEXXZ ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@6

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@6:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAEXXZ ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAEXXZ ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@8

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@8:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAEXXZ ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@9

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@9:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAEXXZ ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@10

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@10:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAEXXZ ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@11

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@11:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAEXXZ ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@12

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@12:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAEXXZ ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@13

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@13:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAEXXZ ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@14

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@14:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAEXXZ ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@15

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@15:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAEXXZ ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@16

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@16:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAEXXZ ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@17

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@17:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAEXXZ ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@18

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@18:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAEXXZ ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@19

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@19:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAEXXZ ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@20

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@20:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAEXXZ ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@21

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@21:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAEXXZ ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@22

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@22:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAEXXZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@23

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@23:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@24

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@24:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@25

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@25:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@26

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@26:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAEXXZ ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@27

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@27:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAEXXZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@28

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@28:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAEXXZ ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@29

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@29:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAEXXZ ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@30

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@30:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAEXXZ ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@31

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@31:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAEXXZ ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@32

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@32:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAEXXZ ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@33

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@33:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAEXXZ ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@34

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@34:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAEXXZ ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@35

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@35:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAEXXZ ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@36

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@36:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAEXXZ ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@37

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@37:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAEXXZ ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@38

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@38:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$_List_val@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::_List_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_List_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_List_val@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_val@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ PROC ; std::_List_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_List_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_List_val@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ENDP ; std::_List_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_List_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z PROC ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	add	ecx, 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ENDP ; std::allocator<std::_List_nod<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??0?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@ABV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@1@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@ABV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@ABV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@1@@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT
; _this$ = ecx

; 476  : 		{	// construct empty vector with allocator

	mov	eax, ecx

; 477  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 478  : 		}

	ret	4
??0?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@ABV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@1@@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	?_Hashval@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IBEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Hashval
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?_Hashval@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IBEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Hashval@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IBEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Hashval, COMDAT
; _this$ = ecx

; 822  : 		size_type _Num = this->comp(_Keyval) & _Mask;

	mov	eax, DWORD PTR __Keyval$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??$hash_value@DU?$char_traits@D@std@@V?$allocator@D@2@@stdext@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stdext::hash_value<char,std::char_traits<char>,std::allocator<char> >
	and	eax, 2147483647				; 7fffffffH
	push	127773					; 0001f31dH
	push	eax
	call	DWORD PTR __imp__ldiv
	imul	edx, 16807				; 000041a7H
	imul	eax, 2836				; 00000b14H
	add	esp, 12					; 0000000cH
	sub	edx, eax
	jns	SHORT $LN4@Hashval
	add	edx, 2147483647				; 7fffffffH
$LN4@Hashval:
	mov	ecx, DWORD PTR [esi+32]
	mov	eax, ecx
	and	eax, edx

; 823  : 		if (_Maxidx <= _Num)

	cmp	DWORD PTR [esi+36], eax
	pop	esi
	ja	SHORT $LN1@Hashval

; 824  : 			_Num -= (_Mask >> 1) + 1;

	shr	ecx, 1
	or	edx, -1
	sub	edx, ecx
	add	eax, edx
$LN1@Hashval:

; 825  : 		return (_Num);
; 826  : 		}

	ret	4
?_Hashval@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IBEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Hashval
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T276814 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@39
	cmp	edx, eax
	jne	SHORT $LN101@erase@39

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@39:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@39
	npad	2
$LL2@erase@39:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+21], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@39
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN103@erase@39
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN79@erase@39
	npad	5
$LL80@erase@39:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL80@erase@39
$LN79@erase@39:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@39
$LN103@erase@39:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN63@erase@39
	npad	7
$LL64@erase@39:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@39
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL64@erase@39
$LN63@erase@39:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@39:
	push	edx
	lea	eax, DWORD PTR $T276814[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@39
$LN1@erase@39:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+21], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z
_TEXT	SEGMENT
$T277165 = -80						; size = 28
$T277164 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 536870910		; 1ffffffeH
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T277165[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T277164[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T277165[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T277164[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T277164[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T277164[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T277164[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+20], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+20], 0
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+20], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+20], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+20], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+20], 0
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+20], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+20], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+20], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN170@Insert
	mov	DWORD PTR [edx+4], eax
$LN170@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert
$LN169@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert
$LN167@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+20], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+20], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z$0:
	lea	ecx, DWORD PTR $T277165[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z$2:
	lea	ecx, DWORD PTR $T277164[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
PUBLIC	?erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::erase, COMDAT
; _this$ = ecx

; 786  : 		{	// erase element at _Where

	push	esi

; 787  : 
; 788  :  #if _HAS_ITERATOR_DEBUGGING
; 789  : 		if (_Where._Mycont != this || _Where._Ptr == _Myhead)
; 790  : 			_DEBUG_ERROR("list erase iterator outside range");
; 791  : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 792  : 		_Orphan_ptr(*this, _Pnode);
; 793  : 
; 794  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 795  : 		_Nodeptr _Pnode = (_Where++)._Mynode();

	mov	esi, DWORD PTR __Where$[esp]
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR __Where$[esp+4], ecx

; 796  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 797  : 
; 798  : 		if (_Pnode != _Myhead)

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN45@erase@40

; 799  : 			{	// not list head, safe to erase
; 800  : 			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 801  : 			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]

; 802  : 			this->_Alnod.destroy(_Pnode);

	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [edx+4], eax
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 803  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	esi
	call	??3@YAXPAX@Z				; operator delete

; 804  : 			--_Mysize;
; 805  : 			}
; 806  : 		return (_Make_iter(_Where));

	mov	ecx, DWORD PTR __Where$[esp+8]
	add	esp, 4
	dec	DWORD PTR [edi+8]
$LN45@erase@40:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 807  : 		}

	ret	8
?erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::erase
_TEXT	ENDS
PUBLIC	??0?$_List_val@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ; std::_List_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_List_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_val@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_val@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z PROC ; std::_List_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_List_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx

; 85   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 86   : 		}

	ret	4
??0?$_List_val@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ENDP ; std::_List_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_List_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z$0
__unwindtable$?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z$2
__ehfuncinfo$?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z
_TEXT	SEGMENT
__Pnode$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode, COMDAT
; _this$ = ecx

; 1190 : 		{	// allocate a node and set links and value

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1191 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR __Pnode$[ebp], esi

; 1192 : 		int _Linkcnt = 0;
; 1193 : 
; 1194 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1195 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Next);

	test	esi, esi
	je	SHORT $LN27@Buynode@4
	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR [esi], eax
$LN27@Buynode@4:

; 1196 : 		++_Linkcnt;
; 1197 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);

	lea	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN37@Buynode@4
	mov	ecx, DWORD PTR __Prev$[ebp]
	mov	DWORD PTR [eax], ecx
$LN37@Buynode@4:

; 1198 : 		++_Linkcnt;
; 1199 : 		this->_Alval.construct(&_Myval(_Pnode), _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	??$_Construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@U12@@std@@YAXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@ABU10@@Z ; std::_Construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >

; 1207 : 		_CATCH_END
; 1208 : 		return (_Pnode);
; 1209 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	add	esp, 8
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z$0:

; 1200 : 		_CATCH_ALL
; 1201 : 		if (1 < _Linkcnt)
; 1202 : 			this->_Alptr.destroy(&_Prevnode(_Pnode));
; 1203 : 		if (0 < _Linkcnt)
; 1204 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1205 : 		this->_Alnod.deallocate(_Pnode, 1);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1206 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN54@Buynode@4:
$LN53@Buynode@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode
PUBLIC	??$_Destroy_range@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@stdext@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IABV123@AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@Z ; stdext::unchecked_uninitialized_fill_n<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,unsigned int,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@stdext@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IABV123@AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@Z
_TEXT	SEGMENT
$T277907 = -4						; size = 1
__Cat$277912 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@stdext@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IABV123@AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,unsigned int,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T277907[esp+4], 0
	mov	eax, DWORD PTR $T277907[esp+4]
	mov	ecx, DWORD PTR __Cat$277912[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IABV120@AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,unsigned int,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@stdext@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IABV123@AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,unsigned int,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEXXZ ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEXXZ ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@2
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@2:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@2:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEXXZ ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@3
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@3
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@3:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@3:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEXXZ ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@4
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@4
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@4:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@4:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEXXZ ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@5
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@5
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@5:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@5:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEXXZ ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@6
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@6
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@6:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@6:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEXXZ ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@7
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@7
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@7:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@7:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEXXZ ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@8
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@8
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@8:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@8:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEXXZ ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@9
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@9
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@9:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@9:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEXXZ ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@10
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@10
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@10:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@10:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEXXZ ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@11
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@11
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@11:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@11:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEXXZ ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@12
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@12
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@12:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@12:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAEXXZ ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@13
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@13
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@13:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@13:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEXXZ ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@14
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@14
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@14:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@14:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEXXZ ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@15
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@15
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@15:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@15:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEXXZ ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@16
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@16
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@16:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@16:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEXXZ ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@17
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@17
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@17:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@17:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEXXZ ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@18
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@18
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@18:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@18:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEXXZ ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@19
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@19
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@19:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@19:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEXXZ ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@20
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@20
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@20:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@20:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEXXZ ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@21
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@21
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@21:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@21:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEXXZ ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@22
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@22
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@22:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@22:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEXXZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@23
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@23
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@23:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@23:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEXXZ ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@24
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@24
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@24:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@24:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEXXZ ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@25
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@25
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@25:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@25:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEXXZ ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@26
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@26
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@26:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@26:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEXXZ ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@27
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@27
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@27:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@27:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEXXZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@28
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@28
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@28:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@28:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEXXZ ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@29
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@29
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@29:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@29:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEXXZ ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@30
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@30
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@30:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@30:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEXXZ ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@31
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@31
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@31:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@31:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEXXZ ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@32
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@32
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@32:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@32:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEXXZ ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@33
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@33
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@33:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@33:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEXXZ ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@34
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@34
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@34:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@34:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEXXZ ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@35
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@35
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@35:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@35:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEXXZ ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@36
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@36
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@36:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@36:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEXXZ ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@37
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@37
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@37:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@37:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::clear
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvTurnTimerInfo@@@@YAXAAPAVCvTurnTimerInfo@@@Z ; SAFE_DELETE<CvTurnTimerInfo>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvTurnTimerInfo@@@@YAXAAPAVCvTurnTimerInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvTurnTimerInfo@@@@YAXAAPAVCvTurnTimerInfo@@@Z PROC ; SAFE_DELETE<CvTurnTimerInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@56
	mov	ecx, esi
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@56:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvTurnTimerInfo@@@@YAXAAPAVCvTurnTimerInfo@@@Z ENDP ; SAFE_DELETE<CvTurnTimerInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvHurryInfo@@@@YAXAAPAVCvHurryInfo@@@Z ; SAFE_DELETE<CvHurryInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvHurryInfo@@@@YAXAAPAVCvHurryInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvHurryInfo@@@@YAXAAPAVCvHurryInfo@@@Z PROC ; SAFE_DELETE<CvHurryInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@57
	mov	ecx, esi
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@57:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvHurryInfo@@@@YAXAAPAVCvHurryInfo@@@Z ENDP ; SAFE_DELETE<CvHurryInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvColorInfo@@@@YAXAAPAVCvColorInfo@@@Z ; SAFE_DELETE<CvColorInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvColorInfo@@@@YAXAAPAVCvColorInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvColorInfo@@@@YAXAAPAVCvColorInfo@@@Z PROC ; SAFE_DELETE<CvColorInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@58
	mov	ecx, esi
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@58:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvColorInfo@@@@YAXAAPAVCvColorInfo@@@Z ENDP ; SAFE_DELETE<CvColorInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvPlayerColorInfo@@@@YAXAAPAVCvPlayerColorInfo@@@Z ; SAFE_DELETE<CvPlayerColorInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvPlayerColorInfo@@@@YAXAAPAVCvPlayerColorInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvPlayerColorInfo@@@@YAXAAPAVCvPlayerColorInfo@@@Z PROC ; SAFE_DELETE<CvPlayerColorInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@59
	mov	ecx, esi
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@59:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvPlayerColorInfo@@@@YAXAAPAVCvPlayerColorInfo@@@Z ENDP ; SAFE_DELETE<CvPlayerColorInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvInterfaceModeInfo@@@@YAXAAPAVCvInterfaceModeInfo@@@Z ; SAFE_DELETE<CvInterfaceModeInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvInterfaceModeInfo@@@@YAXAAPAVCvInterfaceModeInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvInterfaceModeInfo@@@@YAXAAPAVCvInterfaceModeInfo@@@Z PROC ; SAFE_DELETE<CvInterfaceModeInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@60
	mov	ecx, esi
	call	??1CvHotKeyInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@60:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvInterfaceModeInfo@@@@YAXAAPAVCvInterfaceModeInfo@@@Z ENDP ; SAFE_DELETE<CvInterfaceModeInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvUnitClassInfo@@@@YAXAAPAVCvUnitClassInfo@@@Z ; SAFE_DELETE<CvUnitClassInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvUnitClassInfo@@@@YAXAAPAVCvUnitClassInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvUnitClassInfo@@@@YAXAAPAVCvUnitClassInfo@@@Z PROC ; SAFE_DELETE<CvUnitClassInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@61
	mov	ecx, esi
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@61:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvUnitClassInfo@@@@YAXAAPAVCvUnitClassInfo@@@Z ENDP ; SAFE_DELETE<CvUnitClassInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvMissionInfo@@@@YAXAAPAVCvMissionInfo@@@Z ; SAFE_DELETE<CvMissionInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvMissionInfo@@@@YAXAAPAVCvMissionInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvMissionInfo@@@@YAXAAPAVCvMissionInfo@@@Z PROC ; SAFE_DELETE<CvMissionInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@62
	mov	ecx, esi
	call	??1CvMissionInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@62:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvMissionInfo@@@@YAXAAPAVCvMissionInfo@@@Z ENDP ; SAFE_DELETE<CvMissionInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvControlInfo@@@@YAXAAPAVCvControlInfo@@@Z ; SAFE_DELETE<CvControlInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvControlInfo@@@@YAXAAPAVCvControlInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvControlInfo@@@@YAXAAPAVCvControlInfo@@@Z PROC ; SAFE_DELETE<CvControlInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@63
	mov	ecx, esi
	call	??1CvHotKeyInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@63:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvControlInfo@@@@YAXAAPAVCvControlInfo@@@Z ENDP ; SAFE_DELETE<CvControlInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvCommandInfo@@@@YAXAAPAVCvCommandInfo@@@Z ; SAFE_DELETE<CvCommandInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvCommandInfo@@@@YAXAAPAVCvCommandInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvCommandInfo@@@@YAXAAPAVCvCommandInfo@@@Z PROC ; SAFE_DELETE<CvCommandInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@64
	mov	ecx, esi
	call	??1CvHotKeyInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@64:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvCommandInfo@@@@YAXAAPAVCvCommandInfo@@@Z ENDP ; SAFE_DELETE<CvCommandInfo>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvAutomateInfo@@@@YAXAAPAVCvAutomateInfo@@@Z ; SAFE_DELETE<CvAutomateInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvAutomateInfo@@@@YAXAAPAVCvAutomateInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvAutomateInfo@@@@YAXAAPAVCvAutomateInfo@@@Z PROC ; SAFE_DELETE<CvAutomateInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN11@SAFE_DELET@65
	mov	ecx, esi
	call	??1CvHotKeyInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@SAFE_DELET@65:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvAutomateInfo@@@@YAXAAPAVCvAutomateInfo@@@Z ENDP ; SAFE_DELETE<CvAutomateInfo>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@U_Undefined_move_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@U_Undefined_move_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T283945 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$283949 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@U_Undefined_move_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$283949[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T283945[esp+4], 0
	mov	eax, DWORD PTR $T283945[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@U_Undefined_move_tag@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@@Z ; std::_Destroy_range<std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum AnimationPathTypes> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	?getInfoTypeForHash@CvGlobals@@QBEHI_N@Z	; CvGlobals::getInfoTypeForHash
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
;	COMDAT ?getInfoTypeForHash@CvGlobals@@QBEHI_N@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
_uiHash$ = 8						; size = 4
_hideAssert$ = 12					; size = 1
?getInfoTypeForHash@CvGlobals@@QBEHI_N@Z PROC		; CvGlobals::getInfoTypeForHash, COMDAT
; _this$ = ecx

; 6996 : {

	push	ecx
	push	esi
	mov	esi, ecx

; 6997 : 
; 6998 : 	InfosHashMap::const_iterator it = m_infosHashMap.find(uiHash);

	lea	eax, DWORD PTR _uiHash$[esp+4]
	push	eax
	lea	ecx, DWORD PTR _it$[esp+12]
	push	ecx
	lea	ecx, DWORD PTR [esi+1024]
	call	?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::find

; 6999 : 	if(it!=m_infosHashMap.end())

	mov	eax, DWORD PTR _it$[esp+8]
	cmp	eax, DWORD PTR [esi+1028]
	pop	esi
	je	SHORT $LN2@getInfoTyp

; 7000 : 	{
; 7001 : 		return it->second;

	mov	eax, DWORD PTR [eax+16]

; 7010 : }

	pop	ecx
	ret	8
$LN2@getInfoTyp:

; 7002 : 	}
; 7003 : 
; 7004 : 	if(!hideAssert)
; 7005 : 	{
; 7006 : 		CvAssertMsg(uiHash==0, "Could not find resource hash");
; 7007 : 	}
; 7008 : 
; 7009 : 	return -1;

	or	eax, -1

; 7010 : }

	pop	ecx
	ret	8
?getInfoTypeForHash@CvGlobals@@QBEHI_N@Z ENDP		; CvGlobals::getInfoTypeForHash
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::~vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::~vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::~vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::~vector<CvColorInfo *,std::allocator<CvColorInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::~vector<CvColorInfo *,std::allocator<CvColorInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::~vector<CvColorInfo *,std::allocator<CvColorInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::~vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::~vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@4:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::~vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::~vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::~vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@5:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::~vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::~vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::~vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@6:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::~vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::~vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::~vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@7:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::~vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::~vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::~vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@8:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::~vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::~vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::~vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@9
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@9:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::~vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::~vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::~vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@10
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@10:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::~vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::~vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::~vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@11
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@11:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::~vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::~vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::~vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@12
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@12:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::~vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::~vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::~vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@13
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@13:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::~vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::~vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::~vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@14
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@14:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::~vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::~vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::~vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@15
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@15:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::~vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::~vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::~vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@16
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@16:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::~vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::~vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::~vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@17
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@17:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::~vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::~vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::~vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@18
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@18:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::~vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::~vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::~vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@19
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@19:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::~vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::~vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::~vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@20
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@20:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::~vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::~vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::~vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@21
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@21:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::~vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::~vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::~vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@22
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@22:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::~vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::~vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::~vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@23
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@23:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::~vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::~vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::~vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@24
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@24:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::~vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::~vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::~vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@25
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@25:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::~vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::~vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::~vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@26
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@26:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::~vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::~vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::~vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@27
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@27:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::~vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::~vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::~vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@28
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@28:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::~vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::~vector<CvActionInfo *,std::allocator<CvActionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::~vector<CvActionInfo *,std::allocator<CvActionInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@29
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@29:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::~vector<CvActionInfo *,std::allocator<CvActionInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::~vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::~vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@30
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@30:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::~vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::~vector<CvControlInfo *,std::allocator<CvControlInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::~vector<CvControlInfo *,std::allocator<CvControlInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@31
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@31:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::~vector<CvControlInfo *,std::allocator<CvControlInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::~vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::~vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@32
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@32:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::~vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::~vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::~vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@33
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@33:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::~vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::~vector<CvEraInfo *,std::allocator<CvEraInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::~vector<CvEraInfo *,std::allocator<CvEraInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@34
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@34:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::~vector<CvEraInfo *,std::allocator<CvEraInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::~vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::~vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@35
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@35:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::~vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::~vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::~vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@36
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@36:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::~vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::~vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::~vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@37
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@37:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::~vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::~vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::~vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@38
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@38:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::~vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAE@XZ ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::~vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::~vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@39
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@39:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvMultiUnitFormationInfo@@V?$allocator@PAVCvMultiUnitFormationInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >::~vector<CvMultiUnitFormationInfo *,std::allocator<CvMultiUnitFormationInfo *> >
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::clear, COMDAT
; _this$ = ecx

; 825  : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 826  : 
; 827  :  #if _HAS_ITERATOR_DEBUGGING
; 828  : 		this->_Orphan_ptr(*this, 0);
; 829  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 830  : 
; 831  : 		_Nodeptr _Pnext;
; 832  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [eax]

; 833  : 		_Nextnode(_Myhead) = _Myhead;

	mov	DWORD PTR [eax], eax

; 834  : 		_Prevnode(_Myhead) = _Myhead;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], eax

; 835  : 		_Mysize = 0;

	mov	DWORD PTR [edi+8], 0

; 836  : 
; 837  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN1@clear@38
	push	ebx
	npad	2
$LL3@clear@38:

; 838  : 			{	// delete an element
; 839  : 			_Pnext = _Nextnode(_Pnode);

	mov	ebx, DWORD PTR [esi]

; 840  : 			this->_Alnod.destroy(_Pnode);

	lea	ecx, DWORD PTR [esi+8]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 841  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	esi, ebx
	cmp	ebx, DWORD PTR [edi+4]
	jne	SHORT $LL3@clear@38
	pop	ebx
$LN1@clear@38:
	pop	edi
	pop	esi

; 842  : 			}
; 843  : 		}

	ret	0
?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::clear
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?lower_bound@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z
_TEXT	SEGMENT
$T284599 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 637  : 		{	// find leftmost not less than _Keyval in mutable hash table

	push	ecx
	push	ebx
	push	ebp

; 638  : 		size_type _Bucket = _Hashval(_Keyval);

	mov	ebp, DWORD PTR __Keyval$[esp+8]
	push	esi
	push	edi
	push	ebp
	mov	edi, ecx
	call	?_Hashval@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IBEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Hashval
	mov	ebx, eax

; 639  : 		iterator _Where;
; 640  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	eax, DWORD PTR [edi+20]
	mov	esi, DWORD PTR [eax+ebx*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR __Where$[esp+16], esi
	cmp	DWORD PTR [eax+4], esi
	je	SHORT $LN2@lower_boun@3
$LL19@lower_boun@3:

; 641  : 			if (!this->comp(this->_Kfn(*_Where), _Keyval))

	lea	ecx, DWORD PTR [esi+8]
	push	ebp
	push	ecx
	call	DWORD PTR __imp_??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN70@lower_boun@3
	mov	esi, DWORD PTR [esi]
	mov	edx, DWORD PTR [edi+20]
	cmp	DWORD PTR [edx+ebx*4+4], esi
	jne	SHORT $LL19@lower_boun@3

; 639  : 		iterator _Where;
; 640  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	DWORD PTR __Where$[esp+16], esi
$LN2@lower_boun@3:

; 644  : 		return (end());

	mov	edx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	pop	ebx

; 645  : 		}

	pop	ecx
	ret	8
$LN70@lower_boun@3:

; 639  : 		iterator _Where;
; 640  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	DWORD PTR __Where$[esp+16], esi

; 642  : 				return (this->comp(_Keyval,
; 643  : 					this->_Kfn(*_Where)) ? end() : _Where);

	add	esi, 8
	push	esi
	push	ebp
	call	DWORD PTR __imp_??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN7@lower_boun@3
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR $T284599[esp+20], eax
	pop	edi
	lea	eax, DWORD PTR $T284599[esp+16]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 645  : 		}

	pop	ecx
	ret	8
$LN7@lower_boun@3:
	pop	edi

; 642  : 				return (this->comp(_Keyval,
; 643  : 					this->_Kfn(*_Where)) ? end() : _Where);

	lea	eax, DWORD PTR __Where$[esp+12]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 645  : 		}

	pop	ecx
	ret	8
?lower_bound@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z
_TEXT	SEGMENT
$T284755 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 648  : 		{	// find leftmost not less than _Keyval in nonmutable hash table

	push	ecx
	push	ebx
	push	ebp

; 649  : 		size_type _Bucket = _Hashval(_Keyval);

	mov	ebp, DWORD PTR __Keyval$[esp+8]
	push	esi
	push	edi
	push	ebp
	mov	edi, ecx
	call	?_Hashval@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IBEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Hashval
	mov	ebx, eax

; 650  : 		const_iterator _Where;
; 651  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	eax, DWORD PTR [edi+20]
	mov	esi, DWORD PTR [eax+ebx*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR __Where$[esp+16], esi
	cmp	DWORD PTR [eax+4], esi
	je	SHORT $LN2@lower_boun@4
$LL15@lower_boun@4:

; 652  : 			if (!this->comp(this->_Kfn(*_Where), _Keyval))

	lea	ecx, DWORD PTR [esi+8]
	push	ebp
	push	ecx
	call	DWORD PTR __imp_??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN58@lower_boun@4
	mov	esi, DWORD PTR [esi]
	mov	edx, DWORD PTR [edi+20]
	cmp	DWORD PTR [edx+ebx*4+4], esi
	jne	SHORT $LL15@lower_boun@4

; 650  : 		const_iterator _Where;
; 651  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	DWORD PTR __Where$[esp+16], esi
$LN2@lower_boun@4:

; 655  : 		return (end());

	mov	edx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	pop	ebx

; 656  : 		}

	pop	ecx
	ret	8
$LN58@lower_boun@4:

; 650  : 		const_iterator _Where;
; 651  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	DWORD PTR __Where$[esp+16], esi

; 653  : 				return (this->comp(_Keyval,
; 654  : 					this->_Kfn(*_Where)) ? end() : _Where);

	add	esi, 8
	push	esi
	push	ebp
	call	DWORD PTR __imp_??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN7@lower_boun@4
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR $T284755[esp+20], eax
	pop	edi
	lea	eax, DWORD PTR $T284755[esp+16]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 656  : 		}

	pop	ecx
	ret	8
$LN7@lower_boun@4:
	pop	edi

; 653  : 				return (this->comp(_Keyval,
; 654  : 					this->_Kfn(*_Where)) ? end() : _Where);

	lea	eax, DWORD PTR __Where$[esp+12]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 656  : 		}

	pop	ecx
	ret	8
?lower_bound@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T284869 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T284869[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx

; 441  : 		{	// construct empty list, allocator

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], 0

; 442  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Tidy, COMDAT
; _this$ = ecx

; 1212 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1213 : 		clear();

	call	?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::clear

; 1214 : 		this->_Alptr.destroy(&_Nextnode(_Myhead));
; 1215 : 		this->_Alptr.destroy(&_Prevnode(_Myhead));
; 1216 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1217 : 		_Myhead = 0;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 1218 : 		}

	ret	0
?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Tidy
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T285044 = 12						; size = 4
$T285042 = 12						; size = 4
__Where$235063 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+21], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setb	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@insert
$LN9@insert:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$235063[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T285042[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$235063[esp+12]
$LN57@insert:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T285044[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@0@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@0@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@0@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Destroy
_TEXT	ENDS
PUBLIC	?_Insert@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Insert@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert, COMDAT
; _this$ = ecx

; 711  : 
; 712  :  #if _HAS_ITERATOR_DEBUGGING
; 713  : 		if (_Where._Mycont != this)
; 714  : 			_DEBUG_ERROR("list insert iterator outside range");
; 715  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 716  : 
; 717  : 		_Nodeptr _Pnode = _Where._Mynode();
; 718  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

	mov	eax, DWORD PTR __Where$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR __Val$[esp+8]
	lea	ebx, DWORD PTR [eax+4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, edi
	call	?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode

; 719  : 		_Incsize(1);

	push	1
	mov	ecx, edi
	mov	esi, eax
	call	?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Incsize

; 720  : 		_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [ebx], esi

; 721  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 722  : 		}

	ret	8
?_Insert@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert
_TEXT	ENDS
PUBLIC	?erase@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@V?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@0@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@V?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@V?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@0@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@41
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@41
	push	ebx
	npad	4
$LL28@erase@41:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	add	edx, 4
	add	esi, 4
	cmp	edx, edi
	jne	SHORT $LL28@erase@41
	pop	ebx
$LN26@erase@41:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@41:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE?AV?$_Vector_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@V?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@0@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::erase
_TEXT	ENDS
PUBLIC	?erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@0@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@0@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::erase, COMDAT
; _this$ = ecx

; 810  : 		{	// erase [_First, _Last)

	push	esi

; 811  : 		if (_First == begin() && _Last == end())

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR __Last$[esp+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN85@erase@42
	cmp	ecx, eax
	jne	SHORT $LN85@erase@42

; 812  : 			{	// erase all and return fresh iterator
; 813  : 			clear();

	mov	ecx, edi
	call	?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::clear

; 814  : 			return (end());

	mov	ecx, DWORD PTR [edi+4]

; 820  : 			return (_Make_iter(_Last));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 821  : 			}
; 822  : 		}

	ret	12					; 0000000cH
$LN85@erase@42:

; 815  : 			}
; 816  : 		else
; 817  : 			{	// erase subrange
; 818  : 			while (_First != _Last)

	cmp	esi, ecx
	je	SHORT $LN1@erase@42
	push	ebx
$LL2@erase@42:

; 819  : 				_First = erase(_First);

	mov	ebx, DWORD PTR [esi]
	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN35@erase@42
	mov	edx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], ebx
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], edx
	lea	ecx, DWORD PTR [esi+8]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __Last$[esp+12]
	add	esp, 4
	dec	DWORD PTR [edi+8]
$LN35@erase@42:
	mov	esi, ebx
	mov	DWORD PTR __First$[esp+8], esi
	cmp	ebx, ecx
	jne	SHORT $LL2@erase@42
	pop	ebx
$LN1@erase@42:

; 820  : 			return (_Make_iter(_Last));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 821  : 			}
; 822  : 		}

	ret	12					; 0000000cH
?erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@0@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::erase
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAV342@IABV342@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAV342@IABV342@@Z
_TEXT	SEGMENT
$T285610 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$285613 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAV342@IABV342@@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$285613[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T285610[esp+12], 0
	mov	eax, DWORD PTR $T285610[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IABV120@AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,unsigned int,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAV342@IABV342@@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Ufill
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvBuildingClassInfo@@@@YAXAAV?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@@Z ; deleteInfoArray<CvBuildingClassInfo>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
;	COMDAT ??$deleteInfoArray@VCvBuildingClassInfo@@@@YAXAAV?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvBuildingClassInfo@@@@YAXAAV?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvBuildingClassInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo
	npad	2
$LL14@deleteInfo:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo
$LN1@deleteInfo:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvBuildingClassInfo@@@@YAXAAV?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvBuildingClassInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvLeaderHeadInfo@@@@YAXAAV?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@@Z ; deleteInfoArray<CvLeaderHeadInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvLeaderHeadInfo@@@@YAXAAV?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvLeaderHeadInfo@@@@YAXAAV?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvLeaderHeadInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@2
	npad	2
$LL14@deleteInfo@2:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@2
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@2:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@2
$LN1@deleteInfo@2:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@2
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@2:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@2:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvLeaderHeadInfo@@@@YAXAAV?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvLeaderHeadInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvCivilizationInfo@@@@YAXAAV?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@@Z ; deleteInfoArray<CvCivilizationInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvCivilizationInfo@@@@YAXAAV?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvCivilizationInfo@@@@YAXAAV?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvCivilizationInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@3
	npad	2
$LL14@deleteInfo@3:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@3
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@3:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@3
$LN1@deleteInfo@3:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@3
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@3
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@3:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@3:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvCivilizationInfo@@@@YAXAAV?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvCivilizationInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvMinorCivInfo@@@@YAXAAV?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@@Z ; deleteInfoArray<CvMinorCivInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvMinorCivInfo@@@@YAXAAV?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvMinorCivInfo@@@@YAXAAV?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvMinorCivInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@4
	npad	2
$LL14@deleteInfo@4:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@4
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@4:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@4
$LN1@deleteInfo@4:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@4
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@4
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@4:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@4:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvMinorCivInfo@@@@YAXAAV?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvMinorCivInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvVoteSourceInfo@@@@YAXAAV?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@@Z ; deleteInfoArray<CvVoteSourceInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvVoteSourceInfo@@@@YAXAAV?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvVoteSourceInfo@@@@YAXAAV?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvVoteSourceInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@5
	npad	2
$LL14@deleteInfo@5:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@5
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@5:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@5
$LN1@deleteInfo@5:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@5
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@5
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@5:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@5:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvVoteSourceInfo@@@@YAXAAV?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvVoteSourceInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvHandicapInfo@@@@YAXAAV?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@@Z ; deleteInfoArray<CvHandicapInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvHandicapInfo@@@@YAXAAV?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvHandicapInfo@@@@YAXAAV?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvHandicapInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@6
	npad	2
$LL14@deleteInfo@6:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@6
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@6:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@6
$LN1@deleteInfo@6:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@6
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@6
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@6:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@6:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvHandicapInfo@@@@YAXAAV?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvHandicapInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvGameSpeedInfo@@@@YAXAAV?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@@Z ; deleteInfoArray<CvGameSpeedInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvGameSpeedInfo@@@@YAXAAV?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvGameSpeedInfo@@@@YAXAAV?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvGameSpeedInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@7
	npad	2
$LL14@deleteInfo@7:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@7
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@7:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@7
$LN1@deleteInfo@7:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@7
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@7
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@7:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@7:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvGameSpeedInfo@@@@YAXAAV?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvGameSpeedInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvTurnTimerInfo@@@@YAXAAV?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@@Z ; deleteInfoArray<CvTurnTimerInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvTurnTimerInfo@@@@YAXAAV?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvTurnTimerInfo@@@@YAXAAV?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvTurnTimerInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@8
	npad	1
$LL14@deleteInfo@8:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@8
	mov	ecx, edi
	call	??1CvBaseInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@8:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@8
$LN1@deleteInfo@8:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@8
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@8
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@8:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@8:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvTurnTimerInfo@@@@YAXAAV?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvTurnTimerInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvVictoryInfo@@@@YAXAAV?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@@Z ; deleteInfoArray<CvVictoryInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvVictoryInfo@@@@YAXAAV?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvVictoryInfo@@@@YAXAAV?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvVictoryInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@9
	npad	2
$LL14@deleteInfo@9:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@9
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@9:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@9
$LN1@deleteInfo@9:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@9
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@9
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@9:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@9:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvVictoryInfo@@@@YAXAAV?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvVictoryInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvSmallAwardInfo@@@@YAXAAV?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@@Z ; deleteInfoArray<CvSmallAwardInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvSmallAwardInfo@@@@YAXAAV?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvSmallAwardInfo@@@@YAXAAV?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvSmallAwardInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@10
	npad	2
$LL14@deleteInfo@10:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@10
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@10:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@10
$LN1@deleteInfo@10:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@10
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@10
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@10:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@10:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvSmallAwardInfo@@@@YAXAAV?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvSmallAwardInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvHurryInfo@@@@YAXAAV?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@@Z ; deleteInfoArray<CvHurryInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvHurryInfo@@@@YAXAAV?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvHurryInfo@@@@YAXAAV?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvHurryInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@11
	npad	1
$LL14@deleteInfo@11:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@11
	mov	ecx, edi
	call	??1CvBaseInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@11:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@11
$LN1@deleteInfo@11:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@11
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@11
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@11:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@11:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvHurryInfo@@@@YAXAAV?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvHurryInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvProcessInfo@@@@YAXAAV?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@@Z ; deleteInfoArray<CvProcessInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvProcessInfo@@@@YAXAAV?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvProcessInfo@@@@YAXAAV?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvProcessInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@12
	npad	2
$LL14@deleteInfo@12:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@12
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@12:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@12
$LN1@deleteInfo@12:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@12
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@12
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@12:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@12:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvProcessInfo@@@@YAXAAV?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvProcessInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvVoteInfo@@@@YAXAAV?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@@Z ; deleteInfoArray<CvVoteInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvVoteInfo@@@@YAXAAV?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvVoteInfo@@@@YAXAAV?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvVoteInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@13
	npad	2
$LL14@deleteInfo@13:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@13
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@13:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@13
$LN1@deleteInfo@13:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@13
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@13
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@13:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@13:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvVoteInfo@@@@YAXAAV?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvVoteInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvColorInfo@@@@YAXAAV?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@@Z ; deleteInfoArray<CvColorInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvColorInfo@@@@YAXAAV?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvColorInfo@@@@YAXAAV?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvColorInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@14
	npad	1
$LL14@deleteInfo@14:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@14
	mov	ecx, edi
	call	??1CvBaseInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@14:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@14
$LN1@deleteInfo@14:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@14
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@14
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@14:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@14:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvColorInfo@@@@YAXAAV?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvColorInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvPlayerColorInfo@@@@YAXAAV?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@@Z ; deleteInfoArray<CvPlayerColorInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvPlayerColorInfo@@@@YAXAAV?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvPlayerColorInfo@@@@YAXAAV?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvPlayerColorInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@15
	npad	1
$LL14@deleteInfo@15:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@15
	mov	ecx, edi
	call	??1CvBaseInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@15:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@15
$LN1@deleteInfo@15:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@15
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@15
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@15:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@15:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvPlayerColorInfo@@@@YAXAAV?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvPlayerColorInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvInterfaceModeInfo@@@@YAXAAV?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@@Z ; deleteInfoArray<CvInterfaceModeInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvInterfaceModeInfo@@@@YAXAAV?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvInterfaceModeInfo@@@@YAXAAV?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvInterfaceModeInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@16
	npad	1
$LL14@deleteInfo@16:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@16
	mov	ecx, edi
	call	??1CvHotKeyInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@16:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@16
$LN1@deleteInfo@16:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@16
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@16
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@16:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@16:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvInterfaceModeInfo@@@@YAXAAV?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvInterfaceModeInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvRouteInfo@@@@YAXAAV?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@@Z ; deleteInfoArray<CvRouteInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvRouteInfo@@@@YAXAAV?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvRouteInfo@@@@YAXAAV?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvRouteInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@17
	npad	2
$LL14@deleteInfo@17:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@17
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@17:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@17
$LN1@deleteInfo@17:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@17
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@17
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@17:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@17:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvRouteInfo@@@@YAXAAV?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvRouteInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvEraInfo@@@@YAXAAV?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@@Z ; deleteInfoArray<CvEraInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvEraInfo@@@@YAXAAV?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvEraInfo@@@@YAXAAV?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvEraInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@18
	npad	2
$LL14@deleteInfo@18:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@18
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@18:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@18
$LN1@deleteInfo@18:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@18
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@18
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@18:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@18:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvEraInfo@@@@YAXAAV?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvEraInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvBuildInfo@@@@YAXAAV?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@@Z ; deleteInfoArray<CvBuildInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvBuildInfo@@@@YAXAAV?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvBuildInfo@@@@YAXAAV?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvBuildInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@19
	npad	2
$LL14@deleteInfo@19:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@19
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@19:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@19
$LN1@deleteInfo@19:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@19
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@19
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@19:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@19:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvBuildInfo@@@@YAXAAV?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvBuildInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvUnitClassInfo@@@@YAXAAV?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@@Z ; deleteInfoArray<CvUnitClassInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvUnitClassInfo@@@@YAXAAV?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvUnitClassInfo@@@@YAXAAV?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvUnitClassInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@20
	npad	1
$LL14@deleteInfo@20:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@20
	mov	ecx, edi
	call	??1CvBaseInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@20:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@20
$LN1@deleteInfo@20:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@20
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@20
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@20:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@20:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvUnitClassInfo@@@@YAXAAV?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvUnitClassInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvSpecialUnitInfo@@@@YAXAAV?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@@Z ; deleteInfoArray<CvSpecialUnitInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvSpecialUnitInfo@@@@YAXAAV?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvSpecialUnitInfo@@@@YAXAAV?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvSpecialUnitInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@21
	npad	2
$LL14@deleteInfo@21:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@21
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@21:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@21
$LN1@deleteInfo@21:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@21
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@21
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@21:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@21:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvSpecialUnitInfo@@@@YAXAAV?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvSpecialUnitInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvSpecialistInfo@@@@YAXAAV?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@@Z ; deleteInfoArray<CvSpecialistInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvSpecialistInfo@@@@YAXAAV?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvSpecialistInfo@@@@YAXAAV?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvSpecialistInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@22
	npad	2
$LL14@deleteInfo@22:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@22
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@22:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@22
$LN1@deleteInfo@22:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@22
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@22
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@22:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@22:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvSpecialistInfo@@@@YAXAAV?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvSpecialistInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvActionInfo@@@@YAXAAV?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@@Z ; deleteInfoArray<CvActionInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvActionInfo@@@@YAXAAV?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvActionInfo@@@@YAXAAV?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvActionInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@23
	npad	2
$LL14@deleteInfo@23:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	DWORD PTR [esi], 0
	add	esi, 4
	add	esp, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@23
$LN1@deleteInfo@23:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN46@deleteInfo@23
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN71@deleteInfo@23
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN71@deleteInfo@23:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN46@deleteInfo@23:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvActionInfo@@@@YAXAAV?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvActionInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z ; deleteInfoArray<CvMissionInfo>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z$0
__ehfuncinfo$??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T292388 = 8						; size = 4
_array$ = 8						; size = 4
??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvMissionInfo>, COMDAT

; 51   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp+12]
	mov	eax, DWORD PTR [ebx+8]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+4]
	cmp	edi, eax
	je	SHORT $LN1@deleteInfo@24
$LL14@deleteInfo@24:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR $T292388[esp+20], esi
	test	esi, esi
	je	SHORT $LN32@deleteInfo@24
	lea	ecx, DWORD PTR [esi+472]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvHotKeyInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@24:
	mov	DWORD PTR [edi], 0
	add	edi, 4
	cmp	edi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@24
$LN1@deleteInfo@24:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN58@deleteInfo@24
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN83@deleteInfo@24
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN83@deleteInfo@24:
	mov	DWORD PTR [ebx+8], edi
$LN58@deleteInfo@24:

; 58   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z$0:
	mov	ecx, DWORD PTR $T292388[ebp-4]
	jmp	??1CvHotKeyInfo@@QAE@XZ
__ehhandler$??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvMissionInfo>
PUBLIC	??$deleteInfoArray@VCvControlInfo@@@@YAXAAV?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@@Z ; deleteInfoArray<CvControlInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvControlInfo@@@@YAXAAV?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvControlInfo@@@@YAXAAV?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvControlInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@25
	npad	1
$LL14@deleteInfo@25:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@25
	mov	ecx, edi
	call	??1CvHotKeyInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@25:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@25
$LN1@deleteInfo@25:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@25
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@25
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@25:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@25:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvControlInfo@@@@YAXAAV?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvControlInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvCommandInfo@@@@YAXAAV?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@@Z ; deleteInfoArray<CvCommandInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvCommandInfo@@@@YAXAAV?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvCommandInfo@@@@YAXAAV?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvCommandInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@26
	npad	1
$LL14@deleteInfo@26:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@26
	mov	ecx, edi
	call	??1CvHotKeyInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@26:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@26
$LN1@deleteInfo@26:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@26
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@26
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@26:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@26:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvCommandInfo@@@@YAXAAV?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvCommandInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvAutomateInfo@@@@YAXAAV?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@@Z ; deleteInfoArray<CvAutomateInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvAutomateInfo@@@@YAXAAV?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvAutomateInfo@@@@YAXAAV?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvAutomateInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@27
	npad	1
$LL14@deleteInfo@27:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@27
	mov	ecx, edi
	call	??1CvHotKeyInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@27:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@27
$LN1@deleteInfo@27:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@27
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@27
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@27:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@27:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvAutomateInfo@@@@YAXAAV?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvAutomateInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvBaseInfo@@@@YAXAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@@Z ; deleteInfoArray<CvBaseInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvBaseInfo@@@@YAXAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvBaseInfo@@@@YAXAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvBaseInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@28
	npad	1
$LL14@deleteInfo@28:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@28
	mov	ecx, edi
	call	??1CvBaseInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@28:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@28
$LN1@deleteInfo@28:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN51@deleteInfo@28
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN76@deleteInfo@28
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN76@deleteInfo@28:
	mov	DWORD PTR [ebx+8], edi
$LN51@deleteInfo@28:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvBaseInfo@@@@YAXAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvBaseInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvGameOptionInfo@@@@YAXAAV?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@@Z ; deleteInfoArray<CvGameOptionInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvGameOptionInfo@@@@YAXAAV?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvGameOptionInfo@@@@YAXAAV?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvGameOptionInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@29
	npad	1
$LL14@deleteInfo@29:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@29
	mov	ecx, edi
	call	??1CvBaseInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@29:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@29
$LN1@deleteInfo@29:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@29
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@29
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@29:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@29:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvGameOptionInfo@@@@YAXAAV?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvGameOptionInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvMPOptionInfo@@@@YAXAAV?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@@Z ; deleteInfoArray<CvMPOptionInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvMPOptionInfo@@@@YAXAAV?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvMPOptionInfo@@@@YAXAAV?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvMPOptionInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@30
	npad	1
$LL14@deleteInfo@30:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@30
	mov	ecx, edi
	call	??1CvBaseInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@30:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@30
$LN1@deleteInfo@30:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@30
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@30
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@30:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@30:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvMPOptionInfo@@@@YAXAAV?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvMPOptionInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvPlayerOptionInfo@@@@YAXAAV?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@@Z ; deleteInfoArray<CvPlayerOptionInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvPlayerOptionInfo@@@@YAXAAV?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvPlayerOptionInfo@@@@YAXAAV?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvPlayerOptionInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@31
	npad	1
$LL14@deleteInfo@31:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@31
	mov	ecx, edi
	call	??1CvBaseInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@31:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@31
$LN1@deleteInfo@31:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@31
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@31
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@31:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@31:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvPlayerOptionInfo@@@@YAXAAV?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvPlayerOptionInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvYieldInfo@@@@YAXAAV?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@@Z ; deleteInfoArray<CvYieldInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvYieldInfo@@@@YAXAAV?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvYieldInfo@@@@YAXAAV?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvYieldInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@32
	npad	1
$LL14@deleteInfo@32:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@32
	mov	ecx, edi
	call	??1CvBaseInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@32:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@32
$LN1@deleteInfo@32:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@32
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@32
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@32:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@32:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvYieldInfo@@@@YAXAAV?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvYieldInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvTerrainInfo@@@@YAXAAV?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@@Z ; deleteInfoArray<CvTerrainInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvTerrainInfo@@@@YAXAAV?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvTerrainInfo@@@@YAXAAV?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvTerrainInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@33
	npad	2
$LL14@deleteInfo@33:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@33
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@33:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@33
$LN1@deleteInfo@33:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@33
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@33
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@33:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@33:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvTerrainInfo@@@@YAXAAV?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvTerrainInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvFeatureInfo@@@@YAXAAV?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@@Z ; deleteInfoArray<CvFeatureInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvFeatureInfo@@@@YAXAAV?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvFeatureInfo@@@@YAXAAV?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvFeatureInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@34
	npad	2
$LL14@deleteInfo@34:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@34
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@34:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@34
$LN1@deleteInfo@34:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@34
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@34
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@34:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@34:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvFeatureInfo@@@@YAXAAV?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvFeatureInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvResourceClassInfo@@@@YAXAAV?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@@Z ; deleteInfoArray<CvResourceClassInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvResourceClassInfo@@@@YAXAAV?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvResourceClassInfo@@@@YAXAAV?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvResourceClassInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@35
	npad	1
$LL14@deleteInfo@35:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@deleteInfo@35
	mov	ecx, edi
	call	??1CvBaseInfo@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@35:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@35
$LN1@deleteInfo@35:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN54@deleteInfo@35
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN79@deleteInfo@35
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN79@deleteInfo@35:
	mov	DWORD PTR [ebx+8], edi
$LN54@deleteInfo@35:
	pop	edi
	pop	esi
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvResourceClassInfo@@@@YAXAAV?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvResourceClassInfo>
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvResourceInfo@@@@YAXAAV?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@@Z ; deleteInfoArray<CvResourceInfo>
; Function compile flags: /Ogtpy
;	COMDAT ??$deleteInfoArray@VCvResourceInfo@@@@YAXAAV?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvResourceInfo@@@@YAXAAV?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvResourceInfo>, COMDAT

; 51   : {

	push	esi
	push	edi

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	edi, DWORD PTR _array$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@deleteInfo@36
	npad	2
$LL14@deleteInfo@36:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@deleteInfo@36
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@deleteInfo@36:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@deleteInfo@36
$LN1@deleteInfo@36:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@deleteInfo@36
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@deleteInfo@36
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@deleteInfo@36:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@deleteInfo@36:
	pop	edi
	pop	esi

; 58   : }

	ret	0
??$deleteInfoArray@VCvResourceInfo@@@@YAXAAV?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvResourceInfo>
_TEXT	ENDS
PUBLIC	??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
xdata$x	SEGMENT
__catchsym$??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z$0
__unwindtable$??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z$2
__ehfuncinfo$??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
$T296195 = -24						; size = 4
_this$ = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0> >, COMDAT
; _this$ = ecx

; 762  : 		void _Insert(const_iterator _Where,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH

; 763  : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 764  : 		{	// insert [_First, _Last) at _Where, forward iterators
; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		_DEBUG_RANGE(_First, _Last);
; 768  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 769  : 
; 770  : 		_Iter _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ebx
	mov	DWORD PTR __Next$[ebp], eax

; 771  : 
; 772  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 773  : 		for (; _First != _Last; ++_First)

$LL14@Insert@2:
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Insert@2

; 774  : 			_Insert(_Where, *_First);

	mov	ecx, DWORD PTR __Where$[ebp]
	add	eax, 8
	lea	edi, DWORD PTR [ecx+4]
	push	eax
	mov	eax, DWORD PTR [edi]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode
	push	1
	mov	ecx, ebx
	mov	esi, eax
	call	?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Incsize
	mov	DWORD PTR [edi], esi
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __First$[ebp], eax
	jmp	SHORT $LL14@Insert@2
__catch$??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z$0:

; 775  : 		_CATCH_ALL
; 776  : 		for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	cmp	esi, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Insert@2
	mov	edi, DWORD PTR _this$[ebp]
$LL38@Insert@2:

; 777  : 			{	// undo inserts
; 778  : 			const_iterator _Before = _Where;
; 779  : 			erase(--_Before);

	mov	eax, DWORD PTR __Where$[ebp]
	mov	eax, DWORD PTR [eax+4]
	push	eax
	lea	ecx, DWORD PTR $T296195[ebp]
	push	ecx
	mov	ecx, edi
	call	?erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::erase
	mov	esi, DWORD PTR [esi]
	cmp	esi, DWORD PTR __First$[ebp]
	jne	SHORT $LL38@Insert@2
$LN1@Insert@2:

; 780  : 			}
; 781  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN56@Insert@2:
$LN4@Insert@2:

; 782  : 		_CATCH_END
; 783  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN55@Insert@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0> >
PUBLIC	??$_Unchecked_uninitialized_move@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@Z ; stdext::_Unchecked_uninitialized_move<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@Z
_TEXT	SEGMENT
$T296323 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$296327 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$296327[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T296323[esp+4], 0
	mov	eax, DWORD PTR $T296323[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXPAW4AnimationPathTypes@@0@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXPAW4AnimationPathTypes@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXPAW4AnimationPathTypes@@0@Z PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXPAW4AnimationPathTypes@@0@Z ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Destroy
_TEXT	ENDS
PUBLIC	?find@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::find
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?find@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::find, COMDAT
; _this$ = ecx

; 625  : 		return (lower_bound(_Keyval));

	mov	eax, DWORD PTR __Keyval$[esp-4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	push	eax
	push	esi
	call	?lower_bound@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::lower_bound
	mov	eax, esi
	pop	esi

; 626  : 		}

	ret	8
?find@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::find
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T296410 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T296410[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx

; 520  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 521  : 		_Tidy();

	call	?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::clear
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 522  : 		}

	ret	0
??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z
_TEXT	SEGMENT
$T296632 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;
; 672  : 
; 673  : 		if (size() == 0)

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN32@insert@2

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[esp+12]
	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	push	eax
	push	ecx
	push	1
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN32@insert@2:

; 675  : 		else if (this->_Multi)
; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())
; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,
; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 682  : 				}
; 683  : 			else if (_Where == end())
; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,
; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));
; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,
; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))
; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 696  : 				else
; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,
; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))
; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 707  : 				else
; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 709  : 				}
; 710  : 			}
; 711  : 		else
; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	esi, DWORD PTR __Val$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR __Where$[esp+16]
	push	ebp
	cmp	ebx, DWORD PTR [eax]
	jne	SHORT $LN14@insert@2
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [ebx+12]
	jae	$LN1@insert@2

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN14@insert@2:

; 718  : 				}
; 719  : 			else if (_Where == end())

	cmp	ebx, eax
	jne	SHORT $LN11@insert@2

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [esi]
	jae	$LN1@insert@2

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	eax
	push	0
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN11@insert@2:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,
; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ebp, DWORD PTR [esi]
	cmp	DWORD PTR [ebx+12], ebp
	jbe	SHORT $LN305@insert@2
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	DWORD PTR [eax+12], ebp
	jae	SHORT $LN8@insert@2

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN7@insert@2
	push	eax
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN7@insert@2:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN8@insert@2:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,
; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	cmp	DWORD PTR [ebx+12], ebp
$LN305@insert@2:
	jae	SHORT $LN1@insert@2
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN3@insert@2
	cmp	ebp, DWORD PTR [eax+12]
	jae	SHORT $LN1@insert@2
$LN3@insert@2:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [ecx+21], 0

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN2@insert@2
	push	ebx
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN2@insert@2:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	push	eax
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN1@insert@2:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	esi
	lea	edx, DWORD PTR $T296632[esp+28]
	push	edx
	mov	ecx, edi
	call	?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXXZ ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXXZ PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@39

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@39:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXXZ ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Tidy
_TEXT	ENDS
PUBLIC	?insert@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?insert@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::insert, COMDAT
; _this$ = ecx

; 704  : 		_Insert(_Where, _Val);

	mov	eax, DWORD PTR __Where$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR __Val$[esp+8]
	lea	ebx, DWORD PTR [eax+4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, edi
	call	?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode
	push	1
	mov	ecx, edi
	mov	esi, eax
	call	?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Incsize
	mov	DWORD PTR [ebx], esi
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], esi

; 705  : 		return (_Make_iter(--_Where));

	mov	ecx, DWORD PTR __Where$[esp+8]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx

; 706  : 		}

	ret	12					; 0000000cH
?insert@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::insert
_TEXT	ENDS
PUBLIC	??$insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::insert<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0> >
; Function compile flags: /Ogtpy
;	COMDAT ??$insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
$T297222 = 16						; size = 1
__Last$ = 16						; size = 4
??$insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::insert<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0> >, COMDAT
; _this$ = ecx

; 731  : 		{	// insert [_First, _Last) at _Where
; 732  : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));

	mov	eax, DWORD PTR $T297222[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	push	eax
	mov	eax, DWORD PTR __First$[esp]
	push	edx
	mov	edx, DWORD PTR __Where$[esp+4]
	push	eax
	push	edx
	call	??$_Insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00Uforward_iterator_tag@1@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0> >

; 733  : 		}

	ret	12					; 0000000cH
??$insert@V?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@01@00@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::insert<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@PAV231@00@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Umove<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@PAV231@00@Z
_TEXT	SEGMENT
$T297274 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$297278 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@PAV231@00@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Umove<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$297278[esp]
	mov	BYTE PTR $T297274[esp+4], 0
	mov	eax, DWORD PTR $T297274[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@PAV231@00@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Umove<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXXZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@40

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@40:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T297397 = -4						; size = 4
??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T297397[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
_TEXT	ENDS
PUBLIC	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z	; CvGlobals::getInfoTypeForString
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z$1
__ehfuncinfo$?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z
_TEXT	SEGMENT
$T297427 = -68						; size = 28
_strError$232792 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_it$ = 8						; size = 4
_szType$ = 8						; size = 4
_hideAssert$ = 12					; size = 1
?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z PROC	; CvGlobals::getInfoTypeForString, COMDAT
; _this$ = ecx

; 6941 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi

; 6942 : 	if(!hideAssert)
; 6943 : 	{
; 6944 : 		CvAssertMsg(szType, "null info type string");
; 6945 : 	}
; 6946 : 
; 6947 : 	if(szType == NULL)

	mov	edi, DWORD PTR _szType$[esp+72]
	mov	esi, ecx
	test	edi, edi

; 6948 : 		return -1;

	je	$LN1@getInfoTyp@2

; 6949 : 
; 6950 : 
; 6951 : 	InfosMap::const_iterator it = m_infosMap.find(szType);

	push	edi
	lea	ecx, DWORD PTR $T297427[esp+80]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T297427[esp+76]
	push	eax
	lea	ecx, DWORD PTR _it$[esp+76]
	push	ecx
	lea	ecx, DWORD PTR [esi+980]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	?lower_bound@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::lower_bound
	lea	ecx, DWORD PTR $T297427[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6952 : 	if(it!=m_infosMap.end())

	mov	esi, DWORD PTR [esi+988]
	mov	eax, DWORD PTR _it$[esp+72]
	cmp	eax, esi
	je	SHORT $LN2@getInfoTyp@2

; 6953 : 	{
; 6954 : 		return it->second;

	mov	eax, DWORD PTR [eax+36]
	pop	edi
	pop	esi

; 6967 : 
; 6968 : 	return -1;
; 6969 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
$LN2@getInfoTyp@2:

; 6955 : 	}
; 6956 : 
; 6957 : 	if(!hideAssert)

	cmp	BYTE PTR _hideAssert$[esp+72], 0
	jne	SHORT $LN1@getInfoTyp@2

; 6958 : 	{
; 6959 : 		//
; 6960 : 		// *** EFB: Need to restore this logging??? ***
; 6961 : 		//
; 6962 : 		CvString strError;

	lea	ecx, DWORD PTR _strError$232792[esp+76]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6963 : 		strError.Format("Info type %s not found.", szType);

	push	edi
	lea	edx, DWORD PTR _strError$232792[esp+80]
	push	OFFSET $SG232793
	push	edx
	mov	DWORD PTR __$EHRec$[esp+96], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 6964 : 		CvAssertMsg(strcmp(szType, "NONE")==0 || strcmp(szType, "")==0, strError.c_str());
; 6965 : //		gDLL->logMsg("xml.log", szError);
; 6966 : 	}

	lea	ecx, DWORD PTR _strError$232792[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@getInfoTyp@2:

; 6967 : 
; 6968 : 	return -1;
; 6969 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	pop	edi
	or	eax, -1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z$0:
	lea	ecx, DWORD PTR $T297427[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z$1:
	lea	ecx, DWORD PTR _strError$232792[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ENDP	; CvGlobals::getInfoTypeForString
PUBLIC	??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 104  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
_TEXT	ENDS
PUBLIC	??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z
_TEXT	SEGMENT
$T297711 = -8						; size = 8
$T297714 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[], COMDAT
; _this$ = ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	sub	esp, 8
	cmp	BYTE PTR [eax+21], 0
	push	esi
	mov	esi, DWORD PTR __Keyval$[esp+8]
	jne	SHORT $LN9@operator@4
	push	edi
	mov	edi, DWORD PTR [esi]
$LL10@operator@4:
	cmp	DWORD PTR [eax+12], edi
	jae	SHORT $LN8@operator@4
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@operator@4
$LN8@operator@4:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@operator@4:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@operator@4
	pop	edi
$LN9@operator@4:

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN1@operator@4
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [edx+12]
	jae	SHORT $LN62@operator@4
$LN1@operator@4:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T297711[esp+12], eax
	lea	eax, DWORD PTR $T297711[esp+12]
	push	eax
	push	edx
	lea	edx, DWORD PTR $T297714[esp+16]
	push	edx
	mov	DWORD PTR $T297711[esp+28], 0
	call	?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
	mov	eax, DWORD PTR [eax]

; 174  : 		return ((*_Where).second);

	add	eax, 16					; 00000010H
	pop	esi

; 175  : 		}

	add	esp, 8
	ret	4
$LN62@operator@4:

; 174  : 		return ((*_Where).second);

	lea	eax, DWORD PTR [edx+16]
	pop	esi

; 175  : 		}

	add	esp, 8
	ret	4
??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[]
_TEXT	ENDS
PUBLIC	??1?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@XZ ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::~vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@XZ PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::~vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@40
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@40:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@XZ ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::~vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
_TEXT	ENDS
PUBLIC	?_Splice@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@AAV12@00I_N@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Splice
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Splice@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@AAV12@00I_N@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Right$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Count$ = 24						; size = 4
__Keep$ = 28						; size = 1
?_Splice@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@AAV12@00I_N@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Splice, COMDAT
; _this$ = ecx

; 1126 : 		{	// splice _Right [_First, _Last) before _Where

	push	esi

; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 		if (_Where._Mycont != this)
; 1129 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1130 : 		if (this->_Alval == _Right._Alval)
; 1131 : 			{	// same allocator, just relink
; 1132 : 			if (!_Keep && this != &_Right)
; 1133 : 				for (const_iterator _Next = _First; _Next != _Last; )
; 1134 : 					_Orphan_ptr(_Right, (_Next++)._Ptr);
; 1135 : 
; 1136 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1137 :         _Keep;                  // unused in this branch
; 1138 : 		if (this->_Alval == _Right._Alval)
; 1139 : 			{	// same allocator, just relink
; 1140 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1141 : 
; 1142 : 			if (this != &_Right)

	mov	esi, DWORD PTR __Right$[esp]
	cmp	ecx, esi
	je	SHORT $LN2@Splice
	push	edi

; 1143 : 				{	// splicing from another list, adjust counts
; 1144 : 				_Incsize(_Count);

	mov	edi, DWORD PTR __Count$[esp+4]
	push	edi
	call	?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Incsize

; 1145 : 				_Right._Mysize -= _Count;

	sub	DWORD PTR [esi+8], edi
	pop	edi
$LN2@Splice:

; 1146 : 				}
; 1147 : 			_Nextnode(_Prevnode(_First._Mynode())) = _Last._Mynode();

	mov	eax, DWORD PTR __First$[esp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Last$[esp]
	mov	DWORD PTR [ecx], edx

; 1148 : 			_Nextnode(_Prevnode(_Last._Mynode())) = _Where._Mynode();

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Where$[esp]
	mov	DWORD PTR [ecx], edx

; 1149 : 			_Nextnode(_Prevnode(_Where._Mynode())) = _First._Mynode();

	mov	eax, DWORD PTR __Where$[esp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __First$[esp]
	mov	DWORD PTR [ecx], edx

; 1150 : 			_Nodeptr _Pnode = _Prevnode(_Where._Mynode());

	mov	eax, DWORD PTR __Where$[esp]

; 1151 : 			_Prevnode(_Where._Mynode()) = _Prevnode(_Last._Mynode());

	mov	edx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+4], edx

; 1152 : 			_Prevnode(_Last._Mynode()) = _Prevnode(_First._Mynode());

	mov	eax, DWORD PTR __First$[esp]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[esp]
	mov	DWORD PTR [eax+4], edx

; 1153 : 			_Prevnode(_First._Mynode()) = _Pnode;

	mov	edx, DWORD PTR __First$[esp]
	mov	DWORD PTR [edx+4], ecx
	pop	esi

; 1154 : 			}
; 1155 : 		else
; 1156 : 			{	// different allocator, copy nodes then erase source
; 1157 : 			insert(_Where, _First, _Last);
; 1158 : 			_Right.erase(_First, _Last);
; 1159 : 			}
; 1160 :         }

	ret	24					; 00000018H
?_Splice@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@AAV12@00I_N@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Splice
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z$2
__catchsym$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z$0
__unwindtable$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
_TEXT	SEGMENT
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$298193 = 8					; size = 1
__Cat$298120 = 8					; size = 1
__Where$ = 8						; size = 4
__Tmp$237038 = 12					; size = 4
__Tmp$237028 = 12					; size = 4
__Newvec$237013 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T298188 = 16						; size = 1
$T298116 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@KAXXZ ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Xlen
$LN87@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@IPAV120@@Z ; std::_Allocate<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	ebx, 2
	push	edi
	lea	edx, DWORD PTR [eax+ebx*4]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$237013[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAV342@IABV342@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$298120[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T298116[ebp], 0
	mov	ecx, DWORD PTR $T298116[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$237013[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T298188[ebp], 0
	mov	edx, DWORD PTR $T298188[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$298193[ebp]
	push	edx
	lea	ecx, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$237013[ebp]
	push	esi
	lea	ecx, DWORD PTR [ebx+ecx*4]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@PAV120@00AAV?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ebx+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$237013[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n:
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, ebx
	sub	ecx, eax
	sar	ecx, 2
	cmp	ecx, edi
	jae	SHORT $LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$237028[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@PAV231@00@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Umove<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$237028[ebp]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAV342@IABV342@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$237028[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0ABV120@@Z ; std::fill<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __Tmp$237038[ebp], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@1@PAV231@00@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Umove<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@@stdext@@YAPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@PAV123@00@Z ; stdext::_Unchecked_move_backward<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$237038[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V123@@std@@YAXPAV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@0@0ABV120@@Z ; std::fill<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> *,std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> >
	add	esp, 24					; 00000018H
$LN1@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Insert_n
PUBLIC	??1?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::~vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::~vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@41
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@41:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::~vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??1?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@XZ ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::~_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ??1?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@XZ
_TEXT	SEGMENT
??1?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@XZ PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::~_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >, COMDAT
; _this$ = ecx

; 365  : 		{	// destroy hash table

	push	esi
	mov	esi, ecx

; 366  : 		}

	mov	eax, DWORD PTR [esi+20]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN10@Hash@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@Hash@2:
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+28], edi
	add	esi, 4
	mov	ecx, esi
	call	?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::clear
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi
	ret	0
??1?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@XZ ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::~_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?splice@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@AAV12@0@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::splice
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?splice@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@AAV12@0@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Right$ = 12						; size = 4
__First$ = 16						; size = 4
?splice@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@AAV12@0@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::splice, COMDAT
; _this$ = ecx

; 884  : 
; 885  :  #if _HAS_ITERATOR_DEBUGGING
; 886  : 		if (_First == _Right.end())
; 887  : 			_DEBUG_ERROR("list splice iterator outside range");
; 888  : 		else
; 889  : 
; 890  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 891  : 		if (_First != _Right.end())

	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Right$[esp]
	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN2@splice

; 892  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 893  : 
; 894  : 			{	// element exists, try splice
; 895  : 			const_iterator _Last = _First;
; 896  : 			++_Last;

	mov	edx, DWORD PTR [eax]
	push	edi

; 897  : 			if (this != &_Right
; 898  : 				|| (_Where != _First && _Where != _Last))

	mov	edi, DWORD PTR __Where$[esp+4]
	cmp	ecx, esi
	jne	SHORT $LN1@splice
	cmp	edi, eax
	je	SHORT $LN28@splice
	cmp	edi, edx
	je	SHORT $LN28@splice
$LN1@splice:

; 899  : 				_Splice(_Where, _Right, _First, _Last, 1);

	push	0
	push	1
	push	edx
	push	eax
	push	esi
	push	edi
	call	?_Splice@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@AAV12@00I_N@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Splice
$LN28@splice:
	pop	edi
$LN2@splice:
	pop	esi

; 900  : 			}
; 901  : 		}

	ret	12					; 0000000cH
?splice@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@AAV12@0@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::splice
_TEXT	ENDS
PUBLIC	?insert@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::insert, COMDAT
; _this$ = ecx

; 883  : 		_Insert_n(_Where, _Count, _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR __Count$[esp-4]
	push	eax
	mov	eax, DWORD PTR __Where$[esp]
	push	edx
	push	eax
	call	?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Insert_n

; 884  : 		}

	ret	12					; 0000000cH
?insert@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::insert
_TEXT	ENDS
PUBLIC	??1CvEntityEventInfo@@QAE@XZ			; CvEntityEventInfo::~CvEntityEventInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvEntityEventInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvEntityEventInfo@@QAE@XZ PROC			; CvEntityEventInfo::~CvEntityEventInfo, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+264]
	test	eax, eax
	je	SHORT $LN10@CvEntityEv
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@CvEntityEv:
	mov	DWORD PTR [esi+264], 0
	mov	DWORD PTR [esi+268], 0
	mov	DWORD PTR [esi+272], 0
	mov	ecx, esi
	pop	esi
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvEntityEventInfo@@QAE@XZ ENDP			; CvEntityEventInfo::~CvEntityEventInfo
_TEXT	ENDS
PUBLIC	??1?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAE@XZ ; stdext::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAE@XZ
_TEXT	SEGMENT
??1?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAE@XZ PROC ; stdext::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+20]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN13@hash_map
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@hash_map:
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+28], edi
	add	esi, 4
	mov	ecx, esi
	call	?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::clear
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi
	ret	0
??1?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAE@XZ ENDP ; stdext::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
PUBLIC	??_7CvGlobals@@6B@				; CvGlobals::`vftable'
PUBLIC	??1CvGlobals@@UAE@XZ				; CvGlobals::~CvGlobals
PUBLIC	??_R4CvGlobals@@6B@				; CvGlobals::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvGlobals@@@8				; CvGlobals `RTTI Type Descriptor'
PUBLIC	??_R3CvGlobals@@8				; CvGlobals::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvGlobals@@8				; CvGlobals::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvGlobals@@8			; CvGlobals::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??1Results@Database@@UAE@XZ:PROC
EXTRN	??_ECvGlobals@@UAEPAXI@Z:PROC			; CvGlobals::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvGlobals@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
rdata$r	SEGMENT
??_R1A@?0A@EA@CvGlobals@@8 DD FLAT:??_R0?AVCvGlobals@@@8 ; CvGlobals::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvGlobals@@8
rdata$r	ENDS
;	COMDAT ??_R2CvGlobals@@8
rdata$r	SEGMENT
??_R2CvGlobals@@8 DD FLAT:??_R1A@?0A@EA@CvGlobals@@8	; CvGlobals::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvGlobals@@8
rdata$r	SEGMENT
??_R3CvGlobals@@8 DD 00H				; CvGlobals::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvGlobals@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvGlobals@@@8
_DATA	SEGMENT
??_R0?AVCvGlobals@@@8 DD FLAT:??_7type_info@@6B@	; CvGlobals `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvGlobals@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvGlobals@@6B@
rdata$r	SEGMENT
??_R4CvGlobals@@6B@ DD 00H				; CvGlobals::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvGlobals@@@8
	DD	FLAT:??_R3CvGlobals@@8
rdata$r	ENDS
;	COMDAT ??_7CvGlobals@@6B@
CONST	SEGMENT
??_7CvGlobals@@6B@ DD FLAT:??_R4CvGlobals@@6B@		; CvGlobals::`vftable'
	DD	FLAT:??_ECvGlobals@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvGlobals@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvGlobals@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvGlobals@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvGlobals@@UAE@XZ$2
__ehfuncinfo$??1CvGlobals@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CvGlobals@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ??1CvGlobals@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T299419 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvGlobals@@UAE@XZ PROC				; CvGlobals::~CvGlobals, COMDAT
; _this$ = ecx

; 1940 : {

	push	-1
	push	__ehhandler$??1CvGlobals@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvGlobals@@6B@

; 1941 : }

	mov	eax, DWORD PTR [esi+1656]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+36], 2
	cmp	eax, ebx
	je	SHORT $LN51@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN51@CvGlobals:
	mov	DWORD PTR [esi+1656], ebx
	mov	DWORD PTR [esi+1660], ebx
	mov	DWORD PTR [esi+1664], ebx
	mov	eax, DWORD PTR [esi+1640]
	cmp	eax, ebx
	je	SHORT $LN58@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN58@CvGlobals:
	mov	DWORD PTR [esi+1640], ebx
	mov	DWORD PTR [esi+1644], ebx
	mov	DWORD PTR [esi+1648], ebx
	mov	eax, DWORD PTR [esi+1624]
	cmp	eax, ebx
	je	SHORT $LN65@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN65@CvGlobals:
	mov	DWORD PTR [esi+1624], ebx
	mov	DWORD PTR [esi+1628], ebx
	mov	DWORD PTR [esi+1632], ebx
	mov	eax, DWORD PTR [esi+1608]
	cmp	eax, ebx
	je	SHORT $LN72@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN72@CvGlobals:
	mov	DWORD PTR [esi+1608], ebx
	mov	DWORD PTR [esi+1612], ebx
	mov	DWORD PTR [esi+1616], ebx
	mov	eax, DWORD PTR [esi+1592]
	cmp	eax, ebx
	je	SHORT $LN79@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN79@CvGlobals:
	mov	DWORD PTR [esi+1592], ebx
	mov	DWORD PTR [esi+1596], ebx
	mov	DWORD PTR [esi+1600], ebx
	mov	eax, DWORD PTR [esi+1576]
	cmp	eax, ebx
	je	SHORT $LN86@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN86@CvGlobals:
	mov	DWORD PTR [esi+1576], ebx
	mov	DWORD PTR [esi+1580], ebx
	mov	DWORD PTR [esi+1584], ebx
	mov	eax, DWORD PTR [esi+1560]
	cmp	eax, ebx
	je	SHORT $LN93@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN93@CvGlobals:
	mov	DWORD PTR [esi+1560], ebx
	mov	DWORD PTR [esi+1564], ebx
	mov	DWORD PTR [esi+1568], ebx
	mov	eax, DWORD PTR [esi+1544]
	cmp	eax, ebx
	je	SHORT $LN100@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN100@CvGlobals:
	mov	DWORD PTR [esi+1544], ebx
	mov	DWORD PTR [esi+1548], ebx
	mov	DWORD PTR [esi+1552], ebx
	mov	eax, DWORD PTR [esi+1528]
	cmp	eax, ebx
	je	SHORT $LN107@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN107@CvGlobals:
	mov	DWORD PTR [esi+1528], ebx
	mov	DWORD PTR [esi+1532], ebx
	mov	DWORD PTR [esi+1536], ebx
	mov	eax, DWORD PTR [esi+1512]
	cmp	eax, ebx
	je	SHORT $LN114@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN114@CvGlobals:
	mov	DWORD PTR [esi+1512], ebx
	mov	DWORD PTR [esi+1516], ebx
	mov	DWORD PTR [esi+1520], ebx
	mov	eax, DWORD PTR [esi+1496]
	cmp	eax, ebx
	je	SHORT $LN121@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN121@CvGlobals:
	mov	DWORD PTR [esi+1496], ebx
	mov	DWORD PTR [esi+1500], ebx
	mov	DWORD PTR [esi+1504], ebx
	mov	eax, DWORD PTR [esi+1480]
	cmp	eax, ebx
	je	SHORT $LN128@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN128@CvGlobals:
	mov	DWORD PTR [esi+1480], ebx
	mov	DWORD PTR [esi+1484], ebx
	mov	DWORD PTR [esi+1488], ebx
	mov	eax, DWORD PTR [esi+1464]
	cmp	eax, ebx
	je	SHORT $LN135@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN135@CvGlobals:
	mov	DWORD PTR [esi+1464], ebx
	mov	DWORD PTR [esi+1468], ebx
	mov	DWORD PTR [esi+1472], ebx
	mov	eax, DWORD PTR [esi+1448]
	cmp	eax, ebx
	je	SHORT $LN142@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN142@CvGlobals:
	mov	DWORD PTR [esi+1448], ebx
	mov	DWORD PTR [esi+1452], ebx
	mov	DWORD PTR [esi+1456], ebx
	mov	eax, DWORD PTR [esi+1432]
	cmp	eax, ebx
	je	SHORT $LN149@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN149@CvGlobals:
	mov	DWORD PTR [esi+1432], ebx
	mov	DWORD PTR [esi+1436], ebx
	mov	DWORD PTR [esi+1440], ebx
	mov	eax, DWORD PTR [esi+1416]
	cmp	eax, ebx
	je	SHORT $LN156@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN156@CvGlobals:
	mov	DWORD PTR [esi+1416], ebx
	mov	DWORD PTR [esi+1420], ebx
	mov	DWORD PTR [esi+1424], ebx
	mov	eax, DWORD PTR [esi+1400]
	cmp	eax, ebx
	je	SHORT $LN163@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN163@CvGlobals:
	mov	DWORD PTR [esi+1400], ebx
	mov	DWORD PTR [esi+1404], ebx
	mov	DWORD PTR [esi+1408], ebx
	mov	eax, DWORD PTR [esi+1384]
	cmp	eax, ebx
	je	SHORT $LN170@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN170@CvGlobals:
	mov	DWORD PTR [esi+1384], ebx
	mov	DWORD PTR [esi+1388], ebx
	mov	DWORD PTR [esi+1392], ebx
	mov	eax, DWORD PTR [esi+1368]
	cmp	eax, ebx
	je	SHORT $LN177@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN177@CvGlobals:
	mov	DWORD PTR [esi+1368], ebx
	mov	DWORD PTR [esi+1372], ebx
	mov	DWORD PTR [esi+1376], ebx
	mov	eax, DWORD PTR [esi+1352]
	cmp	eax, ebx
	je	SHORT $LN184@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN184@CvGlobals:
	mov	DWORD PTR [esi+1352], ebx
	mov	DWORD PTR [esi+1356], ebx
	mov	DWORD PTR [esi+1360], ebx
	mov	eax, DWORD PTR [esi+1336]
	cmp	eax, ebx
	je	SHORT $LN191@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN191@CvGlobals:
	mov	DWORD PTR [esi+1336], ebx
	mov	DWORD PTR [esi+1340], ebx
	mov	DWORD PTR [esi+1344], ebx
	mov	eax, DWORD PTR [esi+1320]
	cmp	eax, ebx
	je	SHORT $LN198@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN198@CvGlobals:
	mov	DWORD PTR [esi+1320], ebx
	mov	DWORD PTR [esi+1324], ebx
	mov	DWORD PTR [esi+1328], ebx
	mov	eax, DWORD PTR [esi+1304]
	cmp	eax, ebx
	je	SHORT $LN205@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN205@CvGlobals:
	mov	DWORD PTR [esi+1304], ebx
	mov	DWORD PTR [esi+1308], ebx
	mov	DWORD PTR [esi+1312], ebx
	mov	eax, DWORD PTR [esi+1288]
	cmp	eax, ebx
	je	SHORT $LN212@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN212@CvGlobals:
	mov	DWORD PTR [esi+1288], ebx
	mov	DWORD PTR [esi+1292], ebx
	mov	DWORD PTR [esi+1296], ebx
	mov	eax, DWORD PTR [esi+1272]
	cmp	eax, ebx
	je	SHORT $LN219@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN219@CvGlobals:
	mov	DWORD PTR [esi+1272], ebx
	mov	DWORD PTR [esi+1276], ebx
	mov	DWORD PTR [esi+1280], ebx
	mov	eax, DWORD PTR [esi+1256]
	cmp	eax, ebx
	je	SHORT $LN226@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN226@CvGlobals:
	mov	DWORD PTR [esi+1256], ebx
	mov	DWORD PTR [esi+1260], ebx
	mov	DWORD PTR [esi+1264], ebx
	mov	eax, DWORD PTR [esi+1232]
	cmp	eax, ebx
	je	SHORT $LN233@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN233@CvGlobals:
	mov	DWORD PTR [esi+1232], ebx
	mov	DWORD PTR [esi+1236], ebx
	mov	DWORD PTR [esi+1240], ebx
	mov	eax, DWORD PTR [esi+1216]
	cmp	eax, ebx
	je	SHORT $LN240@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN240@CvGlobals:
	mov	DWORD PTR [esi+1216], ebx
	mov	DWORD PTR [esi+1220], ebx
	mov	DWORD PTR [esi+1224], ebx
	mov	eax, DWORD PTR [esi+1200]
	cmp	eax, ebx
	je	SHORT $LN247@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN247@CvGlobals:
	mov	DWORD PTR [esi+1200], ebx
	mov	DWORD PTR [esi+1204], ebx
	mov	DWORD PTR [esi+1208], ebx
	mov	eax, DWORD PTR [esi+1184]
	cmp	eax, ebx
	je	SHORT $LN254@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN254@CvGlobals:
	mov	DWORD PTR [esi+1184], ebx
	mov	DWORD PTR [esi+1188], ebx
	mov	DWORD PTR [esi+1192], ebx
	mov	eax, DWORD PTR [esi+1168]
	cmp	eax, ebx
	je	SHORT $LN261@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN261@CvGlobals:
	mov	DWORD PTR [esi+1168], ebx
	mov	DWORD PTR [esi+1172], ebx
	mov	DWORD PTR [esi+1176], ebx
	mov	eax, DWORD PTR [esi+1152]
	cmp	eax, ebx
	je	SHORT $LN268@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN268@CvGlobals:
	mov	DWORD PTR [esi+1152], ebx
	mov	DWORD PTR [esi+1156], ebx
	mov	DWORD PTR [esi+1160], ebx
	mov	eax, DWORD PTR [esi+1136]
	cmp	eax, ebx
	je	SHORT $LN275@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN275@CvGlobals:
	mov	DWORD PTR [esi+1136], ebx
	mov	DWORD PTR [esi+1140], ebx
	mov	DWORD PTR [esi+1144], ebx
	mov	eax, DWORD PTR [esi+1120]
	cmp	eax, ebx
	je	SHORT $LN282@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN282@CvGlobals:
	mov	DWORD PTR [esi+1120], ebx
	mov	DWORD PTR [esi+1124], ebx
	mov	DWORD PTR [esi+1128], ebx
	mov	eax, DWORD PTR [esi+1104]
	cmp	eax, ebx
	je	SHORT $LN289@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN289@CvGlobals:
	mov	DWORD PTR [esi+1104], ebx
	mov	DWORD PTR [esi+1108], ebx
	mov	DWORD PTR [esi+1112], ebx
	mov	eax, DWORD PTR [esi+1088]
	cmp	eax, ebx
	je	SHORT $LN296@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN296@CvGlobals:
	mov	DWORD PTR [esi+1088], ebx
	mov	DWORD PTR [esi+1092], ebx
	mov	DWORD PTR [esi+1096], ebx
	mov	eax, DWORD PTR [esi+1072]
	cmp	eax, ebx
	je	SHORT $LN303@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN303@CvGlobals:
	mov	DWORD PTR [esi+1072], ebx
	mov	DWORD PTR [esi+1076], ebx
	mov	DWORD PTR [esi+1080], ebx
	mov	eax, DWORD PTR [esi+1056]
	cmp	eax, ebx
	je	SHORT $LN310@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN310@CvGlobals:
	mov	DWORD PTR [esi+1056], ebx
	mov	DWORD PTR [esi+1060], ebx
	mov	DWORD PTR [esi+1064], ebx
	mov	eax, DWORD PTR [esi+1040]
	cmp	eax, ebx
	je	SHORT $LN317@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN317@CvGlobals:
	push	edi
	mov	DWORD PTR [esi+1040], ebx
	mov	DWORD PTR [esi+1044], ebx
	mov	DWORD PTR [esi+1048], ebx
	mov	eax, DWORD PTR [esi+1028]
	mov	ecx, DWORD PTR [eax]
	lea	edi, DWORD PTR [esi+1024]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T299419[esp+40]
	push	eax
	mov	ecx, edi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi+8], ebx
	mov	eax, DWORD PTR [esi+1000]
	add	esp, 4
	mov	BYTE PTR __$EHRec$[esp+40], 1
	cmp	eax, ebx
	je	SHORT $LN362@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN362@CvGlobals:
	lea	edi, DWORD PTR [esi+984]
	mov	ecx, edi
	mov	DWORD PTR [esi+1000], ebx
	mov	DWORD PTR [esi+1004], ebx
	mov	DWORD PTR [esi+1008], ebx
	call	?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::clear
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	lea	ecx, DWORD PTR [esi+916]
	mov	DWORD PTR [edi+4], ebx
	mov	BYTE PTR __$EHRec$[esp+40], bl
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ
	mov	eax, DWORD PTR [esi+900]
	pop	edi
	cmp	eax, ebx
	je	SHORT $LN379@CvGlobals
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN379@CvGlobals:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi+900], ebx
	mov	DWORD PTR [esi+904], ebx
	mov	DWORD PTR [esi+908], ebx
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvGlobals@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 896				; 00000380H
	jmp	??1?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::~vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
__unwindfunclet$??1CvGlobals@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 916				; 00000394H
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__unwindfunclet$??1CvGlobals@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 980				; 000003d4H
	jmp	??1?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAE@XZ
__ehhandler$??1CvGlobals@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvGlobals@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvGlobals@@UAE@XZ ENDP				; CvGlobals::~CvGlobals
PUBLIC	?_Assign_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Assign_n
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Assign_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Tmp$ = 12						; size = 4
__Val$ = 12						; size = 4
?_Assign_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Assign_n, COMDAT
; _this$ = ecx

; 1096 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [eax]
	push	esi

; 1097 : 		erase(begin(), end());

	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$[esp], edx
	mov	edx, DWORD PTR [ecx+8]
	cmp	esi, edx
	je	SHORT $LN15@Assign_n
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN40@Assign_n
	push	edi
	npad	4
$LL42@Assign_n:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	add	eax, 4
	add	esi, 4
	cmp	eax, edx
	jne	SHORT $LL42@Assign_n
	pop	edi
$LN40@Assign_n:
	mov	DWORD PTR [ecx+8], esi
$LN15@Assign_n:

; 1098 : 		insert(begin(), _Count, _Tmp);

	mov	eax, DWORD PTR [ecx+4]
	lea	edx, DWORD PTR __Tmp$[esp]
	push	edx
	mov	edx, DWORD PTR __Count$[esp+4]
	push	edx
	push	eax
	call	?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Insert_n
	pop	esi

; 1099 : 		}

	ret	8
?_Assign_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Assign_n
_TEXT	ENDS
PUBLIC	??_GCvEntityEventInfo@@QAEPAXI@Z		; CvEntityEventInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvEntityEventInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvEntityEventInfo@@QAEPAXI@Z PROC			; CvEntityEventInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+264]
	test	eax, eax
	je	SHORT $LN13@scalar@49
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@49:
	mov	ecx, esi
	mov	DWORD PTR [esi+264], 0
	mov	DWORD PTR [esi+268], 0
	mov	DWORD PTR [esi+272], 0
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN15@scalar@49
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@scalar@49:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvEntityEventInfo@@QAEPAXI@Z ENDP			; CvEntityEventInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvGlobals@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvGlobals@@UAEPAXI@Z PROC				; CvGlobals::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvGlobals@@UAE@XZ			; CvGlobals::~CvGlobals
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@50
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@50:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvGlobals@@UAEPAXI@Z ENDP				; CvGlobals::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?assign@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
?assign@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z PROC ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::assign, COMDAT
; _this$ = ecx

; 871  : 		_Assign_n(_Count, _Val);

	jmp	?_Assign_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Assign_n
?assign@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ENDP ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::assign
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvEntityEventInfo@@@@YAXAAPAVCvEntityEventInfo@@@Z ; SAFE_DELETE<CvEntityEventInfo>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvEntityEventInfo@@@@YAXAAPAVCvEntityEventInfo@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvEntityEventInfo@@@@YAXAAPAVCvEntityEventInfo@@@Z PROC ; SAFE_DELETE<CvEntityEventInfo>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN19@SAFE_DELET@66
	mov	eax, DWORD PTR [esi+264]
	test	eax, eax
	je	SHORT $LN17@SAFE_DELET@66
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@SAFE_DELET@66:
	mov	ecx, esi
	mov	DWORD PTR [esi+264], 0
	mov	DWORD PTR [esi+268], 0
	mov	DWORD PTR [esi+272], 0
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@SAFE_DELET@66:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvEntityEventInfo@@@@YAXAAPAVCvEntityEventInfo@@@Z ENDP ; SAFE_DELETE<CvEntityEventInfo>
_TEXT	ENDS
PUBLIC	?_Init@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAEXI@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?_Init@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAEXI@Z
_TEXT	SEGMENT
$T299853 = -4						; size = 4
__Buckets$ = 8						; size = 4
?_Init@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAEXI@Z PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 829  : 		{	// initialize hash table with _Buckets buckets, leave list alone

	push	ecx
	push	esi
	push	edi

; 830  : 		_Vec.assign(_Buckets + 1, end());

	mov	edi, DWORD PTR __Buckets$[esp+8]
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR $T299853[esp+12]
	push	ecx
	lea	edx, DWORD PTR [edi+1]
	push	edx
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR $T299853[esp+20], eax
	call	?_Assign_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Assign_n

; 831  : 		_Mask = _Buckets - 1;

	lea	eax, DWORD PTR [edi-1]

; 832  : 		_Maxidx = _Buckets;

	mov	DWORD PTR [esi+36], edi
	pop	edi
	mov	DWORD PTR [esi+32], eax
	pop	esi

; 833  : 		}

	pop	ecx
	ret	4
?_Init@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAEXI@Z ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?_Reinsert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAEXXZ ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Reinsert
PUBLIC	?_Insert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAE?AU?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@4@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAE?AU?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@4@@Z
_TEXT	SEGMENT
tv929 = -4						; size = 4
tv926 = -4						; size = 4
$T300287 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Tmp$300731 = 12					; size = 4
$T300264 = 12						; size = 4
$T299888 = 12						; size = 4
__Bucket$ = 12						; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 4
?_Insert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAE?AU?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@4@@Z PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 836  : 		{	// try to insert (possibly existing) node with value _Val

	push	ecx
	push	ebx

; 837  : 		size_type _Bucket = _Hashval(this->_Kfn(_Val));

	mov	ebx, DWORD PTR __Val$[esp+4]
	push	ebp
	push	esi
	push	edi
	push	ebx
	mov	edi, ecx
	call	?_Hashval@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IBEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Hashval
	mov	ebp, eax

; 838  : 		iterator _Plist = _Get_iter_from_vec(_Vec[_Bucket + 1]);

	mov	eax, DWORD PTR [edi+20]
	mov	esi, DWORD PTR [eax+ebp*4+4]
	lea	eax, DWORD PTR [eax+ebp*4]
	mov	DWORD PTR __Bucket$[esp+16], ebp

; 839  : 
; 840  : 		for (; _Plist != _Get_iter_from_vec(_Vec[_Bucket]); )

	cmp	esi, DWORD PTR [eax]
	je	SHORT $LN17@Insert@3
$LL18@Insert@3:

; 841  : 			if (this->comp(this->_Kfn(_Val), this->_Kfn(*--_Plist)))

	mov	esi, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	push	ebx
	call	DWORD PTR __imp_??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN16@Insert@3
	mov	edx, DWORD PTR [edi+20]
	cmp	esi, DWORD PTR [edx+ebp*4]
	jne	SHORT $LL18@Insert@3
$LN17@Insert@3:

; 854  : 				}
; 855  : 
; 856  : 		if (_Where != end())

	mov	edx, DWORD PTR __Where$[esp+16]
	cmp	edx, DWORD PTR [edi+8]
	je	SHORT $LN10@Insert@3

; 857  : 			_List.splice(_Plist, _List, _Where);	// move element into place

	cmp	edx, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [edi+4]
	je	$LN284@Insert@3
	mov	eax, DWORD PTR [edx]
	cmp	ecx, ecx
	jne	SHORT $LN101@Insert@3
	cmp	esi, edx
	je	$LN284@Insert@3
	cmp	esi, eax
	je	$LN284@Insert@3
$LN101@Insert@3:
	push	0
	push	1
	push	eax
	push	edx
	push	ecx
	push	esi
	call	?_Splice@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXV?$_Const_iterator@$0A@@12@AAV12@00I_N@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Splice

; 858  : 		else

	mov	edx, DWORD PTR __Where$[esp+16]
	jmp	SHORT $LN284@Insert@3
$LN16@Insert@3:

; 842  : 				;	// still too high in bucket list
; 843  : 			else if (_Multi
; 844  : 				|| this->comp(this->_Kfn(*_Plist), this->_Kfn(_Val)))

	lea	eax, DWORD PTR [esi+8]
	push	ebx
	push	eax
	call	DWORD PTR __imp_??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN14@Insert@3

; 845  : 				{	// found insertion point, back up to it
; 846  : 				++_Plist;

	mov	esi, DWORD PTR [esi]

; 847  : 				break;

	jmp	SHORT $LN17@Insert@3
$LN14@Insert@3:

; 848  : 				}
; 849  : 			else
; 850  : 				{	// discard new list element and return existing
; 851  : 				if (_Where != end())

	mov	eax, DWORD PTR __Where$[esp+16]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN11@Insert@3

; 852  : 					_List.erase(_Where);

	push	eax
	lea	ecx, DWORD PTR $T299888[esp+20]
	push	ecx
	lea	ecx, DWORD PTR [edi+4]
	call	?erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::erase
$LN11@Insert@3:

; 853  : 				return (_Pairib(_Plist, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebp
	mov	BYTE PTR [eax+4], 0
	pop	ebx

; 884  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert@3:

; 859  : 			_Where = _List.insert(_Plist, _Val);	// insert new element

	mov	edx, DWORD PTR [esi+4]
	push	ebx
	push	edx
	lea	ebp, DWORD PTR [edi+4]
	push	esi
	mov	ecx, ebp
	call	?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@0ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode
	push	1
	mov	ecx, ebp
	mov	ebx, eax
	call	?_Incsize@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Incsize
	mov	ebp, DWORD PTR __Bucket$[esp+16]
	mov	DWORD PTR [esi+4], ebx
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax], ebx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR __Where$[esp+16], edx
$LN284@Insert@3:

; 860  : 		for (; _Plist == _Get_iter_from_vec(_Vec[_Bucket]); --_Bucket)

	mov	ecx, DWORD PTR [edi+20]
	cmp	esi, DWORD PTR [ecx+ebp*4]
	jne	SHORT $LN285@Insert@3
	jmp	SHORT $LN8@Insert@3
	npad	9
$LL282@Insert@3:
	mov	edx, DWORD PTR __Where$[esp+16]
$LN8@Insert@3:

; 861  : 			{	// update end iterators if new first bucket element
; 862  : 			_Vec[_Bucket] = _Where;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [eax+ebp*4], edx

; 863  : 			if (_Bucket == 0)

	test	ebp, ebp
	je	SHORT $LN283@Insert@3
	mov	ecx, DWORD PTR [edi+20]
	dec	ebp
	cmp	esi, DWORD PTR [ecx+ebp*4]
	je	SHORT $LL282@Insert@3
$LN283@Insert@3:

; 860  : 		for (; _Plist == _Get_iter_from_vec(_Vec[_Bucket]); --_Bucket)

	mov	edx, DWORD PTR __Where$[esp+16]
$LN285@Insert@3:

; 864  : 				break;
; 865  : 			}
; 866  : 
; 867  : 		if (max_load_factor() < load_factor())

	mov	ecx, DWORD PTR [edi+12]
	fild	DWORD PTR [edi+12]
	mov	eax, DWORD PTR [edi+40]
	mov	esi, DWORD PTR [edi+36]
	mov	DWORD PTR $T300264[esp+16], eax
	test	ecx, ecx
	jge	SHORT $LN286@Insert@3
	fadd	DWORD PTR __real@4f800000
$LN286@Insert@3:
	mov	eax, esi
	mov	DWORD PTR tv926[esp+20], eax
	fild	DWORD PTR tv926[esp+20]
	test	eax, eax
	jge	SHORT $LN287@Insert@3
	fadd	DWORD PTR __real@4f800000
$LN287@Insert@3:
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR $T300287[esp+20]
	fld	DWORD PTR $T300264[esp+16]
	fld	DWORD PTR $T300287[esp+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@Insert@3

; 868  :  #if _HAS_INCREMENTAL_HASH
; 869  : 			_Grow();	// too dense, need to grow hash table
; 870  : 
; 871  :  #else /* _HAS_INCREMENTAL_HASH */
; 872  : 			{	// rehash to bigger table
; 873  : 			size_type _Maxsize = _Vec.max_size() / 2;
; 874  : 			size_type _Newsize = bucket_count();
; 875  : 
; 876  : 			for (int _Idx = 0; _Idx < 3 && _Newsize < _Maxsize; ++_Idx)

	xor	eax, eax
$LL3@Insert@3:
	cmp	esi, 536870911				; 1fffffffH
	jae	SHORT $LN1@Insert@3
	inc	eax

; 877  : 				_Newsize *= 2;	// multiply safely by 8

	add	esi, esi
	cmp	eax, 3
	jl	SHORT $LL3@Insert@3
$LN1@Insert@3:

; 878  : 			_Init(_Newsize);

	mov	edx, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR [edi+20]
	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR __Tmp$300731[esp+16], edx
	mov	edx, DWORD PTR [ecx+8]
	cmp	ebx, edx
	je	SHORT $LN204@Insert@3
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN229@Insert@3
	npad	4
$LL231@Insert@3:
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ebx], ebp
	add	eax, 4
	add	ebx, 4
	cmp	eax, edx
	jne	SHORT $LL231@Insert@3
$LN229@Insert@3:
	mov	DWORD PTR [ecx+8], ebx
$LN204@Insert@3:
	mov	eax, DWORD PTR [ecx+4]
	lea	edx, DWORD PTR __Tmp$300731[esp+16]
	push	edx
	lea	edx, DWORD PTR [esi+1]
	push	edx
	push	eax
	call	?_Insert_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXV?$_Vector_const_iterator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@2@IABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Insert_n
	lea	eax, DWORD PTR [esi-1]

; 879  : 			_Reinsert();

	mov	ecx, edi
	mov	DWORD PTR [edi+32], eax
	mov	DWORD PTR [edi+36], esi
	call	?_Reinsert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAEXXZ ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Reinsert
	mov	edx, DWORD PTR __Where$[esp+16]
$LN4@Insert@3:

; 880  : 			}
; 881  : #endif /* _HAS_INCREMENTAL_HASH */
; 882  : 
; 883  : 		return (_Pairib(_Where, true));	// return iterator for new element

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	mov	BYTE PTR [eax+4], 1
	pop	ebx

; 884  : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Insert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAE?AU?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@4@@Z ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Reinsert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAEXXZ
_TEXT	SEGMENT
$T300818 = -8						; size = 8
?_Reinsert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAEXXZ PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Reinsert, COMDAT
; _this$ = ecx

; 887  : 		{	// insert elements at beginning of list into table

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 888  : 		iterator _First;
; 889  : 		for (; (_First = _List.begin()) != _Get_iter_from_vec(_Vec[0]); )

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+20]
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $LN1@Reinsert
$LL2@Reinsert:

; 890  : 			_Insert(*_First, _First);

	push	eax
	add	eax, 8
	push	eax
	lea	edx, DWORD PTR $T300818[esp+20]
	push	edx
	mov	ecx, esi
	call	?_Insert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAE?AU?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@4@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+20]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LL2@Reinsert
$LN1@Reinsert:
	pop	esi

; 891  : 		}

	add	esp, 8
	ret	0
?_Reinsert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAEXXZ ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Reinsert
_TEXT	ENDS
PUBLIC	??$deleteInfoArray@VCvEntityEventInfo@@@@YAXAAV?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@@Z ; deleteInfoArray<CvEntityEventInfo>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
;	COMDAT ??$deleteInfoArray@VCvEntityEventInfo@@@@YAXAAV?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
??$deleteInfoArray@VCvEntityEventInfo@@@@YAXAAV?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@@Z PROC ; deleteInfoArray<CvEntityEventInfo>, COMDAT

; 51   : {

	push	ebx

; 52   : 	for(std::vector<T*>::iterator it = array.begin(); it != array.end(); ++it)

	mov	ebx, DWORD PTR _array$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+4]
	xor	ebp, ebp
	cmp	edi, DWORD PTR [ebx+8]
	je	SHORT $LN1@deleteInfo@37
$LL14@deleteInfo@37:

; 53   : 	{
; 54   : 		SAFE_DELETE(*it);

	mov	esi, DWORD PTR [edi]
	cmp	esi, ebp
	je	SHORT $LN32@deleteInfo@37
	mov	eax, DWORD PTR [esi+264]
	cmp	eax, ebp
	je	SHORT $LN46@deleteInfo@37
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN46@deleteInfo@37:
	mov	ecx, esi
	mov	DWORD PTR [esi+264], ebp
	mov	DWORD PTR [esi+268], ebp
	mov	DWORD PTR [esi+272], ebp
	call	??1CvBaseInfo@@QAE@XZ
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@deleteInfo@37:
	mov	DWORD PTR [edi], ebp
	add	edi, 4
	cmp	edi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@deleteInfo@37
$LN1@deleteInfo@37:

; 55   : 	}
; 56   : 
; 57   : 	array.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN62@deleteInfo@37
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	cmp	eax, ebp
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	jle	SHORT $LN87@deleteInfo@37
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN87@deleteInfo@37:
	mov	DWORD PTR [ebx+8], edi
$LN62@deleteInfo@37:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 58   : }

	ret	0
??$deleteInfoArray@VCvEntityEventInfo@@@@YAXAAV?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@@Z ENDP ; deleteInfoArray<CvEntityEventInfo>
_TEXT	ENDS
PUBLIC	?deleteInfoArrays@CvGlobals@@QAEXXZ		; CvGlobals::deleteInfoArrays
; Function compile flags: /Ogtpy
;	COMDAT ?deleteInfoArrays@CvGlobals@@QAEXXZ
_TEXT	SEGMENT
?deleteInfoArrays@CvGlobals@@QAEXXZ PROC		; CvGlobals::deleteInfoArrays, COMDAT
; _this$ = ecx

; 6879 : {

	push	esi
	mov	esi, ecx

; 6880 : 	deleteInfoArray(m_paBuildingClassInfo);

	lea	eax, DWORD PTR [esi+1316]
	push	eax
	call	??$deleteInfoArray@VCvBuildingClassInfo@@@@YAXAAV?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@@Z ; deleteInfoArray<CvBuildingClassInfo>

; 6881 : 
; 6882 : 	deleteInfoArray(m_paLeaderHeadInfo);

	lea	ecx, DWORD PTR [esi+1268]
	push	ecx
	call	??$deleteInfoArray@VCvLeaderHeadInfo@@@@YAXAAV?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@@Z ; deleteInfoArray<CvLeaderHeadInfo>

; 6883 : 	deleteInfoArray(m_paCivilizationInfo);

	lea	edx, DWORD PTR [esi+1228]
	push	edx
	call	??$deleteInfoArray@VCvCivilizationInfo@@@@YAXAAV?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@@Z ; deleteInfoArray<CvCivilizationInfo>

; 6884 : 	deleteInfoArray(m_paMinorCivInfo);

	lea	eax, DWORD PTR [esi+1252]
	push	eax
	call	??$deleteInfoArray@VCvMinorCivInfo@@@@YAXAAV?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@@Z ; deleteInfoArray<CvMinorCivInfo>

; 6885 : 
; 6886 : 	deleteInfoArray(m_paVoteSourceInfo);

	lea	ecx, DWORD PTR [esi+1364]
	push	ecx
	call	??$deleteInfoArray@VCvVoteSourceInfo@@@@YAXAAV?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@@Z ; deleteInfoArray<CvVoteSourceInfo>

; 6887 : 	deleteInfoArray(m_paHandicapInfo);

	lea	edx, DWORD PTR [esi+1180]
	push	edx
	call	??$deleteInfoArray@VCvHandicapInfo@@@@YAXAAV?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@@Z ; deleteInfoArray<CvHandicapInfo>

; 6888 : 	deleteInfoArray(m_paGameSpeedInfo);

	lea	eax, DWORD PTR [esi+1196]
	push	eax
	call	??$deleteInfoArray@VCvGameSpeedInfo@@@@YAXAAV?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@@Z ; deleteInfoArray<CvGameSpeedInfo>

; 6889 : 	deleteInfoArray(m_paTurnTimerInfo);

	lea	ecx, DWORD PTR [esi+1212]
	push	ecx
	call	??$deleteInfoArray@VCvTurnTimerInfo@@@@YAXAAV?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@@Z ; deleteInfoArray<CvTurnTimerInfo>

; 6890 : 	deleteInfoArray(m_paVictoryInfo);

	lea	edx, DWORD PTR [esi+1588]
	push	edx
	call	??$deleteInfoArray@VCvVictoryInfo@@@@YAXAAV?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@@Z ; deleteInfoArray<CvVictoryInfo>

; 6891 : 	deleteInfoArray(m_paSmallAwardInfo);

	lea	eax, DWORD PTR [esi+1604]
	push	eax
	call	??$deleteInfoArray@VCvSmallAwardInfo@@@@YAXAAV?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@@Z ; deleteInfoArray<CvSmallAwardInfo>

; 6892 : 	deleteInfoArray(m_paHurryInfo);

	lea	ecx, DWORD PTR [esi+1572]
	push	ecx
	call	??$deleteInfoArray@VCvHurryInfo@@@@YAXAAV?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@@Z ; deleteInfoArray<CvHurryInfo>

; 6893 : 	deleteInfoArray(m_paProcessInfo);

	lea	edx, DWORD PTR [esi+1284]
	push	edx
	call	??$deleteInfoArray@VCvProcessInfo@@@@YAXAAV?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@@Z ; deleteInfoArray<CvProcessInfo>

; 6894 : 	deleteInfoArray(m_paVoteInfo);

	lea	eax, DWORD PTR [esi+1300]
	push	eax
	call	??$deleteInfoArray@VCvVoteInfo@@@@YAXAAV?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@@Z ; deleteInfoArray<CvVoteInfo>

; 6895 : 
; 6896 : 	deleteInfoArray(m_paColorInfo);

	lea	ecx, DWORD PTR [esi+1036]
	push	ecx
	call	??$deleteInfoArray@VCvColorInfo@@@@YAXAAV?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@@Z ; deleteInfoArray<CvColorInfo>

; 6897 : 	deleteInfoArray(m_paPlayerColorInfo);

	lea	edx, DWORD PTR [esi+1052]
	push	edx
	call	??$deleteInfoArray@VCvPlayerColorInfo@@@@YAXAAV?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@@Z ; deleteInfoArray<CvPlayerColorInfo>

; 6898 : 	deleteInfoArray(m_paInterfaceModeInfo);

	lea	eax, DWORD PTR [esi+896]
	push	eax
	call	??$deleteInfoArray@VCvInterfaceModeInfo@@@@YAXAAV?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@@Z ; deleteInfoArray<CvInterfaceModeInfo>

; 6899 : 
; 6900 : 	deleteInfoArray(m_paRouteInfo);

	lea	ecx, DWORD PTR [esi+1100]
	add	esp, 64					; 00000040H
	push	ecx
	call	??$deleteInfoArray@VCvRouteInfo@@@@YAXAAV?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@@Z ; deleteInfoArray<CvRouteInfo>

; 6901 : 
; 6902 : 	deleteInfoArray(m_aEraInfo);

	lea	edx, DWORD PTR [esi+1556]
	push	edx
	call	??$deleteInfoArray@VCvEraInfo@@@@YAXAAV?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@@Z ; deleteInfoArray<CvEraInfo>

; 6903 : 
; 6904 : 	deleteInfoArray(m_paBuildInfo);

	lea	eax, DWORD PTR [esi+1164]
	push	eax
	call	??$deleteInfoArray@VCvBuildInfo@@@@YAXAAV?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@@Z ; deleteInfoArray<CvBuildInfo>

; 6905 : 	deleteInfoArray(m_paUnitClassInfo);

	lea	ecx, DWORD PTR [esi+1332]
	push	ecx
	call	??$deleteInfoArray@VCvUnitClassInfo@@@@YAXAAV?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@@Z ; deleteInfoArray<CvUnitClassInfo>

; 6906 : 	deleteInfoArray(m_paSpecialUnitInfo);

	lea	edx, DWORD PTR [esi+1348]
	push	edx
	call	??$deleteInfoArray@VCvSpecialUnitInfo@@@@YAXAAV?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@@Z ; deleteInfoArray<CvSpecialUnitInfo>

; 6907 : 	deleteInfoArray(m_paSpecialistInfo);

	lea	eax, DWORD PTR [esi+1460]
	push	eax
	call	??$deleteInfoArray@VCvSpecialistInfo@@@@YAXAAV?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@@Z ; deleteInfoArray<CvSpecialistInfo>

; 6908 : 	deleteInfoArray(m_paActionInfo);

	lea	ecx, DWORD PTR [esi+1476]
	push	ecx
	call	??$deleteInfoArray@VCvActionInfo@@@@YAXAAV?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@@Z ; deleteInfoArray<CvActionInfo>

; 6909 : 	deleteInfoArray(m_paMissionInfo);

	lea	edx, DWORD PTR [esi+1492]
	push	edx
	call	??$deleteInfoArray@VCvMissionInfo@@@@YAXAAV?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@@Z ; deleteInfoArray<CvMissionInfo>

; 6910 : 	deleteInfoArray(m_paControlInfo);

	lea	eax, DWORD PTR [esi+1508]
	push	eax
	call	??$deleteInfoArray@VCvControlInfo@@@@YAXAAV?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@@Z ; deleteInfoArray<CvControlInfo>

; 6911 : 	deleteInfoArray(m_paCommandInfo);

	lea	ecx, DWORD PTR [esi+1524]
	push	ecx
	call	??$deleteInfoArray@VCvCommandInfo@@@@YAXAAV?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@@Z ; deleteInfoArray<CvCommandInfo>

; 6912 : 	deleteInfoArray(m_paAutomateInfo);

	lea	edx, DWORD PTR [esi+1540]
	push	edx
	call	??$deleteInfoArray@VCvAutomateInfo@@@@YAXAAV?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@@Z ; deleteInfoArray<CvAutomateInfo>

; 6913 : 
; 6914 : 	deleteInfoArray(m_paUnitCombatClassInfo);

	lea	eax, DWORD PTR [esi+1380]
	push	eax
	call	??$deleteInfoArray@VCvBaseInfo@@@@YAXAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@@Z ; deleteInfoArray<CvBaseInfo>

; 6915 : 	deleteInfoArray(m_paUnitAIInfos);

	lea	ecx, DWORD PTR [esi+1396]
	push	ecx
	call	??$deleteInfoArray@VCvBaseInfo@@@@YAXAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@@Z ; deleteInfoArray<CvBaseInfo>

; 6916 : 	deleteInfoArray(m_paGameOptionInfos);

	lea	edx, DWORD PTR [esi+1412]
	push	edx
	call	??$deleteInfoArray@VCvGameOptionInfo@@@@YAXAAV?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@@Z ; deleteInfoArray<CvGameOptionInfo>

; 6917 : 	deleteInfoArray(m_paMPOptionInfos);

	lea	eax, DWORD PTR [esi+1428]
	push	eax
	call	??$deleteInfoArray@VCvMPOptionInfo@@@@YAXAAV?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@@Z ; deleteInfoArray<CvMPOptionInfo>

; 6918 : 	deleteInfoArray(m_paPlayerOptionInfos);

	lea	ecx, DWORD PTR [esi+1444]
	push	ecx
	call	??$deleteInfoArray@VCvPlayerOptionInfo@@@@YAXAAV?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@@Z ; deleteInfoArray<CvPlayerOptionInfo>

; 6919 : 
; 6920 : 	deleteInfoArray(m_paYieldInfo);

	lea	edx, DWORD PTR [esi+1084]
	add	esp, 64					; 00000040H
	push	edx
	call	??$deleteInfoArray@VCvYieldInfo@@@@YAXAAV?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@@Z ; deleteInfoArray<CvYieldInfo>

; 6921 : 	deleteInfoArray(m_paTerrainInfo);

	lea	eax, DWORD PTR [esi+1068]
	push	eax
	call	??$deleteInfoArray@VCvTerrainInfo@@@@YAXAAV?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@@Z ; deleteInfoArray<CvTerrainInfo>

; 6922 : 	deleteInfoArray(m_paFeatureInfo);

	lea	ecx, DWORD PTR [esi+1116]
	push	ecx
	call	??$deleteInfoArray@VCvFeatureInfo@@@@YAXAAV?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@@Z ; deleteInfoArray<CvFeatureInfo>

; 6923 : 	deleteInfoArray(m_paResourceClassInfo);

	lea	edx, DWORD PTR [esi+1132]
	push	edx
	call	??$deleteInfoArray@VCvResourceClassInfo@@@@YAXAAV?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@@Z ; deleteInfoArray<CvResourceClassInfo>

; 6924 : 	deleteInfoArray(m_paResourceInfo);

	lea	eax, DWORD PTR [esi+1148]
	push	eax
	call	??$deleteInfoArray@VCvResourceInfo@@@@YAXAAV?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@@Z ; deleteInfoArray<CvResourceInfo>

; 6925 : 	deleteInfoArray(m_paUnitDomainInfo);

	lea	ecx, DWORD PTR [esi+1636]
	push	ecx
	call	??$deleteInfoArray@VCvBaseInfo@@@@YAXAAV?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@@Z ; deleteInfoArray<CvBaseInfo>

; 6926 : 
; 6927 : 	SAFE_DELETE_ARRAY(GC.getFootstepAudioTags());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1768
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN7@deleteInfo@38
	mov	edx, DWORD PTR [eax-4]
	push	edi
	lea	edi, DWORD PTR [eax-4]
	push	OFFSET ??1CvString@@QAE@XZ		; CvString::~CvString
	push	edx
	push	28					; 0000001cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	edi
$LN7@deleteInfo@38:

; 6928 : 
; 6929 : 	deleteInfoArray(m_paEntityEventInfo);

	add	esi, 1620				; 00000654H
	push	esi
	mov	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1768, 0
	call	??$deleteInfoArray@VCvEntityEventInfo@@@@YAXAAV?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@@Z ; deleteInfoArray<CvEntityEventInfo>
	add	esp, 4
	pop	esi

; 6930 : }

	ret	0
?deleteInfoArrays@CvGlobals@@QAEXXZ ENDP		; CvGlobals::deleteInfoArrays
_TEXT	ENDS
PUBLIC	?clear@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAEXXZ ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAEXXZ
_TEXT	SEGMENT
$T301297 = -4						; size = 4
?clear@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAEXXZ PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 613  : 		{	// erase all

	push	ecx
	push	esi
	mov	esi, ecx

; 614  : 		_List.clear();

	lea	ecx, DWORD PTR [esi+4]
	call	?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::clear

; 615  : 		_Init();

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR $T301297[esp+8]
	push	ecx
	push	9
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR $T301297[esp+16], eax
	call	?_Assign_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Assign_n
	mov	DWORD PTR [esi+32], 7
	mov	DWORD PTR [esi+36], 8
	pop	esi

; 616  : 		}

	pop	ecx
	ret	0
?clear@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAEXXZ ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z$1
__ehfuncinfo$??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xhash
xdata$x	ENDS
;	COMDAT ??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T301608 = 8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >, COMDAT
; _this$ = ecx

; 343  : 		{	// construct empty hash table

	push	-1
	push	__ehhandler$??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, DWORD PTR __Parg$[esp+12]
	push	esi
	mov	esi, ecx
	mov	cl, BYTE PTR [eax]
	push	edi
	mov	BYTE PTR [esi], cl
	lea	edi, DWORD PTR [esi+4]
	mov	ecx, edi
	mov	DWORD PTR _this$[esp+24], esi
	call	?_Buynode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode
	mov	DWORD PTR [edi+4], eax
	xor	eax, eax
	mov	DWORD PTR [edi+8], eax
	lea	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR __$EHRec$[esp+32], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax

; 344  : 		_Init();

	mov	edx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR $T301608[esp+20]
	push	eax
	push	9
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [esi+40], 1082130432		; 40800000H
	mov	DWORD PTR $T301608[esp+28], edx
	call	?_Assign_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Assign_n

; 345  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+32], 7
	mov	DWORD PTR [esi+36], 8
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
__unwindfunclet$??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@QAE@XZ ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::~vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >
__ehhandler$??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
PUBLIC	?insert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AU?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AU?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AU?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@@Z PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 545  : 		return (_Insert(_Val, end()));

	mov	eax, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	eax
	push	esi
	call	?_Insert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAE?AU?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@4@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert
	mov	eax, esi
	pop	esi

; 546  : 		}

	ret	8
?insert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AU?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@@Z ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	?infoTypeFromStringReset@CvGlobals@@QAEXXZ	; CvGlobals::infoTypeFromStringReset
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
;	COMDAT ?infoTypeFromStringReset@CvGlobals@@QAEXXZ
_TEXT	SEGMENT
$T301706 = -4						; size = 4
?infoTypeFromStringReset@CvGlobals@@QAEXXZ PROC		; CvGlobals::infoTypeFromStringReset, COMDAT
; _this$ = ecx

; 6989 : {

	push	ecx
	push	esi
	mov	esi, ecx

; 6990 : 	m_infosMap.clear();

	lea	ecx, DWORD PTR [esi+984]
	call	?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::clear
	mov	eax, DWORD PTR [esi+988]
	lea	ecx, DWORD PTR $T301706[esp+8]
	push	ecx
	push	9
	lea	ecx, DWORD PTR [esi+996]
	mov	DWORD PTR $T301706[esp+16], eax
	call	?_Assign_n@?$vector@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@V?$allocator@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@3@@std@@IAEXIABV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::vector<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0>,std::allocator<std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Iterator<0> > >::_Assign_n
	mov	DWORD PTR [esi+1012], 7
	mov	DWORD PTR [esi+1016], 8

; 6991 : 	m_infosHashMap.clear();

	mov	edx, DWORD PTR [esi+1028]
	mov	eax, DWORD PTR [edx+4]
	add	esi, 1024				; 00000400H
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 6992 : }

	pop	ecx
	ret	0
?infoTypeFromStringReset@CvGlobals@@QAEXXZ ENDP		; CvGlobals::infoTypeFromStringReset
_TEXT	ENDS
PUBLIC	??0?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAE@XZ ; stdext::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\hash_map
;	COMDAT ??0?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAE@XZ
_TEXT	SEGMENT
$T301775 = -1						; size = 1
$T301774 = -1						; size = 1
??0?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAE@XZ PROC ; stdext::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx

; 113  : 		{	// construct empty map from defaults

	push	ecx
	push	esi
	mov	esi, ecx
	lea	eax, DWORD PTR $T301774[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T301775[esp+12]
	push	ecx
	mov	ecx, esi
	call	??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >

; 114  : 		}

	mov	eax, esi
	pop	esi
	pop	ecx
	ret	0
??0?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAE@XZ ENDP ; stdext::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
PUBLIC	??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stdext::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
xdata$x	SEGMENT
__unwindtable$??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\hash_map
xdata$x	ENDS
;	COMDAT ??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T301789 = -52						; size = 8
$T301787 = -44						; size = 32
__$EHRec$ = -12						; size = 12
__Where$ = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; stdext::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[], COMDAT
; _this$ = ecx

; 157  : 		{	// find element matching _Keyval or insert with default mapped

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi

; 158  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	edi, DWORD PTR __Keyval$[esp+56]
	push	edi
	lea	eax, DWORD PTR __Where$[esp+60]
	push	eax
	mov	esi, ecx
	call	?lower_bound@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE?AV?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::lower_bound

; 159  : 		if (_Where == this->end())

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR __Where$[esp+56]
	cmp	ecx, eax
	jne	SHORT $LN37@operator@5

; 160  : 			_Where = this->insert(value_type(_Keyval, mapped_type())).first;

	push	edi
	lea	ecx, DWORD PTR $T301787[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	xor	eax, eax
	mov	DWORD PTR $T301787[esp+88], eax
	mov	DWORD PTR __$EHRec$[esp+68], eax
	mov	eax, DWORD PTR [esi+8]
	push	eax
	lea	ecx, DWORD PTR $T301787[esp+64]
	push	ecx
	lea	edx, DWORD PTR $T301789[esp+68]
	push	edx
	mov	ecx, esi
	call	?_Insert@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@IAE?AU?$pair@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@_N@std@@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@4@V?$_Iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@4@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert
	mov	esi, DWORD PTR $T301789[esp+60]
	lea	ecx, DWORD PTR $T301787[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi

; 161  : 		return ((*_Where).second);

	lea	eax, DWORD PTR [esi+36]
	pop	esi

; 162  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	4
$LN37@operator@5:

; 161  : 		return ((*_Where).second);

	lea	eax, DWORD PTR [ecx+36]

; 162  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	lea	ecx, DWORD PTR $T301787[ebp]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ
__ehhandler$??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; stdext::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
PUBLIC	??0CvGlobals@@QAE@XZ				; CvGlobals::CvGlobals
EXTRN	__imp_??0Results@Database@@QAE@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__ehfuncinfo$??0CvGlobals@@QAE@XZ DD 019930522H
	DD	02aH
	DD	FLAT:__unwindtable$??0CvGlobals@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvGlobals@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$15
	DD	0fH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$16
	DD	010H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$18
	DD	012H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$19
	DD	013H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$20
	DD	014H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$21
	DD	015H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$22
	DD	016H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$23
	DD	017H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$24
	DD	018H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$25
	DD	019H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$26
	DD	01aH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$27
	DD	01bH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$28
	DD	01cH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$29
	DD	01dH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$30
	DD	01eH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$31
	DD	01fH
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$32
	DD	020H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$33
	DD	021H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$34
	DD	022H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$35
	DD	023H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$36
	DD	024H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$37
	DD	025H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$38
	DD	026H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$39
	DD	027H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$40
	DD	028H
	DD	FLAT:__unwindfunclet$??0CvGlobals@@QAE@XZ$41
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ??0CvGlobals@@QAE@XZ
_TEXT	SEGMENT
$T302094 = -17						; size = 1
$T302093 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvGlobals@@QAE@XZ PROC				; CvGlobals::CvGlobals, COMDAT
; _this$ = ecx

; 1936 : {

	push	-1
	push	__ehhandler$??0CvGlobals@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+36], esi
	xor	ebx, ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvGlobals@@6B@
	mov	BYTE PTR [esi+4], bl
	mov	BYTE PTR [esi+5], bl
	mov	BYTE PTR [esi+6], bl
	mov	BYTE PTR [esi+7], bl
	mov	DWORD PTR [esi+8], ebx
	mov	BYTE PTR [esi+12], bl
	mov	BYTE PTR [esi+13], bl
	mov	BYTE PTR [esi+14], bl
	mov	BYTE PTR [esi+15], bl
	mov	BYTE PTR [esi+16], bl
	mov	BYTE PTR [esi+17], bl
	mov	BYTE PTR [esi+18], bl
	mov	BYTE PTR [esi+19], bl
	mov	BYTE PTR [esi+20], bl
	mov	BYTE PTR [esi+21], bl
	mov	BYTE PTR [esi+22], bl
	mov	BYTE PTR [esi+23], bl
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [esi+32], ebx
	mov	DWORD PTR [esi+36], ebx
	mov	BYTE PTR [esi+40], bl
	mov	BYTE PTR [esi+41], bl
	mov	BYTE PTR [esi+42], bl
	mov	DWORD PTR [esi+44], ebx
	mov	DWORD PTR [esi+48], ebx
	mov	DWORD PTR [esi+52], ebx
	mov	DWORD PTR [esi+56], ebx
	mov	DWORD PTR [esi+60], ebx
	mov	DWORD PTR [esi+64], ebx
	mov	DWORD PTR [esi+68], ebx
	mov	DWORD PTR [esi+72], ebx
	mov	DWORD PTR [esi+76], ebx
	mov	DWORD PTR [esi+84], ebx
	mov	DWORD PTR [esi+88], ebx
	mov	DWORD PTR [esi+92], ebx
	mov	DWORD PTR [esi+96], ebx
	mov	DWORD PTR [esi+100], ebx
	mov	DWORD PTR [esi+104], ebx
	mov	DWORD PTR [esi+900], ebx
	mov	DWORD PTR [esi+904], ebx
	mov	DWORD PTR [esi+908], ebx
	push	ebx
	lea	ecx, DWORD PTR [esi+916]
	mov	DWORD PTR __$EHRec$[esp+48], ebx
	mov	DWORD PTR [esi+912], ebx
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z
	lea	eax, DWORD PTR $T302093[esp+36]
	push	eax
	lea	edx, DWORD PTR $T302094[esp+40]
	lea	ecx, DWORD PTR [esi+980]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+52], 1
	call	??0?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QAE@ABV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@Z ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
	lea	edi, DWORD PTR [esi+1024]
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+44], 2
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR [edi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [esi+1040], ebx
	mov	DWORD PTR [esi+1044], ebx
	mov	DWORD PTR [esi+1048], ebx
	mov	DWORD PTR [esi+1056], ebx
	mov	DWORD PTR [esi+1060], ebx
	mov	DWORD PTR [esi+1064], ebx
	mov	DWORD PTR [esi+1072], ebx
	mov	DWORD PTR [esi+1076], ebx
	mov	DWORD PTR [esi+1080], ebx
	mov	DWORD PTR [esi+1088], ebx
	mov	DWORD PTR [esi+1092], ebx
	mov	DWORD PTR [esi+1096], ebx
	mov	DWORD PTR [esi+1104], ebx
	mov	DWORD PTR [esi+1108], ebx
	mov	DWORD PTR [esi+1112], ebx
	mov	DWORD PTR [esi+1120], ebx
	mov	DWORD PTR [esi+1124], ebx
	mov	DWORD PTR [esi+1128], ebx
	mov	DWORD PTR [esi+1136], ebx
	mov	DWORD PTR [esi+1140], ebx
	mov	DWORD PTR [esi+1144], ebx
	mov	DWORD PTR [esi+1152], ebx
	mov	DWORD PTR [esi+1156], ebx
	mov	DWORD PTR [esi+1160], ebx
	mov	DWORD PTR [esi+1168], ebx
	mov	DWORD PTR [esi+1172], ebx
	mov	DWORD PTR [esi+1176], ebx
	mov	DWORD PTR [esi+1184], ebx
	mov	DWORD PTR [esi+1188], ebx
	mov	DWORD PTR [esi+1192], ebx
	mov	DWORD PTR [esi+1200], ebx
	mov	DWORD PTR [esi+1204], ebx
	mov	DWORD PTR [esi+1208], ebx
	mov	DWORD PTR [esi+1216], ebx
	mov	DWORD PTR [esi+1220], ebx
	mov	DWORD PTR [esi+1224], ebx
	mov	DWORD PTR [esi+1232], ebx
	mov	DWORD PTR [esi+1236], ebx
	mov	DWORD PTR [esi+1240], ebx
	mov	DWORD PTR [esi+1256], ebx
	mov	DWORD PTR [esi+1260], ebx
	mov	DWORD PTR [esi+1264], ebx
	mov	DWORD PTR [esi+1272], ebx
	mov	DWORD PTR [esi+1276], ebx
	mov	DWORD PTR [esi+1280], ebx
	mov	DWORD PTR [esi+1288], ebx
	mov	DWORD PTR [esi+1292], ebx
	mov	DWORD PTR [esi+1296], ebx
	mov	DWORD PTR [esi+1304], ebx
	mov	DWORD PTR [esi+1308], ebx
	mov	DWORD PTR [esi+1312], ebx
	mov	DWORD PTR [esi+1320], ebx
	mov	DWORD PTR [esi+1324], ebx
	mov	DWORD PTR [esi+1328], ebx
	mov	DWORD PTR [esi+1336], ebx
	mov	DWORD PTR [esi+1340], ebx
	mov	DWORD PTR [esi+1344], ebx
	mov	DWORD PTR [esi+1352], ebx
	mov	DWORD PTR [esi+1356], ebx
	mov	DWORD PTR [esi+1360], ebx
	mov	DWORD PTR [esi+1368], ebx
	mov	DWORD PTR [esi+1372], ebx
	mov	DWORD PTR [esi+1376], ebx
	mov	DWORD PTR [esi+1384], ebx
	mov	DWORD PTR [esi+1388], ebx
	mov	DWORD PTR [esi+1392], ebx
	mov	DWORD PTR [esi+1400], ebx
	mov	DWORD PTR [esi+1404], ebx
	mov	DWORD PTR [esi+1408], ebx
	mov	DWORD PTR [esi+1416], ebx
	mov	DWORD PTR [esi+1420], ebx
	mov	DWORD PTR [esi+1424], ebx
	mov	DWORD PTR [esi+1432], ebx
	mov	DWORD PTR [esi+1436], ebx
	mov	DWORD PTR [esi+1440], ebx
	mov	DWORD PTR [esi+1448], ebx
	mov	DWORD PTR [esi+1452], ebx
	mov	DWORD PTR [esi+1456], ebx
	mov	DWORD PTR [esi+1464], ebx
	mov	DWORD PTR [esi+1468], ebx
	mov	DWORD PTR [esi+1472], ebx
	mov	DWORD PTR [esi+1480], ebx
	mov	DWORD PTR [esi+1484], ebx
	mov	DWORD PTR [esi+1488], ebx
	mov	DWORD PTR [esi+1496], ebx
	mov	DWORD PTR [esi+1500], ebx
	mov	DWORD PTR [esi+1504], ebx
	mov	DWORD PTR [esi+1512], ebx
	mov	DWORD PTR [esi+1516], ebx
	mov	DWORD PTR [esi+1520], ebx
	mov	DWORD PTR [esi+1528], ebx
	mov	DWORD PTR [esi+1532], ebx
	mov	DWORD PTR [esi+1536], ebx
	mov	DWORD PTR [esi+1544], ebx
	mov	DWORD PTR [esi+1548], ebx
	mov	DWORD PTR [esi+1552], ebx
	mov	DWORD PTR [esi+1560], ebx
	mov	DWORD PTR [esi+1564], ebx
	mov	DWORD PTR [esi+1568], ebx
	mov	DWORD PTR [esi+1576], ebx
	mov	DWORD PTR [esi+1580], ebx
	mov	DWORD PTR [esi+1584], ebx
	mov	DWORD PTR [esi+1592], ebx
	mov	DWORD PTR [esi+1596], ebx
	mov	DWORD PTR [esi+1600], ebx
	mov	DWORD PTR [esi+1608], ebx
	mov	DWORD PTR [esi+1612], ebx
	mov	DWORD PTR [esi+1616], ebx
	mov	DWORD PTR [esi+1624], ebx
	mov	DWORD PTR [esi+1628], ebx
	mov	DWORD PTR [esi+1632], ebx
	mov	DWORD PTR [esi+1640], ebx
	mov	DWORD PTR [esi+1644], ebx
	mov	DWORD PTR [esi+1648], ebx
	mov	DWORD PTR [esi+1656], ebx
	mov	DWORD PTR [esi+1660], ebx
	mov	DWORD PTR [esi+1664], ebx
	mov	DWORD PTR [esi+1668], ebx
	mov	DWORD PTR [esi+1672], ebx
	mov	DWORD PTR [esi+1676], ebx
	mov	DWORD PTR [esi+1680], ebx
	mov	DWORD PTR [esi+1684], ebx
	mov	DWORD PTR [esi+1692], ebx
	mov	DWORD PTR [esi+1696], ebx
	mov	DWORD PTR [esi+1700], ebx
	mov	DWORD PTR [esi+1720], ebx
	mov	DWORD PTR [esi+1724], ebx
	mov	DWORD PTR [esi+1728], ebx
	mov	DWORD PTR [esi+1732], ebx
	mov	DWORD PTR [esi+1736], ebx
	mov	DWORD PTR [esi+1740], ebx
	mov	DWORD PTR [esi+1744], ebx
	mov	DWORD PTR [esi+1748], ebx
	mov	DWORD PTR [esi+1752], ebx
	mov	DWORD PTR [esi+1776], ebx
	mov	DWORD PTR [esi+1780], ebx
	mov	DWORD PTR [esi+1784], ebx
	mov	DWORD PTR [esi+1788], ebx
	mov	DWORD PTR [esi+1792], ebx
	mov	DWORD PTR [esi+1796], ebx
	mov	DWORD PTR [esi+1800], ebx
	mov	DWORD PTR [esi+1804], ebx
	mov	DWORD PTR [esi+1812], ebx
	mov	DWORD PTR [esi+1820], ebx
	mov	DWORD PTR [esi+1832], 75		; 0000004bH
	mov	DWORD PTR [esi+1852], 7
	mov	DWORD PTR [esi+1872], ebx
	mov	DWORD PTR [esi+1876], -1000		; fffffc18H
	mov	DWORD PTR [esi+1880], 1000		; 000003e8H
	mov	DWORD PTR [esi+1892], ebx
	mov	DWORD PTR [esi+1908], 120		; 00000078H
	mov	DWORD PTR [esi+1912], 70		; 00000046H
	mov	DWORD PTR [esi+1924], -50		; ffffffceH
	mov	DWORD PTR [esi+1932], 60		; 0000003cH
	mov	eax, 15					; 0000000fH
	mov	DWORD PTR [esi+1808], eax
	mov	DWORD PTR [esi+1856], eax
	mov	ebp, 5
	mov	DWORD PTR [esi+1844], ebp
	mov	DWORD PTR [esi+1864], ebp
	mov	eax, 8
	mov	DWORD PTR [esi+1860], eax
	mov	DWORD PTR [esi+1888], eax
	mov	ecx, 50					; 00000032H
	mov	DWORD PTR [esi+1824], ecx
	mov	DWORD PTR [esi+1836], ecx
	mov	DWORD PTR [esi+1848], ecx
	mov	DWORD PTR [esi+1896], ecx
	mov	DWORD PTR [esi+1900], ecx
	mov	ebp, 20					; 00000014H
	mov	DWORD PTR [esi+1868], ebp
	mov	DWORD PTR [esi+1920], ebp
	mov	eax, 40					; 00000028H
	mov	DWORD PTR [esi+1904], eax
	mov	DWORD PTR [esi+1916], eax
	mov	eax, 10					; 0000000aH
	mov	DWORD PTR [esi+1928], eax
	mov	edi, 2
	mov	DWORD PTR [esi+1828], edi
	mov	DWORD PTR [esi+1840], edi
	mov	DWORD PTR [esi+1884], edi
	mov	ebp, 100				; 00000064H
	mov	DWORD PTR [esi+1936], ebp
	mov	edx, 1
	mov	DWORD PTR [esi+1816], edx
	mov	DWORD PTR [esi+1940], 20		; 00000014H
	mov	DWORD PTR [esi+1944], 5
	mov	DWORD PTR [esi+1948], eax
	mov	DWORD PTR [esi+1952], eax
	mov	DWORD PTR [esi+1956], 15		; 0000000fH
	mov	DWORD PTR [esi+1960], 75		; 0000004bH
	mov	DWORD PTR [esi+1964], 75		; 0000004bH
	mov	DWORD PTR [esi+1968], ecx
	mov	DWORD PTR [esi+1972], ebp
	mov	DWORD PTR [esi+1976], ecx
	mov	DWORD PTR [esi+1980], -40		; ffffffd8H
	mov	DWORD PTR [esi+1984], 300		; 0000012cH
	mov	DWORD PTR [esi+1988], 150		; 00000096H
	mov	DWORD PTR [esi+1992], 300		; 0000012cH
	mov	DWORD PTR [esi+1996], ebp
	mov	DWORD PTR [esi+2000], edx
	mov	DWORD PTR [esi+2004], eax
	mov	DWORD PTR [esi+2008], 25		; 00000019H
	mov	DWORD PTR [esi+2012], eax
	mov	DWORD PTR [esi+2016], 1051595899	; 3eae147bH
	mov	DWORD PTR [esi+2020], 80		; 00000050H
	mov	DWORD PTR [esi+2024], 75		; 0000004bH
	mov	DWORD PTR [esi+2028], 20000		; 00004e20H
	mov	DWORD PTR [esi+2032], 5
	mov	DWORD PTR [esi+2036], 40		; 00000028H
	mov	DWORD PTR [esi+2040], ecx
	mov	DWORD PTR [esi+2044], 20		; 00000014H
	mov	DWORD PTR [esi+2048], eax
	mov	DWORD PTR [esi+2052], 5
	mov	DWORD PTR [esi+2056], 6
	mov	DWORD PTR [esi+2060], 4
	mov	DWORD PTR [esi+2064], edi
	mov	DWORD PTR [esi+2068], 150		; 00000096H
	mov	DWORD PTR [esi+2072], 1000		; 000003e8H
	mov	DWORD PTR [esi+2076], 150		; 00000096H
	mov	DWORD PTR [esi+2080], 25		; 00000019H
	mov	DWORD PTR [esi+2084], 150		; 00000096H
	mov	DWORD PTR [esi+2088], 25		; 00000019H
	mov	DWORD PTR [esi+2092], 300		; 0000012cH
	mov	DWORD PTR [esi+2096], 400		; 00000190H
	mov	DWORD PTR [esi+2100], ebp
	mov	DWORD PTR [esi+2104], edi
	mov	DWORD PTR [esi+2108], edi
	mov	DWORD PTR [esi+2112], edx
	mov	DWORD PTR [esi+2116], edx
	mov	DWORD PTR [esi+2120], edx
	mov	DWORD PTR [esi+2124], 50000		; 0000c350H
	mov	DWORD PTR [esi+2128], 15		; 0000000fH
	mov	DWORD PTR [esi+2132], ebp
	mov	DWORD PTR [esi+2136], edx
	mov	DWORD PTR [esi+2140], edx
	mov	DWORD PTR [esi+2144], ebp
	mov	DWORD PTR [esi+2148], eax
	mov	DWORD PTR [esi+2152], eax
	mov	DWORD PTR [esi+2156], 1000		; 000003e8H
	mov	DWORD PTR [esi+2164], edx
	mov	DWORD PTR [esi+2168], 3
	mov	DWORD PTR [esi+2172], 6
	mov	DWORD PTR [esi+2176], eax
	mov	DWORD PTR [esi+2180], edi
	mov	DWORD PTR [esi+2184], 33		; 00000021H
	mov	DWORD PTR [esi+2188], 125		; 0000007dH
	mov	DWORD PTR [esi+2192], edi
	mov	DWORD PTR [esi+2196], ebx
	mov	DWORD PTR [esi+2200], 150		; 00000096H
	mov	DWORD PTR [esi+2204], 150		; 00000096H
	mov	DWORD PTR [esi+2208], 25		; 00000019H
	mov	DWORD PTR [esi+2212], 10000		; 00002710H
	mov	DWORD PTR [esi+2216], 200		; 000000c8H
	mov	DWORD PTR [esi+2220], 5
	mov	DWORD PTR [esi+2224], 5
	mov	DWORD PTR [esi+2228], -50		; ffffffceH
	mov	DWORD PTR [esi+2232], -40		; ffffffd8H
	mov	DWORD PTR [esi+2236], 500		; 000001f4H
	mov	DWORD PTR [esi+2240], eax
	mov	DWORD PTR [esi+2244], ebp
	mov	DWORD PTR [esi+2248], 300		; 0000012cH
	mov	DWORD PTR [esi+2252], 300		; 0000012cH
	mov	DWORD PTR [esi+2256], 1000		; 000003e8H
	mov	DWORD PTR [esi+2260], ecx
	mov	DWORD PTR [esi+2264], ecx
	mov	DWORD PTR [esi+2268], 250		; 000000faH
	mov	DWORD PTR [esi+2272], 200		; 000000c8H
	mov	DWORD PTR [esi+2276], 5
	mov	DWORD PTR [esi+2280], eax
	mov	DWORD PTR [esi+2284], eax
	mov	DWORD PTR [esi+2288], 20		; 00000014H
	mov	DWORD PTR [esi+2292], eax
	mov	DWORD PTR [esi+2296], 20		; 00000014H
	mov	DWORD PTR [esi+2300], eax
	mov	DWORD PTR [esi+2304], 8
	mov	DWORD PTR [esi+2308], 5
	mov	DWORD PTR [esi+2312], edi
	mov	DWORD PTR [esi+2316], 18		; 00000012H
	mov	DWORD PTR [esi+2320], edi
	mov	DWORD PTR [esi+2324], 8
	mov	DWORD PTR [esi+2328], 15		; 0000000fH
	mov	DWORD PTR [esi+2332], edi
	mov	DWORD PTR [esi+2336], 200		; 000000c8H
	mov	DWORD PTR [esi+2340], 30		; 0000001eH
	mov	DWORD PTR [esi+2344], edi
	mov	DWORD PTR [esi+2348], 1073741824	; 40000000H
	mov	DWORD PTR [esi+2352], 1061997773	; 3f4ccccdH
	mov	DWORD PTR [esi+2356], ebx
	mov	DWORD PTR [esi+2360], ebx
	mov	DWORD PTR [esi+2364], 900		; 00000384H
	mov	DWORD PTR [esi+2368], ebp
	mov	DWORD PTR [esi+2372], 700		; 000002bcH
	mov	DWORD PTR [esi+2376], 12		; 0000000cH
	mov	DWORD PTR [esi+2380], 8
	mov	DWORD PTR [esi+2384], 6
	mov	DWORD PTR [esi+2388], 6
	mov	DWORD PTR [esi+2392], 8
	mov	DWORD PTR [esi+2396], 6
	mov	DWORD PTR [esi+2400], 6
	mov	DWORD PTR [esi+2404], 5
	mov	DWORD PTR [esi+2408], 300		; 0000012cH
	mov	DWORD PTR [esi+2412], 250		; 000000faH
	mov	DWORD PTR [esi+2416], edi
	mov	DWORD PTR [esi+2420], 5
	mov	DWORD PTR [esi+2424], 4
	mov	DWORD PTR [esi+2428], edx
	mov	DWORD PTR [esi+2432], 20		; 00000014H
	mov	DWORD PTR [esi+2436], 80		; 00000050H
	mov	DWORD PTR [esi+2440], eax
	mov	DWORD PTR [esi+2444], 25		; 00000019H
	mov	DWORD PTR [esi+2448], 5
	mov	DWORD PTR [esi+2452], 4
	mov	DWORD PTR [esi+2456], edx
	mov	DWORD PTR [esi+2460], eax
	mov	DWORD PTR [esi+2464], eax
	mov	DWORD PTR [esi+2468], ecx
	mov	DWORD PTR [esi+2472], 15		; 0000000fH
	mov	DWORD PTR [esi+2476], 6
	mov	DWORD PTR [esi+2480], 9
	mov	DWORD PTR [esi+2484], 5
	mov	DWORD PTR [esi+2488], 16		; 00000010H
	mov	DWORD PTR [esi+2492], 15		; 0000000fH
	mov	DWORD PTR [esi+2496], 14		; 0000000eH
	mov	DWORD PTR [esi+2500], 12		; 0000000cH
	mov	DWORD PTR [esi+2504], eax
	mov	DWORD PTR [esi+2508], 7
	mov	DWORD PTR [esi+2512], 6
	mov	DWORD PTR [esi+2516], ebx
	mov	DWORD PTR [esi+2520], 8
	mov	DWORD PTR [esi+2524], 14		; 0000000eH
	mov	DWORD PTR [esi+2528], 6
	mov	DWORD PTR [esi+2532], eax
	mov	DWORD PTR [esi+2536], 13		; 0000000dH
	mov	DWORD PTR [esi+2540], -1
	mov	DWORD PTR [esi+2544], 3
	mov	DWORD PTR [esi+2548], 13		; 0000000dH
	mov	DWORD PTR [esi+2552], 30		; 0000001eH
	mov	DWORD PTR [esi+2556], 11		; 0000000bH
	mov	DWORD PTR [esi+2560], eax
	mov	DWORD PTR [esi+2564], 5
	mov	DWORD PTR [esi+2568], 4
	mov	DWORD PTR [esi+2572], eax
	mov	DWORD PTR [esi+2576], ecx
	mov	DWORD PTR [esi+2580], 30		; 0000001eH
	mov	DWORD PTR [esi+2584], 30		; 0000001eH
	mov	DWORD PTR [esi+2588], 30		; 0000001eH
	mov	DWORD PTR [esi+2592], 30		; 0000001eH
	mov	DWORD PTR [esi+2596], 35		; 00000023H
	mov	DWORD PTR [esi+2600], 35		; 00000023H
	mov	DWORD PTR [esi+2604], 20		; 00000014H
	mov	DWORD PTR [esi+2608], 15		; 0000000fH
	mov	DWORD PTR [esi+2612], eax
	mov	DWORD PTR [esi+2616], ebx
	mov	DWORD PTR [esi+2620], 25		; 00000019H
	mov	DWORD PTR [esi+2624], 40		; 00000028H
	mov	DWORD PTR [esi+2628], 40		; 00000028H
	mov	DWORD PTR [esi+2632], ecx
	mov	DWORD PTR [esi+2636], ecx
	mov	DWORD PTR [esi+2640], ecx
	mov	DWORD PTR [esi+2644], ecx
	mov	DWORD PTR [esi+2648], ecx
	mov	DWORD PTR [esi+2652], ecx
	mov	DWORD PTR [esi+2656], ecx
	mov	DWORD PTR [esi+2660], ecx
	mov	DWORD PTR [esi+2664], 40		; 00000028H
	mov	DWORD PTR [esi+2668], 40		; 00000028H
	mov	DWORD PTR [esi+2672], 20		; 00000014H
	mov	DWORD PTR [esi+2676], 200		; 000000c8H
	mov	DWORD PTR [esi+2680], ecx
	mov	DWORD PTR [esi+2684], ebp
	mov	DWORD PTR [esi+2688], ebp
	mov	DWORD PTR [esi+2692], ebp
	mov	DWORD PTR [esi+2696], 24		; 00000018H
	mov	DWORD PTR [esi+2700], eax
	mov	DWORD PTR [esi+2704], 5
	mov	DWORD PTR [esi+2708], edx
	mov	DWORD PTR [esi+2712], 3
	mov	DWORD PTR [esi+2716], 5
	mov	DWORD PTR [esi+2720], ebp
	mov	DWORD PTR [esi+2724], 150		; 00000096H
	mov	DWORD PTR [esi+2728], ecx
	mov	DWORD PTR [esi+2732], -100		; ffffff9cH
	mov	DWORD PTR [esi+2736], -150		; ffffff6aH
	mov	DWORD PTR [esi+2740], -200		; ffffff38H
	mov	DWORD PTR [esi+2744], -2000		; fffff830H
	mov	DWORD PTR [esi+2748], -1500		; fffffa24H
	mov	DWORD PTR [esi+2752], ebx
	mov	DWORD PTR [esi+2756], -5000		; ffffec78H
	mov	DWORD PTR [esi+2760], ebx
	mov	DWORD PTR [esi+2764], ebp
	mov	DWORD PTR [esi+2768], -60		; ffffffc4H
	mov	DWORD PTR [esi+2772], edi
	mov	DWORD PTR [esi+2776], 4
	mov	DWORD PTR [esi+2780], ecx
	mov	DWORD PTR [esi+2784], 25		; 00000019H
	mov	DWORD PTR [esi+2788], ecx
	mov	DWORD PTR [esi+2792], 75		; 0000004bH
	mov	DWORD PTR [esi+2796], ebp
	mov	DWORD PTR [esi+2800], ebx
	mov	DWORD PTR [esi+2804], ebx
	mov	DWORD PTR [esi+2808], 20		; 00000014H
	mov	DWORD PTR [esi+2812], ecx
	mov	DWORD PTR [esi+2816], ecx
	mov	DWORD PTR [esi+2820], ebx
	mov	DWORD PTR [esi+2824], ebx
	mov	DWORD PTR [esi+2828], ebx
	mov	DWORD PTR [esi+2832], 30		; 0000001eH
	mov	DWORD PTR [esi+2836], ebx
	mov	DWORD PTR [esi+2840], 60		; 0000003cH
	mov	DWORD PTR [esi+2844], 120		; 00000078H
	mov	DWORD PTR [esi+2848], -30		; ffffffe2H
	mov	DWORD PTR [esi+2852], ebx
	mov	DWORD PTR [esi+2856], 8
	mov	DWORD PTR [esi+2860], 25		; 00000019H
	mov	DWORD PTR [esi+2864], 4
	mov	DWORD PTR [esi+2868], 6
	mov	DWORD PTR [esi+2872], eax
	mov	DWORD PTR [esi+2876], 4
	mov	DWORD PTR [esi+2880], 6
	mov	DWORD PTR [esi+2884], eax
	mov	DWORD PTR [esi+2888], edx
	mov	DWORD PTR [esi+2892], edx
	mov	DWORD PTR [esi+2896], edx
	mov	DWORD PTR [esi+2900], edi
	mov	DWORD PTR [esi+2904], edx
	mov	DWORD PTR [esi+2908], edx
	mov	DWORD PTR [esi+2912], 15		; 0000000fH
	mov	DWORD PTR [esi+2916], 3
	mov	DWORD PTR [esi+2920], -3		; fffffffdH
	mov	DWORD PTR [esi+2924], 67		; 00000043H
	mov	DWORD PTR [esi+2928], 3
	mov	DWORD PTR [esi+2932], edi
	mov	DWORD PTR [esi+2936], 3
	mov	DWORD PTR [esi+2940], 4
	mov	DWORD PTR [esi+2944], edi
	mov	DWORD PTR [esi+2948], edi
	mov	DWORD PTR [esi+2952], edi
	mov	DWORD PTR [esi+2956], edx
	mov	DWORD PTR [esi+2960], edx
	mov	DWORD PTR [esi+2964], edx
	mov	DWORD PTR [esi+2968], edx
	mov	DWORD PTR [esi+2972], edx
	mov	DWORD PTR [esi+2976], edx
	mov	DWORD PTR [esi+2980], 13		; 0000000dH
	mov	DWORD PTR [esi+2984], 12		; 0000000cH
	mov	DWORD PTR [esi+2988], eax
	mov	DWORD PTR [esi+2992], 7
	mov	DWORD PTR [esi+2996], edi
	mov	DWORD PTR [esi+3000], 13		; 0000000dH
	mov	DWORD PTR [esi+3004], 12		; 0000000cH
	mov	DWORD PTR [esi+3008], eax
	mov	DWORD PTR [esi+3012], 7
	mov	DWORD PTR [esi+3016], edi
	mov	DWORD PTR [esi+3020], 37		; 00000025H
	mov	DWORD PTR [esi+3024], 7
	mov	DWORD PTR [esi+3028], ecx
	mov	DWORD PTR [esi+3032], -1
	mov	DWORD PTR [esi+3036], -10		; fffffff6H
	mov	DWORD PTR [esi+3040], ecx
	mov	DWORD PTR [esi+3044], edi
	mov	DWORD PTR [esi+3048], ebp
	mov	DWORD PTR [esi+3052], 4
	mov	DWORD PTR [esi+3056], 3
	mov	DWORD PTR [esi+3060], ecx
	mov	DWORD PTR [esi+3064], ecx
	mov	DWORD PTR [esi+3068], 40		; 00000028H
	mov	DWORD PTR [esi+3072], 40		; 00000028H
	mov	DWORD PTR [esi+3076], 40		; 00000028H
	mov	DWORD PTR [esi+3080], 80		; 00000050H
	mov	DWORD PTR [esi+3084], 35		; 00000023H
	mov	DWORD PTR [esi+3088], 40		; 00000028H
	mov	DWORD PTR [esi+3092], eax
	mov	DWORD PTR [esi+3096], 20		; 00000014H
	mov	DWORD PTR [esi+3100], 40		; 00000028H
	mov	DWORD PTR [esi+3104], 40		; 00000028H
	mov	DWORD PTR [esi+3108], 40		; 00000028H
	mov	DWORD PTR [esi+3112], ebx
	mov	DWORD PTR [esi+3116], 40		; 00000028H
	mov	DWORD PTR [esi+3120], 40		; 00000028H
	mov	DWORD PTR [esi+3124], 40		; 00000028H
	mov	DWORD PTR [esi+3128], 40		; 00000028H
	mov	DWORD PTR [esi+3132], 30		; 0000001eH
	mov	DWORD PTR [esi+3136], edi
	mov	DWORD PTR [esi+3140], 3
	mov	DWORD PTR [esi+3144], 5
	mov	DWORD PTR [esi+3148], 5
	mov	DWORD PTR [esi+3152], edi
	mov	DWORD PTR [esi+3156], 5
	mov	DWORD PTR [esi+3160], -6		; fffffffaH
	mov	DWORD PTR [esi+3164], 5
	mov	DWORD PTR [esi+3168], edi
	mov	DWORD PTR [esi+3172], 3
	mov	DWORD PTR [esi+3176], 150		; 00000096H
	mov	DWORD PTR [esi+3180], 30		; 0000001eH
	mov	DWORD PTR [esi+3184], edx
	mov	DWORD PTR [esi+3188], edi
	mov	DWORD PTR [esi+3192], 30		; 0000001eH
	mov	DWORD PTR [esi+3196], 20		; 00000014H
	mov	DWORD PTR [esi+3200], eax
	mov	DWORD PTR [esi+3204], 25		; 00000019H
	mov	DWORD PTR [esi+3208], 200		; 000000c8H
	mov	DWORD PTR [esi+3212], 30		; 0000001eH
	mov	DWORD PTR [esi+3216], 20		; 00000014H
	mov	DWORD PTR [esi+3220], eax
	mov	DWORD PTR [esi+3224], 25		; 00000019H
	mov	DWORD PTR [esi+3228], 200		; 000000c8H
	mov	DWORD PTR [esi+3232], 8
	mov	DWORD PTR [esi+3236], 25		; 00000019H
	mov	DWORD PTR [esi+3240], edi
	mov	DWORD PTR [esi+3244], edx
	mov	DWORD PTR [esi+3248], ebx
	mov	DWORD PTR [esi+3252], ebx
	mov	DWORD PTR [esi+3256], ebx
	mov	DWORD PTR [esi+3260], ebx
	mov	DWORD PTR [esi+3264], ebx
	mov	DWORD PTR [esi+3268], ebx
	mov	DWORD PTR [esi+3272], ebx
	mov	DWORD PTR [esi+3276], ebx
	mov	DWORD PTR [esi+3280], ebx
	mov	DWORD PTR [esi+3284], ebx
	mov	DWORD PTR [esi+3288], ebx
	mov	DWORD PTR [esi+3292], ebx
	mov	DWORD PTR [esi+3296], ebx
	mov	DWORD PTR [esi+3300], ebx
	mov	DWORD PTR [esi+3304], ebx
	mov	DWORD PTR [esi+3308], ebx
	mov	DWORD PTR [esi+3312], ebx
	mov	DWORD PTR [esi+3316], ebx
	mov	DWORD PTR [esi+3320], ebx
	mov	DWORD PTR [esi+3324], eax
	mov	DWORD PTR [esi+3328], 200		; 000000c8H
	mov	DWORD PTR [esi+3332], 20		; 00000014H
	mov	DWORD PTR [esi+3336], 120		; 00000078H
	mov	DWORD PTR [esi+3340], 150		; 00000096H
	mov	DWORD PTR [esi+3344], 300		; 0000012cH
	mov	DWORD PTR [esi+3348], 200		; 000000c8H
	mov	DWORD PTR [esi+3352], 300		; 0000012cH
	mov	DWORD PTR [esi+3356], 300		; 0000012cH
	mov	DWORD PTR [esi+3360], 300		; 0000012cH
	mov	DWORD PTR [esi+3364], 200		; 000000c8H
	mov	DWORD PTR [esi+3368], 200		; 000000c8H
	mov	DWORD PTR [esi+3372], 40		; 00000028H
	mov	DWORD PTR [esi+3376], 300		; 0000012cH
	mov	DWORD PTR [esi+3380], 200		; 000000c8H
	mov	DWORD PTR [esi+3384], ecx
	mov	DWORD PTR [esi+3388], 30		; 0000001eH
	mov	DWORD PTR [esi+3392], 200		; 000000c8H
	mov	DWORD PTR [esi+3396], 350		; 0000015eH
	mov	DWORD PTR [esi+3400], 300		; 0000012cH
	mov	DWORD PTR [esi+3404], 200		; 000000c8H
	mov	DWORD PTR [esi+3408], 350		; 0000015eH
	mov	DWORD PTR [esi+3412], 300		; 0000012cH
	mov	DWORD PTR [esi+3416], eax
	mov	DWORD PTR [esi+3420], 8
	mov	DWORD PTR [esi+3424], 5
	mov	DWORD PTR [esi+3428], 3
	mov	DWORD PTR [esi+3432], eax
	mov	DWORD PTR [esi+3436], 4
	mov	DWORD PTR [esi+3440], ebp
	mov	DWORD PTR [esi+3444], 4
	mov	DWORD PTR [esi+3448], 5
	mov	DWORD PTR [esi+3452], 30		; 0000001eH
	mov	DWORD PTR [esi+3456], 15		; 0000000fH
	mov	DWORD PTR [esi+3460], ebp
	mov	DWORD PTR [esi+3464], ebp
	mov	DWORD PTR [esi+3468], ebp
	mov	DWORD PTR [esi+3472], ebp
	mov	DWORD PTR [esi+3476], -50		; ffffffceH
	mov	DWORD PTR [esi+3480], 80		; 00000050H
	mov	DWORD PTR [esi+3484], 101		; 00000065H
	mov	DWORD PTR [esi+3488], eax
	mov	DWORD PTR [esi+3492], -20		; ffffffecH
	mov	DWORD PTR [esi+3496], 5
	mov	DWORD PTR [esi+3500], 4
	mov	DWORD PTR [esi+3504], 3
	mov	DWORD PTR [esi+3508], 150		; 00000096H
	mov	DWORD PTR [esi+3512], 125		; 0000007dH
	mov	DWORD PTR [esi+3516], 30		; 0000001eH
	mov	DWORD PTR [esi+3520], 20		; 00000014H
	mov	DWORD PTR [esi+3524], eax
	mov	DWORD PTR [esi+3528], -6		; fffffffaH
	mov	DWORD PTR [esi+3532], 30		; 0000001eH
	mov	DWORD PTR [esi+3536], 20		; 00000014H
	mov	DWORD PTR [esi+3540], eax
	mov	DWORD PTR [esi+3544], -6		; fffffffaH
	mov	DWORD PTR [esi+3548], 20		; 00000014H
	mov	DWORD PTR [esi+3552], 15		; 0000000fH
	mov	DWORD PTR [esi+3556], eax
	mov	DWORD PTR [esi+3560], ebx
	mov	DWORD PTR [esi+3564], 30		; 0000001eH
	mov	DWORD PTR [esi+3568], 20		; 00000014H
	mov	DWORD PTR [esi+3572], eax
	mov	DWORD PTR [esi+3576], ebx
	mov	DWORD PTR [esi+3580], ebp
	mov	DWORD PTR [esi+3584], 70		; 00000046H
	mov	DWORD PTR [esi+3588], 40		; 00000028H
	mov	DWORD PTR [esi+3592], 15		; 0000000fH
	mov	DWORD PTR [esi+3596], ebx
	mov	DWORD PTR [esi+3600], 20		; 00000014H
	mov	DWORD PTR [esi+3604], 20		; 00000014H
	mov	DWORD PTR [esi+3608], 20		; 00000014H
	mov	DWORD PTR [esi+3612], -20		; ffffffecH
	mov	DWORD PTR [esi+3616], -20		; ffffffecH
	mov	DWORD PTR [esi+3620], -200		; ffffff38H
	mov	DWORD PTR [esi+3624], -30		; ffffffe2H
	mov	DWORD PTR [esi+3628], -50		; ffffffceH
	mov	DWORD PTR [esi+3632], -60		; ffffffc4H
	mov	DWORD PTR [esi+3636], -1
	mov	DWORD PTR [esi+3640], 30		; 0000001eH
	mov	DWORD PTR [esi+3644], edi
	mov	DWORD PTR [esi+3648], -10		; fffffff6H
	mov	DWORD PTR [esi+3652], -6		; fffffffaH
	mov	DWORD PTR [esi+3656], -10		; fffffff6H
	mov	DWORD PTR [esi+3660], eax
	mov	DWORD PTR [esi+3664], 40		; 00000028H
	mov	DWORD PTR [esi+3668], 15		; 0000000fH
	mov	DWORD PTR [esi+3672], 15		; 0000000fH
	mov	DWORD PTR [esi+3676], 20		; 00000014H
	mov	DWORD PTR [esi+3680], 15		; 0000000fH
	mov	DWORD PTR [esi+3684], 20		; 00000014H
	mov	DWORD PTR [esi+3688], 15		; 0000000fH
	mov	DWORD PTR [esi+3692], 40		; 00000028H
	mov	DWORD PTR [esi+3696], 15		; 0000000fH
	mov	DWORD PTR [esi+3700], 15		; 0000000fH
	mov	DWORD PTR [esi+3704], 20		; 00000014H
	mov	DWORD PTR [esi+3708], eax
	mov	DWORD PTR [esi+3712], -10		; fffffff6H
	mov	DWORD PTR [esi+3716], 8
	mov	DWORD PTR [esi+3720], 4
	mov	DWORD PTR [esi+3724], 30		; 0000001eH
	mov	DWORD PTR [esi+3728], 20		; 00000014H
	mov	DWORD PTR [esi+3732], 20		; 00000014H
	mov	DWORD PTR [esi+3736], 125		; 0000007dH
	mov	DWORD PTR [esi+3740], 40		; 00000028H
	mov	DWORD PTR [esi+3744], eax
	mov	DWORD PTR [esi+3748], 75		; 0000004bH
	mov	DWORD PTR [esi+3752], ecx
	mov	DWORD PTR [esi+3756], 20		; 00000014H
	mov	DWORD PTR [esi+3760], 15		; 0000000fH
	mov	DWORD PTR [esi+3764], 15		; 0000000fH
	mov	DWORD PTR [esi+3768], 75		; 0000004bH
	mov	DWORD PTR [esi+3772], ecx
	mov	DWORD PTR [esi+3776], 15		; 0000000fH
	mov	DWORD PTR [esi+3780], eax
	mov	DWORD PTR [esi+3784], eax
	mov	DWORD PTR [esi+3788], 25		; 00000019H
	mov	DWORD PTR [esi+3792], 5
	mov	DWORD PTR [esi+3796], -35		; ffffffddH
	mov	DWORD PTR [esi+3800], -15		; fffffff1H
	mov	DWORD PTR [esi+3804], 15		; 0000000fH
	mov	DWORD PTR [esi+3808], 25		; 00000019H
	mov	DWORD PTR [esi+3812], -10		; fffffff6H
	mov	DWORD PTR [esi+3816], 15		; 0000000fH
	mov	DWORD PTR [esi+3820], 35		; 00000023H
	mov	DWORD PTR [esi+3824], 40		; 00000028H
	mov	DWORD PTR [esi+3828], 60		; 0000003cH
	mov	DWORD PTR [esi+3832], 15		; 0000000fH
	mov	DWORD PTR [esi+3836], 35		; 00000023H
	mov	DWORD PTR [esi+3840], 35		; 00000023H
	mov	DWORD PTR [esi+3844], 15		; 0000000fH
	mov	DWORD PTR [esi+3848], -15		; fffffff1H
	mov	DWORD PTR [esi+3852], 35		; 00000023H
	mov	DWORD PTR [esi+3900], -15		; fffffff1H
	mov	DWORD PTR [esi+3904], 45		; 0000002dH
	mov	DWORD PTR [esi+3908], 15		; 0000000fH
	mov	DWORD PTR [esi+3912], 45		; 0000002dH
	mov	DWORD PTR [esi+3916], -20		; ffffffecH
	mov	DWORD PTR [esi+3920], 45		; 0000002dH
	mov	DWORD PTR [esi+3924], 20		; 00000014H
	mov	DWORD PTR [esi+3928], 45		; 0000002dH
	mov	DWORD PTR [esi+3932], -20		; ffffffecH
	mov	DWORD PTR [esi+3936], 45		; 0000002dH
	mov	DWORD PTR [esi+3940], ecx
	mov	DWORD PTR [esi+3944], 30		; 0000001eH
	mov	DWORD PTR [esi+3948], eax
	mov	DWORD PTR [esi+3952], -10		; fffffff6H
	mov	DWORD PTR [esi+3956], -30		; ffffffe2H
	mov	DWORD PTR [esi+3960], -50		; ffffffceH
	mov	DWORD PTR [esi+3964], 4
	mov	DWORD PTR [esi+3968], 3
	mov	DWORD PTR [esi+3972], edi
	mov	DWORD PTR [esi+3976], 5
	mov	DWORD PTR [esi+3980], 3
	mov	DWORD PTR [esi+3984], 15		; 0000000fH
	mov	DWORD PTR [esi+3988], 5
	mov	DWORD PTR [esi+3992], eax
	mov	DWORD PTR [esi+3996], 4
	mov	DWORD PTR [esi+4000], ebx
	mov	DWORD PTR [esi+4004], 4
	mov	DWORD PTR [esi+4008], 8
	mov	DWORD PTR [esi+4012], 4
	mov	DWORD PTR [esi+4016], edx
	mov	DWORD PTR [esi+4020], 4
	mov	DWORD PTR [esi+4024], 4
	mov	DWORD PTR [esi+4028], 4
	mov	DWORD PTR [esi+4032], edi
	mov	DWORD PTR [esi+4036], edi
	mov	DWORD PTR [esi+4040], ebx
	mov	DWORD PTR [esi+4044], edi
	mov	DWORD PTR [esi+4048], -5		; fffffffbH
	mov	DWORD PTR [esi+4052], ebx
	mov	DWORD PTR [esi+4056], 4
	mov	DWORD PTR [esi+4060], -5		; fffffffbH
	mov	DWORD PTR [esi+4064], eax
	mov	DWORD PTR [esi+4068], eax
	mov	DWORD PTR [esi+4072], 15		; 0000000fH
	mov	DWORD PTR [esi+4076], 15		; 0000000fH
	mov	DWORD PTR [esi+4080], -10		; fffffff6H
	mov	DWORD PTR [esi+4084], -10		; fffffff6H
	mov	DWORD PTR [esi+4088], eax
	mov	DWORD PTR [esi+4092], eax
	mov	DWORD PTR [esi+4096], eax
	mov	DWORD PTR [esi+4100], eax
	mov	DWORD PTR [esi+4104], eax
	mov	DWORD PTR [esi+4108], 5
	mov	DWORD PTR [esi+4112], -15		; fffffff1H
	mov	DWORD PTR [esi+4116], -15		; fffffff1H
	mov	DWORD PTR [esi+4120], 6
	mov	DWORD PTR [esi+4124], edi
	mov	DWORD PTR [esi+4128], edx
	mov	DWORD PTR [esi+4132], 4
	mov	DWORD PTR [esi+4136], edx
	mov	DWORD PTR [esi+4140], edx
	mov	DWORD PTR [esi+4144], ebx
	mov	DWORD PTR [esi+4148], 4
	mov	DWORD PTR [esi+4152], 4
	mov	DWORD PTR [esi+4156], -6		; fffffffaH
	mov	DWORD PTR [esi+4160], -6		; fffffffaH
	mov	DWORD PTR [esi+4164], 4
	mov	DWORD PTR [esi+4168], -10		; fffffff6H
	mov	DWORD PTR [esi+4172], -10		; fffffff6H
	mov	DWORD PTR [esi+4176], 5
	mov	DWORD PTR [esi+4180], -4		; fffffffcH
	mov	DWORD PTR [esi+4184], -4		; fffffffcH
	mov	DWORD PTR [esi+4188], -4		; fffffffcH
	mov	DWORD PTR [esi+4192], -4		; fffffffcH
	mov	DWORD PTR [esi+4196], 4
	mov	DWORD PTR [esi+4200], -6		; fffffffaH
	mov	DWORD PTR [esi+4204], -6		; fffffffaH
	mov	DWORD PTR [esi+4208], 3
	mov	DWORD PTR [esi+4212], -4		; fffffffcH
	mov	DWORD PTR [esi+4216], -4		; fffffffcH
	mov	DWORD PTR [esi+4220], 4
	mov	DWORD PTR [esi+4224], -6		; fffffffaH
	mov	DWORD PTR [esi+4228], -6		; fffffffaH
	mov	DWORD PTR [esi+4232], 3
	mov	DWORD PTR [esi+4236], -4		; fffffffcH
	mov	DWORD PTR [esi+4240], -4		; fffffffcH
	mov	DWORD PTR [esi+4244], 4
	mov	DWORD PTR [esi+4248], -10		; fffffff6H
	mov	DWORD PTR [esi+4252], -10		; fffffff6H
	mov	DWORD PTR [esi+4256], 3
	mov	DWORD PTR [esi+4260], -3		; fffffffdH
	mov	DWORD PTR [esi+4264], -3		; fffffffdH
	mov	DWORD PTR [esi+4268], 4
	mov	DWORD PTR [esi+4272], -4		; fffffffcH
	mov	DWORD PTR [esi+4276], -4		; fffffffcH
	mov	DWORD PTR [esi+4280], ebx
	mov	DWORD PTR [esi+4284], ebx
	mov	DWORD PTR [esi+4288], 3
	mov	DWORD PTR [esi+4292], edi
	mov	DWORD PTR [esi+4296], ebx
	mov	DWORD PTR [esi+4300], ebx
	mov	DWORD PTR [esi+4304], edi
	mov	DWORD PTR [esi+4308], edx
	mov	DWORD PTR [esi+4312], ebx
	mov	DWORD PTR [esi+4316], ebx
	mov	DWORD PTR [esi+4320], ebx
	mov	DWORD PTR [esi+4324], edx
	mov	DWORD PTR [esi+4328], ebx
	mov	DWORD PTR [esi+4332], edi
	mov	DWORD PTR [esi+4336], -9		; fffffff7H
	mov	DWORD PTR [esi+4340], -3		; fffffffdH
	mov	DWORD PTR [esi+4344], -12		; fffffff4H
	mov	DWORD PTR [esi+4348], -2		; fffffffeH
	mov	DWORD PTR [esi+4352], edi
	mov	DWORD PTR [esi+4356], ebx
	mov	DWORD PTR [esi+4360], edi
	mov	DWORD PTR [esi+4364], -12		; fffffff4H
	mov	DWORD PTR [esi+4368], -2		; fffffffeH
	mov	DWORD PTR [esi+4372], edi
	mov	DWORD PTR [esi+4376], ebx
	mov	DWORD PTR [esi+4380], edi
	mov	DWORD PTR [esi+4384], -2		; fffffffeH
	mov	DWORD PTR [esi+4388], -2		; fffffffeH
	mov	DWORD PTR [esi+4392], edi
	mov	DWORD PTR [esi+4396], edi
	mov	DWORD PTR [esi+4400], -4		; fffffffcH
	mov	DWORD PTR [esi+4404], -4		; fffffffcH
	mov	DWORD PTR [esi+4408], edi
	mov	DWORD PTR [esi+4412], edi
	mov	DWORD PTR [esi+4416], 45		; 0000002dH
	mov	DWORD PTR [esi+4420], 60		; 0000003cH
	mov	DWORD PTR [esi+4424], 80		; 00000050H
	mov	DWORD PTR [esi+4428], ebp
	mov	DWORD PTR [esi+4432], 150		; 00000096H
	mov	DWORD PTR [esi+4436], 180		; 000000b4H
	mov	DWORD PTR [esi+4440], 125		; 0000007dH
	mov	DWORD PTR [esi+4444], 115		; 00000073H
	mov	DWORD PTR [esi+4448], 105		; 00000069H
	mov	DWORD PTR [esi+4452], ebp
	mov	DWORD PTR [esi+4456], 80		; 00000050H
	mov	DWORD PTR [esi+4460], 60		; 0000003cH
	mov	DWORD PTR [esi+4464], 25		; 00000019H
	mov	DWORD PTR [esi+4468], 65		; 00000041H
	mov	DWORD PTR [esi+4472], 160		; 000000a0H
	mov	DWORD PTR [esi+4476], 115		; 00000073H
	mov	DWORD PTR [esi+4480], ebp
	mov	DWORD PTR [esi+4484], 60		; 0000003cH
	mov	DWORD PTR [esi+4488], ecx
	mov	DWORD PTR [esi+4492], edx
	mov	DWORD PTR [esi+4496], edi
	mov	DWORD PTR [esi+4500], 3
	mov	DWORD PTR [esi+4504], eax
	mov	DWORD PTR [esi+4508], -15		; fffffff1H
	mov	DWORD PTR [esi+4512], -5		; fffffffbH
	mov	DWORD PTR [esi+4516], eax
	mov	DWORD PTR [esi+4520], -20		; ffffffecH
	mov	DWORD PTR [esi+4524], -15		; fffffff1H
	mov	DWORD PTR [esi+4528], 5
	mov	DWORD PTR [esi+4532], -20		; ffffffecH
	mov	DWORD PTR [esi+4536], -15		; fffffff1H
	mov	DWORD PTR [esi+4540], 5
	mov	DWORD PTR [esi+4544], -10		; fffffff6H
	mov	DWORD PTR [esi+4548], eax
	mov	DWORD PTR [esi+4552], -15		; fffffff1H
	mov	DWORD PTR [esi+4556], -6		; fffffffaH
	mov	DWORD PTR [esi+4560], edx
	mov	DWORD PTR [esi+4564], edx
	mov	DWORD PTR [esi+4568], -100		; ffffff9cH
	mov	DWORD PTR [esi+4572], 4
	mov	DWORD PTR [esi+4576], edi
	mov	DWORD PTR [esi+4580], -2		; fffffffeH
	mov	DWORD PTR [esi+4584], -1
	mov	DWORD PTR [esi+4588], edx
	mov	DWORD PTR [esi+4592], edx
	mov	DWORD PTR [esi+4596], -1
	mov	DWORD PTR [esi+4600], edx
	mov	DWORD PTR [esi+4604], -2		; fffffffeH
	mov	DWORD PTR [esi+4608], edi
	mov	DWORD PTR [esi+4612], -4		; fffffffcH
	mov	DWORD PTR [esi+4616], edi
	mov	DWORD PTR [esi+4620], -10		; fffffff6H
	mov	DWORD PTR [esi+4624], ebx
	mov	DWORD PTR [esi+4628], ebx
	mov	DWORD PTR [esi+4632], ebx
	mov	DWORD PTR [esi+4636], ebx
	mov	DWORD PTR [esi+4640], -1
	mov	DWORD PTR [esi+4644], -2		; fffffffeH
	mov	DWORD PTR [esi+4648], edx
	mov	DWORD PTR [esi+4652], ebx
	mov	DWORD PTR [esi+4656], ebx
	mov	DWORD PTR [esi+4660], -20		; ffffffecH
	mov	DWORD PTR [esi+4664], -2		; fffffffeH
	mov	DWORD PTR [esi+4668], eax
	mov	DWORD PTR [esi+4672], 20		; 00000014H
	mov	DWORD PTR [esi+4676], 40		; 00000028H
	mov	DWORD PTR [esi+4680], 110		; 0000006eH
	mov	DWORD PTR [esi+4684], 130		; 00000082H
	mov	DWORD PTR [esi+4688], 200		; 000000c8H
	mov	DWORD PTR [esi+4692], 150		; 00000096H
	mov	DWORD PTR [esi+4696], ebp
	mov	DWORD PTR [esi+4700], ecx
	mov	DWORD PTR [esi+4704], ebx
	mov	DWORD PTR [esi+4708], -100		; ffffff9cH
	mov	DWORD PTR [esi+4712], -50		; ffffffceH
	mov	DWORD PTR [esi+4716], ebx
	mov	DWORD PTR [esi+4720], 25		; 00000019H
	mov	DWORD PTR [esi+4724], 60		; 0000003cH
	mov	DWORD PTR [esi+4728], ecx
	mov	DWORD PTR [esi+4732], 40		; 00000028H
	mov	DWORD PTR [esi+4736], 25		; 00000019H
	mov	DWORD PTR [esi+4740], eax
	mov	DWORD PTR [esi+4744], ebx
	mov	DWORD PTR [esi+4748], ebx
	mov	DWORD PTR [esi+4752], ebx
	mov	DWORD PTR [esi+4756], 150		; 00000096H
	mov	DWORD PTR [esi+4760], ebp
	mov	DWORD PTR [esi+4764], ecx
	mov	DWORD PTR [esi+4768], 25		; 00000019H
	mov	DWORD PTR [esi+4772], ebx
	mov	DWORD PTR [esi+4776], ebx
	mov	DWORD PTR [esi+4780], eax
	mov	DWORD PTR [esi+4784], 25		; 00000019H
	mov	DWORD PTR [esi+4788], 35		; 00000023H
	mov	DWORD PTR [esi+4792], ecx
	mov	DWORD PTR [esi+4796], ecx
	mov	DWORD PTR [esi+4800], 75		; 0000004bH
	mov	DWORD PTR [esi+4804], 75		; 0000004bH
	mov	DWORD PTR [esi+4808], ebp
	mov	DWORD PTR [esi+4812], 400		; 00000190H
	mov	DWORD PTR [esi+4816], ecx
	mov	DWORD PTR [esi+4820], ecx
	mov	DWORD PTR [esi+4824], -100		; ffffff9cH
	mov	DWORD PTR [esi+4828], -150		; ffffff6aH
	mov	DWORD PTR [esi+4832], 150		; 00000096H
	mov	DWORD PTR [esi+4836], ebp
	mov	DWORD PTR [esi+4840], ecx
	mov	DWORD PTR [esi+4844], 20		; 00000014H
	mov	DWORD PTR [esi+4848], ebx
	mov	DWORD PTR [esi+4852], ebp
	mov	DWORD PTR [esi+4856], ecx
	mov	DWORD PTR [esi+4860], -25		; ffffffe7H
	mov	DWORD PTR [esi+4864], -100		; ffffff9cH
	mov	DWORD PTR [esi+4868], -200		; ffffff38H
	mov	DWORD PTR [esi+4872], 4
	mov	DWORD PTR [esi+4876], ebp
	mov	DWORD PTR [esi+4880], 60		; 0000003cH
	mov	DWORD PTR [esi+4884], 20		; 00000014H
	mov	DWORD PTR [esi+4888], ebx
	mov	DWORD PTR [esi+4892], -20		; ffffffecH
	mov	DWORD PTR [esi+4896], -50		; ffffffceH
	mov	DWORD PTR [esi+4900], ebx
	mov	DWORD PTR [esi+4904], eax
	mov	DWORD PTR [esi+4908], 20		; 00000014H
	mov	DWORD PTR [esi+4912], ecx
	mov	DWORD PTR [esi+4916], 80		; 00000050H
	mov	DWORD PTR [esi+4920], 180		; 000000b4H
	mov	DWORD PTR [esi+4924], 150		; 00000096H
	mov	DWORD PTR [esi+4928], 120		; 00000078H
	mov	DWORD PTR [esi+4932], 95		; 0000005fH
	mov	DWORD PTR [esi+4936], 70		; 00000046H
	mov	DWORD PTR [esi+4940], 55		; 00000037H
	mov	DWORD PTR [esi+4944], 40		; 00000028H
	mov	DWORD PTR [esi+4948], 20		; 00000014H
	mov	DWORD PTR [esi+4952], -50		; ffffffceH
	mov	DWORD PTR [esi+4956], -20		; ffffffecH
	mov	DWORD PTR [esi+4960], -10		; fffffff6H
	mov	DWORD PTR [esi+4964], ebx
	mov	DWORD PTR [esi+4968], ecx
	mov	DWORD PTR [esi+4972], ebp
	mov	DWORD PTR [esi+4976], -50		; ffffffceH
	mov	DWORD PTR [esi+4980], -20		; ffffffecH
	mov	DWORD PTR [esi+4984], ebx
	mov	DWORD PTR [esi+4988], 20		; 00000014H
	mov	DWORD PTR [esi+4992], ecx
	mov	DWORD PTR [esi+4996], 150		; 00000096H
	mov	DWORD PTR [esi+5000], 115		; 00000073H
	mov	DWORD PTR [esi+5004], 80		; 00000050H
	mov	DWORD PTR [esi+5008], 65		; 00000041H
	mov	DWORD PTR [esi+5012], ecx
	mov	DWORD PTR [esi+5016], 35		; 00000023H
	mov	DWORD PTR [esi+5020], 20		; 00000014H
	mov	DWORD PTR [esi+5024], eax
	mov	DWORD PTR [esi+5028], 3
	mov	DWORD PTR [esi+5032], ebp
	mov	DWORD PTR [esi+5036], 250		; 000000faH
	mov	DWORD PTR [esi+5040], 130		; 00000082H
	mov	DWORD PTR [esi+5044], 70		; 00000046H
	mov	DWORD PTR [esi+5048], ebx
	mov	DWORD PTR [esi+5052], 300		; 0000012cH
	mov	DWORD PTR [esi+5056], ebp
	mov	DWORD PTR [esi+5060], -30		; ffffffe2H
	mov	DWORD PTR [esi+5064], -100		; ffffff9cH
	mov	DWORD PTR [esi+5068], -300		; fffffed4H
	mov	DWORD PTR [esi+5072], -50		; ffffffceH
	mov	DWORD PTR [esi+5076], ebx
	mov	DWORD PTR [esi+5080], -20		; ffffffecH
	mov	DWORD PTR [esi+5084], -60		; ffffffc4H
	mov	DWORD PTR [esi+5088], -100		; ffffff9cH
	mov	DWORD PTR [esi+5092], -150		; ffffff6aH
	mov	DWORD PTR [esi+5096], -100		; ffffff9cH
	mov	DWORD PTR [esi+5100], -50		; ffffffceH
	mov	DWORD PTR [esi+5104], -25		; ffffffe7H
	mov	DWORD PTR [esi+5108], -10		; fffffff6H
	mov	DWORD PTR [esi+5112], ebx
	mov	DWORD PTR [esi+5116], 200		; 000000c8H
	mov	DWORD PTR [esi+5120], ebp
	mov	DWORD PTR [esi+5124], ecx
	mov	DWORD PTR [esi+5128], 20		; 00000014H
	mov	DWORD PTR [esi+5132], ebx
	mov	DWORD PTR [esi+5136], ebp
	mov	DWORD PTR [esi+5140], ecx
	mov	DWORD PTR [esi+5144], ebx
	mov	DWORD PTR [esi+5148], -50		; ffffffceH
	mov	DWORD PTR [esi+5152], -100		; ffffff9cH
	mov	DWORD PTR [esi+5156], ebp
	mov	DWORD PTR [esi+5160], 25		; 00000019H
	mov	DWORD PTR [esi+5164], -100		; ffffff9cH
	mov	DWORD PTR [esi+5168], -25		; ffffffe7H
	mov	DWORD PTR [esi+5172], ebx
	mov	DWORD PTR [esi+5176], ebp
	mov	DWORD PTR [esi+5180], 60		; 0000003cH
	mov	DWORD PTR [esi+5184], 25		; 00000019H
	mov	DWORD PTR [esi+5188], 25		; 00000019H
	mov	DWORD PTR [esi+5192], ebx
	mov	DWORD PTR [esi+5196], -25		; ffffffe7H
	mov	DWORD PTR [esi+5200], -60		; ffffffc4H
	mov	DWORD PTR [esi+5204], -100		; ffffff9cH
	mov	DWORD PTR [esi+5208], ecx
	mov	DWORD PTR [esi+5212], 30		; 0000001eH
	mov	DWORD PTR [esi+5216], 12		; 0000000cH
	mov	DWORD PTR [esi+5220], ebx
	mov	DWORD PTR [esi+5224], -12		; fffffff4H
	mov	DWORD PTR [esi+5228], -30		; ffffffe2H
	mov	DWORD PTR [esi+5232], -50		; ffffffceH
	mov	DWORD PTR [esi+5236], ebx
	mov	DWORD PTR [esi+5240], -10		; fffffff6H
	mov	DWORD PTR [esi+5244], -20		; ffffffecH
	mov	DWORD PTR [esi+5248], -30		; ffffffe2H
	mov	DWORD PTR [esi+5252], -40		; ffffffd8H
	mov	DWORD PTR [esi+5256], ebx
	mov	DWORD PTR [esi+5260], 5
	mov	DWORD PTR [esi+5264], eax
	mov	DWORD PTR [esi+5268], 15		; 0000000fH
	mov	DWORD PTR [esi+5272], 20		; 00000014H
	mov	DWORD PTR [esi+5276], 20		; 00000014H
	mov	DWORD PTR [esi+5280], 25		; 00000019H
	mov	DWORD PTR [esi+5284], 75		; 0000004bH
	mov	DWORD PTR [esi+5288], 57		; 00000039H
	mov	DWORD PTR [esi+5292], 42		; 0000002aH
	mov	DWORD PTR [esi+5296], 25		; 00000019H
	mov	DWORD PTR [esi+5300], 67		; 00000043H
	mov	DWORD PTR [esi+5304], ecx
	mov	DWORD PTR [esi+5308], 25		; 00000019H
	mov	DWORD PTR [esi+5312], eax
	mov	DWORD PTR [esi+5316], 150		; 00000096H
	mov	DWORD PTR [esi+5320], ebp
	mov	DWORD PTR [esi+5324], 120		; 00000078H
	mov	DWORD PTR [esi+5328], 80		; 00000050H
	mov	DWORD PTR [esi+5332], ecx
	mov	DWORD PTR [esi+5336], 30		; 0000001eH
	mov	DWORD PTR [esi+5340], eax
	mov	DWORD PTR [esi+5344], 3
	mov	DWORD PTR [esi+5348], 5
	mov	DWORD PTR [esi+5352], 9
	mov	DWORD PTR [esi+5356], eax
	mov	DWORD PTR [esi+5360], 7
	mov	DWORD PTR [esi+5364], 4
	mov	DWORD PTR [esi+5368], edi
	mov	DWORD PTR [esi+5372], 30		; 0000001eH
	mov	DWORD PTR [esi+5376], ebp
	mov	DWORD PTR [esi+5380], 33		; 00000021H
	mov	DWORD PTR [esi+5384], 250		; 000000faH
	mov	DWORD PTR [esi+5388], 165		; 000000a5H
	mov	DWORD PTR [esi+5392], 115		; 00000073H
	mov	DWORD PTR [esi+5396], 85		; 00000055H
	mov	DWORD PTR [esi+5400], 60		; 0000003cH
	mov	DWORD PTR [esi+5404], 40		; 00000028H
	mov	DWORD PTR [esi+5408], ebp
	mov	DWORD PTR [esi+5412], 250		; 000000faH
	mov	DWORD PTR [esi+5416], 153		; 00000099H
	mov	DWORD PTR [esi+5420], 120		; 00000078H
	mov	DWORD PTR [esi+5424], 83		; 00000053H
	mov	DWORD PTR [esi+5428], 65		; 00000041H
	mov	DWORD PTR [esi+5432], 40		; 00000028H
	mov	DWORD PTR [esi+5436], 200		; 000000c8H
	mov	DWORD PTR [esi+5440], 125		; 0000007dH
	mov	DWORD PTR [esi+5444], 80		; 00000050H
	mov	DWORD PTR [esi+5448], ecx
	mov	DWORD PTR [esi+5452], ecx
	mov	DWORD PTR [esi+5456], 250		; 000000faH
	mov	DWORD PTR [esi+5460], 165		; 000000a5H
	mov	DWORD PTR [esi+5464], 115		; 00000073H
	mov	DWORD PTR [esi+5468], 85		; 00000055H
	mov	DWORD PTR [esi+5472], 60		; 0000003cH
	mov	DWORD PTR [esi+5476], 40		; 00000028H
	mov	DWORD PTR [esi+5480], ebx
	mov	DWORD PTR [esi+5484], 30		; 0000001eH
	mov	DWORD PTR [esi+5488], -10		; fffffff6H
	mov	DWORD PTR [esi+5492], ebx
	mov	DWORD PTR [esi+5496], 30		; 0000001eH
	mov	DWORD PTR [esi+5500], 80		; 00000050H
	mov	DWORD PTR [esi+5504], ebx
	mov	DWORD PTR [esi+5508], ebx
	mov	DWORD PTR [esi+5512], 5
	mov	DWORD PTR [esi+5516], 15		; 0000000fH
	mov	DWORD PTR [esi+5520], 25		; 00000019H
	mov	DWORD PTR [esi+5524], 35		; 00000023H
	mov	DWORD PTR [esi+5528], ecx
	mov	DWORD PTR [esi+5532], ebp
	mov	DWORD PTR [esi+5536], 115		; 00000073H
	mov	DWORD PTR [esi+5540], 150		; 00000096H
	mov	DWORD PTR [esi+5544], 200		; 000000c8H
	mov	DWORD PTR [esi+5548], 150		; 00000096H
	mov	DWORD PTR [esi+5552], ebp
	mov	DWORD PTR [esi+5556], ecx
	mov	DWORD PTR [esi+5560], eax
	mov	DWORD PTR [esi+5564], eax
	mov	DWORD PTR [esi+5568], 40		; 00000028H
	mov	DWORD PTR [esi+5572], ebp
	mov	DWORD PTR [esi+5576], 80		; 00000050H
	mov	DWORD PTR [esi+5580], ecx
	mov	DWORD PTR [esi+5584], 30		; 0000001eH
	mov	DWORD PTR [esi+5588], eax
	mov	DWORD PTR [esi+5592], ecx
	mov	DWORD PTR [esi+5596], ebp
	mov	DWORD PTR [esi+5600], 60		; 0000003cH
	mov	DWORD PTR [esi+5604], 40		; 00000028H
	mov	DWORD PTR [esi+5608], 20		; 00000014H
	mov	DWORD PTR [esi+5612], 300		; 0000012cH
	mov	DWORD PTR [esi+5616], 220		; 000000dcH
	mov	DWORD PTR [esi+5620], 170		; 000000aaH
	mov	DWORD PTR [esi+5624], ebp
	mov	DWORD PTR [esi+5628], 300		; 0000012cH
	mov	DWORD PTR [esi+5632], 200		; 000000c8H
	mov	DWORD PTR [esi+5636], 135		; 00000087H
	mov	DWORD PTR [esi+5640], ebp
	mov	DWORD PTR [esi+5644], 65		; 00000041H
	mov	DWORD PTR [esi+5648], 20		; 00000014H
	mov	DWORD PTR [esi+5652], 5
	mov	DWORD PTR [esi+5656], ebx
	mov	DWORD PTR [esi+5660], -100		; ffffff9cH
	mov	DWORD PTR [esi+5664], -40		; ffffffd8H
	mov	DWORD PTR [esi+5668], 30		; 0000001eH
	mov	DWORD PTR [esi+5672], 80		; 00000050H
	mov	DWORD PTR [esi+5676], 150		; 00000096H
	mov	DWORD PTR [esi+5680], ebp
	mov	DWORD PTR [esi+5684], 40		; 00000028H
	mov	DWORD PTR [esi+5688], -40		; ffffffd8H
	mov	DWORD PTR [esi+5692], -100		; ffffff9cH
	mov	DWORD PTR [esi+5696], 20		; 00000014H
	mov	DWORD PTR [esi+5700], eax
	mov	DWORD PTR [esi+5704], 40		; 00000028H
	mov	DWORD PTR [esi+5708], 20		; 00000014H
	mov	DWORD PTR [esi+5712], -30		; ffffffe2H
	mov	DWORD PTR [esi+5716], 200		; 000000c8H
	mov	DWORD PTR [esi+5720], ebp
	mov	DWORD PTR [esi+5724], ecx
	mov	DWORD PTR [esi+5728], 20		; 00000014H
	mov	DWORD PTR [esi+5732], ecx
	mov	DWORD PTR [esi+5736], ebp
	mov	DWORD PTR [esi+5740], ecx
	mov	DWORD PTR [esi+5744], ebp
	mov	DWORD PTR [esi+5748], 5
	mov	DWORD PTR [esi+5752], eax
	mov	DWORD PTR [esi+5756], 40		; 00000028H
	mov	DWORD PTR [esi+5760], 25		; 00000019H
	mov	DWORD PTR [esi+5764], ecx
	mov	DWORD PTR [esi+5768], 400		; 00000190H
	mov	DWORD PTR [esi+5772], 230		; 000000e6H
	mov	DWORD PTR [esi+5776], ebp
	mov	DWORD PTR [esi+5780], 80		; 00000050H
	mov	DWORD PTR [esi+5784], ecx
	mov	DWORD PTR [esi+5788], 30		; 0000001eH
	mov	DWORD PTR [esi+5792], eax
	mov	DWORD PTR [esi+5796], 7
	mov	DWORD PTR [esi+5800], 5
	mov	DWORD PTR [esi+5804], 700		; 000002bcH
	mov	DWORD PTR [esi+5808], 400		; 00000190H
	mov	DWORD PTR [esi+5812], 200		; 000000c8H
	mov	DWORD PTR [esi+5816], eax
	mov	DWORD PTR [esi+5820], 5
	mov	DWORD PTR [esi+5824], ebx
	mov	DWORD PTR [esi+5828], eax
	mov	DWORD PTR [esi+5832], 32		; 00000020H
	mov	DWORD PTR [esi+5836], ecx
	mov	DWORD PTR [esi+5840], 60		; 0000003cH
	mov	DWORD PTR [esi+5844], ebx
	mov	DWORD PTR [esi+5848], 5
	mov	DWORD PTR [esi+5852], 12		; 0000000cH
	mov	DWORD PTR [esi+5856], 20		; 00000014H
	mov	DWORD PTR [esi+5860], 30		; 0000001eH
	mov	DWORD PTR [esi+5864], ebx
	mov	DWORD PTR [esi+5868], eax
	mov	DWORD PTR [esi+5872], 18		; 00000012H
	mov	DWORD PTR [esi+5876], 30		; 0000001eH
	mov	DWORD PTR [esi+5880], ebx
	mov	DWORD PTR [esi+5884], ebx
	mov	DWORD PTR [esi+5888], 14		; 0000000eH
	mov	DWORD PTR [esi+5892], eax
	mov	DWORD PTR [esi+5896], 6
	mov	DWORD PTR [esi+5900], 200		; 000000c8H
	mov	DWORD PTR [esi+5904], 180		; 000000b4H
	mov	DWORD PTR [esi+5908], 160		; 000000a0H
	mov	DWORD PTR [esi+5912], 130		; 00000082H
	mov	DWORD PTR [esi+5916], 110		; 0000006eH
	mov	DWORD PTR [esi+5920], 90		; 0000005aH
	mov	DWORD PTR [esi+5924], 80		; 00000050H
	mov	DWORD PTR [esi+5928], 55		; 00000037H
	mov	DWORD PTR [esi+5932], 30		; 0000001eH
	mov	DWORD PTR [esi+5936], 70		; 00000046H
	mov	DWORD PTR [esi+5940], ecx
	mov	DWORD PTR [esi+5944], 30		; 0000001eH
	mov	DWORD PTR [esi+5948], 7
	mov	DWORD PTR [esi+5952], 5
	mov	DWORD PTR [esi+5956], 3
	mov	DWORD PTR [esi+5960], ecx
	mov	DWORD PTR [esi+5964], ecx
	mov	DWORD PTR [esi+5968], eax
	mov	DWORD PTR [esi+5972], 20		; 00000014H
	mov	DWORD PTR [esi+5976], 1000		; 000003e8H
	mov	DWORD PTR [esi+5980], 20		; 00000014H
	mov	DWORD PTR [esi+5984], eax
	mov	DWORD PTR [esi+5988], ebp
	mov	DWORD PTR [esi+5992], 8
	mov	DWORD PTR [esi+5996], 5
	mov	DWORD PTR [esi+6000], 30		; 0000001eH
	mov	DWORD PTR [esi+6004], -30		; ffffffe2H
	mov	DWORD PTR [esi+6008], -20		; ffffffecH
	mov	DWORD PTR [esi+6012], -10		; fffffff6H
	mov	DWORD PTR [esi+6016], ebx
	mov	DWORD PTR [esi+6020], 25		; 00000019H
	mov	DWORD PTR [esi+6024], 40		; 00000028H
	mov	DWORD PTR [esi+6028], 60		; 0000003cH
	mov	DWORD PTR [esi+6032], ebp
	mov	DWORD PTR [esi+6036], ebp
	mov	DWORD PTR [esi+6040], 150		; 00000096H
	mov	DWORD PTR [esi+6044], 200		; 000000c8H
	mov	DWORD PTR [esi+6048], 300		; 0000012cH
	mov	DWORD PTR [esi+6052], 20		; 00000014H
	mov	DWORD PTR [esi+6056], 12		; 0000000cH
	mov	DWORD PTR [esi+6060], 30		; 0000001eH
	mov	DWORD PTR [esi+6064], ecx
	mov	DWORD PTR [esi+6068], ebp
	mov	DWORD PTR [esi+6072], 75		; 0000004bH
	mov	DWORD PTR [esi+6076], eax
	mov	DWORD PTR [esi+6080], ecx
	mov	DWORD PTR [esi+6084], 3
	mov	DWORD PTR [esi+6088], eax
	mov	DWORD PTR [esi+6092], 30		; 0000001eH
	mov	DWORD PTR [esi+6096], 3
	mov	DWORD PTR [esi+6100], eax
	mov	DWORD PTR [esi+6104], 15		; 0000000fH
	mov	DWORD PTR [esi+6108], ecx
	mov	DWORD PTR [esi+6112], 3
	mov	DWORD PTR [esi+6116], eax
	mov	DWORD PTR [esi+6120], 30		; 0000001eH
	mov	DWORD PTR [esi+6124], 3
	mov	DWORD PTR [esi+6128], eax
	mov	DWORD PTR [esi+6132], 15		; 0000000fH
	mov	DWORD PTR [esi+6136], ebp
	mov	DWORD PTR [esi+6140], edx
	mov	DWORD PTR [esi+6144], 3
	mov	DWORD PTR [esi+6148], eax
	mov	DWORD PTR [esi+6152], 25		; 00000019H
	mov	DWORD PTR [esi+6156], ecx
	mov	DWORD PTR [esi+6160], 8
	mov	DWORD PTR [esi+6164], ebp
	mov	DWORD PTR [esi+6168], edx
	mov	DWORD PTR [esi+6172], edi
	mov	DWORD PTR [esi+6176], eax
	mov	DWORD PTR [esi+6180], -4000		; fffff060H
	mov	DWORD PTR [esi+6184], 4
	mov	DWORD PTR [esi+6188], ebx
	mov	DWORD PTR [esi+6192], 6
	mov	DWORD PTR [esi+6196], edx
	mov	DWORD PTR [esi+6200], edx
	mov	DWORD PTR [esi+6204], 200		; 000000c8H
	mov	DWORD PTR [esi+6208], edi
	mov	DWORD PTR [esi+6212], edi
	mov	DWORD PTR [esi+6216], edx
	mov	DWORD PTR [esi+6220], edx
	mov	DWORD PTR [esi+6224], edx
	mov	DWORD PTR [esi+6228], edx
	mov	DWORD PTR [esi+6232], 5
	mov	DWORD PTR [esi+6236], 60		; 0000003cH
	mov	DWORD PTR [esi+6240], 12		; 0000000cH
	mov	DWORD PTR [esi+6244], eax
	mov	DWORD PTR [esi+6248], edi
	mov	DWORD PTR [esi+6252], 20		; 00000014H
	mov	DWORD PTR [esi+6256], edi
	mov	DWORD PTR [esi+6260], 20		; 00000014H
	mov	DWORD PTR [esi+6264], 5
	mov	DWORD PTR [esi+6268], 3
	mov	DWORD PTR [esi+6272], 4
	mov	DWORD PTR [esi+6276], 3
	mov	DWORD PTR [esi+6280], 3
	mov	DWORD PTR [esi+6284], 5
	mov	DWORD PTR [esi+6288], edx
	mov	DWORD PTR [esi+6292], -1
	mov	DWORD PTR [esi+6296], -1
	mov	DWORD PTR [esi+6300], -1
	mov	DWORD PTR [esi+6304], -1
	mov	DWORD PTR [esi+6308], -1
	mov	DWORD PTR [esi+6312], edx
	mov	DWORD PTR [esi+6316], 6
	mov	DWORD PTR [esi+6320], ecx
	mov	DWORD PTR [esi+6324], 15		; 0000000fH
	mov	DWORD PTR [esi+6328], edi
	mov	DWORD PTR [esi+6332], ebx
	mov	DWORD PTR [esi+6336], edx
	mov	DWORD PTR [esi+6340], ebx
	mov	DWORD PTR [esi+6344], edx
	mov	DWORD PTR [esi+6348], 1067450368	; 3fa00000H
	mov	DWORD PTR [esi+6352], edi
	mov	DWORD PTR [esi+6356], 3
	mov	DWORD PTR [esi+6360], -75		; ffffffb5H
	mov	DWORD PTR [esi+6364], -100		; ffffff9cH
	mov	DWORD PTR [esi+6368], edx
	mov	DWORD PTR [esi+6372], -10		; fffffff6H
	mov	DWORD PTR [esi+6376], -20		; ffffffecH
	mov	DWORD PTR [esi+6380], 5
	mov	DWORD PTR [esi+6384], 5
	mov	DWORD PTR [esi+6388], ebp
	mov	DWORD PTR [esi+6392], 20		; 00000014H
	mov	DWORD PTR [esi+6396], 5
	mov	DWORD PTR [esi+6400], -2		; fffffffeH
	mov	DWORD PTR [esi+6404], -40		; ffffffd8H
	mov	DWORD PTR [esi+6408], -50		; ffffffceH
	mov	DWORD PTR [esi+6412], -2		; fffffffeH
	mov	DWORD PTR [esi+6416], -40		; ffffffd8H
	mov	DWORD PTR [esi+6420], -2		; fffffffeH
	mov	DWORD PTR [esi+6424], -40		; ffffffd8H
	mov	DWORD PTR [esi+6428], 25		; 00000019H
	mov	DWORD PTR [esi+6432], ecx
	mov	DWORD PTR [esi+6436], 15		; 0000000fH
	mov	DWORD PTR [esi+6440], 25		; 00000019H
	mov	DWORD PTR [esi+6444], eax
	mov	DWORD PTR [esi+6448], ecx
	mov	DWORD PTR [esi+6452], edi
	mov	DWORD PTR [esi+6456], 25		; 00000019H
	mov	DWORD PTR [esi+6460], 15		; 0000000fH
	mov	DWORD PTR [esi+6464], 20		; 00000014H
	mov	DWORD PTR [esi+6468], 5
	mov	DWORD PTR [esi+6472], 60		; 0000003cH
	mov	DWORD PTR [esi+6476], 32		; 00000020H
	mov	DWORD PTR [esi+6480], 20		; 00000014H
	mov	DWORD PTR [esi+6484], 4
	mov	DWORD PTR [esi+6488], ebp
	mov	DWORD PTR [esi+6492], 160		; 000000a0H
	mov	DWORD PTR [esi+6496], 12		; 0000000cH
	mov	DWORD PTR [esi+6500], 4
	mov	DWORD PTR [esi+6504], edi
	mov	DWORD PTR [esi+6508], 9
	mov	DWORD PTR [esi+6512], ecx
	mov	DWORD PTR [esi+6516], 3
	mov	DWORD PTR [esi+6520], ebx
	mov	DWORD PTR [esi+6524], 5
	mov	DWORD PTR [esi+6528], 6
	mov	DWORD PTR [esi+6532], ebx
	mov	DWORD PTR [esi+6536], edx
	mov	DWORD PTR [esi+6540], ebx
	mov	DWORD PTR [esi+6544], 125		; 0000007dH
	mov	DWORD PTR [esi+6548], -5		; fffffffbH
	mov	DWORD PTR [esi+6552], 500		; 000001f4H
	mov	DWORD PTR [esi+6556], 1017370378	; 3ca3d70aH
	mov	DWORD PTR [esi+6560], 500		; 000001f4H
	mov	DWORD PTR [esi+6564], 5
	mov	DWORD PTR [esi+6568], edx
	mov	DWORD PTR [esi+6572], edx
	mov	DWORD PTR [esi+6576], eax
	mov	DWORD PTR [esi+6580], ebp
	mov	DWORD PTR [esi+6584], 3
	mov	DWORD PTR [esi+6588], ecx
	mov	DWORD PTR [esi+6592], edx
	mov	DWORD PTR [esi+6596], eax
	mov	DWORD PTR [esi+6600], 25		; 00000019H
	mov	DWORD PTR [esi+6604], -50		; ffffffceH
	mov	DWORD PTR [esi+6608], edx
	mov	DWORD PTR [esi+6612], 25		; 00000019H
	mov	DWORD PTR [esi+6616], edi
	mov	DWORD PTR [esi+6620], ecx
	mov	DWORD PTR [esi+6624], 3
	mov	DWORD PTR [esi+6628], 4
	mov	DWORD PTR [esi+6632], 4
	mov	DWORD PTR [esi+6636], 6
	mov	DWORD PTR [esi+6640], 30		; 0000001eH
	mov	DWORD PTR [esi+6644], 20		; 00000014H
	mov	DWORD PTR [esi+6648], 20		; 00000014H
	mov	DWORD PTR [esi+6652], 60		; 0000003cH
	mov	DWORD PTR [esi+6656], eax
	mov	DWORD PTR [esi+6660], eax
	mov	DWORD PTR [esi+6664], 5
	mov	DWORD PTR [esi+6668], ecx
	mov	DWORD PTR [esi+6672], edi
	mov	DWORD PTR [esi+6676], ecx
	mov	DWORD PTR [esi+6680], 30		; 0000001eH
	mov	DWORD PTR [esi+6684], 20		; 00000014H
	mov	DWORD PTR [esi+6688], eax
	mov	DWORD PTR [esi+6692], 15		; 0000000fH
	mov	DWORD PTR [esi+6696], 67		; 00000043H
	mov	DWORD PTR [esi+6700], ebx
	mov	DWORD PTR [esi+6704], 67		; 00000043H
	mov	DWORD PTR [esi+6708], ebp
	mov	DWORD PTR [esi+6712], ebp
	mov	DWORD PTR [esi+6716], 70		; 00000046H
	mov	DWORD PTR [esi+6720], ebp
	mov	DWORD PTR [esi+6724], ebp
	mov	DWORD PTR [esi+6728], ebp
	mov	DWORD PTR [esi+6732], ebp
	mov	DWORD PTR [esi+6736], 300		; 0000012cH
	mov	DWORD PTR [esi+6740], ebp
	mov	DWORD PTR [esi+6744], ebx
	mov	DWORD PTR [esi+6748], 20		; 00000014H
	mov	DWORD PTR [esi+6752], eax
	mov	DWORD PTR [esi+6756], 20		; 00000014H
	mov	DWORD PTR [esi+6760], 20		; 00000014H
	mov	DWORD PTR [esi+6764], ecx
	mov	DWORD PTR [esi+6768], -25		; ffffffe7H
	mov	DWORD PTR [esi+6772], ecx
	mov	DWORD PTR [esi+6776], 99		; 00000063H
	mov	DWORD PTR [esi+6780], eax
	mov	DWORD PTR [esi+6784], 98		; 00000062H
	mov	DWORD PTR [esi+6788], eax
	mov	DWORD PTR [esi+6792], edi
	mov	DWORD PTR [esi+6796], 5
	mov	DWORD PTR [esi+6800], -75		; ffffffb5H
	mov	DWORD PTR [esi+6804], edx
	mov	DWORD PTR [esi+6808], eax
	mov	DWORD PTR [esi+6812], 4
	mov	DWORD PTR [esi+6816], edi
	mov	DWORD PTR [esi+6820], 20		; 00000014H
	mov	DWORD PTR [esi+6824], 3
	mov	DWORD PTR [esi+6828], 5000		; 00001388H
	mov	DWORD PTR [esi+6832], 2000		; 000007d0H
	mov	DWORD PTR [esi+6836], 1000		; 000003e8H
	mov	DWORD PTR [esi+6840], 2000		; 000007d0H
	mov	DWORD PTR [esi+6844], ebx
	mov	DWORD PTR [esi+6848], ebx
	mov	DWORD PTR [esi+6852], -60		; ffffffc4H
	mov	DWORD PTR [esi+6856], 20		; 00000014H
	mov	DWORD PTR [esi+6860], 512		; 00000200H
	mov	DWORD PTR [esi+6864], ebp
	mov	DWORD PTR [esi+6868], 90		; 0000005aH
	mov	DWORD PTR [esi+6872], ebx
	mov	DWORD PTR [esi+6876], eax
	mov	DWORD PTR [esi+6880], ebx
	mov	DWORD PTR [esi+6884], ebx
	mov	DWORD PTR [esi+6888], ebx
	mov	DWORD PTR [esi+6892], edx
	mov	DWORD PTR [esi+6896], edi
	mov	DWORD PTR [esi+6900], ebx
	mov	DWORD PTR [esi+6904], ebx
	mov	DWORD PTR [esi+6908], edi
	mov	DWORD PTR [esi+6912], 67		; 00000043H
	mov	DWORD PTR [esi+6916], ebx
	mov	DWORD PTR [esi+6920], 150		; 00000096H
	mov	DWORD PTR [esi+6924], ebx
	mov	DWORD PTR [esi+6928], edi
	mov	DWORD PTR [esi+6932], 3
	mov	DWORD PTR [esi+6936], 6
	mov	DWORD PTR [esi+6940], -60		; ffffffc4H
	mov	DWORD PTR [esi+6944], ebx
	mov	DWORD PTR [esi+6948], -25		; ffffffe7H
	mov	DWORD PTR [esi+6952], -25		; ffffffe7H
	mov	DWORD PTR [esi+6956], ebx
	mov	DWORD PTR [esi+6960], ebx
	mov	DWORD PTR [esi+6964], 25		; 00000019H
	mov	DWORD PTR [esi+6968], 6
	mov	DWORD PTR [esi+6972], 5
	mov	DWORD PTR [esi+6976], edx
	mov	DWORD PTR [esi+6980], edi
	mov	DWORD PTR [esi+6984], -75		; ffffffb5H
	mov	DWORD PTR [esi+6988], 4
	mov	DWORD PTR [esi+6992], eax
	mov	DWORD PTR [esi+6996], edx
	mov	DWORD PTR [esi+7000], 3
	mov	DWORD PTR [esi+7004], edi
	mov	DWORD PTR [esi+7008], edx
	mov	DWORD PTR [esi+7012], ebx
	mov	DWORD PTR [esi+7016], 4
	mov	DWORD PTR [esi+7020], ebx
	mov	DWORD PTR [esi+7024], edx
	mov	DWORD PTR [esi+7028], ebx
	mov	DWORD PTR [esi+7032], 33		; 00000021H
	mov	DWORD PTR [esi+7036], edi
	mov	DWORD PTR [esi+7040], 4
	mov	DWORD PTR [esi+7044], 7
	mov	DWORD PTR [esi+7048], 6
	mov	DWORD PTR [esi+7052], eax
	mov	DWORD PTR [esi+7056], 30		; 0000001eH
	mov	DWORD PTR [esi+7060], edi
	mov	DWORD PTR [esi+7064], 4
	mov	DWORD PTR [esi+7068], 25		; 00000019H
	mov	DWORD PTR [esi+7072], 200		; 000000c8H
	mov	DWORD PTR [esi+7076], ebp
	mov	DWORD PTR [esi+7080], edi
	mov	DWORD PTR [esi+7084], ebx
	mov	DWORD PTR [esi+7088], -1
	mov	DWORD PTR [esi+7092], 75		; 0000004bH
	mov	DWORD PTR [esi+7096], 20		; 00000014H
	mov	DWORD PTR [esi+7100], 4
	mov	DWORD PTR [esi+7104], ebp
	mov	DWORD PTR [esi+7108], ebp
	mov	DWORD PTR [esi+7112], eax
	mov	DWORD PTR [esi+7116], -50		; ffffffceH
	mov	DWORD PTR [esi+7120], ecx
	mov	DWORD PTR [esi+7124], ebx
	mov	DWORD PTR [esi+7132], ebx
	mov	DWORD PTR [esi+7136], ebx
	mov	DWORD PTR [esi+7140], 4
	mov	DWORD PTR [esi+7144], 75		; 0000004bH
	mov	DWORD PTR [esi+7148], edi
	mov	DWORD PTR [esi+7152], 3
	mov	DWORD PTR [esi+7156], ecx
	mov	DWORD PTR [esi+7160], 6
	mov	DWORD PTR [esi+7164], 12		; 0000000cH
	mov	DWORD PTR [esi+7168], 8
	mov	DWORD PTR [esi+7172], edi
	mov	DWORD PTR [esi+7176], edx
	mov	DWORD PTR [esi+7180], edx
	mov	DWORD PTR [esi+7184], edx
	mov	DWORD PTR [esi+7188], edx
	mov	DWORD PTR [esi+7192], 20		; 00000014H
	mov	DWORD PTR [esi+7196], 15		; 0000000fH
	mov	DWORD PTR [esi+7200], 6
	mov	DWORD PTR [esi+7204], 3
	mov	DWORD PTR [esi+7208], edi
	mov	DWORD PTR [esi+7212], edx
	mov	DWORD PTR [esi+7216], edx
	mov	DWORD PTR [esi+7220], edx
	mov	DWORD PTR [esi+7224], edx
	mov	DWORD PTR [esi+7228], eax
	mov	DWORD PTR [esi+7232], 12		; 0000000cH
	mov	DWORD PTR [esi+7236], 8
	mov	DWORD PTR [esi+7240], 6
	mov	DWORD PTR [esi+7244], edx
	mov	DWORD PTR [esi+7248], edx
	mov	DWORD PTR [esi+7252], 40		; 00000028H
	mov	DWORD PTR [esi+7256], 85		; 00000055H
	mov	DWORD PTR [esi+7260], -50		; ffffffceH
	mov	DWORD PTR [esi+7264], 15		; 0000000fH
	mov	DWORD PTR [esi+7268], 5
	mov	DWORD PTR [esi+7272], 3
	mov	DWORD PTR [esi+7276], -1000		; fffffc18H
	mov	DWORD PTR [esi+7280], 30		; 0000001eH
	mov	DWORD PTR [esi+7284], 15		; 0000000fH
	mov	DWORD PTR [esi+7288], 150		; 00000096H
	mov	DWORD PTR [esi+7292], 150		; 00000096H
	mov	DWORD PTR [esi+7296], 200		; 000000c8H
	mov	DWORD PTR [esi+7300], 40		; 00000028H
	mov	DWORD PTR [esi+7304], 200		; 000000c8H
	mov	DWORD PTR [esi+7308], 150		; 00000096H
	mov	DWORD PTR [esi+7312], 1000		; 000003e8H
	mov	DWORD PTR [esi+7316], 500		; 000001f4H
	mov	DWORD PTR [esi+7320], 250		; 000000faH
	mov	DWORD PTR [esi+7324], 200		; 000000c8H
	mov	DWORD PTR [esi+7328], 500		; 000001f4H
	mov	DWORD PTR [esi+7332], 5
	mov	DWORD PTR [esi+7336], 30		; 0000001eH
	mov	DWORD PTR [esi+7340], ebx
	mov	DWORD PTR [esi+7344], eax
	mov	DWORD PTR [esi+7348], -20		; ffffffecH
	mov	DWORD PTR [esi+7352], 3
	mov	DWORD PTR [esi+7356], edx
	mov	DWORD PTR [esi+7360], edx
	mov	DWORD PTR [esi+7364], edx
	mov	DWORD PTR [esi+7368], eax
	mov	DWORD PTR [esi+7372], 200		; 000000c8H
	mov	DWORD PTR [esi+7376], edx
	mov	DWORD PTR [esi+7380], -33		; ffffffdfH
	mov	DWORD PTR [esi+7384], 25		; 00000019H
	mov	DWORD PTR [esi+7388], -20		; ffffffecH
	mov	DWORD PTR [esi+7392], -50		; ffffffceH
	mov	DWORD PTR [esi+7396], eax
	mov	DWORD PTR [esi+7400], eax
	mov	DWORD PTR [esi+7404], 15		; 0000000fH
	mov	DWORD PTR [esi+7408], ecx
	mov	DWORD PTR [esi+7412], 15		; 0000000fH
	mov	DWORD PTR [esi+7416], 400		; 00000190H
	mov	DWORD PTR [esi+7420], 125		; 0000007dH
	mov	DWORD PTR [esi+7424], 400		; 00000190H
	mov	DWORD PTR [esi+7428], 250		; 000000faH
	mov	DWORD PTR [esi+7432], 300		; 0000012cH
	mov	DWORD PTR [esi+7436], 200		; 000000c8H
	mov	DWORD PTR [esi+7440], 200		; 000000c8H
	mov	DWORD PTR [esi+7444], 400		; 00000190H
	mov	DWORD PTR [esi+7448], 300		; 0000012cH
	mov	DWORD PTR [esi+7452], 75		; 0000004bH
	mov	DWORD PTR [esi+7456], ecx
	mov	DWORD PTR [esi+7460], -50		; ffffffceH
	mov	DWORD PTR [esi+7464], 400		; 00000190H
	mov	DWORD PTR [esi+7468], 25		; 00000019H
	mov	DWORD PTR [esi+7472], 300		; 0000012cH
	mov	DWORD PTR [esi+7476], 3
	mov	DWORD PTR [esi+7480], ecx
	mov	DWORD PTR [esi+7484], ebp
	mov	DWORD PTR [esi+7488], edi
	mov	DWORD PTR [esi+7492], edx
	mov	DWORD PTR [esi+7496], 40		; 00000028H
	mov	DWORD PTR [esi+7500], edx
	mov	DWORD PTR [esi+7504], ecx
	mov	DWORD PTR [esi+7508], eax
	mov	DWORD PTR [esi+7512], 5
	mov	DWORD PTR [esi+7516], 4
	mov	DWORD PTR [esi+7520], 4
	mov	DWORD PTR [esi+7524], edi
	mov	DWORD PTR [esi+7528], edi
	mov	DWORD PTR [esi+7532], edi
	mov	DWORD PTR [esi+7536], 5
	mov	DWORD PTR [esi+7540], 5
	mov	DWORD PTR [esi+7544], edi
	mov	DWORD PTR [esi+7548], 5
	mov	DWORD PTR [esi+7552], 3
	mov	DWORD PTR [esi+7556], 4
	mov	DWORD PTR [esi+7560], 30		; 0000001eH
	mov	DWORD PTR [esi+7564], ebp
	mov	DWORD PTR [esi+7568], ecx
	mov	DWORD PTR [esi+7572], ecx
	mov	DWORD PTR [esi+7576], 200		; 000000c8H
	mov	DWORD PTR [esi+7580], ecx
	mov	DWORD PTR [esi+7584], edx
	mov	DWORD PTR [esi+7588], eax
	mov	DWORD PTR [esi+7592], 5
	mov	DWORD PTR [esi+7596], 25		; 00000019H
	mov	DWORD PTR [esi+7600], 7
	mov	DWORD PTR [esi+7604], 11		; 0000000bH
	mov	DWORD PTR [esi+7608], 25		; 00000019H
	mov	DWORD PTR [esi+7612], 20		; 00000014H
	mov	DWORD PTR [esi+7616], eax
	mov	DWORD PTR [esi+7620], 45		; 0000002dH
	mov	DWORD PTR [esi+7624], ecx
	mov	DWORD PTR [esi+7628], 20		; 00000014H
	mov	DWORD PTR [esi+7632], ecx
	mov	DWORD PTR [esi+7636], 5
	mov	DWORD PTR [esi+7640], 5
	mov	DWORD PTR [esi+7644], 20		; 00000014H
	mov	DWORD PTR [esi+7648], eax
	mov	DWORD PTR [esi+7652], 5
	mov	DWORD PTR [esi+7656], -85		; ffffffabH
	mov	DWORD PTR [esi+7660], 150		; 00000096H
	mov	DWORD PTR [esi+7664], 3
	mov	DWORD PTR [esi+7668], 5
	mov	DWORD PTR [esi+7672], ebp
	mov	DWORD PTR [esi+7676], ecx
	mov	DWORD PTR [esi+7680], 3
	mov	DWORD PTR [esi+7684], ebp
	mov	DWORD PTR [esi+7688], ebx
	mov	DWORD PTR [esi+7692], -5		; fffffffbH
	mov	DWORD PTR [esi+7696], ebx
	mov	DWORD PTR [esi+7700], -105		; ffffff97H
	mov	DWORD PTR [esi+7704], -105		; ffffff97H
	mov	DWORD PTR [esi+7708], -100		; ffffff9cH
	mov	DWORD PTR [esi+7712], eax
	mov	DWORD PTR [esi+7716], -1
	mov	DWORD PTR [esi+7720], 1000		; 000003e8H
	mov	DWORD PTR [esi+7724], eax
	mov	DWORD PTR [esi+7728], edx
	mov	DWORD PTR [esi+7732], 28		; 0000001cH
	mov	DWORD PTR [esi+7736], 35		; 00000023H
	mov	DWORD PTR [esi+7740], 67		; 00000043H
	mov	DWORD PTR [esi+7744], eax
	mov	DWORD PTR [esi+7748], 3
	mov	DWORD PTR [esi+7752], edx
	mov	DWORD PTR [esi+7756], 40		; 00000028H
	mov	DWORD PTR [esi+7760], 4
	mov	DWORD PTR [esi+7764], eax
	mov	DWORD PTR [esi+7768], 4
	mov	DWORD PTR [esi+7772], 4
	mov	DWORD PTR [esi+7776], 20		; 00000014H
	mov	DWORD PTR [esi+7780], edx
	mov	DWORD PTR [esi+7784], edx
	mov	DWORD PTR [esi+7788], eax
	mov	DWORD PTR [esi+7792], 5
	mov	DWORD PTR [esi+7796], 5
	mov	DWORD PTR [esi+7800], 5
	mov	DWORD PTR [esi+7804], 3
	mov	DWORD PTR [esi+7808], 3
	mov	DWORD PTR [esi+7812], 25		; 00000019H
	mov	DWORD PTR [esi+7816], ebx
	mov	DWORD PTR [esi+7820], ebx
	mov	DWORD PTR [esi+7824], edi
	mov	DWORD PTR [esi+7828], ebx
	mov	DWORD PTR [esi+7832], eax
	mov	DWORD PTR [esi+7836], eax
	mov	DWORD PTR [esi+7840], ebx
	mov	DWORD PTR [esi+7844], ebx
	mov	DWORD PTR [esi+7848], ebx
	mov	DWORD PTR [esi+7852], 5
	mov	DWORD PTR [esi+7856], eax
	mov	DWORD PTR [esi+7860], ebx
	mov	DWORD PTR [esi+7864], ebx
	mov	DWORD PTR [esi+7868], ebx
	mov	DWORD PTR [esi+7872], ebx
	mov	DWORD PTR [esi+7876], ebx
	mov	DWORD PTR [esi+7880], ebx
	mov	DWORD PTR [esi+7884], ebx
	mov	DWORD PTR [esi+7888], ebx
	mov	DWORD PTR [esi+7892], ebx
	mov	DWORD PTR [esi+7896], ebx
	mov	DWORD PTR [esi+7900], ebx
	mov	DWORD PTR [esi+7904], ebx
	mov	DWORD PTR [esi+7908], ebx
	mov	DWORD PTR [esi+7912], ebx
	mov	DWORD PTR [esi+7916], ebx
	mov	DWORD PTR [esi+7920], ebx
	mov	DWORD PTR [esi+7924], ebx
	mov	DWORD PTR [esi+7928], ebx
	mov	DWORD PTR [esi+7932], ebx
	mov	DWORD PTR [esi+7936], ebx
	mov	DWORD PTR [esi+7940], ebx
	mov	DWORD PTR [esi+7944], ebx
	mov	DWORD PTR [esi+7948], ebx
	mov	DWORD PTR [esi+7952], eax
	mov	DWORD PTR [esi+7956], ebp
	mov	DWORD PTR [esi+7960], 200		; 000000c8H
	mov	DWORD PTR [esi+7964], 20		; 00000014H
	mov	DWORD PTR [esi+7968], ecx
	mov	DWORD PTR [esi+7972], eax
	mov	DWORD PTR [esi+7976], 80		; 00000050H
	mov	DWORD PTR [esi+7980], 40		; 00000028H
	mov	DWORD PTR [esi+7984], 1069069369	; 3fb8b439H
	mov	DWORD PTR [esi+7988], 1088421888	; 40e00000H
	mov	DWORD PTR [esi+7992], 1098919707	; 41802f1bH
	mov	DWORD PTR [esi+7996], -1050947879	; c15bced9H
	mov	DWORD PTR [esi+8000], 1014350479	; 3c75c28fH
	mov	DWORD PTR [esi+8004], 1041865114	; 3e19999aH
	mov	DWORD PTR [esi+8008], 1014350479	; 3c75c28fH
	mov	DWORD PTR [esi+8012], 1041865114	; 3e19999aH
	mov	DWORD PTR [esi+8016], 1064514355	; 3f733333H
	mov	DWORD PTR [esi+8020], 1140457472	; 43fa0000H
	mov	DWORD PTR [esi+8024], 1143930880	; 442f0000H
	mov	DWORD PTR [esi+8028], 1145569280	; 44480000H
	mov	DWORD PTR [esi+8032], 1101004800	; 41a00000H
	mov	DWORD PTR [esi+8036], 1066192077	; 3f8ccccdH
	mov	DWORD PTR [esi+8040], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8044], 1045220557	; 3e4ccccdH
	mov	DWORD PTR [esi+8048], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8052], 1045220557	; 3e4ccccdH
	mov	DWORD PTR [esi+8056], 1036831949	; 3dcccccdH
	mov	DWORD PTR [esi+8060], 1056964608	; 3f000000H
	mov	DWORD PTR [esi+8064], 1063675494	; 3f666666H
	mov	DWORD PTR [esi+8068], ebx
	mov	DWORD PTR [esi+8072], 1036831949	; 3dcccccdH
	mov	DWORD PTR [esi+8076], 1036831949	; 3dcccccdH
	mov	DWORD PTR [esi+8080], ebx
	mov	DWORD PTR [esi+8084], 1063675494	; 3f666666H
	mov	DWORD PTR [esi+8088], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8092], 1074161254	; 40066666H
	mov	DWORD PTR [esi+8096], 1066192077	; 3f8ccccdH
	mov	DWORD PTR [esi+8100], 1050253722	; 3e99999aH
	mov	DWORD PTR [esi+8104], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8108], 1059816735	; 3f2b851fH
	mov	DWORD PTR [esi+8112], 1065437102	; 3f8147aeH
	mov	DWORD PTR [esi+8116], 1086953882	; 40c9999aH
	mov	DWORD PTR [esi+8120], 1066192077	; 3f8ccccdH
	mov	DWORD PTR [esi+8124], 1066192077	; 3f8ccccdH
	mov	DWORD PTR [esi+8128], 1086324736	; 40c00000H
	mov	DWORD PTR [esi+8132], 1072064102	; 3fe66666H
	mov	DWORD PTR [esi+8136], 1071225242	; 3fd9999aH
	mov	DWORD PTR [esi+8140], ebx
	mov	DWORD PTR [esi+8144], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8148], 1084227584	; 40a00000H
	mov	DWORD PTR [esi+8152], 1072064102	; 3fe66666H
	mov	DWORD PTR [esi+8156], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8160], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8164], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8168], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8172], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8176], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8180], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8184], 25		; 00000019H
	mov	DWORD PTR [esi+8188], edx
	mov	DWORD PTR [esi+8200], 1092280648	; 411ae148H
	mov	DWORD PTR [esi+8204], -1025236009	; c2e423d7H
	mov	DWORD PTR [esi+8208], edi
	mov	DWORD PTR [esi+8212], edi
	mov	DWORD PTR [esi+8216], 25		; 00000019H
	mov	DWORD PTR [esi+8220], 25		; 00000019H
	mov	DWORD PTR [esi+8224], 25		; 00000019H
	mov	DWORD PTR [esi+8228], -50		; ffffffceH
	mov	DWORD PTR [esi+8232], 25		; 00000019H
	mov	DWORD PTR [esi+8236], ebp
	mov	DWORD PTR [esi+8240], 5
	mov	DWORD PTR [esi+8244], eax
	mov	DWORD PTR [esi+8248], 15		; 0000000fH
	mov	DWORD PTR [esi+8252], 20		; 00000014H
	mov	DWORD PTR [esi+8256], ecx
	mov	DWORD PTR [esi+8260], 5
	mov	DWORD PTR [esi+8264], 8
	mov	DWORD PTR [esi+8268], 30		; 0000001eH
	mov	DWORD PTR [esi+8272], 30		; 0000001eH
	mov	DWORD PTR [esi+8276], ecx
	mov	DWORD PTR [esi+8280], edi
	mov	DWORD PTR [esi+8284], ecx
	mov	DWORD PTR [esi+8288], 250		; 000000faH
	mov	ecx, 5
	mov	DWORD PTR [esi+8292], ecx
	mov	DWORD PTR [esi+8296], 25		; 00000019H
	mov	DWORD PTR [esi+8300], ebp
	mov	DWORD PTR [esi+8304], ebp
	mov	DWORD PTR [esi+8308], 30		; 0000001eH
	mov	DWORD PTR [esi+8312], ecx
	mov	DWORD PTR [esi+8316], edx
	mov	DWORD PTR [esi+8320], edx
	mov	DWORD PTR [esi+8324], edx
	mov	DWORD PTR [esi+8328], edx
	mov	DWORD PTR [esi+8332], 1056964608	; 3f000000H
	mov	DWORD PTR [esi+8336], 1065353216	; 3f800000H
	mov	DWORD PTR [esi+8340], -1
	mov	DWORD PTR [esi+8344], 25		; 00000019H
	mov	DWORD PTR [esi+8348], edx
	mov	DWORD PTR [esi+8352], edx
	mov	ebp, 4
	mov	DWORD PTR [esi+8356], ebp
	mov	DWORD PTR [esi+8360], ebp
	mov	DWORD PTR [esi+8364], edi
	mov	ebp, 3
	mov	DWORD PTR [esi+8368], ebp
	mov	DWORD PTR [esi+8372], 6
	mov	DWORD PTR [esi+8376], 9
	mov	DWORD PTR [esi+8380], 11		; 0000000bH
	mov	DWORD PTR [esi+8384], eax
	mov	DWORD PTR [esi+8388], ebx
	mov	eax, 6
	mov	DWORD PTR [esi+8392], eax
	mov	DWORD PTR [esi+8396], ecx
	mov	DWORD PTR [esi+8400], ebx
	mov	DWORD PTR [esi+8404], eax
	mov	DWORD PTR [esi+8408], 35		; 00000023H
	mov	DWORD PTR [esi+8412], 39		; 00000027H
	mov	DWORD PTR [esi+8416], 28		; 0000001cH
	mov	DWORD PTR [esi+8420], ebx
	mov	DWORD PTR [esi+8424], edx
	mov	DWORD PTR [esi+8428], edi
	mov	DWORD PTR [esi+8432], ecx
	mov	DWORD PTR [esi+8436], ebp
	mov	eax, 4
	mov	DWORD PTR [esi+8440], eax
	mov	DWORD PTR [esi+8444], ebx
	mov	DWORD PTR [esi+8448], ebx
	mov	DWORD PTR [esi+8452], edx
	mov	DWORD PTR [esi+8456], ebp
	mov	DWORD PTR [esi+8460], edx
	mov	DWORD PTR [esi+8464], edi
	mov	DWORD PTR [esi+8468], ebp
	mov	DWORD PTR [esi+8472], ebx
	mov	DWORD PTR [esi+8476], ebp
	mov	DWORD PTR [esi+8480], edx
	mov	DWORD PTR [esi+8484], ebx
	mov	DWORD PTR [esi+8488], eax
	mov	DWORD PTR [esi+8492], eax
	mov	DWORD PTR [esi+8496], ecx
	mov	DWORD PTR [esi+8500], ebx
	mov	DWORD PTR [esi+8504], edx
	mov	eax, 19					; 00000013H
	mov	DWORD PTR [esi+8508], eax
	mov	DWORD PTR [esi+8512], eax
	mov	DWORD PTR [esi+8516], ebp
	mov	DWORD PTR [esi+8520], 18		; 00000012H
	mov	DWORD PTR [esi+8524], 76		; 0000004cH
	mov	DWORD PTR [esi+8528], 77		; 0000004dH
	mov	DWORD PTR [esi+8532], 146		; 00000092H
	mov	DWORD PTR [esi+8536], 115		; 00000073H
	mov	DWORD PTR [esi+8540], 116		; 00000074H

; 1937 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR [esi+8544], 8
	mov	DWORD PTR [esi+8548], edx
	or	eax, -1
	mov	DWORD PTR [esi+8552], eax
	mov	DWORD PTR [esi+8556], eax
	mov	DWORD PTR [esi+8560], eax
	mov	DWORD PTR [esi+8564], ebx
	pop	edi
	mov	DWORD PTR [esi+8568], ebx
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvGlobals@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 896				; 00000380H
	jmp	??1?$vector@PAVCvInterfaceModeInfo@@V?$allocator@PAVCvInterfaceModeInfo@@@std@@@std@@QAE@XZ ; std::vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >::~vector<CvInterfaceModeInfo *,std::allocator<CvInterfaceModeInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 916				; 00000394H
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__unwindfunclet$??0CvGlobals@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 980				; 000003d4H
	jmp	??1?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAE@XZ
__unwindfunclet$??0CvGlobals@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1024				; 00000400H
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CvGlobals@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1036				; 0000040cH
	jmp	??1?$vector@PAVCvColorInfo@@V?$allocator@PAVCvColorInfo@@@std@@@std@@QAE@XZ ; std::vector<CvColorInfo *,std::allocator<CvColorInfo *> >::~vector<CvColorInfo *,std::allocator<CvColorInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1052				; 0000041cH
	jmp	??1?$vector@PAVCvPlayerColorInfo@@V?$allocator@PAVCvPlayerColorInfo@@@std@@@std@@QAE@XZ ; std::vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >::~vector<CvPlayerColorInfo *,std::allocator<CvPlayerColorInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1068				; 0000042cH
	jmp	??1?$vector@PAVCvTerrainInfo@@V?$allocator@PAVCvTerrainInfo@@@std@@@std@@QAE@XZ ; std::vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >::~vector<CvTerrainInfo *,std::allocator<CvTerrainInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1084				; 0000043cH
	jmp	??1?$vector@PAVCvYieldInfo@@V?$allocator@PAVCvYieldInfo@@@std@@@std@@QAE@XZ ; std::vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >::~vector<CvYieldInfo *,std::allocator<CvYieldInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1100				; 0000044cH
	jmp	??1?$vector@PAVCvRouteInfo@@V?$allocator@PAVCvRouteInfo@@@std@@@std@@QAE@XZ ; std::vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >::~vector<CvRouteInfo *,std::allocator<CvRouteInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1116				; 0000045cH
	jmp	??1?$vector@PAVCvFeatureInfo@@V?$allocator@PAVCvFeatureInfo@@@std@@@std@@QAE@XZ ; std::vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >::~vector<CvFeatureInfo *,std::allocator<CvFeatureInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1132				; 0000046cH
	jmp	??1?$vector@PAVCvResourceClassInfo@@V?$allocator@PAVCvResourceClassInfo@@@std@@@std@@QAE@XZ ; std::vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >::~vector<CvResourceClassInfo *,std::allocator<CvResourceClassInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1148				; 0000047cH
	jmp	??1?$vector@PAVCvResourceInfo@@V?$allocator@PAVCvResourceInfo@@@std@@@std@@QAE@XZ ; std::vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >::~vector<CvResourceInfo *,std::allocator<CvResourceInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$12:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1164				; 0000048cH
	jmp	??1?$vector@PAVCvBuildInfo@@V?$allocator@PAVCvBuildInfo@@@std@@@std@@QAE@XZ ; std::vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >::~vector<CvBuildInfo *,std::allocator<CvBuildInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$13:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1180				; 0000049cH
	jmp	??1?$vector@PAVCvHandicapInfo@@V?$allocator@PAVCvHandicapInfo@@@std@@@std@@QAE@XZ ; std::vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >::~vector<CvHandicapInfo *,std::allocator<CvHandicapInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$14:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1196				; 000004acH
	jmp	??1?$vector@PAVCvGameSpeedInfo@@V?$allocator@PAVCvGameSpeedInfo@@@std@@@std@@QAE@XZ ; std::vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >::~vector<CvGameSpeedInfo *,std::allocator<CvGameSpeedInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$15:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1212				; 000004bcH
	jmp	??1?$vector@PAVCvTurnTimerInfo@@V?$allocator@PAVCvTurnTimerInfo@@@std@@@std@@QAE@XZ ; std::vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >::~vector<CvTurnTimerInfo *,std::allocator<CvTurnTimerInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$16:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1228				; 000004ccH
	jmp	??1?$vector@PAVCvCivilizationInfo@@V?$allocator@PAVCvCivilizationInfo@@@std@@@std@@QAE@XZ ; std::vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >::~vector<CvCivilizationInfo *,std::allocator<CvCivilizationInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$17:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1252				; 000004e4H
	jmp	??1?$vector@PAVCvMinorCivInfo@@V?$allocator@PAVCvMinorCivInfo@@@std@@@std@@QAE@XZ ; std::vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >::~vector<CvMinorCivInfo *,std::allocator<CvMinorCivInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$18:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1268				; 000004f4H
	jmp	??1?$vector@PAVCvLeaderHeadInfo@@V?$allocator@PAVCvLeaderHeadInfo@@@std@@@std@@QAE@XZ ; std::vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >::~vector<CvLeaderHeadInfo *,std::allocator<CvLeaderHeadInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$19:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1284				; 00000504H
	jmp	??1?$vector@PAVCvProcessInfo@@V?$allocator@PAVCvProcessInfo@@@std@@@std@@QAE@XZ ; std::vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >::~vector<CvProcessInfo *,std::allocator<CvProcessInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$20:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1300				; 00000514H
	jmp	??1?$vector@PAVCvVoteInfo@@V?$allocator@PAVCvVoteInfo@@@std@@@std@@QAE@XZ ; std::vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >::~vector<CvVoteInfo *,std::allocator<CvVoteInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$21:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1316				; 00000524H
	jmp	??1?$vector@PAVCvBuildingClassInfo@@V?$allocator@PAVCvBuildingClassInfo@@@std@@@std@@QAE@XZ ; std::vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >::~vector<CvBuildingClassInfo *,std::allocator<CvBuildingClassInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$22:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1332				; 00000534H
	jmp	??1?$vector@PAVCvUnitClassInfo@@V?$allocator@PAVCvUnitClassInfo@@@std@@@std@@QAE@XZ ; std::vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >::~vector<CvUnitClassInfo *,std::allocator<CvUnitClassInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$23:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1348				; 00000544H
	jmp	??1?$vector@PAVCvSpecialUnitInfo@@V?$allocator@PAVCvSpecialUnitInfo@@@std@@@std@@QAE@XZ ; std::vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >::~vector<CvSpecialUnitInfo *,std::allocator<CvSpecialUnitInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$24:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1364				; 00000554H
	jmp	??1?$vector@PAVCvVoteSourceInfo@@V?$allocator@PAVCvVoteSourceInfo@@@std@@@std@@QAE@XZ ; std::vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >::~vector<CvVoteSourceInfo *,std::allocator<CvVoteSourceInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$25:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1380				; 00000564H
	jmp	??1?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::~vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$26:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1396				; 00000574H
	jmp	??1?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::~vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$27:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1412				; 00000584H
	jmp	??1?$vector@PAVCvGameOptionInfo@@V?$allocator@PAVCvGameOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >::~vector<CvGameOptionInfo *,std::allocator<CvGameOptionInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$28:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1428				; 00000594H
	jmp	??1?$vector@PAVCvMPOptionInfo@@V?$allocator@PAVCvMPOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >::~vector<CvMPOptionInfo *,std::allocator<CvMPOptionInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$29:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1444				; 000005a4H
	jmp	??1?$vector@PAVCvPlayerOptionInfo@@V?$allocator@PAVCvPlayerOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >::~vector<CvPlayerOptionInfo *,std::allocator<CvPlayerOptionInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$30:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1460				; 000005b4H
	jmp	??1?$vector@PAVCvSpecialistInfo@@V?$allocator@PAVCvSpecialistInfo@@@std@@@std@@QAE@XZ ; std::vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >::~vector<CvSpecialistInfo *,std::allocator<CvSpecialistInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$31:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1476				; 000005c4H
	jmp	??1?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::~vector<CvActionInfo *,std::allocator<CvActionInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$32:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1492				; 000005d4H
	jmp	??1?$vector@PAVCvMissionInfo@@V?$allocator@PAVCvMissionInfo@@@std@@@std@@QAE@XZ ; std::vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >::~vector<CvMissionInfo *,std::allocator<CvMissionInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$33:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1508				; 000005e4H
	jmp	??1?$vector@PAVCvControlInfo@@V?$allocator@PAVCvControlInfo@@@std@@@std@@QAE@XZ ; std::vector<CvControlInfo *,std::allocator<CvControlInfo *> >::~vector<CvControlInfo *,std::allocator<CvControlInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$34:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1524				; 000005f4H
	jmp	??1?$vector@PAVCvCommandInfo@@V?$allocator@PAVCvCommandInfo@@@std@@@std@@QAE@XZ ; std::vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >::~vector<CvCommandInfo *,std::allocator<CvCommandInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$35:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1540				; 00000604H
	jmp	??1?$vector@PAVCvAutomateInfo@@V?$allocator@PAVCvAutomateInfo@@@std@@@std@@QAE@XZ ; std::vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >::~vector<CvAutomateInfo *,std::allocator<CvAutomateInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$36:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1556				; 00000614H
	jmp	??1?$vector@PAVCvEraInfo@@V?$allocator@PAVCvEraInfo@@@std@@@std@@QAE@XZ ; std::vector<CvEraInfo *,std::allocator<CvEraInfo *> >::~vector<CvEraInfo *,std::allocator<CvEraInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$37:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1572				; 00000624H
	jmp	??1?$vector@PAVCvHurryInfo@@V?$allocator@PAVCvHurryInfo@@@std@@@std@@QAE@XZ ; std::vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >::~vector<CvHurryInfo *,std::allocator<CvHurryInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$38:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1588				; 00000634H
	jmp	??1?$vector@PAVCvVictoryInfo@@V?$allocator@PAVCvVictoryInfo@@@std@@@std@@QAE@XZ ; std::vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >::~vector<CvVictoryInfo *,std::allocator<CvVictoryInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$39:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1604				; 00000644H
	jmp	??1?$vector@PAVCvSmallAwardInfo@@V?$allocator@PAVCvSmallAwardInfo@@@std@@@std@@QAE@XZ ; std::vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >::~vector<CvSmallAwardInfo *,std::allocator<CvSmallAwardInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$40:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1620				; 00000654H
	jmp	??1?$vector@PAVCvEntityEventInfo@@V?$allocator@PAVCvEntityEventInfo@@@std@@@std@@QAE@XZ ; std::vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >::~vector<CvEntityEventInfo *,std::allocator<CvEntityEventInfo *> >
__unwindfunclet$??0CvGlobals@@QAE@XZ$41:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1636				; 00000664H
	jmp	??1?$vector@PAVCvBaseInfo@@V?$allocator@PAVCvBaseInfo@@@std@@@std@@QAE@XZ ; std::vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >::~vector<CvBaseInfo *,std::allocator<CvBaseInfo *> >
__ehhandler$??0CvGlobals@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvGlobals@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvGlobals@@QAE@XZ ENDP				; CvGlobals::CvGlobals
PUBLIC	?setInfoTypeFromString@CvGlobals@@QAEXPBDH@Z	; CvGlobals::setInfoTypeFromString
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\fstringa.inl
xdata$x	SEGMENT
__unwindtable$?setInfoTypeFromString@CvGlobals@@QAEXPBDH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setInfoTypeFromString@CvGlobals@@QAEXPBDH@Z$0
__ehfuncinfo$?setInfoTypeFromString@CvGlobals@@QAEXPBDH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?setInfoTypeFromString@CvGlobals@@QAEXPBDH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.cpp
xdata$x	ENDS
;	COMDAT ?setInfoTypeFromString@CvGlobals@@QAEXPBDH@Z
_TEXT	SEGMENT
$T307761 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_uiHash$ = 8						; size = 4
_szType$ = 8						; size = 4
_idx$ = 12						; size = 4
?setInfoTypeFromString@CvGlobals@@QAEXPBDH@Z PROC	; CvGlobals::setInfoTypeFromString, COMDAT
; _this$ = ecx

; 6972 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?setInfoTypeFromString@CvGlobals@@QAEXPBDH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 6973 : 	CvAssertMsg(szType, "null info type string");
; 6974 : 	uint uiHash = FString::Hash(szType);

	mov	esi, DWORD PTR _szType$[esp+40]
	push	edi
	mov	edi, ecx
	test	esi, esi
	je	SHORT $LN8@setInfoTyp
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL10@setInfoTyp:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL10@setInfoTyp
	sub	eax, edx
	jmp	SHORT $LN9@setInfoTyp
$LN8@setInfoTyp:
	xor	eax, eax
$LN9@setInfoTyp:
	push	-1
	push	eax
	push	esi
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc

; 6975 : #ifdef _DEBUG
; 6976 : 	InfosMap::const_iterator it = m_infosMap.find(szType);
; 6977 : 	int iExisting = (it!=m_infosMap.end()) ? it->second : -1;
; 6978 : 	CvAssertMsg(iExisting==-1 || iExisting==idx || strcmp(szType ? szType : "", "ERROR")==0, CvString::format("xml info type entry %s already exists", szType).c_str());
; 6979 : 
; 6980 : 	InfosHashMap::const_iterator ith = m_infosHashMap.find(uiHash);
; 6981 : 	iExisting = (ith!=m_infosHashMap.end()) ? ith->second : -1;
; 6982 : 	CvAssertMsg(iExisting==-1 || iExisting==idx || strcmp(szType ? szType : "", "ERROR")==0, CvString::format("xml info type entry %s already exists", szType).c_str());
; 6983 : #endif
; 6984 : 	m_infosMap[szType] = idx;

	push	esi
	lea	ecx, DWORD PTR $T307761[esp+52]
	mov	DWORD PTR _uiHash$[esp+48], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T307761[esp+48]
	push	eax
	lea	ecx, DWORD PTR [edi+980]
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	??A?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@QAEAAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stdext::hash_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
	mov	esi, DWORD PTR _idx$[esp+44]
	lea	ecx, DWORD PTR $T307761[esp+48]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR __$EHRec$[esp+56], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6985 : 	m_infosHashMap[uiHash] = idx;

	lea	ecx, DWORD PTR _uiHash$[esp+44]
	push	ecx
	lea	ecx, DWORD PTR [edi+1024]
	call	??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[]

; 6986 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR [eax], esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setInfoTypeFromString@CvGlobals@@QAEXPBDH@Z$0:
	lea	ecx, DWORD PTR $T307761[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?setInfoTypeFromString@CvGlobals@@QAEXPBDH@Z:
	mov	eax, OFFSET __ehfuncinfo$?setInfoTypeFromString@CvGlobals@@QAEXPBDH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setInfoTypeFromString@CvGlobals@@QAEXPBDH@Z ENDP	; CvGlobals::setInfoTypeFromString
EXTRN	_atexit:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??__EgGlobals@@YAXXZ
text$yc	SEGMENT
??__EgGlobals@@YAXXZ PROC				; `dynamic initializer for 'gGlobals'', COMDAT

; 63   : CvGlobals gGlobals;

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	??0CvGlobals@@QAE@XZ			; CvGlobals::CvGlobals
	push	OFFSET ??__FgGlobals@@YAXXZ		; `dynamic atexit destructor for 'gGlobals''
	call	_atexit
	pop	ecx
	ret	0
??__EgGlobals@@YAXXZ ENDP				; `dynamic initializer for 'gGlobals''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__FgGlobals@@YAXXZ
text$yd	SEGMENT
??__FgGlobals@@YAXXZ PROC				; `dynamic atexit destructor for 'gGlobals'', COMDAT
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	jmp	??1CvGlobals@@UAE@XZ			; CvGlobals::~CvGlobals
??__FgGlobals@@YAXXZ ENDP				; `dynamic atexit destructor for 'gGlobals''
text$yd	ENDS
PUBLIC	?gGlobals@@3VCvGlobals@@A			; gGlobals
_BSS	SEGMENT
?gGlobals@@3VCvGlobals@@A DB 0217cH DUP (?)		; gGlobals
_BSS	ENDS
CRT$XCU	SEGMENT
_gGlobals$initializer$ DD FLAT:??__EgGlobals@@YAXXZ
CRT$XCU	ENDS
END
